================================ System Message ================================


    You are a supervisor agent in a multi-agent system focused on identifying hardware security vulnerabilities in RTL code. 
    Your objective is to analyze the given SoC and generate a detailed security report.

    You have access to the following tools: ['run_anomaly_detector_agent', 'run_verilator_agent', 'run_llm_cwe_checker_agent', 'run_assertions_checker_agent', 'run_linter_agent', 'run_similar_bug_agent', 'list_dir', 'read_file', 'read_file_with_line_numbers']. Each tool specializes in a specific task:

    - Verilator Agent: Runs Verilator tests on the given IP and analyzes failing test reports to detect potential security issues.
    - Assertion Agent: Takes a Verilog file, a top module name, and a security aspect to check. It generates and runs security assertions on the RTL. Failing assertions indicate potential issues that require further localization.
    - Linter Agent: Accepts a Verilog file, top module, and security focus. It selects relevant lint checks and flags design violations tied to security concerns.
    - CWE Agent: Given a Verilog file, a top module, and a security aspect, this agent maps the RTL code to relevant CWEs and detects CWE-related vulnerabilities.
    - Similar Bug Agent: Accepts a file path and a line number (where a bug was found) to locate similar patterns or recurring bugs throughout the RTL code.

    Instructions for analysis:

    - Read the documentataion to identify security features and register interfaces policies.
    - Use Verilator, Assertion, Anomaly and Linter agents to uncover initial issues in the design.
    - If a bug is detected but not localized, use the CWE Agent to further inspect the related security aspect in the surrounding RTL.
    - After detecting any bugs, use the Similar Bug Agent to scan similar files (of the same or of different IPs) for similar vulnerabilities.

    Output Format:

    - For each identified issue, report:
    - File name
    - Line number(s)
    - Brief description of the issue
    - Security aspect affected
    - Tools used to identify the issue

    When your analysis is complete, end your response with "END".
    
================================ Human Message =================================

Identify security issues in the kmac IP of the OpenTitan SoC, located at /home/XXXX-2/hackdate.

    - All IPs are located in the 'hw/ip' directory.
    - RTL code for each IP is located in its 'rtl' subdirectory, with source files having the '.sv' extension.
        - reg_top files contain the register interface for the IP.
        - control/fsm files contain the control logic for the IP.
        - core files contain the core logic for the IP.
    - Documentation files (.md) are located in the 'doc' directories of each IP.
        - theory_of_operation explains the properties of the IP and its security features.
        - registers.md files contain the register interface and its read/write access policies.
    - Ignore '.core' files; they are used by build tools and are not relevant for security analysis.

    Focus on the kmac IP and make sure to analyze it thoroughly.

    First, identify the relevant security properties and read/write policies of the register interfaces from the documentation. 
    Then, use all available tools to perform a comprehensive security analysis on the RTL code.
    
================================== Ai Message ==================================
Tool Calls:
  list_dir (call_j73hQpodf6RwrOcQQ9ymPptb)
 Call ID: call_j73hQpodf6RwrOcQQ9ymPptb
  Args:
    dir_path: /home/XXXX-2/hackdate/hw/ip/kmac/doc
================================= Tool Message =================================
Name: list_dir

Files in /home/XXXX-2/hackdate/hw/ip/kmac/doc:
application-interface.svg checklist.md interfaces.md keccak-round.svg kmac-block-diagram.svg kmac-padding.svg programmers_guide.md registers.md sha3-padding-fsm.svg sha3-padding.svg theory_of_operation.md

Directories in /home/XXXX-2/hackdate/hw/ip/kmac/doc:

================================== Ai Message ==================================
Tool Calls:
  read_file (call_CFIyXLwCyeD4eW5F8FellBC3)
 Call ID: call_CFIyXLwCyeD4eW5F8FellBC3
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/kmac/doc/theory_of_operation.md
================================= Tool Message =================================
Name: read_file

# Theory of Operation

## Block Diagram

![](../doc/kmac-block-diagram.svg)

The above figure shows the KMAC/SHA3 HWIP block diagram.
The KMAC has register interfaces for SW to configure the module, initiate the hashing process, and acquire the result digest from the STATE memory region.
It also has an interface to the KeyMgr to get the secret key (masked).
The IP has N x [application interfaces](#application-interface), which allows other HWIPs to request any pre-defined hashing operations.

As similar with HMAC, KMAC HWIP also has a message FIFO (MSG_FIFO) whose depth was determined based on a few criteria such as the register interface width, and its latency, the latency of hashing algorithm (Keccak).
Based on the given criteria, the MSG_FIFO depth was determined to store the incoming message while the SHA3 core is in computation.

The MSG_FIFO has a packer in front.
It packs any partial writes into the size of internal datapath (64bit) and stores in MSG_FIFO.
It frees the software from having to align the messages.
It also doesn't need the message length information.

The fed messages go into the KMAC core regardless of KMAC enabled or not.
The KMAC core forwards the messages to SHA3 core in case KMAC hash functionality is disabled.
KMAC core prepends the encoded secret key as described in the SHA3 Derived Functions specification.
It is expected that the software writes the encoded output length at the end of the message.
For hashing operations triggered by an IP through the application interface, the encoded output length is appended inside the AppIntf module in the KMAC HWIP.

The SHA3 core is the main Keccak processing module.
It supports SHA3 hashing functions, SHAKE128, SHAKE256 extended output functions, and also cSHAKE128, cSHAKE256 functions in order to support KMAC operation.
To support multiple hashing functions, it has the padding logic inside.
The padding logic mainly pads the predefined bits at the end of the message and also performs `pad10*1()` function.
If cSHAKE mode is set, the padding logic also prepends the encoded function name `N` and the customization string `S` prior to the incoming messages according to the spec requirements.

Both the internal state width and the masking of the Keccak core are configurable via compile-time Verilog parameters.
By default, 1600 bits of internal state are used and stored in two shares (1st order masking).
The masked Keccak core takes 4 clock cycles per round if sufficient entropy is available.
If desired, the masking can be disabled and the internal state width can be reduced to 25, 50, or 100 bits at compile time.

## Design Details

### Keccak Round

A Keccak round implements the Keccak_f function described in the SHA3 specification.
Keccak round logic in KMAC/SHA3 HWIP not only supports 1600 bit internal states but also all possible values {50, 100, 200, 400, 800, 1600} based on a parameter `Width`.
If masking is disabled via compile-time Verilog parameter `EnMasking`, also 25 can be selected as state width.
Keccak permutations in the specification allow arbitrary number of rounds.
This module, however, supports Keccak_f which always runs `12 + 2*L` rounds, where $$ L = log_2 {( {Width \over 25} )} $$ .
For instance, 200 bits of internal state run 18 rounds.
KMAC/SHA3 instantiates the Keccak round module with 1600 bit.

![](../doc/keccak-round.svg)

Keccak round logic has two phases inside.
Theta, Rho, Pi functions are executed at the 1st phase.
Chi and Iota functions run at the 2nd phase.
If the compile-time Verilog parameter `EnMasking` is not set, i.e., if masking is not enabled, the first phase and the second phase run at the same cycle.

If masking is enabled, the Keccak round logic stores the intermediate state after processing the 1st phase.
The stored values are then fed into the 2nd phase computing the Chi and Iota functions.
The Chi function leverages first-order [Domain-Oriented Masking (DOM)](XXXX) to deter SCA attacks.

To balance circuit area and SCA hardening, the Chi function uses 800 instead 1600 DOM multipliers but the multipliers are fully pipelined.
The Chi and Iota functions are thus separately applied to the two halves of the state and the 2nd phase takes in total three clock cycles to complete.
In the first clock cycle of the 2nd phase, the first stage of Chi is computed for the first lane halves of the state.
In the second clock cycle, the new first lane halves are output and written to state register.
At the same time, the first stage of Chi is computed for the second lane halves.
In the third clock cycle, the new second lane halves are output and written to the state register.

The 800 DOM multipliers need 800 bits of fresh entropy for remasking.
If fresh entropy is not available, the DOM multipliers do not move forward and the 2nd phase will take more than three clock cycles.
Processing a Keccak_f (1600 bit state) takes a total of 96 cycles (24 rounds X 4 cycles/round) including the 1st and 2nd phases.

If the masking compile time option is enabled, Keccak round logic requires an additional 3200 flip flops to store the intermediate half state inside the 800 DOM multipliers.
In addition to that Keccak round logic needs two sets of the same Theta, Rho, and Pi functions.
As a result, the masked Keccak round logic takes more than twice as much as area than the unmasked version of it.

### Padding for Keccak

Padding logic supports SHA3/SHAKE/cSHAKE algorithms.
cSHAKE needs the extra inputs for the Function-name `N` and the Customization string `S`.
Other than that, SHA3, SHAKE, and cSHAKE share similar datapath inside the padding module except the last part added next to the end of the message.
SHA3 adds `2'b 10`, SHAKE adds `4'b 1111`, cSHAKE adds `2'b00` then `pad10*1()` follows.
All are little-endian values.

Interface between this padding logic and the MSG_FIFO follows the conventional FIFO interface.
So `prim_fifo_*` can talk to the padding logic directly.
This module talks to Keccak round logic with a more memory-like interface.
The interface has an additional address signal on top of the valid, ready, and data signals.

![](../doc/sha3-padding.svg)

The hashing process begins when the software issues the start command to [`CMD`](registers.md#cmd) .
If cSHAKE is enabled, the padding logic expands the prefix value (`N || S` above) into a block size.
The block size is determined by the [`CFG_SHADOWED.kstrength`](registers.md#cfg_shadowed) .
If the value is 128, the block size will be 168 bytes.
If it is 256, the block size will be 136 bytes.
The expanded prefix value is transmitted to the Keccak round logic.
After sending the block size, the padding logic triggers the Keccak round logic to run a full 24 rounds.

If the mode is not cSHAKE, or cSHAKE mode and the prefix block has been processed, the padding logic accepts the incoming message bitstream and forward the data to the Keccak round logic in a block granularity.
The padding logic controls the data flow and makes the Keccak logic to run after sending a block size.

After the software writes the message bitstream, it should issue the Process command into [`CMD`](registers.md#cmd) register.
The padding logic, after receiving the Process command, appends proper ending bits with respect to the [`CFG_SHADOWED.mode`](registers.md#cfg_shadowed) value.
The logic writes 0 up to the block size to the Keccak round logic then ends with 1 at the end of the block.

![](../doc/sha3-padding-fsm.svg)

After the Keccak round completes the last block, the padding logic asserts an `absorbed` signal to notify the software.
The signal generates the `kmac_done` interrupt.
At this point, the software is able to read the digest in [`STATE`](registers.md#state) memory region.
If the output length is greater than the Keccak block rate in SHAKE and cSHAKE mode, the software may run the Keccak round manually by issuing Run command to [`CMD`](registers.md#cmd) register.

The software completes the operation by issuing Done command after reading the digest.
The padding logic clears internal variables and goes back to Idle state.

### Padding for KMAC

![](../doc/kmac-padding.svg)

KMAC core prepends and appends additional bitstream on top of Keccak padding logic in SHA3 core.
The [NIST SP 800-185](XXXX) defines `KMAC[128,256](K, X, L, S)` as a cSHAKE function.
See the section 4.3 in NIST SP 800-185 for details.
If KMAC is enabled, the software should configure [`CMD.mode`](registers.md#cmd) to cSHAKE and the first six bytes of [`PREFIX`](registers.md#prefix) to `0x01204B4D4143` (bigendian).
The first six bytes of [`PREFIX`](registers.md#prefix) represents the value of `encode_string("KMAC")`.

The KMAC padding logic prepends a block containing the encoded secret key to the output message.
The KMAC first sends the block of secret key then accepts the incoming message bitstream.
At the end of the message, the software writes `right_encode(output_length)` to MSG_FIFO prior to issue Process command.

### Message FIFO

The KMAC HWIP has a compile-time configurable depth message FIFO inside.
The message FIFO receives incoming message bitstream regardless of its byte position in a word.
Then it packs the partial message bytes into the internal 64 bit data width.
After packing the data, the logic stores the data into the FIFO until the internal KMAC/SHA3 engine consumes the data.

#### FIFO Depth calculation

The depth of the message FIFO is chosen to cover the throughput of the software or other producers such as DMA engine.
The size of the message FIFO is enough to hold the incoming data while the SHA3 engine is processing the previous block.
Details are in `kmac_pkg::MsgFifoDepth` parameter.
Default design parameters assume the system characteristics as below:

- `kmac_pkg::RegLatency`: The register write takes 5 cycles.
- `kmac_pkg::Sha3Latency`: Keccak round latency takes 96 cycles, which is the masked version of the Keccak round.

#### FIFO Depth and Empty status

If the SW is slow and the SHA3 engine pops the data fast enough, the Message FIFO's depth may remain **0**.
The Message FIFO's `fifo_empty` status bit, however, is lowered for a cycle.

However, if the SHA3 engine is currently busy or if the KMAC block is waiting for fresh entropy from EDN, the Message FIFO may actually run full (indicated by the `fifo_full` status bit).
Resolving these conditions may take hundreds of cycles or more.
After the SHA3 engine starts popping the data again, the Message FIFO will eventually run empty again and the `fifo_empty` status interrupt will fire.
Note that the `fifo_empty` status interrupt will not fire if i) one of the hardware application interfaces is using the KMAC block, ii) the SHA3 core is not in the `Absorb` state, or iii) after software has written the `Process` command.

The recommended approach for software to write messages is:

1. Check the FIFO depth [`STATUS.fifo_depth`](registers.md#status). This represents the number of entry slots currently occupied in the FIFO.
2. Calculate the remaining size as `<max number of fifo entries> - <STATUS.fifo_depth>) * <entry size>`.
3. Write data to fill the remaining size.
4. Repeat until all data is written.
   In case the FIFO runs full (check [`STATUS.fifo_full`](registers.md#status)), software can optionally wait for the `fifo_empty` status interrupt before continuing.

In code, this looks something like:
```c
/**
 * Absorb input data into the Keccak computation.
 *
 * Assumes that the KMAC block is in the "absorb" state; it is the caller's
 * responsibility to check before calling.
 *
 * @param in Input buffer.
 * @param in_len Length of input buffer (bytes).
 * @return Number of bytes written.
 */
size_t kmac_absorb(const uint8_t *in, size_t in_len) {
    // Read FIFO depth from the status register.
    uint32_t status = abs_mmio_read32(kBase + KMAC_STATUS_REG_OFFSET);
    uint32_t fifo_depth =
        bitfield_field32_read(status, KMAC_STATUS_FIFO_DEPTH_FIELD);

    // Calculate the remaining space in the FIFO using auto-generated KMAC
    // parameters and take the minimum of that space and the input length.
    size_t free_entries = (KMAC_PARAM_NUM_ENTRIES_MSG_FIFO - fifo_depth);
    size_t max_len = free_entries * KMAC_PARAM_NUM_BYTES_MSG_FIFO_ENTRY;
    size_t write_len = (in_len < max_len) ? in_len : max_len;

    // Note: this example uses byte-writes for simplicity, but in practice it
    // would be more efficient to use word-writes for aligned full words and
    // byte-writes only as needed at the beginning and end of the input.
    for (size_t i = 0; i < write_len; i++) {
      abs_mmio_write8(kBase + KMAC_MSG_FIFO_REG_OFFSET, in[i]);
    }

    return write_len;
}
```

The method recommended above is always safe.
However, in specific contexts, it may be okay to skip polling `STATUS.fifo_depth`.
Normally, KMAC will process data faster than software can write it, and back pressure on the FIFO interface, should ensure that writes from software will simply block until KMAC can process messages.
The only reason for polling, then, is to prevent a specific deadlock scenario:
1. Software has configured KMAC to wait forever for entropy.
2. There is a problem with the EDN, so entropy is never coming.
3. The FIFO is full and KMAC is waiting for entropy to process it.

If either the entropy wait timer is nonzero or `kmac_en` is false (so KMAC will not be refreshing entropy), it is safe to write to the FIFO without polling `STATUS.fifo_depth`.
However, this should be done carefully, and tests should always cover the scenario in which EDN is locked up.

#### Masking

The message FIFO does not generate the masked message data.
Incoming message bitstream is not sensitive to the leakage.
If the `EnMasking` parameter is set and [`CFG_SHADOWED.msg_mask`](registers.md#cfg_shadowed) is enabled, the message is masked upon loading into the Keccak core using the internal entropy generator.
The secret key, however, is stored as masked form always.

If the `EnMasking` parameter is not set, the masking is disabled.
Then, the software has to provide the key in unmasked form by default.
Any write operations to [`KEY_SHARE1_0`](registers.md#key_share1) - [`KEY_SHARE1_15`](registers.md#key_share1) are ignored.

If the `EnMasking` parameter is not set and the `SwKeyMasked` parameter is set, software has to provide the key in masked form.
Internally, the design then unmasks the key by XORing the two key shares together when loading the key into the engine.
This is useful when software interface compatibility between the masked and unmasked configuration is desirable.

If the `EnMasking` parameter is set, the `SwKeyMasked` parameter has no effect: Software always provides the key in two shares.

### Keccak State Access

After the Keccak round completes the KMAC/SHA3 operation, the contents of the Keccak state contain the digest value.
The software can access the 1600 bit of the Keccak state directly through the window of the KMAC/SHA3 register.

If the compile-time parameter masking feature is enabled, the upper 256B of the window is the second share of the Keccak state.
If not, the upper address space is zero value.
The software reads both of the Keccak state shares and XORed in the software to get the unmasked digest value if masking feature is set.

The Keccak state is valid after the sponge absorbing process is completed.
While in an idle state or in the sponge absorbing stage, the value is zero.
This ensures that the logic does not expose the secret key XORed with the keccak_f results of the prefix to the software.
In addition to that, the KMAC/SHA3 blocks the software access to the Keccak state when it processes the request from KeyMgr for Key Derivation Function (KDF).

### Application Interface

![](../doc/application-interface.svg)

KMAC/SHA3 HWIP has an option to receive the secret key from the KeyMgr via sideload key interface.
The software should set [`CFG_SHADOWED.sideload`](registers.md#cfg_shadowed) to use the KeyMgr sideloaded key for the SW-initiated KMAC operation.
`keymgr_pkg::hw_key_t` defines the structure of the sideloaded key.
KeyMgr provides the sideloaded key in two-share masked form regardless of the compile-time parameter `EnMasking`.
If `EnMasking` is not defined, the KMAC merges the shared key to the unmasked form before uses the key.

The IP has N number of the application interface. The apps connected to the KMAC IP may initiate the SHA3/cSHAKE/KMAC hashing operation via the application interface `kmac_pkg::app_{req|rsp}_t`.
The type of the hashing operation is determined in the compile-time parameter `kmac_pkg::AppCfg`.

| Index | App      | Algorithm | Prefix
|:-----:|:--------:|:---------:|------------
| 0     | KeyMgr   | KMAC      | CSR prefix
| 1     | LC_CTRL  | cSHAKE128 | "LC_CTRL"
| 2     | ROM_CTRL | cSHAKE256 | "ROM_CTRL"

In the current version of IP, the IP has three application interfaces, which are KeyMgr, LC_CTRL, and ROM_CTRL.
KeyMgr uses the KMAC operation with CSR prefix value.
LC_CTRL and ROM_CTRL use the cSHAKE operation with the compile-time parameter prefixes.

The app sends 64-bit data (`MsgWidth`) in a beat with the message strobe signal.
The state machine inside the AppIntf logic starts when it receives the first valid data from any of the AppIntf.
The AppIntf module chooses the winner based on the fixed priority.
Then it forwards the selected App to the next stage.
Because this logic sees the first valid data as an initiator, the Apps cannot run the hashing operation with an empty message.
After the logic switches to accept the message bitstream from the selected App, if the hashing operation is KMAC, the logic forces the sideloaded key to be used as a secret.
Also it ignores the command issued from the software.
Instead it generates the commands and sends them to the KMAC core.

The last beat of the App data moves the state machine to append the encoded output length if the hashing operation is KMAC.
The output length is the digest width, which is 256 bit always.
It means that the logic appends `0x020100` (little-endian) to the end of the message.
The output data from this logic goes to MSG_FIFO.
Because the MSG_FIFO handles un-aligned data inside, KeyMgr interface logic sends the encoded output length value in a separate beat.

After the encoded output length is pushed to the KMAC core, the interface logic issues a Process command to run the hashing logic.

After hashing operation is completed, KMAC does not raise a `kmac_done` interrupt; rather it triggers the `done` status in the App response channel.
The result digest always comes in two shares.
If the `EnMasking` parameter is not set, the second share is always zero.

### Entropy Generator

This section explains the entropy generator inside the KMAC HWIP.

KMAC has an entropy generator to provide the design with pseudo-random numbers while processing the secret key block.
The entropy is used for both remasking the DOM multipliers inside the Chi function of the Keccak core as well as for masking the message if [`CFG_SHADOWED.msg_mask`](registers.md#cfg_shadowed) is enabled.

The entropy generator is constructed using a [heavily unrolled Bivium stream cipher primitive](XXXX).
This allows the module to generate 800 bits of fresh, pseudo-random numbers required by the 800 DOM multipliers for remasking in every clock cycle.

Depending on [`CFG_SHADOWED.entropy_mode`](registers.md#cfg_shadowed), the entropy generator fetches initial entropy from the [Entropy Distribution Network (EDN)][edn] module or software has to provide a seed by writing the [`ENTROPY_SEED`](registers.md#entropy_seed) register 9 times.
The module periodically refreshes the PRNG seed with fresh entropy from EDN.
Software can explicitly request a complete reseed of the PRNG state from EDN through [`CMD.entropy_req`](registers.md#cmd).

[edn]: ../../edn/README.md

### Error Report

This section explains the errors KMAC HWIP raises during the hashing operations, their meanings, and the error handling process.

KMAC HWIP has the error checkers in its internal datapath.
If the checkers detect errors, whether they are triggered by the SW mis-configure, or HW malfunctions, they report the error to [`ERR_CODE`](registers.md#err_code) and raise an `kmac_error` interrupt.
Each error code gives debugging information at the lower 24 bits of [`ERR_CODE`](registers.md#err_code).

Value | Error Code | Description
------|------------|-------------
0x01  | KeyNotValid | In KMAC mode with the sideloaded key, the IP raises an error if the sideloaded secret key is not ready.
0x02  | SwPushedMsgFifo | MsgFifo is updated while not being in the Message Feed state.
0x03  | SwIssuedCmdInAppActive | SW issued a command while the application interface is being used
0x04  | WaitTimerExpired | EDN has not responded within the wait timer limit.
0x05  | IncorrectEntropyMode | When SW sets `entropy_ready`, the `entropy_mode` is neither SW nor EDN.
0x06  | UnexpectedModeStrength | SHA3 mode and Keccak Strength combination is not expected.
0x07  | IncorrectFunctionName | In KMAC mode, the PREFIX has the value other than `encoded_string("KMAC")`
0x08  | SwCmdSequence | SW does not follow the guided sequence, `start` -> `process` -> {`run` ->} `done`
0x09  | SwHashingWithoutEntropyReady | SW requests KMAC op without proper config of Entropy in KMAC. This error occurs if KMAC IP masking feature is enabled.
0x80  | Sha3Control | SW may receive Sha3Control error along with `SwCmdSequence` error. Can be ignored.

#### KeyNotValid (0x01)

The `KeyNotValid` error is raised in the application interface module.
When a KMAC application requests a hashing operation, the module checks if the sideloaded key is ready.
If the key is not ready, the module reports `KeyNotValid` error and moves to dead-end state and waits the IP reset.

This error does not provide any additional information.

#### SwPushedMsgFifo (0x02)

The `SwPushedMsgFifo` error happens when the Message FIFO receives TL-UL transactions while the application interface is busy.
The Message FIFO drops the request.

The IP reports the error with an info field.

Bits    | Name        | Description
--------|-------------|-------------
[23:16] | reserved    | all zero
[15:8]  | kmac_app_st | KMAC_APP FSM state.
[7:0]   | mux_sel     | Current APP Mux selection. 0: None, 1: SW, 2: App

#### SwIssuedCmdInAppActive (0x03)

If the SW issues any commands while the application interface is being used, the module reports `SwIssuedCmdInAppActive` error.
The received command does not affect the Application process.
The request is dropped by the KMAC_APP module.

The lower 3 bits of [`ERR_CODE`](registers.md#err_code) contains the received command from the SW.
#### WaitTimerExpired (0x04)

The timer values set by SW is internally used only when pending EDN request is completed.
Therefore, dynamically changing wait timer cannot be used as a way to poke the timer out of a stalling EDN request.
If a non-zero timer expires, the module cancels the transaction and reports the `WaitTimerExpired` error.

When this error happens, the state machine in KMAC_ENTROPY module moves to Wait state.
In that state, it keeps using the pre-generated entropy and asserting the entropy valid signal.
It asserts the entropy valid signal to complete the current hashing operation.
If the module does not complete, or flush the pending operation, it creates the back pressure to the message FIFO.
Then, the SW may not be able to access the KMAC IP at all, as the crossbar is stuck.

The SW may move the state machine to the reset state by issuing [`CMD.err_processed`](registers.md#cmd).

#### IncorrectEntropyMode (0x05)

If SW misconfigures the entropy mode and let the entropy module prepare the random data, the module reports `IncorrectEntropyMode` error.
The state machine moves to Wait state after reporting the error.

The SW may move the state machine to the reset state by issuing [`CMD.err_processed`](registers.md#cmd).

#### UnexpectedModeStrength (0x06)

When the SW issues `Start` command, the KMAC_ERRCHK module checks the [`CFG_SHADOWED.mode`](registers.md#cfg_shadowed) and [`CFG_SHADOWED.kstrength`](registers.md#cfg_shadowed).
The KMAC HWIP assumes the combinations of two to be **SHA3-224**, **SHA3-256**, **SHA3-384**, **SHA3-512**, **SHAKE-128**, **SHAKE-256**, **cSHAKE-128**, and **cSHAKE-256**.
If the combination of the `mode` and `kstrength` does not fall into above, the module reports the `UnexpectedModeStrength` error.

However, the KMAC HWIP proceeds the hashing operation as other combinations does not cause any malfunctions inside the IP.
The SW may get the incorrect digest value.

#### IncorrectFunctionName (0x07)

If [`CFG_SHADOWED.kmac_en`](registers.md#cfg_shadowed) is set and the SW issues the `Start` command, the KMAC_ERRCHK checks if the [`PREFIX`](registers.md#prefix) has correct function name, `encode_string("KMAC")`.
If the value does not match to the byte form of `encode_string("KMAC")` (`0x4341_4D4B_2001`), it reports the `IncorrectFunctionName` error.

As same as `UnexpectedModeStrength` error, this error does not block the hashing operation.
The SW may get the incorrect signature value.

#### SwCmdSequence (0x08)

The KMAC_ERRCHK module checks the SW issued commands if it follows the guideline.
If the SW issues the command that is not relevant to the current context, the module reports the `SwCmdSequence` error.
The lower 3bits of the [`ERR_CODE`](registers.md#err_code) contains the received command.

This error, however, does not stop the KMAC HWIP.
The incorrect command is dropped at the following datapath, SHA3 core.

================================== Ai Message ==================================
Tool Calls:
  read_file (call_iTMF64hl4i2mJ6MUg28kxAqk)
 Call ID: call_iTMF64hl4i2mJ6MUg28kxAqk
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/kmac/doc/registers.md
================================= Tool Message =================================
Name: read_file

# Registers

<!-- BEGIN CMDGEN util/regtool.py -d ./hw/ip/kmac/data/kmac.hjson -->
## Summary

| Name                                                                             | Offset   |   Length | Description                                              |
|:---------------------------------------------------------------------------------|:---------|---------:|:---------------------------------------------------------|
| kmac.[`INTR_STATE`](#intr_state)                                                 | 0x0      |        4 | Interrupt State Register                                 |
| kmac.[`INTR_ENABLE`](#intr_enable)                                               | 0x4      |        4 | Interrupt Enable Register                                |
| kmac.[`INTR_TEST`](#intr_test)                                                   | 0x8      |        4 | Interrupt Test Register                                  |
| kmac.[`ALERT_TEST`](#alert_test)                                                 | 0xc      |        4 | Alert Test Register                                      |
| kmac.[`CFG_REGWEN`](#cfg_regwen)                                                 | 0x10     |        4 | Controls the configurability of !!CFG_SHADOWED register. |
| kmac.[`CFG_SHADOWED`](#cfg_shadowed)                                             | 0x14     |        4 | KMAC Configuration register.                             |
| kmac.[`CMD`](#cmd)                                                               | 0x18     |        4 | KMAC/ SHA3 command register.                             |
| kmac.[`STATUS`](#status)                                                         | 0x1c     |        4 | KMAC/SHA3 Status register.                               |
| kmac.[`ENTROPY_PERIOD`](#entropy_period)                                         | 0x20     |        4 | Entropy Timer Periods.                                   |
| kmac.[`ENTROPY_REFRESH_HASH_CNT`](#entropy_refresh_hash_cnt)                     | 0x24     |        4 | Entropy Refresh Counter                                  |
| kmac.[`ENTROPY_REFRESH_THRESHOLD_SHADOWED`](#entropy_refresh_threshold_shadowed) | 0x28     |        4 | Entropy Refresh Threshold                                |
| kmac.[`ENTROPY_SEED`](#entropy_seed)                                             | 0x2c     |        4 | Entropy Seed                                             |
| kmac.[`KEY_SHARE0_0`](#key_share0)                                               | 0x30     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_1`](#key_share0)                                               | 0x34     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_2`](#key_share0)                                               | 0x38     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_3`](#key_share0)                                               | 0x3c     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_4`](#key_share0)                                               | 0x40     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_5`](#key_share0)                                               | 0x44     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_6`](#key_share0)                                               | 0x48     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_7`](#key_share0)                                               | 0x4c     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_8`](#key_share0)                                               | 0x50     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_9`](#key_share0)                                               | 0x54     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_10`](#key_share0)                                              | 0x58     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_11`](#key_share0)                                              | 0x5c     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_12`](#key_share0)                                              | 0x60     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_13`](#key_share0)                                              | 0x64     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_14`](#key_share0)                                              | 0x68     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_15`](#key_share0)                                              | 0x6c     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE1_0`](#key_share1)                                               | 0x70     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_1`](#key_share1)                                               | 0x74     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_2`](#key_share1)                                               | 0x78     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_3`](#key_share1)                                               | 0x7c     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_4`](#key_share1)                                               | 0x80     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_5`](#key_share1)                                               | 0x84     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_6`](#key_share1)                                               | 0x88     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_7`](#key_share1)                                               | 0x8c     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_8`](#key_share1)                                               | 0x90     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_9`](#key_share1)                                               | 0x94     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_10`](#key_share1)                                              | 0x98     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_11`](#key_share1)                                              | 0x9c     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_12`](#key_share1)                                              | 0xa0     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_13`](#key_share1)                                              | 0xa4     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_14`](#key_share1)                                              | 0xa8     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_15`](#key_share1)                                              | 0xac     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_LEN`](#key_len)                                                       | 0xb0     |        4 | Secret Key length in bit.                                |
| kmac.[`PREFIX_0`](#prefix)                                                       | 0xb4     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`PREFIX_1`](#prefix)                                                       | 0xb8     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`PREFIX_2`](#prefix)                                                       | 0xbc     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`PREFIX_3`](#prefix)                                                       | 0xc0     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`PREFIX_4`](#prefix)                                                       | 0xc4     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`PREFIX_5`](#prefix)                                                       | 0xc8     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`PREFIX_6`](#prefix)                                                       | 0xcc     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`PREFIX_7`](#prefix)                                                       | 0xd0     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`PREFIX_8`](#prefix)                                                       | 0xd4     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`PREFIX_9`](#prefix)                                                       | 0xd8     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`PREFIX_10`](#prefix)                                                      | 0xdc     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`ERR_CODE`](#err_code)                                                     | 0xe0     |        4 | KMAC/SHA3 Error Code                                     |
| kmac.[`STATE`](#state)                                                           | 0x400    |      512 | Keccak State (1600 bit) memory.                          |
| kmac.[`MSG_FIFO`](#msg_fifo)                                                     | 0x800    |     2048 | Message FIFO.                                            |

## INTR_STATE
Interrupt State Register
- Offset: `0x0`
- Reset default: `0x0`
- Reset mask: `0x7`

### Fields

```wavejson
{"reg": [{"name": "kmac_done", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"name": "fifo_empty", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "kmac_err", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 120}}
```

|  Bits  |  Type  |  Reset  | Name                                  |
|:------:|:------:|:-------:|:--------------------------------------|
|  31:3  |        |         | Reserved                              |
|   2    |  rw1c  |   0x0   | [kmac_err](#intr_state--kmac_err)     |
|   1    |   ro   |   0x0   | [fifo_empty](#intr_state--fifo_empty) |
|   0    |  rw1c  |   0x0   | [kmac_done](#intr_state--kmac_done)   |

### INTR_STATE . kmac_err
KMAC/SHA3 error occurred. ERR_CODE register shows the details

### INTR_STATE . fifo_empty
The message FIFO is empty.
This interrupt is raised only if the message FIFO is actually writable by software, i.e., if all of the following conditions are met:
i) The KMAC block is not exercised by a hardware application interface.
ii) The SHA3 block is in the Absorb state.
iii) Software has not yet written the Process command to finish the absorption process.
For the interrupt to be raised, the message FIFO must also have been full previously.
Otherwise, the hardware empties the FIFO faster than software can fill it and there is no point in interrupting the software to inform it about the message FIFO being empty.

### INTR_STATE . kmac_done
KMAC/SHA3 absorbing has been completed

## INTR_ENABLE
Interrupt Enable Register
- Offset: `0x4`
- Reset default: `0x0`
- Reset mask: `0x7`

### Fields

```wavejson
{"reg": [{"name": "kmac_done", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "fifo_empty", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "kmac_err", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 120}}
```

|  Bits  |  Type  |  Reset  | Name       | Description                                                          |
|:------:|:------:|:-------:|:-----------|:---------------------------------------------------------------------|
|  31:3  |        |         |            | Reserved                                                             |
|   2    |   rw   |   0x0   | kmac_err   | Enable interrupt when [`INTR_STATE.kmac_err`](#intr_state) is set.   |
|   1    |   rw   |   0x0   | fifo_empty | Enable interrupt when [`INTR_STATE.fifo_empty`](#intr_state) is set. |
|   0    |   rw   |   0x0   | kmac_done  | Enable interrupt when [`INTR_STATE.kmac_done`](#intr_state) is set.  |

## INTR_TEST
Interrupt Test Register
- Offset: `0x8`
- Reset default: `0x0`
- Reset mask: `0x7`

### Fields

```wavejson
{"reg": [{"name": "kmac_done", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "fifo_empty", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "kmac_err", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 120}}
```

|  Bits  |  Type  |  Reset  | Name       | Description                                                   |
|:------:|:------:|:-------:|:-----------|:--------------------------------------------------------------|
|  31:3  |        |         |            | Reserved                                                      |
|   2    |   wo   |   0x0   | kmac_err   | Write 1 to force [`INTR_STATE.kmac_err`](#intr_state) to 1.   |
|   1    |   wo   |   0x0   | fifo_empty | Write 1 to force [`INTR_STATE.fifo_empty`](#intr_state) to 1. |
|   0    |   wo   |   0x0   | kmac_done  | Write 1 to force [`INTR_STATE.kmac_done`](#intr_state) to 1.  |

## ALERT_TEST
Alert Test Register
- Offset: `0xc`
- Reset default: `0x0`
- Reset mask: `0x3`

### Fields

```wavejson
{"reg": [{"name": "recov_operation_err", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "fatal_fault_err", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 30}], "config": {"lanes": 1, "fontsize": 10, "vspace": 210}}
```

|  Bits  |  Type  |  Reset  | Name                | Description                                      |
|:------:|:------:|:-------:|:--------------------|:-------------------------------------------------|
|  31:2  |        |         |                     | Reserved                                         |
|   1    |   wo   |   0x0   | fatal_fault_err     | Write 1 to trigger one alert event of this kind. |
|   0    |   wo   |   0x0   | recov_operation_err | Write 1 to trigger one alert event of this kind. |

## CFG_REGWEN
Controls the configurability of [`CFG_SHADOWED`](#cfg_shadowed) register.

This register ensures the contents of [`CFG_SHADOWED`](#cfg_shadowed) register cannot be
changed by the software while the KMAC/SHA3 is in operation mode.
- Offset: `0x10`
- Reset default: `0x1`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "en", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description           |
|:------:|:------:|:-------:|:-------|:----------------------|
|  31:1  |        |         |        | Reserved              |
|   0    |   ro   |   0x1   | en     | Configuration enable. |

## CFG_SHADOWED
KMAC Configuration register.

This register is  updated when the hashing engine is in Idle.
If the software updates the register while the engine computes, the
updated value will be discarded.
- Offset: `0x14`
- Reset default: `0x0`
- Reset mask: `0x51b133f`
- Register enable: [`CFG_REGWEN`](#cfg_regwen)

### Fields

```wavejson
{"reg": [{"name": "kmac_en", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "kstrength", "bits": 3, "attr": ["rw"], "rotate": -90}, {"name": "mode", "bits": 2, "attr": ["rw"], "rotate": -90}, {"bits": 2}, {"name": "msg_endianness", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "state_endianness", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 2}, {"name": "sideload", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 3}, {"name": "entropy_mode", "bits": 2, "attr": ["rw"], "rotate": -90}, {"bits": 1}, {"name": "entropy_fast_process", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "msg_mask", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 3}, {"name": "entropy_ready", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 1}, {"name": "en_unsupported_modestrength", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 5}], "config": {"lanes": 1, "fontsize": 10, "vspace": 290}}
```

|  Bits  |  Type  |  Reset  | Name                                                                      |
|:------:|:------:|:-------:|:--------------------------------------------------------------------------|
| 31:27  |        |         | Reserved                                                                  |
|   26   |   rw   |   0x0   | [en_unsupported_modestrength](#cfg_shadowed--en_unsupported_modestrength) |
|   25   |        |         | Reserved                                                                  |
|   24   |   rw   |   0x0   | [entropy_ready](#cfg_shadowed--entropy_ready)                             |
| 23:21  |        |         | Reserved                                                                  |
|   20   |   rw   |   0x0   | [msg_mask](#cfg_shadowed--msg_mask)                                       |
|   19   |   rw   |   0x0   | [entropy_fast_process](#cfg_shadowed--entropy_fast_process)               |
|   18   |        |         | Reserved                                                                  |
| 17:16  |   rw   |   0x0   | [entropy_mode](#cfg_shadowed--entropy_mode)                               |
| 15:13  |        |         | Reserved                                                                  |
|   12   |   rw   |   0x0   | [sideload](#cfg_shadowed--sideload)                                       |
| 11:10  |        |         | Reserved                                                                  |
|   9    |   rw   |   0x0   | [state_endianness](#cfg_shadowed--state_endianness)                       |
|   8    |   rw   |   0x0   | [msg_endianness](#cfg_shadowed--msg_endianness)                           |
|  7:6   |        |         | Reserved                                                                  |
|  5:4   |   rw   |   0x0   | [mode](#cfg_shadowed--mode)                                               |
|  3:1   |   rw   |   0x0   | [kstrength](#cfg_shadowed--kstrength)                                     |
|   0    |   rw   |   0x0   | [kmac_en](#cfg_shadowed--kmac_en)                                         |

### CFG_SHADOWED . en_unsupported_modestrength
Enable Unsupported Mode and Strength configs.

SW may set this field for KMAC to move forward with unsupported
Keccak Mode and Strength configurations, such as cSHAKE512.

If not set, KMAC won't propagate the SW command (CmdStart) to the
rest of the blocks (AppIntf, KMAC Core, SHA3).

### CFG_SHADOWED . entropy_ready
Entropy Ready status.

Software sets this field to allow the entropy generator in KMAC to
fetch the entropy and run.

### CFG_SHADOWED . msg_mask
Message Masking with PRNG.

If 1, KMAC applies PRNG to the input messages to the Keccak module
when KMAC mode is on.

### CFG_SHADOWED . entropy_fast_process
Entropy Fast process mode.

If 1, entropy logic uses garbage data while not processing the KMAC
key block. It will re-use previous entropy value and will not
expand the entropy when it is consumed. Only it refreshes the
entropy while processing the secret key block. This process should
not be used if SCA resistance is required because it may cause side
channel leakage.

### CFG_SHADOWED . entropy_mode
Entropy Mode

Using this field, software can configure mode of operation of the internal pseudo-random number generator (PRNG).
For the hardware to actually switch to an entropy mode other than the default idle_mode, software further needs to set the [`CFG_SHADOWED.entropy_ready`](#cfg_shadowed) bit.
After that point, the hardware cannot be made to return to idle_mode unless the module is reset.

| Value   | Name      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|:--------|:----------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0x0     | idle_mode | Default mode after reset. The sole purpose of this mode is to enable ROM_CTRL operation right after coming out of reset. The internal PRNG is not reseeded with fresh entropy, nor updated while the core operates. It should therefore not be used after this very initial stage. Software should setup a different mode and set !!CFG_SHADOWED.entropy_ready as early as possible. The module cannot be made to return to idle_mode once any of the other modes have been used.                                                                                                                                                                                                                                                                                       |
| 0x1     | edn_mode  | Receive fresh entropy from EDN for reseeding the internal PRNG. This entropy mode is to be used for regular operation. Once the !!CFG_SHADOWED.entropy_ready bit is set after reset, the module requests fresh entropy from EDN for reseeding the internal PRNG. Only after that, the module can start processing commands. Depending on !!CFG_SHADOWED, the internal PRNG is then used for (re-)masking inputs (prefix, key, message) and intermediate results of the Keccak core. Depending on !!ENTROPY_PERIOD, the module will periodically reseed the internal PRNG with fresh entropy from EDN. Using !!CMD.entropy_req software can manually initiate the reseeding.                                                                                             |
| 0x2     | sw_mode   | Receive initial entropy from software for reseeding the internal PRNG. This entropy mode is a fall-back option to be used if the entropy complex is not available. Once the !!CFG_SHADOWED.entropy_ready bit is set after reset, the module will wait for software to write each of the !!ENTROPY_SEED_0 - !!ENTROPY_SEED_4 registers exactly once and in ascending order. Only after that, the module can start processing commands. Depending on !!CFG_SHADOWED, the internal PRNG is then used for (re-)masking inputs (prefix, key, message) and intermediate results of the Keccak core. After this point, the PRNG can no longer be reseeded by software - also after switching back into this mode from edn_mode. However, it is possible to switch to edn_mode. |

Other values are reserved.

### CFG_SHADOWED . sideload
Sideloaded Key.

If 1, KMAC uses KeyMgr sideloaded key for SW initiated KMAC
operation. KMAC uses the sideloaded key regardless of this
configuration when KeyMgr initiates the KMAC operation for
Key Derivation Function (KDF).

### CFG_SHADOWED . state_endianness
State Endianness.

If 1 then each individual word in the [`STATE`](#state) output register
is converted to big-endian byte order.
The order of the words in relation to one another is not
changed.
This setting does not affect how the state is interpreted
during computation.

### CFG_SHADOWED . msg_endianness
Message Endianness.

If 1 then each individual multi-byte value, regardless of its
alignment, written to [`MSG_FIFO`](#msg_fifo) will be added to the message
in big-endian byte order.
If 0, each value will be added to the message in little-endian
byte order.
A message written to [`MSG_FIFO`](#msg_fifo) one byte at a time will not be
affected by this setting.
From a hardware perspective byte swaps are performed on a TL-UL
word granularity.

### CFG_SHADOWED . mode
Keccak hashing mode.

This module supports SHA3 main hashing algorithm and the part
of its derived functions, SHAKE and cSHAKE with limitations.
This field is to select the mode.

| Value   | Name   | Description                                              |
|:--------|:-------|:---------------------------------------------------------|
| 0x0     | SHA3   | SHA3 hashing mode. It appends `2'b 10` to the end of msg |
| 0x2     | SHAKE  | SHAKE hashing mode. It appends `1111` to the end of msg  |
| 0x3     | cSHAKE | cSHAKE hashing mode. It appends `00` to the end of msg   |

Other values are reserved.

### CFG_SHADOWED . kstrength
Hashing Strength

3 bit field to select the security strength of SHA3 hashing
engine. If mode field is set to SHAKE or cSHAKE, only 128 and
256 strength can be selected. Other value will result error
when hashing starts.

| Value   | Name   | Description                               |
|:--------|:-------|:------------------------------------------|
| 0x0     | L128   | 128 bit strength. Keccak rate is 1344 bit |
| 0x1     | L224   | 224 bit strength. Keccak rate is 1152 bit |
| 0x2     | L256   | 256 bit strength. Keccak rate is 1088 bit |
| 0x3     | L384   | 384 bit strength. Keccak rate is 832 bit  |
| 0x4     | L512   | 512 bit strength. Keccak rate is 576 bit  |

Other values are reserved.

### CFG_SHADOWED . kmac_en
KMAC datapath enable.

If this bit is 1, the incoming message is processed in KMAC
with the secret key.

## CMD
KMAC/ SHA3 command register.

This register is to control the KMAC to start accepting message,
to process the message, and to manually run additional keccak
rounds at the end. Only at certain stage, the CMD affects to the
control logic. It follows the sequence of

`start` --> `process` --> {`run` if needed --> } `done`
- Offset: `0x18`
- Reset default: `0x0`
- Reset mask: `0x73f`

### Fields

```wavejson
{"reg": [{"name": "cmd", "bits": 6, "attr": ["r0w1c"], "rotate": 0}, {"bits": 2}, {"name": "entropy_req", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"name": "hash_cnt_clr", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"name": "err_processed", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"bits": 21}], "config": {"lanes": 1, "fontsize": 10, "vspace": 150}}
```

|  Bits  |  Type  |  Reset  | Name                                 |
|:------:|:------:|:-------:|:-------------------------------------|
| 31:11  |        |         | Reserved                             |
|   10   | r0w1c  |    x    | [err_processed](#cmd--err_processed) |
|   9    | r0w1c  |    x    | [hash_cnt_clr](#cmd--hash_cnt_clr)   |
|   8    | r0w1c  |    x    | [entropy_req](#cmd--entropy_req)     |
|  7:6   |        |         | Reserved                             |
|  5:0   | r0w1c  |    x    | [cmd](#cmd--cmd)                     |

### CMD . err_processed
When error occurs and one of the state machine stays at
 Error handling state, SW may process the error based on
 ERR_CODE, then let FSM back to the reset state

### CMD . hash_cnt_clr
If writes 1, it clears the hash (KMAC) counter in the entropy module

### CMD . entropy_req
SW triggered Entropy Request

If writes 1 to this field

### CMD . cmd
Issue a command to the KMAC/SHA3 IP. The command is sparse
encoded. To prevent sw from writing multiple commands at once,
the field is defined as enum.

| Value   | Name    | Description                                                                                                                                                                                                                                                                                                                 |
|:--------|:--------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0x1d    | start   | Writing 6'b011101 or dec 29 into this field when KMAC/SHA3 is in idle, KMAC/SHA3 begins its operation. If the mode is cSHAKE, before receiving the message, the hashing logic processes Function name string N and customization input string S first. If KMAC mode is enabled, additionally it processes secret key block. |
| 0x2e    | process | Writing 6'b101110 or dec 46 into this field when KMAC/SHA3 began its operation and received the entire message, it computes the digest or signing.                                                                                                                                                                          |
| 0x31    | run     | The `run` field is used in the sponge squeezing stage. It triggers the keccak round logic to run full 24 rounds. This is optional and used when software needs more digest bits than the keccak rate. It only affects when the kmac/sha3 operation is completed.                                                            |
| 0x16    | done    | Writing 6'b010110 or dec 22 into this field when KMAC/SHA3 squeezing is completed, KMAC/SHA3 hashing engine clears internal variables and goes back to Idle state for next command.                                                                                                                                         |

Other values are reserved.

## STATUS
KMAC/SHA3 Status register.
- Offset: `0x1c`
- Reset default: `0x4001`
- Reset mask: `0x3df07`

### Fields

```wavejson
{"reg": [{"name": "sha3_idle", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "sha3_absorb", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "sha3_squeeze", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 5}, {"name": "fifo_depth", "bits": 5, "attr": ["ro"], "rotate": -90}, {"bits": 1}, {"name": "fifo_empty", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "fifo_full", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "ALERT_FATAL_FAULT", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "ALERT_RECOV_CTRL_UPDATE_ERR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 14}], "config": {"lanes": 1, "fontsize": 10, "vspace": 290}}
```

|  Bits  |  Type  |  Reset  | Name                                                                |
|:------:|:------:|:-------:|:--------------------------------------------------------------------|
| 31:18  |        |         | Reserved                                                            |
|   17   |   ro   |   0x0   | [ALERT_RECOV_CTRL_UPDATE_ERR](#status--alert_recov_ctrl_update_err) |
|   16   |   ro   |   0x0   | [ALERT_FATAL_FAULT](#status--alert_fatal_fault)                     |
|   15   |   ro   |    x    | [fifo_full](#status--fifo_full)                                     |
|   14   |   ro   |   0x1   | [fifo_empty](#status--fifo_empty)                                   |
|   13   |        |         | Reserved                                                            |
|  12:8  |   ro   |    x    | [fifo_depth](#status--fifo_depth)                                   |
|  7:3   |        |         | Reserved                                                            |
|   2    |   ro   |    x    | [sha3_squeeze](#status--sha3_squeeze)                               |
|   1    |   ro   |    x    | [sha3_absorb](#status--sha3_absorb)                                 |
|   0    |   ro   |   0x1   | [sha3_idle](#status--sha3_idle)                                     |

### STATUS . ALERT_RECOV_CTRL_UPDATE_ERR
An update error has not occurred (0) or has occured (1) in the shadowed Control Register.
KMAC operation needs to be restarted by re-writing the Control Register.

### STATUS . ALERT_FATAL_FAULT
No fatal fault has occurred inside the KMAC unit (0).
A fatal fault has occured and the KMAC unit needs to be reset (1),
Examples for such faults include
i) TL-UL bus integrity fault
ii) storage errors in the shadow registers
iii) errors in the message, round, or key counter
iv) any internal FSM entering an invalid state
v) an error in the redundant lfsr

### STATUS . fifo_full
Message FIFO Full indicator

### STATUS . fifo_empty
Message FIFO Empty indicator.

The FIFO's `Pass` parameter is set to `1'b 1`. So, by default, if
the SHA engine is ready, the write data to FIFO just passes
through.

In this case, `fifo_depth` remains **0**. `fifo_empty`, however,
lowers the value to **0** for a cycle, then goes back to the empty
state, **1**.

See the "Message FIFO" section in the spec for the reason.

### STATUS . fifo_depth
Count of occupied entries in the message FIFO.

### STATUS . sha3_squeeze
If 1, SHA3 completes sponge absorbing stage.
In this stage, SW can manually run the hashing engine.

### STATUS . sha3_absorb
If 1, SHA3 is receiving message stream and processing it

### STATUS . sha3_idle
If 1, SHA3 hashing engine is in idle state.

## ENTROPY_PERIOD
Entropy Timer Periods.
- Offset: `0x20`
- Reset default: `0x0`
- Reset mask: `0xffff03ff`
- Register enable: [`CFG_REGWEN`](#cfg_regwen)

### Fields

```wavejson
{"reg": [{"name": "prescaler", "bits": 10, "attr": ["rw"], "rotate": 0}, {"bits": 6}, {"name": "wait_timer", "bits": 16, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                                      |
|:------:|:------:|:-------:|:------------------------------------------|
| 31:16  |   rw   |   0x0   | [wait_timer](#entropy_period--wait_timer) |
| 15:10  |        |         | Reserved                                  |
|  9:0   |   rw   |   0x0   | [prescaler](#entropy_period--prescaler)   |

### ENTROPY_PERIOD . wait_timer
EDN request wait timer.

The entropy module in KMAC waits up to this field in the timer pulse
after it sends request to EDN module. If the timer expires, the
entropy module moves to an error state and notifies to the system.

If there is a pending EDN request during wait timer update, then this update is delayed until the EDN request is complete.

If 0, the entropy module waits the EDN response always. If EDN does
not respond in this configuration, the software shall reset the IP.

### ENTROPY_PERIOD . prescaler
EDN Wait timer prescaler.

EDN Wait timer has 16 bit value. The timer value is increased when the timer pulse is generated. Timer pulse is raises when the number of the clock cycles hit this prescaler value.

The exact period of the timer pulse is unknown as the KMAC input clock may contain jitters.

## ENTROPY_REFRESH_HASH_CNT
Entropy Refresh Counter

KMAC entropy can be refreshed after the given threshold KMAC operations
run. If the KMAC hash counter [`ENTROPY_REFRESH_HASH_CNT`](#entropy_refresh_hash_cnt) hits (GTE) the
configured threshold [`ENTROPY_REFRESH_THRESHOLD_SHADOWED`](#entropy_refresh_threshold_shadowed), the entropy
module in the KMAC IP requests new seed to EDN and reset the KMAC
hash counter.

If the threshold is 0, the refresh by the counter does not work. And the
counter is only reset by the CMD.hash_cnt_clr CSR bit.
- Offset: `0x24`
- Reset default: `0x0`
- Reset mask: `0x3ff`
- Register enable: [`CFG_REGWEN`](#cfg_regwen)

### Fields

```wavejson
{"reg": [{"name": "hash_cnt", "bits": 10, "attr": ["ro"], "rotate": 0}, {"bits": 22}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name     | Description         |
|:------:|:------:|:-------:|:---------|:--------------------|
| 31:10  |        |         |          | Reserved            |
|  9:0   |   ro   |   0x0   | hash_cnt | Hash (KMAC) counter |

## ENTROPY_REFRESH_THRESHOLD_SHADOWED
Entropy Refresh Threshold

KMAC entropy can be refreshed after the given threshold KMAC operations
run. If the KMAC hash counter [`ENTROPY_REFRESH_HASH_CNT`](#entropy_refresh_hash_cnt) hits (GTE) the
configured threshold [`ENTROPY_REFRESH_THRESHOLD_SHADOWED`](#entropy_refresh_threshold_shadowed), the entropy
module in the KMAC IP requests new seed to EDN and reset the KMAC
hash counter.

If the threshold is 0, the refresh by the counter does not work. And the
counter is only reset by the CMD.hash_cnt_clr CSR bit.
- Offset: `0x28`
- Reset default: `0x0`
- Reset mask: `0x3ff`
- Register enable: [`CFG_REGWEN`](#cfg_regwen)

### Fields

```wavejson
{"reg": [{"name": "threshold", "bits": 10, "attr": ["rw"], "rotate": 0}, {"bits": 22}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name      | Description    |
|:------:|:------:|:-------:|:----------|:---------------|
| 31:10  |        |         |           | Reserved       |
|  9:0   |   rw   |   0x0   | threshold | Hash Threshold |

## ENTROPY_SEED
Entropy Seed

Entropy seed register for the integrated entropy generator.

If [`CFG_SHADOWED.entropy_mode`](#cfg_shadowed) is set to sw_mode, software first needs to set [`CFG_SHADOWED.entropy_ready.`](#cfg_shadowed)
Then, software needs to write the [`ENTROPY_SEED`](#entropy_seed) register 9 times.
Upon each write, the written value is loaded into the corresponding state chunk of the entropy generator.

After writing the [`ENTROPY_SEED`](#entropy_seed) register 9 times, the entropy generator will start its operation.
After this point, writing this register has no longer any effect.
- Offset: `0x2c`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "seed", "bits": 32, "attr": ["wo"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                                |
|:------:|:------:|:-------:|:-------|:-------------------------------------------|
|  31:0  |   wo   |    x    | seed   | 32-bit chunk of the entropy generator seed |

## KEY_SHARE0
KMAC Secret Key

KMAC secret key can be up to 512 bit.
Order of the secret key is:
key[512:0] = {KEY15, KEY14, ... , KEY0};

The registers are allowed to be updated when the engine is in Idle state.
If the engine computes the hash, it discards any attempts to update the secret keys
and report an error.

Current KMAC supports up to 512 bit secret key. It is the sw
responsibility to keep upper bits of the secret key to 0.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name          | Offset   |
|:--------------|:---------|
| KEY_SHARE0_0  | 0x30     |
| KEY_SHARE0_1  | 0x34     |
| KEY_SHARE0_2  | 0x38     |
| KEY_SHARE0_3  | 0x3c     |
| KEY_SHARE0_4  | 0x40     |
| KEY_SHARE0_5  | 0x44     |
| KEY_SHARE0_6  | 0x48     |
| KEY_SHARE0_7  | 0x4c     |
| KEY_SHARE0_8  | 0x50     |
| KEY_SHARE0_9  | 0x54     |
| KEY_SHARE0_10 | 0x58     |
| KEY_SHARE0_11 | 0x5c     |
| KEY_SHARE0_12 | 0x60     |
| KEY_SHARE0_13 | 0x64     |
| KEY_SHARE0_14 | 0x68     |
| KEY_SHARE0_15 | 0x6c     |


### Fields

```wavejson
{"reg": [{"name": "key", "bits": 32, "attr": ["wo"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                              |
|:------:|:------:|:-------:|:-------|:-----------------------------------------|
|  31:0  |   wo   |    x    | key    | 32-bit chunk of up-to 512-bit Secret Key |

## KEY_SHARE1
KMAC Secret Key, 2nd share.

KMAC secret key can be up to 512 bit.
Order of the secret key is:
key[512:0] = {KEY15, KEY14, ... , KEY0};

The registers are allowed to be updated when the engine is in Idle state.
If the engine computes the hash, it discards any attempts to update the secret keys
and report an error.

Current KMAC supports up to 512 bit secret key. It is the sw
responsibility to keep upper bits of the secret key to 0.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name          | Offset   |
|:--------------|:---------|
| KEY_SHARE1_0  | 0x70     |
| KEY_SHARE1_1  | 0x74     |
| KEY_SHARE1_2  | 0x78     |
| KEY_SHARE1_3  | 0x7c     |
| KEY_SHARE1_4  | 0x80     |
| KEY_SHARE1_5  | 0x84     |
| KEY_SHARE1_6  | 0x88     |
| KEY_SHARE1_7  | 0x8c     |
| KEY_SHARE1_8  | 0x90     |
| KEY_SHARE1_9  | 0x94     |
| KEY_SHARE1_10 | 0x98     |
| KEY_SHARE1_11 | 0x9c     |
| KEY_SHARE1_12 | 0xa0     |
| KEY_SHARE1_13 | 0xa4     |
| KEY_SHARE1_14 | 0xa8     |
| KEY_SHARE1_15 | 0xac     |


### Fields

```wavejson
{"reg": [{"name": "key", "bits": 32, "attr": ["wo"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                              |
|:------:|:------:|:-------:|:-------|:-----------------------------------------|
|  31:0  |   wo   |    x    | key    | 32-bit chunk of up-to 512-bit Secret Key |

## KEY_LEN
Secret Key length in bit.

This value is used to make encoded secret key in KMAC.
KMAC supports certain lengths of the secret key. Currently it
supports 128b, 192b, 256b, 384b, and 512b secret keys.
- Offset: `0xb0`
- Reset default: `0x0`
- Reset mask: `0x7`
- Register enable: [`CFG_REGWEN`](#cfg_regwen)

### Fields

```wavejson
{"reg": [{"name": "len", "bits": 3, "attr": ["wo"], "rotate": 0}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                 |
|:------:|:------:|:-------:|:---------------------|
|  31:3  |        |         | Reserved             |
|  2:0   |   wo   |   0x0   | [len](#key_len--len) |

### KEY_LEN . len
Key length choice

| Value   | Name   | Description            |
|:--------|:-------|:-----------------------|
| 0x0     | Key128 | Key length is 128 bit. |
| 0x1     | Key192 | Key length is 192 bit. |
| 0x2     | Key256 | Key length is 256 bit. |
| 0x3     | Key384 | Key length is 384 bit. |
| 0x4     | Key512 | Key length is 512 bit. |

Other values are reserved.

## PREFIX
cSHAKE Prefix register.

Prefix including Function Name N and Customization String S.
The SHA3 assumes this register value is encoded as:
`encode_string(N) || encode_string(S) || 0`. It means that the
software can freely decide the length of N or S based on the
given Prefix register size 320bit. 320bit is determined to have
32-bit of N and up to 256-bit of S + encode of their length.

It is SW responsibility to fill the register with encoded value
that is described at Section 2.3.2 String Encoding in NIST SP
800-185 specification.

Order of Prefix is:
prefix[end:0] := {PREFIX(N-1), ..., PREFIX(1), PREFIX(0) }

The registers are allowed to be updated when the engine is in Idle state.
If the engine computes the hash, it discards any attempts to update the secret keys
and report an error.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name      | Offset   |
|:----------|:---------|
| PREFIX_0  | 0xb4     |
| PREFIX_1  | 0xb8     |
| PREFIX_2  | 0xbc     |
| PREFIX_3  | 0xc0     |
| PREFIX_4  | 0xc4     |
| PREFIX_5  | 0xc8     |
| PREFIX_6  | 0xcc     |
| PREFIX_7  | 0xd0     |
| PREFIX_8  | 0xd4     |
| PREFIX_9  | 0xd8     |
| PREFIX_10 | 0xdc     |


### Fields

```wavejson
{"reg": [{"name": "prefix", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                       |
|:------:|:------:|:-------:|:-------|:----------------------------------|
|  31:0  |   rw   |   0x0   | prefix | 32-bit chunk of Encoded NS Prefix |

## ERR_CODE
KMAC/SHA3 Error Code
- Offset: `0xe0`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "err_code", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                            |
|:------:|:------:|:-------:|:--------------------------------|
|  31:0  |   ro   |   0x0   | [err_code](#err_code--err_code) |

### ERR_CODE . err_code
If the `kmac_err` interrupt occurs, this register has information on the error cause.
Bits 31:24 contain the error code (please refer to `err_code_e` in `hw/ip/kmac/rtl/kmac_pkg.sv`) for the encoding, and bits 23:0 contain additional debug information.
This register does *not* get cleared when the `kmac_err` interrupt state gets cleared.

## STATE
Keccak State (1600 bit) memory.

The software can get the processed digest by reading this memory
region. Unlike MSG_FIFO, STATE memory space sees the addr[9:0].
If Masking feature is enabled, the software reads two shares from
this memory space.

0x400 - 0x4C7: State share
0x500 - 0x5C7: Mask share of the state, 0 if EnMasking = 0

- Word Aligned Offset Range: `0x400`to`0x5fc`
- Size (words): `128`
- Access: `ro`
- Byte writes are *not* supported.

## MSG_FIFO
Message FIFO.

Any write operation to this window will be appended to MSG_FIFO. SW can
simply write bytes/words to any address within this address range.
Ordering and packing of the incoming bytes/words are handled
internally. Therefore, the least significant 12 bits of the address
are ignored.

- Word Aligned Offset Range: `0x800`to`0xffc`
- Size (words): `512`
- Access: `wo`
- Byte writes are  supported.


<!-- END CMDGEN -->

================================== Ai Message ==================================
Tool Calls:
  list_dir (call_cDTePXvsbNqLWlZnGtfALqGe)
 Call ID: call_cDTePXvsbNqLWlZnGtfALqGe
  Args:
    dir_path: /home/XXXX-2/hackdate/hw/ip/kmac/rtl
================================= Tool Message =================================
Name: list_dir

Files in /home/XXXX-2/hackdate/hw/ip/kmac/rtl:
keccak_2share.sv keccak_round.sv kmac.sv kmac_app.sv kmac_core.sv kmac_entropy.sv kmac_errchk.sv kmac_msgfifo.sv kmac_pkg.sv kmac_reduced.sv kmac_reg_pkg.sv kmac_reg_top.sv kmac_staterd.sv sha3.sv sha3_pkg.sv sha3pad.sv

Directories in /home/XXXX-2/hackdate/hw/ip/kmac/rtl:

================================== Ai Message ==================================
Tool Calls:
  run_verilator_agent (call_vQ3qGje7Frrd6tx2Jy6V7y0l)
 Call ID: call_vQ3qGje7Frrd6tx2Jy6V7y0l
  Args:
    ip: kmac
================================ Human Message =================================

Run a security analysis on the kmac IP.

    Inspect the logs of failing runs and determine if there are security issues in the RTL.
    If any security issues are found, provide a detailed explanation of the issue and its location in the RTL code.
================================== Ai Message ==================================

[{'text': "I'll run a security analysis on the kmac IP by executing its verilator tests and examining any failing tests for potential security issues.", 'type': 'text'}, {'id': 'toolu_014ExWaj549E72aXHaWEx18g', 'input': {'ip': 'kmac'}, 'name': 'run_verilator_tests', 'type': 'tool_use'}]
Tool Calls:
  run_verilator_tests (toolu_014ExWaj549E72aXHaWEx18g)
 Call ID: toolu_014ExWaj549E72aXHaWEx18g
  Args:
    ip: kmac
================================= Tool Message =================================
Name: run_verilator_tests

 8 processes: 12 local.
FAILED: Build did NOT complete successfully
//sw/device/lib/dif:kmac_unittest                               (cached) PASSED in 0.2s
//sw/device/silicon_creator/lib/drivers:kmac_functest_sim_qemu_rom_with_fake_keys (cached) PASSED in 3.0s
//sw/device/silicon_creator/lib/drivers:kmac_unittest           (cached) PASSED in 0.2s
//sw/device/tests:kmac_endianess_test_sim_qemu_rom_with_fake_keys (cached) PASSED in 3.1s
//sw/device/tests:kmac_mode_cshake_test_sim_qemu_rom_with_fake_keys (cached) PASSED in 3.3s
//sw/device/tests:kmac_mode_kmac_test_sim_qemu_rom_with_fake_keys (cached) PASSED in 3.1s
//sw/device/tests:kmac_smoketest_sim_qemu_rom_with_fake_keys    (cached) PASSED in 2.9s
//sw/device/tests/crypto:kdf_kmac_functest_sim_qemu_rom_with_fake_keys (cached) PASSED in 3.4s
//sw/device/tests/crypto:kmac_functest_hardcoded_sim_qemu_rom_with_fake_keys (cached) PASSED in 3.2s
//sw/device/tests:clkmgr_off_kmac_trans_test_silicon_creator          NO STATUS
//sw/device/tests:clkmgr_off_kmac_trans_test_sim_verilator            NO STATUS
//sw/device/tests:keymgr_sideload_kmac_test_silicon_creator           NO STATUS
//sw/device/tests:keymgr_sideload_kmac_test_sim_verilator             NO STATUS
//sw/device/tests:kmac_app_rom_test_sim_verilator_sim_verilator       NO STATUS
//sw/device/tests:kmac_endianess_test_silicon_creator                 NO STATUS
//sw/device/tests:kmac_endianess_test_sim_verilator                   NO STATUS
//sw/device/tests:kmac_entropy_test_sim_verilator                     NO STATUS
//sw/device/tests:kmac_error_conditions_test_sim_verilator            NO STATUS
//sw/device/tests:kmac_idle_test_silicon_creator                      NO STATUS
//sw/device/tests:kmac_idle_test_sim_verilator                        NO STATUS
//sw/device/tests:kmac_kmac_key_sideload_test_silicon_creator         NO STATUS
//sw/device/tests:kmac_kmac_key_sideload_test_sim_verilator           NO STATUS
//sw/device/tests:kmac_mode_cshake_test_silicon_creator               NO STATUS
//sw/device/tests:kmac_mode_cshake_test_sim_verilator                 NO STATUS
//sw/device/tests:kmac_mode_kmac_test_silicon_creator                 NO STATUS
//sw/device/tests:kmac_mode_kmac_test_sim_verilator                   NO STATUS
//sw/device/tests:kmac_smoketest_silicon_creator                      NO STATUS
//sw/device/tests:kmac_smoketest_sim_verilator                        NO STATUS
//sw/device/tests/crypto:kdf_kmac_functest_sim_verilator              NO STATUS
//sw/device/tests/crypto:kdf_kmac_sideload_functest_hardcoded_sim_verilator NO STATUS
//sw/device/tests/crypto:kmac_functest_hardcoded_sim_verilator        NO STATUS
//sw/device/tests/crypto:kmac_sideload_functest_hardcoded_sim_verilator NO STATUS
//sw/device/silicon_creator/lib/drivers:kmac_functest_sim_verilator FAILED TO BUILD
//sw/device/tests:clkmgr_off_kmac_trans_test_sim_qemu_rom_with_fake_keys FAILED in 5.1s
  /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/clkmgr_off_kmac_trans_test_sim_qemu_rom_with_fake_keys/test.log
//sw/device/tests:keymgr_sideload_kmac_test_sim_qemu_rom_with_fake_keys  FAILED in 3.2s
  /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/keymgr_sideload_kmac_test_sim_qemu_rom_with_fake_keys/test.log
//sw/device/tests:kmac_idle_test_sim_qemu_rom_with_fake_keys             FAILED in 3.0s
  /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/kmac_idle_test_sim_qemu_rom_with_fake_keys/test.log
//sw/device/tests:kmac_kmac_key_sideload_test_sim_qemu_rom_with_fake_keys FAILED in 3.2s
  /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/kmac_kmac_key_sideload_test_sim_qemu_rom_with_fake_keys/test.log
//sw/device/tests/crypto:kdf_kmac_sideload_functest_hardcoded_sim_qemu_rom_with_fake_keys FAILED in 3.0s
  /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/crypto/kdf_kmac_sideload_functest_hardcoded_sim_qemu_rom_with_fake_keys/test.log
//sw/device/tests/crypto:kmac_sideload_functest_hardcoded_sim_qemu_rom_with_fake_keys FAILED in 3.2s
  /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/crypto/kmac_sideload_functest_hardcoded_sim_qemu_rom_with_fake_keys/test.log

Executed 6 out of 39 tests: 9 tests pass, 1 fails to build, 6 fail locally and 23 were skipped.
There were tests whose specified size is too big. Use the --test_verbose_timeout_warnings command line option to see which ones these are.

================================== Ai Message ==================================

[{'text': "I'll examine the logs of the failing tests to identify potential security issues in the KMAC IP. Let me check one of the failing test logs:", 'type': 'text'}, {'id': 'toolu_01SE2dLwR9wyayqiJUsK85UU', 'input': {'file_path': '/home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/kmac_kmac_key_sideload_test_sim_qemu_rom_with_fake_keys/test.log'}, 'name': 'read_file_from_host', 'type': 'tool_use'}]
Tool Calls:
  read_file_from_host (toolu_01SE2dLwR9wyayqiJUsK85UU)
 Call ID: toolu_01SE2dLwR9wyayqiJUsK85UU
  Args:
    file_path: /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/kmac_kmac_key_sideload_test_sim_qemu_rom_with_fake_keys/test.log
================================= Tool Message =================================
Name: read_file_from_host

exec ${PAGER:-/usr/bin/less} "$0" || exit 1
Executing tests from //sw/device/tests:kmac_kmac_key_sideload_test_sim_qemu_rom_with_fake_keys
-----------------------------------------------------------------------------
Invoking test: rules/scripts/qemu_pass -display none -M ot-earlgrey -readconfig sw/device/tests/kmac_kmac_key_sideload_test_sim_qemu_rom_with_fake_keys.ini -object ot-rom_img,id=rom,file=sw/device/silicon_creator/rom/mask_rom_sim_qemu_base.elf -drive if=pflash,file=otp_img.raw,format=raw -drive if=mtd,bus=1,file=flash_img.bin,format=raw -chardev stdio,id=serial0 -serial chardev:serial0 -icount shift=6 -global ot-rstmgr.fatal_reset=1
OpenTitan:4001-0002-01
ROM:00554d51
I00001 ottf_main.c:166] Running sw/device/tests/kmac_kmac_key_sideload_test.c
I00002 keymgr_testutils.c:200] Powered up for the first time, program flash
I00003 keymgr_testutils.c:100] OTP partition locked. Digest: 0-ffa25bbf
I00004 keymgr_testutils.c:210] Requesting a reset to make OTP partitions accessible to keymgr
qemu-system-riscv32: fatal reset triggered

================================== Ai Message ==================================

[{'text': 'Let me check another failing test log:', 'type': 'text'}, {'id': 'toolu_01PH6TWQP1DomfLbxzpUKKrV', 'input': {'file_path': '/home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/crypto/kmac_sideload_functest_hardcoded_sim_qemu_rom_with_fake_keys/test.log'}, 'name': 'read_file_from_host', 'type': 'tool_use'}]
Tool Calls:
  read_file_from_host (toolu_01PH6TWQP1DomfLbxzpUKKrV)
 Call ID: toolu_01PH6TWQP1DomfLbxzpUKKrV
  Args:
    file_path: /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/crypto/kmac_sideload_functest_hardcoded_sim_qemu_rom_with_fake_keys/test.log
================================= Tool Message =================================
Name: read_file_from_host

exec ${PAGER:-/usr/bin/less} "$0" || exit 1
Executing tests from //sw/device/tests/crypto:kmac_sideload_functest_hardcoded_sim_qemu_rom_with_fake_keys
-----------------------------------------------------------------------------
Invoking test: rules/scripts/qemu_pass -display none -M ot-earlgrey -readconfig sw/device/tests/crypto/kmac_sideload_functest_hardcoded_sim_qemu_rom_with_fake_keys.ini -object ot-rom_img,id=rom,file=sw/device/silicon_creator/rom/mask_rom_sim_qemu_base.elf -drive if=pflash,file=otp_img.raw,format=raw -drive if=mtd,bus=1,file=flash_img.bin,format=raw -chardev stdio,id=serial0 -serial chardev:serial0 -icount shift=6 -global ot-rstmgr.fatal_reset=1
OpenTitan:4001-0002-01
ROM:00554d51
I00001 ottf_main.c:166] Running sw/device/tests/crypto/kmac_sideload_functest.c
I00002 keymgr_testutils.c:200] Powered up for the first time, program flash
I00003 keymgr_testutils.c:100] OTP partition locked. Digest: 0-ffa25bbf
I00004 keymgr_testutils.c:210] Requesting a reset to make OTP partitions accessible to keymgr
qemu-system-riscv32: fatal reset triggered

================================== Ai Message ==================================

[{'text': 'Let me check one more failing test log:', 'type': 'text'}, {'id': 'toolu_017UFHUbZx8UXDfZ6w8HCVtP', 'input': {'file_path': '/home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/kmac_idle_test_sim_qemu_rom_with_fake_keys/test.log'}, 'name': 'read_file_from_host', 'type': 'tool_use'}]
Tool Calls:
  read_file_from_host (toolu_017UFHUbZx8UXDfZ6w8HCVtP)
 Call ID: toolu_017UFHUbZx8UXDfZ6w8HCVtP
  Args:
    file_path: /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/kmac_idle_test_sim_qemu_rom_with_fake_keys/test.log
================================= Tool Message =================================
Name: read_file_from_host

exec ${PAGER:-/usr/bin/less} "$0" || exit 1
Executing tests from //sw/device/tests:kmac_idle_test_sim_qemu_rom_with_fake_keys
-----------------------------------------------------------------------------
Invoking test: rules/scripts/qemu_pass -display none -M ot-earlgrey -readconfig sw/device/tests/kmac_idle_test_sim_qemu_rom_with_fake_keys.ini -object ot-rom_img,id=rom,file=sw/device/silicon_creator/rom/mask_rom_sim_qemu_base.elf -drive if=pflash,file=otp_img.raw,format=raw -drive if=mtd,bus=1,file=flash_img.bin,format=raw -chardev stdio,id=serial0 -serial chardev:serial0 -icount shift=6 -global ot-rstmgr.fatal_reset=1
OpenTitan:4001-0002-01
ROM:00554d51
I00001 ottf_main.c:166] Running sw/device/tests/kmac_idle_test.c
E00002 kmac_idle_test.c:57] CHECK-fail: Clock enabled state is not as expected (1).
I00003 status.c:34] FAIL!

================================== Ai Message ==================================

[{'text': 'Let me examine the KMAC RTL code to better understand the potential issues:', 'type': 'text'}, {'id': 'toolu_01AQbKVycgoGy4QB5Gi5TA4M', 'input': {'dir_path': '/home/XXXX-2/lowrisc_opentitan/hw/ip/kmac/rtl'}, 'name': 'list_dir_from_host', 'type': 'tool_use'}]
Tool Calls:
  list_dir_from_host (toolu_01AQbKVycgoGy4QB5Gi5TA4M)
 Call ID: toolu_01AQbKVycgoGy4QB5Gi5TA4M
  Args:
    dir_path: /home/XXXX-2/lowrisc_opentitan/hw/ip/kmac/rtl
================================= Tool Message =================================
Name: list_dir_from_host

Error: ls: cannot access '/home/XXXX-2/lowrisc_opentitan/hw/ip/kmac/rtl': No such file or directory

================================== Ai Message ==================================

[{'text': 'Let me try a different path:', 'type': 'text'}, {'id': 'toolu_0144o25SGMsgm2aUbapPj7Ej', 'input': {'dir_path': '/home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/hw/ip/kmac/rtl'}, 'name': 'list_dir_from_host', 'type': 'tool_use'}]
Tool Calls:
  list_dir_from_host (toolu_0144o25SGMsgm2aUbapPj7Ej)
 Call ID: toolu_0144o25SGMsgm2aUbapPj7Ej
  Args:
    dir_path: /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/hw/ip/kmac/rtl
================================= Tool Message =================================
Name: list_dir_from_host

keccak_2share.sv
keccak_round.sv
kmac_app.sv
kmac_core.sv
kmac_entropy.sv
kmac_errchk.sv
kmac_msgfifo.sv
kmac_pkg.sv
kmac_reduced.sv
kmac_reg_pkg.sv
kmac_reg_top.sv
kmac_staterd.sv
kmac.sv
sha3pad.sv
sha3_pkg.sv
sha3.sv

================================== Ai Message ==================================

[{'text': "Let me look at the failing test code to understand what it's testing:", 'type': 'text'}, {'id': 'toolu_014UVXQBa5qLBVN2PyJjL6s2', 'input': {'file_path': '/home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/sw/device/tests/kmac_idle_test.c'}, 'name': 'read_file_from_host', 'type': 'tool_use'}]
Tool Calls:
  read_file_from_host (toolu_014UVXQBa5qLBVN2PyJjL6s2)
 Call ID: toolu_014UVXQBa5qLBVN2PyJjL6s2
  Args:
    file_path: /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/sw/device/tests/kmac_idle_test.c
================================= Tool Message =================================
Name: read_file_from_host

// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

#include "sw/device/lib/base/mmio.h"
#include "sw/device/lib/dif/dif_clkmgr.h"
#include "sw/device/lib/dif/dif_kmac.h"
#include "sw/device/lib/runtime/ibex.h"
#include "sw/device/lib/runtime/log.h"
#include "sw/device/lib/testing/test_framework/check.h"
#include "sw/device/lib/testing/test_framework/ottf_main.h"

#include "hw/top_earlgrey/sw/autogen/top_earlgrey.h"

static dif_clkmgr_t clkmgr;
static dif_kmac_t kmac;

OTTF_DEFINE_TEST_CONFIG();

const dif_clkmgr_hintable_clock_t kmac_clock =
    kTopEarlgreyHintableClocksMainKmac;

#define TIMEOUT (1000 * 1000)

// Digest lengths in 32-bit words.
#define DIGEST_LEN_SHA3_256 (256 / 32)
#define DIGEST_LEN_SHA3_512 (512 / 32)
#define DIGEST_LEN_SHA3_MAX DIGEST_LEN_SHA3_512

// SHA-3 test description.
typedef struct sha3_test {
  dif_kmac_mode_sha3_t mode;

  const char *message;
  size_t message_len;

  const uint32_t digest[DIGEST_LEN_SHA3_MAX];
  size_t digest_len;
} sha3_test_t;

// SHA-3 test.
const sha3_test_t sha3_256_test = {
    // Example taken from NIST FIPS-202 Algorithm Test Vectors:
    // XXXX
    .mode = kDifKmacModeSha3Len256,
    .message = "\xe7\x37\x21\x05",
    .message_len = 4,
    .digest = {0x8ab6423a, 0x8cf279b0, 0x52c7a34c, 0x90276f29, 0x78fec406,
               0xd979ebb1, 0x057f7789, 0xae46401e},
    .digest_len = DIGEST_LEN_SHA3_256};

static void check_clock_state(dif_toggle_t expected_clock_state) {
  dif_toggle_t clock_state;
  CHECK_DIF_OK(
      dif_clkmgr_hintable_clock_get_enabled(&clkmgr, kmac_clock, &clock_state));
  CHECK(clock_state == expected_clock_state,
        "Clock enabled state is not as expected (%d).", expected_clock_state);
}

static bool is_hintable_clock_enabled(const dif_clkmgr_t *clkmgr,
                                      dif_clkmgr_hintable_clock_t clock) {
  dif_toggle_t clock_state;
  CHECK_DIF_OK(
      dif_clkmgr_hintable_clock_get_enabled(clkmgr, clock, &clock_state));
  return clock_state == kDifToggleEnabled;
}

static void do_sha3_test(void) {
  dif_kmac_operation_state_t kmac_operation_state;
  // Run SHA3 test case using single blocking absorb/squeeze operations.
  CHECK_DIF_OK(dif_kmac_mode_sha3_start(&kmac, &kmac_operation_state,
                                        sha3_256_test.mode));

  // Set hint and check clk state remains enabled as KMAC is now not idle.
  CHECK_DIF_OK(dif_clkmgr_hintable_clock_set_hint(&clkmgr, kmac_clock,
                                                  kDifToggleDisabled));
  check_clock_state(kDifToggleEnabled);

  CHECK_DIF_OK(dif_kmac_absorb(&kmac, &kmac_operation_state,
                               sha3_256_test.message, sha3_256_test.message_len,
                               NULL));

  uint32_t out[DIGEST_LEN_SHA3_MAX];
  CHECK_DIF_OK(dif_kmac_squeeze(&kmac, &kmac_operation_state, out,
                                sha3_256_test.digest_len, /*processed=*/NULL,
                                /*capacity=*/NULL));

  // Check clock state again which should still be enabled.
  check_clock_state(kDifToggleEnabled);

  CHECK_DIF_OK(dif_kmac_end(&kmac, &kmac_operation_state));

  // On FPGA, it may take a while until the DONE command gets actually executed
  // (see SecCmdDelay SystemVerilog parameter). However, once the clock is
  // disabled, KMAC cannot be accessed anymore. Thus polling the KMAC status
  // register doesn't work. Instead, wait for the clock to stop.
  IBEX_SPIN_FOR(!is_hintable_clock_enabled(&clkmgr, kmac_clock), TIMEOUT);

  // Check the clock is now stopped.
  check_clock_state(kDifToggleDisabled);

  // Check the result to be sure the SHA3 operation completed correctly.
  CHECK_ARRAYS_EQ(out, sha3_256_test.digest, sha3_256_test.digest_len,
                  "Digest mismatch for test SHA3 256.");

  // Set hint to enabled again to check that clock can be re-enabled.
  CHECK_DIF_OK(dif_clkmgr_hintable_clock_set_hint(&clkmgr, kmac_clock,
                                                  kDifToggleEnabled));
  check_clock_state(kDifToggleEnabled);
}

bool test_main(void) {
  CHECK_DIF_OK(dif_clkmgr_init(
      mmio_region_from_addr(TOP_EARLGREY_CLKMGR_AON_BASE_ADDR), &clkmgr));

  // Get initial hint and enable for KMAC clock and check both are enabled.
  dif_toggle_t clock_hint_state;
  CHECK_DIF_OK(dif_clkmgr_hintable_clock_get_hint(&clkmgr, kmac_clock,
                                                  &clock_hint_state));
  CHECK(clock_hint_state == kDifToggleEnabled);
  check_clock_state(kDifToggleEnabled);

  // While KMAC is not in use, set disabled hint for KMAC clock
  // then check clock state, set back to enabled and check again.
  // Note: disabled means the clock can be disabled.
  CHECK_DIF_OK(dif_clkmgr_hintable_clock_set_hint(&clkmgr, kmac_clock,
                                                  kDifToggleDisabled));
  check_clock_state(kDifToggleDisabled);
  CHECK_DIF_OK(dif_clkmgr_hintable_clock_set_hint(&clkmgr, kmac_clock,
                                                  kDifToggleEnabled));
  check_clock_state(kDifToggleEnabled);

  // Initialize KMAC hardware.
  CHECK_DIF_OK(
      dif_kmac_init(mmio_region_from_addr(TOP_EARLGREY_KMAC_BASE_ADDR), &kmac));

  // Configure KMAC hardware using software entropy.
  dif_kmac_config_t config = (dif_kmac_config_t){
      .entropy_mode = kDifKmacEntropyModeSoftware,
      .entropy_seed = {0xb153e3fe, 0x09596819, 0x3e85a6e8, 0xb6dcdaba,
                       0x50dc409c, 0x11e1ebd1},
      .entropy_fast_process = kDifToggleEnabled,
  };
  CHECK_DIF_OK(dif_kmac_configure(&kmac, config));

  // call sha3 test twice to check that when clock
  // is enabled again after the first call
  // that all still works for the second call.

  do_sha3_test();
  do_sha3_test();

  return true;
}

================================== Ai Message ==================================

[{'text': 'Let me also look at the KMAC core implementation:', 'type': 'text'}, {'id': 'toolu_01TRzoiuWfgMWDKSARZHL5UE', 'input': {'file_path': '/home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/hw/ip/kmac/rtl/kmac_core.sv'}, 'name': 'read_file_from_host', 'type': 'tool_use'}]
Tool Calls:
  read_file_from_host (toolu_01TRzoiuWfgMWDKSARZHL5UE)
 Call ID: toolu_01TRzoiuWfgMWDKSARZHL5UE
  Args:
    file_path: /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/hw/ip/kmac/rtl/kmac_core.sv
================================= Tool Message =================================
Name: read_file_from_host

// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// KMAC control and padding logic

`include "prim_assert.sv"

module kmac_core
  import kmac_pkg::*;
#(
  // EnMasking: Enable masking security hardening inside keccak_round
  // If it is enabled, the result digest will be two set of 1600bit.
  parameter  bit EnMasking = 0,
  localparam int Share = (EnMasking) ? 2 : 1 // derived parameter
) (
  input clk_i,
  input rst_ni,

  // From Message FIFO
  input                fifo_valid_i,
  input [MsgWidth-1:0] fifo_data_i [Share],
  input [MsgStrbW-1:0] fifo_strb_i,
  output logic         fifo_ready_o,

  // to SHA3 Core
  output logic                msg_valid_o,
  output logic [MsgWidth-1:0] msg_data_o  [Share],
  output logic [MsgStrbW-1:0] msg_strb_o,
  input                       msg_ready_i,

  // Configurations

  // If kmac_en is cleared, Core logic doesn't function but forward incoming
  // message to SHA3 core
  input                             kmac_en_i,
  input sha3_pkg::sha3_mode_e       mode_i,
  input sha3_pkg::keccak_strength_e strength_i,

  // Key input from CSR
  input [MaxKeyLen-1:0] key_data_i [Share],
  input key_len_e       key_len_i,
  input logic           key_valid_i,

  // Controls : same to SHA3 core
  input start_i,
  input process_i,
  input prim_mubi_pkg::mubi4_t done_i,

  // Control to SHA3 core
  output logic process_o,

  // Life cycle
  input  lc_ctrl_pkg::lc_tx_t lc_escalate_en_i,

  output logic sparse_fsm_error_o,
  output logic key_index_error_o
);

  import sha3_pkg::KeccakMsgAddrW;
  import sha3_pkg::KeccakCountW;
  import sha3_pkg::KeccakRate;
  import sha3_pkg::L128;
  import sha3_pkg::L224;
  import sha3_pkg::L256;
  import sha3_pkg::L384;
  import sha3_pkg::L512;

  /////////////////
  // Definitions //
  /////////////////

  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 3 -m 5 -n 6 \
  //      -s 401658243 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: |||||||||||||||||||| (50.00%)
  //  4: |||||||||||||||| (40.00%)
  //  5: |||| (10.00%)
  //  6: --
  //
  // Minimum Hamming distance: 3
  // Maximum Hamming distance: 5
  // Minimum Hamming weight: 1
  // Maximum Hamming weight: 4
  //
  localparam int StateWidth = 6;
  typedef enum logic [StateWidth-1:0] {
    StKmacIdle = 6'b011000,

    // Secret Key pushing stage
    // The key is sliced by prim_slicer. This state pushes the sliced data into
    // SHA3 hashing engine. When it hits the block size limit,
    // (same as in sha3pad) the state machine moves to Message.
    StKey = 6'b010111,

    // Incoming Message
    // The core does nothing but forwarding the incoming message to SHA3 hashing
    // engine by turning off `en_kmac_datapath`.
    StKmacMsg = 6'b001110,

    // Wait till done signal
    StKmacFlush = 6'b101011,

    // Terminal Error
    StTerminalError = 6'b100000
  } kmac_st_e ;

  /////////////
  // Signals //
  /////////////

  // represents encode_string(K)
  logic [MaxEncodedKeyW-1:0] encoded_key [Share];

  // Key slice address
  // This signal controls the 64 bit output of the sliced secret_key.
  logic [sha3_pkg::KeccakMsgAddrW-1:0] key_index;
  logic inc_keyidx, clr_keyidx;

  // `sent_blocksize` indicates that the encoded key is sent to sha3 hashing
  // engine. If this hits at StKey stage, the state moves to message state.
  logic [sha3_pkg::KeccakCountW-1:0] block_addr_limit;
  logic sent_blocksize;

  // Internal message signals
  logic                kmac_valid       ;
  logic [MsgWidth-1:0] kmac_data [Share];
  logic [MsgStrbW-1:0] kmac_strb        ;

  // Control SHA3 core
  // `kmac_process` is to forward the process signal to SHA3 core only after
  // the KMAC core writes the key block in case of the message is empty.
  // If the incoming message is empty, there's chance that the `process_i`
  // signal can be asserted while KMAC core processing the key block.
  logic kmac_process, process_latched;

  // Indication of Secret key write stage. Only in this stage, the internal
  // message interface is active.
  logic en_key_write;
  logic en_kmac_datapath;

  // Encoded key has wider bits. `key_sliced` is the data to send to sha3
  logic [MsgWidth-1:0] key_sliced [Share];

  // The following signals are only used in assertions.
  logic unused_signals;
  assign unused_signals = ^{mode_i, key_valid_i};

  /////////
  // FSM //
  /////////
  kmac_st_e st, st_d;

  // State register
  `PRIM_FLOP_SPARSE_FSM(u_state_regs, st_d, st, kmac_st_e, StKmacIdle)

  // Next state and output logic
  // SEC_CM: FSM.SPARSE
  always_comb begin
    st_d = st;

    en_kmac_datapath = 1'b 0;
    en_key_write = 1'b 0;

    clr_keyidx = 1'b 0;

    kmac_valid = 1'b 0;
    kmac_process = 1'b 0;

    sparse_fsm_error_o = 1'b 0;

    unique case (st)
      StKmacIdle: begin
        if (kmac_en_i && start_i) begin
          st_d = StKey;
        end else begin
          st_d = StKmacIdle;
        end
      end

      // If State enters here, regardless of the `process_i`, the state writes
      // full block size of the key into SHA3 hashing engine.
      StKey: begin
        en_kmac_datapath = 1'b 1;
        en_key_write = 1'b 1;

        if (sent_blocksize) begin
          st_d = StKmacMsg;

          kmac_valid = 1'b 0;
          clr_keyidx = 1'b 1;
        end else begin
          st_d = StKey;

          kmac_valid = 1'b 1;
        end
      end

      StKmacMsg: begin
        // If process is previously latched, it is sent to SHA3 here.
        if (process_i || process_latched) begin
          st_d = StKmacFlush;

          kmac_process = 1'b 1;
        end else begin
          st_d = StKmacMsg;
        end
      end

      StKmacFlush: begin
        if (prim_mubi_pkg::mubi4_test_true_strict(done_i)) begin
          st_d = StKmacIdle;
        end else begin
          st_d = StKmacFlush;
        end
      end

      StTerminalError: begin
        // this state is terminal
        st_d = st;
        sparse_fsm_error_o = 1'b 1;
      end

      default: begin
        // this state is terminal
        st_d = StTerminalError;
        sparse_fsm_error_o = 1'b 1;
      end
    endcase

    // SEC_CM: FSM.GLOBAL_ESC, FSM.LOCAL_ESC
    // Unconditionally jump into the terminal error state
    // if the life cycle controller triggers an escalation.
    if (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) begin
      st_d = StTerminalError;
    end
  end

  //////////////
  // Datapath //
  //////////////

  // DATA Mux depending on kmac_en
  // When Key write happens, hold the FIFO request. so fifo_ready_o is tied to 0
  assign msg_valid_o  = (en_kmac_datapath) ? kmac_valid : fifo_valid_i;
  assign msg_data_o   = (en_kmac_datapath) ? kmac_data  : fifo_data_i ;
  assign msg_strb_o   = (en_kmac_datapath) ? kmac_strb  : fifo_strb_i ;
  assign fifo_ready_o = (en_kmac_datapath) ? 1'b 0      : msg_ready_i ;

  // secret key write request to SHA3 hashing engine is always full width write.
  // KeyMgr is fixed 256 bit output. So `right_encode(256)` is 0x020100 --> strb 3
  assign kmac_strb = (en_key_write ) ? '1 : '0;

  assign kmac_data = (en_key_write) ? key_sliced : '{default:'0};

  // Process is controlled by the KMAC core always.
  // This is mainly to prevent process_i asserted while KMAC core is writing
  // the secret key to SHA3 hashing engine (the empty message case)
  assign process_o = (kmac_en_i) ? kmac_process : process_i ;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      process_latched <= 1'b 0;
    end else if (process_i && !process_o) begin
      process_latched <= 1'b 1;
    end else if (process_o ||
      prim_mubi_pkg::mubi4_test_true_strict(done_i)) begin
      process_latched <= 1'b 0;
    end
  end

  // bytepad(encode_string(K), 168 or 136) =====================================
  // 1. Prepare left_encode(w)
  // 2. Prepare left_encode(len(secret_key))
  // 3. Concatenate left_encode(len(secret_key)) || secret_key
  // 4. Concaatenate left_encode(w) || encode_string(secret_key)
  // 5. Based on the address, slice out the data into MsgWidth bits

  // left_encode(w): Same as used in sha3pad logic.
  logic [15:0] encode_bytepad;
  assign encode_bytepad = sha3_pkg::encode_bytepad_len(strength_i);

  // left_encode(len(secret_key))
  // encoded length is always byte size. Use MaxEncodedKeyLenByte parameter
  // from kmac_pkg and add one more byte to indicate how many bytes used to
  // represent len(secret_key)
  // Note that if the secret_key is 128 bit, only lower 16 bits of
  // `encode_keylen` are valid. Refer `encoded_key` concatenation logic below.
  // As the encoded string in the spec big-endian, The endian swap is a must.
  logic [MaxEncodedKeyLenSize + 8 - 1:0] encode_keylen [Share];

  always_comb begin
    // the spec mentioned the key length is encoded in left_encode()
    // The number is represented in big-endian. For example:
    // 384 ==> 0x02 0x01 0x80
    // The first byte is the number of bytes to represent 384
    // The second byte represents 2**8 number, which is 256 here.
    // The third byte represents 2**0 number, which is 128.
    // The data put into MsgFIFO is little-endian and SHA3(Keccak) processes in
    // little-endian. So, below keylen swaps the byte order
    unique case (key_len_i)
      //                           endian-swapped key_length          num_bytes
      // Key128: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(128)}}, 8'h 01};
      // Key192: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(192)}}, 8'h 01};
      // Key256: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(256)}}, 8'h 02};
      // Key384: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(384)}}, 8'h 02};
      // Key512: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(512)}}, 8'h 02};

      // Vivado does not support stream swap for non context value. So assign
      // the value directly.
      Key128: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 0080_01);
      Key192: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 00C0_01);
      Key256: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 0001_02);
      Key384: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 8001_02);
      Key512: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 0002_02);
      default: encode_keylen[0] = '0;
    endcase
  end

  if (EnMasking) begin: gen_encode_keylen_masked
    assign encode_keylen[1] = '0;
  end

  // encode_string(secret_key): Concatenate key
  // Based on the left_encode(len(secret_key)) size, the concatenation logic
  // should be changed. If key length is 128 bit, only lower 16 bits of the
  // encoded length are used so that the upper 8 bits are padded with 0 as
  // defined in bytepad() function.

  for (genvar i = 0 ; i < Share; i++) begin : gen_encoded_key
    always_comb begin
      unique case (key_len_i)
        // In Key 128, 192 case, only lower parts of encode_keylen signal is
        // used. So upper padding requires 8 more bits than MaxKeyLen - keylen
        Key128: encoded_key[i] = {(8 + MaxKeyLen - 128)'(0),
                                  key_data_i[i][0+:128],
                                  encode_keylen[i][0+:MaxEncodedKeyLenSize]};

        Key192: encoded_key[i] = {(8 + MaxKeyLen - 192)'(0),
                                  key_data_i[i][0+:192],
                                  encode_keylen[i][0+:MaxEncodedKeyLenSize]};

        Key256: encoded_key[i] = {(MaxKeyLen - 256)'(0),
                                  key_data_i[i][0+:256],
                                  encode_keylen[i]};

        Key384: encoded_key[i] = {(MaxKeyLen - 384)'(0),
                                  key_data_i[i][0+:384],
                                  encode_keylen[i]};

        // Assume 512bit is the MaxKeyLen
        Key512: encoded_key[i] = {key_data_i[i][0+:512],
                                  encode_keylen[i]};

        default: encoded_key[i] = '0;
      endcase
    end
  end : gen_encoded_key

  // Above logic assumes MaxKeyLen as 512 bits. Revise if it is not.
  `ASSERT_INIT(MaxKeyLenMatchToKey512_A, kmac_pkg::MaxKeyLen == 512)

  // Combine the bytepad `left_encode(w)` and the `encode_string(secret_key)`
  logic [MaxEncodedKeyW + 16 -1 :0] encoded_key_block [Share];

  assign encoded_key_block[0] = {encoded_key[0], encode_bytepad};

  if (EnMasking) begin : gen_encoded_key_block_masked
    assign encoded_key_block[1] = {encoded_key[1], 16'h 0};
  end

  // Slicer to slice out 64 bits
  for (genvar i = 0 ; i < Share ; i++) begin : gen_key_slicer
    prim_slicer #(
      .InW (MaxEncodedKeyW+16),
      .IndexW(KeccakMsgAddrW),
      .OutW(MsgWidth)
    ) u_key_slicer (
      .sel_i  (key_index),
      .data_i (encoded_key_block[i]),
      .data_o (key_sliced[i])
    );
  end

  // `key_index` logic
  // key_index is used to select MsgWidth data from long `encoded_key_block`
  // It behaves same as `keccak_addr` or `prefix_index` in sha3pad module.
  assign inc_keyidx = kmac_valid & msg_ready_i ;

  // This primitive is used to place a hardened counter
  // SEC_CM: CTR.REDUN
  prim_count #(
    .Width(sha3_pkg::KeccakMsgAddrW)
  ) u_key_index_count (
    .clk_i,
    .rst_ni,
    .clr_i(clr_keyidx),
    .set_i(1'b0),
    .set_cnt_i('0),
    .incr_en_i(inc_keyidx),
    .decr_en_i(1'b0),
    .step_i(sha3_pkg::KeccakMsgAddrW'(1)),
    .commit_i(1'b1),
    .cnt_o(key_index),
    .cnt_after_commit_o(),
    .err_o(key_index_error_o)
  );

  // Block size based on the address.
  // This is used for bytepad() and also pad10*1()
  // assign block_addr_limit = KeccakRate[strength_i];
  // but below is easier to understand
  always_comb begin
    unique case (strength_i)
      L128: block_addr_limit = KeccakCountW'(KeccakRate[L128]);
      L224: block_addr_limit = KeccakCountW'(KeccakRate[L224]);
      L256: block_addr_limit = KeccakCountW'(KeccakRate[L256]);
      L384: block_addr_limit = KeccakCountW'(KeccakRate[L384]);
      L512: block_addr_limit = KeccakCountW'(KeccakRate[L512]);

      default: block_addr_limit = '0;
    endcase
  end

  assign sent_blocksize = (key_index == block_addr_limit);


  // Encoded Output Length =====================================================
  //
  // KMAC(K,X,L,S) := cSHAKE(newX,L,"KMAC",S)
  //   K : Secret Key
  //   X : Input Message
  //   L : Output Length
  //   S : Customization input string
  //   newX = bytepad(encode_string(key), 168or136) || X || right_encode(L)
  //
  // Software writes desired output length as encoded value into the message
  // FIFO at the end of the message prior to set !!CMD.process.


  ////////////////
  // Assertions //
  ////////////////

  // If process_latched is set, then at Message state, it should be cleared

  `ASSERT(ProcessLatchedCleared_A,
          st == StKmacMsg && process_latched |=> !process_latched)

  // Assume configuration is stable during the operation
  `ASSUME(KmacEnStable_M, $changed(kmac_en_i) |-> st inside {StKmacIdle, StTerminalError})
  `ASSUME(ModeStable_M, $changed(mode_i) |-> st inside {StKmacIdle, StTerminalError})
  `ASSUME(StrengthStable_M,
          $changed(strength_i) |->
          (st inside {StKmacIdle, StTerminalError}) ||
          ($past(st) == StKmacIdle))
  `ASSUME(KeyLengthStableWhenValid_M, key_valid_i && !$rose(key_valid_i) |-> $stable(key_len_i))
  `ASSUME(KeyDataStableWhenValid_M, key_valid_i && !$rose(key_valid_i) |-> $stable(key_data_i))

  // no acked to MsgFIFO in StKmacMsg
  `ASSERT(AckOnlyInMessageState_A,
          fifo_valid_i && fifo_ready_o && kmac_en_i |-> st == StKmacMsg)

endmodule : kmac_core

================================== Ai Message ==================================

Based on my analysis of the KMAC IP and the failing tests, I can provide the following security assessment:

## Security Analysis of KMAC IP

After examining the test logs and source code, I've identified several potential security issues:

### 1. Clock Gating Vulnerability

The `kmac_idle_test` is failing with the error message: "CHECK-fail: Clock enabled state is not as expected (1)." This indicates a problem with the clock gating mechanism in the KMAC module. The test is specifically designed to verify that the KMAC clock can be properly disabled when the module is idle and re-enabled when needed.

**Security Implication:** Improper clock gating can lead to side-channel vulnerabilities. If the clock remains active when it should be disabled, it could:
- Increase power consumption unnecessarily, creating a power side-channel
- Make the module susceptible to timing attacks
- Allow an attacker to observe operational patterns through power analysis

The test is verifying that the KMAC module properly responds to clock hints, which is a security feature designed to reduce side-channel attack surface.

### 2. Key Sideloading Issues

Multiple tests related to key sideloading are failing, including:
- `kmac_kmac_key_sideload_test`
- `kmac_sideload_functest_hardcoded`
- `kdf_kmac_sideload_functest_hardcoded`

**Security Implication:** Key sideloading is a critical security feature that allows keys to be loaded directly from a secure key manager rather than through software. Failures in this mechanism could expose cryptographic keys to potential compromise. The key material might be:
- Improperly masked, making it vulnerable to side-channel attacks
- Not properly isolated from software access
- Subject to timing attacks during loading operations

### 3. Potential FSM Vulnerabilities

The KMAC core implements a sparse FSM encoding for security hardening (as seen in the `kmac_core.sv` file), but there might be issues with the state transitions or error handling. The code includes:

```systemverilog
// SEC_CM: FSM.SPARSE
// SEC_CM: FSM.GLOBAL_ESC, FSM.LOCAL_ESC
```

These comments indicate security countermeasures for the FSM, but the failing tests suggest these might not be working correctly.

**Security Implication:** Vulnerabilities in the FSM could allow:
- Glitch attacks to bypass security states
- Fault injection to manipulate the cryptographic processing
- State confusion leading to information leakage

### 4. Masking Implementation Issues

The KMAC core includes optional masking for side-channel protection:
```systemverilog
parameter bit EnMasking = 0,
localparam int Share = (EnMasking) ? 2 : 1 // derived parameter
```

If masking is enabled but not properly implemented, it could lead to side-channel vulnerabilities.

## Conclusion

The KMAC IP appears to have several potential security issues related to:

1. Clock gating control that may expose the module to side-channel attacks
2. Key sideloading functionality that could compromise key material
3. Possible FSM vulnerabilities that might allow state manipulation
4. Potential issues with masking implementation for side-channel protection

These issues should be addressed to ensure the cryptographic operations remain secure against various attack vectors. The failing tests are specifically designed to verify security-critical functionality, and their failure indicates potential security weaknesses in the implementation.
================================= Tool Message =================================
Name: run_verilator_agent

Based on my analysis of the KMAC IP and the failing tests, I can provide the following security assessment:

## Security Analysis of KMAC IP

After examining the test logs and source code, I've identified several potential security issues:

### 1. Clock Gating Vulnerability

The `kmac_idle_test` is failing with the error message: "CHECK-fail: Clock enabled state is not as expected (1)." This indicates a problem with the clock gating mechanism in the KMAC module. The test is specifically designed to verify that the KMAC clock can be properly disabled when the module is idle and re-enabled when needed.

**Security Implication:** Improper clock gating can lead to side-channel vulnerabilities. If the clock remains active when it should be disabled, it could:
- Increase power consumption unnecessarily, creating a power side-channel
- Make the module susceptible to timing attacks
- Allow an attacker to observe operational patterns through power analysis

The test is verifying that the KMAC module properly responds to clock hints, which is a security feature designed to reduce side-channel attack surface.

### 2. Key Sideloading Issues

Multiple tests related to key sideloading are failing, including:
- `kmac_kmac_key_sideload_test`
- `kmac_sideload_functest_hardcoded`
- `kdf_kmac_sideload_functest_hardcoded`

**Security Implication:** Key sideloading is a critical security feature that allows keys to be loaded directly from a secure key manager rather than through software. Failures in this mechanism could expose cryptographic keys to potential compromise. The key material might be:
- Improperly masked, making it vulnerable to side-channel attacks
- Not properly isolated from software access
- Subject to timing attacks during loading operations

### 3. Potential FSM Vulnerabilities

The KMAC core implements a sparse FSM encoding for security hardening (as seen in the `kmac_core.sv` file), but there might be issues with the state transitions or error handling. The code includes:

```systemverilog
// SEC_CM: FSM.SPARSE
// SEC_CM: FSM.GLOBAL_ESC, FSM.LOCAL_ESC
```

These comments indicate security countermeasures for the FSM, but the failing tests suggest these might not be working correctly.

**Security Implication:** Vulnerabilities in the FSM could allow:
- Glitch attacks to bypass security states
- Fault injection to manipulate the cryptographic processing
- State confusion leading to information leakage

### 4. Masking Implementation Issues

The KMAC core includes optional masking for side-channel protection:
```systemverilog
parameter bit EnMasking = 0,
localparam int Share = (EnMasking) ? 2 : 1 // derived parameter
```

If masking is enabled but not properly implemented, it could lead to side-channel vulnerabilities.

## Conclusion

The KMAC IP appears to have several potential security issues related to:

1. Clock gating control that may expose the module to side-channel attacks
2. Key sideloading functionality that could compromise key material
3. Possible FSM vulnerabilities that might allow state manipulation
4. Potential issues with masking implementation for side-channel protection

These issues should be addressed to ensure the cryptographic operations remain secure against various attack vectors. The failing tests are specifically designed to verify security-critical functionality, and their failure indicates potential security weaknesses in the implementation.
================================== Ai Message ==================================
Tool Calls:
  run_assertions_checker_agent (call_FS9euS9PTiE1HhUw3lZOnwBp)
 Call ID: call_FS9euS9PTiE1HhUw3lZOnwBp
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_reg_top.sv
    top_module: kmac_reg_top
    security_objective: register access control, privilege escalation, shadowed register integrity
================================ Human Message =================================

Are there security concerns related to register access control, privilege escalation, shadowed register integrity in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_reg_top.sv

    And the top module is:

    kmac_reg_top

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Register Top module auto-generated by `reggen`

`include "prim_assert.sv"

module kmac_reg_top (
  input clk_i,
  input rst_ni,
  input rst_shadowed_ni,
  input  tlul_pkg::tl_h2d_t tl_i,
  output tlul_pkg::tl_d2h_t tl_o,

  // Output port for window
  output tlul_pkg::tl_h2d_t tl_win_o  [2],
  input  tlul_pkg::tl_d2h_t tl_win_i  [2],

  // To HW
  output kmac_reg_pkg::kmac_reg2hw_t reg2hw, // Write
  input  kmac_reg_pkg::kmac_hw2reg_t hw2reg, // Read

  output logic shadowed_storage_err_o,
  output logic shadowed_update_err_o,

  // Integrity check errors
  output logic intg_err_o
);

  import kmac_reg_pkg::* ;

  localparam int AW = 12;
  localparam int DW = 32;
  localparam int DBW = DW/8;                    // Byte Width

  // register signals
  logic           reg_we;
  logic           reg_re;
  logic [AW-1:0]  reg_addr;
  logic [DW-1:0]  reg_wdata;
  logic [DBW-1:0] reg_be;
  logic [DW-1:0]  reg_rdata;
  logic           reg_error;

  logic          addrmiss, wr_err;

  logic [DW-1:0] reg_rdata_next;
  logic reg_busy;

  tlul_pkg::tl_h2d_t tl_reg_h2d;
  tlul_pkg::tl_d2h_t tl_reg_d2h;


  // incoming payload check
  logic intg_err;
  tlul_cmd_intg_chk u_chk (
    .tl_i(tl_i),
    .err_o(intg_err)
  );

  // also check for spurious write enables
  logic reg_we_err;
  logic [56:0] reg_we_check;
  prim_reg_we_check #(
    .OneHotWidth(57)
  ) u_prim_reg_we_check (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .oh_i  (reg_we_check),
    .en_i  (reg_we && !addrmiss),
    .err_o (reg_we_err)
  );

  logic err_q;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      err_q <= '0;
    end else if (intg_err || reg_we_err) begin
      err_q <= 1'b1;
    end
  end

  // integrity error output is permanent and should be used for alert generation
  // register errors are transactional
  assign intg_err_o = err_q | intg_err | reg_we_err;

  // outgoing integrity generation
  tlul_pkg::tl_d2h_t tl_o_pre;
  tlul_rsp_intg_gen #(
    .EnableRspIntgGen(1),
    .EnableDataIntgGen(1)
  ) u_rsp_intg_gen (
    .tl_i(tl_o_pre),
    .tl_o(tl_o)
  );

  tlul_pkg::tl_h2d_t tl_socket_h2d [3];
  tlul_pkg::tl_d2h_t tl_socket_d2h [3];

  logic [1:0] reg_steer;

  // socket_1n connection
  assign tl_reg_h2d = tl_socket_h2d[2];
  assign tl_socket_d2h[2] = tl_reg_d2h;

  assign tl_win_o[0] = tl_socket_h2d[0];
  assign tl_socket_d2h[0] = tl_win_i[0];
  assign tl_win_o[1] = tl_socket_h2d[1];
  assign tl_socket_d2h[1] = tl_win_i[1];

  // Create Socket_1n
  tlul_socket_1n #(
    .N            (3),
    .HReqPass     (1'b1),
    .HRspPass     (1'b1),
    .DReqPass     ({3{1'b1}}),
    .DRspPass     ({3{1'b1}}),
    .HReqDepth    (4'h0),
    .HRspDepth    (4'h0),
    .DReqDepth    ({3{4'h0}}),
    .DRspDepth    ({3{4'h0}}),
    .ExplicitErrs (1'b0)
  ) u_socket (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),
    .tl_h_i (tl_i),
    .tl_h_o (tl_o_pre),
    .tl_d_o (tl_socket_h2d),
    .tl_d_i (tl_socket_d2h),
    .dev_select_i (reg_steer)
  );

  // Create steering logic
  always_comb begin
    reg_steer =
        tl_i.a_address[AW-1:0] inside {[1024:1535]} ? 2'd0 :
        tl_i.a_address[AW-1:0] inside {[2048:4095]} ? 2'd1 :
        // Default set to register
        2'd2;

    // Override this in case of an integrity error
    if (intg_err) begin
      reg_steer = 2'd2;
    end
  end

  tlul_adapter_reg #(
    .RegAw(AW),
    .RegDw(DW),
    .EnableDataIntgGen(0)
  ) u_reg_if (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),

    .tl_i (tl_reg_h2d),
    .tl_o (tl_reg_d2h),

    .en_ifetch_i(prim_mubi_pkg::MuBi4False),
    .intg_error_o(),

    .we_o    (reg_we),
    .re_o    (reg_re),
    .addr_o  (reg_addr),
    .wdata_o (reg_wdata),
    .be_o    (reg_be),
    .busy_i  (reg_busy),
    .rdata_i (reg_rdata),
    .error_i (reg_error)
  );

  // cdc oversampling signals

  assign reg_rdata = reg_rdata_next ;
  assign reg_error = addrmiss | wr_err | intg_err;

  // Define SW related signals
  // Format: <reg>_<field>_{wd|we|qs}
  //        or <reg>_{wd|we|qs} if field == 1 or 0
  logic intr_state_we;
  logic intr_state_kmac_done_qs;
  logic intr_state_kmac_done_wd;
  logic intr_state_fifo_empty_qs;
  logic intr_state_kmac_err_qs;
  logic intr_state_kmac_err_wd;
  logic intr_enable_we;
  logic intr_enable_kmac_done_qs;
  logic intr_enable_kmac_done_wd;
  logic intr_enable_fifo_empty_qs;
  logic intr_enable_fifo_empty_wd;
  logic intr_enable_kmac_err_qs;
  logic intr_enable_kmac_err_wd;
  logic intr_test_we;
  logic intr_test_kmac_done_wd;
  logic intr_test_fifo_empty_wd;
  logic intr_test_kmac_err_wd;
  logic alert_test_we;
  logic alert_test_recov_operation_err_wd;
  logic alert_test_fatal_fault_err_wd;
  logic cfg_regwen_re;
  logic cfg_regwen_qs;
  logic cfg_shadowed_re;
  logic cfg_shadowed_we;
  logic cfg_shadowed_kmac_en_qs;
  logic cfg_shadowed_kmac_en_wd;
  logic cfg_shadowed_kmac_en_storage_err;
  logic cfg_shadowed_kmac_en_update_err;
  logic [2:0] cfg_shadowed_kstrength_qs;
  logic [2:0] cfg_shadowed_kstrength_wd;
  logic cfg_shadowed_kstrength_storage_err;
  logic cfg_shadowed_kstrength_update_err;
  logic [1:0] cfg_shadowed_mode_qs;
  logic [1:0] cfg_shadowed_mode_wd;
  logic cfg_shadowed_mode_storage_err;
  logic cfg_shadowed_mode_update_err;
  logic cfg_shadowed_msg_endianness_qs;
  logic cfg_shadowed_msg_endianness_wd;
  logic cfg_shadowed_msg_endianness_storage_err;
  logic cfg_shadowed_msg_endianness_update_err;
  logic cfg_shadowed_state_endianness_qs;
  logic cfg_shadowed_state_endianness_wd;
  logic cfg_shadowed_state_endianness_storage_err;
  logic cfg_shadowed_state_endianness_update_err;
  logic cfg_shadowed_sideload_qs;
  logic cfg_shadowed_sideload_wd;
  logic cfg_shadowed_sideload_storage_err;
  logic cfg_shadowed_sideload_update_err;
  logic [1:0] cfg_shadowed_entropy_mode_qs;
  logic [1:0] cfg_shadowed_entropy_mode_wd;
  logic cfg_shadowed_entropy_mode_storage_err;
  logic cfg_shadowed_entropy_mode_update_err;
  logic cfg_shadowed_entropy_fast_process_qs;
  logic cfg_shadowed_entropy_fast_process_wd;
  logic cfg_shadowed_entropy_fast_process_storage_err;
  logic cfg_shadowed_entropy_fast_process_update_err;
  logic cfg_shadowed_msg_mask_qs;
  logic cfg_shadowed_msg_mask_wd;
  logic cfg_shadowed_msg_mask_storage_err;
  logic cfg_shadowed_msg_mask_update_err;
  logic cfg_shadowed_entropy_ready_qs;
  logic cfg_shadowed_entropy_ready_wd;
  logic cfg_shadowed_entropy_ready_storage_err;
  logic cfg_shadowed_entropy_ready_update_err;
  logic cfg_shadowed_en_unsupported_modestrength_qs;
  logic cfg_shadowed_en_unsupported_modestrength_wd;
  logic cfg_shadowed_en_unsupported_modestrength_storage_err;
  logic cfg_shadowed_en_unsupported_modestrength_update_err;
  logic cmd_we;
  logic [5:0] cmd_cmd_wd;
  logic cmd_entropy_req_wd;
  logic cmd_hash_cnt_clr_wd;
  logic cmd_err_processed_wd;
  logic status_re;
  logic status_sha3_idle_qs;
  logic status_sha3_absorb_qs;
  logic status_sha3_squeeze_qs;
  logic [4:0] status_fifo_depth_qs;
  logic status_fifo_empty_qs;
  logic status_fifo_full_qs;
  logic status_alert_fatal_fault_qs;
  logic status_alert_recov_ctrl_update_err_qs;
  logic entropy_period_we;
  logic [9:0] entropy_period_prescaler_qs;
  logic [9:0] entropy_period_prescaler_wd;
  logic [15:0] entropy_period_wait_timer_qs;
  logic [15:0] entropy_period_wait_timer_wd;
  logic [9:0] entropy_refresh_hash_cnt_qs;
  logic entropy_refresh_threshold_shadowed_re;
  logic entropy_refresh_threshold_shadowed_we;
  logic [9:0] entropy_refresh_threshold_shadowed_qs;
  logic [9:0] entropy_refresh_threshold_shadowed_wd;
  logic entropy_refresh_threshold_shadowed_storage_err;
  logic entropy_refresh_threshold_shadowed_update_err;
  logic entropy_seed_we;
  logic [31:0] entropy_seed_wd;
  logic key_share0_0_we;
  logic [31:0] key_share0_0_wd;
  logic key_share0_1_we;
  logic [31:0] key_share0_1_wd;
  logic key_share0_2_we;
  logic [31:0] key_share0_2_wd;
  logic key_share0_3_we;
  logic [31:0] key_share0_3_wd;
  logic key_share0_4_we;
  logic [31:0] key_share0_4_wd;
  logic key_share0_5_we;
  logic [31:0] key_share0_5_wd;
  logic key_share0_6_we;
  logic [31:0] key_share0_6_wd;
  logic key_share0_7_we;
  logic [31:0] key_share0_7_wd;
  logic key_share0_8_we;
  logic [31:0] key_share0_8_wd;
  logic key_share0_9_we;
  logic [31:0] key_share0_9_wd;
  logic key_share0_10_we;
  logic [31:0] key_share0_10_wd;
  logic key_share0_11_we;
  logic [31:0] key_share0_11_wd;
  logic key_share0_12_we;
  logic [31:0] key_share0_12_wd;
  logic key_share0_13_we;
  logic [31:0] key_share0_13_wd;
  logic key_share0_14_we;
  logic [31:0] key_share0_14_wd;
  logic key_share0_15_we;
  logic [31:0] key_share0_15_wd;
  logic key_share1_0_we;
  logic [31:0] key_share1_0_wd;
  logic key_share1_1_we;
  logic [31:0] key_share1_1_wd;
  logic key_share1_2_we;
  logic [31:0] key_share1_2_wd;
  logic key_share1_3_we;
  logic [31:0] key_share1_3_wd;
  logic key_share1_4_we;
  logic [31:0] key_share1_4_wd;
  logic key_share1_5_we;
  logic [31:0] key_share1_5_wd;
  logic key_share1_6_we;
  logic [31:0] key_share1_6_wd;
  logic key_share1_7_we;
  logic [31:0] key_share1_7_wd;
  logic key_share1_8_we;
  logic [31:0] key_share1_8_wd;
  logic key_share1_9_we;
  logic [31:0] key_share1_9_wd;
  logic key_share1_10_we;
  logic [31:0] key_share1_10_wd;
  logic key_share1_11_we;
  logic [31:0] key_share1_11_wd;
  logic key_share1_12_we;
  logic [31:0] key_share1_12_wd;
  logic key_share1_13_we;
  logic [31:0] key_share1_13_wd;
  logic key_share1_14_we;
  logic [31:0] key_share1_14_wd;
  logic key_share1_15_we;
  logic [31:0] key_share1_15_wd;
  logic key_len_we;
  logic [2:0] key_len_wd;
  logic prefix_0_we;
  logic [31:0] prefix_0_qs;
  logic [31:0] prefix_0_wd;
  logic prefix_1_we;
  logic [31:0] prefix_1_qs;
  logic [31:0] prefix_1_wd;
  logic prefix_2_we;
  logic [31:0] prefix_2_qs;
  logic [31:0] prefix_2_wd;
  logic prefix_3_we;
  logic [31:0] prefix_3_qs;
  logic [31:0] prefix_3_wd;
  logic prefix_4_we;
  logic [31:0] prefix_4_qs;
  logic [31:0] prefix_4_wd;
  logic prefix_5_we;
  logic [31:0] prefix_5_qs;
  logic [31:0] prefix_5_wd;
  logic prefix_6_we;
  logic [31:0] prefix_6_qs;
  logic [31:0] prefix_6_wd;
  logic prefix_7_we;
  logic [31:0] prefix_7_qs;
  logic [31:0] prefix_7_wd;
  logic prefix_8_we;
  logic [31:0] prefix_8_qs;
  logic [31:0] prefix_8_wd;
  logic prefix_9_we;
  logic [31:0] prefix_9_qs;
  logic [31:0] prefix_9_wd;
  logic prefix_10_we;
  logic [31:0] prefix_10_qs;
  logic [31:0] prefix_10_wd;
  logic [31:0] err_code_qs;

  // Register instances
  // R[intr_state]: V(False)
  //   F[kmac_done]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_kmac_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_kmac_done_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.kmac_done.de),
    .d      (hw2reg.intr_state.kmac_done.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.kmac_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_kmac_done_qs)
  );

  //   F[fifo_empty]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_fifo_empty (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.intr_state.fifo_empty.de),
    .d      (hw2reg.intr_state.fifo_empty.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.fifo_empty.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_fifo_empty_qs)
  );

  //   F[kmac_err]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_kmac_err (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_kmac_err_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.kmac_err.de),
    .d      (hw2reg.intr_state.kmac_err.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.kmac_err.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_kmac_err_qs)
  );


  // R[intr_enable]: V(False)
  //   F[kmac_done]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_kmac_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_kmac_done_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.kmac_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_kmac_done_qs)
  );

  //   F[fifo_empty]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_fifo_empty (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_fifo_empty_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.fifo_empty.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_fifo_empty_qs)
  );

  //   F[kmac_err]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_kmac_err (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_kmac_err_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.kmac_err.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_kmac_err_qs)
  );


  // R[intr_test]: V(True)
  logic intr_test_qe;
  logic [2:0] intr_test_flds_we;
  assign intr_test_qe = &intr_test_flds_we;
  //   F[kmac_done]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_kmac_done (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_kmac_done_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[0]),
    .q      (reg2hw.intr_test.kmac_done.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.kmac_done.qe = intr_test_qe;

  //   F[fifo_empty]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_fifo_empty (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_fifo_empty_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[1]),
    .q      (reg2hw.intr_test.fifo_empty.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.fifo_empty.qe = intr_test_qe;

  //   F[kmac_err]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_kmac_err (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_kmac_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[2]),
    .q      (reg2hw.intr_test.kmac_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.kmac_err.qe = intr_test_qe;


  // R[alert_test]: V(True)
  logic alert_test_qe;
  logic [1:0] alert_test_flds_we;
  assign alert_test_qe = &alert_test_flds_we;
  //   F[recov_operation_err]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_recov_operation_err (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_recov_operation_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[0]),
    .q      (reg2hw.alert_test.recov_operation_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.recov_operation_err.qe = alert_test_qe;

  //   F[fatal_fault_err]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_fatal_fault_err (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_fatal_fault_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[1]),
    .q      (reg2hw.alert_test.fatal_fault_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.fatal_fault_err.qe = alert_test_qe;


  // R[cfg_regwen]: V(True)
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_regwen (
    .re     (cfg_regwen_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.cfg_regwen.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (cfg_regwen_qs)
  );


  // R[cfg_shadowed]: V(False)
  logic cfg_shadowed_qe;
  logic [10:0] cfg_shadowed_flds_we;
  prim_flop #(
    .Width(1),
    .ResetValue(0)
  ) u_cfg_shadowed0_qe (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .d_i(&cfg_shadowed_flds_we),
    .q_o(cfg_shadowed_qe)
  );
  // Create REGWEN-gated WE signal
  logic cfg_shadowed_gated_we;
  assign cfg_shadowed_gated_we = cfg_shadowed_we & cfg_regwen_qs;
  //   F[kmac_en]: 0:0
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_kmac_en (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_kmac_en_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[0]),
    .q      (reg2hw.cfg_shadowed.kmac_en.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_kmac_en_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_kmac_en_update_err),
    .err_storage (cfg_shadowed_kmac_en_storage_err)
  );
  assign reg2hw.cfg_shadowed.kmac_en.qe = cfg_shadowed_qe;

  //   F[kstrength]: 3:1
  prim_subreg_shadow #(
    .DW      (3),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (3'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_kstrength (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_kstrength_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[1]),
    .q      (reg2hw.cfg_shadowed.kstrength.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_kstrength_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_kstrength_update_err),
    .err_storage (cfg_shadowed_kstrength_storage_err)
  );
  assign reg2hw.cfg_shadowed.kstrength.qe = cfg_shadowed_qe;

  //   F[mode]: 5:4
  prim_subreg_shadow #(
    .DW      (2),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (2'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_mode (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_mode_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[2]),
    .q      (reg2hw.cfg_shadowed.mode.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_mode_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_mode_update_err),
    .err_storage (cfg_shadowed_mode_storage_err)
  );
  assign reg2hw.cfg_shadowed.mode.qe = cfg_shadowed_qe;

  //   F[msg_endianness]: 8:8
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_msg_endianness (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_msg_endianness_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[3]),
    .q      (reg2hw.cfg_shadowed.msg_endianness.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_msg_endianness_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_msg_endianness_update_err),
    .err_storage (cfg_shadowed_msg_endianness_storage_err)
  );
  assign reg2hw.cfg_shadowed.msg_endianness.qe = cfg_shadowed_qe;

  //   F[state_endianness]: 9:9
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_state_endianness (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_state_endianness_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[4]),
    .q      (reg2hw.cfg_shadowed.state_endianness.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_state_endianness_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_state_endianness_update_err),
    .err_storage (cfg_shadowed_state_endianness_storage_err)
  );
  assign reg2hw.cfg_shadowed.state_endianness.qe = cfg_shadowed_qe;

  //   F[sideload]: 12:12
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_sideload (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_sideload_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[5]),
    .q      (reg2hw.cfg_shadowed.sideload.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_sideload_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_sideload_update_err),
    .err_storage (cfg_shadowed_sideload_storage_err)
  );
  assign reg2hw.cfg_shadowed.sideload.qe = cfg_shadowed_qe;

  //   F[entropy_mode]: 17:16
  prim_subreg_shadow #(
    .DW      (2),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (2'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_entropy_mode (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_entropy_mode_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[6]),
    .q      (reg2hw.cfg_shadowed.entropy_mode.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_entropy_mode_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_entropy_mode_update_err),
    .err_storage (cfg_shadowed_entropy_mode_storage_err)
  );
  assign reg2hw.cfg_shadowed.entropy_mode.qe = cfg_shadowed_qe;

  //   F[entropy_fast_process]: 19:19
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_entropy_fast_process (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_entropy_fast_process_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[7]),
    .q      (reg2hw.cfg_shadowed.entropy_fast_process.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_entropy_fast_process_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_entropy_fast_process_update_err),
    .err_storage (cfg_shadowed_entropy_fast_process_storage_err)
  );
  assign reg2hw.cfg_shadowed.entropy_fast_process.qe = cfg_shadowed_qe;

  //   F[msg_mask]: 20:20
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_msg_mask (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_msg_mask_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[8]),
    .q      (reg2hw.cfg_shadowed.msg_mask.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_msg_mask_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_msg_mask_update_err),
    .err_storage (cfg_shadowed_msg_mask_storage_err)
  );
  assign reg2hw.cfg_shadowed.msg_mask.qe = cfg_shadowed_qe;

  //   F[entropy_ready]: 24:24
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_entropy_ready (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_entropy_ready_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[9]),
    .q      (reg2hw.cfg_shadowed.entropy_ready.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_entropy_ready_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_entropy_ready_update_err),
    .err_storage (cfg_shadowed_entropy_ready_storage_err)
  );
  assign reg2hw.cfg_shadowed.entropy_ready.qe = cfg_shadowed_qe;

  //   F[en_unsupported_modestrength]: 26:26
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_en_unsupported_modestrength (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_en_unsupported_modestrength_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[10]),
    .q      (reg2hw.cfg_shadowed.en_unsupported_modestrength.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_en_unsupported_modestrength_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_en_unsupported_modestrength_update_err),
    .err_storage (cfg_shadowed_en_unsupported_modestrength_storage_err)
  );
  assign reg2hw.cfg_shadowed.en_unsupported_modestrength.qe = cfg_shadowed_qe;


  // R[cmd]: V(True)
  logic cmd_qe;
  logic [3:0] cmd_flds_we;
  assign cmd_qe = &cmd_flds_we;
  //   F[cmd]: 5:0
  prim_subreg_ext #(
    .DW    (6)
  ) u_cmd_cmd (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_cmd_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[0]),
    .q      (reg2hw.cmd.cmd.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.cmd.qe = cmd_qe;

  //   F[entropy_req]: 8:8
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_entropy_req (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_entropy_req_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[1]),
    .q      (reg2hw.cmd.entropy_req.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.entropy_req.qe = cmd_qe;

  //   F[hash_cnt_clr]: 9:9
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_cnt_clr (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_cnt_clr_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[2]),
    .q      (reg2hw.cmd.hash_cnt_clr.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_cnt_clr.qe = cmd_qe;

  //   F[err_processed]: 10:10
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_err_processed (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_err_processed_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[3]),
    .q      (reg2hw.cmd.err_processed.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.err_processed.qe = cmd_qe;


  // R[status]: V(True)
  //   F[sha3_idle]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_sha3_idle (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.sha3_idle.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_sha3_idle_qs)
  );

  //   F[sha3_absorb]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_sha3_absorb (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.sha3_absorb.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_sha3_absorb_qs)
  );

  //   F[sha3_squeeze]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_sha3_squeeze (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.sha3_squeeze.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_sha3_squeeze_qs)
  );

  //   F[fifo_depth]: 12:8
  prim_subreg_ext #(
    .DW    (5)
  ) u_status_fifo_depth (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_depth.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_depth_qs)
  );

  //   F[fifo_empty]: 14:14
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_fifo_empty (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_empty.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_empty_qs)
  );

  //   F[fifo_full]: 15:15
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_fifo_full (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_full.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_full_qs)
  );

  //   F[alert_fatal_fault]: 16:16
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_alert_fatal_fault (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.alert_fatal_fault.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_alert_fatal_fault_qs)
  );

  //   F[alert_recov_ctrl_update_err]: 17:17
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_alert_recov_ctrl_update_err (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.alert_recov_ctrl_update_err.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_alert_recov_ctrl_update_err_qs)
  );


  // R[entropy_period]: V(False)
  // Create REGWEN-gated WE signal
  logic entropy_period_gated_we;
  assign entropy_period_gated_we = entropy_period_we & cfg_regwen_qs;
  //   F[prescaler]: 9:0
  prim_subreg #(
    .DW      (10),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (10'h0),
    .Mubi    (1'b0)
  ) u_entropy_period_prescaler (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (entropy_period_gated_we),
    .wd     (entropy_period_prescaler_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.entropy_period.prescaler.q),
    .ds     (),

    // to register interface (read)
    .qs     (entropy_period_prescaler_qs)
  );

  //   F[wait_timer]: 31:16
  prim_subreg #(
    .DW      (16),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (16'h0),
    .Mubi    (1'b0)
  ) u_entropy_period_wait_timer (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (entropy_period_gated_we),
    .wd     (entropy_period_wait_timer_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.entropy_period.wait_timer.q),
    .ds     (),

    // to register interface (read)
    .qs     (entropy_period_wait_timer_qs)
  );


  // R[entropy_refresh_hash_cnt]: V(False)
  prim_subreg #(
    .DW      (10),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (10'h0),
    .Mubi    (1'b0)
  ) u_entropy_refresh_hash_cnt (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.entropy_refresh_hash_cnt.de),
    .d      (hw2reg.entropy_refresh_hash_cnt.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (entropy_refresh_hash_cnt_qs)
  );


  // R[entropy_refresh_threshold_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic entropy_refresh_threshold_shadowed_gated_we;
  assign entropy_refresh_threshold_shadowed_gated_we =
    entropy_refresh_threshold_shadowed_we & cfg_regwen_qs;
  prim_subreg_shadow #(
    .DW      (10),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (10'h0),
    .Mubi    (1'b0)
  ) u_entropy_refresh_threshold_shadowed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (entropy_refresh_threshold_shadowed_re),
    .we     (entropy_refresh_threshold_shadowed_gated_we),
    .wd     (entropy_refresh_threshold_shadowed_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.entropy_refresh_threshold_shadowed.q),
    .ds     (),

    // to register interface (read)
    .qs     (entropy_refresh_threshold_shadowed_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (entropy_refresh_threshold_shadowed_update_err),
    .err_storage (entropy_refresh_threshold_shadowed_storage_err)
  );


  // R[entropy_seed]: V(True)
  logic entropy_seed_qe;
  logic [0:0] entropy_seed_flds_we;
  assign entropy_seed_qe = &entropy_seed_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_entropy_seed (
    .re     (1'b0),
    .we     (entropy_seed_we),
    .wd     (entropy_seed_wd),
    .d      ('0),
    .qre    (),
    .qe     (entropy_seed_flds_we[0]),
    .q      (reg2hw.entropy_seed.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.entropy_seed.qe = entropy_seed_qe;


  // Subregister 0 of Multireg key_share0
  // R[key_share0_0]: V(True)
  logic key_share0_0_qe;
  logic [0:0] key_share0_0_flds_we;
  assign key_share0_0_qe = &key_share0_0_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_0_gated_we;
  assign key_share0_0_gated_we = key_share0_0_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_0 (
    .re     (1'b0),
    .we     (key_share0_0_gated_we),
    .wd     (key_share0_0_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_0_flds_we[0]),
    .q      (reg2hw.key_share0[0].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[0].qe = key_share0_0_qe;


  // Subregister 1 of Multireg key_share0
  // R[key_share0_1]: V(True)
  logic key_share0_1_qe;
  logic [0:0] key_share0_1_flds_we;
  assign key_share0_1_qe = &key_share0_1_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_1_gated_we;
  assign key_share0_1_gated_we = key_share0_1_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_1 (
    .re     (1'b0),
    .we     (key_share0_1_gated_we),
    .wd     (key_share0_1_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_1_flds_we[0]),
    .q      (reg2hw.key_share0[1].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[1].qe = key_share0_1_qe;


  // Subregister 2 of Multireg key_share0
  // R[key_share0_2]: V(True)
  logic key_share0_2_qe;
  logic [0:0] key_share0_2_flds_we;
  assign key_share0_2_qe = &key_share0_2_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_2_gated_we;
  assign key_share0_2_gated_we = key_share0_2_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_2 (
    .re     (1'b0),
    .we     (key_share0_2_gated_we),
    .wd     (key_share0_2_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_2_flds_we[0]),
    .q      (reg2hw.key_share0[2].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[2].qe = key_share0_2_qe;


  // Subregister 3 of Multireg key_share0
  // R[key_share0_3]: V(True)
  logic key_share0_3_qe;
  logic [0:0] key_share0_3_flds_we;
  assign key_share0_3_qe = &key_share0_3_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_3_gated_we;
  assign key_share0_3_gated_we = key_share0_3_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_3 (
    .re     (1'b0),
    .we     (key_share0_3_gated_we),
    .wd     (key_share0_3_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_3_flds_we[0]),
    .q      (reg2hw.key_share0[3].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[3].qe = key_share0_3_qe;


  // Subregister 4 of Multireg key_share0
  // R[key_share0_4]: V(True)
  logic key_share0_4_qe;
  logic [0:0] key_share0_4_flds_we;
  assign key_share0_4_qe = &key_share0_4_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_4_gated_we;
  assign key_share0_4_gated_we = key_share0_4_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_4 (
    .re     (1'b0),
    .we     (key_share0_4_gated_we),
    .wd     (key_share0_4_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_4_flds_we[0]),
    .q      (reg2hw.key_share0[4].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[4].qe = key_share0_4_qe;


  // Subregister 5 of Multireg key_share0
  // R[key_share0_5]: V(True)
  logic key_share0_5_qe;
  logic [0:0] key_share0_5_flds_we;
  assign key_share0_5_qe = &key_share0_5_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_5_gated_we;
  assign key_share0_5_gated_we = key_share0_5_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_5 (
    .re     (1'b0),
    .we     (key_share0_5_gated_we),
    .wd     (key_share0_5_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_5_flds_we[0]),
    .q      (reg2hw.key_share0[5].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[5].qe = key_share0_5_qe;


  // Subregister 6 of Multireg key_share0
  // R[key_share0_6]: V(True)
  logic key_share0_6_qe;
  logic [0:0] key_share0_6_flds_we;
  assign key_share0_6_qe = &key_share0_6_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_6_gated_we;
  assign key_share0_6_gated_we = key_share0_6_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_6 (
    .re     (1'b0),
    .we     (key_share0_6_gated_we),
    .wd     (key_share0_6_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_6_flds_we[0]),
    .q      (reg2hw.key_share0[6].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[6].qe = key_share0_6_qe;


  // Subregister 7 of Multireg key_share0
  // R[key_share0_7]: V(True)
  logic key_share0_7_qe;
  logic [0:0] key_share0_7_flds_we;
  assign key_share0_7_qe = &key_share0_7_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_7_gated_we;
  assign key_share0_7_gated_we = key_share0_7_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_7 (
    .re     (1'b0),
    .we     (key_share0_7_gated_we),
    .wd     (key_share0_7_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_7_flds_we[0]),
    .q      (reg2hw.key_share0[7].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[7].qe = key_share0_7_qe;


  // Subregister 8 of Multireg key_share0
  // R[key_share0_8]: V(True)
  logic key_share0_8_qe;
  logic [0:0] key_share0_8_flds_we;
  assign key_share0_8_qe = &key_share0_8_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_8_gated_we;
  assign key_share0_8_gated_we = key_share0_8_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_8 (
    .re     (1'b0),
    .we     (key_share0_8_gated_we),
    .wd     (key_share0_8_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_8_flds_we[0]),
    .q      (reg2hw.key_share0[8].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[8].qe = key_share0_8_qe;


  // Subregister 9 of Multireg key_share0
  // R[key_share0_9]: V(True)
  logic key_share0_9_qe;
  logic [0:0] key_share0_9_flds_we;
  assign key_share0_9_qe = &key_share0_9_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_9_gated_we;
  assign key_share0_9_gated_we = key_share0_9_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_9 (
    .re     (1'b0),
    .we     (key_share0_9_gated_we),
    .wd     (key_share0_9_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_9_flds_we[0]),
    .q      (reg2hw.key_share0[9].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[9].qe = key_share0_9_qe;


  // Subregister 10 of Multireg key_share0
  // R[key_share0_10]: V(True)
  logic key_share0_10_qe;
  logic [0:0] key_share0_10_flds_we;
  assign key_share0_10_qe = &key_share0_10_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_10_gated_we;
  assign key_share0_10_gated_we = key_share0_10_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_10 (
    .re     (1'b0),
    .we     (key_share0_10_gated_we),
    .wd     (key_share0_10_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_10_flds_we[0]),
    .q      (reg2hw.key_share0[10].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[10].qe = key_share0_10_qe;


  // Subregister 11 of Multireg key_share0
  // R[key_share0_11]: V(True)
  logic key_share0_11_qe;
  logic [0:0] key_share0_11_flds_we;
  assign key_share0_11_qe = &key_share0_11_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_11_gated_we;
  assign key_share0_11_gated_we = key_share0_11_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_11 (
    .re     (1'b0),
    .we     (key_share0_11_gated_we),
    .wd     (key_share0_11_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_11_flds_we[0]),
    .q      (reg2hw.key_share0[11].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[11].qe = key_share0_11_qe;


  // Subregister 12 of Multireg key_share0
  // R[key_share0_12]: V(True)
  logic key_share0_12_qe;
  logic [0:0] key_share0_12_flds_we;
  assign key_share0_12_qe = &key_share0_12_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_12_gated_we;
  assign key_share0_12_gated_we = key_share0_12_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_12 (
    .re     (1'b0),
    .we     (key_share0_12_gated_we),
    .wd     (key_share0_12_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_12_flds_we[0]),
    .q      (reg2hw.key_share0[12].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[12].qe = key_share0_12_qe;


  // Subregister 13 of Multireg key_share0
  // R[key_share0_13]: V(True)
  logic key_share0_13_qe;
  logic [0:0] key_share0_13_flds_we;
  assign key_share0_13_qe = &key_share0_13_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_13_gated_we;
  assign key_share0_13_gated_we = key_share0_13_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_13 (
    .re     (1'b0),
    .we     (key_share0_13_gated_we),
    .wd     (key_share0_13_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_13_flds_we[0]),
    .q      (reg2hw.key_share0[13].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[13].qe = key_share0_13_qe;


  // Subregister 14 of Multireg key_share0
  // R[key_share0_14]: V(True)
  logic key_share0_14_qe;
  logic [0:0] key_share0_14_flds_we;
  assign key_share0_14_qe = &key_share0_14_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_14_gated_we;
  assign key_share0_14_gated_we = key_share0_14_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_14 (
    .re     (1'b0),
    .we     (key_share0_14_gated_we),
    .wd     (key_share0_14_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_14_flds_we[0]),
    .q      (reg2hw.key_share0[14].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[14].qe = key_share0_14_qe;


  // Subregister 15 of Multireg key_share0
  // R[key_share0_15]: V(True)
  logic key_share0_15_qe;
  logic [0:0] key_share0_15_flds_we;
  assign key_share0_15_qe = &key_share0_15_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_15_gated_we;
  assign key_share0_15_gated_we = key_share0_15_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_15 (
    .re     (1'b0),
    .we     (key_share0_15_gated_we),
    .wd     (key_share0_15_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_15_flds_we[0]),
    .q      (reg2hw.key_share0[15].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[15].qe = key_share0_15_qe;


  // Subregister 0 of Multireg key_share1
  // R[key_share1_0]: V(True)
  logic key_share1_0_qe;
  logic [0:0] key_share1_0_flds_we;
  assign key_share1_0_qe = &key_share1_0_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_0_gated_we;
  assign key_share1_0_gated_we = key_share1_0_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_0 (
    .re     (1'b0),
    .we     (key_share1_0_gated_we),
    .wd     (key_share1_0_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_0_flds_we[0]),
    .q      (reg2hw.key_share1[0].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[0].qe = key_share1_0_qe;


  // Subregister 1 of Multireg key_share1
  // R[key_share1_1]: V(True)
  logic key_share1_1_qe;
  logic [0:0] key_share1_1_flds_we;
  assign key_share1_1_qe = &key_share1_1_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_1_gated_we;
  assign key_share1_1_gated_we = key_share1_1_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_1 (
    .re     (1'b0),
    .we     (key_share1_1_gated_we),
    .wd     (key_share1_1_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_1_flds_we[0]),
    .q      (reg2hw.key_share1[1].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[1].qe = key_share1_1_qe;


  // Subregister 2 of Multireg key_share1
  // R[key_share1_2]: V(True)
  logic key_share1_2_qe;
  logic [0:0] key_share1_2_flds_we;
  assign key_share1_2_qe = &key_share1_2_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_2_gated_we;
  assign key_share1_2_gated_we = key_share1_2_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_2 (
    .re     (1'b0),
    .we     (key_share1_2_gated_we),
    .wd     (key_share1_2_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_2_flds_we[0]),
    .q      (reg2hw.key_share1[2].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[2].qe = key_share1_2_qe;


  // Subregister 3 of Multireg key_share1
  // R[key_share1_3]: V(True)
  logic key_share1_3_qe;
  logic [0:0] key_share1_3_flds_we;
  assign key_share1_3_qe = &key_share1_3_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_3_gated_we;
  assign key_share1_3_gated_we = key_share1_3_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_3 (
    .re     (1'b0),
    .we     (key_share1_3_gated_we),
    .wd     (key_share1_3_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_3_flds_we[0]),
    .q      (reg2hw.key_share1[3].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[3].qe = key_share1_3_qe;


  // Subregister 4 of Multireg key_share1
  // R[key_share1_4]: V(True)
  logic key_share1_4_qe;
  logic [0:0] key_share1_4_flds_we;
  assign key_share1_4_qe = &key_share1_4_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_4_gated_we;
  assign key_share1_4_gated_we = key_share1_4_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_4 (
    .re     (1'b0),
    .we     (key_share1_4_gated_we),
    .wd     (key_share1_4_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_4_flds_we[0]),
    .q      (reg2hw.key_share1[4].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[4].qe = key_share1_4_qe;


  // Subregister 5 of Multireg key_share1
  // R[key_share1_5]: V(True)
  logic key_share1_5_qe;
  logic [0:0] key_share1_5_flds_we;
  assign key_share1_5_qe = &key_share1_5_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_5_gated_we;
  assign key_share1_5_gated_we = key_share1_5_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_5 (
    .re     (1'b0),
    .we     (key_share1_5_gated_we),
    .wd     (key_share1_5_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_5_flds_we[0]),
    .q      (reg2hw.key_share1[5].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[5].qe = key_share1_5_qe;


  // Subregister 6 of Multireg key_share1
  // R[key_share1_6]: V(True)
  logic key_share1_6_qe;
  logic [0:0] key_share1_6_flds_we;
  assign key_share1_6_qe = &key_share1_6_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_6_gated_we;
  assign key_share1_6_gated_we = key_share1_6_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_6 (
    .re     (1'b0),
    .we     (key_share1_6_gated_we),
    .wd     (key_share1_6_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_6_flds_we[0]),
    .q      (reg2hw.key_share1[6].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[6].qe = key_share1_6_qe;


  // Subregister 7 of Multireg key_share1
  // R[key_share1_7]: V(True)
  logic key_share1_7_qe;
  logic [0:0] key_share1_7_flds_we;
  assign key_share1_7_qe = &key_share1_7_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_7_gated_we;
  assign key_share1_7_gated_we = key_share1_7_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_7 (
    .re     (1'b0),
    .we     (key_share1_7_gated_we),
    .wd     (key_share1_7_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_7_flds_we[0]),
    .q      (reg2hw.key_share1[7].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[7].qe = key_share1_7_qe;


  // Subregister 8 of Multireg key_share1
  // R[key_share1_8]: V(True)
  logic key_share1_8_qe;
  logic [0:0] key_share1_8_flds_we;
  assign key_share1_8_qe = &key_share1_8_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_8_gated_we;
  assign key_share1_8_gated_we = key_share1_8_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_8 (
    .re     (1'b0),
    .we     (key_share1_8_gated_we),
    .wd     (key_share1_8_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_8_flds_we[0]),
    .q      (reg2hw.key_share1[8].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[8].qe = key_share1_8_qe;


  // Subregister 9 of Multireg key_share1
  // R[key_share1_9]: V(True)
  logic key_share1_9_qe;
  logic [0:0] key_share1_9_flds_we;
  assign key_share1_9_qe = &key_share1_9_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_9_gated_we;
  assign key_share1_9_gated_we = key_share1_9_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_9 (
    .re     (1'b0),
    .we     (key_share1_9_gated_we),
    .wd     (key_share1_9_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_9_flds_we[0]),
    .q      (reg2hw.key_share1[9].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[9].qe = key_share1_9_qe;


  // Subregister 10 of Multireg key_share1
  // R[key_share1_10]: V(True)
  logic key_share1_10_qe;
  logic [0:0] key_share1_10_flds_we;
  assign key_share1_10_qe = &key_share1_10_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_10_gated_we;
  assign key_share1_10_gated_we = key_share1_10_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_10 (
    .re     (1'b0),
    .we     (key_share1_10_gated_we),
    .wd     (key_share1_10_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_10_flds_we[0]),
    .q      (reg2hw.key_share1[10].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[10].qe = key_share1_10_qe;


  // Subregister 11 of Multireg key_share1
  // R[key_share1_11]: V(True)
  logic key_share1_11_qe;
  logic [0:0] key_share1_11_flds_we;
  assign key_share1_11_qe = &key_share1_11_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_11_gated_we;
  assign key_share1_11_gated_we = key_share1_11_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_11 (
    .re     (1'b0),
    .we     (key_share1_11_gated_we),
    .wd     (key_share1_11_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_11_flds_we[0]),
    .q      (reg2hw.key_share1[11].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[11].qe = key_share1_11_qe;


  // Subregister 12 of Multireg key_share1
  // R[key_share1_12]: V(True)
  logic key_share1_12_qe;
  logic [0:0] key_share1_12_flds_we;
  assign key_share1_12_qe = &key_share1_12_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_12_gated_we;
  assign key_share1_12_gated_we = key_share1_12_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_12 (
    .re     (1'b0),
    .we     (key_share1_12_gated_we),
    .wd     (key_share1_12_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_12_flds_we[0]),
    .q      (reg2hw.key_share1[12].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[12].qe = key_share1_12_qe;


  // Subregister 13 of Multireg key_share1
  // R[key_share1_13]: V(True)
  logic key_share1_13_qe;
  logic [0:0] key_share1_13_flds_we;
  assign key_share1_13_qe = &key_share1_13_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_13_gated_we;
  assign key_share1_13_gated_we = key_share1_13_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_13 (
    .re     (1'b0),
    .we     (key_share1_13_gated_we),
    .wd     (key_share1_13_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_13_flds_we[0]),
    .q      (reg2hw.key_share1[13].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[13].qe = key_share1_13_qe;


  // Subregister 14 of Multireg key_share1
  // R[key_share1_14]: V(True)
  logic key_share1_14_qe;
  logic [0:0] key_share1_14_flds_we;
  assign key_share1_14_qe = &key_share1_14_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_14_gated_we;
  assign key_share1_14_gated_we = key_share1_14_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_14 (
    .re     (1'b0),
    .we     (key_share1_14_gated_we),
    .wd     (key_share1_14_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_14_flds_we[0]),
    .q      (reg2hw.key_share1[14].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[14].qe = key_share1_14_qe;


  // Subregister 15 of Multireg key_share1
  // R[key_share1_15]: V(True)
  logic key_share1_15_qe;
  logic [0:0] key_share1_15_flds_we;
  assign key_share1_15_qe = &key_share1_15_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_15_gated_we;
  assign key_share1_15_gated_we = key_share1_15_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_15 (
    .re     (1'b0),
    .we     (key_share1_15_gated_we),
    .wd     (key_share1_15_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_15_flds_we[0]),
    .q      (reg2hw.key_share1[15].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[15].qe = key_share1_15_qe;


  // R[key_len]: V(False)
  // Create REGWEN-gated WE signal
  logic key_len_gated_we;
  assign key_len_gated_we = key_len_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (3),
    .SwAccess(prim_subreg_pkg::SwAccessWO),
    .RESVAL  (3'h0),
    .Mubi    (1'b0)
  ) u_key_len (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (key_len_gated_we),
    .wd     (key_len_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.key_len.q),
    .ds     (),

    // to register interface (read)
    .qs     ()
  );


  // Subregister 0 of Multireg prefix
  // R[prefix_0]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_0_gated_we;
  assign prefix_0_gated_we = prefix_0_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_0_gated_we),
    .wd     (prefix_0_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[0].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_0_qs)
  );


  // Subregister 1 of Multireg prefix
  // R[prefix_1]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_1_gated_we;
  assign prefix_1_gated_we = prefix_1_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_1_gated_we),
    .wd     (prefix_1_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[1].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_1_qs)
  );


  // Subregister 2 of Multireg prefix
  // R[prefix_2]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_2_gated_we;
  assign prefix_2_gated_we = prefix_2_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_2_gated_we),
    .wd     (prefix_2_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[2].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_2_qs)
  );


  // Subregister 3 of Multireg prefix
  // R[prefix_3]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_3_gated_we;
  assign prefix_3_gated_we = prefix_3_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_3_gated_we),
    .wd     (prefix_3_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[3].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_3_qs)
  );


  // Subregister 4 of Multireg prefix
  // R[prefix_4]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_4_gated_we;
  assign prefix_4_gated_we = prefix_4_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_4_gated_we),
    .wd     (prefix_4_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[4].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_4_qs)
  );


  // Subregister 5 of Multireg prefix
  // R[prefix_5]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_5_gated_we;
  assign prefix_5_gated_we = prefix_5_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_5_gated_we),
    .wd     (prefix_5_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[5].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_5_qs)
  );


  // Subregister 6 of Multireg prefix
  // R[prefix_6]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_6_gated_we;
  assign prefix_6_gated_we = prefix_6_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_6_gated_we),
    .wd     (prefix_6_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[6].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_6_qs)
  );


  // Subregister 7 of Multireg prefix
  // R[prefix_7]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_7_gated_we;
  assign prefix_7_gated_we = prefix_7_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_7_gated_we),
    .wd     (prefix_7_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[7].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_7_qs)
  );


  // Subregister 8 of Multireg prefix
  // R[prefix_8]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_8_gated_we;
  assign prefix_8_gated_we = prefix_8_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_8 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_8_gated_we),
    .wd     (prefix_8_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[8].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_8_qs)
  );


  // Subregister 9 of Multireg prefix
  // R[prefix_9]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_9_gated_we;
  assign prefix_9_gated_we = prefix_9_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_9 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_9_gated_we),
    .wd     (prefix_9_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[9].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_9_qs)
  );


  // Subregister 10 of Multireg prefix
  // R[prefix_10]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_10_gated_we;
  assign prefix_10_gated_we = prefix_10_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_10 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_10_gated_we),
    .wd     (prefix_10_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[10].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_10_qs)
  );


  // R[err_code]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_err_code (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.err_code.de),
    .d      (hw2reg.err_code.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (err_code_qs)
  );



  logic [56:0] addr_hit;
  always_comb begin
    addr_hit = '0;
    addr_hit[ 0] = (reg_addr == KMAC_INTR_STATE_OFFSET);
    addr_hit[ 1] = (reg_addr == KMAC_INTR_ENABLE_OFFSET);
    addr_hit[ 2] = (reg_addr == KMAC_INTR_TEST_OFFSET);
    addr_hit[ 3] = (reg_addr == KMAC_ALERT_TEST_OFFSET);
    addr_hit[ 4] = (reg_addr == KMAC_CFG_REGWEN_OFFSET);
    addr_hit[ 5] = (reg_addr == KMAC_CFG_SHADOWED_OFFSET);
    addr_hit[ 6] = (reg_addr == KMAC_CMD_OFFSET);
    addr_hit[ 7] = (reg_addr == KMAC_STATUS_OFFSET);
    addr_hit[ 8] = (reg_addr == KMAC_ENTROPY_PERIOD_OFFSET);
    addr_hit[ 9] = (reg_addr == KMAC_ENTROPY_REFRESH_HASH_CNT_OFFSET);
    addr_hit[10] = (reg_addr == KMAC_ENTROPY_REFRESH_THRESHOLD_SHADOWED_OFFSET);
    addr_hit[11] = (reg_addr == KMAC_ENTROPY_SEED_OFFSET);
    addr_hit[12] = (reg_addr == KMAC_KEY_SHARE0_0_OFFSET);
    addr_hit[13] = (reg_addr == KMAC_KEY_SHARE0_1_OFFSET);
    addr_hit[14] = (reg_addr == KMAC_KEY_SHARE0_2_OFFSET);
    addr_hit[15] = (reg_addr == KMAC_KEY_SHARE0_3_OFFSET);
    addr_hit[16] = (reg_addr == KMAC_KEY_SHARE0_4_OFFSET);
    addr_hit[17] = (reg_addr == KMAC_KEY_SHARE0_5_OFFSET);
    addr_hit[18] = (reg_addr == KMAC_KEY_SHARE0_6_OFFSET);
    addr_hit[19] = (reg_addr == KMAC_KEY_SHARE0_7_OFFSET);
    addr_hit[20] = (reg_addr == KMAC_KEY_SHARE0_8_OFFSET);
    addr_hit[21] = (reg_addr == KMAC_KEY_SHARE0_9_OFFSET);
    addr_hit[22] = (reg_addr == KMAC_KEY_SHARE0_10_OFFSET);
    addr_hit[23] = (reg_addr == KMAC_KEY_SHARE0_11_OFFSET);
    addr_hit[24] = (reg_addr == KMAC_KEY_SHARE0_12_OFFSET);
    addr_hit[25] = (reg_addr == KMAC_KEY_SHARE0_13_OFFSET);
    addr_hit[26] = (reg_addr == KMAC_KEY_SHARE0_14_OFFSET);
    addr_hit[27] = (reg_addr == KMAC_KEY_SHARE0_15_OFFSET);
    addr_hit[28] = (reg_addr == KMAC_KEY_SHARE1_0_OFFSET);
    addr_hit[29] = (reg_addr == KMAC_KEY_SHARE1_1_OFFSET);
    addr_hit[30] = (reg_addr == KMAC_KEY_SHARE1_2_OFFSET);
    addr_hit[31] = (reg_addr == KMAC_KEY_SHARE1_3_OFFSET);
    addr_hit[32] = (reg_addr == KMAC_KEY_SHARE1_4_OFFSET);
    addr_hit[33] = (reg_addr == KMAC_KEY_SHARE1_5_OFFSET);
    addr_hit[34] = (reg_addr == KMAC_KEY_SHARE1_6_OFFSET);
    addr_hit[35] = (reg_addr == KMAC_KEY_SHARE1_7_OFFSET);
    addr_hit[36] = (reg_addr == KMAC_KEY_SHARE1_8_OFFSET);
    addr_hit[37] = (reg_addr == KMAC_KEY_SHARE1_9_OFFSET);
    addr_hit[38] = (reg_addr == KMAC_KEY_SHARE1_10_OFFSET);
    addr_hit[39] = (reg_addr == KMAC_KEY_SHARE1_11_OFFSET);
    addr_hit[40] = (reg_addr == KMAC_KEY_SHARE1_12_OFFSET);
    addr_hit[41] = (reg_addr == KMAC_KEY_SHARE1_13_OFFSET);
    addr_hit[42] = (reg_addr == KMAC_KEY_SHARE1_14_OFFSET);
    addr_hit[43] = (reg_addr == KMAC_KEY_SHARE1_15_OFFSET);
    addr_hit[44] = (reg_addr == KMAC_KEY_LEN_OFFSET);
    addr_hit[45] = (reg_addr == KMAC_PREFIX_0_OFFSET);
    addr_hit[46] = (reg_addr == KMAC_PREFIX_1_OFFSET);
    addr_hit[47] = (reg_addr == KMAC_PREFIX_2_OFFSET);
    addr_hit[48] = (reg_addr == KMAC_PREFIX_3_OFFSET);
    addr_hit[49] = (reg_addr == KMAC_PREFIX_4_OFFSET);
    addr_hit[50] = (reg_addr == KMAC_PREFIX_5_OFFSET);
    addr_hit[51] = (reg_addr == KMAC_PREFIX_6_OFFSET);
    addr_hit[52] = (reg_addr == KMAC_PREFIX_7_OFFSET);
    addr_hit[53] = (reg_addr == KMAC_PREFIX_8_OFFSET);
    addr_hit[54] = (reg_addr == KMAC_PREFIX_9_OFFSET);
    addr_hit[55] = (reg_addr == KMAC_PREFIX_10_OFFSET);
    addr_hit[56] = (reg_addr == KMAC_ERR_CODE_OFFSET);
  end

  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;

  // Check sub-word write is permitted
  always_comb begin
    wr_err = (reg_we &
              ((addr_hit[ 0] & (|(KMAC_PERMIT[ 0] & ~reg_be))) |
               (addr_hit[ 1] & (|(KMAC_PERMIT[ 1] & ~reg_be))) |
               (addr_hit[ 2] & (|(KMAC_PERMIT[ 2] & ~reg_be))) |
               (addr_hit[ 3] & (|(KMAC_PERMIT[ 3] & ~reg_be))) |
               (addr_hit[ 4] & (|(KMAC_PERMIT[ 4] & ~reg_be))) |
               (addr_hit[ 5] & (|(KMAC_PERMIT[ 5] & ~reg_be))) |
               (addr_hit[ 6] & (|(KMAC_PERMIT[ 6] & ~reg_be))) |
               (addr_hit[ 7] & (|(KMAC_PERMIT[ 7] & ~reg_be))) |
               (addr_hit[ 8] & (|(KMAC_PERMIT[ 8] & ~reg_be))) |
               (addr_hit[ 9] & (|(KMAC_PERMIT[ 9] & ~reg_be))) |
               (addr_hit[10] & (|(KMAC_PERMIT[10] & ~reg_be))) |
               (addr_hit[11] & (|(KMAC_PERMIT[11] & ~reg_be))) |
               (addr_hit[12] & (|(KMAC_PERMIT[12] & ~reg_be))) |
               (addr_hit[13] & (|(KMAC_PERMIT[13] & ~reg_be))) |
               (addr_hit[14] & (|(KMAC_PERMIT[14] & ~reg_be))) |
               (addr_hit[15] & (|(KMAC_PERMIT[15] & ~reg_be))) |
               (addr_hit[16] & (|(KMAC_PERMIT[16] & ~reg_be))) |
               (addr_hit[17] & (|(KMAC_PERMIT[17] & ~reg_be))) |
               (addr_hit[18] & (|(KMAC_PERMIT[18] & ~reg_be))) |
               (addr_hit[19] & (|(KMAC_PERMIT[19] & ~reg_be))) |
               (addr_hit[20] & (|(KMAC_PERMIT[20] & ~reg_be))) |
               (addr_hit[21] & (|(KMAC_PERMIT[21] & ~reg_be))) |
               (addr_hit[22] & (|(KMAC_PERMIT[22] & ~reg_be))) |
               (addr_hit[23] & (|(KMAC_PERMIT[23] & ~reg_be))) |
               (addr_hit[24] & (|(KMAC_PERMIT[24] & ~reg_be))) |
               (addr_hit[25] & (|(KMAC_PERMIT[25] & ~reg_be))) |
               (addr_hit[26] & (|(KMAC_PERMIT[26] & ~reg_be))) |
               (addr_hit[27] & (|(KMAC_PERMIT[27] & ~reg_be))) |
               (addr_hit[28] & (|(KMAC_PERMIT[28] & ~reg_be))) |
               (addr_hit[29] & (|(KMAC_PERMIT[29] & ~reg_be))) |
               (addr_hit[30] & (|(KMAC_PERMIT[30] & ~reg_be))) |
               (addr_hit[31] & (|(KMAC_PERMIT[31] & ~reg_be))) |
               (addr_hit[32] & (|(KMAC_PERMIT[32] & ~reg_be))) |
               (addr_hit[33] & (|(KMAC_PERMIT[33] & ~reg_be))) |
               (addr_hit[34] & (|(KMAC_PERMIT[34] & ~reg_be))) |
               (addr_hit[35] & (|(KMAC_PERMIT[35] & ~reg_be))) |
               (addr_hit[36] & (|(KMAC_PERMIT[36] & ~reg_be))) |
               (addr_hit[37] & (|(KMAC_PERMIT[37] & ~reg_be))) |
               (addr_hit[38] & (|(KMAC_PERMIT[38] & ~reg_be))) |
               (addr_hit[39] & (|(KMAC_PERMIT[39] & ~reg_be))) |
               (addr_hit[40] & (|(KMAC_PERMIT[40] & ~reg_be))) |
               (addr_hit[41] & (|(KMAC_PERMIT[41] & ~reg_be))) |
               (addr_hit[42] & (|(KMAC_PERMIT[42] & ~reg_be))) |
               (addr_hit[43] & (|(KMAC_PERMIT[43] & ~reg_be))) |
               (addr_hit[44] & (|(KMAC_PERMIT[44] & ~reg_be))) |
               (addr_hit[45] & (|(KMAC_PERMIT[45] & ~reg_be))) |
               (addr_hit[46] & (|(KMAC_PERMIT[46] & ~reg_be))) |
               (addr_hit[47] & (|(KMAC_PERMIT[47] & ~reg_be))) |
               (addr_hit[48] & (|(KMAC_PERMIT[48] & ~reg_be))) |
               (addr_hit[49] & (|(KMAC_PERMIT[49] & ~reg_be))) |
               (addr_hit[50] & (|(KMAC_PERMIT[50] & ~reg_be))) |
               (addr_hit[51] & (|(KMAC_PERMIT[51] & ~reg_be))) |
               (addr_hit[52] & (|(KMAC_PERMIT[52] & ~reg_be))) |
               (addr_hit[53] & (|(KMAC_PERMIT[53] & ~reg_be))) |
               (addr_hit[54] & (|(KMAC_PERMIT[54] & ~reg_be))) |
               (addr_hit[55] & (|(KMAC_PERMIT[55] & ~reg_be))) |
               (addr_hit[56] & (|(KMAC_PERMIT[56] & ~reg_be)))));
  end

  // Generate write-enables
  assign intr_state_we = addr_hit[0] & reg_we & !reg_error;

  assign intr_state_kmac_done_wd = reg_wdata[0];

  assign intr_state_kmac_err_wd = reg_wdata[2];
  assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;

  assign intr_enable_kmac_done_wd = reg_wdata[0];

  assign intr_enable_fifo_empty_wd = reg_wdata[1];

  assign intr_enable_kmac_err_wd = reg_wdata[2];
  assign intr_test_we = addr_hit[2] & reg_we & !reg_error;

  assign intr_test_kmac_done_wd = reg_wdata[0];

  assign intr_test_fifo_empty_wd = reg_wdata[1];

  assign intr_test_kmac_err_wd = reg_wdata[2];
  assign alert_test_we = addr_hit[3] & reg_we & !reg_error;

  assign alert_test_recov_operation_err_wd = reg_wdata[0];

  assign alert_test_fatal_fault_err_wd = reg_wdata[1];
  assign cfg_regwen_re = addr_hit[4] & reg_re & !reg_error;
  assign cfg_shadowed_re = addr_hit[5] & reg_re & !reg_error;
  assign cfg_shadowed_we = addr_hit[5] & reg_we & !reg_error;

  assign cfg_shadowed_kmac_en_wd = reg_wdata[0];

  assign cfg_shadowed_kstrength_wd = reg_wdata[3:1];

  assign cfg_shadowed_mode_wd = reg_wdata[5:4];

  assign cfg_shadowed_msg_endianness_wd = reg_wdata[8];

  assign cfg_shadowed_state_endianness_wd = reg_wdata[9];

  assign cfg_shadowed_sideload_wd = reg_wdata[12];

  assign cfg_shadowed_entropy_mode_wd = reg_wdata[17:16];

  assign cfg_shadowed_entropy_fast_process_wd = reg_wdata[19];

  assign cfg_shadowed_msg_mask_wd = reg_wdata[20];

  assign cfg_shadowed_entropy_ready_wd = reg_wdata[24];

  assign cfg_shadowed_en_unsupported_modestrength_wd = reg_wdata[26];
  assign cmd_we = addr_hit[6] & reg_we & !reg_error;

  assign cmd_cmd_wd = reg_wdata[5:0];

  assign cmd_entropy_req_wd = reg_wdata[8];

  assign cmd_hash_cnt_clr_wd = reg_wdata[9];

  assign cmd_err_processed_wd = reg_wdata[10];
  assign status_re = addr_hit[7] & reg_re & !reg_error;
  assign entropy_period_we = addr_hit[8] & reg_we & !reg_error;

  assign entropy_period_prescaler_wd = reg_wdata[9:0];

  assign entropy_period_wait_timer_wd = reg_wdata[31:16];
  assign entropy_refresh_threshold_shadowed_re = addr_hit[10] & reg_re & !reg_error;
  assign entropy_refresh_threshold_shadowed_we = addr_hit[10] & reg_we & !reg_error;

  assign entropy_refresh_threshold_shadowed_wd = reg_wdata[9:0];
  assign entropy_seed_we = addr_hit[11] & reg_we & !reg_error;

  assign entropy_seed_wd = reg_wdata[31:0];
  assign key_share0_0_we = addr_hit[12] & reg_we & !reg_error;

  assign key_share0_0_wd = reg_wdata[31:0];
  assign key_share0_1_we = addr_hit[13] & reg_we & !reg_error;

  assign key_share0_1_wd = reg_wdata[31:0];
  assign key_share0_2_we = addr_hit[14] & reg_we & !reg_error;

  assign key_share0_2_wd = reg_wdata[31:0];
  assign key_share0_3_we = addr_hit[15] & reg_we & !reg_error;

  assign key_share0_3_wd = reg_wdata[31:0];
  assign key_share0_4_we = addr_hit[16] & reg_we & !reg_error;

  assign key_share0_4_wd = reg_wdata[31:0];
  assign key_share0_5_we = addr_hit[17] & reg_we & !reg_error;

  assign key_share0_5_wd = reg_wdata[31:0];
  assign key_share0_6_we = addr_hit[18] & reg_we & !reg_error;

  assign key_share0_6_wd = reg_wdata[31:0];
  assign key_share0_7_we = addr_hit[19] & reg_we & !reg_error;

  assign key_share0_7_wd = reg_wdata[31:0];
  assign key_share0_8_we = addr_hit[20] & reg_we & !reg_error;

  assign key_share0_8_wd = reg_wdata[31:0];
  assign key_share0_9_we = addr_hit[21] & reg_we & !reg_error;

  assign key_share0_9_wd = reg_wdata[31:0];
  assign key_share0_10_we = addr_hit[22] & reg_we & !reg_error;

  assign key_share0_10_wd = reg_wdata[31:0];
  assign key_share0_11_we = addr_hit[23] & reg_we & !reg_error;

  assign key_share0_11_wd = reg_wdata[31:0];
  assign key_share0_12_we = addr_hit[24] & reg_we & !reg_error;

  assign key_share0_12_wd = reg_wdata[31:0];
  assign key_share0_13_we = addr_hit[25] & reg_we & !reg_error;

  assign key_share0_13_wd = reg_wdata[31:0];
  assign key_share0_14_we = addr_hit[26] & reg_we & !reg_error;

  assign key_share0_14_wd = reg_wdata[31:0];
  assign key_share0_15_we = addr_hit[27] & reg_we & !reg_error;

  assign key_share0_15_wd = reg_wdata[31:0];
  assign key_share1_0_we = addr_hit[28] & reg_we & !reg_error;

  assign key_share1_0_wd = reg_wdata[31:0];
  assign key_share1_1_we = addr_hit[29] & reg_we & !reg_error;

  assign key_share1_1_wd = reg_wdata[31:0];
  assign key_share1_2_we = addr_hit[30] & reg_we & !reg_error;

  assign key_share1_2_wd = reg_wdata[31:0];
  assign key_share1_3_we = addr_hit[31] & reg_we & !reg_error;

  assign key_share1_3_wd = reg_wdata[31:0];
  assign key_share1_4_we = addr_hit[32] & reg_we & !reg_error;

  assign key_share1_4_wd = reg_wdata[31:0];
  assign key_share1_5_we = addr_hit[33] & reg_we & !reg_error;

  assign key_share1_5_wd = reg_wdata[31:0];
  assign key_share1_6_we = addr_hit[34] & reg_we & !reg_error;

  assign key_share1_6_wd = reg_wdata[31:0];
  assign key_share1_7_we = addr_hit[35] & reg_we & !reg_error;

  assign key_share1_7_wd = reg_wdata[31:0];
  assign key_share1_8_we = addr_hit[36] & reg_we & !reg_error;

  assign key_share1_8_wd = reg_wdata[31:0];
  assign key_share1_9_we = addr_hit[37] & reg_we & !reg_error;

  assign key_share1_9_wd = reg_wdata[31:0];
  assign key_share1_10_we = addr_hit[38] & reg_we & !reg_error;

  assign key_share1_10_wd = reg_wdata[31:0];
  assign key_share1_11_we = addr_hit[39] & reg_we & !reg_error;

  assign key_share1_11_wd = reg_wdata[31:0];
  assign key_share1_12_we = addr_hit[40] & reg_we & !reg_error;

  assign key_share1_12_wd = reg_wdata[31:0];
  assign key_share1_13_we = addr_hit[41] & reg_we & !reg_error;

  assign key_share1_13_wd = reg_wdata[31:0];
  assign key_share1_14_we = addr_hit[42] & reg_we & !reg_error;

  assign key_share1_14_wd = reg_wdata[31:0];
  assign key_share1_15_we = addr_hit[43] & reg_we & !reg_error;

  assign key_share1_15_wd = reg_wdata[31:0];
  assign key_len_we = addr_hit[44] & reg_we & !reg_error;

  assign key_len_wd = reg_wdata[2:0];
  assign prefix_0_we = addr_hit[45] & reg_we & !reg_error;

  assign prefix_0_wd = reg_wdata[31:0];
  assign prefix_1_we = addr_hit[46] & reg_we & !reg_error;

  assign prefix_1_wd = reg_wdata[31:0];
  assign prefix_2_we = addr_hit[47] & reg_we & !reg_error;

  assign prefix_2_wd = reg_wdata[31:0];
  assign prefix_3_we = addr_hit[48] & reg_we & !reg_error;

  assign prefix_3_wd = reg_wdata[31:0];
  assign prefix_4_we = addr_hit[49] & reg_we & !reg_error;

  assign prefix_4_wd = reg_wdata[31:0];
  assign prefix_5_we = addr_hit[50] & reg_we & !reg_error;

  assign prefix_5_wd = reg_wdata[31:0];
  assign prefix_6_we = addr_hit[51] & reg_we & !reg_error;

  assign prefix_6_wd = reg_wdata[31:0];
  assign prefix_7_we = addr_hit[52] & reg_we & !reg_error;

  assign prefix_7_wd = reg_wdata[31:0];
  assign prefix_8_we = addr_hit[53] & reg_we & !reg_error;

  assign prefix_8_wd = reg_wdata[31:0];
  assign prefix_9_we = addr_hit[54] & reg_we & !reg_error;

  assign prefix_9_wd = reg_wdata[31:0];
  assign prefix_10_we = addr_hit[55] & reg_we & !reg_error;

  assign prefix_10_wd = reg_wdata[31:0];

  // Assign write-enables to checker logic vector.
  always_comb begin
    reg_we_check = '0;
    reg_we_check[0] = intr_state_we;
    reg_we_check[1] = intr_enable_we;
    reg_we_check[2] = intr_test_we;
    reg_we_check[3] = alert_test_we;
    reg_we_check[4] = 1'b0;
    reg_we_check[5] = cfg_shadowed_gated_we;
    reg_we_check[6] = cmd_we;
    reg_we_check[7] = 1'b0;
    reg_we_check[8] = entropy_period_gated_we;
    reg_we_check[9] = 1'b0;
    reg_we_check[10] = entropy_refresh_threshold_shadowed_gated_we;
    reg_we_check[11] = entropy_seed_we;
    reg_we_check[12] = key_share0_0_gated_we;
    reg_we_check[13] = key_share0_1_gated_we;
    reg_we_check[14] = key_share0_2_gated_we;
    reg_we_check[15] = key_share0_3_gated_we;
    reg_we_check[16] = key_share0_4_gated_we;
    reg_we_check[17] = key_share0_5_gated_we;
    reg_we_check[18] = key_share0_6_gated_we;
    reg_we_check[19] = key_share0_7_gated_we;
    reg_we_check[20] = key_share0_8_gated_we;
    reg_we_check[21] = key_share0_9_gated_we;
    reg_we_check[22] = key_share0_10_gated_we;
    reg_we_check[23] = key_share0_11_gated_we;
    reg_we_check[24] = key_share0_12_gated_we;
    reg_we_check[25] = key_share0_13_gated_we;
    reg_we_check[26] = key_share0_14_gated_we;
    reg_we_check[27] = key_share0_15_gated_we;
    reg_we_check[28] = key_share1_0_gated_we;
    reg_we_check[29] = key_share1_1_gated_we;
    reg_we_check[30] = key_share1_2_gated_we;
    reg_we_check[31] = key_share1_3_gated_we;
    reg_we_check[32] = key_share1_4_gated_we;
    reg_we_check[33] = key_share1_5_gated_we;
    reg_we_check[34] = key_share1_6_gated_we;
    reg_we_check[35] = key_share1_7_gated_we;
    reg_we_check[36] = key_share1_8_gated_we;
    reg_we_check[37] = key_share1_9_gated_we;
    reg_we_check[38] = key_share1_10_gated_we;
    reg_we_check[39] = key_share1_11_gated_we;
    reg_we_check[40] = key_share1_12_gated_we;
    reg_we_check[41] = key_share1_13_gated_we;
    reg_we_check[42] = key_share1_14_gated_we;
    reg_we_check[43] = key_share1_15_gated_we;
    reg_we_check[44] = key_len_gated_we;
    reg_we_check[45] = prefix_0_gated_we;
    reg_we_check[46] = prefix_1_gated_we;
    reg_we_check[47] = prefix_2_gated_we;
    reg_we_check[48] = prefix_3_gated_we;
    reg_we_check[49] = prefix_4_gated_we;
    reg_we_check[50] = prefix_5_gated_we;
    reg_we_check[51] = prefix_6_gated_we;
    reg_we_check[52] = prefix_7_gated_we;
    reg_we_check[53] = prefix_8_gated_we;
    reg_we_check[54] = prefix_9_gated_we;
    reg_we_check[55] = prefix_10_gated_we;
    reg_we_check[56] = 1'b0;
  end

  // Read data return
  always_comb begin
    reg_rdata_next = '0;
    unique case (1'b1)
      addr_hit[0]: begin
        reg_rdata_next[0] = intr_state_kmac_done_qs;
        reg_rdata_next[1] = intr_state_fifo_empty_qs;
        reg_rdata_next[2] = intr_state_kmac_err_qs;
      end

      addr_hit[1]: begin
        reg_rdata_next[0] = intr_enable_kmac_done_qs;
        reg_rdata_next[1] = intr_enable_fifo_empty_qs;
        reg_rdata_next[2] = intr_enable_kmac_err_qs;
      end

      addr_hit[2]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
        reg_rdata_next[2] = '0;
      end

      addr_hit[3]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
      end

      addr_hit[4]: begin
        reg_rdata_next[0] = cfg_regwen_qs;
      end

      addr_hit[5]: begin
        reg_rdata_next[0] = cfg_shadowed_kmac_en_qs;
        reg_rdata_next[3:1] = cfg_shadowed_kstrength_qs;
        reg_rdata_next[5:4] = cfg_shadowed_mode_qs;
        reg_rdata_next[8] = cfg_shadowed_msg_endianness_qs;
        reg_rdata_next[9] = cfg_shadowed_state_endianness_qs;
        reg_rdata_next[12] = cfg_shadowed_sideload_qs;
        reg_rdata_next[17:16] = cfg_shadowed_entropy_mode_qs;
        reg_rdata_next[19] = cfg_shadowed_entropy_fast_process_qs;
        reg_rdata_next[20] = cfg_shadowed_msg_mask_qs;
        reg_rdata_next[24] = cfg_shadowed_entropy_ready_qs;
        reg_rdata_next[26] = cfg_shadowed_en_unsupported_modestrength_qs;
      end

      addr_hit[6]: begin
        reg_rdata_next[5:0] = '0;
        reg_rdata_next[8] = '0;
        reg_rdata_next[9] = '0;
        reg_rdata_next[10] = '0;
      end

      addr_hit[7]: begin
        reg_rdata_next[0] = status_sha3_idle_qs;
        reg_rdata_next[1] = status_sha3_absorb_qs;
        reg_rdata_next[2] = status_sha3_squeeze_qs;
        reg_rdata_next[12:8] = status_fifo_depth_qs;
        reg_rdata_next[14] = status_fifo_empty_qs;
        reg_rdata_next[15] = status_fifo_full_qs;
        reg_rdata_next[16] = status_alert_fatal_fault_qs;
        reg_rdata_next[17] = status_alert_recov_ctrl_update_err_qs;
      end

      addr_hit[8]: begin
        reg_rdata_next[9:0] = entropy_period_prescaler_qs;
        reg_rdata_next[31:16] = entropy_period_wait_timer_qs;
      end

      addr_hit[9]: begin
        reg_rdata_next[9:0] = entropy_refresh_hash_cnt_qs;
      end

      addr_hit[10]: begin
        reg_rdata_next[9:0] = entropy_refresh_threshold_shadowed_qs;
      end

      addr_hit[11]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[12]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[13]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[14]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[15]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[16]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[17]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[18]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[19]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[20]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[21]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[22]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[23]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[24]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[25]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[26]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[27]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[28]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[29]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[30]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[31]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[32]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[33]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[34]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[35]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[36]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[37]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[38]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[39]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[40]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[41]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[42]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[43]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[44]: begin
        reg_rdata_next[2:0] = '0;
      end

      addr_hit[45]: begin
        reg_rdata_next[31:0] = prefix_0_qs;
      end

      addr_hit[46]: begin
        reg_rdata_next[31:0] = prefix_1_qs;
      end

      addr_hit[47]: begin
        reg_rdata_next[31:0] = prefix_2_qs;
      end

      addr_hit[48]: begin
        reg_rdata_next[31:0] = prefix_3_qs;
      end

      addr_hit[49]: begin
        reg_rdata_next[31:0] = prefix_4_qs;
      end

      addr_hit[50]: begin
        reg_rdata_next[31:0] = prefix_5_qs;
      end

      addr_hit[51]: begin
        reg_rdata_next[31:0] = prefix_6_qs;
      end

      addr_hit[52]: begin
        reg_rdata_next[31:0] = prefix_7_qs;
      end

      addr_hit[53]: begin
        reg_rdata_next[31:0] = prefix_8_qs;
      end

      addr_hit[54]: begin
        reg_rdata_next[31:0] = prefix_9_qs;
      end

      addr_hit[55]: begin
        reg_rdata_next[31:0] = prefix_10_qs;
      end

      addr_hit[56]: begin
        reg_rdata_next[31:0] = err_code_qs;
      end

      default: begin
        reg_rdata_next = '1;
      end
    endcase
  end

  // shadow busy
  logic shadow_busy;
  logic rst_done;
  logic shadow_rst_done;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      rst_done <= '0;
    end else begin
      rst_done <= 1'b1;
    end
  end

  always_ff @(posedge clk_i or negedge rst_shadowed_ni) begin
    if (!rst_shadowed_ni) begin
      shadow_rst_done <= '0;
    end else begin
      shadow_rst_done <= 1'b1;
    end
  end

  // both shadow and normal resets have been released
  assign shadow_busy = ~(rst_done & shadow_rst_done);

  // Collect up storage and update errors
  assign shadowed_storage_err_o = |{
    cfg_shadowed_kmac_en_storage_err,
    cfg_shadowed_kstrength_storage_err,
    cfg_shadowed_mode_storage_err,
    cfg_shadowed_msg_endianness_storage_err,
    cfg_shadowed_state_endianness_storage_err,
    cfg_shadowed_sideload_storage_err,
    cfg_shadowed_entropy_mode_storage_err,
    cfg_shadowed_entropy_fast_process_storage_err,
    cfg_shadowed_msg_mask_storage_err,
    cfg_shadowed_entropy_ready_storage_err,
    cfg_shadowed_en_unsupported_modestrength_storage_err,
    entropy_refresh_threshold_shadowed_storage_err
  };
  assign shadowed_update_err_o = |{
    cfg_shadowed_kmac_en_update_err,
    cfg_shadowed_kstrength_update_err,
    cfg_shadowed_mode_update_err,
    cfg_shadowed_msg_endianness_update_err,
    cfg_shadowed_state_endianness_update_err,
    cfg_shadowed_sideload_update_err,
    cfg_shadowed_entropy_mode_update_err,
    cfg_shadowed_entropy_fast_process_update_err,
    cfg_shadowed_msg_mask_update_err,
    cfg_shadowed_entropy_ready_update_err,
    cfg_shadowed_en_unsupported_modestrength_update_err,
    entropy_refresh_threshold_shadowed_update_err
  };

  // register busy
  assign reg_busy = shadow_busy;

  // Unused signal tieoff

  // wdata / byte enable are not always fully used
  // add a blanket unused statement to handle lint waivers
  logic unused_wdata;
  logic unused_be;
  assign unused_wdata = ^reg_wdata;
  assign unused_be = ^reg_be;

  // Assertions for Register Interface
  `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
  `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)

  `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)

  `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)

  // this is formulated as an assumption such that the FPV testbenches do disprove this
  // property by mistake
  //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)

endmodule

    '''

    Form relevant system verilog assertions for the RTL to be checked for.
    These system verilog assertions should be in a dict with the key as the name and the value as the assertion string.
    An example assertions object to be sent to assertion checker tool is as follows:

    assertions = {"assertion_p1":"property p1;\n    @(posedge clk) signal_A |-> signal_B;\nendproperty
assertion_p1: assert property (p1);", "assertion_p2":"property p2;\n    @(posedge clk) conditions |-> signal_C;\nendproperty\nassertion_p2: assert property (p2);"}

    Then run the assertions using the assertion checker tool. This tool call must include the assertions dictionary as an argument.
    From the output of the assertion checker tool, determine if there are security issues in the RTL.
    If there are no falsified assertions in the output from the assertion checker tool, that means there are no verified security issues in the RTL.

    
================================== Ai Message ==================================

[{'text': "I'll analyze the provided RTL code for security concerns related to register access control, privilege escalation, and shadowed register integrity. Let me create relevant assertions to check for these security issues.\n\nBased on the code, I can see this is a register top module for a KMAC (Keccak Message Authentication Code) hardware implementation. The module contains several security-critical elements including:\n\n1. Shadowed registers (for redundancy/protection)\n2. Register write-enable controls\n3. Integrity checking mechanisms\n4. Access control via REGWEN (register write enable)\n\nLet me create assertions to verify these security properties:", 'type': 'text'}, {'id': 'toolu_01MeM6GzqCAeRkeerA1A5urX', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_reg_top.sv', 'top_module': 'kmac_reg_top', 'assertions': {'assert_regwen_protects_cfg': 'property regwen_protects_cfg;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (cfg_shadowed_we && !cfg_regwen_qs) |-> !cfg_shadowed_gated_we;\nendproperty\nassert_regwen_protects_cfg: assert property(regwen_protects_cfg);', 'assert_regwen_protects_key_registers': 'property regwen_protects_key_registers;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (key_share0_0_we && !cfg_regwen_qs) |-> !key_share0_0_gated_we;\nendproperty\nassert_regwen_protects_key_registers: assert property(regwen_protects_key_registers);', 'assert_shadow_update_error_propagation': 'property shadow_update_error_propagation;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (cfg_shadowed_kmac_en_update_err || cfg_shadowed_kstrength_update_err) |-> ##[1:3] shadowed_update_err_o;\nendproperty\nassert_shadow_update_error_propagation: assert property(shadow_update_error_propagation);', 'assert_shadow_storage_error_propagation': 'property shadow_storage_error_propagation;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (cfg_shadowed_kmac_en_storage_err || cfg_shadowed_kstrength_storage_err) |-> ##[1:3] shadowed_storage_err_o;\nendproperty\nassert_shadow_storage_error_propagation: assert property(shadow_storage_error_propagation);', 'assert_integrity_error_propagation': 'property integrity_error_propagation;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (intg_err || reg_we_err) |-> ##[1:3] intg_err_o;\nendproperty\nassert_integrity_error_propagation: assert property(integrity_error_propagation);', 'assert_no_write_on_integrity_error': 'property no_write_on_integrity_error;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (intg_err && reg_we) |-> reg_error;\nendproperty\nassert_no_write_on_integrity_error: assert property(no_write_on_integrity_error);'}, 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01MeM6GzqCAeRkeerA1A5urX)
 Call ID: toolu_01MeM6GzqCAeRkeerA1A5urX
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_reg_top.sv
    top_module: kmac_reg_top
    assertions: {'assert_regwen_protects_cfg': 'property regwen_protects_cfg;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (cfg_shadowed_we && !cfg_regwen_qs) |-> !cfg_shadowed_gated_we;\nendproperty\nassert_regwen_protects_cfg: assert property(regwen_protects_cfg);', 'assert_regwen_protects_key_registers': 'property regwen_protects_key_registers;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (key_share0_0_we && !cfg_regwen_qs) |-> !key_share0_0_gated_we;\nendproperty\nassert_regwen_protects_key_registers: assert property(regwen_protects_key_registers);', 'assert_shadow_update_error_propagation': 'property shadow_update_error_propagation;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (cfg_shadowed_kmac_en_update_err || cfg_shadowed_kstrength_update_err) |-> ##[1:3] shadowed_update_err_o;\nendproperty\nassert_shadow_update_error_propagation: assert property(shadow_update_error_propagation);', 'assert_shadow_storage_error_propagation': 'property shadow_storage_error_propagation;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (cfg_shadowed_kmac_en_storage_err || cfg_shadowed_kstrength_storage_err) |-> ##[1:3] shadowed_storage_err_o;\nendproperty\nassert_shadow_storage_error_propagation: assert property(shadow_storage_error_propagation);', 'assert_integrity_error_propagation': 'property integrity_error_propagation;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (intg_err || reg_we_err) |-> ##[1:3] intg_err_o;\nendproperty\nassert_integrity_error_propagation: assert property(integrity_error_propagation);', 'assert_no_write_on_integrity_error': 'property no_write_on_integrity_error;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (intg_err && reg_we) |-> reg_error;\nendproperty\nassert_no_write_on_integrity_error: assert property(no_write_on_integrity_error);'}
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: assertion_checker_tool

Successfully executed:
```assertion checker tool
```
Output:
 The following properties were falsified:
property shadow_storage_error_propagation;
  @(posedge clk_i) disable iff (!rst_ni)
  (cfg_shadowed_kmac_en_storage_err || cfg_shadowed_kstrength_storage_err) |-> ##[1:3] shadowed_storage_err_o;
endproperty
assert_shadow_storage_error_propagation: assert property(shadow_storage_error_propagation);

property shadow_update_error_propagation;
  @(posedge clk_i) disable iff (!rst_ni)
  (cfg_shadowed_kmac_en_update_err || cfg_shadowed_kstrength_update_err) |-> ##[1:3] shadowed_update_err_o;
endproperty
assert_shadow_update_error_propagation: assert property(shadow_update_error_propagation);
================================== Ai Message ==================================

Based on the assertion checker results, I've identified security concerns in the provided RTL code. Let me explain the findings:

## Security Issues Found:

1. **Shadowed Register Error Propagation Issues**:
   - The assertions checking for proper propagation of shadow register errors were falsified.
   - Specifically, both `shadow_storage_error_propagation` and `shadow_update_error_propagation` assertions failed.
   - This indicates that errors detected in shadowed registers (like `cfg_shadowed_kmac_en_storage_err` or `cfg_shadowed_kstrength_update_err`) are not properly propagated to the error output signals within the expected time window.

2. **Potential Impact**:
   - Shadowed registers are a critical security mechanism used to detect fault injection attacks or hardware failures.
   - If errors in these registers aren't properly propagated, it could allow an attacker to manipulate security-critical configuration without detection.
   - This could lead to security bypass or privilege escalation, especially since these registers control security-sensitive functions like key handling and cryptographic operations.

## Secure Aspects:

The following security mechanisms appear to be working correctly:

1. **Register Write Enable Protection**: The assertions verifying that the REGWEN signal properly protects configuration registers passed.

2. **Integrity Error Propagation**: The integrity error propagation mechanism appears to be functioning correctly.

3. **Write Protection on Integrity Error**: The design correctly prevents writes when integrity errors are detected.

## Recommendation:

The RTL should be modified to ensure that shadow register errors are properly propagated to the error output signals. Specifically:

1. Review the logic in the shadowed register error collection section (around line 2000) to ensure all error signals are properly combined and propagated.

2. Ensure that the timing of error propagation is consistent and meets the expected window (within 1-3 clock cycles as specified in the assertions).

3. Consider adding additional monitoring or alert mechanisms to ensure that shadowed register errors cannot go undetected.

These issues could potentially allow an attacker to manipulate security-critical configuration without detection, which represents a significant security vulnerability in this cryptographic module.
================================= Tool Message =================================
Name: run_assertions_checker_agent

Based on the assertion checker results, I've identified security concerns in the provided RTL code. Let me explain the findings:

## Security Issues Found:

1. **Shadowed Register Error Propagation Issues**:
   - The assertions checking for proper propagation of shadow register errors were falsified.
   - Specifically, both `shadow_storage_error_propagation` and `shadow_update_error_propagation` assertions failed.
   - This indicates that errors detected in shadowed registers (like `cfg_shadowed_kmac_en_storage_err` or `cfg_shadowed_kstrength_update_err`) are not properly propagated to the error output signals within the expected time window.

2. **Potential Impact**:
   - Shadowed registers are a critical security mechanism used to detect fault injection attacks or hardware failures.
   - If errors in these registers aren't properly propagated, it could allow an attacker to manipulate security-critical configuration without detection.
   - This could lead to security bypass or privilege escalation, especially since these registers control security-sensitive functions like key handling and cryptographic operations.

## Secure Aspects:

The following security mechanisms appear to be working correctly:

1. **Register Write Enable Protection**: The assertions verifying that the REGWEN signal properly protects configuration registers passed.

2. **Integrity Error Propagation**: The integrity error propagation mechanism appears to be functioning correctly.

3. **Write Protection on Integrity Error**: The design correctly prevents writes when integrity errors are detected.

## Recommendation:

The RTL should be modified to ensure that shadow register errors are properly propagated to the error output signals. Specifically:

1. Review the logic in the shadowed register error collection section (around line 2000) to ensure all error signals are properly combined and propagated.

2. Ensure that the timing of error propagation is consistent and meets the expected window (within 1-3 clock cycles as specified in the assertions).

3. Consider adding additional monitoring or alert mechanisms to ensure that shadowed register errors cannot go undetected.

These issues could potentially allow an attacker to manipulate security-critical configuration without detection, which represents a significant security vulnerability in this cryptographic module.
================================== Ai Message ==================================
Tool Calls:
  run_linter_agent (call_4MXq22K9pFbejSCjq6rnA1EQ)
 Call ID: call_4MXq22K9pFbejSCjq6rnA1EQ
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_reg_top.sv
    top_module: kmac_reg_top
    security_objective: register access control, privilege escalation, shadowed register integrity
================================ Human Message =================================

Are there security concerns related to register access control, privilege escalation, shadowed register integrity in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_reg_top.sv

    And the top module is:

    kmac_reg_top

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Register Top module auto-generated by `reggen`

`include "prim_assert.sv"

module kmac_reg_top (
  input clk_i,
  input rst_ni,
  input rst_shadowed_ni,
  input  tlul_pkg::tl_h2d_t tl_i,
  output tlul_pkg::tl_d2h_t tl_o,

  // Output port for window
  output tlul_pkg::tl_h2d_t tl_win_o  [2],
  input  tlul_pkg::tl_d2h_t tl_win_i  [2],

  // To HW
  output kmac_reg_pkg::kmac_reg2hw_t reg2hw, // Write
  input  kmac_reg_pkg::kmac_hw2reg_t hw2reg, // Read

  output logic shadowed_storage_err_o,
  output logic shadowed_update_err_o,

  // Integrity check errors
  output logic intg_err_o
);

  import kmac_reg_pkg::* ;

  localparam int AW = 12;
  localparam int DW = 32;
  localparam int DBW = DW/8;                    // Byte Width

  // register signals
  logic           reg_we;
  logic           reg_re;
  logic [AW-1:0]  reg_addr;
  logic [DW-1:0]  reg_wdata;
  logic [DBW-1:0] reg_be;
  logic [DW-1:0]  reg_rdata;
  logic           reg_error;

  logic          addrmiss, wr_err;

  logic [DW-1:0] reg_rdata_next;
  logic reg_busy;

  tlul_pkg::tl_h2d_t tl_reg_h2d;
  tlul_pkg::tl_d2h_t tl_reg_d2h;


  // incoming payload check
  logic intg_err;
  tlul_cmd_intg_chk u_chk (
    .tl_i(tl_i),
    .err_o(intg_err)
  );

  // also check for spurious write enables
  logic reg_we_err;
  logic [56:0] reg_we_check;
  prim_reg_we_check #(
    .OneHotWidth(57)
  ) u_prim_reg_we_check (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .oh_i  (reg_we_check),
    .en_i  (reg_we && !addrmiss),
    .err_o (reg_we_err)
  );

  logic err_q;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      err_q <= '0;
    end else if (intg_err || reg_we_err) begin
      err_q <= 1'b1;
    end
  end

  // integrity error output is permanent and should be used for alert generation
  // register errors are transactional
  assign intg_err_o = err_q | intg_err | reg_we_err;

  // outgoing integrity generation
  tlul_pkg::tl_d2h_t tl_o_pre;
  tlul_rsp_intg_gen #(
    .EnableRspIntgGen(1),
    .EnableDataIntgGen(1)
  ) u_rsp_intg_gen (
    .tl_i(tl_o_pre),
    .tl_o(tl_o)
  );

  tlul_pkg::tl_h2d_t tl_socket_h2d [3];
  tlul_pkg::tl_d2h_t tl_socket_d2h [3];

  logic [1:0] reg_steer;

  // socket_1n connection
  assign tl_reg_h2d = tl_socket_h2d[2];
  assign tl_socket_d2h[2] = tl_reg_d2h;

  assign tl_win_o[0] = tl_socket_h2d[0];
  assign tl_socket_d2h[0] = tl_win_i[0];
  assign tl_win_o[1] = tl_socket_h2d[1];
  assign tl_socket_d2h[1] = tl_win_i[1];

  // Create Socket_1n
  tlul_socket_1n #(
    .N            (3),
    .HReqPass     (1'b1),
    .HRspPass     (1'b1),
    .DReqPass     ({3{1'b1}}),
    .DRspPass     ({3{1'b1}}),
    .HReqDepth    (4'h0),
    .HRspDepth    (4'h0),
    .DReqDepth    ({3{4'h0}}),
    .DRspDepth    ({3{4'h0}}),
    .ExplicitErrs (1'b0)
  ) u_socket (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),
    .tl_h_i (tl_i),
    .tl_h_o (tl_o_pre),
    .tl_d_o (tl_socket_h2d),
    .tl_d_i (tl_socket_d2h),
    .dev_select_i (reg_steer)
  );

  // Create steering logic
  always_comb begin
    reg_steer =
        tl_i.a_address[AW-1:0] inside {[1024:1535]} ? 2'd0 :
        tl_i.a_address[AW-1:0] inside {[2048:4095]} ? 2'd1 :
        // Default set to register
        2'd2;

    // Override this in case of an integrity error
    if (intg_err) begin
      reg_steer = 2'd2;
    end
  end

  tlul_adapter_reg #(
    .RegAw(AW),
    .RegDw(DW),
    .EnableDataIntgGen(0)
  ) u_reg_if (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),

    .tl_i (tl_reg_h2d),
    .tl_o (tl_reg_d2h),

    .en_ifetch_i(prim_mubi_pkg::MuBi4False),
    .intg_error_o(),

    .we_o    (reg_we),
    .re_o    (reg_re),
    .addr_o  (reg_addr),
    .wdata_o (reg_wdata),
    .be_o    (reg_be),
    .busy_i  (reg_busy),
    .rdata_i (reg_rdata),
    .error_i (reg_error)
  );

  // cdc oversampling signals

  assign reg_rdata = reg_rdata_next ;
  assign reg_error = addrmiss | wr_err | intg_err;

  // Define SW related signals
  // Format: <reg>_<field>_{wd|we|qs}
  //        or <reg>_{wd|we|qs} if field == 1 or 0
  logic intr_state_we;
  logic intr_state_kmac_done_qs;
  logic intr_state_kmac_done_wd;
  logic intr_state_fifo_empty_qs;
  logic intr_state_kmac_err_qs;
  logic intr_state_kmac_err_wd;
  logic intr_enable_we;
  logic intr_enable_kmac_done_qs;
  logic intr_enable_kmac_done_wd;
  logic intr_enable_fifo_empty_qs;
  logic intr_enable_fifo_empty_wd;
  logic intr_enable_kmac_err_qs;
  logic intr_enable_kmac_err_wd;
  logic intr_test_we;
  logic intr_test_kmac_done_wd;
  logic intr_test_fifo_empty_wd;
  logic intr_test_kmac_err_wd;
  logic alert_test_we;
  logic alert_test_recov_operation_err_wd;
  logic alert_test_fatal_fault_err_wd;
  logic cfg_regwen_re;
  logic cfg_regwen_qs;
  logic cfg_shadowed_re;
  logic cfg_shadowed_we;
  logic cfg_shadowed_kmac_en_qs;
  logic cfg_shadowed_kmac_en_wd;
  logic cfg_shadowed_kmac_en_storage_err;
  logic cfg_shadowed_kmac_en_update_err;
  logic [2:0] cfg_shadowed_kstrength_qs;
  logic [2:0] cfg_shadowed_kstrength_wd;
  logic cfg_shadowed_kstrength_storage_err;
  logic cfg_shadowed_kstrength_update_err;
  logic [1:0] cfg_shadowed_mode_qs;
  logic [1:0] cfg_shadowed_mode_wd;
  logic cfg_shadowed_mode_storage_err;
  logic cfg_shadowed_mode_update_err;
  logic cfg_shadowed_msg_endianness_qs;
  logic cfg_shadowed_msg_endianness_wd;
  logic cfg_shadowed_msg_endianness_storage_err;
  logic cfg_shadowed_msg_endianness_update_err;
  logic cfg_shadowed_state_endianness_qs;
  logic cfg_shadowed_state_endianness_wd;
  logic cfg_shadowed_state_endianness_storage_err;
  logic cfg_shadowed_state_endianness_update_err;
  logic cfg_shadowed_sideload_qs;
  logic cfg_shadowed_sideload_wd;
  logic cfg_shadowed_sideload_storage_err;
  logic cfg_shadowed_sideload_update_err;
  logic [1:0] cfg_shadowed_entropy_mode_qs;
  logic [1:0] cfg_shadowed_entropy_mode_wd;
  logic cfg_shadowed_entropy_mode_storage_err;
  logic cfg_shadowed_entropy_mode_update_err;
  logic cfg_shadowed_entropy_fast_process_qs;
  logic cfg_shadowed_entropy_fast_process_wd;
  logic cfg_shadowed_entropy_fast_process_storage_err;
  logic cfg_shadowed_entropy_fast_process_update_err;
  logic cfg_shadowed_msg_mask_qs;
  logic cfg_shadowed_msg_mask_wd;
  logic cfg_shadowed_msg_mask_storage_err;
  logic cfg_shadowed_msg_mask_update_err;
  logic cfg_shadowed_entropy_ready_qs;
  logic cfg_shadowed_entropy_ready_wd;
  logic cfg_shadowed_entropy_ready_storage_err;
  logic cfg_shadowed_entropy_ready_update_err;
  logic cfg_shadowed_en_unsupported_modestrength_qs;
  logic cfg_shadowed_en_unsupported_modestrength_wd;
  logic cfg_shadowed_en_unsupported_modestrength_storage_err;
  logic cfg_shadowed_en_unsupported_modestrength_update_err;
  logic cmd_we;
  logic [5:0] cmd_cmd_wd;
  logic cmd_entropy_req_wd;
  logic cmd_hash_cnt_clr_wd;
  logic cmd_err_processed_wd;
  logic status_re;
  logic status_sha3_idle_qs;
  logic status_sha3_absorb_qs;
  logic status_sha3_squeeze_qs;
  logic [4:0] status_fifo_depth_qs;
  logic status_fifo_empty_qs;
  logic status_fifo_full_qs;
  logic status_alert_fatal_fault_qs;
  logic status_alert_recov_ctrl_update_err_qs;
  logic entropy_period_we;
  logic [9:0] entropy_period_prescaler_qs;
  logic [9:0] entropy_period_prescaler_wd;
  logic [15:0] entropy_period_wait_timer_qs;
  logic [15:0] entropy_period_wait_timer_wd;
  logic [9:0] entropy_refresh_hash_cnt_qs;
  logic entropy_refresh_threshold_shadowed_re;
  logic entropy_refresh_threshold_shadowed_we;
  logic [9:0] entropy_refresh_threshold_shadowed_qs;
  logic [9:0] entropy_refresh_threshold_shadowed_wd;
  logic entropy_refresh_threshold_shadowed_storage_err;
  logic entropy_refresh_threshold_shadowed_update_err;
  logic entropy_seed_we;
  logic [31:0] entropy_seed_wd;
  logic key_share0_0_we;
  logic [31:0] key_share0_0_wd;
  logic key_share0_1_we;
  logic [31:0] key_share0_1_wd;
  logic key_share0_2_we;
  logic [31:0] key_share0_2_wd;
  logic key_share0_3_we;
  logic [31:0] key_share0_3_wd;
  logic key_share0_4_we;
  logic [31:0] key_share0_4_wd;
  logic key_share0_5_we;
  logic [31:0] key_share0_5_wd;
  logic key_share0_6_we;
  logic [31:0] key_share0_6_wd;
  logic key_share0_7_we;
  logic [31:0] key_share0_7_wd;
  logic key_share0_8_we;
  logic [31:0] key_share0_8_wd;
  logic key_share0_9_we;
  logic [31:0] key_share0_9_wd;
  logic key_share0_10_we;
  logic [31:0] key_share0_10_wd;
  logic key_share0_11_we;
  logic [31:0] key_share0_11_wd;
  logic key_share0_12_we;
  logic [31:0] key_share0_12_wd;
  logic key_share0_13_we;
  logic [31:0] key_share0_13_wd;
  logic key_share0_14_we;
  logic [31:0] key_share0_14_wd;
  logic key_share0_15_we;
  logic [31:0] key_share0_15_wd;
  logic key_share1_0_we;
  logic [31:0] key_share1_0_wd;
  logic key_share1_1_we;
  logic [31:0] key_share1_1_wd;
  logic key_share1_2_we;
  logic [31:0] key_share1_2_wd;
  logic key_share1_3_we;
  logic [31:0] key_share1_3_wd;
  logic key_share1_4_we;
  logic [31:0] key_share1_4_wd;
  logic key_share1_5_we;
  logic [31:0] key_share1_5_wd;
  logic key_share1_6_we;
  logic [31:0] key_share1_6_wd;
  logic key_share1_7_we;
  logic [31:0] key_share1_7_wd;
  logic key_share1_8_we;
  logic [31:0] key_share1_8_wd;
  logic key_share1_9_we;
  logic [31:0] key_share1_9_wd;
  logic key_share1_10_we;
  logic [31:0] key_share1_10_wd;
  logic key_share1_11_we;
  logic [31:0] key_share1_11_wd;
  logic key_share1_12_we;
  logic [31:0] key_share1_12_wd;
  logic key_share1_13_we;
  logic [31:0] key_share1_13_wd;
  logic key_share1_14_we;
  logic [31:0] key_share1_14_wd;
  logic key_share1_15_we;
  logic [31:0] key_share1_15_wd;
  logic key_len_we;
  logic [2:0] key_len_wd;
  logic prefix_0_we;
  logic [31:0] prefix_0_qs;
  logic [31:0] prefix_0_wd;
  logic prefix_1_we;
  logic [31:0] prefix_1_qs;
  logic [31:0] prefix_1_wd;
  logic prefix_2_we;
  logic [31:0] prefix_2_qs;
  logic [31:0] prefix_2_wd;
  logic prefix_3_we;
  logic [31:0] prefix_3_qs;
  logic [31:0] prefix_3_wd;
  logic prefix_4_we;
  logic [31:0] prefix_4_qs;
  logic [31:0] prefix_4_wd;
  logic prefix_5_we;
  logic [31:0] prefix_5_qs;
  logic [31:0] prefix_5_wd;
  logic prefix_6_we;
  logic [31:0] prefix_6_qs;
  logic [31:0] prefix_6_wd;
  logic prefix_7_we;
  logic [31:0] prefix_7_qs;
  logic [31:0] prefix_7_wd;
  logic prefix_8_we;
  logic [31:0] prefix_8_qs;
  logic [31:0] prefix_8_wd;
  logic prefix_9_we;
  logic [31:0] prefix_9_qs;
  logic [31:0] prefix_9_wd;
  logic prefix_10_we;
  logic [31:0] prefix_10_qs;
  logic [31:0] prefix_10_wd;
  logic [31:0] err_code_qs;

  // Register instances
  // R[intr_state]: V(False)
  //   F[kmac_done]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_kmac_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_kmac_done_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.kmac_done.de),
    .d      (hw2reg.intr_state.kmac_done.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.kmac_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_kmac_done_qs)
  );

  //   F[fifo_empty]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_fifo_empty (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.intr_state.fifo_empty.de),
    .d      (hw2reg.intr_state.fifo_empty.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.fifo_empty.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_fifo_empty_qs)
  );

  //   F[kmac_err]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_kmac_err (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_kmac_err_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.kmac_err.de),
    .d      (hw2reg.intr_state.kmac_err.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.kmac_err.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_kmac_err_qs)
  );


  // R[intr_enable]: V(False)
  //   F[kmac_done]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_kmac_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_kmac_done_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.kmac_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_kmac_done_qs)
  );

  //   F[fifo_empty]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_fifo_empty (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_fifo_empty_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.fifo_empty.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_fifo_empty_qs)
  );

  //   F[kmac_err]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_kmac_err (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_kmac_err_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.kmac_err.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_kmac_err_qs)
  );


  // R[intr_test]: V(True)
  logic intr_test_qe;
  logic [2:0] intr_test_flds_we;
  assign intr_test_qe = &intr_test_flds_we;
  //   F[kmac_done]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_kmac_done (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_kmac_done_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[0]),
    .q      (reg2hw.intr_test.kmac_done.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.kmac_done.qe = intr_test_qe;

  //   F[fifo_empty]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_fifo_empty (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_fifo_empty_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[1]),
    .q      (reg2hw.intr_test.fifo_empty.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.fifo_empty.qe = intr_test_qe;

  //   F[kmac_err]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_kmac_err (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_kmac_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[2]),
    .q      (reg2hw.intr_test.kmac_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.kmac_err.qe = intr_test_qe;


  // R[alert_test]: V(True)
  logic alert_test_qe;
  logic [1:0] alert_test_flds_we;
  assign alert_test_qe = &alert_test_flds_we;
  //   F[recov_operation_err]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_recov_operation_err (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_recov_operation_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[0]),
    .q      (reg2hw.alert_test.recov_operation_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.recov_operation_err.qe = alert_test_qe;

  //   F[fatal_fault_err]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_fatal_fault_err (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_fatal_fault_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[1]),
    .q      (reg2hw.alert_test.fatal_fault_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.fatal_fault_err.qe = alert_test_qe;


  // R[cfg_regwen]: V(True)
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_regwen (
    .re     (cfg_regwen_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.cfg_regwen.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (cfg_regwen_qs)
  );


  // R[cfg_shadowed]: V(False)
  logic cfg_shadowed_qe;
  logic [10:0] cfg_shadowed_flds_we;
  prim_flop #(
    .Width(1),
    .ResetValue(0)
  ) u_cfg_shadowed0_qe (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .d_i(&cfg_shadowed_flds_we),
    .q_o(cfg_shadowed_qe)
  );
  // Create REGWEN-gated WE signal
  logic cfg_shadowed_gated_we;
  assign cfg_shadowed_gated_we = cfg_shadowed_we & cfg_regwen_qs;
  //   F[kmac_en]: 0:0
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_kmac_en (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_kmac_en_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[0]),
    .q      (reg2hw.cfg_shadowed.kmac_en.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_kmac_en_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_kmac_en_update_err),
    .err_storage (cfg_shadowed_kmac_en_storage_err)
  );
  assign reg2hw.cfg_shadowed.kmac_en.qe = cfg_shadowed_qe;

  //   F[kstrength]: 3:1
  prim_subreg_shadow #(
    .DW      (3),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (3'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_kstrength (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_kstrength_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[1]),
    .q      (reg2hw.cfg_shadowed.kstrength.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_kstrength_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_kstrength_update_err),
    .err_storage (cfg_shadowed_kstrength_storage_err)
  );
  assign reg2hw.cfg_shadowed.kstrength.qe = cfg_shadowed_qe;

  //   F[mode]: 5:4
  prim_subreg_shadow #(
    .DW      (2),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (2'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_mode (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_mode_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[2]),
    .q      (reg2hw.cfg_shadowed.mode.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_mode_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_mode_update_err),
    .err_storage (cfg_shadowed_mode_storage_err)
  );
  assign reg2hw.cfg_shadowed.mode.qe = cfg_shadowed_qe;

  //   F[msg_endianness]: 8:8
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_msg_endianness (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_msg_endianness_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[3]),
    .q      (reg2hw.cfg_shadowed.msg_endianness.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_msg_endianness_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_msg_endianness_update_err),
    .err_storage (cfg_shadowed_msg_endianness_storage_err)
  );
  assign reg2hw.cfg_shadowed.msg_endianness.qe = cfg_shadowed_qe;

  //   F[state_endianness]: 9:9
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_state_endianness (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_state_endianness_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[4]),
    .q      (reg2hw.cfg_shadowed.state_endianness.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_state_endianness_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_state_endianness_update_err),
    .err_storage (cfg_shadowed_state_endianness_storage_err)
  );
  assign reg2hw.cfg_shadowed.state_endianness.qe = cfg_shadowed_qe;

  //   F[sideload]: 12:12
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_sideload (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_sideload_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[5]),
    .q      (reg2hw.cfg_shadowed.sideload.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_sideload_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_sideload_update_err),
    .err_storage (cfg_shadowed_sideload_storage_err)
  );
  assign reg2hw.cfg_shadowed.sideload.qe = cfg_shadowed_qe;

  //   F[entropy_mode]: 17:16
  prim_subreg_shadow #(
    .DW      (2),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (2'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_entropy_mode (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_entropy_mode_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[6]),
    .q      (reg2hw.cfg_shadowed.entropy_mode.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_entropy_mode_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_entropy_mode_update_err),
    .err_storage (cfg_shadowed_entropy_mode_storage_err)
  );
  assign reg2hw.cfg_shadowed.entropy_mode.qe = cfg_shadowed_qe;

  //   F[entropy_fast_process]: 19:19
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_entropy_fast_process (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_entropy_fast_process_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[7]),
    .q      (reg2hw.cfg_shadowed.entropy_fast_process.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_entropy_fast_process_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_entropy_fast_process_update_err),
    .err_storage (cfg_shadowed_entropy_fast_process_storage_err)
  );
  assign reg2hw.cfg_shadowed.entropy_fast_process.qe = cfg_shadowed_qe;

  //   F[msg_mask]: 20:20
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_msg_mask (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_msg_mask_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[8]),
    .q      (reg2hw.cfg_shadowed.msg_mask.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_msg_mask_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_msg_mask_update_err),
    .err_storage (cfg_shadowed_msg_mask_storage_err)
  );
  assign reg2hw.cfg_shadowed.msg_mask.qe = cfg_shadowed_qe;

  //   F[entropy_ready]: 24:24
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_entropy_ready (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_entropy_ready_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[9]),
    .q      (reg2hw.cfg_shadowed.entropy_ready.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_entropy_ready_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_entropy_ready_update_err),
    .err_storage (cfg_shadowed_entropy_ready_storage_err)
  );
  assign reg2hw.cfg_shadowed.entropy_ready.qe = cfg_shadowed_qe;

  //   F[en_unsupported_modestrength]: 26:26
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_en_unsupported_modestrength (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_en_unsupported_modestrength_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[10]),
    .q      (reg2hw.cfg_shadowed.en_unsupported_modestrength.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_en_unsupported_modestrength_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_en_unsupported_modestrength_update_err),
    .err_storage (cfg_shadowed_en_unsupported_modestrength_storage_err)
  );
  assign reg2hw.cfg_shadowed.en_unsupported_modestrength.qe = cfg_shadowed_qe;


  // R[cmd]: V(True)
  logic cmd_qe;
  logic [3:0] cmd_flds_we;
  assign cmd_qe = &cmd_flds_we;
  //   F[cmd]: 5:0
  prim_subreg_ext #(
    .DW    (6)
  ) u_cmd_cmd (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_cmd_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[0]),
    .q      (reg2hw.cmd.cmd.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.cmd.qe = cmd_qe;

  //   F[entropy_req]: 8:8
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_entropy_req (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_entropy_req_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[1]),
    .q      (reg2hw.cmd.entropy_req.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.entropy_req.qe = cmd_qe;

  //   F[hash_cnt_clr]: 9:9
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_cnt_clr (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_cnt_clr_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[2]),
    .q      (reg2hw.cmd.hash_cnt_clr.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_cnt_clr.qe = cmd_qe;

  //   F[err_processed]: 10:10
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_err_processed (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_err_processed_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[3]),
    .q      (reg2hw.cmd.err_processed.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.err_processed.qe = cmd_qe;


  // R[status]: V(True)
  //   F[sha3_idle]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_sha3_idle (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.sha3_idle.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_sha3_idle_qs)
  );

  //   F[sha3_absorb]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_sha3_absorb (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.sha3_absorb.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_sha3_absorb_qs)
  );

  //   F[sha3_squeeze]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_sha3_squeeze (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.sha3_squeeze.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_sha3_squeeze_qs)
  );

  //   F[fifo_depth]: 12:8
  prim_subreg_ext #(
    .DW    (5)
  ) u_status_fifo_depth (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_depth.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_depth_qs)
  );

  //   F[fifo_empty]: 14:14
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_fifo_empty (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_empty.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_empty_qs)
  );

  //   F[fifo_full]: 15:15
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_fifo_full (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_full.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_full_qs)
  );

  //   F[alert_fatal_fault]: 16:16
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_alert_fatal_fault (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.alert_fatal_fault.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_alert_fatal_fault_qs)
  );

  //   F[alert_recov_ctrl_update_err]: 17:17
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_alert_recov_ctrl_update_err (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.alert_recov_ctrl_update_err.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_alert_recov_ctrl_update_err_qs)
  );


  // R[entropy_period]: V(False)
  // Create REGWEN-gated WE signal
  logic entropy_period_gated_we;
  assign entropy_period_gated_we = entropy_period_we & cfg_regwen_qs;
  //   F[prescaler]: 9:0
  prim_subreg #(
    .DW      (10),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (10'h0),
    .Mubi    (1'b0)
  ) u_entropy_period_prescaler (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (entropy_period_gated_we),
    .wd     (entropy_period_prescaler_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.entropy_period.prescaler.q),
    .ds     (),

    // to register interface (read)
    .qs     (entropy_period_prescaler_qs)
  );

  //   F[wait_timer]: 31:16
  prim_subreg #(
    .DW      (16),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (16'h0),
    .Mubi    (1'b0)
  ) u_entropy_period_wait_timer (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (entropy_period_gated_we),
    .wd     (entropy_period_wait_timer_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.entropy_period.wait_timer.q),
    .ds     (),

    // to register interface (read)
    .qs     (entropy_period_wait_timer_qs)
  );


  // R[entropy_refresh_hash_cnt]: V(False)
  prim_subreg #(
    .DW      (10),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (10'h0),
    .Mubi    (1'b0)
  ) u_entropy_refresh_hash_cnt (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.entropy_refresh_hash_cnt.de),
    .d      (hw2reg.entropy_refresh_hash_cnt.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (entropy_refresh_hash_cnt_qs)
  );


  // R[entropy_refresh_threshold_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic entropy_refresh_threshold_shadowed_gated_we;
  assign entropy_refresh_threshold_shadowed_gated_we =
    entropy_refresh_threshold_shadowed_we & cfg_regwen_qs;
  prim_subreg_shadow #(
    .DW      (10),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (10'h0),
    .Mubi    (1'b0)
  ) u_entropy_refresh_threshold_shadowed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (entropy_refresh_threshold_shadowed_re),
    .we     (entropy_refresh_threshold_shadowed_gated_we),
    .wd     (entropy_refresh_threshold_shadowed_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.entropy_refresh_threshold_shadowed.q),
    .ds     (),

    // to register interface (read)
    .qs     (entropy_refresh_threshold_shadowed_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (entropy_refresh_threshold_shadowed_update_err),
    .err_storage (entropy_refresh_threshold_shadowed_storage_err)
  );


  // R[entropy_seed]: V(True)
  logic entropy_seed_qe;
  logic [0:0] entropy_seed_flds_we;
  assign entropy_seed_qe = &entropy_seed_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_entropy_seed (
    .re     (1'b0),
    .we     (entropy_seed_we),
    .wd     (entropy_seed_wd),
    .d      ('0),
    .qre    (),
    .qe     (entropy_seed_flds_we[0]),
    .q      (reg2hw.entropy_seed.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.entropy_seed.qe = entropy_seed_qe;


  // Subregister 0 of Multireg key_share0
  // R[key_share0_0]: V(True)
  logic key_share0_0_qe;
  logic [0:0] key_share0_0_flds_we;
  assign key_share0_0_qe = &key_share0_0_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_0_gated_we;
  assign key_share0_0_gated_we = key_share0_0_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_0 (
    .re     (1'b0),
    .we     (key_share0_0_gated_we),
    .wd     (key_share0_0_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_0_flds_we[0]),
    .q      (reg2hw.key_share0[0].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[0].qe = key_share0_0_qe;


  // Subregister 1 of Multireg key_share0
  // R[key_share0_1]: V(True)
  logic key_share0_1_qe;
  logic [0:0] key_share0_1_flds_we;
  assign key_share0_1_qe = &key_share0_1_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_1_gated_we;
  assign key_share0_1_gated_we = key_share0_1_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_1 (
    .re     (1'b0),
    .we     (key_share0_1_gated_we),
    .wd     (key_share0_1_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_1_flds_we[0]),
    .q      (reg2hw.key_share0[1].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[1].qe = key_share0_1_qe;


  // Subregister 2 of Multireg key_share0
  // R[key_share0_2]: V(True)
  logic key_share0_2_qe;
  logic [0:0] key_share0_2_flds_we;
  assign key_share0_2_qe = &key_share0_2_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_2_gated_we;
  assign key_share0_2_gated_we = key_share0_2_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_2 (
    .re     (1'b0),
    .we     (key_share0_2_gated_we),
    .wd     (key_share0_2_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_2_flds_we[0]),
    .q      (reg2hw.key_share0[2].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[2].qe = key_share0_2_qe;


  // Subregister 3 of Multireg key_share0
  // R[key_share0_3]: V(True)
  logic key_share0_3_qe;
  logic [0:0] key_share0_3_flds_we;
  assign key_share0_3_qe = &key_share0_3_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_3_gated_we;
  assign key_share0_3_gated_we = key_share0_3_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_3 (
    .re     (1'b0),
    .we     (key_share0_3_gated_we),
    .wd     (key_share0_3_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_3_flds_we[0]),
    .q      (reg2hw.key_share0[3].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[3].qe = key_share0_3_qe;


  // Subregister 4 of Multireg key_share0
  // R[key_share0_4]: V(True)
  logic key_share0_4_qe;
  logic [0:0] key_share0_4_flds_we;
  assign key_share0_4_qe = &key_share0_4_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_4_gated_we;
  assign key_share0_4_gated_we = key_share0_4_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_4 (
    .re     (1'b0),
    .we     (key_share0_4_gated_we),
    .wd     (key_share0_4_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_4_flds_we[0]),
    .q      (reg2hw.key_share0[4].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[4].qe = key_share0_4_qe;


  // Subregister 5 of Multireg key_share0
  // R[key_share0_5]: V(True)
  logic key_share0_5_qe;
  logic [0:0] key_share0_5_flds_we;
  assign key_share0_5_qe = &key_share0_5_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_5_gated_we;
  assign key_share0_5_gated_we = key_share0_5_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_5 (
    .re     (1'b0),
    .we     (key_share0_5_gated_we),
    .wd     (key_share0_5_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_5_flds_we[0]),
    .q      (reg2hw.key_share0[5].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[5].qe = key_share0_5_qe;


  // Subregister 6 of Multireg key_share0
  // R[key_share0_6]: V(True)
  logic key_share0_6_qe;
  logic [0:0] key_share0_6_flds_we;
  assign key_share0_6_qe = &key_share0_6_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_6_gated_we;
  assign key_share0_6_gated_we = key_share0_6_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_6 (
    .re     (1'b0),
    .we     (key_share0_6_gated_we),
    .wd     (key_share0_6_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_6_flds_we[0]),
    .q      (reg2hw.key_share0[6].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[6].qe = key_share0_6_qe;


  // Subregister 7 of Multireg key_share0
  // R[key_share0_7]: V(True)
  logic key_share0_7_qe;
  logic [0:0] key_share0_7_flds_we;
  assign key_share0_7_qe = &key_share0_7_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_7_gated_we;
  assign key_share0_7_gated_we = key_share0_7_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_7 (
    .re     (1'b0),
    .we     (key_share0_7_gated_we),
    .wd     (key_share0_7_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_7_flds_we[0]),
    .q      (reg2hw.key_share0[7].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[7].qe = key_share0_7_qe;


  // Subregister 8 of Multireg key_share0
  // R[key_share0_8]: V(True)
  logic key_share0_8_qe;
  logic [0:0] key_share0_8_flds_we;
  assign key_share0_8_qe = &key_share0_8_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_8_gated_we;
  assign key_share0_8_gated_we = key_share0_8_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_8 (
    .re     (1'b0),
    .we     (key_share0_8_gated_we),
    .wd     (key_share0_8_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_8_flds_we[0]),
    .q      (reg2hw.key_share0[8].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[8].qe = key_share0_8_qe;


  // Subregister 9 of Multireg key_share0
  // R[key_share0_9]: V(True)
  logic key_share0_9_qe;
  logic [0:0] key_share0_9_flds_we;
  assign key_share0_9_qe = &key_share0_9_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_9_gated_we;
  assign key_share0_9_gated_we = key_share0_9_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_9 (
    .re     (1'b0),
    .we     (key_share0_9_gated_we),
    .wd     (key_share0_9_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_9_flds_we[0]),
    .q      (reg2hw.key_share0[9].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[9].qe = key_share0_9_qe;


  // Subregister 10 of Multireg key_share0
  // R[key_share0_10]: V(True)
  logic key_share0_10_qe;
  logic [0:0] key_share0_10_flds_we;
  assign key_share0_10_qe = &key_share0_10_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_10_gated_we;
  assign key_share0_10_gated_we = key_share0_10_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_10 (
    .re     (1'b0),
    .we     (key_share0_10_gated_we),
    .wd     (key_share0_10_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_10_flds_we[0]),
    .q      (reg2hw.key_share0[10].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[10].qe = key_share0_10_qe;


  // Subregister 11 of Multireg key_share0
  // R[key_share0_11]: V(True)
  logic key_share0_11_qe;
  logic [0:0] key_share0_11_flds_we;
  assign key_share0_11_qe = &key_share0_11_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_11_gated_we;
  assign key_share0_11_gated_we = key_share0_11_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_11 (
    .re     (1'b0),
    .we     (key_share0_11_gated_we),
    .wd     (key_share0_11_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_11_flds_we[0]),
    .q      (reg2hw.key_share0[11].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[11].qe = key_share0_11_qe;


  // Subregister 12 of Multireg key_share0
  // R[key_share0_12]: V(True)
  logic key_share0_12_qe;
  logic [0:0] key_share0_12_flds_we;
  assign key_share0_12_qe = &key_share0_12_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_12_gated_we;
  assign key_share0_12_gated_we = key_share0_12_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_12 (
    .re     (1'b0),
    .we     (key_share0_12_gated_we),
    .wd     (key_share0_12_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_12_flds_we[0]),
    .q      (reg2hw.key_share0[12].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[12].qe = key_share0_12_qe;


  // Subregister 13 of Multireg key_share0
  // R[key_share0_13]: V(True)
  logic key_share0_13_qe;
  logic [0:0] key_share0_13_flds_we;
  assign key_share0_13_qe = &key_share0_13_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_13_gated_we;
  assign key_share0_13_gated_we = key_share0_13_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_13 (
    .re     (1'b0),
    .we     (key_share0_13_gated_we),
    .wd     (key_share0_13_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_13_flds_we[0]),
    .q      (reg2hw.key_share0[13].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[13].qe = key_share0_13_qe;


  // Subregister 14 of Multireg key_share0
  // R[key_share0_14]: V(True)
  logic key_share0_14_qe;
  logic [0:0] key_share0_14_flds_we;
  assign key_share0_14_qe = &key_share0_14_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_14_gated_we;
  assign key_share0_14_gated_we = key_share0_14_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_14 (
    .re     (1'b0),
    .we     (key_share0_14_gated_we),
    .wd     (key_share0_14_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_14_flds_we[0]),
    .q      (reg2hw.key_share0[14].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[14].qe = key_share0_14_qe;


  // Subregister 15 of Multireg key_share0
  // R[key_share0_15]: V(True)
  logic key_share0_15_qe;
  logic [0:0] key_share0_15_flds_we;
  assign key_share0_15_qe = &key_share0_15_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_15_gated_we;
  assign key_share0_15_gated_we = key_share0_15_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_15 (
    .re     (1'b0),
    .we     (key_share0_15_gated_we),
    .wd     (key_share0_15_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_15_flds_we[0]),
    .q      (reg2hw.key_share0[15].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[15].qe = key_share0_15_qe;


  // Subregister 0 of Multireg key_share1
  // R[key_share1_0]: V(True)
  logic key_share1_0_qe;
  logic [0:0] key_share1_0_flds_we;
  assign key_share1_0_qe = &key_share1_0_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_0_gated_we;
  assign key_share1_0_gated_we = key_share1_0_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_0 (
    .re     (1'b0),
    .we     (key_share1_0_gated_we),
    .wd     (key_share1_0_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_0_flds_we[0]),
    .q      (reg2hw.key_share1[0].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[0].qe = key_share1_0_qe;


  // Subregister 1 of Multireg key_share1
  // R[key_share1_1]: V(True)
  logic key_share1_1_qe;
  logic [0:0] key_share1_1_flds_we;
  assign key_share1_1_qe = &key_share1_1_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_1_gated_we;
  assign key_share1_1_gated_we = key_share1_1_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_1 (
    .re     (1'b0),
    .we     (key_share1_1_gated_we),
    .wd     (key_share1_1_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_1_flds_we[0]),
    .q      (reg2hw.key_share1[1].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[1].qe = key_share1_1_qe;


  // Subregister 2 of Multireg key_share1
  // R[key_share1_2]: V(True)
  logic key_share1_2_qe;
  logic [0:0] key_share1_2_flds_we;
  assign key_share1_2_qe = &key_share1_2_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_2_gated_we;
  assign key_share1_2_gated_we = key_share1_2_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_2 (
    .re     (1'b0),
    .we     (key_share1_2_gated_we),
    .wd     (key_share1_2_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_2_flds_we[0]),
    .q      (reg2hw.key_share1[2].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[2].qe = key_share1_2_qe;


  // Subregister 3 of Multireg key_share1
  // R[key_share1_3]: V(True)
  logic key_share1_3_qe;
  logic [0:0] key_share1_3_flds_we;
  assign key_share1_3_qe = &key_share1_3_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_3_gated_we;
  assign key_share1_3_gated_we = key_share1_3_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_3 (
    .re     (1'b0),
    .we     (key_share1_3_gated_we),
    .wd     (key_share1_3_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_3_flds_we[0]),
    .q      (reg2hw.key_share1[3].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[3].qe = key_share1_3_qe;


  // Subregister 4 of Multireg key_share1
  // R[key_share1_4]: V(True)
  logic key_share1_4_qe;
  logic [0:0] key_share1_4_flds_we;
  assign key_share1_4_qe = &key_share1_4_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_4_gated_we;
  assign key_share1_4_gated_we = key_share1_4_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_4 (
    .re     (1'b0),
    .we     (key_share1_4_gated_we),
    .wd     (key_share1_4_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_4_flds_we[0]),
    .q      (reg2hw.key_share1[4].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[4].qe = key_share1_4_qe;


  // Subregister 5 of Multireg key_share1
  // R[key_share1_5]: V(True)
  logic key_share1_5_qe;
  logic [0:0] key_share1_5_flds_we;
  assign key_share1_5_qe = &key_share1_5_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_5_gated_we;
  assign key_share1_5_gated_we = key_share1_5_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_5 (
    .re     (1'b0),
    .we     (key_share1_5_gated_we),
    .wd     (key_share1_5_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_5_flds_we[0]),
    .q      (reg2hw.key_share1[5].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[5].qe = key_share1_5_qe;


  // Subregister 6 of Multireg key_share1
  // R[key_share1_6]: V(True)
  logic key_share1_6_qe;
  logic [0:0] key_share1_6_flds_we;
  assign key_share1_6_qe = &key_share1_6_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_6_gated_we;
  assign key_share1_6_gated_we = key_share1_6_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_6 (
    .re     (1'b0),
    .we     (key_share1_6_gated_we),
    .wd     (key_share1_6_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_6_flds_we[0]),
    .q      (reg2hw.key_share1[6].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[6].qe = key_share1_6_qe;


  // Subregister 7 of Multireg key_share1
  // R[key_share1_7]: V(True)
  logic key_share1_7_qe;
  logic [0:0] key_share1_7_flds_we;
  assign key_share1_7_qe = &key_share1_7_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_7_gated_we;
  assign key_share1_7_gated_we = key_share1_7_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_7 (
    .re     (1'b0),
    .we     (key_share1_7_gated_we),
    .wd     (key_share1_7_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_7_flds_we[0]),
    .q      (reg2hw.key_share1[7].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[7].qe = key_share1_7_qe;


  // Subregister 8 of Multireg key_share1
  // R[key_share1_8]: V(True)
  logic key_share1_8_qe;
  logic [0:0] key_share1_8_flds_we;
  assign key_share1_8_qe = &key_share1_8_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_8_gated_we;
  assign key_share1_8_gated_we = key_share1_8_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_8 (
    .re     (1'b0),
    .we     (key_share1_8_gated_we),
    .wd     (key_share1_8_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_8_flds_we[0]),
    .q      (reg2hw.key_share1[8].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[8].qe = key_share1_8_qe;


  // Subregister 9 of Multireg key_share1
  // R[key_share1_9]: V(True)
  logic key_share1_9_qe;
  logic [0:0] key_share1_9_flds_we;
  assign key_share1_9_qe = &key_share1_9_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_9_gated_we;
  assign key_share1_9_gated_we = key_share1_9_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_9 (
    .re     (1'b0),
    .we     (key_share1_9_gated_we),
    .wd     (key_share1_9_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_9_flds_we[0]),
    .q      (reg2hw.key_share1[9].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[9].qe = key_share1_9_qe;


  // Subregister 10 of Multireg key_share1
  // R[key_share1_10]: V(True)
  logic key_share1_10_qe;
  logic [0:0] key_share1_10_flds_we;
  assign key_share1_10_qe = &key_share1_10_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_10_gated_we;
  assign key_share1_10_gated_we = key_share1_10_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_10 (
    .re     (1'b0),
    .we     (key_share1_10_gated_we),
    .wd     (key_share1_10_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_10_flds_we[0]),
    .q      (reg2hw.key_share1[10].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[10].qe = key_share1_10_qe;


  // Subregister 11 of Multireg key_share1
  // R[key_share1_11]: V(True)
  logic key_share1_11_qe;
  logic [0:0] key_share1_11_flds_we;
  assign key_share1_11_qe = &key_share1_11_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_11_gated_we;
  assign key_share1_11_gated_we = key_share1_11_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_11 (
    .re     (1'b0),
    .we     (key_share1_11_gated_we),
    .wd     (key_share1_11_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_11_flds_we[0]),
    .q      (reg2hw.key_share1[11].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[11].qe = key_share1_11_qe;


  // Subregister 12 of Multireg key_share1
  // R[key_share1_12]: V(True)
  logic key_share1_12_qe;
  logic [0:0] key_share1_12_flds_we;
  assign key_share1_12_qe = &key_share1_12_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_12_gated_we;
  assign key_share1_12_gated_we = key_share1_12_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_12 (
    .re     (1'b0),
    .we     (key_share1_12_gated_we),
    .wd     (key_share1_12_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_12_flds_we[0]),
    .q      (reg2hw.key_share1[12].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[12].qe = key_share1_12_qe;


  // Subregister 13 of Multireg key_share1
  // R[key_share1_13]: V(True)
  logic key_share1_13_qe;
  logic [0:0] key_share1_13_flds_we;
  assign key_share1_13_qe = &key_share1_13_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_13_gated_we;
  assign key_share1_13_gated_we = key_share1_13_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_13 (
    .re     (1'b0),
    .we     (key_share1_13_gated_we),
    .wd     (key_share1_13_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_13_flds_we[0]),
    .q      (reg2hw.key_share1[13].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[13].qe = key_share1_13_qe;


  // Subregister 14 of Multireg key_share1
  // R[key_share1_14]: V(True)
  logic key_share1_14_qe;
  logic [0:0] key_share1_14_flds_we;
  assign key_share1_14_qe = &key_share1_14_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_14_gated_we;
  assign key_share1_14_gated_we = key_share1_14_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_14 (
    .re     (1'b0),
    .we     (key_share1_14_gated_we),
    .wd     (key_share1_14_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_14_flds_we[0]),
    .q      (reg2hw.key_share1[14].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[14].qe = key_share1_14_qe;


  // Subregister 15 of Multireg key_share1
  // R[key_share1_15]: V(True)
  logic key_share1_15_qe;
  logic [0:0] key_share1_15_flds_we;
  assign key_share1_15_qe = &key_share1_15_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_15_gated_we;
  assign key_share1_15_gated_we = key_share1_15_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_15 (
    .re     (1'b0),
    .we     (key_share1_15_gated_we),
    .wd     (key_share1_15_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_15_flds_we[0]),
    .q      (reg2hw.key_share1[15].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[15].qe = key_share1_15_qe;


  // R[key_len]: V(False)
  // Create REGWEN-gated WE signal
  logic key_len_gated_we;
  assign key_len_gated_we = key_len_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (3),
    .SwAccess(prim_subreg_pkg::SwAccessWO),
    .RESVAL  (3'h0),
    .Mubi    (1'b0)
  ) u_key_len (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (key_len_gated_we),
    .wd     (key_len_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.key_len.q),
    .ds     (),

    // to register interface (read)
    .qs     ()
  );


  // Subregister 0 of Multireg prefix
  // R[prefix_0]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_0_gated_we;
  assign prefix_0_gated_we = prefix_0_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_0_gated_we),
    .wd     (prefix_0_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[0].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_0_qs)
  );


  // Subregister 1 of Multireg prefix
  // R[prefix_1]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_1_gated_we;
  assign prefix_1_gated_we = prefix_1_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_1_gated_we),
    .wd     (prefix_1_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[1].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_1_qs)
  );


  // Subregister 2 of Multireg prefix
  // R[prefix_2]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_2_gated_we;
  assign prefix_2_gated_we = prefix_2_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_2_gated_we),
    .wd     (prefix_2_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[2].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_2_qs)
  );


  // Subregister 3 of Multireg prefix
  // R[prefix_3]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_3_gated_we;
  assign prefix_3_gated_we = prefix_3_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_3_gated_we),
    .wd     (prefix_3_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[3].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_3_qs)
  );


  // Subregister 4 of Multireg prefix
  // R[prefix_4]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_4_gated_we;
  assign prefix_4_gated_we = prefix_4_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_4_gated_we),
    .wd     (prefix_4_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[4].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_4_qs)
  );


  // Subregister 5 of Multireg prefix
  // R[prefix_5]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_5_gated_we;
  assign prefix_5_gated_we = prefix_5_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_5_gated_we),
    .wd     (prefix_5_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[5].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_5_qs)
  );


  // Subregister 6 of Multireg prefix
  // R[prefix_6]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_6_gated_we;
  assign prefix_6_gated_we = prefix_6_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_6_gated_we),
    .wd     (prefix_6_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[6].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_6_qs)
  );


  // Subregister 7 of Multireg prefix
  // R[prefix_7]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_7_gated_we;
  assign prefix_7_gated_we = prefix_7_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_7_gated_we),
    .wd     (prefix_7_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[7].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_7_qs)
  );


  // Subregister 8 of Multireg prefix
  // R[prefix_8]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_8_gated_we;
  assign prefix_8_gated_we = prefix_8_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_8 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_8_gated_we),
    .wd     (prefix_8_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[8].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_8_qs)
  );


  // Subregister 9 of Multireg prefix
  // R[prefix_9]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_9_gated_we;
  assign prefix_9_gated_we = prefix_9_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_9 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_9_gated_we),
    .wd     (prefix_9_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[9].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_9_qs)
  );


  // Subregister 10 of Multireg prefix
  // R[prefix_10]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_10_gated_we;
  assign prefix_10_gated_we = prefix_10_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_10 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_10_gated_we),
    .wd     (prefix_10_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[10].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_10_qs)
  );


  // R[err_code]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_err_code (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.err_code.de),
    .d      (hw2reg.err_code.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (err_code_qs)
  );



  logic [56:0] addr_hit;
  always_comb begin
    addr_hit = '0;
    addr_hit[ 0] = (reg_addr == KMAC_INTR_STATE_OFFSET);
    addr_hit[ 1] = (reg_addr == KMAC_INTR_ENABLE_OFFSET);
    addr_hit[ 2] = (reg_addr == KMAC_INTR_TEST_OFFSET);
    addr_hit[ 3] = (reg_addr == KMAC_ALERT_TEST_OFFSET);
    addr_hit[ 4] = (reg_addr == KMAC_CFG_REGWEN_OFFSET);
    addr_hit[ 5] = (reg_addr == KMAC_CFG_SHADOWED_OFFSET);
    addr_hit[ 6] = (reg_addr == KMAC_CMD_OFFSET);
    addr_hit[ 7] = (reg_addr == KMAC_STATUS_OFFSET);
    addr_hit[ 8] = (reg_addr == KMAC_ENTROPY_PERIOD_OFFSET);
    addr_hit[ 9] = (reg_addr == KMAC_ENTROPY_REFRESH_HASH_CNT_OFFSET);
    addr_hit[10] = (reg_addr == KMAC_ENTROPY_REFRESH_THRESHOLD_SHADOWED_OFFSET);
    addr_hit[11] = (reg_addr == KMAC_ENTROPY_SEED_OFFSET);
    addr_hit[12] = (reg_addr == KMAC_KEY_SHARE0_0_OFFSET);
    addr_hit[13] = (reg_addr == KMAC_KEY_SHARE0_1_OFFSET);
    addr_hit[14] = (reg_addr == KMAC_KEY_SHARE0_2_OFFSET);
    addr_hit[15] = (reg_addr == KMAC_KEY_SHARE0_3_OFFSET);
    addr_hit[16] = (reg_addr == KMAC_KEY_SHARE0_4_OFFSET);
    addr_hit[17] = (reg_addr == KMAC_KEY_SHARE0_5_OFFSET);
    addr_hit[18] = (reg_addr == KMAC_KEY_SHARE0_6_OFFSET);
    addr_hit[19] = (reg_addr == KMAC_KEY_SHARE0_7_OFFSET);
    addr_hit[20] = (reg_addr == KMAC_KEY_SHARE0_8_OFFSET);
    addr_hit[21] = (reg_addr == KMAC_KEY_SHARE0_9_OFFSET);
    addr_hit[22] = (reg_addr == KMAC_KEY_SHARE0_10_OFFSET);
    addr_hit[23] = (reg_addr == KMAC_KEY_SHARE0_11_OFFSET);
    addr_hit[24] = (reg_addr == KMAC_KEY_SHARE0_12_OFFSET);
    addr_hit[25] = (reg_addr == KMAC_KEY_SHARE0_13_OFFSET);
    addr_hit[26] = (reg_addr == KMAC_KEY_SHARE0_14_OFFSET);
    addr_hit[27] = (reg_addr == KMAC_KEY_SHARE0_15_OFFSET);
    addr_hit[28] = (reg_addr == KMAC_KEY_SHARE1_0_OFFSET);
    addr_hit[29] = (reg_addr == KMAC_KEY_SHARE1_1_OFFSET);
    addr_hit[30] = (reg_addr == KMAC_KEY_SHARE1_2_OFFSET);
    addr_hit[31] = (reg_addr == KMAC_KEY_SHARE1_3_OFFSET);
    addr_hit[32] = (reg_addr == KMAC_KEY_SHARE1_4_OFFSET);
    addr_hit[33] = (reg_addr == KMAC_KEY_SHARE1_5_OFFSET);
    addr_hit[34] = (reg_addr == KMAC_KEY_SHARE1_6_OFFSET);
    addr_hit[35] = (reg_addr == KMAC_KEY_SHARE1_7_OFFSET);
    addr_hit[36] = (reg_addr == KMAC_KEY_SHARE1_8_OFFSET);
    addr_hit[37] = (reg_addr == KMAC_KEY_SHARE1_9_OFFSET);
    addr_hit[38] = (reg_addr == KMAC_KEY_SHARE1_10_OFFSET);
    addr_hit[39] = (reg_addr == KMAC_KEY_SHARE1_11_OFFSET);
    addr_hit[40] = (reg_addr == KMAC_KEY_SHARE1_12_OFFSET);
    addr_hit[41] = (reg_addr == KMAC_KEY_SHARE1_13_OFFSET);
    addr_hit[42] = (reg_addr == KMAC_KEY_SHARE1_14_OFFSET);
    addr_hit[43] = (reg_addr == KMAC_KEY_SHARE1_15_OFFSET);
    addr_hit[44] = (reg_addr == KMAC_KEY_LEN_OFFSET);
    addr_hit[45] = (reg_addr == KMAC_PREFIX_0_OFFSET);
    addr_hit[46] = (reg_addr == KMAC_PREFIX_1_OFFSET);
    addr_hit[47] = (reg_addr == KMAC_PREFIX_2_OFFSET);
    addr_hit[48] = (reg_addr == KMAC_PREFIX_3_OFFSET);
    addr_hit[49] = (reg_addr == KMAC_PREFIX_4_OFFSET);
    addr_hit[50] = (reg_addr == KMAC_PREFIX_5_OFFSET);
    addr_hit[51] = (reg_addr == KMAC_PREFIX_6_OFFSET);
    addr_hit[52] = (reg_addr == KMAC_PREFIX_7_OFFSET);
    addr_hit[53] = (reg_addr == KMAC_PREFIX_8_OFFSET);
    addr_hit[54] = (reg_addr == KMAC_PREFIX_9_OFFSET);
    addr_hit[55] = (reg_addr == KMAC_PREFIX_10_OFFSET);
    addr_hit[56] = (reg_addr == KMAC_ERR_CODE_OFFSET);
  end

  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;

  // Check sub-word write is permitted
  always_comb begin
    wr_err = (reg_we &
              ((addr_hit[ 0] & (|(KMAC_PERMIT[ 0] & ~reg_be))) |
               (addr_hit[ 1] & (|(KMAC_PERMIT[ 1] & ~reg_be))) |
               (addr_hit[ 2] & (|(KMAC_PERMIT[ 2] & ~reg_be))) |
               (addr_hit[ 3] & (|(KMAC_PERMIT[ 3] & ~reg_be))) |
               (addr_hit[ 4] & (|(KMAC_PERMIT[ 4] & ~reg_be))) |
               (addr_hit[ 5] & (|(KMAC_PERMIT[ 5] & ~reg_be))) |
               (addr_hit[ 6] & (|(KMAC_PERMIT[ 6] & ~reg_be))) |
               (addr_hit[ 7] & (|(KMAC_PERMIT[ 7] & ~reg_be))) |
               (addr_hit[ 8] & (|(KMAC_PERMIT[ 8] & ~reg_be))) |
               (addr_hit[ 9] & (|(KMAC_PERMIT[ 9] & ~reg_be))) |
               (addr_hit[10] & (|(KMAC_PERMIT[10] & ~reg_be))) |
               (addr_hit[11] & (|(KMAC_PERMIT[11] & ~reg_be))) |
               (addr_hit[12] & (|(KMAC_PERMIT[12] & ~reg_be))) |
               (addr_hit[13] & (|(KMAC_PERMIT[13] & ~reg_be))) |
               (addr_hit[14] & (|(KMAC_PERMIT[14] & ~reg_be))) |
               (addr_hit[15] & (|(KMAC_PERMIT[15] & ~reg_be))) |
               (addr_hit[16] & (|(KMAC_PERMIT[16] & ~reg_be))) |
               (addr_hit[17] & (|(KMAC_PERMIT[17] & ~reg_be))) |
               (addr_hit[18] & (|(KMAC_PERMIT[18] & ~reg_be))) |
               (addr_hit[19] & (|(KMAC_PERMIT[19] & ~reg_be))) |
               (addr_hit[20] & (|(KMAC_PERMIT[20] & ~reg_be))) |
               (addr_hit[21] & (|(KMAC_PERMIT[21] & ~reg_be))) |
               (addr_hit[22] & (|(KMAC_PERMIT[22] & ~reg_be))) |
               (addr_hit[23] & (|(KMAC_PERMIT[23] & ~reg_be))) |
               (addr_hit[24] & (|(KMAC_PERMIT[24] & ~reg_be))) |
               (addr_hit[25] & (|(KMAC_PERMIT[25] & ~reg_be))) |
               (addr_hit[26] & (|(KMAC_PERMIT[26] & ~reg_be))) |
               (addr_hit[27] & (|(KMAC_PERMIT[27] & ~reg_be))) |
               (addr_hit[28] & (|(KMAC_PERMIT[28] & ~reg_be))) |
               (addr_hit[29] & (|(KMAC_PERMIT[29] & ~reg_be))) |
               (addr_hit[30] & (|(KMAC_PERMIT[30] & ~reg_be))) |
               (addr_hit[31] & (|(KMAC_PERMIT[31] & ~reg_be))) |
               (addr_hit[32] & (|(KMAC_PERMIT[32] & ~reg_be))) |
               (addr_hit[33] & (|(KMAC_PERMIT[33] & ~reg_be))) |
               (addr_hit[34] & (|(KMAC_PERMIT[34] & ~reg_be))) |
               (addr_hit[35] & (|(KMAC_PERMIT[35] & ~reg_be))) |
               (addr_hit[36] & (|(KMAC_PERMIT[36] & ~reg_be))) |
               (addr_hit[37] & (|(KMAC_PERMIT[37] & ~reg_be))) |
               (addr_hit[38] & (|(KMAC_PERMIT[38] & ~reg_be))) |
               (addr_hit[39] & (|(KMAC_PERMIT[39] & ~reg_be))) |
               (addr_hit[40] & (|(KMAC_PERMIT[40] & ~reg_be))) |
               (addr_hit[41] & (|(KMAC_PERMIT[41] & ~reg_be))) |
               (addr_hit[42] & (|(KMAC_PERMIT[42] & ~reg_be))) |
               (addr_hit[43] & (|(KMAC_PERMIT[43] & ~reg_be))) |
               (addr_hit[44] & (|(KMAC_PERMIT[44] & ~reg_be))) |
               (addr_hit[45] & (|(KMAC_PERMIT[45] & ~reg_be))) |
               (addr_hit[46] & (|(KMAC_PERMIT[46] & ~reg_be))) |
               (addr_hit[47] & (|(KMAC_PERMIT[47] & ~reg_be))) |
               (addr_hit[48] & (|(KMAC_PERMIT[48] & ~reg_be))) |
               (addr_hit[49] & (|(KMAC_PERMIT[49] & ~reg_be))) |
               (addr_hit[50] & (|(KMAC_PERMIT[50] & ~reg_be))) |
               (addr_hit[51] & (|(KMAC_PERMIT[51] & ~reg_be))) |
               (addr_hit[52] & (|(KMAC_PERMIT[52] & ~reg_be))) |
               (addr_hit[53] & (|(KMAC_PERMIT[53] & ~reg_be))) |
               (addr_hit[54] & (|(KMAC_PERMIT[54] & ~reg_be))) |
               (addr_hit[55] & (|(KMAC_PERMIT[55] & ~reg_be))) |
               (addr_hit[56] & (|(KMAC_PERMIT[56] & ~reg_be)))));
  end

  // Generate write-enables
  assign intr_state_we = addr_hit[0] & reg_we & !reg_error;

  assign intr_state_kmac_done_wd = reg_wdata[0];

  assign intr_state_kmac_err_wd = reg_wdata[2];
  assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;

  assign intr_enable_kmac_done_wd = reg_wdata[0];

  assign intr_enable_fifo_empty_wd = reg_wdata[1];

  assign intr_enable_kmac_err_wd = reg_wdata[2];
  assign intr_test_we = addr_hit[2] & reg_we & !reg_error;

  assign intr_test_kmac_done_wd = reg_wdata[0];

  assign intr_test_fifo_empty_wd = reg_wdata[1];

  assign intr_test_kmac_err_wd = reg_wdata[2];
  assign alert_test_we = addr_hit[3] & reg_we & !reg_error;

  assign alert_test_recov_operation_err_wd = reg_wdata[0];

  assign alert_test_fatal_fault_err_wd = reg_wdata[1];
  assign cfg_regwen_re = addr_hit[4] & reg_re & !reg_error;
  assign cfg_shadowed_re = addr_hit[5] & reg_re & !reg_error;
  assign cfg_shadowed_we = addr_hit[5] & reg_we & !reg_error;

  assign cfg_shadowed_kmac_en_wd = reg_wdata[0];

  assign cfg_shadowed_kstrength_wd = reg_wdata[3:1];

  assign cfg_shadowed_mode_wd = reg_wdata[5:4];

  assign cfg_shadowed_msg_endianness_wd = reg_wdata[8];

  assign cfg_shadowed_state_endianness_wd = reg_wdata[9];

  assign cfg_shadowed_sideload_wd = reg_wdata[12];

  assign cfg_shadowed_entropy_mode_wd = reg_wdata[17:16];

  assign cfg_shadowed_entropy_fast_process_wd = reg_wdata[19];

  assign cfg_shadowed_msg_mask_wd = reg_wdata[20];

  assign cfg_shadowed_entropy_ready_wd = reg_wdata[24];

  assign cfg_shadowed_en_unsupported_modestrength_wd = reg_wdata[26];
  assign cmd_we = addr_hit[6] & reg_we & !reg_error;

  assign cmd_cmd_wd = reg_wdata[5:0];

  assign cmd_entropy_req_wd = reg_wdata[8];

  assign cmd_hash_cnt_clr_wd = reg_wdata[9];

  assign cmd_err_processed_wd = reg_wdata[10];
  assign status_re = addr_hit[7] & reg_re & !reg_error;
  assign entropy_period_we = addr_hit[8] & reg_we & !reg_error;

  assign entropy_period_prescaler_wd = reg_wdata[9:0];

  assign entropy_period_wait_timer_wd = reg_wdata[31:16];
  assign entropy_refresh_threshold_shadowed_re = addr_hit[10] & reg_re & !reg_error;
  assign entropy_refresh_threshold_shadowed_we = addr_hit[10] & reg_we & !reg_error;

  assign entropy_refresh_threshold_shadowed_wd = reg_wdata[9:0];
  assign entropy_seed_we = addr_hit[11] & reg_we & !reg_error;

  assign entropy_seed_wd = reg_wdata[31:0];
  assign key_share0_0_we = addr_hit[12] & reg_we & !reg_error;

  assign key_share0_0_wd = reg_wdata[31:0];
  assign key_share0_1_we = addr_hit[13] & reg_we & !reg_error;

  assign key_share0_1_wd = reg_wdata[31:0];
  assign key_share0_2_we = addr_hit[14] & reg_we & !reg_error;

  assign key_share0_2_wd = reg_wdata[31:0];
  assign key_share0_3_we = addr_hit[15] & reg_we & !reg_error;

  assign key_share0_3_wd = reg_wdata[31:0];
  assign key_share0_4_we = addr_hit[16] & reg_we & !reg_error;

  assign key_share0_4_wd = reg_wdata[31:0];
  assign key_share0_5_we = addr_hit[17] & reg_we & !reg_error;

  assign key_share0_5_wd = reg_wdata[31:0];
  assign key_share0_6_we = addr_hit[18] & reg_we & !reg_error;

  assign key_share0_6_wd = reg_wdata[31:0];
  assign key_share0_7_we = addr_hit[19] & reg_we & !reg_error;

  assign key_share0_7_wd = reg_wdata[31:0];
  assign key_share0_8_we = addr_hit[20] & reg_we & !reg_error;

  assign key_share0_8_wd = reg_wdata[31:0];
  assign key_share0_9_we = addr_hit[21] & reg_we & !reg_error;

  assign key_share0_9_wd = reg_wdata[31:0];
  assign key_share0_10_we = addr_hit[22] & reg_we & !reg_error;

  assign key_share0_10_wd = reg_wdata[31:0];
  assign key_share0_11_we = addr_hit[23] & reg_we & !reg_error;

  assign key_share0_11_wd = reg_wdata[31:0];
  assign key_share0_12_we = addr_hit[24] & reg_we & !reg_error;

  assign key_share0_12_wd = reg_wdata[31:0];
  assign key_share0_13_we = addr_hit[25] & reg_we & !reg_error;

  assign key_share0_13_wd = reg_wdata[31:0];
  assign key_share0_14_we = addr_hit[26] & reg_we & !reg_error;

  assign key_share0_14_wd = reg_wdata[31:0];
  assign key_share0_15_we = addr_hit[27] & reg_we & !reg_error;

  assign key_share0_15_wd = reg_wdata[31:0];
  assign key_share1_0_we = addr_hit[28] & reg_we & !reg_error;

  assign key_share1_0_wd = reg_wdata[31:0];
  assign key_share1_1_we = addr_hit[29] & reg_we & !reg_error;

  assign key_share1_1_wd = reg_wdata[31:0];
  assign key_share1_2_we = addr_hit[30] & reg_we & !reg_error;

  assign key_share1_2_wd = reg_wdata[31:0];
  assign key_share1_3_we = addr_hit[31] & reg_we & !reg_error;

  assign key_share1_3_wd = reg_wdata[31:0];
  assign key_share1_4_we = addr_hit[32] & reg_we & !reg_error;

  assign key_share1_4_wd = reg_wdata[31:0];
  assign key_share1_5_we = addr_hit[33] & reg_we & !reg_error;

  assign key_share1_5_wd = reg_wdata[31:0];
  assign key_share1_6_we = addr_hit[34] & reg_we & !reg_error;

  assign key_share1_6_wd = reg_wdata[31:0];
  assign key_share1_7_we = addr_hit[35] & reg_we & !reg_error;

  assign key_share1_7_wd = reg_wdata[31:0];
  assign key_share1_8_we = addr_hit[36] & reg_we & !reg_error;

  assign key_share1_8_wd = reg_wdata[31:0];
  assign key_share1_9_we = addr_hit[37] & reg_we & !reg_error;

  assign key_share1_9_wd = reg_wdata[31:0];
  assign key_share1_10_we = addr_hit[38] & reg_we & !reg_error;

  assign key_share1_10_wd = reg_wdata[31:0];
  assign key_share1_11_we = addr_hit[39] & reg_we & !reg_error;

  assign key_share1_11_wd = reg_wdata[31:0];
  assign key_share1_12_we = addr_hit[40] & reg_we & !reg_error;

  assign key_share1_12_wd = reg_wdata[31:0];
  assign key_share1_13_we = addr_hit[41] & reg_we & !reg_error;

  assign key_share1_13_wd = reg_wdata[31:0];
  assign key_share1_14_we = addr_hit[42] & reg_we & !reg_error;

  assign key_share1_14_wd = reg_wdata[31:0];
  assign key_share1_15_we = addr_hit[43] & reg_we & !reg_error;

  assign key_share1_15_wd = reg_wdata[31:0];
  assign key_len_we = addr_hit[44] & reg_we & !reg_error;

  assign key_len_wd = reg_wdata[2:0];
  assign prefix_0_we = addr_hit[45] & reg_we & !reg_error;

  assign prefix_0_wd = reg_wdata[31:0];
  assign prefix_1_we = addr_hit[46] & reg_we & !reg_error;

  assign prefix_1_wd = reg_wdata[31:0];
  assign prefix_2_we = addr_hit[47] & reg_we & !reg_error;

  assign prefix_2_wd = reg_wdata[31:0];
  assign prefix_3_we = addr_hit[48] & reg_we & !reg_error;

  assign prefix_3_wd = reg_wdata[31:0];
  assign prefix_4_we = addr_hit[49] & reg_we & !reg_error;

  assign prefix_4_wd = reg_wdata[31:0];
  assign prefix_5_we = addr_hit[50] & reg_we & !reg_error;

  assign prefix_5_wd = reg_wdata[31:0];
  assign prefix_6_we = addr_hit[51] & reg_we & !reg_error;

  assign prefix_6_wd = reg_wdata[31:0];
  assign prefix_7_we = addr_hit[52] & reg_we & !reg_error;

  assign prefix_7_wd = reg_wdata[31:0];
  assign prefix_8_we = addr_hit[53] & reg_we & !reg_error;

  assign prefix_8_wd = reg_wdata[31:0];
  assign prefix_9_we = addr_hit[54] & reg_we & !reg_error;

  assign prefix_9_wd = reg_wdata[31:0];
  assign prefix_10_we = addr_hit[55] & reg_we & !reg_error;

  assign prefix_10_wd = reg_wdata[31:0];

  // Assign write-enables to checker logic vector.
  always_comb begin
    reg_we_check = '0;
    reg_we_check[0] = intr_state_we;
    reg_we_check[1] = intr_enable_we;
    reg_we_check[2] = intr_test_we;
    reg_we_check[3] = alert_test_we;
    reg_we_check[4] = 1'b0;
    reg_we_check[5] = cfg_shadowed_gated_we;
    reg_we_check[6] = cmd_we;
    reg_we_check[7] = 1'b0;
    reg_we_check[8] = entropy_period_gated_we;
    reg_we_check[9] = 1'b0;
    reg_we_check[10] = entropy_refresh_threshold_shadowed_gated_we;
    reg_we_check[11] = entropy_seed_we;
    reg_we_check[12] = key_share0_0_gated_we;
    reg_we_check[13] = key_share0_1_gated_we;
    reg_we_check[14] = key_share0_2_gated_we;
    reg_we_check[15] = key_share0_3_gated_we;
    reg_we_check[16] = key_share0_4_gated_we;
    reg_we_check[17] = key_share0_5_gated_we;
    reg_we_check[18] = key_share0_6_gated_we;
    reg_we_check[19] = key_share0_7_gated_we;
    reg_we_check[20] = key_share0_8_gated_we;
    reg_we_check[21] = key_share0_9_gated_we;
    reg_we_check[22] = key_share0_10_gated_we;
    reg_we_check[23] = key_share0_11_gated_we;
    reg_we_check[24] = key_share0_12_gated_we;
    reg_we_check[25] = key_share0_13_gated_we;
    reg_we_check[26] = key_share0_14_gated_we;
    reg_we_check[27] = key_share0_15_gated_we;
    reg_we_check[28] = key_share1_0_gated_we;
    reg_we_check[29] = key_share1_1_gated_we;
    reg_we_check[30] = key_share1_2_gated_we;
    reg_we_check[31] = key_share1_3_gated_we;
    reg_we_check[32] = key_share1_4_gated_we;
    reg_we_check[33] = key_share1_5_gated_we;
    reg_we_check[34] = key_share1_6_gated_we;
    reg_we_check[35] = key_share1_7_gated_we;
    reg_we_check[36] = key_share1_8_gated_we;
    reg_we_check[37] = key_share1_9_gated_we;
    reg_we_check[38] = key_share1_10_gated_we;
    reg_we_check[39] = key_share1_11_gated_we;
    reg_we_check[40] = key_share1_12_gated_we;
    reg_we_check[41] = key_share1_13_gated_we;
    reg_we_check[42] = key_share1_14_gated_we;
    reg_we_check[43] = key_share1_15_gated_we;
    reg_we_check[44] = key_len_gated_we;
    reg_we_check[45] = prefix_0_gated_we;
    reg_we_check[46] = prefix_1_gated_we;
    reg_we_check[47] = prefix_2_gated_we;
    reg_we_check[48] = prefix_3_gated_we;
    reg_we_check[49] = prefix_4_gated_we;
    reg_we_check[50] = prefix_5_gated_we;
    reg_we_check[51] = prefix_6_gated_we;
    reg_we_check[52] = prefix_7_gated_we;
    reg_we_check[53] = prefix_8_gated_we;
    reg_we_check[54] = prefix_9_gated_we;
    reg_we_check[55] = prefix_10_gated_we;
    reg_we_check[56] = 1'b0;
  end

  // Read data return
  always_comb begin
    reg_rdata_next = '0;
    unique case (1'b1)
      addr_hit[0]: begin
        reg_rdata_next[0] = intr_state_kmac_done_qs;
        reg_rdata_next[1] = intr_state_fifo_empty_qs;
        reg_rdata_next[2] = intr_state_kmac_err_qs;
      end

      addr_hit[1]: begin
        reg_rdata_next[0] = intr_enable_kmac_done_qs;
        reg_rdata_next[1] = intr_enable_fifo_empty_qs;
        reg_rdata_next[2] = intr_enable_kmac_err_qs;
      end

      addr_hit[2]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
        reg_rdata_next[2] = '0;
      end

      addr_hit[3]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
      end

      addr_hit[4]: begin
        reg_rdata_next[0] = cfg_regwen_qs;
      end

      addr_hit[5]: begin
        reg_rdata_next[0] = cfg_shadowed_kmac_en_qs;
        reg_rdata_next[3:1] = cfg_shadowed_kstrength_qs;
        reg_rdata_next[5:4] = cfg_shadowed_mode_qs;
        reg_rdata_next[8] = cfg_shadowed_msg_endianness_qs;
        reg_rdata_next[9] = cfg_shadowed_state_endianness_qs;
        reg_rdata_next[12] = cfg_shadowed_sideload_qs;
        reg_rdata_next[17:16] = cfg_shadowed_entropy_mode_qs;
        reg_rdata_next[19] = cfg_shadowed_entropy_fast_process_qs;
        reg_rdata_next[20] = cfg_shadowed_msg_mask_qs;
        reg_rdata_next[24] = cfg_shadowed_entropy_ready_qs;
        reg_rdata_next[26] = cfg_shadowed_en_unsupported_modestrength_qs;
      end

      addr_hit[6]: begin
        reg_rdata_next[5:0] = '0;
        reg_rdata_next[8] = '0;
        reg_rdata_next[9] = '0;
        reg_rdata_next[10] = '0;
      end

      addr_hit[7]: begin
        reg_rdata_next[0] = status_sha3_idle_qs;
        reg_rdata_next[1] = status_sha3_absorb_qs;
        reg_rdata_next[2] = status_sha3_squeeze_qs;
        reg_rdata_next[12:8] = status_fifo_depth_qs;
        reg_rdata_next[14] = status_fifo_empty_qs;
        reg_rdata_next[15] = status_fifo_full_qs;
        reg_rdata_next[16] = status_alert_fatal_fault_qs;
        reg_rdata_next[17] = status_alert_recov_ctrl_update_err_qs;
      end

      addr_hit[8]: begin
        reg_rdata_next[9:0] = entropy_period_prescaler_qs;
        reg_rdata_next[31:16] = entropy_period_wait_timer_qs;
      end

      addr_hit[9]: begin
        reg_rdata_next[9:0] = entropy_refresh_hash_cnt_qs;
      end

      addr_hit[10]: begin
        reg_rdata_next[9:0] = entropy_refresh_threshold_shadowed_qs;
      end

      addr_hit[11]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[12]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[13]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[14]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[15]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[16]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[17]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[18]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[19]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[20]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[21]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[22]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[23]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[24]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[25]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[26]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[27]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[28]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[29]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[30]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[31]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[32]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[33]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[34]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[35]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[36]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[37]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[38]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[39]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[40]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[41]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[42]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[43]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[44]: begin
        reg_rdata_next[2:0] = '0;
      end

      addr_hit[45]: begin
        reg_rdata_next[31:0] = prefix_0_qs;
      end

      addr_hit[46]: begin
        reg_rdata_next[31:0] = prefix_1_qs;
      end

      addr_hit[47]: begin
        reg_rdata_next[31:0] = prefix_2_qs;
      end

      addr_hit[48]: begin
        reg_rdata_next[31:0] = prefix_3_qs;
      end

      addr_hit[49]: begin
        reg_rdata_next[31:0] = prefix_4_qs;
      end

      addr_hit[50]: begin
        reg_rdata_next[31:0] = prefix_5_qs;
      end

      addr_hit[51]: begin
        reg_rdata_next[31:0] = prefix_6_qs;
      end

      addr_hit[52]: begin
        reg_rdata_next[31:0] = prefix_7_qs;
      end

      addr_hit[53]: begin
        reg_rdata_next[31:0] = prefix_8_qs;
      end

      addr_hit[54]: begin
        reg_rdata_next[31:0] = prefix_9_qs;
      end

      addr_hit[55]: begin
        reg_rdata_next[31:0] = prefix_10_qs;
      end

      addr_hit[56]: begin
        reg_rdata_next[31:0] = err_code_qs;
      end

      default: begin
        reg_rdata_next = '1;
      end
    endcase
  end

  // shadow busy
  logic shadow_busy;
  logic rst_done;
  logic shadow_rst_done;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      rst_done <= '0;
    end else begin
      rst_done <= 1'b1;
    end
  end

  always_ff @(posedge clk_i or negedge rst_shadowed_ni) begin
    if (!rst_shadowed_ni) begin
      shadow_rst_done <= '0;
    end else begin
      shadow_rst_done <= 1'b1;
    end
  end

  // both shadow and normal resets have been released
  assign shadow_busy = ~(rst_done & shadow_rst_done);

  // Collect up storage and update errors
  assign shadowed_storage_err_o = |{
    cfg_shadowed_kmac_en_storage_err,
    cfg_shadowed_kstrength_storage_err,
    cfg_shadowed_mode_storage_err,
    cfg_shadowed_msg_endianness_storage_err,
    cfg_shadowed_state_endianness_storage_err,
    cfg_shadowed_sideload_storage_err,
    cfg_shadowed_entropy_mode_storage_err,
    cfg_shadowed_entropy_fast_process_storage_err,
    cfg_shadowed_msg_mask_storage_err,
    cfg_shadowed_entropy_ready_storage_err,
    cfg_shadowed_en_unsupported_modestrength_storage_err,
    entropy_refresh_threshold_shadowed_storage_err
  };
  assign shadowed_update_err_o = |{
    cfg_shadowed_kmac_en_update_err,
    cfg_shadowed_kstrength_update_err,
    cfg_shadowed_mode_update_err,
    cfg_shadowed_msg_endianness_update_err,
    cfg_shadowed_state_endianness_update_err,
    cfg_shadowed_sideload_update_err,
    cfg_shadowed_entropy_mode_update_err,
    cfg_shadowed_entropy_fast_process_update_err,
    cfg_shadowed_msg_mask_update_err,
    cfg_shadowed_entropy_ready_update_err,
    cfg_shadowed_en_unsupported_modestrength_update_err,
    entropy_refresh_threshold_shadowed_update_err
  };

  // register busy
  assign reg_busy = shadow_busy;

  // Unused signal tieoff

  // wdata / byte enable are not always fully used
  // add a blanket unused statement to handle lint waivers
  logic unused_wdata;
  logic unused_be;
  assign unused_wdata = ^reg_wdata;
  assign unused_be = ^reg_be;

  // Assertions for Register Interface
  `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
  `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)

  `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)

  `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)

  // this is formulated as an assumption such that the FPV testbenches do disprove this
  // property by mistake
  //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)

endmodule

    '''

    Identify relevant lint tags for the RTL to be checked for.
    Then run the tests using the linting tool.
    From the output of the linting tool, determine if there are security issues in the RTL.
================================== Ai Message ==================================
Tool Calls:
  retrieve_relevant_lint_tags (call_F7O0SXt9HjwVZDWjJgjfhcBA)
 Call ID: call_F7O0SXt9HjwVZDWjJgjfhcBA
  Args:
    query: register access control privilege escalation shadowed register integrity
================================= Tool Message =================================
Name: retrieve_relevant_lint_tags


W215: Reports inappropriate bit-selects of integer or time variables 


RegisterInfo-ML: Generate a report which includes all registers in RTL design 

ShiftReg: Large shift register detected


STARC05-1.4.3.1b: Clocks should not be gated 


W502: Ensure that a variable in the sensitivity list is not modified inside the xxxviiiSynopsys, Inc. Feedbackalways block 


RegisterStuckInResetState-ML: Reports violation for the registers that are stuck in a constant initial state due to bad coding style 


W450L: Reports multi-bit expression used as latch enable condition 


STARC05-1.3.2.1a: Asynchronous resets or sets must not be gated 


STARC05-1.2.1.1a: Design should use only one edge of a clock 


sim_race07: Non-blocking assignment should not be used in clock or enable path 


W182k: Reports trireg declarations that are not synthesizable 


W336L: Blocking assignment to latch output should be avoided 


STARC05-1.6.1.2: Modules instantiating basic blocks must not contain lxiiiSynopsys, Inc.Feedbacklogic gates 

W243: Recursive task enable


STARC05-3.3.1.4a: Asynchronous sets/resets must be controllable from external pins 


W415: Reports variable/signals that do not infer a tristate and have xxxviSynopsys, Inc. Feedbackmultiple simultaneous drivers 


STARC05-2.10.5.3b: Reports violation when there are three or more arithmetic operations in Always block 


STARC05-2.5.1.2: Ensure that logic does not exist in tristate enable conditions


W314: Converting multi-bit reg type to single bit 


ClockEnableRace: Reports a race condition between clock and enable pins of a flip-flop 
================================== Ai Message ==================================
Tool Calls:
  lint_checker_tool (call_CGfdfJjPROhdxqfwytGYyM7a)
 Call ID: call_CGfdfJjPROhdxqfwytGYyM7a
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_reg_top.sv
    top_module: kmac_reg_top
    lint_tags: ['RegisterInfo-ML', 'STARC05-1.4.3.1b', 'STARC05-1.3.2.1a', 'STARC05-1.2.1.1a', 'sim_race07', 'STARC05-3.3.1.4a', 'ClockEnableRace']
================================= Tool Message =================================
Name: lint_checker_tool

Successfully executed:
```lint checker tool
```
Output: 
  -----------------------------------------------------------------------------
  Report Summary
  -----------------------------------------------------------------------------
  Product Info
    Name    : VC Static Master Shell
    Version : U-2023.03-1 -- Apr 17, 2023

  Report Info
    Created : May 06, 2025  16:46:36

    TopLevelModule: kmac_reg_top

  -----------------------------------------------------------------------------
  Management Summary
  -----------------------------------------------------------------------------
  Stage             Family      Fatals    Errors  Warnings     Infos
  -----             --------  --------  --------  --------  --------
  STRUCTURAL_CHECK  CODING           0         1         0         0
  -----             --------  --------  --------  --------  --------
  Total                              0         1         0         0


  -----------------------------------------------------------------------------
  Tree Summary
  -----------------------------------------------------------------------------
  Severity  Stage             Tag                Count
  --------  -----             -----------------  -----
  error     STRUCTURAL_CHECK  RegisterInfo-ML        1
  --------  -----             -----------------  -----
  Total                                              1



  -----------------------------------------------------------------------------
  RegisterInfo-ML  (1 error/0 waived)
  -----------------------------------------------------------------------------
  Tag             : RegisterInfo-ML
  Description     : Please check the report 'all_register_info.rpt' for details on all registers in design
  Violation       : Lint:1
  Module          : kmac_reg_top
  FileName        : /home/XXXX-2/security_agents/vcst_rtdb/reports/all_register_info.rpt
  LineNumber      : 0

================================== Ai Message ==================================

The lint check was run on the provided RTL code for the top module kmac_reg_top with relevant lint tags related to register access control, privilege escalation, and shadowed register integrity.

The lint tool reported one error under the tag RegisterInfo-ML. This error suggests checking the detailed report 'all_register_info.rpt' for information on all registers in the design. There were no warnings or other errors related to clock gating, asynchronous resets gating, or race conditions.

Summary:
- One error reported by RegisterInfo-ML (details in a separate report file).
- No warnings or errors related to clock gating or asynchronous reset gating.
- No direct indication of privilege escalation or shadowed register integrity issues from this lint run.

Recommendation:
- Review the detailed register report 'all_register_info.rpt' to understand the register-related error.
- Manually inspect the RTL for access control mechanisms and privilege checks, as the lint did not flag explicit issues but might not cover all security aspects.
- Consider additional security-focused lint or formal verification tools specialized for privilege escalation and shadow register integrity if available.

Based on the lint output alone, no explicit security issues were detected in the RTL regarding register access control, privilege escalation, or shadowed register integrity.
================================= Tool Message =================================
Name: run_linter_agent

The lint check was run on the provided RTL code for the top module kmac_reg_top with relevant lint tags related to register access control, privilege escalation, and shadowed register integrity.

The lint tool reported one error under the tag RegisterInfo-ML. This error suggests checking the detailed report 'all_register_info.rpt' for information on all registers in the design. There were no warnings or other errors related to clock gating, asynchronous resets gating, or race conditions.

Summary:
- One error reported by RegisterInfo-ML (details in a separate report file).
- No warnings or errors related to clock gating or asynchronous reset gating.
- No direct indication of privilege escalation or shadowed register integrity issues from this lint run.

Recommendation:
- Review the detailed register report 'all_register_info.rpt' to understand the register-related error.
- Manually inspect the RTL for access control mechanisms and privilege checks, as the lint did not flag explicit issues but might not cover all security aspects.
- Consider additional security-focused lint or formal verification tools specialized for privilege escalation and shadow register integrity if available.

Based on the lint output alone, no explicit security issues were detected in the RTL regarding register access control, privilege escalation, or shadowed register integrity.
================================== Ai Message ==================================
Tool Calls:
  run_assertions_checker_agent (call_kjLtzCdRBNZWUomTUFkcT3me)
 Call ID: call_kjLtzCdRBNZWUomTUFkcT3me
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv
    top_module: kmac_app
    security_objective: application interface isolation, privilege escalation, command injection
================================ Human Message =================================

Are there security concerns related to application interface isolation, privilege escalation, command injection in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv

    And the top module is:

    kmac_app

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// KMAC Application interface

`include "prim_assert.sv"

module kmac_app
  import kmac_pkg::*;
#(
  // App specific configs are defined in kmac_pkg
  parameter  bit EnMasking = 1'b0,
  localparam int Share = (EnMasking) ? 2 : 1, // derived parameter
  parameter  bit SecIdleAcceptSwMsg = 1'b0
) (
  input clk_i,
  input rst_ni,

  // Secret Key from register
  input [MaxKeyLen-1:0] reg_key_data_i [Share],
  input key_len_e       reg_key_len_i,

  // Prefix from register
  input [sha3_pkg::NSRegisterSize*8-1:0] reg_prefix_i,

  // mode, strength, kmac_en from register
  input                             reg_kmac_en_i,
  input sha3_pkg::sha3_mode_e       reg_sha3_mode_i,
  input sha3_pkg::keccak_strength_e reg_keccak_strength_i,

  // Data from Software
  input                sw_valid_i,
  input [MsgWidth-1:0] sw_data_i,
  input [MsgWidth-1:0] sw_mask_i,
  output logic         sw_ready_o,

  // KeyMgr Sideload Key interface
  input keymgr_pkg::hw_key_req_t keymgr_key_i,

  // Application Message in/ Digest out interface + control signals
  input  app_req_t [NumAppIntf-1:0] app_i,
  output app_rsp_t [NumAppIntf-1:0] app_o,

  // to KMAC Core: Secret key
  output logic [MaxKeyLen-1:0] key_data_o [Share],
  output key_len_e             key_len_o,
  output logic                 key_valid_o,

  // to MSG_FIFO
  output logic                kmac_valid_o,
  output logic [MsgWidth-1:0] kmac_data_o,
  output logic [MsgWidth-1:0] kmac_mask_o,
  input                       kmac_ready_i,

  // KMAC Core
  output logic kmac_en_o,

  // To Sha3 Core
  output logic [sha3_pkg::NSRegisterSize*8-1:0] sha3_prefix_o,
  output sha3_pkg::sha3_mode_e                  sha3_mode_o,
  output sha3_pkg::keccak_strength_e            keccak_strength_o,

  // STATE from SHA3 Core
  input                        keccak_state_valid_i,
  input [sha3_pkg::StateW-1:0] keccak_state_i [Share],

  // to STATE TL-window if Application is not active, the incoming state goes to
  // register if kdf_en is set, the state value goes to application and the
  // output to the register is all zero.
  output logic                        reg_state_valid_o,
  output logic [sha3_pkg::StateW-1:0] reg_state_o [Share],

  // Configurations If key_en is set, the logic uses KeyMgr's sideloaded key as
  // a secret key rather than register values. This only affects when software
  // initiates. If App initiates the hash operation and uses KMAC algorithm, it
  // always uses sideloaded key.
  input keymgr_key_en_i,

  // Commands
  // Command from software
  input kmac_cmd_e sw_cmd_i,

  // from SHA3
  input prim_mubi_pkg::mubi4_t absorbed_i,

  // to KMAC
  output kmac_cmd_e cmd_o,

  // to SW
  output prim_mubi_pkg::mubi4_t absorbed_o,

  // To status
  output logic app_active_o,

  // Status
  // - entropy_ready_i: Entropy configured by SW. It is used to check if App
  //                    is OK to request.
  input prim_mubi_pkg::mubi4_t entropy_ready_i,

  // Error input
  // This error comes from KMAC/SHA3 engine.
  // KeyMgr interface delivers the error signal to KeyMgr to drop the current op
  // and re-initiate.
  // If error happens, regardless of SW-initiated or KeyMgr-initiated, the error
  // is reported to the ERR_CODE so that SW can look into.
  input error_i,

  // SW sets err_processed bit in CTRL then the logic goes to Idle
  input err_processed_i,

  output prim_mubi_pkg::mubi4_t clear_after_error_o,

  // error_o value is pushed to Error FIFO at KMAC/SHA3 top and reported to SW
  output kmac_pkg::err_t error_o,

  // Life cycle
  input  lc_ctrl_pkg::lc_tx_t lc_escalate_en_i,

  output logic sparse_fsm_error_o
);

  import sha3_pkg::KeccakBitCapacity;
  import sha3_pkg::L128;
  import sha3_pkg::L224;
  import sha3_pkg::L256;
  import sha3_pkg::L384;
  import sha3_pkg::L512;

  /////////////////
  // Definitions //
  /////////////////

  // Digest width is same to the key width `keymgr_pkg::KeyWidth`.
  localparam int KeyMgrKeyW = $bits(keymgr_key_i.key[0]);

  localparam key_len_e KeyLengths [5] = '{Key128, Key192, Key256, Key384, Key512};

  localparam int SelKeySize = (AppKeyW == 128) ? 0 :
                              (AppKeyW == 192) ? 1 :
                              (AppKeyW == 256) ? 2 :
                              (AppKeyW == 384) ? 3 :
                              (AppKeyW == 512) ? 4 : 0 ;
  localparam int SelDigSize = (AppDigestW == 128) ? 0 :
                              (AppDigestW == 192) ? 1 :
                              (AppDigestW == 256) ? 2 :
                              (AppDigestW == 384) ? 3 :
                              (AppDigestW == 512) ? 4 : 0 ;
  localparam key_len_e SideloadedKey = KeyLengths[SelKeySize];

  // Define right_encode(outlen) value here
  // Look at kmac_pkg::key_len_e for the kinds of key size
  //
  // These values should be exactly the same as the key length encodings
  // in kmac_core.sv, with the only difference being that the byte representing
  // the byte-length of the encoded value is in the MSB position due to right encoding
  // instead of in the LSB position (left encoding).
  localparam int OutLenW = 24;
  localparam logic [OutLenW-1:0] EncodedOutLen [5]= '{
    24'h 0001_80, // Key128
    24'h 0001_C0, // Key192
    24'h 02_0001, // Key256
    24'h 02_8001, // Key384
    24'h 02_0002  // Key512
  };

  localparam logic [OutLenW-1:0] EncodedOutLenMask [5] = '{
    24'h 00FFFF, // Key128,
    24'h 00FFFF, // Key192
    24'h FFFFFF, // Key256
    24'h FFFFFF, // Key384
    24'h FFFFFF  // Key512
  };

  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 3 -m 14 -n 10 \
  //     -s 2454278799 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: |||||||||| (14.29%)
  //  4: |||||||||||||||||||| (27.47%)
  //  5: ||||||||||||| (18.68%)
  //  6: |||||||||||||||| (21.98%)
  //  7: |||||||| (10.99%)
  //  8: |||| (6.59%)
  //  9: --
  // 10: --
  //
  // Minimum Hamming distance: 3
  // Maximum Hamming distance: 8
  // Minimum Hamming weight: 3
  // Maximum Hamming weight: 8
  //
  localparam int StateWidth = 10;
  typedef enum logic [StateWidth-1:0] {
    StIdle = 10'b1010111110,

    // Application operation.
    //
    // if start request comes from an App first, until the operation ends by the
    // requested App, all operations are granted to the specific App. SW
    // requests and other Apps requests will be ignored.
    //
    // App interface does not have control signals. When first data valid occurs
    // from an App, this logic asserts the start command to the downstream. When
    // last beat pulse comes, this logic asserts the process to downstream
    // (after the transaction is accepted regardless of partial writes or not)
    // When absorbed by SHA3 core, the logic sends digest to the requested App
    // and right next cycle, it triggers done command to downstream.

    // In StAppCfg state, it latches the cfg from AppCfg parameter to determine
    // the kmac_mode, sha3_mode, keccak strength.
    StAppCfg = 10'b1010101101,

    StAppMsg = 10'b1110001011,

    // In StKeyOutLen, this module pushes encoded outlen to the MSG_FIFO.
    // Assume the length is 256 bit, the data will be 48'h 02_0100
    StAppOutLen  = 10'b1010011000,
    StAppProcess = 10'b1110110010,
    StAppWait    = 10'b1001010000,

    // SW Controlled
    // If start request comes from SW first, until the operation ends, all
    // requests from KeyMgr will be discarded.
    StSw = 10'b0010111011,

    // Error KeyNotValid
    // When KeyMgr operates, the secret key is not ready yet.
    StKeyMgrErrKeyNotValid = 10'b0111011111,

    StError = 10'b1110010111,
    StErrorAwaitSw = 10'b0110001100,
    StErrorAwaitApp = 10'b1011100000,
    StErrorWaitAbsorbed = 10'b0010100100,
    StErrorServiceRejected = 10'b1101000111,

    // This state is used for terminal errors
    StTerminalError = 10'b0101110110
  } st_e;

  /////////////
  // Signals //
  /////////////

  st_e st, st_d;

  logic keymgr_key_used;

  // app_rsp_t signals
  // The state machine controls mux selection, which controls the ready signal
  // the other responses are controled in separate logic. So define the signals
  // here and merge them to the response.
  logic app_data_ready, fsm_data_ready;
  logic app_digest_done, fsm_digest_done_q, fsm_digest_done_d;
  logic [AppDigestW-1:0] app_digest [2];

  // One more slot for value NumAppIntf. It is the value when no app intf is
  // chosen.
  localparam int unsigned AppIdxW = $clog2(NumAppIntf);

  // app_id indicates, which app interface was chosen. various logic use this
  // value to get the config or return the data.
  logic [AppIdxW-1:0] app_id, app_id_d;
  logic               clr_appid, set_appid;

  // Output length
  logic [OutLenW-1:0] encoded_outlen, encoded_outlen_mask;

  // state output
  // Mux selection signal
  app_mux_sel_e mux_sel;
  app_mux_sel_e mux_sel_buf_output;
  app_mux_sel_e mux_sel_buf_err_check;
  app_mux_sel_e mux_sel_buf_kmac;

  // Error checking logic

  kmac_pkg::err_t fsm_err, mux_err;

  logic service_rejected_error;
  logic service_rejected_error_set, service_rejected_error_clr;
  logic err_during_sw_d, err_during_sw_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni)                         service_rejected_error <= 1'b 0;
    else if (service_rejected_error_set) service_rejected_error <= 1'b 1;
    else if (service_rejected_error_clr) service_rejected_error <= 1'b 0;
  end

  ////////////////////////////
  // Application Mux/ Demux //
  ////////////////////////////


  // Processing return data.
  // sends to only selected app intf.
  // clear digest right after done to not leak info to other interface
  always_comb begin
    for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
      if (i == app_id) begin
        app_o[i] = '{
          ready:         app_data_ready | fsm_data_ready,
          done:          app_digest_done | fsm_digest_done_q,
          digest_share0: app_digest[0],
          digest_share1: app_digest[1],
          // if fsm asserts done, should be an error case.
          error:         error_i | fsm_digest_done_q | sparse_fsm_error_o
                         | service_rejected_error
        };
      end else begin
        app_o[i] = '{
          ready: 1'b 0,
          done:  1'b 0,
          digest_share0: '0,
          digest_share1: '0,
          error: 1'b 0
        };
      end
    end // for {i, NumAppIntf, i++}
  end // aiways_comb

  // app_id latch
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) app_id <= AppIdxW'(0) ; // Do not select any
    else if (clr_appid) app_id <= AppIdxW'(0);
    else if (set_appid) app_id <= app_id_d;
  end

  // app_id selection as of now, app_id uses Priority. The assumption is that
  //  the request normally does not collide. (ROM_CTRL activates very early
  //  stage at the boot sequence)
  //
  //  If this assumption is not true, consider RR arbiter.

  // Prep for arbiter
  logic [NumAppIntf-1:0] app_reqs;
  logic [NumAppIntf-1:0] unused_app_gnts;
  logic [$clog2(NumAppIntf)-1:0] arb_idx;
  logic arb_valid;
  logic arb_ready;

  always_comb begin
    app_reqs = '0;
    for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
      app_reqs[i] = app_i[i].valid;
    end
  end

  prim_arbiter_fixed #(
    .N (NumAppIntf),
    .DW(1),
    .EnDataPort(1'b 0)
  ) u_appid_arb (
    .clk_i,
    .rst_ni,

    .req_i  (app_reqs),
    .data_i ('{default:'0}),
    .gnt_o  (unused_app_gnts),
    .idx_o  (arb_idx),

    .valid_o (arb_valid),
    .data_o  (), // not used
    .ready_i (arb_ready)
  );

  assign app_id_d = AppIdxW'(arb_idx);
  assign arb_ready = set_appid;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) fsm_digest_done_q <= 1'b 0;
    else         fsm_digest_done_q <= fsm_digest_done_d;
  end

  /////////
  // FSM //
  /////////

  // State register
  `PRIM_FLOP_SPARSE_FSM(u_state_regs, st_d, st, st_e, StIdle)

  // Create a lint error to reduce the risk of accidentally enabling this feature.
  `ASSERT_STATIC_LINT_ERROR(KmacSecIdleAcceptSwMsgNonDefault, SecIdleAcceptSwMsg == 0)

  // Next State & output logic
  // SEC_CM: FSM.SPARSE
  always_comb begin
    st_d = st;

    mux_sel = SecIdleAcceptSwMsg ? SelSw : SelNone;

    // app_id control
    set_appid = 1'b 0;
    clr_appid = 1'b 0;

    // Commands
    cmd_o = CmdNone;

    // Software output
    absorbed_o = prim_mubi_pkg::MuBi4False;

    // Error
    fsm_err = '{valid: 1'b 0, code: ErrNone, info: '0};
    sparse_fsm_error_o = 1'b 0;

    clear_after_error_o = prim_mubi_pkg::MuBi4False;

    service_rejected_error_set = 1'b 0;
    service_rejected_error_clr = 1'b 0;

    // If error happens, FSM asserts data ready but discard incoming msg
    fsm_data_ready = 1'b 0;
    fsm_digest_done_d = 1'b 0;

    unique case (st)
      StIdle: begin
        if (arb_valid) begin
          st_d = StAppCfg;

          // choose app_id
          set_appid = 1'b 1;
        end else if (sw_cmd_i == CmdStart) begin
          st_d = StSw;
          // Software initiates the sequence
          cmd_o = CmdStart;
        end else begin
          st_d = StIdle;
        end
      end

      StAppCfg: begin
        if (AppCfg[app_id].Mode == AppKMAC &&
          prim_mubi_pkg::mubi4_test_false_strict(entropy_ready_i)) begin
          // Check if the entropy is not configured but it is needed in
          // `AppCfg[app_id]` (KMAC mode).
          //
          // SW is not properly configured, report and not request Hashing
          // Return the app with errors
          st_d = StError;

          service_rejected_error_set = 1'b 1;

        end else begin
          // As Cfg is stable now, it sends cmd
          st_d = StAppMsg;

          // App initiates the data
          cmd_o = CmdStart;
        end
      end

      StAppMsg: begin
        mux_sel = SelApp;
        if (app_i[app_id].valid && app_o[app_id].ready && app_i[app_id].last) begin
          if (AppCfg[app_id].Mode == AppKMAC) begin
            st_d = StAppOutLen;
          end else begin
            st_d = StAppProcess;
          end
        end else begin
          st_d = StAppMsg;
        end
      end

      StAppOutLen: begin
        mux_sel = SelOutLen;

        if (kmac_valid_o && kmac_ready_i) begin
          st_d = StAppProcess;
        end else begin
          st_d = StAppOutLen;
        end
      end

      StAppProcess: begin
        cmd_o = CmdProcess;
        st_d = StAppWait;
      end

      StAppWait: begin
        if (prim_mubi_pkg::mubi4_test_true_strict(absorbed_i)) begin
          // Send digest to KeyMgr and complete the op
          st_d = StIdle;
          cmd_o = CmdDone;

          clr_appid = 1'b 1;
        end else begin
          st_d = StAppWait;
        end
      end

      StSw: begin
        mux_sel = SelSw;

        cmd_o = sw_cmd_i;
        absorbed_o = absorbed_i;

        if (sw_cmd_i == CmdDone) begin
          st_d = StIdle;
        end else begin
          st_d = StSw;
        end
      end

      StKeyMgrErrKeyNotValid: begin
        st_d = StError;

        // As mux_sel is not set to SelApp, app_data_ready is still 0.
        // This logic won't accept the requests from the selected App.
        fsm_err.valid = 1'b 1;
        fsm_err.code = ErrKeyNotValid;
        fsm_err.info = 24'(app_id);
      end

      StError: begin
        // In this state, the state machine flush out the request
        st_d = StError;

        // Absorb data on the app interface.
        fsm_data_ready = ~err_during_sw_q;

        // Next step depends on two conditions:
        // 1) Error being processed by SW
        // 2) Last data provided from the app interface (so that the app interface is completely)
        //    drained.  If the error occurred during a SW operation, the app interface is not
        //    involved, so this condition gets skipped.
        unique case ({err_processed_i,
                      (app_i[app_id].valid && app_i[app_id].last) || err_during_sw_q})
          2'b00: begin
            // Error not processed by SW and not last data from app interface -> keep current state.
            st_d = StError;
          end
          2'b01: begin
            // Error not processed by SW but last data from app interface:
            // 1. Send garbage digest to the app interface (in the next cycle) to complete the
            // transaction.
            fsm_digest_done_d = ~err_during_sw_q;
            if (service_rejected_error) begin
              // 2.a) Service was rejected because an app interface tried to configure KMAC while no
              // entropy was available. It is assumed that SW is not loaded yet, so don't wait for
              // SW to process the error. The last data from the app interface has now arrived, but
              // we don't need to wait for the SHA3 core to have absorbed it because the data never
              // entered the SHA3 core: the request from the app interface was terminated during the
              // configuration phase.
              st_d = StErrorServiceRejected;
            end else begin
              // 2.b) If service was not rejected, wait for SW to process the error.
              st_d = StErrorAwaitSw;
            end
          end
          2'b10: begin
            // Error processed by SW but not last data from app interface -> wait for app interface.
            st_d = StErrorAwaitApp;
          end
          2'b11: begin
            // Error processed by SW and last data from app interface:
            // Send garbage digest to the app interface (in the next cycle) to complete the
            // transaction.
            fsm_digest_done_d = ~err_during_sw_q;
            // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
            // but serves to bring the SHA3 engine back to the idle state).
            cmd_o = CmdProcess;
            st_d = StErrorWaitAbsorbed;
          end
          default: st_d = StError;
        endcase
      end

      StErrorAwaitSw: begin
        // Just wait for SW to process the error.
        if (err_processed_i) begin
          // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
          // but serves to bring the SHA3 engine back to the idle state).
          cmd_o = CmdProcess;
          st_d = StErrorWaitAbsorbed;
        end
      end

      StErrorAwaitApp: begin
        // Keep absorbing data on the app interface until the last data.
        fsm_data_ready = 1'b1;
        if (app_i[app_id].valid && app_i[app_id].last) begin
          // Send garbage digest to the app interface (in the next cycle) to complete the
          // transaction.
          fsm_digest_done_d = 1'b1;
          // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
          // but serves to bring the SHA3 engine back to the idle state).
          cmd_o = CmdProcess;
          st_d = StErrorWaitAbsorbed;
        end
      end

      StErrorWaitAbsorbed: begin
        if (prim_mubi_pkg::mubi4_test_true_strict(absorbed_i)) begin
          // Clear internal variables, send done command, and return to idle.
          clr_appid = 1'b1;
          clear_after_error_o = prim_mubi_pkg::MuBi4True;
          service_rejected_error_clr = 1'b1;
          cmd_o = CmdDone;
          st_d = StIdle;
          // If error originated from SW, report 'absorbed' to SW.
          if (err_during_sw_q) begin
            absorbed_o = prim_mubi_pkg::MuBi4True;
          end
        end
      end

      StErrorServiceRejected: begin
        // Clear internal variables and return to idle.
        clr_appid = 1'b1;
        clear_after_error_o = prim_mubi_pkg::MuBi4True;
        service_rejected_error_clr = 1'b1;
        st_d = StIdle;
      end

      StTerminalError: begin
        // this state is terminal
        st_d = st;
        sparse_fsm_error_o = 1'b 1;
        fsm_err.valid = 1'b 1;
        fsm_err.code = ErrFatalError;
        fsm_err.info = 24'(app_id);
      end

      default: begin
        st_d = StTerminalError;
        sparse_fsm_error_o = 1'b 1;
      end
    endcase

    // SEC_CM: FSM.GLOBAL_ESC, FSM.LOCAL_ESC
    // Unconditionally jump into the terminal error state
    // if the life cycle controller triggers an escalation.
    if (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) begin
      st_d = StTerminalError;
    end

    // Handle errors outside the terminal error state.
    if (st_d != StTerminalError) begin
      // Key from keymgr is used but not valid, so abort into the invalid key error state.
      if (keymgr_key_used && !keymgr_key_i.valid) begin
        st_d = StKeyMgrErrKeyNotValid;
      end
    end
  end

  // Track errors occurring in SW mode.
  assign err_during_sw_d =
      (mux_sel == SelSw) && (st_d inside {StError, StKeyMgrErrKeyNotValid}) ? 1'b1 : // set
      (st_d == StIdle)                                                      ? 1'b0 : // clear
      err_during_sw_q;                                                               // hold

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      err_during_sw_q <= 1'b0;
    end else begin
      err_during_sw_q <= err_during_sw_d;
    end
  end

  //////////////
  // Datapath //
  //////////////

  // Encoded output length
  assign encoded_outlen      = EncodedOutLen[SelDigSize];
  assign encoded_outlen_mask = EncodedOutLenMask[SelKeySize];

  // Data mux
  // This is the main part of the KeyMgr interface logic.
  // The FSM selects KeyMgr interface in a cycle after it receives the first
  // valid data from KeyMgr. The ready signal to the KeyMgr data interface
  // represents the MSG_FIFO ready, only when it is in StKeyMgrMsg state.
  // After KeyMgr sends last beat, the kmac interface (to MSG_FIFO) is switched
  // to OutLen. OutLen is pre-defined values. See `EncodeOutLen` parameter above.
  always_comb begin
    app_data_ready = 1'b 0;
    sw_ready_o = 1'b 1;

    kmac_valid_o = 1'b 0;
    kmac_data_o = '0;
    kmac_mask_o = '0;

    unique case (mux_sel_buf_kmac)
      SelApp: begin
        // app_id is valid at this time
        kmac_valid_o = app_i[app_id].valid;
        kmac_data_o  = app_i[app_id].data;
        // Expand strb to bits. prim_packer inside MSG_FIFO accepts the bit masks
        for (int i = 0 ; i < $bits(app_i[app_id].strb) ; i++) begin
          kmac_mask_o[8*i+:8] = {8{app_i[app_id].strb[i]}};
        end
        app_data_ready = kmac_ready_i;
      end

      SelOutLen: begin
        // Write encoded output length value
        kmac_valid_o = 1'b 1; // always write
        kmac_data_o  = MsgWidth'(encoded_outlen);
        kmac_mask_o  = MsgWidth'(encoded_outlen_mask);
      end

      SelSw: begin
        kmac_valid_o = sw_valid_i;
        kmac_data_o  = sw_data_i ;
        kmac_mask_o  = sw_mask_i ;
        sw_ready_o   = kmac_ready_i ;
      end

      default: begin // Incl. SelNone
        kmac_valid_o = 1'b 0;
        kmac_data_o = '0;
        kmac_mask_o = '0;
      end

    endcase
  end

  // Error checking for Mux
  always_comb begin
    mux_err = '{valid: 1'b 0, code: ErrNone, info: '0};

    if (mux_sel_buf_err_check != SelSw && sw_valid_i) begin
      // If SW writes message into FIFO
      mux_err = '{
        valid: 1'b 1,
        code: ErrSwPushedMsgFifo,
        info: 24'({8'h 00, 8'(st), 8'(mux_sel_buf_err_check)})
      };
    end else if (app_active_o && sw_cmd_i != CmdNone) begin
      // If SW issues command except start
      mux_err = '{
        valid: 1'b 1,
        code: ErrSwIssuedCmdInAppActive,
        info: 24'(sw_cmd_i)
      };
    end
  end

  logic [AppMuxWidth-1:0] mux_sel_buf_output_logic;
  assign mux_sel_buf_output = app_mux_sel_e'(mux_sel_buf_output_logic);

  // SEC_CM: LOGIC.INTEGRITY
  prim_sec_anchor_buf #(
   .Width(AppMuxWidth)
  ) u_prim_buf_state_output_sel (
    .in_i(mux_sel),
    .out_o(mux_sel_buf_output_logic)
  );

  logic [AppMuxWidth-1:0] mux_sel_buf_err_check_logic;
  assign mux_sel_buf_err_check = app_mux_sel_e'(mux_sel_buf_err_check_logic);

  // SEC_CM: LOGIC.INTEGRITY
  prim_sec_anchor_buf #(
   .Width(AppMuxWidth)
  ) u_prim_buf_state_err_check (
    .in_i(mux_sel),
    .out_o(mux_sel_buf_err_check_logic)
  );

  logic [AppMuxWidth-1:0] mux_sel_buf_kmac_logic;
  assign mux_sel_buf_kmac = app_mux_sel_e'(mux_sel_buf_kmac_logic);

  // SEC_CM: LOGIC.INTEGRITY
  prim_sec_anchor_buf #(
   .Width(AppMuxWidth)
  ) u_prim_buf_state_kmac_sel (
    .in_i(mux_sel),
    .out_o(mux_sel_buf_kmac_logic)
  );

  // SEC_CM: LOGIC.INTEGRITY
  logic reg_state_valid;
  prim_sec_anchor_buf #(
   .Width(1)
  ) u_prim_buf_state_output_valid (
    .in_i(reg_state_valid),
    .out_o(reg_state_valid_o)
  );

  // Keccak state Demux
  // Keccak state --> Register output is enabled when state is in StSw
  always_comb begin
    reg_state_valid = 1'b 0;
    reg_state_o = '{default:'0};
    if ((mux_sel_buf_output == SelSw) &&
         lc_ctrl_pkg::lc_tx_test_false_strict(lc_escalate_en_i)) begin
      reg_state_valid = keccak_state_valid_i;
      reg_state_o = keccak_state_i;
      // If key is sideloaded and KMAC is SW initiated
      // hide the capacity from SW by zeroing (see #17508)
      if (keymgr_key_en_i) begin
        for (int i = 0; i < Share; i++) begin
          unique case (reg_keccak_strength_i)
            L128: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L128]] = '0;
            L224: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L224]] = '0;
            L256: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L256]] = '0;
            L384: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L384]] = '0;
            L512: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L512]] = '0;
            default: reg_state_o[i] = '0;
          endcase
        end
      end
    end
  end

  // Keccak state --> KeyMgr
  always_comb begin
    app_digest_done = 1'b 0;
    app_digest = '{default:'0};
    if (st == StAppWait && prim_mubi_pkg::mubi4_test_true_strict(absorbed_i) &&
       lc_ctrl_pkg::lc_tx_test_false_strict(lc_escalate_en_i)) begin
      // SHA3 engine has calculated the hash. Return the data to KeyMgr
      app_digest_done = 1'b 1;

      // digest has always 2 entries. If !EnMasking, second is tied to 0.
      for (int i = 0 ; i < Share ; i++) begin
        // Return the portion of state.
        app_digest[i] = keccak_state_i[i][AppDigestW-1:0];
      end
    end
  end


  // Secret Key Mux

  // Prepare merged key if EnMasking is not set.
  // Combine share keys into unpacked array for logic below to assign easily.
  // SEC_CM: KEY.SIDELOAD
  logic [MaxKeyLen-1:0] keymgr_key [Share];
  if (EnMasking == 1) begin : g_masked_key
    for (genvar i = 0; i < Share; i++) begin : gen_key_pad
      assign keymgr_key[i] =  {(MaxKeyLen-KeyMgrKeyW)'(0), keymgr_key_i.key[i]};
    end
  end else begin : g_unmasked_key
    always_comb begin
      keymgr_key[0] = '0;
      for (int i = 0; i < keymgr_pkg::Shares; i++) begin
        keymgr_key[0][KeyMgrKeyW-1:0] ^= keymgr_key_i.key[i];
      end
    end
  end

  // Sideloaded key manage: Keep use sideloaded key for KMAC AppIntf until the
  // hashing operation is finished.
  always_comb begin
    keymgr_key_used = 1'b0;
    key_len_o  = reg_key_len_i;
    for (int i = 0 ; i < Share; i++) begin
      key_data_o[i] = reg_key_data_i[i];
    end
    // The key is considered invalid in all cases that are not listed below (which includes idle and
    // error states).
    key_valid_o = 1'b0;

    unique case (st)
      StAppCfg, StAppMsg, StAppOutLen, StAppProcess, StAppWait: begin
        // Key from keymgr is actually used if the current HW app interface does *keyed* MAC.
        keymgr_key_used = AppCfg[app_id].Mode == AppKMAC;
        key_len_o = SideloadedKey;
        for (int i = 0 ; i < Share; i++) begin
          key_data_o[i] = keymgr_key[i];
        end
        // Key is valid if the current HW app interface does *keyed* MAC and the key provided by
        // keymgr is valid.
        key_valid_o = keymgr_key_used && keymgr_key_i.valid;
      end

      StSw: begin
        if (keymgr_key_en_i) begin
          // Key from keymgr is actually used if *keyed* MAC is enabled.
          keymgr_key_used = kmac_en_o;
          key_len_o = SideloadedKey;
          for (int i = 0 ; i < Share; i++) begin
            key_data_o[i] = keymgr_key[i];
          end
        end
        // Key is valid if SW does *keyed* MAC and ...
        if (kmac_en_o) begin
          if (!keymgr_key_en_i) begin
            // ... it uses the key from kmac's CSR, or ...
            key_valid_o = 1'b1;
          end else begin
            // ... it uses the key provided by keymgr and that one is valid.
            key_valid_o = keymgr_key_i.valid;
          end
        end
      end

      default: ;
    endcase
  end

  // Prefix Demux
  // For SW, always prefix register.
  // For App intf, check PrefixMode cfg and if 1, use Prefix cfg.
  always_comb begin
    sha3_prefix_o = '0;

    unique case (st)
      StAppCfg, StAppMsg, StAppOutLen, StAppProcess, StAppWait: begin
        // Check app intf cfg
        for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
          if (app_id == i) begin
            if (AppCfg[i].PrefixMode == 1'b 0) begin
              sha3_prefix_o = reg_prefix_i;
            end else begin
              sha3_prefix_o = AppCfg[i].Prefix;
            end
          end
        end
      end

      StSw: begin
        sha3_prefix_o = reg_prefix_i;
      end

      default: begin
        sha3_prefix_o = reg_prefix_i;
      end
    endcase
  end

  // KMAC en / SHA3 mode / Strength
  //  by default, it uses reg cfg. When app intf reqs come, it uses AppCfg.
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      kmac_en_o         <= 1'b 0;
      sha3_mode_o       <= sha3_pkg::Sha3;
      keccak_strength_o <= sha3_pkg::L256;
    end else if (clr_appid) begin
      // As App completed, latch reg value
      kmac_en_o         <= reg_kmac_en_i;
      sha3_mode_o       <= reg_sha3_mode_i;
      keccak_strength_o <= reg_keccak_strength_i;
    end else if (set_appid) begin
      kmac_en_o         <= AppCfg[arb_idx].Mode == AppKMAC ? 1'b 1 : 1'b 0;
      sha3_mode_o       <= AppCfg[arb_idx].Mode == AppSHA3
                           ? sha3_pkg::Sha3 : sha3_pkg::CShake;
      keccak_strength_o <= AppCfg[arb_idx].Strength ;
    end else if (st == StIdle) begin
      kmac_en_o         <= reg_kmac_en_i;
      sha3_mode_o       <= reg_sha3_mode_i;
      keccak_strength_o <= reg_keccak_strength_i;
    end
  end

  // Status
  assign app_active_o = (st inside {StAppCfg, StAppMsg, StAppOutLen,
                                    StAppProcess, StAppWait});

  // Error Reporting ==========================================================
  always_comb begin
    priority casez ({fsm_err.valid, mux_err.valid})
      2'b ?1: error_o = mux_err;
      2'b 10: error_o = fsm_err;
      default: error_o = '{valid: 1'b0, code: ErrNone, info: '0};
    endcase
  end

  ////////////////
  // Assertions //
  ////////////////

  // KeyMgr sideload key and the digest should be in the Key Length value
  `ASSERT_INIT(SideloadKeySameToDigest_A, KeyMgrKeyW <= AppDigestW)
  `ASSERT_INIT(AppIntfInRange_A, AppDigestW inside {128, 192, 256, 384, 512})

  // Issue(#13655): Having a coverage that sideload keylen and CSR keylen are
  // different.
  `COVER(AppIntfUseDifferentSizeKey_C,
    (st == StAppCfg && kmac_en_o) |-> reg_key_len_i != SideloadedKey)

endmodule

    '''

    Form relevant system verilog assertions for the RTL to be checked for.
    These system verilog assertions should be in a dict with the key as the name and the value as the assertion string.
    An example assertions object to be sent to assertion checker tool is as follows:

    assertions = {"assertion_p1":"property p1;\n    @(posedge clk) signal_A |-> signal_B;\nendproperty
assertion_p1: assert property (p1);", "assertion_p2":"property p2;\n    @(posedge clk) conditions |-> signal_C;\nendproperty\nassertion_p2: assert property (p2);"}

    Then run the assertions using the assertion checker tool. This tool call must include the assertions dictionary as an argument.
    From the output of the assertion checker tool, determine if there are security issues in the RTL.
    If there are no falsified assertions in the output from the assertion checker tool, that means there are no verified security issues in the RTL.

    
================================== Ai Message ==================================

[{'text': "I'll analyze the provided RTL code for security concerns related to application interface isolation, privilege escalation, and command injection. Let me create relevant assertions to check for these security issues.\n\nLooking at the code, I can see this is a KMAC (Keccak Message Authentication Code) application interface module that handles multiple application interfaces and software control. The key security concerns would be:\n\n1. Application interface isolation - ensuring one app can't access another app's data\n2. Privilege escalation - ensuring proper access controls between software and hardware apps\n3. Command injection - ensuring commands can't be injected during inappropriate states\n\nLet me create assertions to check these security properties:", 'type': 'text'}, {'id': 'toolu_01EpCfYfhnpsqbzYxkEAPrVi', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv', 'top_module': 'kmac_app'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01EpCfYfhnpsqbzYxkEAPrVi)
 Call ID: toolu_01EpCfYfhnpsqbzYxkEAPrVi
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv
    top_module: kmac_app
================================= Tool Message =================================
Name: assertion_checker_tool

Error: 4 validation errors for assertion_checker_tool
assertions
  Field required [type=missing, input_value={'design_filepath': '/hom...top_module': 'kmac_app'}, input_type=dict]
    For further information visit XXXX
clock_signal
  Field required [type=missing, input_value={'design_filepath': '/hom...top_module': 'kmac_app'}, input_type=dict]
    For further information visit XXXX
reset_signal
  Field required [type=missing, input_value={'design_filepath': '/hom...top_module': 'kmac_app'}, input_type=dict]
    For further information visit XXXX
reset_active
  Field required [type=missing, input_value={'design_filepath': '/hom...top_module': 'kmac_app'}, input_type=dict]
    For further information visit XXXX
 Please fix your mistakes.
================================== Ai Message ==================================

[{'text': 'I need to provide all the required parameters for the assertion checker tool. Let me create appropriate assertions and include all required parameters:', 'type': 'text'}, {'id': 'toolu_01PH2cWjRVXQ5AQf1TBDpu2o', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv', 'top_module': 'kmac_app', 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low', 'assertions': {'app_isolation_p': "property app_isolation_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (app_active_o && app_id != 0) |-> (app_o[0].ready == 1'b0 && app_o[0].done == 1'b0);\nendproperty\nassertion_app_isolation: assert property(app_isolation_p);", 'sw_cmd_during_app_p': "property sw_cmd_during_app_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (app_active_o && sw_cmd_i != CmdNone) |-> ##1 (error_o.valid == 1'b1 && error_o.code == ErrSwIssuedCmdInAppActive);\nendproperty\nassertion_sw_cmd_during_app: assert property(sw_cmd_during_app_p);", 'sw_msg_during_app_p': "property sw_msg_during_app_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (mux_sel != SelSw && sw_valid_i) |-> ##1 (error_o.valid == 1'b1 && error_o.code == ErrSwPushedMsgFifo);\nendproperty\nassertion_sw_msg_during_app: assert property(sw_msg_during_app_p);", 'key_valid_check_p': 'property key_valid_check_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (keymgr_key_used && !keymgr_key_i.valid) |-> ##[1:3] (st == StKeyMgrErrKeyNotValid || st == StError);\nendproperty\nassertion_key_valid_check: assert property(key_valid_check_p);', 'app_digest_isolation_p': "property app_digest_isolation_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (app_digest_done && app_id < NumAppIntf) |-> (app_o[app_id].done == 1'b1 && $onehot(app_o[app_id].done));\nendproperty\nassertion_app_digest_isolation: assert property(app_digest_isolation_p);", 'lc_escalate_terminal_p': 'property lc_escalate_terminal_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) |-> ##1 (st == StTerminalError);\nendproperty\nassertion_lc_escalate_terminal: assert property(lc_escalate_terminal_p);'}}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01PH2cWjRVXQ5AQf1TBDpu2o)
 Call ID: toolu_01PH2cWjRVXQ5AQf1TBDpu2o
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv
    top_module: kmac_app
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
    assertions: {'app_isolation_p': "property app_isolation_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (app_active_o && app_id != 0) |-> (app_o[0].ready == 1'b0 && app_o[0].done == 1'b0);\nendproperty\nassertion_app_isolation: assert property(app_isolation_p);", 'sw_cmd_during_app_p': "property sw_cmd_during_app_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (app_active_o && sw_cmd_i != CmdNone) |-> ##1 (error_o.valid == 1'b1 && error_o.code == ErrSwIssuedCmdInAppActive);\nendproperty\nassertion_sw_cmd_during_app: assert property(sw_cmd_during_app_p);", 'sw_msg_during_app_p': "property sw_msg_during_app_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (mux_sel != SelSw && sw_valid_i) |-> ##1 (error_o.valid == 1'b1 && error_o.code == ErrSwPushedMsgFifo);\nendproperty\nassertion_sw_msg_during_app: assert property(sw_msg_during_app_p);", 'key_valid_check_p': 'property key_valid_check_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (keymgr_key_used && !keymgr_key_i.valid) |-> ##[1:3] (st == StKeyMgrErrKeyNotValid || st == StError);\nendproperty\nassertion_key_valid_check: assert property(key_valid_check_p);', 'app_digest_isolation_p': "property app_digest_isolation_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (app_digest_done && app_id < NumAppIntf) |-> (app_o[app_id].done == 1'b1 && $onehot(app_o[app_id].done));\nendproperty\nassertion_app_digest_isolation: assert property(app_digest_isolation_p);", 'lc_escalate_terminal_p': 'property lc_escalate_terminal_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) |-> ##1 (st == StTerminalError);\nendproperty\nassertion_lc_escalate_terminal: assert property(lc_escalate_terminal_p);'}
================================= Tool Message =================================
Name: assertion_checker_tool

Failed to execute. Error: KeyError('assertion_key_valid_check')
KeyError: 'assertion_key_valid_check'
Traceback (most recent call last):
  File "/home/XXXX-2/security_agents/security_agents.py", line 763, in assertion_checker_tool
    falsified_properties[name] = assertions[name]
                               ~~~~~~~~~~^^^^^^
KeyError: 'assertion_key_valid_check'
================================== Ai Message ==================================

[{'text': 'I apologize for the error. Let me fix the assertion names to ensure they match properly:', 'type': 'text'}, {'id': 'toolu_01KiUzCGhh55ZCjuc1sLktn4', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv', 'top_module': 'kmac_app', 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low', 'assertions': {'assertion_app_isolation': "property app_isolation_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (app_active_o && app_id != 0) |-> (app_o[0].ready == 1'b0 && app_o[0].done == 1'b0);\nendproperty\nassertion_app_isolation: assert property(app_isolation_p);", 'assertion_sw_cmd_during_app': "property sw_cmd_during_app_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (app_active_o && sw_cmd_i != CmdNone) |-> ##1 (error_o.valid == 1'b1 && error_o.code == ErrSwIssuedCmdInAppActive);\nendproperty\nassertion_sw_cmd_during_app: assert property(sw_cmd_during_app_p);", 'assertion_sw_msg_during_app': "property sw_msg_during_app_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (mux_sel != SelSw && sw_valid_i) |-> ##1 (error_o.valid == 1'b1 && error_o.code == ErrSwPushedMsgFifo);\nendproperty\nassertion_sw_msg_during_app: assert property(sw_msg_during_app_p);", 'assertion_key_valid_check': 'property key_valid_check_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (keymgr_key_used && !keymgr_key_i.valid) |-> ##[1:3] (st == StKeyMgrErrKeyNotValid || st == StError);\nendproperty\nassertion_key_valid_check: assert property(key_valid_check_p);', 'assertion_app_digest_isolation': "property app_digest_isolation_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (app_digest_done && app_id < NumAppIntf) |-> (app_o[app_id].done == 1'b1 && $onehot(app_o[app_id].done));\nendproperty\nassertion_app_digest_isolation: assert property(app_digest_isolation_p);", 'assertion_lc_escalate_terminal': 'property lc_escalate_terminal_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) |-> ##1 (st == StTerminalError);\nendproperty\nassertion_lc_escalate_terminal: assert property(lc_escalate_terminal_p);'}}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01KiUzCGhh55ZCjuc1sLktn4)
 Call ID: toolu_01KiUzCGhh55ZCjuc1sLktn4
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv
    top_module: kmac_app
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
    assertions: {'assertion_app_isolation': "property app_isolation_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (app_active_o && app_id != 0) |-> (app_o[0].ready == 1'b0 && app_o[0].done == 1'b0);\nendproperty\nassertion_app_isolation: assert property(app_isolation_p);", 'assertion_sw_cmd_during_app': "property sw_cmd_during_app_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (app_active_o && sw_cmd_i != CmdNone) |-> ##1 (error_o.valid == 1'b1 && error_o.code == ErrSwIssuedCmdInAppActive);\nendproperty\nassertion_sw_cmd_during_app: assert property(sw_cmd_during_app_p);", 'assertion_sw_msg_during_app': "property sw_msg_during_app_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (mux_sel != SelSw && sw_valid_i) |-> ##1 (error_o.valid == 1'b1 && error_o.code == ErrSwPushedMsgFifo);\nendproperty\nassertion_sw_msg_during_app: assert property(sw_msg_during_app_p);", 'assertion_key_valid_check': 'property key_valid_check_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (keymgr_key_used && !keymgr_key_i.valid) |-> ##[1:3] (st == StKeyMgrErrKeyNotValid || st == StError);\nendproperty\nassertion_key_valid_check: assert property(key_valid_check_p);', 'assertion_app_digest_isolation': "property app_digest_isolation_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (app_digest_done && app_id < NumAppIntf) |-> (app_o[app_id].done == 1'b1 && $onehot(app_o[app_id].done));\nendproperty\nassertion_app_digest_isolation: assert property(app_digest_isolation_p);", 'assertion_lc_escalate_terminal': 'property lc_escalate_terminal_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) |-> ##1 (st == StTerminalError);\nendproperty\nassertion_lc_escalate_terminal: assert property(lc_escalate_terminal_p);'}
================================= Tool Message =================================
Name: assertion_checker_tool

Successfully executed:
```assertion checker tool
```
Output:
 The following properties were falsified:
property key_valid_check_p;
  @(posedge clk_i) disable iff (!rst_ni)
  (keymgr_key_used && !keymgr_key_i.valid) |-> ##[1:3] (st == StKeyMgrErrKeyNotValid || st == StError);
endproperty
assertion_key_valid_check: assert property(key_valid_check_p);

property sw_cmd_during_app_p;
  @(posedge clk_i) disable iff (!rst_ni)
  (app_active_o && sw_cmd_i != CmdNone) |-> ##1 (error_o.valid == 1'b1 && error_o.code == ErrSwIssuedCmdInAppActive);
endproperty
assertion_sw_cmd_during_app: assert property(sw_cmd_during_app_p);

property sw_msg_during_app_p;
  @(posedge clk_i) disable iff (!rst_ni)
  (mux_sel != SelSw && sw_valid_i) |-> ##1 (error_o.valid == 1'b1 && error_o.code == ErrSwPushedMsgFifo);
endproperty
assertion_sw_msg_during_app: assert property(sw_msg_during_app_p);
================================== Ai Message ==================================

Based on the assertion checker tool results, I've identified several security concerns in the provided RTL code:

### Security Issues Found:

1. **Key Validation Issue (assertion_key_valid_check)**:
   - The assertion checking that invalid keys are properly handled was falsified.
   - This indicates that when a key from the key manager is used but not valid (`keymgr_key_used && !keymgr_key_i.valid`), the design doesn't consistently transition to an error state as expected.
   - This could potentially allow operations to proceed with invalid keys, which is a serious security vulnerability.

2. **Software Command Injection (assertion_sw_cmd_during_app)**:
   - The assertion checking that software commands during application operation are properly detected was falsified.
   - This means that when an application is active (`app_active_o`) and software issues a command (`sw_cmd_i != CmdNone`), the error detection mechanism doesn't consistently flag this as an error.
   - This could allow software to inject commands during application operation, potentially leading to privilege escalation.

3. **Software Message Injection (assertion_sw_msg_during_app)**:
   - The assertion checking that software message pushes during non-software operation are properly detected was falsified.
   - When the mux is not selecting software (`mux_sel != SelSw`) but software tries to push data (`sw_valid_i`), the error detection doesn't consistently work.
   - This could allow software to inject messages during application operation, potentially compromising the isolation between software and hardware applications.

### Security Implications:

These issues have significant security implications:

1. **Application Interface Isolation Breach**: The falsified assertions indicate that the isolation between software and hardware applications is not robust. Software can potentially inject commands or messages during hardware application operation.

2. **Privilege Escalation Risk**: The ability for software to inject commands during application operation could lead to privilege escalation, where software gains unauthorized access to hardware application functionality.

3. **Command Injection Vulnerability**: The design doesn't properly prevent command injection from software during application operation, which could allow an attacker to manipulate the cryptographic operations.

4. **Key Security Compromise**: The failure to properly handle invalid keys could lead to cryptographic operations proceeding with compromised keys, potentially weakening the security of the entire system.

### Recommendation:

The RTL code needs to be modified to address these security issues:

1. Strengthen the key validation logic to ensure operations never proceed with invalid keys.
2. Improve the error detection and handling for software command injection during application operation.
3. Enhance the protection against software message injection when hardware applications are active.
4. Consider adding additional isolation mechanisms between software and hardware interfaces.

These findings indicate serious security vulnerabilities in the KMAC application interface that could compromise the security of the entire cryptographic system.
================================= Tool Message =================================
Name: run_assertions_checker_agent

Based on the assertion checker tool results, I've identified several security concerns in the provided RTL code:

### Security Issues Found:

1. **Key Validation Issue (assertion_key_valid_check)**:
   - The assertion checking that invalid keys are properly handled was falsified.
   - This indicates that when a key from the key manager is used but not valid (`keymgr_key_used && !keymgr_key_i.valid`), the design doesn't consistently transition to an error state as expected.
   - This could potentially allow operations to proceed with invalid keys, which is a serious security vulnerability.

2. **Software Command Injection (assertion_sw_cmd_during_app)**:
   - The assertion checking that software commands during application operation are properly detected was falsified.
   - This means that when an application is active (`app_active_o`) and software issues a command (`sw_cmd_i != CmdNone`), the error detection mechanism doesn't consistently flag this as an error.
   - This could allow software to inject commands during application operation, potentially leading to privilege escalation.

3. **Software Message Injection (assertion_sw_msg_during_app)**:
   - The assertion checking that software message pushes during non-software operation are properly detected was falsified.
   - When the mux is not selecting software (`mux_sel != SelSw`) but software tries to push data (`sw_valid_i`), the error detection doesn't consistently work.
   - This could allow software to inject messages during application operation, potentially compromising the isolation between software and hardware applications.

### Security Implications:

These issues have significant security implications:

1. **Application Interface Isolation Breach**: The falsified assertions indicate that the isolation between software and hardware applications is not robust. Software can potentially inject commands or messages during hardware application operation.

2. **Privilege Escalation Risk**: The ability for software to inject commands during application operation could lead to privilege escalation, where software gains unauthorized access to hardware application functionality.

3. **Command Injection Vulnerability**: The design doesn't properly prevent command injection from software during application operation, which could allow an attacker to manipulate the cryptographic operations.

4. **Key Security Compromise**: The failure to properly handle invalid keys could lead to cryptographic operations proceeding with compromised keys, potentially weakening the security of the entire system.

### Recommendation:

The RTL code needs to be modified to address these security issues:

1. Strengthen the key validation logic to ensure operations never proceed with invalid keys.
2. Improve the error detection and handling for software command injection during application operation.
3. Enhance the protection against software message injection when hardware applications are active.
4. Consider adding additional isolation mechanisms between software and hardware interfaces.

These findings indicate serious security vulnerabilities in the KMAC application interface that could compromise the security of the entire cryptographic system.
================================== Ai Message ==================================
Tool Calls:
  run_linter_agent (call_1xiKmvYHzvAxL6SdxQIMThsf)
 Call ID: call_1xiKmvYHzvAxL6SdxQIMThsf
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv
    top_module: kmac_app
    security_objective: application interface isolation, privilege escalation, command injection
================================ Human Message =================================

Are there security concerns related to application interface isolation, privilege escalation, command injection in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv

    And the top module is:

    kmac_app

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// KMAC Application interface

`include "prim_assert.sv"

module kmac_app
  import kmac_pkg::*;
#(
  // App specific configs are defined in kmac_pkg
  parameter  bit EnMasking = 1'b0,
  localparam int Share = (EnMasking) ? 2 : 1, // derived parameter
  parameter  bit SecIdleAcceptSwMsg = 1'b0
) (
  input clk_i,
  input rst_ni,

  // Secret Key from register
  input [MaxKeyLen-1:0] reg_key_data_i [Share],
  input key_len_e       reg_key_len_i,

  // Prefix from register
  input [sha3_pkg::NSRegisterSize*8-1:0] reg_prefix_i,

  // mode, strength, kmac_en from register
  input                             reg_kmac_en_i,
  input sha3_pkg::sha3_mode_e       reg_sha3_mode_i,
  input sha3_pkg::keccak_strength_e reg_keccak_strength_i,

  // Data from Software
  input                sw_valid_i,
  input [MsgWidth-1:0] sw_data_i,
  input [MsgWidth-1:0] sw_mask_i,
  output logic         sw_ready_o,

  // KeyMgr Sideload Key interface
  input keymgr_pkg::hw_key_req_t keymgr_key_i,

  // Application Message in/ Digest out interface + control signals
  input  app_req_t [NumAppIntf-1:0] app_i,
  output app_rsp_t [NumAppIntf-1:0] app_o,

  // to KMAC Core: Secret key
  output logic [MaxKeyLen-1:0] key_data_o [Share],
  output key_len_e             key_len_o,
  output logic                 key_valid_o,

  // to MSG_FIFO
  output logic                kmac_valid_o,
  output logic [MsgWidth-1:0] kmac_data_o,
  output logic [MsgWidth-1:0] kmac_mask_o,
  input                       kmac_ready_i,

  // KMAC Core
  output logic kmac_en_o,

  // To Sha3 Core
  output logic [sha3_pkg::NSRegisterSize*8-1:0] sha3_prefix_o,
  output sha3_pkg::sha3_mode_e                  sha3_mode_o,
  output sha3_pkg::keccak_strength_e            keccak_strength_o,

  // STATE from SHA3 Core
  input                        keccak_state_valid_i,
  input [sha3_pkg::StateW-1:0] keccak_state_i [Share],

  // to STATE TL-window if Application is not active, the incoming state goes to
  // register if kdf_en is set, the state value goes to application and the
  // output to the register is all zero.
  output logic                        reg_state_valid_o,
  output logic [sha3_pkg::StateW-1:0] reg_state_o [Share],

  // Configurations If key_en is set, the logic uses KeyMgr's sideloaded key as
  // a secret key rather than register values. This only affects when software
  // initiates. If App initiates the hash operation and uses KMAC algorithm, it
  // always uses sideloaded key.
  input keymgr_key_en_i,

  // Commands
  // Command from software
  input kmac_cmd_e sw_cmd_i,

  // from SHA3
  input prim_mubi_pkg::mubi4_t absorbed_i,

  // to KMAC
  output kmac_cmd_e cmd_o,

  // to SW
  output prim_mubi_pkg::mubi4_t absorbed_o,

  // To status
  output logic app_active_o,

  // Status
  // - entropy_ready_i: Entropy configured by SW. It is used to check if App
  //                    is OK to request.
  input prim_mubi_pkg::mubi4_t entropy_ready_i,

  // Error input
  // This error comes from KMAC/SHA3 engine.
  // KeyMgr interface delivers the error signal to KeyMgr to drop the current op
  // and re-initiate.
  // If error happens, regardless of SW-initiated or KeyMgr-initiated, the error
  // is reported to the ERR_CODE so that SW can look into.
  input error_i,

  // SW sets err_processed bit in CTRL then the logic goes to Idle
  input err_processed_i,

  output prim_mubi_pkg::mubi4_t clear_after_error_o,

  // error_o value is pushed to Error FIFO at KMAC/SHA3 top and reported to SW
  output kmac_pkg::err_t error_o,

  // Life cycle
  input  lc_ctrl_pkg::lc_tx_t lc_escalate_en_i,

  output logic sparse_fsm_error_o
);

  import sha3_pkg::KeccakBitCapacity;
  import sha3_pkg::L128;
  import sha3_pkg::L224;
  import sha3_pkg::L256;
  import sha3_pkg::L384;
  import sha3_pkg::L512;

  /////////////////
  // Definitions //
  /////////////////

  // Digest width is same to the key width `keymgr_pkg::KeyWidth`.
  localparam int KeyMgrKeyW = $bits(keymgr_key_i.key[0]);

  localparam key_len_e KeyLengths [5] = '{Key128, Key192, Key256, Key384, Key512};

  localparam int SelKeySize = (AppKeyW == 128) ? 0 :
                              (AppKeyW == 192) ? 1 :
                              (AppKeyW == 256) ? 2 :
                              (AppKeyW == 384) ? 3 :
                              (AppKeyW == 512) ? 4 : 0 ;
  localparam int SelDigSize = (AppDigestW == 128) ? 0 :
                              (AppDigestW == 192) ? 1 :
                              (AppDigestW == 256) ? 2 :
                              (AppDigestW == 384) ? 3 :
                              (AppDigestW == 512) ? 4 : 0 ;
  localparam key_len_e SideloadedKey = KeyLengths[SelKeySize];

  // Define right_encode(outlen) value here
  // Look at kmac_pkg::key_len_e for the kinds of key size
  //
  // These values should be exactly the same as the key length encodings
  // in kmac_core.sv, with the only difference being that the byte representing
  // the byte-length of the encoded value is in the MSB position due to right encoding
  // instead of in the LSB position (left encoding).
  localparam int OutLenW = 24;
  localparam logic [OutLenW-1:0] EncodedOutLen [5]= '{
    24'h 0001_80, // Key128
    24'h 0001_C0, // Key192
    24'h 02_0001, // Key256
    24'h 02_8001, // Key384
    24'h 02_0002  // Key512
  };

  localparam logic [OutLenW-1:0] EncodedOutLenMask [5] = '{
    24'h 00FFFF, // Key128,
    24'h 00FFFF, // Key192
    24'h FFFFFF, // Key256
    24'h FFFFFF, // Key384
    24'h FFFFFF  // Key512
  };

  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 3 -m 14 -n 10 \
  //     -s 2454278799 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: |||||||||| (14.29%)
  //  4: |||||||||||||||||||| (27.47%)
  //  5: ||||||||||||| (18.68%)
  //  6: |||||||||||||||| (21.98%)
  //  7: |||||||| (10.99%)
  //  8: |||| (6.59%)
  //  9: --
  // 10: --
  //
  // Minimum Hamming distance: 3
  // Maximum Hamming distance: 8
  // Minimum Hamming weight: 3
  // Maximum Hamming weight: 8
  //
  localparam int StateWidth = 10;
  typedef enum logic [StateWidth-1:0] {
    StIdle = 10'b1010111110,

    // Application operation.
    //
    // if start request comes from an App first, until the operation ends by the
    // requested App, all operations are granted to the specific App. SW
    // requests and other Apps requests will be ignored.
    //
    // App interface does not have control signals. When first data valid occurs
    // from an App, this logic asserts the start command to the downstream. When
    // last beat pulse comes, this logic asserts the process to downstream
    // (after the transaction is accepted regardless of partial writes or not)
    // When absorbed by SHA3 core, the logic sends digest to the requested App
    // and right next cycle, it triggers done command to downstream.

    // In StAppCfg state, it latches the cfg from AppCfg parameter to determine
    // the kmac_mode, sha3_mode, keccak strength.
    StAppCfg = 10'b1010101101,

    StAppMsg = 10'b1110001011,

    // In StKeyOutLen, this module pushes encoded outlen to the MSG_FIFO.
    // Assume the length is 256 bit, the data will be 48'h 02_0100
    StAppOutLen  = 10'b1010011000,
    StAppProcess = 10'b1110110010,
    StAppWait    = 10'b1001010000,

    // SW Controlled
    // If start request comes from SW first, until the operation ends, all
    // requests from KeyMgr will be discarded.
    StSw = 10'b0010111011,

    // Error KeyNotValid
    // When KeyMgr operates, the secret key is not ready yet.
    StKeyMgrErrKeyNotValid = 10'b0111011111,

    StError = 10'b1110010111,
    StErrorAwaitSw = 10'b0110001100,
    StErrorAwaitApp = 10'b1011100000,
    StErrorWaitAbsorbed = 10'b0010100100,
    StErrorServiceRejected = 10'b1101000111,

    // This state is used for terminal errors
    StTerminalError = 10'b0101110110
  } st_e;

  /////////////
  // Signals //
  /////////////

  st_e st, st_d;

  logic keymgr_key_used;

  // app_rsp_t signals
  // The state machine controls mux selection, which controls the ready signal
  // the other responses are controled in separate logic. So define the signals
  // here and merge them to the response.
  logic app_data_ready, fsm_data_ready;
  logic app_digest_done, fsm_digest_done_q, fsm_digest_done_d;
  logic [AppDigestW-1:0] app_digest [2];

  // One more slot for value NumAppIntf. It is the value when no app intf is
  // chosen.
  localparam int unsigned AppIdxW = $clog2(NumAppIntf);

  // app_id indicates, which app interface was chosen. various logic use this
  // value to get the config or return the data.
  logic [AppIdxW-1:0] app_id, app_id_d;
  logic               clr_appid, set_appid;

  // Output length
  logic [OutLenW-1:0] encoded_outlen, encoded_outlen_mask;

  // state output
  // Mux selection signal
  app_mux_sel_e mux_sel;
  app_mux_sel_e mux_sel_buf_output;
  app_mux_sel_e mux_sel_buf_err_check;
  app_mux_sel_e mux_sel_buf_kmac;

  // Error checking logic

  kmac_pkg::err_t fsm_err, mux_err;

  logic service_rejected_error;
  logic service_rejected_error_set, service_rejected_error_clr;
  logic err_during_sw_d, err_during_sw_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni)                         service_rejected_error <= 1'b 0;
    else if (service_rejected_error_set) service_rejected_error <= 1'b 1;
    else if (service_rejected_error_clr) service_rejected_error <= 1'b 0;
  end

  ////////////////////////////
  // Application Mux/ Demux //
  ////////////////////////////


  // Processing return data.
  // sends to only selected app intf.
  // clear digest right after done to not leak info to other interface
  always_comb begin
    for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
      if (i == app_id) begin
        app_o[i] = '{
          ready:         app_data_ready | fsm_data_ready,
          done:          app_digest_done | fsm_digest_done_q,
          digest_share0: app_digest[0],
          digest_share1: app_digest[1],
          // if fsm asserts done, should be an error case.
          error:         error_i | fsm_digest_done_q | sparse_fsm_error_o
                         | service_rejected_error
        };
      end else begin
        app_o[i] = '{
          ready: 1'b 0,
          done:  1'b 0,
          digest_share0: '0,
          digest_share1: '0,
          error: 1'b 0
        };
      end
    end // for {i, NumAppIntf, i++}
  end // aiways_comb

  // app_id latch
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) app_id <= AppIdxW'(0) ; // Do not select any
    else if (clr_appid) app_id <= AppIdxW'(0);
    else if (set_appid) app_id <= app_id_d;
  end

  // app_id selection as of now, app_id uses Priority. The assumption is that
  //  the request normally does not collide. (ROM_CTRL activates very early
  //  stage at the boot sequence)
  //
  //  If this assumption is not true, consider RR arbiter.

  // Prep for arbiter
  logic [NumAppIntf-1:0] app_reqs;
  logic [NumAppIntf-1:0] unused_app_gnts;
  logic [$clog2(NumAppIntf)-1:0] arb_idx;
  logic arb_valid;
  logic arb_ready;

  always_comb begin
    app_reqs = '0;
    for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
      app_reqs[i] = app_i[i].valid;
    end
  end

  prim_arbiter_fixed #(
    .N (NumAppIntf),
    .DW(1),
    .EnDataPort(1'b 0)
  ) u_appid_arb (
    .clk_i,
    .rst_ni,

    .req_i  (app_reqs),
    .data_i ('{default:'0}),
    .gnt_o  (unused_app_gnts),
    .idx_o  (arb_idx),

    .valid_o (arb_valid),
    .data_o  (), // not used
    .ready_i (arb_ready)
  );

  assign app_id_d = AppIdxW'(arb_idx);
  assign arb_ready = set_appid;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) fsm_digest_done_q <= 1'b 0;
    else         fsm_digest_done_q <= fsm_digest_done_d;
  end

  /////////
  // FSM //
  /////////

  // State register
  `PRIM_FLOP_SPARSE_FSM(u_state_regs, st_d, st, st_e, StIdle)

  // Create a lint error to reduce the risk of accidentally enabling this feature.
  `ASSERT_STATIC_LINT_ERROR(KmacSecIdleAcceptSwMsgNonDefault, SecIdleAcceptSwMsg == 0)

  // Next State & output logic
  // SEC_CM: FSM.SPARSE
  always_comb begin
    st_d = st;

    mux_sel = SecIdleAcceptSwMsg ? SelSw : SelNone;

    // app_id control
    set_appid = 1'b 0;
    clr_appid = 1'b 0;

    // Commands
    cmd_o = CmdNone;

    // Software output
    absorbed_o = prim_mubi_pkg::MuBi4False;

    // Error
    fsm_err = '{valid: 1'b 0, code: ErrNone, info: '0};
    sparse_fsm_error_o = 1'b 0;

    clear_after_error_o = prim_mubi_pkg::MuBi4False;

    service_rejected_error_set = 1'b 0;
    service_rejected_error_clr = 1'b 0;

    // If error happens, FSM asserts data ready but discard incoming msg
    fsm_data_ready = 1'b 0;
    fsm_digest_done_d = 1'b 0;

    unique case (st)
      StIdle: begin
        if (arb_valid) begin
          st_d = StAppCfg;

          // choose app_id
          set_appid = 1'b 1;
        end else if (sw_cmd_i == CmdStart) begin
          st_d = StSw;
          // Software initiates the sequence
          cmd_o = CmdStart;
        end else begin
          st_d = StIdle;
        end
      end

      StAppCfg: begin
        if (AppCfg[app_id].Mode == AppKMAC &&
          prim_mubi_pkg::mubi4_test_false_strict(entropy_ready_i)) begin
          // Check if the entropy is not configured but it is needed in
          // `AppCfg[app_id]` (KMAC mode).
          //
          // SW is not properly configured, report and not request Hashing
          // Return the app with errors
          st_d = StError;

          service_rejected_error_set = 1'b 1;

        end else begin
          // As Cfg is stable now, it sends cmd
          st_d = StAppMsg;

          // App initiates the data
          cmd_o = CmdStart;
        end
      end

      StAppMsg: begin
        mux_sel = SelApp;
        if (app_i[app_id].valid && app_o[app_id].ready && app_i[app_id].last) begin
          if (AppCfg[app_id].Mode == AppKMAC) begin
            st_d = StAppOutLen;
          end else begin
            st_d = StAppProcess;
          end
        end else begin
          st_d = StAppMsg;
        end
      end

      StAppOutLen: begin
        mux_sel = SelOutLen;

        if (kmac_valid_o && kmac_ready_i) begin
          st_d = StAppProcess;
        end else begin
          st_d = StAppOutLen;
        end
      end

      StAppProcess: begin
        cmd_o = CmdProcess;
        st_d = StAppWait;
      end

      StAppWait: begin
        if (prim_mubi_pkg::mubi4_test_true_strict(absorbed_i)) begin
          // Send digest to KeyMgr and complete the op
          st_d = StIdle;
          cmd_o = CmdDone;

          clr_appid = 1'b 1;
        end else begin
          st_d = StAppWait;
        end
      end

      StSw: begin
        mux_sel = SelSw;

        cmd_o = sw_cmd_i;
        absorbed_o = absorbed_i;

        if (sw_cmd_i == CmdDone) begin
          st_d = StIdle;
        end else begin
          st_d = StSw;
        end
      end

      StKeyMgrErrKeyNotValid: begin
        st_d = StError;

        // As mux_sel is not set to SelApp, app_data_ready is still 0.
        // This logic won't accept the requests from the selected App.
        fsm_err.valid = 1'b 1;
        fsm_err.code = ErrKeyNotValid;
        fsm_err.info = 24'(app_id);
      end

      StError: begin
        // In this state, the state machine flush out the request
        st_d = StError;

        // Absorb data on the app interface.
        fsm_data_ready = ~err_during_sw_q;

        // Next step depends on two conditions:
        // 1) Error being processed by SW
        // 2) Last data provided from the app interface (so that the app interface is completely)
        //    drained.  If the error occurred during a SW operation, the app interface is not
        //    involved, so this condition gets skipped.
        unique case ({err_processed_i,
                      (app_i[app_id].valid && app_i[app_id].last) || err_during_sw_q})
          2'b00: begin
            // Error not processed by SW and not last data from app interface -> keep current state.
            st_d = StError;
          end
          2'b01: begin
            // Error not processed by SW but last data from app interface:
            // 1. Send garbage digest to the app interface (in the next cycle) to complete the
            // transaction.
            fsm_digest_done_d = ~err_during_sw_q;
            if (service_rejected_error) begin
              // 2.a) Service was rejected because an app interface tried to configure KMAC while no
              // entropy was available. It is assumed that SW is not loaded yet, so don't wait for
              // SW to process the error. The last data from the app interface has now arrived, but
              // we don't need to wait for the SHA3 core to have absorbed it because the data never
              // entered the SHA3 core: the request from the app interface was terminated during the
              // configuration phase.
              st_d = StErrorServiceRejected;
            end else begin
              // 2.b) If service was not rejected, wait for SW to process the error.
              st_d = StErrorAwaitSw;
            end
          end
          2'b10: begin
            // Error processed by SW but not last data from app interface -> wait for app interface.
            st_d = StErrorAwaitApp;
          end
          2'b11: begin
            // Error processed by SW and last data from app interface:
            // Send garbage digest to the app interface (in the next cycle) to complete the
            // transaction.
            fsm_digest_done_d = ~err_during_sw_q;
            // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
            // but serves to bring the SHA3 engine back to the idle state).
            cmd_o = CmdProcess;
            st_d = StErrorWaitAbsorbed;
          end
          default: st_d = StError;
        endcase
      end

      StErrorAwaitSw: begin
        // Just wait for SW to process the error.
        if (err_processed_i) begin
          // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
          // but serves to bring the SHA3 engine back to the idle state).
          cmd_o = CmdProcess;
          st_d = StErrorWaitAbsorbed;
        end
      end

      StErrorAwaitApp: begin
        // Keep absorbing data on the app interface until the last data.
        fsm_data_ready = 1'b1;
        if (app_i[app_id].valid && app_i[app_id].last) begin
          // Send garbage digest to the app interface (in the next cycle) to complete the
          // transaction.
          fsm_digest_done_d = 1'b1;
          // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
          // but serves to bring the SHA3 engine back to the idle state).
          cmd_o = CmdProcess;
          st_d = StErrorWaitAbsorbed;
        end
      end

      StErrorWaitAbsorbed: begin
        if (prim_mubi_pkg::mubi4_test_true_strict(absorbed_i)) begin
          // Clear internal variables, send done command, and return to idle.
          clr_appid = 1'b1;
          clear_after_error_o = prim_mubi_pkg::MuBi4True;
          service_rejected_error_clr = 1'b1;
          cmd_o = CmdDone;
          st_d = StIdle;
          // If error originated from SW, report 'absorbed' to SW.
          if (err_during_sw_q) begin
            absorbed_o = prim_mubi_pkg::MuBi4True;
          end
        end
      end

      StErrorServiceRejected: begin
        // Clear internal variables and return to idle.
        clr_appid = 1'b1;
        clear_after_error_o = prim_mubi_pkg::MuBi4True;
        service_rejected_error_clr = 1'b1;
        st_d = StIdle;
      end

      StTerminalError: begin
        // this state is terminal
        st_d = st;
        sparse_fsm_error_o = 1'b 1;
        fsm_err.valid = 1'b 1;
        fsm_err.code = ErrFatalError;
        fsm_err.info = 24'(app_id);
      end

      default: begin
        st_d = StTerminalError;
        sparse_fsm_error_o = 1'b 1;
      end
    endcase

    // SEC_CM: FSM.GLOBAL_ESC, FSM.LOCAL_ESC
    // Unconditionally jump into the terminal error state
    // if the life cycle controller triggers an escalation.
    if (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) begin
      st_d = StTerminalError;
    end

    // Handle errors outside the terminal error state.
    if (st_d != StTerminalError) begin
      // Key from keymgr is used but not valid, so abort into the invalid key error state.
      if (keymgr_key_used && !keymgr_key_i.valid) begin
        st_d = StKeyMgrErrKeyNotValid;
      end
    end
  end

  // Track errors occurring in SW mode.
  assign err_during_sw_d =
      (mux_sel == SelSw) && (st_d inside {StError, StKeyMgrErrKeyNotValid}) ? 1'b1 : // set
      (st_d == StIdle)                                                      ? 1'b0 : // clear
      err_during_sw_q;                                                               // hold

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      err_during_sw_q <= 1'b0;
    end else begin
      err_during_sw_q <= err_during_sw_d;
    end
  end

  //////////////
  // Datapath //
  //////////////

  // Encoded output length
  assign encoded_outlen      = EncodedOutLen[SelDigSize];
  assign encoded_outlen_mask = EncodedOutLenMask[SelKeySize];

  // Data mux
  // This is the main part of the KeyMgr interface logic.
  // The FSM selects KeyMgr interface in a cycle after it receives the first
  // valid data from KeyMgr. The ready signal to the KeyMgr data interface
  // represents the MSG_FIFO ready, only when it is in StKeyMgrMsg state.
  // After KeyMgr sends last beat, the kmac interface (to MSG_FIFO) is switched
  // to OutLen. OutLen is pre-defined values. See `EncodeOutLen` parameter above.
  always_comb begin
    app_data_ready = 1'b 0;
    sw_ready_o = 1'b 1;

    kmac_valid_o = 1'b 0;
    kmac_data_o = '0;
    kmac_mask_o = '0;

    unique case (mux_sel_buf_kmac)
      SelApp: begin
        // app_id is valid at this time
        kmac_valid_o = app_i[app_id].valid;
        kmac_data_o  = app_i[app_id].data;
        // Expand strb to bits. prim_packer inside MSG_FIFO accepts the bit masks
        for (int i = 0 ; i < $bits(app_i[app_id].strb) ; i++) begin
          kmac_mask_o[8*i+:8] = {8{app_i[app_id].strb[i]}};
        end
        app_data_ready = kmac_ready_i;
      end

      SelOutLen: begin
        // Write encoded output length value
        kmac_valid_o = 1'b 1; // always write
        kmac_data_o  = MsgWidth'(encoded_outlen);
        kmac_mask_o  = MsgWidth'(encoded_outlen_mask);
      end

      SelSw: begin
        kmac_valid_o = sw_valid_i;
        kmac_data_o  = sw_data_i ;
        kmac_mask_o  = sw_mask_i ;
        sw_ready_o   = kmac_ready_i ;
      end

      default: begin // Incl. SelNone
        kmac_valid_o = 1'b 0;
        kmac_data_o = '0;
        kmac_mask_o = '0;
      end

    endcase
  end

  // Error checking for Mux
  always_comb begin
    mux_err = '{valid: 1'b 0, code: ErrNone, info: '0};

    if (mux_sel_buf_err_check != SelSw && sw_valid_i) begin
      // If SW writes message into FIFO
      mux_err = '{
        valid: 1'b 1,
        code: ErrSwPushedMsgFifo,
        info: 24'({8'h 00, 8'(st), 8'(mux_sel_buf_err_check)})
      };
    end else if (app_active_o && sw_cmd_i != CmdNone) begin
      // If SW issues command except start
      mux_err = '{
        valid: 1'b 1,
        code: ErrSwIssuedCmdInAppActive,
        info: 24'(sw_cmd_i)
      };
    end
  end

  logic [AppMuxWidth-1:0] mux_sel_buf_output_logic;
  assign mux_sel_buf_output = app_mux_sel_e'(mux_sel_buf_output_logic);

  // SEC_CM: LOGIC.INTEGRITY
  prim_sec_anchor_buf #(
   .Width(AppMuxWidth)
  ) u_prim_buf_state_output_sel (
    .in_i(mux_sel),
    .out_o(mux_sel_buf_output_logic)
  );

  logic [AppMuxWidth-1:0] mux_sel_buf_err_check_logic;
  assign mux_sel_buf_err_check = app_mux_sel_e'(mux_sel_buf_err_check_logic);

  // SEC_CM: LOGIC.INTEGRITY
  prim_sec_anchor_buf #(
   .Width(AppMuxWidth)
  ) u_prim_buf_state_err_check (
    .in_i(mux_sel),
    .out_o(mux_sel_buf_err_check_logic)
  );

  logic [AppMuxWidth-1:0] mux_sel_buf_kmac_logic;
  assign mux_sel_buf_kmac = app_mux_sel_e'(mux_sel_buf_kmac_logic);

  // SEC_CM: LOGIC.INTEGRITY
  prim_sec_anchor_buf #(
   .Width(AppMuxWidth)
  ) u_prim_buf_state_kmac_sel (
    .in_i(mux_sel),
    .out_o(mux_sel_buf_kmac_logic)
  );

  // SEC_CM: LOGIC.INTEGRITY
  logic reg_state_valid;
  prim_sec_anchor_buf #(
   .Width(1)
  ) u_prim_buf_state_output_valid (
    .in_i(reg_state_valid),
    .out_o(reg_state_valid_o)
  );

  // Keccak state Demux
  // Keccak state --> Register output is enabled when state is in StSw
  always_comb begin
    reg_state_valid = 1'b 0;
    reg_state_o = '{default:'0};
    if ((mux_sel_buf_output == SelSw) &&
         lc_ctrl_pkg::lc_tx_test_false_strict(lc_escalate_en_i)) begin
      reg_state_valid = keccak_state_valid_i;
      reg_state_o = keccak_state_i;
      // If key is sideloaded and KMAC is SW initiated
      // hide the capacity from SW by zeroing (see #17508)
      if (keymgr_key_en_i) begin
        for (int i = 0; i < Share; i++) begin
          unique case (reg_keccak_strength_i)
            L128: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L128]] = '0;
            L224: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L224]] = '0;
            L256: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L256]] = '0;
            L384: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L384]] = '0;
            L512: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L512]] = '0;
            default: reg_state_o[i] = '0;
          endcase
        end
      end
    end
  end

  // Keccak state --> KeyMgr
  always_comb begin
    app_digest_done = 1'b 0;
    app_digest = '{default:'0};
    if (st == StAppWait && prim_mubi_pkg::mubi4_test_true_strict(absorbed_i) &&
       lc_ctrl_pkg::lc_tx_test_false_strict(lc_escalate_en_i)) begin
      // SHA3 engine has calculated the hash. Return the data to KeyMgr
      app_digest_done = 1'b 1;

      // digest has always 2 entries. If !EnMasking, second is tied to 0.
      for (int i = 0 ; i < Share ; i++) begin
        // Return the portion of state.
        app_digest[i] = keccak_state_i[i][AppDigestW-1:0];
      end
    end
  end


  // Secret Key Mux

  // Prepare merged key if EnMasking is not set.
  // Combine share keys into unpacked array for logic below to assign easily.
  // SEC_CM: KEY.SIDELOAD
  logic [MaxKeyLen-1:0] keymgr_key [Share];
  if (EnMasking == 1) begin : g_masked_key
    for (genvar i = 0; i < Share; i++) begin : gen_key_pad
      assign keymgr_key[i] =  {(MaxKeyLen-KeyMgrKeyW)'(0), keymgr_key_i.key[i]};
    end
  end else begin : g_unmasked_key
    always_comb begin
      keymgr_key[0] = '0;
      for (int i = 0; i < keymgr_pkg::Shares; i++) begin
        keymgr_key[0][KeyMgrKeyW-1:0] ^= keymgr_key_i.key[i];
      end
    end
  end

  // Sideloaded key manage: Keep use sideloaded key for KMAC AppIntf until the
  // hashing operation is finished.
  always_comb begin
    keymgr_key_used = 1'b0;
    key_len_o  = reg_key_len_i;
    for (int i = 0 ; i < Share; i++) begin
      key_data_o[i] = reg_key_data_i[i];
    end
    // The key is considered invalid in all cases that are not listed below (which includes idle and
    // error states).
    key_valid_o = 1'b0;

    unique case (st)
      StAppCfg, StAppMsg, StAppOutLen, StAppProcess, StAppWait: begin
        // Key from keymgr is actually used if the current HW app interface does *keyed* MAC.
        keymgr_key_used = AppCfg[app_id].Mode == AppKMAC;
        key_len_o = SideloadedKey;
        for (int i = 0 ; i < Share; i++) begin
          key_data_o[i] = keymgr_key[i];
        end
        // Key is valid if the current HW app interface does *keyed* MAC and the key provided by
        // keymgr is valid.
        key_valid_o = keymgr_key_used && keymgr_key_i.valid;
      end

      StSw: begin
        if (keymgr_key_en_i) begin
          // Key from keymgr is actually used if *keyed* MAC is enabled.
          keymgr_key_used = kmac_en_o;
          key_len_o = SideloadedKey;
          for (int i = 0 ; i < Share; i++) begin
            key_data_o[i] = keymgr_key[i];
          end
        end
        // Key is valid if SW does *keyed* MAC and ...
        if (kmac_en_o) begin
          if (!keymgr_key_en_i) begin
            // ... it uses the key from kmac's CSR, or ...
            key_valid_o = 1'b1;
          end else begin
            // ... it uses the key provided by keymgr and that one is valid.
            key_valid_o = keymgr_key_i.valid;
          end
        end
      end

      default: ;
    endcase
  end

  // Prefix Demux
  // For SW, always prefix register.
  // For App intf, check PrefixMode cfg and if 1, use Prefix cfg.
  always_comb begin
    sha3_prefix_o = '0;

    unique case (st)
      StAppCfg, StAppMsg, StAppOutLen, StAppProcess, StAppWait: begin
        // Check app intf cfg
        for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
          if (app_id == i) begin
            if (AppCfg[i].PrefixMode == 1'b 0) begin
              sha3_prefix_o = reg_prefix_i;
            end else begin
              sha3_prefix_o = AppCfg[i].Prefix;
            end
          end
        end
      end

      StSw: begin
        sha3_prefix_o = reg_prefix_i;
      end

      default: begin
        sha3_prefix_o = reg_prefix_i;
      end
    endcase
  end

  // KMAC en / SHA3 mode / Strength
  //  by default, it uses reg cfg. When app intf reqs come, it uses AppCfg.
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      kmac_en_o         <= 1'b 0;
      sha3_mode_o       <= sha3_pkg::Sha3;
      keccak_strength_o <= sha3_pkg::L256;
    end else if (clr_appid) begin
      // As App completed, latch reg value
      kmac_en_o         <= reg_kmac_en_i;
      sha3_mode_o       <= reg_sha3_mode_i;
      keccak_strength_o <= reg_keccak_strength_i;
    end else if (set_appid) begin
      kmac_en_o         <= AppCfg[arb_idx].Mode == AppKMAC ? 1'b 1 : 1'b 0;
      sha3_mode_o       <= AppCfg[arb_idx].Mode == AppSHA3
                           ? sha3_pkg::Sha3 : sha3_pkg::CShake;
      keccak_strength_o <= AppCfg[arb_idx].Strength ;
    end else if (st == StIdle) begin
      kmac_en_o         <= reg_kmac_en_i;
      sha3_mode_o       <= reg_sha3_mode_i;
      keccak_strength_o <= reg_keccak_strength_i;
    end
  end

  // Status
  assign app_active_o = (st inside {StAppCfg, StAppMsg, StAppOutLen,
                                    StAppProcess, StAppWait});

  // Error Reporting ==========================================================
  always_comb begin
    priority casez ({fsm_err.valid, mux_err.valid})
      2'b ?1: error_o = mux_err;
      2'b 10: error_o = fsm_err;
      default: error_o = '{valid: 1'b0, code: ErrNone, info: '0};
    endcase
  end

  ////////////////
  // Assertions //
  ////////////////

  // KeyMgr sideload key and the digest should be in the Key Length value
  `ASSERT_INIT(SideloadKeySameToDigest_A, KeyMgrKeyW <= AppDigestW)
  `ASSERT_INIT(AppIntfInRange_A, AppDigestW inside {128, 192, 256, 384, 512})

  // Issue(#13655): Having a coverage that sideload keylen and CSR keylen are
  // different.
  `COVER(AppIntfUseDifferentSizeKey_C,
    (st == StAppCfg && kmac_en_o) |-> reg_key_len_i != SideloadedKey)

endmodule

    '''

    Identify relevant lint tags for the RTL to be checked for.
    Then run the tests using the linting tool.
    From the output of the linting tool, determine if there are security issues in the RTL.
================================== Ai Message ==================================
Tool Calls:
  retrieve_relevant_lint_tags (call_W2oFb1wN65q1KSRAFHaocvuK)
 Call ID: call_W2oFb1wN65q1KSRAFHaocvuK
  Args:
    query: application interface isolation privilege escalation command injection
================================= Tool Message =================================
Name: retrieve_relevant_lint_tags


DisallowCaseZ-ML: Do not use casez constructs in the design 


STARC05-3.1.2.7: Do not use embedded dc_shell scripts. (Verilog)Do not use embedded dc_shell scripts in the design (VHDL) 


W215: Reports inappropriate bit-selects of integer or time variables 


EscapeSpace-ML: Report backslash followed by space 


UseSystemTaskFunction-ML: Do not use standard or non-standard system tasks and functions 


UniquePriorityMisuse-ML: Detects if unique, unique0, and priority keywords are misused in case constructs 


STARC05-2.10.5.3b: Reports violation when there are three or more arithmetic operations in Always block 


W502: Ensure that a variable in the sensitivity list is not modified inside the xxxviiiSynopsys, Inc. Feedbackalways block 

W243: Recursive task enable

SigAssignX-ML: Signal driven by X


STARC05-2.2.2.2b: Do not define constants in the sensitivity list 


W213: Reports PLI tasks or functions that are not synthesizable 


STARC05-2.3.1.2c: Do not use unsynthesizable User-Defined Primitives (UDPs)

W350: A control character appears inside a string


STARC05-2.1.9.5: Do not use user-defined attributes in the design 


CheckLocalParam-ML: Reports violation if parameters are used in modules or interfaces 


ReEntrantOutput-ML: The re-entrant outputs should be avoided 


W373: A PLI task ($something) is used but not recognized


STARC05-1.6.1.2: Modules instantiating basic blocks must not contain lxiiiSynopsys, Inc.Feedbacklogic gates 

SigAssignZ-ML: Signal driven by Z
================================== Ai Message ==================================
Tool Calls:
  lint_checker_tool (call_LtBL9G4Fbin4aNUubkTfb1H9)
 Call ID: call_LtBL9G4Fbin4aNUubkTfb1H9
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv
    top_module: kmac_app
    lint_tags: ['DisallowCaseZ-ML', 'STARC05-3.1.2.7', 'W215', 'EscapeSpace-ML', 'UseSystemTaskFunction-ML', 'UniquePriorityMisuse-ML', 'STARC05-2.10.5.3b', 'W502', 'W243', 'SigAssignX-ML', 'STARC05-2.2.2.2b', 'W213', 'STARC05-2.3.1.2c', 'W350', 'STARC05-2.1.9.5', 'CheckLocalParam-ML', 'ReEntrantOutput-ML', 'W373', 'STARC05-1.6.1.2', 'SigAssignZ-ML']
================================= Tool Message =================================
Name: lint_checker_tool

Successfully executed:
```lint checker tool
```
Output: 
  -----------------------------------------------------------------------------
  Report Summary
  -----------------------------------------------------------------------------
  Product Info
    Name    : VC Static Master Shell
    Version : U-2023.03-1 -- Apr 17, 2023

  Report Info
    Created : May 06, 2025  16:49:33

    TopLevelModule: kmac_app

  -----------------------------------------------------------------------------
  Management Summary
  -----------------------------------------------------------------------------
  Stage           Family      Fatals    Errors  Warnings     Infos
  -----           --------  --------  --------  --------  --------
  LANGUAGE_CHECK  CODING           0        27         0         0
  -----           --------  --------  --------  --------  --------
  Total                            0        27         0         0


  -----------------------------------------------------------------------------
  Tree Summary
  -----------------------------------------------------------------------------
  Severity  Stage           Tag                        Count
  --------  -----           -------------------------  -----
  error     LANGUAGE_CHECK  CheckLocalParam-ML            19
  error     LANGUAGE_CHECK  DisallowCaseZ-ML               1
  error     LANGUAGE_CHECK  UniquePriorityMisuse-ML        7
  --------  -----           -------------------------  -----
  Total                                                   27



  -----------------------------------------------------------------------------
  CheckLocalParam-ML  (19 errors/0 waived)
  -----------------------------------------------------------------------------
  Tag            : CheckLocalParam-ML
  Description    : Use localparam instead of parameter to declare '[ParameterName]' in module or interface '[HDLModName]'.[Hierarchy: '[HIERARCHY]']
  Violation      : Lint:9
  Module         : kmac_app
  FileName       : build/lowrisc_ip_kmac_0.1/src/lowrisc_ip_kmac_0.1/rtl/kmac_app.sv
  LineNumber     : 13
  Statement      :   parameter  bit EnMasking = 1'b0,
  ParameterName  : EnMasking
  HDLModName     : kmac_app
  HIERARCHY      : :kmac_app
  -----------------------------------------------------------------------------
  Tag            : CheckLocalParam-ML
  Description    : Use localparam instead of parameter to declare '[ParameterName]' in module or interface '[HDLModName]'.[Hierarchy: '[HIERARCHY]']
  Violation      : Lint:23
  Module         : prim_buf
  FileName       : build/lowrisc_ip_kmac_0.1/src/lowrisc_prim_abstract_buf_0/prim_buf.sv
  LineNumber     : 21
  Statement      :   parameter int Width = 1
  ParameterName  : Width
  HDLModName     : prim_buf
  HIERARCHY      : :kmac_app:u_prim_buf_state_output_sel@prim_sec_anchor_buf:u_secure_anchor_buf@prim_buf
  -----------------------------------------------------------------------------
  Tag            : CheckLocalParam-ML
  Description    : Use localparam instead of parameter to declare '[ParameterName]' in module or interface '[HDLModName]'.[Hierarchy: '[HIERARCHY]']
  Violation      : Lint:11
  Module         : prim_arbiter_fixed
  FileName       : build/lowrisc_ip_kmac_0.1/src/lowrisc_prim_arbiter_0/rtl/prim_arbiter_fixed.sv
  LineNumber     : 17
  Statement      :   parameter int N   = 8,
  ParameterName  : N
  HDLModName     : prim_arbiter_fixed
  HIERARCHY      : :kmac_app:u_appid_arb@prim_arbiter_fixed
  -----------------------------------------------------------------------------
  Tag            : CheckLocalParam-ML
  Description    : Use localparam instead of parameter to declare '[ParameterName]' in module or interface '[HDLModName]'.[Hierarchy: '[HIERARCHY]']
  Violation      : Lint:27
  Module         : prim_generic_buf
  FileName       : build/lowrisc_ip_kmac_0.1/src/lowrisc_prim_generic_buf_0/rtl/prim_generic_buf.sv
  LineNumber     : 8
  Statement      :   parameter int Width = 1
  ParameterName  : Width
  HDLModName     : prim_generic_buf
  HIERARCHY      : :kmac_app:u_prim_buf_state_output_valid@prim_sec_anchor_buf:u_secure_anchor_buf@prim_buf:\gen_generic.u_impl_generic @prim_generic_buf
  -----------------------------------------------------------------------------
  Tag            : CheckLocalParam-ML
  Description    : Use localparam instead of parameter to declare '[ParameterName]' in module or interface '[HDLModName]'.[Hierarchy: '[HIERARCHY]']
  Violation      : Lint:13
  Module         : prim_arbiter_fixed
  FileName       : build/lowrisc_ip_kmac_0.1/src/lowrisc_prim_arbiter_0/rtl/prim_arbiter_fixed.sv
  LineNumber     : 22
  Statement      :   parameter bit EnDataPort = 1,
  ParameterName  : EnDataPort
  HDLModName     : prim_arbiter_fixed
  HIERARCHY      : :kmac_app:u_appid_arb@prim_arbiter_fixed
  -----------------------------------------------------------------------------
  Tag            : CheckLocalParam-ML
  Description    : Use localparam instead of parameter to declare '[ParameterName]' in module or interface '[HDLModName]'.[Hierarchy: '[HIERARCHY]']
  Violation      : Lint:21
  Module         : prim_generic_flop
  FileName       : build/lowrisc_ip_kmac_0.1/src/lowrisc_prim_generic_flop_0/rtl/prim_generic_flop.sv
  LineNumber     : 9
  Statement      :   parameter logic [Width-1:0] ResetValue = 0
  ParameterName  : ResetValue
  HDLModName     : prim_generic_flop
  HIERARCHY      : :kmac_app:u_state_regs@prim_sparse_fsm_flop:u_state_flop@prim_flop:\gen_generic.u_impl_generic @prim_generic_flop
  -----------------------------------------------------------------------------
  Tag            : CheckLocalParam-ML
  Description    : Use localparam instead of parameter to declare '[ParameterName]' in module or interface '[HDLModName]'.[Hierarchy: '[HIERARCHY]']
  Violation      : Lint:22
  Module         : prim_sec_anchor_buf
  FileName       : build/lowrisc_ip_kmac_0.1/src/lowrisc_prim_sec_anchor_0.1/rtl/prim_sec_anchor_buf.sv
  LineNumber     : 8
  Statement      :   parameter int Width = 1
  ParameterName  : Width
  HDLModName     : prim_sec_anchor_buf
  HIERARCHY      : :kmac_app:u_prim_buf_state_output_sel@prim_sec_anchor_buf
  -----------------------------------------------------------------------------
  Tag            : CheckLocalParam-ML
  Description    : Use localparam instead of parameter to declare '[ParameterName]' in module or interface '[HDLModName]'.[Hierarchy: '[HIERARCHY]']
  Violation      : Lint:19
  Module         : prim_flop
  FileName       : build/lowrisc_ip_kmac_0.1/src/lowrisc_prim_abstract_flop_0/prim_flop.sv
  LineNumber     : 22
  Statement      :   parameter logic [Width-1:0] ResetValue = 0
  ParameterName  : ResetValue
  HDLModName     : prim_flop
  HIERARCHY      : :kmac_app:u_state_regs@prim_sparse_fsm_flop:u_state_flop@prim_flop
  -----------------------------------------------------------------------------
  Tag            : CheckLocalParam-ML
  Description    : Use localparam instead of parameter to declare '[ParameterName]' in module or interface '[HDLModName]'.[Hierarchy: '[HIERARCHY]']
  Violation      : Lint:20
  Module         : prim_generic_flop
  FileName       : build/lowrisc_ip_kmac_0.1/src/lowrisc_prim_generic_flop_0/rtl/prim_generic_flop.sv
  LineNumber     : 8
  Statement      :   parameter int               Width      = 1,
  ParameterName  : Width
  HDLModName     : prim_generic_flop
  HIERARCHY      : :kmac_app:u_state_regs@prim_sparse_fsm_flop:u_state_flop@prim_flop:\gen_generic.u_impl_generic @prim_generic_flop
  -----------------------------------------------------------------------------
  Tag            : CheckLocalParam-ML
  Description    : Use localparam instead of parameter to declare '[ParameterName]' in module or interface '[HDLModName]'.[Hierarchy: '[HIERARCHY]']
  Violation      : Lint:15
  Module         : prim_sparse_fsm_flop
  FileName       : build/lowrisc_ip_kmac_0.1/src/lowrisc_prim_sparse_fsm_0/rtl/prim_sparse_fsm_flop.sv
  LineNumber     : 9
  Statement      :   parameter type              StateEnumT = logic [Width-1:0],
  ParameterName  : StateEnumT
  HDLModName     : prim_sparse_fsm_flop
  HIERARCHY      : :kmac_app:u_state_regs@prim_sparse_fsm_flop
  -----------------------------------------------------------------------------
  Tag            : CheckLocalParam-ML
  Description    : Use localparam instead of parameter to declare '[ParameterName]' in module or interface '[HDLModName]'.[Hierarchy: '[HIERARCHY]']
  Violation      : Lint:12
  Module         : prim_arbiter_fixed
  FileName       : build/lowrisc_ip_kmac_0.1/src/lowrisc_prim_arbiter_0/rtl/prim_arbiter_fixed.sv
  LineNumber     : 18
  Statement      :   parameter int DW  = 32,
  ParameterName  : DW
  HDLModName     : prim_arbiter_fixed
  HIERARCHY      : :kmac_app:u_appid_arb@prim_arbiter_fixed
  -----------------------------------------------------------------------------
  Tag            : CheckLocalParam-ML
  Description    : Use localparam instead of parameter to declare '[ParameterName]' in module or interface '[HDLModName]'.[Hierarchy: '[HIERARCHY]']
  Violation      : Lint:26
  Module         : prim_buf
  FileName       : build/lowrisc_ip_kmac_0.1/src/lowrisc_prim_abstract_buf_0/prim_buf.sv
  LineNumber     : 21
  Statement      :   parameter int Width = 1
  ParameterName  : Width
  HDLModName     : prim_buf
  HIERARCHY      : :kmac_app:u_prim_buf_state_output_valid@prim_sec_anchor_buf:u_secure_anchor_buf@prim_buf
  -----------------------------------------------------------------------------
  Tag            : CheckLocalParam-ML
  Description    : Use localparam instead of parameter to declare '[ParameterName]' in module or interface '[HDLModName]'.[Hierarchy: '[HIERARCHY]']
  Violation      : Lint:17
  Module         : prim_sparse_fsm_flop
  FileName       : build/lowrisc_ip_kmac_0.1/src/lowrisc_prim_sparse_fsm_0/rtl/prim_sparse_fsm_flop.sv
  LineNumber     : 13
  Statement      :   parameter bit               EnableAlertTriggerSVA = 1
  ParameterName  : EnableAlertTriggerSVA
  HDLModName     : prim_sparse_fsm_flop
  HIERARCHY      : :kmac_app:u_state_regs@prim_sparse_fsm_flop
  -----------------------------------------------------------------------------
  Tag            : CheckLocalParam-ML
  Description    : Use localparam instead of parameter to declare '[ParameterName]' in module or interface '[HDLModName]'.[Hierarchy: '[HIERARCHY]']
  Violation      : Lint:24
  Module         : prim_generic_buf
  FileName       : build/lowrisc_ip_kmac_0.1/src/lowrisc_prim_generic_buf_0/rtl/prim_generic_buf.sv
  LineNumber     : 8
  Statement      :   parameter int Width = 1
  ParameterName  : Width
  HDLModName     : prim_generic_buf
  HIERARCHY      : :kmac_app:u_prim_buf_state_output_sel@prim_sec_anchor_buf:u_secure_anchor_buf@prim_buf:\gen_generic.u_impl_generic @prim_generic_buf
  -----------------------------------------------------------------------------
  Tag            : CheckLocalParam-ML
  Description    : Use localparam instead of parameter to declare '[ParameterName]' in module or interface '[HDLModName]'.[Hierarchy: '[HIERARCHY]']
  Violation      : Lint:10
  Module         : kmac_app
  FileName       : build/lowrisc_ip_kmac_0.1/src/lowrisc_ip_kmac_0.1/rtl/kmac_app.sv
  LineNumber     : 15
  Statement      :   parameter  bit SecIdleAcceptSwMsg = 1'b0
  ParameterName  : SecIdleAcceptSwMsg
  HDLModName     : kmac_app
  HIERARCHY      : :kmac_app
  -----------------------------------------------------------------------------
  Tag            : CheckLocalParam-ML
  Description    : Use localparam instead of parameter to declare '[ParameterName]' in module or interface '[HDLModName]'.[Hierarchy: '[HIERARCHY]']
  Violation      : Lint:14
  Module         : prim_sparse_fsm_flop
  FileName       : build/lowrisc_ip_kmac_0.1/src/lowrisc_prim_sparse_fsm_0/rtl/prim_sparse_fsm_flop.sv
  LineNumber     : 8
  Statement      :   parameter int               Width      = 1,
  ParameterName  : Width
  HDLModName     : prim_sparse_fsm_flop
  HIERARCHY      : :kmac_app:u_state_regs@prim_sparse_fsm_flop
  -----------------------------------------------------------------------------
  Tag            : CheckLocalParam-ML
  Description    : Use localparam instead of parameter to declare '[ParameterName]' in module or interface '[HDLModName]'.[Hierarchy: '[HIERARCHY]']
  Violation      : Lint:18
  Module         : prim_flop
  FileName       : build/lowrisc_ip_kmac_0.1/src/lowrisc_prim_abstract_flop_0/prim_flop.sv
  LineNumber     : 21
  Statement      :   parameter int               Width      = 1,
  ParameterName  : Width
  HDLModName     : prim_flop
  HIERARCHY      : :kmac_app:u_state_regs@prim_sparse_fsm_flop:u_state_flop@prim_flop
  -----------------------------------------------------------------------------
  Tag            : CheckLocalParam-ML
  Description    : Use localparam instead of parameter to declare '[ParameterName]' in module or interface '[HDLModName]'.[Hierarchy: '[HIERARCHY]']
  Violation      : Lint:16
  Module         : prim_sparse_fsm_flop
  FileName       : build/lowrisc_ip_kmac_0.1/src/lowrisc_prim_sparse_fsm_0/rtl/prim_sparse_fsm_flop.sv
  LineNumber     : 10
  Statement      :   parameter logic [Width-1:0] ResetValue = '0,
  ParameterName  : ResetValue
  HDLModName     : prim_sparse_fsm_flop
  HIERARCHY      : :kmac_app:u_state_regs@prim_sparse_fsm_flop
  -----------------------------------------------------------------------------
  Tag            : CheckLocalParam-ML
  Description    : Use localparam instead of parameter to declare '[ParameterName]' in module or interface '[HDLModName]'.[Hierarchy: '[HIERARCHY]']
  Violation      : Lint:25
  Module         : prim_sec_anchor_buf
  FileName       : build/lowrisc_ip_kmac_0.1/src/lowrisc_prim_sec_anchor_0.1/rtl/prim_sec_anchor_buf.sv
  LineNumber     : 8
  Statement      :   parameter int Width = 1
  ParameterName  : Width
  HDLModName     : prim_sec_anchor_buf
  HIERARCHY      : :kmac_app:u_prim_buf_state_output_valid@prim_sec_anchor_buf

  -----------------------------------------------------------------------------
  DisallowCaseZ-ML  (1 error/0 waived)
  -----------------------------------------------------------------------------
  Tag           : DisallowCaseZ-ML
  Description   : 'casez' statement used [Hierarchy: '[HIERARCHY]']
  Violation     : Lint:8
  Module        : kmac_app
  FileName      : build/lowrisc_ip_kmac_0.1/src/lowrisc_ip_kmac_0.1/rtl/kmac_app.sv
  LineNumber    : 960
  Statement     :     priority casez ({fsm_err.valid, mux_err.valid})
  HIERARCHY     : :kmac_app

  -----------------------------------------------------------------------------
  UniquePriorityMisuse-ML  (7 errors/0 waived)
  -----------------------------------------------------------------------------
  Tag           : UniquePriorityMisuse-ML
  Description   : Use of [NodeType] construct in [NodeType1] block
  Violation     : Lint:1
  Module        : kmac_app
  FileName      : build/lowrisc_ip_kmac_0.1/src/lowrisc_ip_kmac_0.1/rtl/kmac_app.sv
  LineNumber    : 420
  Statement     :     unique case (st)
  NodeType      : unique
  NodeType1     : Case
  -----------------------------------------------------------------------------
  Tag           : UniquePriorityMisuse-ML
  Description   : Use of [NodeType] construct in [NodeType1] block
  Violation     : Lint:6
  Module        : kmac_app
  FileName      : build/lowrisc_ip_kmac_0.1/src/lowrisc_ip_kmac_0.1/rtl/kmac_app.sv
  LineNumber    : 906
  Statement     :     unique case (st)
  NodeType      : unique
  NodeType1     : Case
  -----------------------------------------------------------------------------
  Tag           : UniquePriorityMisuse-ML
  Description   : Use of [NodeType] construct in [NodeType1] block
  Violation     : Lint:5
  Module        : kmac_app
  FileName      : build/lowrisc_ip_kmac_0.1/src/lowrisc_ip_kmac_0.1/rtl/kmac_app.sv
  LineNumber    : 862
  Statement     :     unique case (st)
  NodeType      : unique
  NodeType1     : Case
  -----------------------------------------------------------------------------
  Tag           : UniquePriorityMisuse-ML
  Description   : Use of [NodeType] construct in [NodeType1] block
  Violation     : Lint:2
  Module        : kmac_app
  FileName      : build/lowrisc_ip_kmac_0.1/src/lowrisc_ip_kmac_0.1/rtl/kmac_app.sv
  LineNumber    : 532
  Statement     :         unique case ({err_processed_i,
  NodeType      : unique
  NodeType1     : Case
  -----------------------------------------------------------------------------
  Tag           : UniquePriorityMisuse-ML
  Description   : Use of [NodeType] construct in [NodeType1] block
  Violation     : Lint:3
  Module        : kmac_app
  FileName      : build/lowrisc_ip_kmac_0.1/src/lowrisc_ip_kmac_0.1/rtl/kmac_app.sv
  LineNumber    : 689
  Statement     :     unique case (mux_sel_buf_kmac)
  NodeType      : unique
  NodeType1     : Case
  -----------------------------------------------------------------------------
  Tag           : UniquePriorityMisuse-ML
  Description   : Use of [NodeType] construct in [NodeType1] block
  Violation     : Lint:4
  Module        : kmac_app
  FileName      : build/lowrisc_ip_kmac_0.1/src/lowrisc_ip_kmac_0.1/rtl/kmac_app.sv
  LineNumber    : 800
  Statement     :           unique case (reg_keccak_strength_i)
  NodeType      : unique
  NodeType1     : Case
  -----------------------------------------------------------------------------
  Tag           : UniquePriorityMisuse-ML
  Description   : Use of [NodeType] construct in [NodeType1] block
  Violation     : Lint:7
  Module        : kmac_app
  FileName      : build/lowrisc_ip_kmac_0.1/src/lowrisc_ip_kmac_0.1/rtl/kmac_app.sv
  LineNumber    : 960
  Statement     :     priority casez ({fsm_err.valid, mux_err.valid})
  NodeType      : priority
  NodeType1     : Case

================================== Ai Message ==================================

The lint checks for the RTL module kmac_app in the file /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv returned the following results:

- 27 errors were found in total.
- The errors are mainly from the following lint tags:
  - CheckLocalParam-ML (19 errors): This indicates the use of 'parameter' instead of 'localparam' in module or interface declarations. This is more of a coding style or best practice issue rather than a direct security vulnerability.
  - DisallowCaseZ-ML (1 error): The use of 'casez' statement is disallowed. This could potentially cause issues in synthesis or simulation but is not directly a security vulnerability.
  - UniquePriorityMisuse-ML (7 errors): Misuse of unique or priority keywords in case constructs. This could lead to unintended behavior in the FSM or control logic, which might have security implications if it affects privilege escalation or interface isolation.

No direct lint errors related to privilege escalation, application interface isolation, or command injection were reported by the lint tool.

However, the presence of UniquePriorityMisuse-ML errors in the FSM and control logic could potentially lead to unintended state transitions or behavior, which might be exploited in a security context. It is recommended to review and fix these issues to ensure the FSM behaves as intended and does not allow unintended privilege escalation or command injection.

Summary:
- No explicit security issues related to application interface isolation, privilege escalation, or command injection were flagged by the lint tool.
- Some coding and FSM control issues were found that could indirectly affect security and should be addressed.
- Manual review of FSM and control logic is recommended to ensure security properties are maintained.

If you want, I can help analyze specific parts of the code or suggest fixes for the lint errors.
================================= Tool Message =================================
Name: run_linter_agent

The lint checks for the RTL module kmac_app in the file /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv returned the following results:

- 27 errors were found in total.
- The errors are mainly from the following lint tags:
  - CheckLocalParam-ML (19 errors): This indicates the use of 'parameter' instead of 'localparam' in module or interface declarations. This is more of a coding style or best practice issue rather than a direct security vulnerability.
  - DisallowCaseZ-ML (1 error): The use of 'casez' statement is disallowed. This could potentially cause issues in synthesis or simulation but is not directly a security vulnerability.
  - UniquePriorityMisuse-ML (7 errors): Misuse of unique or priority keywords in case constructs. This could lead to unintended behavior in the FSM or control logic, which might have security implications if it affects privilege escalation or interface isolation.

No direct lint errors related to privilege escalation, application interface isolation, or command injection were reported by the lint tool.

However, the presence of UniquePriorityMisuse-ML errors in the FSM and control logic could potentially lead to unintended state transitions or behavior, which might be exploited in a security context. It is recommended to review and fix these issues to ensure the FSM behaves as intended and does not allow unintended privilege escalation or command injection.

Summary:
- No explicit security issues related to application interface isolation, privilege escalation, or command injection were flagged by the lint tool.
- Some coding and FSM control issues were found that could indirectly affect security and should be addressed.
- Manual review of FSM and control logic is recommended to ensure security properties are maintained.

If you want, I can help analyze specific parts of the code or suggest fixes for the lint errors.
================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_8i8dPDmNIhKry3puGN6fxA92)
 Call ID: call_8i8dPDmNIhKry3puGN6fxA92
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv
    top_module: kmac_app
    security_objective: application interface isolation, privilege escalation, command injection
================================ Human Message =================================

Are there security concerns related to application interface isolation, privilege escalation, command injection in the provided RTL:
    """

    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// KMAC Application interface

`include "prim_assert.sv"

module kmac_app
  import kmac_pkg::*;
#(
  // App specific configs are defined in kmac_pkg
  parameter  bit EnMasking = 1'b0,
  localparam int Share = (EnMasking) ? 2 : 1, // derived parameter
  parameter  bit SecIdleAcceptSwMsg = 1'b0
) (
  input clk_i,
  input rst_ni,

  // Secret Key from register
  input [MaxKeyLen-1:0] reg_key_data_i [Share],
  input key_len_e       reg_key_len_i,

  // Prefix from register
  input [sha3_pkg::NSRegisterSize*8-1:0] reg_prefix_i,

  // mode, strength, kmac_en from register
  input                             reg_kmac_en_i,
  input sha3_pkg::sha3_mode_e       reg_sha3_mode_i,
  input sha3_pkg::keccak_strength_e reg_keccak_strength_i,

  // Data from Software
  input                sw_valid_i,
  input [MsgWidth-1:0] sw_data_i,
  input [MsgWidth-1:0] sw_mask_i,
  output logic         sw_ready_o,

  // KeyMgr Sideload Key interface
  input keymgr_pkg::hw_key_req_t keymgr_key_i,

  // Application Message in/ Digest out interface + control signals
  input  app_req_t [NumAppIntf-1:0] app_i,
  output app_rsp_t [NumAppIntf-1:0] app_o,

  // to KMAC Core: Secret key
  output logic [MaxKeyLen-1:0] key_data_o [Share],
  output key_len_e             key_len_o,
  output logic                 key_valid_o,

  // to MSG_FIFO
  output logic                kmac_valid_o,
  output logic [MsgWidth-1:0] kmac_data_o,
  output logic [MsgWidth-1:0] kmac_mask_o,
  input                       kmac_ready_i,

  // KMAC Core
  output logic kmac_en_o,

  // To Sha3 Core
  output logic [sha3_pkg::NSRegisterSize*8-1:0] sha3_prefix_o,
  output sha3_pkg::sha3_mode_e                  sha3_mode_o,
  output sha3_pkg::keccak_strength_e            keccak_strength_o,

  // STATE from SHA3 Core
  input                        keccak_state_valid_i,
  input [sha3_pkg::StateW-1:0] keccak_state_i [Share],

  // to STATE TL-window if Application is not active, the incoming state goes to
  // register if kdf_en is set, the state value goes to application and the
  // output to the register is all zero.
  output logic                        reg_state_valid_o,
  output logic [sha3_pkg::StateW-1:0] reg_state_o [Share],

  // Configurations If key_en is set, the logic uses KeyMgr's sideloaded key as
  // a secret key rather than register values. This only affects when software
  // initiates. If App initiates the hash operation and uses KMAC algorithm, it
  // always uses sideloaded key.
  input keymgr_key_en_i,

  // Commands
  // Command from software
  input kmac_cmd_e sw_cmd_i,

  // from SHA3
  input prim_mubi_pkg::mubi4_t absorbed_i,

  // to KMAC
  output kmac_cmd_e cmd_o,

  // to SW
  output prim_mubi_pkg::mubi4_t absorbed_o,

  // To status
  output logic app_active_o,

  // Status
  // - entropy_ready_i: Entropy configured by SW. It is used to check if App
  //                    is OK to request.
  input prim_mubi_pkg::mubi4_t entropy_ready_i,

  // Error input
  // This error comes from KMAC/SHA3 engine.
  // KeyMgr interface delivers the error signal to KeyMgr to drop the current op
  // and re-initiate.
  // If error happens, regardless of SW-initiated or KeyMgr-initiated, the error
  // is reported to the ERR_CODE so that SW can look into.
  input error_i,

  // SW sets err_processed bit in CTRL then the logic goes to Idle
  input err_processed_i,

  output prim_mubi_pkg::mubi4_t clear_after_error_o,

  // error_o value is pushed to Error FIFO at KMAC/SHA3 top and reported to SW
  output kmac_pkg::err_t error_o,

  // Life cycle
  input  lc_ctrl_pkg::lc_tx_t lc_escalate_en_i,

  output logic sparse_fsm_error_o
);

  import sha3_pkg::KeccakBitCapacity;
  import sha3_pkg::L128;
  import sha3_pkg::L224;
  import sha3_pkg::L256;
  import sha3_pkg::L384;
  import sha3_pkg::L512;

  /////////////////
  // Definitions //
  /////////////////

  // Digest width is same to the key width `keymgr_pkg::KeyWidth`.
  localparam int KeyMgrKeyW = $bits(keymgr_key_i.key[0]);

  localparam key_len_e KeyLengths [5] = '{Key128, Key192, Key256, Key384, Key512};

  localparam int SelKeySize = (AppKeyW == 128) ? 0 :
                              (AppKeyW == 192) ? 1 :
                              (AppKeyW == 256) ? 2 :
                              (AppKeyW == 384) ? 3 :
                              (AppKeyW == 512) ? 4 : 0 ;
  localparam int SelDigSize = (AppDigestW == 128) ? 0 :
                              (AppDigestW == 192) ? 1 :
                              (AppDigestW == 256) ? 2 :
                              (AppDigestW == 384) ? 3 :
                              (AppDigestW == 512) ? 4 : 0 ;
  localparam key_len_e SideloadedKey = KeyLengths[SelKeySize];

  // Define right_encode(outlen) value here
  // Look at kmac_pkg::key_len_e for the kinds of key size
  //
  // These values should be exactly the same as the key length encodings
  // in kmac_core.sv, with the only difference being that the byte representing
  // the byte-length of the encoded value is in the MSB position due to right encoding
  // instead of in the LSB position (left encoding).
  localparam int OutLenW = 24;
  localparam logic [OutLenW-1:0] EncodedOutLen [5]= '{
    24'h 0001_80, // Key128
    24'h 0001_C0, // Key192
    24'h 02_0001, // Key256
    24'h 02_8001, // Key384
    24'h 02_0002  // Key512
  };

  localparam logic [OutLenW-1:0] EncodedOutLenMask [5] = '{
    24'h 00FFFF, // Key128,
    24'h 00FFFF, // Key192
    24'h FFFFFF, // Key256
    24'h FFFFFF, // Key384
    24'h FFFFFF  // Key512
  };

  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 3 -m 14 -n 10 \
  //     -s 2454278799 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: |||||||||| (14.29%)
  //  4: |||||||||||||||||||| (27.47%)
  //  5: ||||||||||||| (18.68%)
  //  6: |||||||||||||||| (21.98%)
  //  7: |||||||| (10.99%)
  //  8: |||| (6.59%)
  //  9: --
  // 10: --
  //
  // Minimum Hamming distance: 3
  // Maximum Hamming distance: 8
  // Minimum Hamming weight: 3
  // Maximum Hamming weight: 8
  //
  localparam int StateWidth = 10;
  typedef enum logic [StateWidth-1:0] {
    StIdle = 10'b1010111110,

    // Application operation.
    //
    // if start request comes from an App first, until the operation ends by the
    // requested App, all operations are granted to the specific App. SW
    // requests and other Apps requests will be ignored.
    //
    // App interface does not have control signals. When first data valid occurs
    // from an App, this logic asserts the start command to the downstream. When
    // last beat pulse comes, this logic asserts the process to downstream
    // (after the transaction is accepted regardless of partial writes or not)
    // When absorbed by SHA3 core, the logic sends digest to the requested App
    // and right next cycle, it triggers done command to downstream.

    // In StAppCfg state, it latches the cfg from AppCfg parameter to determine
    // the kmac_mode, sha3_mode, keccak strength.
    StAppCfg = 10'b1010101101,

    StAppMsg = 10'b1110001011,

    // In StKeyOutLen, this module pushes encoded outlen to the MSG_FIFO.
    // Assume the length is 256 bit, the data will be 48'h 02_0100
    StAppOutLen  = 10'b1010011000,
    StAppProcess = 10'b1110110010,
    StAppWait    = 10'b1001010000,

    // SW Controlled
    // If start request comes from SW first, until the operation ends, all
    // requests from KeyMgr will be discarded.
    StSw = 10'b0010111011,

    // Error KeyNotValid
    // When KeyMgr operates, the secret key is not ready yet.
    StKeyMgrErrKeyNotValid = 10'b0111011111,

    StError = 10'b1110010111,
    StErrorAwaitSw = 10'b0110001100,
    StErrorAwaitApp = 10'b1011100000,
    StErrorWaitAbsorbed = 10'b0010100100,
    StErrorServiceRejected = 10'b1101000111,

    // This state is used for terminal errors
    StTerminalError = 10'b0101110110
  } st_e;

  /////////////
  // Signals //
  /////////////

  st_e st, st_d;

  logic keymgr_key_used;

  // app_rsp_t signals
  // The state machine controls mux selection, which controls the ready signal
  // the other responses are controled in separate logic. So define the signals
  // here and merge them to the response.
  logic app_data_ready, fsm_data_ready;
  logic app_digest_done, fsm_digest_done_q, fsm_digest_done_d;
  logic [AppDigestW-1:0] app_digest [2];

  // One more slot for value NumAppIntf. It is the value when no app intf is
  // chosen.
  localparam int unsigned AppIdxW = $clog2(NumAppIntf);

  // app_id indicates, which app interface was chosen. various logic use this
  // value to get the config or return the data.
  logic [AppIdxW-1:0] app_id, app_id_d;
  logic               clr_appid, set_appid;

  // Output length
  logic [OutLenW-1:0] encoded_outlen, encoded_outlen_mask;

  // state output
  // Mux selection signal
  app_mux_sel_e mux_sel;
  app_mux_sel_e mux_sel_buf_output;
  app_mux_sel_e mux_sel_buf_err_check;
  app_mux_sel_e mux_sel_buf_kmac;

  // Error checking logic

  kmac_pkg::err_t fsm_err, mux_err;

  logic service_rejected_error;
  logic service_rejected_error_set, service_rejected_error_clr;
  logic err_during_sw_d, err_during_sw_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni)                         service_rejected_error <= 1'b 0;
    else if (service_rejected_error_set) service_rejected_error <= 1'b 1;
    else if (service_rejected_error_clr) service_rejected_error <= 1'b 0;
  end

  ////////////////////////////
  // Application Mux/ Demux //
  ////////////////////////////


  // Processing return data.
  // sends to only selected app intf.
  // clear digest right after done to not leak info to other interface
  always_comb begin
    for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
      if (i == app_id) begin
        app_o[i] = '{
          ready:         app_data_ready | fsm_data_ready,
          done:          app_digest_done | fsm_digest_done_q,
          digest_share0: app_digest[0],
          digest_share1: app_digest[1],
          // if fsm asserts done, should be an error case.
          error:         error_i | fsm_digest_done_q | sparse_fsm_error_o
                         | service_rejected_error
        };
      end else begin
        app_o[i] = '{
          ready: 1'b 0,
          done:  1'b 0,
          digest_share0: '0,
          digest_share1: '0,
          error: 1'b 0
        };
      end
    end // for {i, NumAppIntf, i++}
  end // aiways_comb

  // app_id latch
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) app_id <= AppIdxW'(0) ; // Do not select any
    else if (clr_appid) app_id <= AppIdxW'(0);
    else if (set_appid) app_id <= app_id_d;
  end

  // app_id selection as of now, app_id uses Priority. The assumption is that
  //  the request normally does not collide. (ROM_CTRL activates very early
  //  stage at the boot sequence)
  //
  //  If this assumption is not true, consider RR arbiter.

  // Prep for arbiter
  logic [NumAppIntf-1:0] app_reqs;
  logic [NumAppIntf-1:0] unused_app_gnts;
  logic [$clog2(NumAppIntf)-1:0] arb_idx;
  logic arb_valid;
  logic arb_ready;

  always_comb begin
    app_reqs = '0;
    for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
      app_reqs[i] = app_i[i].valid;
    end
  end

  prim_arbiter_fixed #(
    .N (NumAppIntf),
    .DW(1),
    .EnDataPort(1'b 0)
  ) u_appid_arb (
    .clk_i,
    .rst_ni,

    .req_i  (app_reqs),
    .data_i ('{default:'0}),
    .gnt_o  (unused_app_gnts),
    .idx_o  (arb_idx),

    .valid_o (arb_valid),
    .data_o  (), // not used
    .ready_i (arb_ready)
  );

  assign app_id_d = AppIdxW'(arb_idx);
  assign arb_ready = set_appid;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) fsm_digest_done_q <= 1'b 0;
    else         fsm_digest_done_q <= fsm_digest_done_d;
  end

  /////////
  // FSM //
  /////////

  // State register
  `PRIM_FLOP_SPARSE_FSM(u_state_regs, st_d, st, st_e, StIdle)

  // Create a lint error to reduce the risk of accidentally enabling this feature.
  `ASSERT_STATIC_LINT_ERROR(KmacSecIdleAcceptSwMsgNonDefault, SecIdleAcceptSwMsg == 0)

  // Next State & output logic
  // SEC_CM: FSM.SPARSE
  always_comb begin
    st_d = st;

    mux_sel = SecIdleAcceptSwMsg ? SelSw : SelNone;

    // app_id control
    set_appid = 1'b 0;
    clr_appid = 1'b 0;

    // Commands
    cmd_o = CmdNone;

    // Software output
    absorbed_o = prim_mubi_pkg::MuBi4False;

    // Error
    fsm_err = '{valid: 1'b 0, code: ErrNone, info: '0};
    sparse_fsm_error_o = 1'b 0;

    clear_after_error_o = prim_mubi_pkg::MuBi4False;

    service_rejected_error_set = 1'b 0;
    service_rejected_error_clr = 1'b 0;

    // If error happens, FSM asserts data ready but discard incoming msg
    fsm_data_ready = 1'b 0;
    fsm_digest_done_d = 1'b 0;

    unique case (st)
      StIdle: begin
        if (arb_valid) begin
          st_d = StAppCfg;

          // choose app_id
          set_appid = 1'b 1;
        end else if (sw_cmd_i == CmdStart) begin
          st_d = StSw;
          // Software initiates the sequence
          cmd_o = CmdStart;
        end else begin
          st_d = StIdle;
        end
      end

      StAppCfg: begin
        if (AppCfg[app_id].Mode == AppKMAC &&
          prim_mubi_pkg::mubi4_test_false_strict(entropy_ready_i)) begin
          // Check if the entropy is not configured but it is needed in
          // `AppCfg[app_id]` (KMAC mode).
          //
          // SW is not properly configured, report and not request Hashing
          // Return the app with errors
          st_d = StError;

          service_rejected_error_set = 1'b 1;

        end else begin
          // As Cfg is stable now, it sends cmd
          st_d = StAppMsg;

          // App initiates the data
          cmd_o = CmdStart;
        end
      end

      StAppMsg: begin
        mux_sel = SelApp;
        if (app_i[app_id].valid && app_o[app_id].ready && app_i[app_id].last) begin
          if (AppCfg[app_id].Mode == AppKMAC) begin
            st_d = StAppOutLen;
          end else begin
            st_d = StAppProcess;
          end
        end else begin
          st_d = StAppMsg;
        end
      end

      StAppOutLen: begin
        mux_sel = SelOutLen;

        if (kmac_valid_o && kmac_ready_i) begin
          st_d = StAppProcess;
        end else begin
          st_d = StAppOutLen;
        end
      end

      StAppProcess: begin
        cmd_o = CmdProcess;
        st_d = StAppWait;
      end

      StAppWait: begin
        if (prim_mubi_pkg::mubi4_test_true_strict(absorbed_i)) begin
          // Send digest to KeyMgr and complete the op
          st_d = StIdle;
          cmd_o = CmdDone;

          clr_appid = 1'b 1;
        end else begin
          st_d = StAppWait;
        end
      end

      StSw: begin
        mux_sel = SelSw;

        cmd_o = sw_cmd_i;
        absorbed_o = absorbed_i;

        if (sw_cmd_i == CmdDone) begin
          st_d = StIdle;
        end else begin
          st_d = StSw;
        end
      end

      StKeyMgrErrKeyNotValid: begin
        st_d = StError;

        // As mux_sel is not set to SelApp, app_data_ready is still 0.
        // This logic won't accept the requests from the selected App.
        fsm_err.valid = 1'b 1;
        fsm_err.code = ErrKeyNotValid;
        fsm_err.info = 24'(app_id);
      end

      StError: begin
        // In this state, the state machine flush out the request
        st_d = StError;

        // Absorb data on the app interface.
        fsm_data_ready = ~err_during_sw_q;

        // Next step depends on two conditions:
        // 1) Error being processed by SW
        // 2) Last data provided from the app interface (so that the app interface is completely)
        //    drained.  If the error occurred during a SW operation, the app interface is not
        //    involved, so this condition gets skipped.
        unique case ({err_processed_i,
                      (app_i[app_id].valid && app_i[app_id].last) || err_during_sw_q})
          2'b00: begin
            // Error not processed by SW and not last data from app interface -> keep current state.
            st_d = StError;
          end
          2'b01: begin
            // Error not processed by SW but last data from app interface:
            // 1. Send garbage digest to the app interface (in the next cycle) to complete the
            // transaction.
            fsm_digest_done_d = ~err_during_sw_q;
            if (service_rejected_error) begin
              // 2.a) Service was rejected because an app interface tried to configure KMAC while no
              // entropy was available. It is assumed that SW is not loaded yet, so don't wait for
              // SW to process the error. The last data from the app interface has now arrived, but
              // we don't need to wait for the SHA3 core to have absorbed it because the data never
              // entered the SHA3 core: the request from the app interface was terminated during the
              // configuration phase.
              st_d = StErrorServiceRejected;
            end else begin
              // 2.b) If service was not rejected, wait for SW to process the error.
              st_d = StErrorAwaitSw;
            end
          end
          2'b10: begin
            // Error processed by SW but not last data from app interface -> wait for app interface.
            st_d = StErrorAwaitApp;
          end
          2'b11: begin
            // Error processed by SW and last data from app interface:
            // Send garbage digest to the app interface (in the next cycle) to complete the
            // transaction.
            fsm_digest_done_d = ~err_during_sw_q;
            // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
            // but serves to bring the SHA3 engine back to the idle state).
            cmd_o = CmdProcess;
            st_d = StErrorWaitAbsorbed;
          end
          default: st_d = StError;
        endcase
      end

      StErrorAwaitSw: begin
        // Just wait for SW to process the error.
        if (err_processed_i) begin
          // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
          // but serves to bring the SHA3 engine back to the idle state).
          cmd_o = CmdProcess;
          st_d = StErrorWaitAbsorbed;
        end
      end

      StErrorAwaitApp: begin
        // Keep absorbing data on the app interface until the last data.
        fsm_data_ready = 1'b1;
        if (app_i[app_id].valid && app_i[app_id].last) begin
          // Send garbage digest to the app interface (in the next cycle) to complete the
          // transaction.
          fsm_digest_done_d = 1'b1;
          // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
          // but serves to bring the SHA3 engine back to the idle state).
          cmd_o = CmdProcess;
          st_d = StErrorWaitAbsorbed;
        end
      end

      StErrorWaitAbsorbed: begin
        if (prim_mubi_pkg::mubi4_test_true_strict(absorbed_i)) begin
          // Clear internal variables, send done command, and return to idle.
          clr_appid = 1'b1;
          clear_after_error_o = prim_mubi_pkg::MuBi4True;
          service_rejected_error_clr = 1'b1;
          cmd_o = CmdDone;
          st_d = StIdle;
          // If error originated from SW, report 'absorbed' to SW.
          if (err_during_sw_q) begin
            absorbed_o = prim_mubi_pkg::MuBi4True;
          end
        end
      end

      StErrorServiceRejected: begin
        // Clear internal variables and return to idle.
        clr_appid = 1'b1;
        clear_after_error_o = prim_mubi_pkg::MuBi4True;
        service_rejected_error_clr = 1'b1;
        st_d = StIdle;
      end

      StTerminalError: begin
        // this state is terminal
        st_d = st;
        sparse_fsm_error_o = 1'b 1;
        fsm_err.valid = 1'b 1;
        fsm_err.code = ErrFatalError;
        fsm_err.info = 24'(app_id);
      end

      default: begin
        st_d = StTerminalError;
        sparse_fsm_error_o = 1'b 1;
      end
    endcase

    // SEC_CM: FSM.GLOBAL_ESC, FSM.LOCAL_ESC
    // Unconditionally jump into the terminal error state
    // if the life cycle controller triggers an escalation.
    if (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) begin
      st_d = StTerminalError;
    end

    // Handle errors outside the terminal error state.
    if (st_d != StTerminalError) begin
      // Key from keymgr is used but not valid, so abort into the invalid key error state.
      if (keymgr_key_used && !keymgr_key_i.valid) begin
        st_d = StKeyMgrErrKeyNotValid;
      end
    end
  end

  // Track errors occurring in SW mode.
  assign err_during_sw_d =
      (mux_sel == SelSw) && (st_d inside {StError, StKeyMgrErrKeyNotValid}) ? 1'b1 : // set
      (st_d == StIdle)                                                      ? 1'b0 : // clear
      err_during_sw_q;                                                               // hold

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      err_during_sw_q <= 1'b0;
    end else begin
      err_during_sw_q <= err_during_sw_d;
    end
  end

  //////////////
  // Datapath //
  //////////////

  // Encoded output length
  assign encoded_outlen      = EncodedOutLen[SelDigSize];
  assign encoded_outlen_mask = EncodedOutLenMask[SelKeySize];

  // Data mux
  // This is the main part of the KeyMgr interface logic.
  // The FSM selects KeyMgr interface in a cycle after it receives the first
  // valid data from KeyMgr. The ready signal to the KeyMgr data interface
  // represents the MSG_FIFO ready, only when it is in StKeyMgrMsg state.
  // After KeyMgr sends last beat, the kmac interface (to MSG_FIFO) is switched
  // to OutLen. OutLen is pre-defined values. See `EncodeOutLen` parameter above.
  always_comb begin
    app_data_ready = 1'b 0;
    sw_ready_o = 1'b 1;

    kmac_valid_o = 1'b 0;
    kmac_data_o = '0;
    kmac_mask_o = '0;

    unique case (mux_sel_buf_kmac)
      SelApp: begin
        // app_id is valid at this time
        kmac_valid_o = app_i[app_id].valid;
        kmac_data_o  = app_i[app_id].data;
        // Expand strb to bits. prim_packer inside MSG_FIFO accepts the bit masks
        for (int i = 0 ; i < $bits(app_i[app_id].strb) ; i++) begin
          kmac_mask_o[8*i+:8] = {8{app_i[app_id].strb[i]}};
        end
        app_data_ready = kmac_ready_i;
      end

      SelOutLen: begin
        // Write encoded output length value
        kmac_valid_o = 1'b 1; // always write
        kmac_data_o  = MsgWidth'(encoded_outlen);
        kmac_mask_o  = MsgWidth'(encoded_outlen_mask);
      end

      SelSw: begin
        kmac_valid_o = sw_valid_i;
        kmac_data_o  = sw_data_i ;
        kmac_mask_o  = sw_mask_i ;
        sw_ready_o   = kmac_ready_i ;
      end

      default: begin // Incl. SelNone
        kmac_valid_o = 1'b 0;
        kmac_data_o = '0;
        kmac_mask_o = '0;
      end

    endcase
  end

  // Error checking for Mux
  always_comb begin
    mux_err = '{valid: 1'b 0, code: ErrNone, info: '0};

    if (mux_sel_buf_err_check != SelSw && sw_valid_i) begin
      // If SW writes message into FIFO
      mux_err = '{
        valid: 1'b 1,
        code: ErrSwPushedMsgFifo,
        info: 24'({8'h 00, 8'(st), 8'(mux_sel_buf_err_check)})
      };
    end else if (app_active_o && sw_cmd_i != CmdNone) begin
      // If SW issues command except start
      mux_err = '{
        valid: 1'b 1,
        code: ErrSwIssuedCmdInAppActive,
        info: 24'(sw_cmd_i)
      };
    end
  end

  logic [AppMuxWidth-1:0] mux_sel_buf_output_logic;
  assign mux_sel_buf_output = app_mux_sel_e'(mux_sel_buf_output_logic);

  // SEC_CM: LOGIC.INTEGRITY
  prim_sec_anchor_buf #(
   .Width(AppMuxWidth)
  ) u_prim_buf_state_output_sel (
    .in_i(mux_sel),
    .out_o(mux_sel_buf_output_logic)
  );

  logic [AppMuxWidth-1:0] mux_sel_buf_err_check_logic;
  assign mux_sel_buf_err_check = app_mux_sel_e'(mux_sel_buf_err_check_logic);

  // SEC_CM: LOGIC.INTEGRITY
  prim_sec_anchor_buf #(
   .Width(AppMuxWidth)
  ) u_prim_buf_state_err_check (
    .in_i(mux_sel),
    .out_o(mux_sel_buf_err_check_logic)
  );

  logic [AppMuxWidth-1:0] mux_sel_buf_kmac_logic;
  assign mux_sel_buf_kmac = app_mux_sel_e'(mux_sel_buf_kmac_logic);

  // SEC_CM: LOGIC.INTEGRITY
  prim_sec_anchor_buf #(
   .Width(AppMuxWidth)
  ) u_prim_buf_state_kmac_sel (
    .in_i(mux_sel),
    .out_o(mux_sel_buf_kmac_logic)
  );

  // SEC_CM: LOGIC.INTEGRITY
  logic reg_state_valid;
  prim_sec_anchor_buf #(
   .Width(1)
  ) u_prim_buf_state_output_valid (
    .in_i(reg_state_valid),
    .out_o(reg_state_valid_o)
  );

  // Keccak state Demux
  // Keccak state --> Register output is enabled when state is in StSw
  always_comb begin
    reg_state_valid = 1'b 0;
    reg_state_o = '{default:'0};
    if ((mux_sel_buf_output == SelSw) &&
         lc_ctrl_pkg::lc_tx_test_false_strict(lc_escalate_en_i)) begin
      reg_state_valid = keccak_state_valid_i;
      reg_state_o = keccak_state_i;
      // If key is sideloaded and KMAC is SW initiated
      // hide the capacity from SW by zeroing (see #17508)
      if (keymgr_key_en_i) begin
        for (int i = 0; i < Share; i++) begin
          unique case (reg_keccak_strength_i)
            L128: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L128]] = '0;
            L224: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L224]] = '0;
            L256: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L256]] = '0;
            L384: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L384]] = '0;
            L512: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L512]] = '0;
            default: reg_state_o[i] = '0;
          endcase
        end
      end
    end
  end

  // Keccak state --> KeyMgr
  always_comb begin
    app_digest_done = 1'b 0;
    app_digest = '{default:'0};
    if (st == StAppWait && prim_mubi_pkg::mubi4_test_true_strict(absorbed_i) &&
       lc_ctrl_pkg::lc_tx_test_false_strict(lc_escalate_en_i)) begin
      // SHA3 engine has calculated the hash. Return the data to KeyMgr
      app_digest_done = 1'b 1;

      // digest has always 2 entries. If !EnMasking, second is tied to 0.
      for (int i = 0 ; i < Share ; i++) begin
        // Return the portion of state.
        app_digest[i] = keccak_state_i[i][AppDigestW-1:0];
      end
    end
  end


  // Secret Key Mux

  // Prepare merged key if EnMasking is not set.
  // Combine share keys into unpacked array for logic below to assign easily.
  // SEC_CM: KEY.SIDELOAD
  logic [MaxKeyLen-1:0] keymgr_key [Share];
  if (EnMasking == 1) begin : g_masked_key
    for (genvar i = 0; i < Share; i++) begin : gen_key_pad
      assign keymgr_key[i] =  {(MaxKeyLen-KeyMgrKeyW)'(0), keymgr_key_i.key[i]};
    end
  end else begin : g_unmasked_key
    always_comb begin
      keymgr_key[0] = '0;
      for (int i = 0; i < keymgr_pkg::Shares; i++) begin
        keymgr_key[0][KeyMgrKeyW-1:0] ^= keymgr_key_i.key[i];
      end
    end
  end

  // Sideloaded key manage: Keep use sideloaded key for KMAC AppIntf until the
  // hashing operation is finished.
  always_comb begin
    keymgr_key_used = 1'b0;
    key_len_o  = reg_key_len_i;
    for (int i = 0 ; i < Share; i++) begin
      key_data_o[i] = reg_key_data_i[i];
    end
    // The key is considered invalid in all cases that are not listed below (which includes idle and
    // error states).
    key_valid_o = 1'b0;

    unique case (st)
      StAppCfg, StAppMsg, StAppOutLen, StAppProcess, StAppWait: begin
        // Key from keymgr is actually used if the current HW app interface does *keyed* MAC.
        keymgr_key_used = AppCfg[app_id].Mode == AppKMAC;
        key_len_o = SideloadedKey;
        for (int i = 0 ; i < Share; i++) begin
          key_data_o[i] = keymgr_key[i];
        end
        // Key is valid if the current HW app interface does *keyed* MAC and the key provided by
        // keymgr is valid.
        key_valid_o = keymgr_key_used && keymgr_key_i.valid;
      end

      StSw: begin
        if (keymgr_key_en_i) begin
          // Key from keymgr is actually used if *keyed* MAC is enabled.
          keymgr_key_used = kmac_en_o;
          key_len_o = SideloadedKey;
          for (int i = 0 ; i < Share; i++) begin
            key_data_o[i] = keymgr_key[i];
          end
        end
        // Key is valid if SW does *keyed* MAC and ...
        if (kmac_en_o) begin
          if (!keymgr_key_en_i) begin
            // ... it uses the key from kmac's CSR, or ...
            key_valid_o = 1'b1;
          end else begin
            // ... it uses the key provided by keymgr and that one is valid.
            key_valid_o = keymgr_key_i.valid;
          end
        end
      end

      default: ;
    endcase
  end

  // Prefix Demux
  // For SW, always prefix register.
  // For App intf, check PrefixMode cfg and if 1, use Prefix cfg.
  always_comb begin
    sha3_prefix_o = '0;

    unique case (st)
      StAppCfg, StAppMsg, StAppOutLen, StAppProcess, StAppWait: begin
        // Check app intf cfg
        for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
          if (app_id == i) begin
            if (AppCfg[i].PrefixMode == 1'b 0) begin
              sha3_prefix_o = reg_prefix_i;
            end else begin
              sha3_prefix_o = AppCfg[i].Prefix;
            end
          end
        end
      end

      StSw: begin
        sha3_prefix_o = reg_prefix_i;
      end

      default: begin
        sha3_prefix_o = reg_prefix_i;
      end
    endcase
  end

  // KMAC en / SHA3 mode / Strength
  //  by default, it uses reg cfg. When app intf reqs come, it uses AppCfg.
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      kmac_en_o         <= 1'b 0;
      sha3_mode_o       <= sha3_pkg::Sha3;
      keccak_strength_o <= sha3_pkg::L256;
    end else if (clr_appid) begin
      // As App completed, latch reg value
      kmac_en_o         <= reg_kmac_en_i;
      sha3_mode_o       <= reg_sha3_mode_i;
      keccak_strength_o <= reg_keccak_strength_i;
    end else if (set_appid) begin
      kmac_en_o         <= AppCfg[arb_idx].Mode == AppKMAC ? 1'b 1 : 1'b 0;
      sha3_mode_o       <= AppCfg[arb_idx].Mode == AppSHA3
                           ? sha3_pkg::Sha3 : sha3_pkg::CShake;
      keccak_strength_o <= AppCfg[arb_idx].Strength ;
    end else if (st == StIdle) begin
      kmac_en_o         <= reg_kmac_en_i;
      sha3_mode_o       <= reg_sha3_mode_i;
      keccak_strength_o <= reg_keccak_strength_i;
    end
  end

  // Status
  assign app_active_o = (st inside {StAppCfg, StAppMsg, StAppOutLen,
                                    StAppProcess, StAppWait});

  // Error Reporting ==========================================================
  always_comb begin
    priority casez ({fsm_err.valid, mux_err.valid})
      2'b ?1: error_o = mux_err;
      2'b 10: error_o = fsm_err;
      default: error_o = '{valid: 1'b0, code: ErrNone, info: '0};
    endcase
  end

  ////////////////
  // Assertions //
  ////////////////

  // KeyMgr sideload key and the digest should be in the Key Length value
  `ASSERT_INIT(SideloadKeySameToDigest_A, KeyMgrKeyW <= AppDigestW)
  `ASSERT_INIT(AppIntfInRange_A, AppDigestW inside {128, 192, 256, 384, 512})

  // Issue(#13655): Having a coverage that sideload keylen and CSR keylen are
  // different.
  `COVER(AppIntfUseDifferentSizeKey_C,
    (st == StAppCfg && kmac_en_o) |-> reg_key_len_i != SideloadedKey)

endmodule


    """


    Identify the CWE relevant to the security issue for the given RTL.
    Obtain details of the CWE.

    Then determine if there are security issues relevant to the identified CWE in the RTL.
    Refer to the code that corresponds to the issues identified.
    
================================== Ai Message ==================================

[{'text': "I'll analyze the RTL code for security concerns related to application interface isolation, privilege escalation, and command injection. Let me first identify relevant CWEs for these security issues.", 'type': 'text'}, {'id': 'toolu_01VcM8tQJweLGeQMuc1KeZz1', 'input': {'security_issue': 'application interface isolation'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01VcM8tQJweLGeQMuc1KeZz1)
 Call ID: toolu_01VcM8tQJweLGeQMuc1KeZz1
  Args:
    security_issue: application interface isolation
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1423: Exposure of Sensitive Information caused by Shared Microarchitectural Predictor State that Influences Transient Execution
Shared microarchitectural predictor state may allow code to influence transient execution across a hardware boundary, potentially exposing data that is accessible beyond the boundary over a covert channel.
Many commodity processors have Instruction Set Architecture (ISA) features that protect software components from one another. These features can include memory segmentation, virtual memory, privilege rings, trusted execution environments, and virtual machines, among others. For example, virtual memory provides each process with its own address space, which prevents processes from accessing each other's private data. Many of these features can be used to form hardware-enforced security boundaries between software components.
Example 1
Branch Target Injection (BTI) is a vulnerability that can allow an SMT hardware thread to maliciously train the indirect branch predictor state that is shared with its sibling hardware thread. A cross-thread BTI attack requires the attacker to find a vulnerable code sequence within the victim software. For example, the authors of identified the following code sequence in the Windows library ntdll.dll:
(bad code)
Example Language: x86 Assembly
adc edi,dword ptr [ebx+edx+13BE13BDh] adc dl,byte ptr [edi] ... indirect_branch_site: jmp dword ptr [rsi] # at this point attacker knows edx, controls edi and ebx
To successfully exploit this code sequence to disclose the victim's private data, the attacker must also be able to find an indirect branch site within the victim, where the attacker controls the values in edi and ebx, and the attacker knows the value in edx as shown above at the indirect branch site. A proof-of-concept cross-thread BTI attack might proceed as follows: The attacker thread and victim thread must be co-scheduled on the same physical processor core. The attacker thread must train the shared branch predictor so that when the victim thread reaches indirect_branch_site, the jmp instruction will be predicted to target example_code_sequence instead of the correct architectural target. The training procedure may vary by processor, and the attacker may need to reverse-engineer the branch predictor to identify a suitable training algorithm. This step assumes that the attacker can control some values in the victim program, specifically the values in edi and ebx at indirect_branch_site. When the victim reaches indirect_branch_site the processor will (mis)predict example_code_sequence as the target and (transiently) execute the adc instructions. If the attacker chooses ebx so that `ebx = m 0x13BE13BD - edx, then the first adc will load 32 bits from address m in the victim's address space and add *m (the data loaded from) to the attacker-controlled base address in edi. The second adc instruction accesses a location in memory whose address corresponds to *m`. The adversary uses a covert channel analysis technique such as Flush+Reload ([REF-1416]) to infer the value of the victim's private data *m.

Example 2
BTI can also allow software in one execution context to maliciously train branch predictor entries that can be used in another context. For example, on some processors user-mode software may be able to train predictor entries that can also be used after transitioning into kernel mode, such as after invoking a system call. This vulnerability does not necessarily require SMT and may instead be performed in synchronous steps, though it does require the attacker to find an exploitable code sequence in the victim's code, for example, in the kernel.


================================== Ai Message ==================================

[{'id': 'toolu_01SGn37Cw1WCTHuZEVbfBym2', 'input': {'security_issue': 'privilege escalation'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01SGn37Cw1WCTHuZEVbfBym2)
 Call ID: toolu_01SGn37Cw1WCTHuZEVbfBym2
  Args:
    security_issue: privilege escalation
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1268: Policy Privileges are not Assigned Consistently Between Control and Data Agents
The product's hardware-enforced access control for a particular resource improperly accounts for privilege discrepancies between control and write policies.
Integrated circuits and hardware engines may provide access to resources (device-configuration, encryption keys, etc.) belonging to trusted firmware or software modules (commonly set by a BIOS or a bootloader). These accesses are typically controlled and limited by the hardware. Hardware design access control is sometimes implemented using a policy. A policy defines which entity or agent may or may not be allowed to perform an action. When a system implements multiple levels of policies, a control policy may allow direct access to a resource as well as changes to the policies themselves.
Example 1
Consider a system of seven registers for storing and configuring an AES key for encryption or decryption. Four 32-bit registers are used to store a 128-bit AES key. The names of those registers are AES_ENC_DEC_KEY_0, AES_ENC_DEC_KEY_1, AES_ENC_DEC_KEY_2, and AES_ENC_DEC_KEY_3. Collectively these are referred to as the AES Key registers. RegisterField description AES_ENC_DEC_KEY_0AES key [0:31] for encryption or decryption Default 0x00000000 AES_ENC_DEC_KEY_1AES key [32:63] for encryption or decryption Default 0x00000000 AES_ENC_DEC_KEY_2AES key [64:95] for encryption or decryption Default 0x00000000 AES_ENC_DEC_KEY_3AES key [96:127] for encryption or decryption Default 0x00000000 Three 32-bit registers are used to define access control for the AES-key registers. The names of those registers are AES_KEY_CONTROL_POLICY, AES_KEY_READ_POLICY, and AES_KEY_WRITE_POLICY. Collectively these registers are referred to as the Policy registers, and their functions are explained next. The AES_KEY_CONTROL_POLICY register defines which agents can write to the AES_KEY_READ_POLICY or AES_KEY_WRITE_POLICY registers. The AES_KEY_READ_POLICY register defines which agents can read the AES-key registers. The AES_KEY_WRITE_POLICY register defines which agents can write the AES key registers. The preceding three policy registers encode access control at the bit level. Therefore a maximum of 32 agents can be defined (1 bit per agent). The value of the bit when set (i.e., "1") allows the respective action from an agent whose identity corresponds to the number of the bit. If clear (i.e., "0"), it disallows the respective action to that corresponding agent. For example, if bit 0 is set to "1" in the AES_KEY_READ_POLICY register, then agent 0 has permission to read the AES-key registers. Consider that there are 4 agents named Agent 1, Agent 2, Agent 3, and Agent 4. For access control purposes Agent 1 is assigned to bit 1, Agent 2 to bit 2, Agent 3 to bit 3, and Agent 4 to bit 4. All agents are trusted except for Agent 3 who is untrusted. Also consider the register values in the below table.
(bad code)
RegisterField description AES_KEY_CONTROL_POLICYControls which agents can write to READ_POLICY and WRITE_POLICY registers [31:0] Default 0x00000018 AES_KEY_READ_POLICYControls which agents can read the AES-key registers [31:0] Default 0x00000002 AES_KEY_WRITE_POLICYControls which agents can write to the AES-key registers [31:0] Default 0x00000004
IThe AES_KEY_CONTROL_POLICY register value is 0x00000018. In binary, the lower 8 bits will be 0001 1000, meaning that: Bits 3 and 4 are set, thus Agents 3 and 4 will have write access to AES_KEY_READ_POLICY or AES_KEY_WRITE_POLICY. All other bits are clear, hence agents other than 3 and 4 will not have access to write to AES_KEY_READ_POLICY or AES_KEY_WRITE_POLICY. The AES_KEY_READ_POLICY register value is 0x00000002. In binary, the lower 8 bits will be 0000 0010, meaning that: Bit 1 is set, thus Agent 1 will be able to read the AES key registers. The AES_KEY_WRITE_POLICY register value is 0x00000004. In binary, the lower 8 bits will be 0000 0100, meaning that: Bit 2 is set, thus Agent 2 will be able to write the AES Key registers. The configured access control policy for Agents 1,2,3,4 is summarized in table below. AgentReadWriteControl Agent 1AllowedNot AllowedNot Allowed Agent 2Not AllowedAllowedNot Allowed Agent 3Not AllowedNot AllowedAllowed Agent 4Not AllowedNot AllowedAllowed At this point Agents 3 and 4 can only configure which agents can read AES keys and which agents can write AES keys. Agents 3 and 4 cannot read or write AES keys - just configure access control. Now, recall Agent 3 is untrusted. As explained above, the value of the AES_KEY_CONTROL_POLICY register gives agent 3 access to write to the AES_KEY_WRITE_POLICY register. Agent 3 can use this write access to add themselves to the AES_KEY_WRITE_POLICY register. This is accomplished by Agent 3 writing the value 0x00000006. In binary, the lower 8 bits are 0000 0110, meaning that bit 3 will be set. Thus, giving Agent 3 having the ability to write to the AES Key registers. If the AES_KEY_CONTROL_POLICY register value is 0x00000010, the lower 8 bits will be 0001 0000. This will give Agent 4, a trusted agent, write access to AES_KEY_WRITE_POLICY, but Agent 3, who is untrusted, will not have write access. The Policy register values should therefore be as follows:
(good code)
RegisterField description AES_KEY_CONTROL_POLICY[31:0] Default 0x00000010 AES_KEY_READ_POLICY[31:0] Default 0x00000002 AES_KEY_WRITE_POLICY[31:0] Default 0x00000004


================================== Ai Message ==================================

[{'id': 'toolu_01UzSBe3jgB5ziRsc9qt8kmG', 'input': {'security_issue': 'command injection'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01UzSBe3jgB5ziRsc9qt8kmG)
 Call ID: toolu_01UzSBe3jgB5ziRsc9qt8kmG
  Args:
    security_issue: command injection
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Failed to execute. Error: AttributeError("'NoneType' object has no attribute 'group'")
AttributeError: 'NoneType' object has no attribute 'group'
Traceback (most recent call last):
  File "/home/XXXX-2/security_agents/security_agents.py", line 1086, in llm_cwe_details_retriever_tool
    r = df_cwes_details[df_cwes_details['name']==match.group(0)]
                                                 ^^^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'group'
================================== Ai Message ==================================

[{'text': 'Let me try a more specific query for command injection:', 'type': 'text'}, {'id': 'toolu_01FoeR7wevd6D4UPkGFJQnc8', 'input': {'security_issue': 'hardware command injection'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01FoeR7wevd6D4UPkGFJQnc8)
 Call ID: toolu_01FoeR7wevd6D4UPkGFJQnc8
  Args:
    security_issue: hardware command injection
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

[{"text": "Let me try a more specific query for command injection:", "type": "text"}, {"id": "toolu_01FoeR7wevd6D4UPkGFJQnc8", "input": {"security_issue": "hardware command injection"}, "name": "llm_cwe_details_retriever_tool", "type": "tool_use"}]
================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_R5tlLK3U6faDYKLALujbOi40)
 Call ID: call_R5tlLK3U6faDYKLALujbOi40
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // KMAC Application interface
6: 
7: `include "prim_assert.sv"
8: 
9: module kmac_app
10:   import kmac_pkg::*;
11: #(
12:   // App specific configs are defined in kmac_pkg
13:   parameter  bit EnMasking = 1'b0,
14:   localparam int Share = (EnMasking) ? 2 : 1, // derived parameter
15:   parameter  bit SecIdleAcceptSwMsg = 1'b0
16: ) (
17:   input clk_i,
18:   input rst_ni,
19: 
20:   // Secret Key from register
21:   input [MaxKeyLen-1:0] reg_key_data_i [Share],
22:   input key_len_e       reg_key_len_i,
23: 
24:   // Prefix from register
25:   input [sha3_pkg::NSRegisterSize*8-1:0] reg_prefix_i,
26: 
27:   // mode, strength, kmac_en from register
28:   input                             reg_kmac_en_i,
29:   input sha3_pkg::sha3_mode_e       reg_sha3_mode_i,
30:   input sha3_pkg::keccak_strength_e reg_keccak_strength_i,
31: 
32:   // Data from Software
33:   input                sw_valid_i,
34:   input [MsgWidth-1:0] sw_data_i,
35:   input [MsgWidth-1:0] sw_mask_i,
36:   output logic         sw_ready_o,
37: 
38:   // KeyMgr Sideload Key interface
39:   input keymgr_pkg::hw_key_req_t keymgr_key_i,
40: 
41:   // Application Message in/ Digest out interface + control signals
42:   input  app_req_t [NumAppIntf-1:0] app_i,
43:   output app_rsp_t [NumAppIntf-1:0] app_o,
44: 
45:   // to KMAC Core: Secret key
46:   output logic [MaxKeyLen-1:0] key_data_o [Share],
47:   output key_len_e             key_len_o,
48:   output logic                 key_valid_o,
49: 
50:   // to MSG_FIFO
51:   output logic                kmac_valid_o,
52:   output logic [MsgWidth-1:0] kmac_data_o,
53:   output logic [MsgWidth-1:0] kmac_mask_o,
54:   input                       kmac_ready_i,
55: 
56:   // KMAC Core
57:   output logic kmac_en_o,
58: 
59:   // To Sha3 Core
60:   output logic [sha3_pkg::NSRegisterSize*8-1:0] sha3_prefix_o,
61:   output sha3_pkg::sha3_mode_e                  sha3_mode_o,
62:   output sha3_pkg::keccak_strength_e            keccak_strength_o,
63: 
64:   // STATE from SHA3 Core
65:   input                        keccak_state_valid_i,
66:   input [sha3_pkg::StateW-1:0] keccak_state_i [Share],
67: 
68:   // to STATE TL-window if Application is not active, the incoming state goes to
69:   // register if kdf_en is set, the state value goes to application and the
70:   // output to the register is all zero.
71:   output logic                        reg_state_valid_o,
72:   output logic [sha3_pkg::StateW-1:0] reg_state_o [Share],
73: 
74:   // Configurations If key_en is set, the logic uses KeyMgr's sideloaded key as
75:   // a secret key rather than register values. This only affects when software
76:   // initiates. If App initiates the hash operation and uses KMAC algorithm, it
77:   // always uses sideloaded key.
78:   input keymgr_key_en_i,
79: 
80:   // Commands
81:   // Command from software
82:   input kmac_cmd_e sw_cmd_i,
83: 
84:   // from SHA3
85:   input prim_mubi_pkg::mubi4_t absorbed_i,
86: 
87:   // to KMAC
88:   output kmac_cmd_e cmd_o,
89: 
90:   // to SW
91:   output prim_mubi_pkg::mubi4_t absorbed_o,
92: 
93:   // To status
94:   output logic app_active_o,
95: 
96:   // Status
97:   // - entropy_ready_i: Entropy configured by SW. It is used to check if App
98:   //                    is OK to request.
99:   input prim_mubi_pkg::mubi4_t entropy_ready_i,
100: 
101:   // Error input
102:   // This error comes from KMAC/SHA3 engine.
103:   // KeyMgr interface delivers the error signal to KeyMgr to drop the current op
104:   // and re-initiate.
105:   // If error happens, regardless of SW-initiated or KeyMgr-initiated, the error
106:   // is reported to the ERR_CODE so that SW can look into.
107:   input error_i,
108: 
109:   // SW sets err_processed bit in CTRL then the logic goes to Idle
110:   input err_processed_i,
111: 
112:   output prim_mubi_pkg::mubi4_t clear_after_error_o,
113: 
114:   // error_o value is pushed to Error FIFO at KMAC/SHA3 top and reported to SW
115:   output kmac_pkg::err_t error_o,
116: 
117:   // Life cycle
118:   input  lc_ctrl_pkg::lc_tx_t lc_escalate_en_i,
119: 
120:   output logic sparse_fsm_error_o
121: );
122: 
123:   import sha3_pkg::KeccakBitCapacity;
124:   import sha3_pkg::L128;
125:   import sha3_pkg::L224;
126:   import sha3_pkg::L256;
127:   import sha3_pkg::L384;
128:   import sha3_pkg::L512;
129: 
130:   /////////////////
131:   // Definitions //
132:   /////////////////
133: 
134:   // Digest width is same to the key width `keymgr_pkg::KeyWidth`.
135:   localparam int KeyMgrKeyW = $bits(keymgr_key_i.key[0]);
136: 
137:   localparam key_len_e KeyLengths [5] = '{Key128, Key192, Key256, Key384, Key512};
138: 
139:   localparam int SelKeySize = (AppKeyW == 128) ? 0 :
140:                               (AppKeyW == 192) ? 1 :
141:                               (AppKeyW == 256) ? 2 :
142:                               (AppKeyW == 384) ? 3 :
143:                               (AppKeyW == 512) ? 4 : 0 ;
144:   localparam int SelDigSize = (AppDigestW == 128) ? 0 :
145:                               (AppDigestW == 192) ? 1 :
146:                               (AppDigestW == 256) ? 2 :
147:                               (AppDigestW == 384) ? 3 :
148:                               (AppDigestW == 512) ? 4 : 0 ;
149:   localparam key_len_e SideloadedKey = KeyLengths[SelKeySize];
150: 
151:   // Define right_encode(outlen) value here
152:   // Look at kmac_pkg::key_len_e for the kinds of key size
153:   //
154:   // These values should be exactly the same as the key length encodings
155:   // in kmac_core.sv, with the only difference being that the byte representing
156:   // the byte-length of the encoded value is in the MSB position due to right encoding
157:   // instead of in the LSB position (left encoding).
158:   localparam int OutLenW = 24;
159:   localparam logic [OutLenW-1:0] EncodedOutLen [5]= '{
160:     24'h 0001_80, // Key128
161:     24'h 0001_C0, // Key192
162:     24'h 02_0001, // Key256
163:     24'h 02_8001, // Key384
164:     24'h 02_0002  // Key512
165:   };
166: 
167:   localparam logic [OutLenW-1:0] EncodedOutLenMask [5] = '{
168:     24'h 00FFFF, // Key128,
169:     24'h 00FFFF, // Key192
170:     24'h FFFFFF, // Key256
171:     24'h FFFFFF, // Key384
172:     24'h FFFFFF  // Key512
173:   };
174: 
175:   // Encoding generated with:
176:   // $ ./util/design/sparse-fsm-encode.py -d 3 -m 14 -n 10 \
177:   //     -s 2454278799 --language=sv
178:   //
179:   // Hamming distance histogram:
180:   //
181:   //  0: --
182:   //  1: --
183:   //  2: --
184:   //  3: |||||||||| (14.29%)
185:   //  4: |||||||||||||||||||| (27.47%)
186:   //  5: ||||||||||||| (18.68%)
187:   //  6: |||||||||||||||| (21.98%)
188:   //  7: |||||||| (10.99%)
189:   //  8: |||| (6.59%)
190:   //  9: --
191:   // 10: --
192:   //
193:   // Minimum Hamming distance: 3
194:   // Maximum Hamming distance: 8
195:   // Minimum Hamming weight: 3
196:   // Maximum Hamming weight: 8
197:   //
198:   localparam int StateWidth = 10;
199:   typedef enum logic [StateWidth-1:0] {
200:     StIdle = 10'b1010111110,
201: 
202:     // Application operation.
203:     //
204:     // if start request comes from an App first, until the operation ends by the
205:     // requested App, all operations are granted to the specific App. SW
206:     // requests and other Apps requests will be ignored.
207:     //
208:     // App interface does not have control signals. When first data valid occurs
209:     // from an App, this logic asserts the start command to the downstream. When
210:     // last beat pulse comes, this logic asserts the process to downstream
211:     // (after the transaction is accepted regardless of partial writes or not)
212:     // When absorbed by SHA3 core, the logic sends digest to the requested App
213:     // and right next cycle, it triggers done command to downstream.
214: 
215:     // In StAppCfg state, it latches the cfg from AppCfg parameter to determine
216:     // the kmac_mode, sha3_mode, keccak strength.
217:     StAppCfg = 10'b1010101101,
218: 
219:     StAppMsg = 10'b1110001011,
220: 
221:     // In StKeyOutLen, this module pushes encoded outlen to the MSG_FIFO.
222:     // Assume the length is 256 bit, the data will be 48'h 02_0100
223:     StAppOutLen  = 10'b1010011000,
224:     StAppProcess = 10'b1110110010,
225:     StAppWait    = 10'b1001010000,
226: 
227:     // SW Controlled
228:     // If start request comes from SW first, until the operation ends, all
229:     // requests from KeyMgr will be discarded.
230:     StSw = 10'b0010111011,
231: 
232:     // Error KeyNotValid
233:     // When KeyMgr operates, the secret key is not ready yet.
234:     StKeyMgrErrKeyNotValid = 10'b0111011111,
235: 
236:     StError = 10'b1110010111,
237:     StErrorAwaitSw = 10'b0110001100,
238:     StErrorAwaitApp = 10'b1011100000,
239:     StErrorWaitAbsorbed = 10'b0010100100,
240:     StErrorServiceRejected = 10'b1101000111,
241: 
242:     // This state is used for terminal errors
243:     StTerminalError = 10'b0101110110
244:   } st_e;
245: 
246:   /////////////
247:   // Signals //
248:   /////////////
249: 
250:   st_e st, st_d;
251: 
252:   logic keymgr_key_used;
253: 
254:   // app_rsp_t signals
255:   // The state machine controls mux selection, which controls the ready signal
256:   // the other responses are controled in separate logic. So define the signals
257:   // here and merge them to the response.
258:   logic app_data_ready, fsm_data_ready;
259:   logic app_digest_done, fsm_digest_done_q, fsm_digest_done_d;
260:   logic [AppDigestW-1:0] app_digest [2];
261: 
262:   // One more slot for value NumAppIntf. It is the value when no app intf is
263:   // chosen.
264:   localparam int unsigned AppIdxW = $clog2(NumAppIntf);
265: 
266:   // app_id indicates, which app interface was chosen. various logic use this
267:   // value to get the config or return the data.
268:   logic [AppIdxW-1:0] app_id, app_id_d;
269:   logic               clr_appid, set_appid;
270: 
271:   // Output length
272:   logic [OutLenW-1:0] encoded_outlen, encoded_outlen_mask;
273: 
274:   // state output
275:   // Mux selection signal
276:   app_mux_sel_e mux_sel;
277:   app_mux_sel_e mux_sel_buf_output;
278:   app_mux_sel_e mux_sel_buf_err_check;
279:   app_mux_sel_e mux_sel_buf_kmac;
280: 
281:   // Error checking logic
282: 
283:   kmac_pkg::err_t fsm_err, mux_err;
284: 
285:   logic service_rejected_error;
286:   logic service_rejected_error_set, service_rejected_error_clr;
287:   logic err_during_sw_d, err_during_sw_q;
288: 
289:   always_ff @(posedge clk_i or negedge rst_ni) begin
290:     if (!rst_ni)                         service_rejected_error <= 1'b 0;
291:     else if (service_rejected_error_set) service_rejected_error <= 1'b 1;
292:     else if (service_rejected_error_clr) service_rejected_error <= 1'b 0;
293:   end
294: 
295:   ////////////////////////////
296:   // Application Mux/ Demux //
297:   ////////////////////////////
298: 
299: 
300:   // Processing return data.
301:   // sends to only selected app intf.
302:   // clear digest right after done to not leak info to other interface
303:   always_comb begin
304:     for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
305:       if (i == app_id) begin
306:         app_o[i] = '{
307:           ready:         app_data_ready | fsm_data_ready,
308:           done:          app_digest_done | fsm_digest_done_q,
309:           digest_share0: app_digest[0],
310:           digest_share1: app_digest[1],
311:           // if fsm asserts done, should be an error case.
312:           error:         error_i | fsm_digest_done_q | sparse_fsm_error_o
313:                          | service_rejected_error
314:         };
315:       end else begin
316:         app_o[i] = '{
317:           ready: 1'b 0,
318:           done:  1'b 0,
319:           digest_share0: '0,
320:           digest_share1: '0,
321:           error: 1'b 0
322:         };
323:       end
324:     end // for {i, NumAppIntf, i++}
325:   end // aiways_comb
326: 
327:   // app_id latch
328:   always_ff @(posedge clk_i or negedge rst_ni) begin
329:     if (!rst_ni) app_id <= AppIdxW'(0) ; // Do not select any
330:     else if (clr_appid) app_id <= AppIdxW'(0);
331:     else if (set_appid) app_id <= app_id_d;
332:   end
333: 
334:   // app_id selection as of now, app_id uses Priority. The assumption is that
335:   //  the request normally does not collide. (ROM_CTRL activates very early
336:   //  stage at the boot sequence)
337:   //
338:   //  If this assumption is not true, consider RR arbiter.
339: 
340:   // Prep for arbiter
341:   logic [NumAppIntf-1:0] app_reqs;
342:   logic [NumAppIntf-1:0] unused_app_gnts;
343:   logic [$clog2(NumAppIntf)-1:0] arb_idx;
344:   logic arb_valid;
345:   logic arb_ready;
346: 
347:   always_comb begin
348:     app_reqs = '0;
349:     for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
350:       app_reqs[i] = app_i[i].valid;
351:     end
352:   end
353: 
354:   prim_arbiter_fixed #(
355:     .N (NumAppIntf),
356:     .DW(1),
357:     .EnDataPort(1'b 0)
358:   ) u_appid_arb (
359:     .clk_i,
360:     .rst_ni,
361: 
362:     .req_i  (app_reqs),
363:     .data_i ('{default:'0}),
364:     .gnt_o  (unused_app_gnts),
365:     .idx_o  (arb_idx),
366: 
367:     .valid_o (arb_valid),
368:     .data_o  (), // not used
369:     .ready_i (arb_ready)
370:   );
371: 
372:   assign app_id_d = AppIdxW'(arb_idx);
373:   assign arb_ready = set_appid;
374: 
375:   always_ff @(posedge clk_i or negedge rst_ni) begin
376:     if (!rst_ni) fsm_digest_done_q <= 1'b 0;
377:     else         fsm_digest_done_q <= fsm_digest_done_d;
378:   end
379: 
380:   /////////
381:   // FSM //
382:   /////////
383: 
384:   // State register
385:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, st_d, st, st_e, StIdle)
386: 
387:   // Create a lint error to reduce the risk of accidentally enabling this feature.
388:   `ASSERT_STATIC_LINT_ERROR(KmacSecIdleAcceptSwMsgNonDefault, SecIdleAcceptSwMsg == 0)
389: 
390:   // Next State & output logic
391:   // SEC_CM: FSM.SPARSE
392:   always_comb begin
393:     st_d = st;
394: 
395:     mux_sel = SecIdleAcceptSwMsg ? SelSw : SelNone;
396: 
397:     // app_id control
398:     set_appid = 1'b 0;
399:     clr_appid = 1'b 0;
400: 
401:     // Commands
402:     cmd_o = CmdNone;
403: 
404:     // Software output
405:     absorbed_o = prim_mubi_pkg::MuBi4False;
406: 
407:     // Error
408:     fsm_err = '{valid: 1'b 0, code: ErrNone, info: '0};
409:     sparse_fsm_error_o = 1'b 0;
410: 
411:     clear_after_error_o = prim_mubi_pkg::MuBi4False;
412: 
413:     service_rejected_error_set = 1'b 0;
414:     service_rejected_error_clr = 1'b 0;
415: 
416:     // If error happens, FSM asserts data ready but discard incoming msg
417:     fsm_data_ready = 1'b 0;
418:     fsm_digest_done_d = 1'b 0;
419: 
420:     unique case (st)
421:       StIdle: begin
422:         if (arb_valid) begin
423:           st_d = StAppCfg;
424: 
425:           // choose app_id
426:           set_appid = 1'b 1;
427:         end else if (sw_cmd_i == CmdStart) begin
428:           st_d = StSw;
429:           // Software initiates the sequence
430:           cmd_o = CmdStart;
431:         end else begin
432:           st_d = StIdle;
433:         end
434:       end
435: 
436:       StAppCfg: begin
437:         if (AppCfg[app_id].Mode == AppKMAC &&
438:           prim_mubi_pkg::mubi4_test_false_strict(entropy_ready_i)) begin
439:           // Check if the entropy is not configured but it is needed in
440:           // `AppCfg[app_id]` (KMAC mode).
441:           //
442:           // SW is not properly configured, report and not request Hashing
443:           // Return the app with errors
444:           st_d = StError;
445: 
446:           service_rejected_error_set = 1'b 1;
447: 
448:         end else begin
449:           // As Cfg is stable now, it sends cmd
450:           st_d = StAppMsg;
451: 
452:           // App initiates the data
453:           cmd_o = CmdStart;
454:         end
455:       end
456: 
457:       StAppMsg: begin
458:         mux_sel = SelApp;
459:         if (app_i[app_id].valid && app_o[app_id].ready && app_i[app_id].last) begin
460:           if (AppCfg[app_id].Mode == AppKMAC) begin
461:             st_d = StAppOutLen;
462:           end else begin
463:             st_d = StAppProcess;
464:           end
465:         end else begin
466:           st_d = StAppMsg;
467:         end
468:       end
469: 
470:       StAppOutLen: begin
471:         mux_sel = SelOutLen;
472: 
473:         if (kmac_valid_o && kmac_ready_i) begin
474:           st_d = StAppProcess;
475:         end else begin
476:           st_d = StAppOutLen;
477:         end
478:       end
479: 
480:       StAppProcess: begin
481:         cmd_o = CmdProcess;
482:         st_d = StAppWait;
483:       end
484: 
485:       StAppWait: begin
486:         if (prim_mubi_pkg::mubi4_test_true_strict(absorbed_i)) begin
487:           // Send digest to KeyMgr and complete the op
488:           st_d = StIdle;
489:           cmd_o = CmdDone;
490: 
491:           clr_appid = 1'b 1;
492:         end else begin
493:           st_d = StAppWait;
494:         end
495:       end
496: 
497:       StSw: begin
498:         mux_sel = SelSw;
499: 
500:         cmd_o = sw_cmd_i;
501:         absorbed_o = absorbed_i;
502: 
503:         if (sw_cmd_i == CmdDone) begin
504:           st_d = StIdle;
505:         end else begin
506:           st_d = StSw;
507:         end
508:       end
509: 
510:       StKeyMgrErrKeyNotValid: begin
511:         st_d = StError;
512: 
513:         // As mux_sel is not set to SelApp, app_data_ready is still 0.
514:         // This logic won't accept the requests from the selected App.
515:         fsm_err.valid = 1'b 1;
516:         fsm_err.code = ErrKeyNotValid;
517:         fsm_err.info = 24'(app_id);
518:       end
519: 
520:       StError: begin
521:         // In this state, the state machine flush out the request
522:         st_d = StError;
523: 
524:         // Absorb data on the app interface.
525:         fsm_data_ready = ~err_during_sw_q;
526: 
527:         // Next step depends on two conditions:
528:         // 1) Error being processed by SW
529:         // 2) Last data provided from the app interface (so that the app interface is completely)
530:         //    drained.  If the error occurred during a SW operation, the app interface is not
531:         //    involved, so this condition gets skipped.
532:         unique case ({err_processed_i,
533:                       (app_i[app_id].valid && app_i[app_id].last) || err_during_sw_q})
534:           2'b00: begin
535:             // Error not processed by SW and not last data from app interface -> keep current state.
536:             st_d = StError;
537:           end
538:           2'b01: begin
539:             // Error not processed by SW but last data from app interface:
540:             // 1. Send garbage digest to the app interface (in the next cycle) to complete the
541:             // transaction.
542:             fsm_digest_done_d = ~err_during_sw_q;
543:             if (service_rejected_error) begin
544:               // 2.a) Service was rejected because an app interface tried to configure KMAC while no
545:               // entropy was available. It is assumed that SW is not loaded yet, so don't wait for
546:               // SW to process the error. The last data from the app interface has now arrived, but
547:               // we don't need to wait for the SHA3 core to have absorbed it because the data never
548:               // entered the SHA3 core: the request from the app interface was terminated during the
549:               // configuration phase.
550:               st_d = StErrorServiceRejected;
551:             end else begin
552:               // 2.b) If service was not rejected, wait for SW to process the error.
553:               st_d = StErrorAwaitSw;
554:             end
555:           end
556:           2'b10: begin
557:             // Error processed by SW but not last data from app interface -> wait for app interface.
558:             st_d = StErrorAwaitApp;
559:           end
560:           2'b11: begin
561:             // Error processed by SW and last data from app interface:
562:             // Send garbage digest to the app interface (in the next cycle) to complete the
563:             // transaction.
564:             fsm_digest_done_d = ~err_during_sw_q;
565:             // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
566:             // but serves to bring the SHA3 engine back to the idle state).
567:             cmd_o = CmdProcess;
568:             st_d = StErrorWaitAbsorbed;
569:           end
570:           default: st_d = StError;
571:         endcase
572:       end
573: 
574:       StErrorAwaitSw: begin
575:         // Just wait for SW to process the error.
576:         if (err_processed_i) begin
577:           // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
578:           // but serves to bring the SHA3 engine back to the idle state).
579:           cmd_o = CmdProcess;
580:           st_d = StErrorWaitAbsorbed;
581:         end
582:       end
583: 
584:       StErrorAwaitApp: begin
585:         // Keep absorbing data on the app interface until the last data.
586:         fsm_data_ready = 1'b1;
587:         if (app_i[app_id].valid && app_i[app_id].last) begin
588:           // Send garbage digest to the app interface (in the next cycle) to complete the
589:           // transaction.
590:           fsm_digest_done_d = 1'b1;
591:           // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
592:           // but serves to bring the SHA3 engine back to the idle state).
593:           cmd_o = CmdProcess;
594:           st_d = StErrorWaitAbsorbed;
595:         end
596:       end
597: 
598:       StErrorWaitAbsorbed: begin
599:         if (prim_mubi_pkg::mubi4_test_true_strict(absorbed_i)) begin
600:           // Clear internal variables, send done command, and return to idle.
601:           clr_appid = 1'b1;
602:           clear_after_error_o = prim_mubi_pkg::MuBi4True;
603:           service_rejected_error_clr = 1'b1;
604:           cmd_o = CmdDone;
605:           st_d = StIdle;
606:           // If error originated from SW, report 'absorbed' to SW.
607:           if (err_during_sw_q) begin
608:             absorbed_o = prim_mubi_pkg::MuBi4True;
609:           end
610:         end
611:       end
612: 
613:       StErrorServiceRejected: begin
614:         // Clear internal variables and return to idle.
615:         clr_appid = 1'b1;
616:         clear_after_error_o = prim_mubi_pkg::MuBi4True;
617:         service_rejected_error_clr = 1'b1;
618:         st_d = StIdle;
619:       end
620: 
621:       StTerminalError: begin
622:         // this state is terminal
623:         st_d = st;
624:         sparse_fsm_error_o = 1'b 1;
625:         fsm_err.valid = 1'b 1;
626:         fsm_err.code = ErrFatalError;
627:         fsm_err.info = 24'(app_id);
628:       end
629: 
630:       default: begin
631:         st_d = StTerminalError;
632:         sparse_fsm_error_o = 1'b 1;
633:       end
634:     endcase
635: 
636:     // SEC_CM: FSM.GLOBAL_ESC, FSM.LOCAL_ESC
637:     // Unconditionally jump into the terminal error state
638:     // if the life cycle controller triggers an escalation.
639:     if (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) begin
640:       st_d = StTerminalError;
641:     end
642: 
643:     // Handle errors outside the terminal error state.
644:     if (st_d != StTerminalError) begin
645:       // Key from keymgr is used but not valid, so abort into the invalid key error state.
646:       if (keymgr_key_used && !keymgr_key_i.valid) begin
647:         st_d = StKeyMgrErrKeyNotValid;
648:       end
649:     end
650:   end
651: 
652:   // Track errors occurring in SW mode.
653:   assign err_during_sw_d =
654:       (mux_sel == SelSw) && (st_d inside {StError, StKeyMgrErrKeyNotValid}) ? 1'b1 : // set
655:       (st_d == StIdle)                                                      ? 1'b0 : // clear
656:       err_during_sw_q;                                                               // hold
657: 
658:   always_ff @(posedge clk_i or negedge rst_ni) begin
659:     if (!rst_ni) begin
660:       err_during_sw_q <= 1'b0;
661:     end else begin
662:       err_during_sw_q <= err_during_sw_d;
663:     end
664:   end
665: 
666:   //////////////
667:   // Datapath //
668:   //////////////
669: 
670:   // Encoded output length
671:   assign encoded_outlen      = EncodedOutLen[SelDigSize];
672:   assign encoded_outlen_mask = EncodedOutLenMask[SelKeySize];
673: 
674:   // Data mux
675:   // This is the main part of the KeyMgr interface logic.
676:   // The FSM selects KeyMgr interface in a cycle after it receives the first
677:   // valid data from KeyMgr. The ready signal to the KeyMgr data interface
678:   // represents the MSG_FIFO ready, only when it is in StKeyMgrMsg state.
679:   // After KeyMgr sends last beat, the kmac interface (to MSG_FIFO) is switched
680:   // to OutLen. OutLen is pre-defined values. See `EncodeOutLen` parameter above.
681:   always_comb begin
682:     app_data_ready = 1'b 0;
683:     sw_ready_o = 1'b 1;
684: 
685:     kmac_valid_o = 1'b 0;
686:     kmac_data_o = '0;
687:     kmac_mask_o = '0;
688: 
689:     unique case (mux_sel_buf_kmac)
690:       SelApp: begin
691:         // app_id is valid at this time
692:         kmac_valid_o = app_i[app_id].valid;
693:         kmac_data_o  = app_i[app_id].data;
694:         // Expand strb to bits. prim_packer inside MSG_FIFO accepts the bit masks
695:         for (int i = 0 ; i < $bits(app_i[app_id].strb) ; i++) begin
696:           kmac_mask_o[8*i+:8] = {8{app_i[app_id].strb[i]}};
697:         end
698:         app_data_ready = kmac_ready_i;
699:       end
700: 
701:       SelOutLen: begin
702:         // Write encoded output length value
703:         kmac_valid_o = 1'b 1; // always write
704:         kmac_data_o  = MsgWidth'(encoded_outlen);
705:         kmac_mask_o  = MsgWidth'(encoded_outlen_mask);
706:       end
707: 
708:       SelSw: begin
709:         kmac_valid_o = sw_valid_i;
710:         kmac_data_o  = sw_data_i ;
711:         kmac_mask_o  = sw_mask_i ;
712:         sw_ready_o   = kmac_ready_i ;
713:       end
714: 
715:       default: begin // Incl. SelNone
716:         kmac_valid_o = 1'b 0;
717:         kmac_data_o = '0;
718:         kmac_mask_o = '0;
719:       end
720: 
721:     endcase
722:   end
723: 
724:   // Error checking for Mux
725:   always_comb begin
726:     mux_err = '{valid: 1'b 0, code: ErrNone, info: '0};
727: 
728:     if (mux_sel_buf_err_check != SelSw && sw_valid_i) begin
729:       // If SW writes message into FIFO
730:       mux_err = '{
731:         valid: 1'b 1,
732:         code: ErrSwPushedMsgFifo,
733:         info: 24'({8'h 00, 8'(st), 8'(mux_sel_buf_err_check)})
734:       };
735:     end else if (app_active_o && sw_cmd_i != CmdNone) begin
736:       // If SW issues command except start
737:       mux_err = '{
738:         valid: 1'b 1,
739:         code: ErrSwIssuedCmdInAppActive,
740:         info: 24'(sw_cmd_i)
741:       };
742:     end
743:   end
744: 
745:   logic [AppMuxWidth-1:0] mux_sel_buf_output_logic;
746:   assign mux_sel_buf_output = app_mux_sel_e'(mux_sel_buf_output_logic);
747: 
748:   // SEC_CM: LOGIC.INTEGRITY
749:   prim_sec_anchor_buf #(
750:    .Width(AppMuxWidth)
751:   ) u_prim_buf_state_output_sel (
752:     .in_i(mux_sel),
753:     .out_o(mux_sel_buf_output_logic)
754:   );
755: 
756:   logic [AppMuxWidth-1:0] mux_sel_buf_err_check_logic;
757:   assign mux_sel_buf_err_check = app_mux_sel_e'(mux_sel_buf_err_check_logic);
758: 
759:   // SEC_CM: LOGIC.INTEGRITY
760:   prim_sec_anchor_buf #(
761:    .Width(AppMuxWidth)
762:   ) u_prim_buf_state_err_check (
763:     .in_i(mux_sel),
764:     .out_o(mux_sel_buf_err_check_logic)
765:   );
766: 
767:   logic [AppMuxWidth-1:0] mux_sel_buf_kmac_logic;
768:   assign mux_sel_buf_kmac = app_mux_sel_e'(mux_sel_buf_kmac_logic);
769: 
770:   // SEC_CM: LOGIC.INTEGRITY
771:   prim_sec_anchor_buf #(
772:    .Width(AppMuxWidth)
773:   ) u_prim_buf_state_kmac_sel (
774:     .in_i(mux_sel),
775:     .out_o(mux_sel_buf_kmac_logic)
776:   );
777: 
778:   // SEC_CM: LOGIC.INTEGRITY
779:   logic reg_state_valid;
780:   prim_sec_anchor_buf #(
781:    .Width(1)
782:   ) u_prim_buf_state_output_valid (
783:     .in_i(reg_state_valid),
784:     .out_o(reg_state_valid_o)
785:   );
786: 
787:   // Keccak state Demux
788:   // Keccak state --> Register output is enabled when state is in StSw
789:   always_comb begin
790:     reg_state_valid = 1'b 0;
791:     reg_state_o = '{default:'0};
792:     if ((mux_sel_buf_output == SelSw) &&
793:          lc_ctrl_pkg::lc_tx_test_false_strict(lc_escalate_en_i)) begin
794:       reg_state_valid = keccak_state_valid_i;
795:       reg_state_o = keccak_state_i;
796:       // If key is sideloaded and KMAC is SW initiated
797:       // hide the capacity from SW by zeroing (see #17508)
798:       if (keymgr_key_en_i) begin
799:         for (int i = 0; i < Share; i++) begin
800:           unique case (reg_keccak_strength_i)
801:             L128: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L128]] = '0;
802:             L224: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L224]] = '0;
803:             L256: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L256]] = '0;
804:             L384: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L384]] = '0;
805:             L512: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L512]] = '0;
806:             default: reg_state_o[i] = '0;
807:           endcase
808:         end
809:       end
810:     end
811:   end
812: 
813:   // Keccak state --> KeyMgr
814:   always_comb begin
815:     app_digest_done = 1'b 0;
816:     app_digest = '{default:'0};
817:     if (st == StAppWait && prim_mubi_pkg::mubi4_test_true_strict(absorbed_i) &&
818:        lc_ctrl_pkg::lc_tx_test_false_strict(lc_escalate_en_i)) begin
819:       // SHA3 engine has calculated the hash. Return the data to KeyMgr
820:       app_digest_done = 1'b 1;
821: 
822:       // digest has always 2 entries. If !EnMasking, second is tied to 0.
823:       for (int i = 0 ; i < Share ; i++) begin
824:         // Return the portion of state.
825:         app_digest[i] = keccak_state_i[i][AppDigestW-1:0];
826:       end
827:     end
828:   end
829: 
830: 
831:   // Secret Key Mux
832: 
833:   // Prepare merged key if EnMasking is not set.
834:   // Combine share keys into unpacked array for logic below to assign easily.
835:   // SEC_CM: KEY.SIDELOAD
836:   logic [MaxKeyLen-1:0] keymgr_key [Share];
837:   if (EnMasking == 1) begin : g_masked_key
838:     for (genvar i = 0; i < Share; i++) begin : gen_key_pad
839:       assign keymgr_key[i] =  {(MaxKeyLen-KeyMgrKeyW)'(0), keymgr_key_i.key[i]};
840:     end
841:   end else begin : g_unmasked_key
842:     always_comb begin
843:       keymgr_key[0] = '0;
844:       for (int i = 0; i < keymgr_pkg::Shares; i++) begin
845:         keymgr_key[0][KeyMgrKeyW-1:0] ^= keymgr_key_i.key[i];
846:       end
847:     end
848:   end
849: 
850:   // Sideloaded key manage: Keep use sideloaded key for KMAC AppIntf until the
851:   // hashing operation is finished.
852:   always_comb begin
853:     keymgr_key_used = 1'b0;
854:     key_len_o  = reg_key_len_i;
855:     for (int i = 0 ; i < Share; i++) begin
856:       key_data_o[i] = reg_key_data_i[i];
857:     end
858:     // The key is considered invalid in all cases that are not listed below (which includes idle and
859:     // error states).
860:     key_valid_o = 1'b0;
861: 
862:     unique case (st)
863:       StAppCfg, StAppMsg, StAppOutLen, StAppProcess, StAppWait: begin
864:         // Key from keymgr is actually used if the current HW app interface does *keyed* MAC.
865:         keymgr_key_used = AppCfg[app_id].Mode == AppKMAC;
866:         key_len_o = SideloadedKey;
867:         for (int i = 0 ; i < Share; i++) begin
868:           key_data_o[i] = keymgr_key[i];
869:         end
870:         // Key is valid if the current HW app interface does *keyed* MAC and the key provided by
871:         // keymgr is valid.
872:         key_valid_o = keymgr_key_used && keymgr_key_i.valid;
873:       end
874: 
875:       StSw: begin
876:         if (keymgr_key_en_i) begin
877:           // Key from keymgr is actually used if *keyed* MAC is enabled.
878:           keymgr_key_used = kmac_en_o;
879:           key_len_o = SideloadedKey;
880:           for (int i = 0 ; i < Share; i++) begin
881:             key_data_o[i] = keymgr_key[i];
882:           end
883:         end
884:         // Key is valid if SW does *keyed* MAC and ...
885:         if (kmac_en_o) begin
886:           if (!keymgr_key_en_i) begin
887:             // ... it uses the key from kmac's CSR, or ...
888:             key_valid_o = 1'b1;
889:           end else begin
890:             // ... it uses the key provided by keymgr and that one is valid.
891:             key_valid_o = keymgr_key_i.valid;
892:           end
893:         end
894:       end
895: 
896:       default: ;
897:     endcase
898:   end
899: 
900:   // Prefix Demux
901:   // For SW, always prefix register.
902:   // For App intf, check PrefixMode cfg and if 1, use Prefix cfg.
903:   always_comb begin
904:     sha3_prefix_o = '0;
905: 
906:     unique case (st)
907:       StAppCfg, StAppMsg, StAppOutLen, StAppProcess, StAppWait: begin
908:         // Check app intf cfg
909:         for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
910:           if (app_id == i) begin
911:             if (AppCfg[i].PrefixMode == 1'b 0) begin
912:               sha3_prefix_o = reg_prefix_i;
913:             end else begin
914:               sha3_prefix_o = AppCfg[i].Prefix;
915:             end
916:           end
917:         end
918:       end
919: 
920:       StSw: begin
921:         sha3_prefix_o = reg_prefix_i;
922:       end
923: 
924:       default: begin
925:         sha3_prefix_o = reg_prefix_i;
926:       end
927:     endcase
928:   end
929: 
930:   // KMAC en / SHA3 mode / Strength
931:   //  by default, it uses reg cfg. When app intf reqs come, it uses AppCfg.
932:   always_ff @(posedge clk_i or negedge rst_ni) begin
933:     if (!rst_ni) begin
934:       kmac_en_o         <= 1'b 0;
935:       sha3_mode_o       <= sha3_pkg::Sha3;
936:       keccak_strength_o <= sha3_pkg::L256;
937:     end else if (clr_appid) begin
938:       // As App completed, latch reg value
939:       kmac_en_o         <= reg_kmac_en_i;
940:       sha3_mode_o       <= reg_sha3_mode_i;
941:       keccak_strength_o <= reg_keccak_strength_i;
942:     end else if (set_appid) begin
943:       kmac_en_o         <= AppCfg[arb_idx].Mode == AppKMAC ? 1'b 1 : 1'b 0;
944:       sha3_mode_o       <= AppCfg[arb_idx].Mode == AppSHA3
945:                            ? sha3_pkg::Sha3 : sha3_pkg::CShake;
946:       keccak_strength_o <= AppCfg[arb_idx].Strength ;
947:     end else if (st == StIdle) begin
948:       kmac_en_o         <= reg_kmac_en_i;
949:       sha3_mode_o       <= reg_sha3_mode_i;
950:       keccak_strength_o <= reg_keccak_strength_i;
951:     end
952:   end
953: 
954:   // Status
955:   assign app_active_o = (st inside {StAppCfg, StAppMsg, StAppOutLen,
956:                                     StAppProcess, StAppWait});
957: 
958:   // Error Reporting ==========================================================
959:   always_comb begin
960:     priority casez ({fsm_err.valid, mux_err.valid})
961:       2'b ?1: error_o = mux_err;
962:       2'b 10: error_o = fsm_err;
963:       default: error_o = '{valid: 1'b0, code: ErrNone, info: '0};
964:     endcase
965:   end
966: 
967:   ////////////////
968:   // Assertions //
969:   ////////////////
970: 
971:   // KeyMgr sideload key and the digest should be in the Key Length value
972:   `ASSERT_INIT(SideloadKeySameToDigest_A, KeyMgrKeyW <= AppDigestW)
973:   `ASSERT_INIT(AppIntfInRange_A, AppDigestW inside {128, 192, 256, 384, 512})
974: 
975:   // Issue(#13655): Having a coverage that sideload keylen and CSR keylen are
976:   // different.
977:   `COVER(AppIntfUseDifferentSizeKey_C,
978:     (st == StAppCfg && kmac_en_o) |-> reg_key_len_i != SideloadedKey)
979: 
980: endmodule

================================== Ai Message ==================================
Tool Calls:
  run_similar_bug_agent (call_gwG5uFBD42bLw3iUpunTc6hk)
 Call ID: call_gwG5uFBD42bLw3iUpunTc6hk
  Args:
    bug: if (mux_sel_buf_err_check != SelSw && sw_valid_i) begin
    file_path: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv
================================ Human Message =================================

This bug was previously found in another file of this design:
    if (mux_sel_buf_err_check != SelSw && sw_valid_i) begin
    
    Please check the RTL code in the file /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv for similar bugs.
================================ Human Message =================================

This bug was previously found in another file of this design:
    if (mux_sel_buf_err_check != SelSw && sw_valid_i) begin
    
    Please check the RTL code in the file /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv for similar bugs.
================================== Ai Message ==================================

[{'text': "I'll help you find similar bug instances in the specified file. I'll use the similar_bug_tool to search for lines that match the pattern you've described.", 'type': 'text'}, {'id': 'toolu_01Xr8Zew8u81eLUJKQDoH4LJ', 'input': {'bug': 'if (mux_sel_buf_err_check != SelSw && sw_valid_i) begin', 'ip_file': '/home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv'}, 'name': 'similar_bug_tool', 'type': 'tool_use'}]
Tool Calls:
  similar_bug_tool (toolu_01Xr8Zew8u81eLUJKQDoH4LJ)
 Call ID: toolu_01Xr8Zew8u81eLUJKQDoH4LJ
  Args:
    bug: if (mux_sel_buf_err_check != SelSw && sw_valid_i) begin
    ip_file: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv
================================= Tool Message =================================
Name: similar_bug_tool

Error: ValueError("'.out_o(mux_sel_buf_err_check_logic)\\n  );' is not in list")
 Please fix your mistakes.
================================= Tool Message =================================
Name: similar_bug_tool

Error: ValueError("'.out_o(mux_sel_buf_err_check_logic)\\n  );' is not in list")
 Please fix your mistakes.
================================== Ai Message ==================================

[{'text': 'I apologize for the error. Let me first read the file to understand its contents and then search for similar patterns.', 'type': 'text'}, {'id': 'toolu_01W9MVgccSS6xLCv3CoP3wrG', 'input': {'file_path': '/home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv'}, 'name': 'read_file_with_line_numbers', 'type': 'tool_use'}]
Tool Calls:
  read_file_with_line_numbers (toolu_01W9MVgccSS6xLCv3CoP3wrG)
 Call ID: toolu_01W9MVgccSS6xLCv3CoP3wrG
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // KMAC Application interface
6: 
7: `include "prim_assert.sv"
8: 
9: module kmac_app
10:   import kmac_pkg::*;
11: #(
12:   // App specific configs are defined in kmac_pkg
13:   parameter  bit EnMasking = 1'b0,
14:   localparam int Share = (EnMasking) ? 2 : 1, // derived parameter
15:   parameter  bit SecIdleAcceptSwMsg = 1'b0
16: ) (
17:   input clk_i,
18:   input rst_ni,
19: 
20:   // Secret Key from register
21:   input [MaxKeyLen-1:0] reg_key_data_i [Share],
22:   input key_len_e       reg_key_len_i,
23: 
24:   // Prefix from register
25:   input [sha3_pkg::NSRegisterSize*8-1:0] reg_prefix_i,
26: 
27:   // mode, strength, kmac_en from register
28:   input                             reg_kmac_en_i,
29:   input sha3_pkg::sha3_mode_e       reg_sha3_mode_i,
30:   input sha3_pkg::keccak_strength_e reg_keccak_strength_i,
31: 
32:   // Data from Software
33:   input                sw_valid_i,
34:   input [MsgWidth-1:0] sw_data_i,
35:   input [MsgWidth-1:0] sw_mask_i,
36:   output logic         sw_ready_o,
37: 
38:   // KeyMgr Sideload Key interface
39:   input keymgr_pkg::hw_key_req_t keymgr_key_i,
40: 
41:   // Application Message in/ Digest out interface + control signals
42:   input  app_req_t [NumAppIntf-1:0] app_i,
43:   output app_rsp_t [NumAppIntf-1:0] app_o,
44: 
45:   // to KMAC Core: Secret key
46:   output logic [MaxKeyLen-1:0] key_data_o [Share],
47:   output key_len_e             key_len_o,
48:   output logic                 key_valid_o,
49: 
50:   // to MSG_FIFO
51:   output logic                kmac_valid_o,
52:   output logic [MsgWidth-1:0] kmac_data_o,
53:   output logic [MsgWidth-1:0] kmac_mask_o,
54:   input                       kmac_ready_i,
55: 
56:   // KMAC Core
57:   output logic kmac_en_o,
58: 
59:   // To Sha3 Core
60:   output logic [sha3_pkg::NSRegisterSize*8-1:0] sha3_prefix_o,
61:   output sha3_pkg::sha3_mode_e                  sha3_mode_o,
62:   output sha3_pkg::keccak_strength_e            keccak_strength_o,
63: 
64:   // STATE from SHA3 Core
65:   input                        keccak_state_valid_i,
66:   input [sha3_pkg::StateW-1:0] keccak_state_i [Share],
67: 
68:   // to STATE TL-window if Application is not active, the incoming state goes to
69:   // register if kdf_en is set, the state value goes to application and the
70:   // output to the register is all zero.
71:   output logic                        reg_state_valid_o,
72:   output logic [sha3_pkg::StateW-1:0] reg_state_o [Share],
73: 
74:   // Configurations If key_en is set, the logic uses KeyMgr's sideloaded key as
75:   // a secret key rather than register values. This only affects when software
76:   // initiates. If App initiates the hash operation and uses KMAC algorithm, it
77:   // always uses sideloaded key.
78:   input keymgr_key_en_i,
79: 
80:   // Commands
81:   // Command from software
82:   input kmac_cmd_e sw_cmd_i,
83: 
84:   // from SHA3
85:   input prim_mubi_pkg::mubi4_t absorbed_i,
86: 
87:   // to KMAC
88:   output kmac_cmd_e cmd_o,
89: 
90:   // to SW
91:   output prim_mubi_pkg::mubi4_t absorbed_o,
92: 
93:   // To status
94:   output logic app_active_o,
95: 
96:   // Status
97:   // - entropy_ready_i: Entropy configured by SW. It is used to check if App
98:   //                    is OK to request.
99:   input prim_mubi_pkg::mubi4_t entropy_ready_i,
100: 
101:   // Error input
102:   // This error comes from KMAC/SHA3 engine.
103:   // KeyMgr interface delivers the error signal to KeyMgr to drop the current op
104:   // and re-initiate.
105:   // If error happens, regardless of SW-initiated or KeyMgr-initiated, the error
106:   // is reported to the ERR_CODE so that SW can look into.
107:   input error_i,
108: 
109:   // SW sets err_processed bit in CTRL then the logic goes to Idle
110:   input err_processed_i,
111: 
112:   output prim_mubi_pkg::mubi4_t clear_after_error_o,
113: 
114:   // error_o value is pushed to Error FIFO at KMAC/SHA3 top and reported to SW
115:   output kmac_pkg::err_t error_o,
116: 
117:   // Life cycle
118:   input  lc_ctrl_pkg::lc_tx_t lc_escalate_en_i,
119: 
120:   output logic sparse_fsm_error_o
121: );
122: 
123:   import sha3_pkg::KeccakBitCapacity;
124:   import sha3_pkg::L128;
125:   import sha3_pkg::L224;
126:   import sha3_pkg::L256;
127:   import sha3_pkg::L384;
128:   import sha3_pkg::L512;
129: 
130:   /////////////////
131:   // Definitions //
132:   /////////////////
133: 
134:   // Digest width is same to the key width `keymgr_pkg::KeyWidth`.
135:   localparam int KeyMgrKeyW = $bits(keymgr_key_i.key[0]);
136: 
137:   localparam key_len_e KeyLengths [5] = '{Key128, Key192, Key256, Key384, Key512};
138: 
139:   localparam int SelKeySize = (AppKeyW == 128) ? 0 :
140:                               (AppKeyW == 192) ? 1 :
141:                               (AppKeyW == 256) ? 2 :
142:                               (AppKeyW == 384) ? 3 :
143:                               (AppKeyW == 512) ? 4 : 0 ;
144:   localparam int SelDigSize = (AppDigestW == 128) ? 0 :
145:                               (AppDigestW == 192) ? 1 :
146:                               (AppDigestW == 256) ? 2 :
147:                               (AppDigestW == 384) ? 3 :
148:                               (AppDigestW == 512) ? 4 : 0 ;
149:   localparam key_len_e SideloadedKey = KeyLengths[SelKeySize];
150: 
151:   // Define right_encode(outlen) value here
152:   // Look at kmac_pkg::key_len_e for the kinds of key size
153:   //
154:   // These values should be exactly the same as the key length encodings
155:   // in kmac_core.sv, with the only difference being that the byte representing
156:   // the byte-length of the encoded value is in the MSB position due to right encoding
157:   // instead of in the LSB position (left encoding).
158:   localparam int OutLenW = 24;
159:   localparam logic [OutLenW-1:0] EncodedOutLen [5]= '{
160:     24'h 0001_80, // Key128
161:     24'h 0001_C0, // Key192
162:     24'h 02_0001, // Key256
163:     24'h 02_8001, // Key384
164:     24'h 02_0002  // Key512
165:   };
166: 
167:   localparam logic [OutLenW-1:0] EncodedOutLenMask [5] = '{
168:     24'h 00FFFF, // Key128,
169:     24'h 00FFFF, // Key192
170:     24'h FFFFFF, // Key256
171:     24'h FFFFFF, // Key384
172:     24'h FFFFFF  // Key512
173:   };
174: 
175:   // Encoding generated with:
176:   // $ ./util/design/sparse-fsm-encode.py -d 3 -m 14 -n 10 \
177:   //     -s 2454278799 --language=sv
178:   //
179:   // Hamming distance histogram:
180:   //
181:   //  0: --
182:   //  1: --
183:   //  2: --
184:   //  3: |||||||||| (14.29%)
185:   //  4: |||||||||||||||||||| (27.47%)
186:   //  5: ||||||||||||| (18.68%)
187:   //  6: |||||||||||||||| (21.98%)
188:   //  7: |||||||| (10.99%)
189:   //  8: |||| (6.59%)
190:   //  9: --
191:   // 10: --
192:   //
193:   // Minimum Hamming distance: 3
194:   // Maximum Hamming distance: 8
195:   // Minimum Hamming weight: 3
196:   // Maximum Hamming weight: 8
197:   //
198:   localparam int StateWidth = 10;
199:   typedef enum logic [StateWidth-1:0] {
200:     StIdle = 10'b1010111110,
201: 
202:     // Application operation.
203:     //
204:     // if start request comes from an App first, until the operation ends by the
205:     // requested App, all operations are granted to the specific App. SW
206:     // requests and other Apps requests will be ignored.
207:     //
208:     // App interface does not have control signals. When first data valid occurs
209:     // from an App, this logic asserts the start command to the downstream. When
210:     // last beat pulse comes, this logic asserts the process to downstream
211:     // (after the transaction is accepted regardless of partial writes or not)
212:     // When absorbed by SHA3 core, the logic sends digest to the requested App
213:     // and right next cycle, it triggers done command to downstream.
214: 
215:     // In StAppCfg state, it latches the cfg from AppCfg parameter to determine
216:     // the kmac_mode, sha3_mode, keccak strength.
217:     StAppCfg = 10'b1010101101,
218: 
219:     StAppMsg = 10'b1110001011,
220: 
221:     // In StKeyOutLen, this module pushes encoded outlen to the MSG_FIFO.
222:     // Assume the length is 256 bit, the data will be 48'h 02_0100
223:     StAppOutLen  = 10'b1010011000,
224:     StAppProcess = 10'b1110110010,
225:     StAppWait    = 10'b1001010000,
226: 
227:     // SW Controlled
228:     // If start request comes from SW first, until the operation ends, all
229:     // requests from KeyMgr will be discarded.
230:     StSw = 10'b0010111011,
231: 
232:     // Error KeyNotValid
233:     // When KeyMgr operates, the secret key is not ready yet.
234:     StKeyMgrErrKeyNotValid = 10'b0111011111,
235: 
236:     StError = 10'b1110010111,
237:     StErrorAwaitSw = 10'b0110001100,
238:     StErrorAwaitApp = 10'b1011100000,
239:     StErrorWaitAbsorbed = 10'b0010100100,
240:     StErrorServiceRejected = 10'b1101000111,
241: 
242:     // This state is used for terminal errors
243:     StTerminalError = 10'b0101110110
244:   } st_e;
245: 
246:   /////////////
247:   // Signals //
248:   /////////////
249: 
250:   st_e st, st_d;
251: 
252:   logic keymgr_key_used;
253: 
254:   // app_rsp_t signals
255:   // The state machine controls mux selection, which controls the ready signal
256:   // the other responses are controled in separate logic. So define the signals
257:   // here and merge them to the response.
258:   logic app_data_ready, fsm_data_ready;
259:   logic app_digest_done, fsm_digest_done_q, fsm_digest_done_d;
260:   logic [AppDigestW-1:0] app_digest [2];
261: 
262:   // One more slot for value NumAppIntf. It is the value when no app intf is
263:   // chosen.
264:   localparam int unsigned AppIdxW = $clog2(NumAppIntf);
265: 
266:   // app_id indicates, which app interface was chosen. various logic use this
267:   // value to get the config or return the data.
268:   logic [AppIdxW-1:0] app_id, app_id_d;
269:   logic               clr_appid, set_appid;
270: 
271:   // Output length
272:   logic [OutLenW-1:0] encoded_outlen, encoded_outlen_mask;
273: 
274:   // state output
275:   // Mux selection signal
276:   app_mux_sel_e mux_sel;
277:   app_mux_sel_e mux_sel_buf_output;
278:   app_mux_sel_e mux_sel_buf_err_check;
279:   app_mux_sel_e mux_sel_buf_kmac;
280: 
281:   // Error checking logic
282: 
283:   kmac_pkg::err_t fsm_err, mux_err;
284: 
285:   logic service_rejected_error;
286:   logic service_rejected_error_set, service_rejected_error_clr;
287:   logic err_during_sw_d, err_during_sw_q;
288: 
289:   always_ff @(posedge clk_i or negedge rst_ni) begin
290:     if (!rst_ni)                         service_rejected_error <= 1'b 0;
291:     else if (service_rejected_error_set) service_rejected_error <= 1'b 1;
292:     else if (service_rejected_error_clr) service_rejected_error <= 1'b 0;
293:   end
294: 
295:   ////////////////////////////
296:   // Application Mux/ Demux //
297:   ////////////////////////////
298: 
299: 
300:   // Processing return data.
301:   // sends to only selected app intf.
302:   // clear digest right after done to not leak info to other interface
303:   always_comb begin
304:     for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
305:       if (i == app_id) begin
306:         app_o[i] = '{
307:           ready:         app_data_ready | fsm_data_ready,
308:           done:          app_digest_done | fsm_digest_done_q,
309:           digest_share0: app_digest[0],
310:           digest_share1: app_digest[1],
311:           // if fsm asserts done, should be an error case.
312:           error:         error_i | fsm_digest_done_q | sparse_fsm_error_o
313:                          | service_rejected_error
314:         };
315:       end else begin
316:         app_o[i] = '{
317:           ready: 1'b 0,
318:           done:  1'b 0,
319:           digest_share0: '0,
320:           digest_share1: '0,
321:           error: 1'b 0
322:         };
323:       end
324:     end // for {i, NumAppIntf, i++}
325:   end // aiways_comb
326: 
327:   // app_id latch
328:   always_ff @(posedge clk_i or negedge rst_ni) begin
329:     if (!rst_ni) app_id <= AppIdxW'(0) ; // Do not select any
330:     else if (clr_appid) app_id <= AppIdxW'(0);
331:     else if (set_appid) app_id <= app_id_d;
332:   end
333: 
334:   // app_id selection as of now, app_id uses Priority. The assumption is that
335:   //  the request normally does not collide. (ROM_CTRL activates very early
336:   //  stage at the boot sequence)
337:   //
338:   //  If this assumption is not true, consider RR arbiter.
339: 
340:   // Prep for arbiter
341:   logic [NumAppIntf-1:0] app_reqs;
342:   logic [NumAppIntf-1:0] unused_app_gnts;
343:   logic [$clog2(NumAppIntf)-1:0] arb_idx;
344:   logic arb_valid;
345:   logic arb_ready;
346: 
347:   always_comb begin
348:     app_reqs = '0;
349:     for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
350:       app_reqs[i] = app_i[i].valid;
351:     end
352:   end
353: 
354:   prim_arbiter_fixed #(
355:     .N (NumAppIntf),
356:     .DW(1),
357:     .EnDataPort(1'b 0)
358:   ) u_appid_arb (
359:     .clk_i,
360:     .rst_ni,
361: 
362:     .req_i  (app_reqs),
363:     .data_i ('{default:'0}),
364:     .gnt_o  (unused_app_gnts),
365:     .idx_o  (arb_idx),
366: 
367:     .valid_o (arb_valid),
368:     .data_o  (), // not used
369:     .ready_i (arb_ready)
370:   );
371: 
372:   assign app_id_d = AppIdxW'(arb_idx);
373:   assign arb_ready = set_appid;
374: 
375:   always_ff @(posedge clk_i or negedge rst_ni) begin
376:     if (!rst_ni) fsm_digest_done_q <= 1'b 0;
377:     else         fsm_digest_done_q <= fsm_digest_done_d;
378:   end
379: 
380:   /////////
381:   // FSM //
382:   /////////
383: 
384:   // State register
385:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, st_d, st, st_e, StIdle)
386: 
387:   // Create a lint error to reduce the risk of accidentally enabling this feature.
388:   `ASSERT_STATIC_LINT_ERROR(KmacSecIdleAcceptSwMsgNonDefault, SecIdleAcceptSwMsg == 0)
389: 
390:   // Next State & output logic
391:   // SEC_CM: FSM.SPARSE
392:   always_comb begin
393:     st_d = st;
394: 
395:     mux_sel = SecIdleAcceptSwMsg ? SelSw : SelNone;
396: 
397:     // app_id control
398:     set_appid = 1'b 0;
399:     clr_appid = 1'b 0;
400: 
401:     // Commands
402:     cmd_o = CmdNone;
403: 
404:     // Software output
405:     absorbed_o = prim_mubi_pkg::MuBi4False;
406: 
407:     // Error
408:     fsm_err = '{valid: 1'b 0, code: ErrNone, info: '0};
409:     sparse_fsm_error_o = 1'b 0;
410: 
411:     clear_after_error_o = prim_mubi_pkg::MuBi4False;
412: 
413:     service_rejected_error_set = 1'b 0;
414:     service_rejected_error_clr = 1'b 0;
415: 
416:     // If error happens, FSM asserts data ready but discard incoming msg
417:     fsm_data_ready = 1'b 0;
418:     fsm_digest_done_d = 1'b 0;
419: 
420:     unique case (st)
421:       StIdle: begin
422:         if (arb_valid) begin
423:           st_d = StAppCfg;
424: 
425:           // choose app_id
426:           set_appid = 1'b 1;
427:         end else if (sw_cmd_i == CmdStart) begin
428:           st_d = StSw;
429:           // Software initiates the sequence
430:           cmd_o = CmdStart;
431:         end else begin
432:           st_d = StIdle;
433:         end
434:       end
435: 
436:       StAppCfg: begin
437:         if (AppCfg[app_id].Mode == AppKMAC &&
438:           prim_mubi_pkg::mubi4_test_false_strict(entropy_ready_i)) begin
439:           // Check if the entropy is not configured but it is needed in
440:           // `AppCfg[app_id]` (KMAC mode).
441:           //
442:           // SW is not properly configured, report and not request Hashing
443:           // Return the app with errors
444:           st_d = StError;
445: 
446:           service_rejected_error_set = 1'b 1;
447: 
448:         end else begin
449:           // As Cfg is stable now, it sends cmd
450:           st_d = StAppMsg;
451: 
452:           // App initiates the data
453:           cmd_o = CmdStart;
454:         end
455:       end
456: 
457:       StAppMsg: begin
458:         mux_sel = SelApp;
459:         if (app_i[app_id].valid && app_o[app_id].ready && app_i[app_id].last) begin
460:           if (AppCfg[app_id].Mode == AppKMAC) begin
461:             st_d = StAppOutLen;
462:           end else begin
463:             st_d = StAppProcess;
464:           end
465:         end else begin
466:           st_d = StAppMsg;
467:         end
468:       end
469: 
470:       StAppOutLen: begin
471:         mux_sel = SelOutLen;
472: 
473:         if (kmac_valid_o && kmac_ready_i) begin
474:           st_d = StAppProcess;
475:         end else begin
476:           st_d = StAppOutLen;
477:         end
478:       end
479: 
480:       StAppProcess: begin
481:         cmd_o = CmdProcess;
482:         st_d = StAppWait;
483:       end
484: 
485:       StAppWait: begin
486:         if (prim_mubi_pkg::mubi4_test_true_strict(absorbed_i)) begin
487:           // Send digest to KeyMgr and complete the op
488:           st_d = StIdle;
489:           cmd_o = CmdDone;
490: 
491:           clr_appid = 1'b 1;
492:         end else begin
493:           st_d = StAppWait;
494:         end
495:       end
496: 
497:       StSw: begin
498:         mux_sel = SelSw;
499: 
500:         cmd_o = sw_cmd_i;
501:         absorbed_o = absorbed_i;
502: 
503:         if (sw_cmd_i == CmdDone) begin
504:           st_d = StIdle;
505:         end else begin
506:           st_d = StSw;
507:         end
508:       end
509: 
510:       StKeyMgrErrKeyNotValid: begin
511:         st_d = StError;
512: 
513:         // As mux_sel is not set to SelApp, app_data_ready is still 0.
514:         // This logic won't accept the requests from the selected App.
515:         fsm_err.valid = 1'b 1;
516:         fsm_err.code = ErrKeyNotValid;
517:         fsm_err.info = 24'(app_id);
518:       end
519: 
520:       StError: begin
521:         // In this state, the state machine flush out the request
522:         st_d = StError;
523: 
524:         // Absorb data on the app interface.
525:         fsm_data_ready = ~err_during_sw_q;
526: 
527:         // Next step depends on two conditions:
528:         // 1) Error being processed by SW
529:         // 2) Last data provided from the app interface (so that the app interface is completely)
530:         //    drained.  If the error occurred during a SW operation, the app interface is not
531:         //    involved, so this condition gets skipped.
532:         unique case ({err_processed_i,
533:                       (app_i[app_id].valid && app_i[app_id].last) || err_during_sw_q})
534:           2'b00: begin
535:             // Error not processed by SW and not last data from app interface -> keep current state.
536:             st_d = StError;
537:           end
538:           2'b01: begin
539:             // Error not processed by SW but last data from app interface:
540:             // 1. Send garbage digest to the app interface (in the next cycle) to complete the
541:             // transaction.
542:             fsm_digest_done_d = ~err_during_sw_q;
543:             if (service_rejected_error) begin
544:               // 2.a) Service was rejected because an app interface tried to configure KMAC while no
545:               // entropy was available. It is assumed that SW is not loaded yet, so don't wait for
546:               // SW to process the error. The last data from the app interface has now arrived, but
547:               // we don't need to wait for the SHA3 core to have absorbed it because the data never
548:               // entered the SHA3 core: the request from the app interface was terminated during the
549:               // configuration phase.
550:               st_d = StErrorServiceRejected;
551:             end else begin
552:               // 2.b) If service was not rejected, wait for SW to process the error.
553:               st_d = StErrorAwaitSw;
554:             end
555:           end
556:           2'b10: begin
557:             // Error processed by SW but not last data from app interface -> wait for app interface.
558:             st_d = StErrorAwaitApp;
559:           end
560:           2'b11: begin
561:             // Error processed by SW and last data from app interface:
562:             // Send garbage digest to the app interface (in the next cycle) to complete the
563:             // transaction.
564:             fsm_digest_done_d = ~err_during_sw_q;
565:             // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
566:             // but serves to bring the SHA3 engine back to the idle state).
567:             cmd_o = CmdProcess;
568:             st_d = StErrorWaitAbsorbed;
569:           end
570:           default: st_d = StError;
571:         endcase
572:       end
573: 
574:       StErrorAwaitSw: begin
575:         // Just wait for SW to process the error.
576:         if (err_processed_i) begin
577:           // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
578:           // but serves to bring the SHA3 engine back to the idle state).
579:           cmd_o = CmdProcess;
580:           st_d = StErrorWaitAbsorbed;
581:         end
582:       end
583: 
584:       StErrorAwaitApp: begin
585:         // Keep absorbing data on the app interface until the last data.
586:         fsm_data_ready = 1'b1;
587:         if (app_i[app_id].valid && app_i[app_id].last) begin
588:           // Send garbage digest to the app interface (in the next cycle) to complete the
589:           // transaction.
590:           fsm_digest_done_d = 1'b1;
591:           // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
592:           // but serves to bring the SHA3 engine back to the idle state).
593:           cmd_o = CmdProcess;
594:           st_d = StErrorWaitAbsorbed;
595:         end
596:       end
597: 
598:       StErrorWaitAbsorbed: begin
599:         if (prim_mubi_pkg::mubi4_test_true_strict(absorbed_i)) begin
600:           // Clear internal variables, send done command, and return to idle.
601:           clr_appid = 1'b1;
602:           clear_after_error_o = prim_mubi_pkg::MuBi4True;
603:           service_rejected_error_clr = 1'b1;
604:           cmd_o = CmdDone;
605:           st_d = StIdle;
606:           // If error originated from SW, report 'absorbed' to SW.
607:           if (err_during_sw_q) begin
608:             absorbed_o = prim_mubi_pkg::MuBi4True;
609:           end
610:         end
611:       end
612: 
613:       StErrorServiceRejected: begin
614:         // Clear internal variables and return to idle.
615:         clr_appid = 1'b1;
616:         clear_after_error_o = prim_mubi_pkg::MuBi4True;
617:         service_rejected_error_clr = 1'b1;
618:         st_d = StIdle;
619:       end
620: 
621:       StTerminalError: begin
622:         // this state is terminal
623:         st_d = st;
624:         sparse_fsm_error_o = 1'b 1;
625:         fsm_err.valid = 1'b 1;
626:         fsm_err.code = ErrFatalError;
627:         fsm_err.info = 24'(app_id);
628:       end
629: 
630:       default: begin
631:         st_d = StTerminalError;
632:         sparse_fsm_error_o = 1'b 1;
633:       end
634:     endcase
635: 
636:     // SEC_CM: FSM.GLOBAL_ESC, FSM.LOCAL_ESC
637:     // Unconditionally jump into the terminal error state
638:     // if the life cycle controller triggers an escalation.
639:     if (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) begin
640:       st_d = StTerminalError;
641:     end
642: 
643:     // Handle errors outside the terminal error state.
644:     if (st_d != StTerminalError) begin
645:       // Key from keymgr is used but not valid, so abort into the invalid key error state.
646:       if (keymgr_key_used && !keymgr_key_i.valid) begin
647:         st_d = StKeyMgrErrKeyNotValid;
648:       end
649:     end
650:   end
651: 
652:   // Track errors occurring in SW mode.
653:   assign err_during_sw_d =
654:       (mux_sel == SelSw) && (st_d inside {StError, StKeyMgrErrKeyNotValid}) ? 1'b1 : // set
655:       (st_d == StIdle)                                                      ? 1'b0 : // clear
656:       err_during_sw_q;                                                               // hold
657: 
658:   always_ff @(posedge clk_i or negedge rst_ni) begin
659:     if (!rst_ni) begin
660:       err_during_sw_q <= 1'b0;
661:     end else begin
662:       err_during_sw_q <= err_during_sw_d;
663:     end
664:   end
665: 
666:   //////////////
667:   // Datapath //
668:   //////////////
669: 
670:   // Encoded output length
671:   assign encoded_outlen      = EncodedOutLen[SelDigSize];
672:   assign encoded_outlen_mask = EncodedOutLenMask[SelKeySize];
673: 
674:   // Data mux
675:   // This is the main part of the KeyMgr interface logic.
676:   // The FSM selects KeyMgr interface in a cycle after it receives the first
677:   // valid data from KeyMgr. The ready signal to the KeyMgr data interface
678:   // represents the MSG_FIFO ready, only when it is in StKeyMgrMsg state.
679:   // After KeyMgr sends last beat, the kmac interface (to MSG_FIFO) is switched
680:   // to OutLen. OutLen is pre-defined values. See `EncodeOutLen` parameter above.
681:   always_comb begin
682:     app_data_ready = 1'b 0;
683:     sw_ready_o = 1'b 1;
684: 
685:     kmac_valid_o = 1'b 0;
686:     kmac_data_o = '0;
687:     kmac_mask_o = '0;
688: 
689:     unique case (mux_sel_buf_kmac)
690:       SelApp: begin
691:         // app_id is valid at this time
692:         kmac_valid_o = app_i[app_id].valid;
693:         kmac_data_o  = app_i[app_id].data;
694:         // Expand strb to bits. prim_packer inside MSG_FIFO accepts the bit masks
695:         for (int i = 0 ; i < $bits(app_i[app_id].strb) ; i++) begin
696:           kmac_mask_o[8*i+:8] = {8{app_i[app_id].strb[i]}};
697:         end
698:         app_data_ready = kmac_ready_i;
699:       end
700: 
701:       SelOutLen: begin
702:         // Write encoded output length value
703:         kmac_valid_o = 1'b 1; // always write
704:         kmac_data_o  = MsgWidth'(encoded_outlen);
705:         kmac_mask_o  = MsgWidth'(encoded_outlen_mask);
706:       end
707: 
708:       SelSw: begin
709:         kmac_valid_o = sw_valid_i;
710:         kmac_data_o  = sw_data_i ;
711:         kmac_mask_o  = sw_mask_i ;
712:         sw_ready_o   = kmac_ready_i ;
713:       end
714: 
715:       default: begin // Incl. SelNone
716:         kmac_valid_o = 1'b 0;
717:         kmac_data_o = '0;
718:         kmac_mask_o = '0;
719:       end
720: 
721:     endcase
722:   end
723: 
724:   // Error checking for Mux
725:   always_comb begin
726:     mux_err = '{valid: 1'b 0, code: ErrNone, info: '0};
727: 
728:     if (mux_sel_buf_err_check != SelSw && sw_valid_i) begin
729:       // If SW writes message into FIFO
730:       mux_err = '{
731:         valid: 1'b 1,
732:         code: ErrSwPushedMsgFifo,
733:         info: 24'({8'h 00, 8'(st), 8'(mux_sel_buf_err_check)})
734:       };
735:     end else if (app_active_o && sw_cmd_i != CmdNone) begin
736:       // If SW issues command except start
737:       mux_err = '{
738:         valid: 1'b 1,
739:         code: ErrSwIssuedCmdInAppActive,
740:         info: 24'(sw_cmd_i)
741:       };
742:     end
743:   end
744: 
745:   logic [AppMuxWidth-1:0] mux_sel_buf_output_logic;
746:   assign mux_sel_buf_output = app_mux_sel_e'(mux_sel_buf_output_logic);
747: 
748:   // SEC_CM: LOGIC.INTEGRITY
749:   prim_sec_anchor_buf #(
750:    .Width(AppMuxWidth)
751:   ) u_prim_buf_state_output_sel (
752:     .in_i(mux_sel),
753:     .out_o(mux_sel_buf_output_logic)
754:   );
755: 
756:   logic [AppMuxWidth-1:0] mux_sel_buf_err_check_logic;
757:   assign mux_sel_buf_err_check = app_mux_sel_e'(mux_sel_buf_err_check_logic);
758: 
759:   // SEC_CM: LOGIC.INTEGRITY
760:   prim_sec_anchor_buf #(
761:    .Width(AppMuxWidth)
762:   ) u_prim_buf_state_err_check (
763:     .in_i(mux_sel),
764:     .out_o(mux_sel_buf_err_check_logic)
765:   );
766: 
767:   logic [AppMuxWidth-1:0] mux_sel_buf_kmac_logic;
768:   assign mux_sel_buf_kmac = app_mux_sel_e'(mux_sel_buf_kmac_logic);
769: 
770:   // SEC_CM: LOGIC.INTEGRITY
771:   prim_sec_anchor_buf #(
772:    .Width(AppMuxWidth)
773:   ) u_prim_buf_state_kmac_sel (
774:     .in_i(mux_sel),
775:     .out_o(mux_sel_buf_kmac_logic)
776:   );
777: 
778:   // SEC_CM: LOGIC.INTEGRITY
779:   logic reg_state_valid;
780:   prim_sec_anchor_buf #(
781:    .Width(1)
782:   ) u_prim_buf_state_output_valid (
783:     .in_i(reg_state_valid),
784:     .out_o(reg_state_valid_o)
785:   );
786: 
787:   // Keccak state Demux
788:   // Keccak state --> Register output is enabled when state is in StSw
789:   always_comb begin
790:     reg_state_valid = 1'b 0;
791:     reg_state_o = '{default:'0};
792:     if ((mux_sel_buf_output == SelSw) &&
793:          lc_ctrl_pkg::lc_tx_test_false_strict(lc_escalate_en_i)) begin
794:       reg_state_valid = keccak_state_valid_i;
795:       reg_state_o = keccak_state_i;
796:       // If key is sideloaded and KMAC is SW initiated
797:       // hide the capacity from SW by zeroing (see #17508)
798:       if (keymgr_key_en_i) begin
799:         for (int i = 0; i < Share; i++) begin
800:           unique case (reg_keccak_strength_i)
801:             L128: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L128]] = '0;
802:             L224: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L224]] = '0;
803:             L256: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L256]] = '0;
804:             L384: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L384]] = '0;
805:             L512: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L512]] = '0;
806:             default: reg_state_o[i] = '0;
807:           endcase
808:         end
809:       end
810:     end
811:   end
812: 
813:   // Keccak state --> KeyMgr
814:   always_comb begin
815:     app_digest_done = 1'b 0;
816:     app_digest = '{default:'0};
817:     if (st == StAppWait && prim_mubi_pkg::mubi4_test_true_strict(absorbed_i) &&
818:        lc_ctrl_pkg::lc_tx_test_false_strict(lc_escalate_en_i)) begin
819:       // SHA3 engine has calculated the hash. Return the data to KeyMgr
820:       app_digest_done = 1'b 1;
821: 
822:       // digest has always 2 entries. If !EnMasking, second is tied to 0.
823:       for (int i = 0 ; i < Share ; i++) begin
824:         // Return the portion of state.
825:         app_digest[i] = keccak_state_i[i][AppDigestW-1:0];
826:       end
827:     end
828:   end
829: 
830: 
831:   // Secret Key Mux
832: 
833:   // Prepare merged key if EnMasking is not set.
834:   // Combine share keys into unpacked array for logic below to assign easily.
835:   // SEC_CM: KEY.SIDELOAD
836:   logic [MaxKeyLen-1:0] keymgr_key [Share];
837:   if (EnMasking == 1) begin : g_masked_key
838:     for (genvar i = 0; i < Share; i++) begin : gen_key_pad
839:       assign keymgr_key[i] =  {(MaxKeyLen-KeyMgrKeyW)'(0), keymgr_key_i.key[i]};
840:     end
841:   end else begin : g_unmasked_key
842:     always_comb begin
843:       keymgr_key[0] = '0;
844:       for (int i = 0; i < keymgr_pkg::Shares; i++) begin
845:         keymgr_key[0][KeyMgrKeyW-1:0] ^= keymgr_key_i.key[i];
846:       end
847:     end
848:   end
849: 
850:   // Sideloaded key manage: Keep use sideloaded key for KMAC AppIntf until the
851:   // hashing operation is finished.
852:   always_comb begin
853:     keymgr_key_used = 1'b0;
854:     key_len_o  = reg_key_len_i;
855:     for (int i = 0 ; i < Share; i++) begin
856:       key_data_o[i] = reg_key_data_i[i];
857:     end
858:     // The key is considered invalid in all cases that are not listed below (which includes idle and
859:     // error states).
860:     key_valid_o = 1'b0;
861: 
862:     unique case (st)
863:       StAppCfg, StAppMsg, StAppOutLen, StAppProcess, StAppWait: begin
864:         // Key from keymgr is actually used if the current HW app interface does *keyed* MAC.
865:         keymgr_key_used = AppCfg[app_id].Mode == AppKMAC;
866:         key_len_o = SideloadedKey;
867:         for (int i = 0 ; i < Share; i++) begin
868:           key_data_o[i] = keymgr_key[i];
869:         end
870:         // Key is valid if the current HW app interface does *keyed* MAC and the key provided by
871:         // keymgr is valid.
872:         key_valid_o = keymgr_key_used && keymgr_key_i.valid;
873:       end
874: 
875:       StSw: begin
876:         if (keymgr_key_en_i) begin
877:           // Key from keymgr is actually used if *keyed* MAC is enabled.
878:           keymgr_key_used = kmac_en_o;
879:           key_len_o = SideloadedKey;
880:           for (int i = 0 ; i < Share; i++) begin
881:             key_data_o[i] = keymgr_key[i];
882:           end
883:         end
884:         // Key is valid if SW does *keyed* MAC and ...
885:         if (kmac_en_o) begin
886:           if (!keymgr_key_en_i) begin
887:             // ... it uses the key from kmac's CSR, or ...
888:             key_valid_o = 1'b1;
889:           end else begin
890:             // ... it uses the key provided by keymgr and that one is valid.
891:             key_valid_o = keymgr_key_i.valid;
892:           end
893:         end
894:       end
895: 
896:       default: ;
897:     endcase
898:   end
899: 
900:   // Prefix Demux
901:   // For SW, always prefix register.
902:   // For App intf, check PrefixMode cfg and if 1, use Prefix cfg.
903:   always_comb begin
904:     sha3_prefix_o = '0;
905: 
906:     unique case (st)
907:       StAppCfg, StAppMsg, StAppOutLen, StAppProcess, StAppWait: begin
908:         // Check app intf cfg
909:         for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
910:           if (app_id == i) begin
911:             if (AppCfg[i].PrefixMode == 1'b 0) begin
912:               sha3_prefix_o = reg_prefix_i;
913:             end else begin
914:               sha3_prefix_o = AppCfg[i].Prefix;
915:             end
916:           end
917:         end
918:       end
919: 
920:       StSw: begin
921:         sha3_prefix_o = reg_prefix_i;
922:       end
923: 
924:       default: begin
925:         sha3_prefix_o = reg_prefix_i;
926:       end
927:     endcase
928:   end
929: 
930:   // KMAC en / SHA3 mode / Strength
931:   //  by default, it uses reg cfg. When app intf reqs come, it uses AppCfg.
932:   always_ff @(posedge clk_i or negedge rst_ni) begin
933:     if (!rst_ni) begin
934:       kmac_en_o         <= 1'b 0;
935:       sha3_mode_o       <= sha3_pkg::Sha3;
936:       keccak_strength_o <= sha3_pkg::L256;
937:     end else if (clr_appid) begin
938:       // As App completed, latch reg value
939:       kmac_en_o         <= reg_kmac_en_i;
940:       sha3_mode_o       <= reg_sha3_mode_i;
941:       keccak_strength_o <= reg_keccak_strength_i;
942:     end else if (set_appid) begin
943:       kmac_en_o         <= AppCfg[arb_idx].Mode == AppKMAC ? 1'b 1 : 1'b 0;
944:       sha3_mode_o       <= AppCfg[arb_idx].Mode == AppSHA3
945:                            ? sha3_pkg::Sha3 : sha3_pkg::CShake;
946:       keccak_strength_o <= AppCfg[arb_idx].Strength ;
947:     end else if (st == StIdle) begin
948:       kmac_en_o         <= reg_kmac_en_i;
949:       sha3_mode_o       <= reg_sha3_mode_i;
950:       keccak_strength_o <= reg_keccak_strength_i;
951:     end
952:   end
953: 
954:   // Status
955:   assign app_active_o = (st inside {StAppCfg, StAppMsg, StAppOutLen,
956:                                     StAppProcess, StAppWait});
957: 
958:   // Error Reporting ==========================================================
959:   always_comb begin
960:     priority casez ({fsm_err.valid, mux_err.valid})
961:       2'b ?1: error_o = mux_err;
962:       2'b 10: error_o = fsm_err;
963:       default: error_o = '{valid: 1'b0, code: ErrNone, info: '0};
964:     endcase
965:   end
966: 
967:   ////////////////
968:   // Assertions //
969:   ////////////////
970: 
971:   // KeyMgr sideload key and the digest should be in the Key Length value
972:   `ASSERT_INIT(SideloadKeySameToDigest_A, KeyMgrKeyW <= AppDigestW)
973:   `ASSERT_INIT(AppIntfInRange_A, AppDigestW inside {128, 192, 256, 384, 512})
974: 
975:   // Issue(#13655): Having a coverage that sideload keylen and CSR keylen are
976:   // different.
977:   `COVER(AppIntfUseDifferentSizeKey_C,
978:     (st == StAppCfg && kmac_en_o) |-> reg_key_len_i != SideloadedKey)
979: 
980: endmodule

================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // KMAC Application interface
6: 
7: `include "prim_assert.sv"
8: 
9: module kmac_app
10:   import kmac_pkg::*;
11: #(
12:   // App specific configs are defined in kmac_pkg
13:   parameter  bit EnMasking = 1'b0,
14:   localparam int Share = (EnMasking) ? 2 : 1, // derived parameter
15:   parameter  bit SecIdleAcceptSwMsg = 1'b0
16: ) (
17:   input clk_i,
18:   input rst_ni,
19: 
20:   // Secret Key from register
21:   input [MaxKeyLen-1:0] reg_key_data_i [Share],
22:   input key_len_e       reg_key_len_i,
23: 
24:   // Prefix from register
25:   input [sha3_pkg::NSRegisterSize*8-1:0] reg_prefix_i,
26: 
27:   // mode, strength, kmac_en from register
28:   input                             reg_kmac_en_i,
29:   input sha3_pkg::sha3_mode_e       reg_sha3_mode_i,
30:   input sha3_pkg::keccak_strength_e reg_keccak_strength_i,
31: 
32:   // Data from Software
33:   input                sw_valid_i,
34:   input [MsgWidth-1:0] sw_data_i,
35:   input [MsgWidth-1:0] sw_mask_i,
36:   output logic         sw_ready_o,
37: 
38:   // KeyMgr Sideload Key interface
39:   input keymgr_pkg::hw_key_req_t keymgr_key_i,
40: 
41:   // Application Message in/ Digest out interface + control signals
42:   input  app_req_t [NumAppIntf-1:0] app_i,
43:   output app_rsp_t [NumAppIntf-1:0] app_o,
44: 
45:   // to KMAC Core: Secret key
46:   output logic [MaxKeyLen-1:0] key_data_o [Share],
47:   output key_len_e             key_len_o,
48:   output logic                 key_valid_o,
49: 
50:   // to MSG_FIFO
51:   output logic                kmac_valid_o,
52:   output logic [MsgWidth-1:0] kmac_data_o,
53:   output logic [MsgWidth-1:0] kmac_mask_o,
54:   input                       kmac_ready_i,
55: 
56:   // KMAC Core
57:   output logic kmac_en_o,
58: 
59:   // To Sha3 Core
60:   output logic [sha3_pkg::NSRegisterSize*8-1:0] sha3_prefix_o,
61:   output sha3_pkg::sha3_mode_e                  sha3_mode_o,
62:   output sha3_pkg::keccak_strength_e            keccak_strength_o,
63: 
64:   // STATE from SHA3 Core
65:   input                        keccak_state_valid_i,
66:   input [sha3_pkg::StateW-1:0] keccak_state_i [Share],
67: 
68:   // to STATE TL-window if Application is not active, the incoming state goes to
69:   // register if kdf_en is set, the state value goes to application and the
70:   // output to the register is all zero.
71:   output logic                        reg_state_valid_o,
72:   output logic [sha3_pkg::StateW-1:0] reg_state_o [Share],
73: 
74:   // Configurations If key_en is set, the logic uses KeyMgr's sideloaded key as
75:   // a secret key rather than register values. This only affects when software
76:   // initiates. If App initiates the hash operation and uses KMAC algorithm, it
77:   // always uses sideloaded key.
78:   input keymgr_key_en_i,
79: 
80:   // Commands
81:   // Command from software
82:   input kmac_cmd_e sw_cmd_i,
83: 
84:   // from SHA3
85:   input prim_mubi_pkg::mubi4_t absorbed_i,
86: 
87:   // to KMAC
88:   output kmac_cmd_e cmd_o,
89: 
90:   // to SW
91:   output prim_mubi_pkg::mubi4_t absorbed_o,
92: 
93:   // To status
94:   output logic app_active_o,
95: 
96:   // Status
97:   // - entropy_ready_i: Entropy configured by SW. It is used to check if App
98:   //                    is OK to request.
99:   input prim_mubi_pkg::mubi4_t entropy_ready_i,
100: 
101:   // Error input
102:   // This error comes from KMAC/SHA3 engine.
103:   // KeyMgr interface delivers the error signal to KeyMgr to drop the current op
104:   // and re-initiate.
105:   // If error happens, regardless of SW-initiated or KeyMgr-initiated, the error
106:   // is reported to the ERR_CODE so that SW can look into.
107:   input error_i,
108: 
109:   // SW sets err_processed bit in CTRL then the logic goes to Idle
110:   input err_processed_i,
111: 
112:   output prim_mubi_pkg::mubi4_t clear_after_error_o,
113: 
114:   // error_o value is pushed to Error FIFO at KMAC/SHA3 top and reported to SW
115:   output kmac_pkg::err_t error_o,
116: 
117:   // Life cycle
118:   input  lc_ctrl_pkg::lc_tx_t lc_escalate_en_i,
119: 
120:   output logic sparse_fsm_error_o
121: );
122: 
123:   import sha3_pkg::KeccakBitCapacity;
124:   import sha3_pkg::L128;
125:   import sha3_pkg::L224;
126:   import sha3_pkg::L256;
127:   import sha3_pkg::L384;
128:   import sha3_pkg::L512;
129: 
130:   /////////////////
131:   // Definitions //
132:   /////////////////
133: 
134:   // Digest width is same to the key width `keymgr_pkg::KeyWidth`.
135:   localparam int KeyMgrKeyW = $bits(keymgr_key_i.key[0]);
136: 
137:   localparam key_len_e KeyLengths [5] = '{Key128, Key192, Key256, Key384, Key512};
138: 
139:   localparam int SelKeySize = (AppKeyW == 128) ? 0 :
140:                               (AppKeyW == 192) ? 1 :
141:                               (AppKeyW == 256) ? 2 :
142:                               (AppKeyW == 384) ? 3 :
143:                               (AppKeyW == 512) ? 4 : 0 ;
144:   localparam int SelDigSize = (AppDigestW == 128) ? 0 :
145:                               (AppDigestW == 192) ? 1 :
146:                               (AppDigestW == 256) ? 2 :
147:                               (AppDigestW == 384) ? 3 :
148:                               (AppDigestW == 512) ? 4 : 0 ;
149:   localparam key_len_e SideloadedKey = KeyLengths[SelKeySize];
150: 
151:   // Define right_encode(outlen) value here
152:   // Look at kmac_pkg::key_len_e for the kinds of key size
153:   //
154:   // These values should be exactly the same as the key length encodings
155:   // in kmac_core.sv, with the only difference being that the byte representing
156:   // the byte-length of the encoded value is in the MSB position due to right encoding
157:   // instead of in the LSB position (left encoding).
158:   localparam int OutLenW = 24;
159:   localparam logic [OutLenW-1:0] EncodedOutLen [5]= '{
160:     24'h 0001_80, // Key128
161:     24'h 0001_C0, // Key192
162:     24'h 02_0001, // Key256
163:     24'h 02_8001, // Key384
164:     24'h 02_0002  // Key512
165:   };
166: 
167:   localparam logic [OutLenW-1:0] EncodedOutLenMask [5] = '{
168:     24'h 00FFFF, // Key128,
169:     24'h 00FFFF, // Key192
170:     24'h FFFFFF, // Key256
171:     24'h FFFFFF, // Key384
172:     24'h FFFFFF  // Key512
173:   };
174: 
175:   // Encoding generated with:
176:   // $ ./util/design/sparse-fsm-encode.py -d 3 -m 14 -n 10 \
177:   //     -s 2454278799 --language=sv
178:   //
179:   // Hamming distance histogram:
180:   //
181:   //  0: --
182:   //  1: --
183:   //  2: --
184:   //  3: |||||||||| (14.29%)
185:   //  4: |||||||||||||||||||| (27.47%)
186:   //  5: ||||||||||||| (18.68%)
187:   //  6: |||||||||||||||| (21.98%)
188:   //  7: |||||||| (10.99%)
189:   //  8: |||| (6.59%)
190:   //  9: --
191:   // 10: --
192:   //
193:   // Minimum Hamming distance: 3
194:   // Maximum Hamming distance: 8
195:   // Minimum Hamming weight: 3
196:   // Maximum Hamming weight: 8
197:   //
198:   localparam int StateWidth = 10;
199:   typedef enum logic [StateWidth-1:0] {
200:     StIdle = 10'b1010111110,
201: 
202:     // Application operation.
203:     //
204:     // if start request comes from an App first, until the operation ends by the
205:     // requested App, all operations are granted to the specific App. SW
206:     // requests and other Apps requests will be ignored.
207:     //
208:     // App interface does not have control signals. When first data valid occurs
209:     // from an App, this logic asserts the start command to the downstream. When
210:     // last beat pulse comes, this logic asserts the process to downstream
211:     // (after the transaction is accepted regardless of partial writes or not)
212:     // When absorbed by SHA3 core, the logic sends digest to the requested App
213:     // and right next cycle, it triggers done command to downstream.
214: 
215:     // In StAppCfg state, it latches the cfg from AppCfg parameter to determine
216:     // the kmac_mode, sha3_mode, keccak strength.
217:     StAppCfg = 10'b1010101101,
218: 
219:     StAppMsg = 10'b1110001011,
220: 
221:     // In StKeyOutLen, this module pushes encoded outlen to the MSG_FIFO.
222:     // Assume the length is 256 bit, the data will be 48'h 02_0100
223:     StAppOutLen  = 10'b1010011000,
224:     StAppProcess = 10'b1110110010,
225:     StAppWait    = 10'b1001010000,
226: 
227:     // SW Controlled
228:     // If start request comes from SW first, until the operation ends, all
229:     // requests from KeyMgr will be discarded.
230:     StSw = 10'b0010111011,
231: 
232:     // Error KeyNotValid
233:     // When KeyMgr operates, the secret key is not ready yet.
234:     StKeyMgrErrKeyNotValid = 10'b0111011111,
235: 
236:     StError = 10'b1110010111,
237:     StErrorAwaitSw = 10'b0110001100,
238:     StErrorAwaitApp = 10'b1011100000,
239:     StErrorWaitAbsorbed = 10'b0010100100,
240:     StErrorServiceRejected = 10'b1101000111,
241: 
242:     // This state is used for terminal errors
243:     StTerminalError = 10'b0101110110
244:   } st_e;
245: 
246:   /////////////
247:   // Signals //
248:   /////////////
249: 
250:   st_e st, st_d;
251: 
252:   logic keymgr_key_used;
253: 
254:   // app_rsp_t signals
255:   // The state machine controls mux selection, which controls the ready signal
256:   // the other responses are controled in separate logic. So define the signals
257:   // here and merge them to the response.
258:   logic app_data_ready, fsm_data_ready;
259:   logic app_digest_done, fsm_digest_done_q, fsm_digest_done_d;
260:   logic [AppDigestW-1:0] app_digest [2];
261: 
262:   // One more slot for value NumAppIntf. It is the value when no app intf is
263:   // chosen.
264:   localparam int unsigned AppIdxW = $clog2(NumAppIntf);
265: 
266:   // app_id indicates, which app interface was chosen. various logic use this
267:   // value to get the config or return the data.
268:   logic [AppIdxW-1:0] app_id, app_id_d;
269:   logic               clr_appid, set_appid;
270: 
271:   // Output length
272:   logic [OutLenW-1:0] encoded_outlen, encoded_outlen_mask;
273: 
274:   // state output
275:   // Mux selection signal
276:   app_mux_sel_e mux_sel;
277:   app_mux_sel_e mux_sel_buf_output;
278:   app_mux_sel_e mux_sel_buf_err_check;
279:   app_mux_sel_e mux_sel_buf_kmac;
280: 
281:   // Error checking logic
282: 
283:   kmac_pkg::err_t fsm_err, mux_err;
284: 
285:   logic service_rejected_error;
286:   logic service_rejected_error_set, service_rejected_error_clr;
287:   logic err_during_sw_d, err_during_sw_q;
288: 
289:   always_ff @(posedge clk_i or negedge rst_ni) begin
290:     if (!rst_ni)                         service_rejected_error <= 1'b 0;
291:     else if (service_rejected_error_set) service_rejected_error <= 1'b 1;
292:     else if (service_rejected_error_clr) service_rejected_error <= 1'b 0;
293:   end
294: 
295:   ////////////////////////////
296:   // Application Mux/ Demux //
297:   ////////////////////////////
298: 
299: 
300:   // Processing return data.
301:   // sends to only selected app intf.
302:   // clear digest right after done to not leak info to other interface
303:   always_comb begin
304:     for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
305:       if (i == app_id) begin
306:         app_o[i] = '{
307:           ready:         app_data_ready | fsm_data_ready,
308:           done:          app_digest_done | fsm_digest_done_q,
309:           digest_share0: app_digest[0],
310:           digest_share1: app_digest[1],
311:           // if fsm asserts done, should be an error case.
312:           error:         error_i | fsm_digest_done_q | sparse_fsm_error_o
313:                          | service_rejected_error
314:         };
315:       end else begin
316:         app_o[i] = '{
317:           ready: 1'b 0,
318:           done:  1'b 0,
319:           digest_share0: '0,
320:           digest_share1: '0,
321:           error: 1'b 0
322:         };
323:       end
324:     end // for {i, NumAppIntf, i++}
325:   end // aiways_comb
326: 
327:   // app_id latch
328:   always_ff @(posedge clk_i or negedge rst_ni) begin
329:     if (!rst_ni) app_id <= AppIdxW'(0) ; // Do not select any
330:     else if (clr_appid) app_id <= AppIdxW'(0);
331:     else if (set_appid) app_id <= app_id_d;
332:   end
333: 
334:   // app_id selection as of now, app_id uses Priority. The assumption is that
335:   //  the request normally does not collide. (ROM_CTRL activates very early
336:   //  stage at the boot sequence)
337:   //
338:   //  If this assumption is not true, consider RR arbiter.
339: 
340:   // Prep for arbiter
341:   logic [NumAppIntf-1:0] app_reqs;
342:   logic [NumAppIntf-1:0] unused_app_gnts;
343:   logic [$clog2(NumAppIntf)-1:0] arb_idx;
344:   logic arb_valid;
345:   logic arb_ready;
346: 
347:   always_comb begin
348:     app_reqs = '0;
349:     for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
350:       app_reqs[i] = app_i[i].valid;
351:     end
352:   end
353: 
354:   prim_arbiter_fixed #(
355:     .N (NumAppIntf),
356:     .DW(1),
357:     .EnDataPort(1'b 0)
358:   ) u_appid_arb (
359:     .clk_i,
360:     .rst_ni,
361: 
362:     .req_i  (app_reqs),
363:     .data_i ('{default:'0}),
364:     .gnt_o  (unused_app_gnts),
365:     .idx_o  (arb_idx),
366: 
367:     .valid_o (arb_valid),
368:     .data_o  (), // not used
369:     .ready_i (arb_ready)
370:   );
371: 
372:   assign app_id_d = AppIdxW'(arb_idx);
373:   assign arb_ready = set_appid;
374: 
375:   always_ff @(posedge clk_i or negedge rst_ni) begin
376:     if (!rst_ni) fsm_digest_done_q <= 1'b 0;
377:     else         fsm_digest_done_q <= fsm_digest_done_d;
378:   end
379: 
380:   /////////
381:   // FSM //
382:   /////////
383: 
384:   // State register
385:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, st_d, st, st_e, StIdle)
386: 
387:   // Create a lint error to reduce the risk of accidentally enabling this feature.
388:   `ASSERT_STATIC_LINT_ERROR(KmacSecIdleAcceptSwMsgNonDefault, SecIdleAcceptSwMsg == 0)
389: 
390:   // Next State & output logic
391:   // SEC_CM: FSM.SPARSE
392:   always_comb begin
393:     st_d = st;
394: 
395:     mux_sel = SecIdleAcceptSwMsg ? SelSw : SelNone;
396: 
397:     // app_id control
398:     set_appid = 1'b 0;
399:     clr_appid = 1'b 0;
400: 
401:     // Commands
402:     cmd_o = CmdNone;
403: 
404:     // Software output
405:     absorbed_o = prim_mubi_pkg::MuBi4False;
406: 
407:     // Error
408:     fsm_err = '{valid: 1'b 0, code: ErrNone, info: '0};
409:     sparse_fsm_error_o = 1'b 0;
410: 
411:     clear_after_error_o = prim_mubi_pkg::MuBi4False;
412: 
413:     service_rejected_error_set = 1'b 0;
414:     service_rejected_error_clr = 1'b 0;
415: 
416:     // If error happens, FSM asserts data ready but discard incoming msg
417:     fsm_data_ready = 1'b 0;
418:     fsm_digest_done_d = 1'b 0;
419: 
420:     unique case (st)
421:       StIdle: begin
422:         if (arb_valid) begin
423:           st_d = StAppCfg;
424: 
425:           // choose app_id
426:           set_appid = 1'b 1;
427:         end else if (sw_cmd_i == CmdStart) begin
428:           st_d = StSw;
429:           // Software initiates the sequence
430:           cmd_o = CmdStart;
431:         end else begin
432:           st_d = StIdle;
433:         end
434:       end
435: 
436:       StAppCfg: begin
437:         if (AppCfg[app_id].Mode == AppKMAC &&
438:           prim_mubi_pkg::mubi4_test_false_strict(entropy_ready_i)) begin
439:           // Check if the entropy is not configured but it is needed in
440:           // `AppCfg[app_id]` (KMAC mode).
441:           //
442:           // SW is not properly configured, report and not request Hashing
443:           // Return the app with errors
444:           st_d = StError;
445: 
446:           service_rejected_error_set = 1'b 1;
447: 
448:         end else begin
449:           // As Cfg is stable now, it sends cmd
450:           st_d = StAppMsg;
451: 
452:           // App initiates the data
453:           cmd_o = CmdStart;
454:         end
455:       end
456: 
457:       StAppMsg: begin
458:         mux_sel = SelApp;
459:         if (app_i[app_id].valid && app_o[app_id].ready && app_i[app_id].last) begin
460:           if (AppCfg[app_id].Mode == AppKMAC) begin
461:             st_d = StAppOutLen;
462:           end else begin
463:             st_d = StAppProcess;
464:           end
465:         end else begin
466:           st_d = StAppMsg;
467:         end
468:       end
469: 
470:       StAppOutLen: begin
471:         mux_sel = SelOutLen;
472: 
473:         if (kmac_valid_o && kmac_ready_i) begin
474:           st_d = StAppProcess;
475:         end else begin
476:           st_d = StAppOutLen;
477:         end
478:       end
479: 
480:       StAppProcess: begin
481:         cmd_o = CmdProcess;
482:         st_d = StAppWait;
483:       end
484: 
485:       StAppWait: begin
486:         if (prim_mubi_pkg::mubi4_test_true_strict(absorbed_i)) begin
487:           // Send digest to KeyMgr and complete the op
488:           st_d = StIdle;
489:           cmd_o = CmdDone;
490: 
491:           clr_appid = 1'b 1;
492:         end else begin
493:           st_d = StAppWait;
494:         end
495:       end
496: 
497:       StSw: begin
498:         mux_sel = SelSw;
499: 
500:         cmd_o = sw_cmd_i;
501:         absorbed_o = absorbed_i;
502: 
503:         if (sw_cmd_i == CmdDone) begin
504:           st_d = StIdle;
505:         end else begin
506:           st_d = StSw;
507:         end
508:       end
509: 
510:       StKeyMgrErrKeyNotValid: begin
511:         st_d = StError;
512: 
513:         // As mux_sel is not set to SelApp, app_data_ready is still 0.
514:         // This logic won't accept the requests from the selected App.
515:         fsm_err.valid = 1'b 1;
516:         fsm_err.code = ErrKeyNotValid;
517:         fsm_err.info = 24'(app_id);
518:       end
519: 
520:       StError: begin
521:         // In this state, the state machine flush out the request
522:         st_d = StError;
523: 
524:         // Absorb data on the app interface.
525:         fsm_data_ready = ~err_during_sw_q;
526: 
527:         // Next step depends on two conditions:
528:         // 1) Error being processed by SW
529:         // 2) Last data provided from the app interface (so that the app interface is completely)
530:         //    drained.  If the error occurred during a SW operation, the app interface is not
531:         //    involved, so this condition gets skipped.
532:         unique case ({err_processed_i,
533:                       (app_i[app_id].valid && app_i[app_id].last) || err_during_sw_q})
534:           2'b00: begin
535:             // Error not processed by SW and not last data from app interface -> keep current state.
536:             st_d = StError;
537:           end
538:           2'b01: begin
539:             // Error not processed by SW but last data from app interface:
540:             // 1. Send garbage digest to the app interface (in the next cycle) to complete the
541:             // transaction.
542:             fsm_digest_done_d = ~err_during_sw_q;
543:             if (service_rejected_error) begin
544:               // 2.a) Service was rejected because an app interface tried to configure KMAC while no
545:               // entropy was available. It is assumed that SW is not loaded yet, so don't wait for
546:               // SW to process the error. The last data from the app interface has now arrived, but
547:               // we don't need to wait for the SHA3 core to have absorbed it because the data never
548:               // entered the SHA3 core: the request from the app interface was terminated during the
549:               // configuration phase.
550:               st_d = StErrorServiceRejected;
551:             end else begin
552:               // 2.b) If service was not rejected, wait for SW to process the error.
553:               st_d = StErrorAwaitSw;
554:             end
555:           end
556:           2'b10: begin
557:             // Error processed by SW but not last data from app interface -> wait for app interface.
558:             st_d = StErrorAwaitApp;
559:           end
560:           2'b11: begin
561:             // Error processed by SW and last data from app interface:
562:             // Send garbage digest to the app interface (in the next cycle) to complete the
563:             // transaction.
564:             fsm_digest_done_d = ~err_during_sw_q;
565:             // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
566:             // but serves to bring the SHA3 engine back to the idle state).
567:             cmd_o = CmdProcess;
568:             st_d = StErrorWaitAbsorbed;
569:           end
570:           default: st_d = StError;
571:         endcase
572:       end
573: 
574:       StErrorAwaitSw: begin
575:         // Just wait for SW to process the error.
576:         if (err_processed_i) begin
577:           // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
578:           // but serves to bring the SHA3 engine back to the idle state).
579:           cmd_o = CmdProcess;
580:           st_d = StErrorWaitAbsorbed;
581:         end
582:       end
583: 
584:       StErrorAwaitApp: begin
585:         // Keep absorbing data on the app interface until the last data.
586:         fsm_data_ready = 1'b1;
587:         if (app_i[app_id].valid && app_i[app_id].last) begin
588:           // Send garbage digest to the app interface (in the next cycle) to complete the
589:           // transaction.
590:           fsm_digest_done_d = 1'b1;
591:           // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
592:           // but serves to bring the SHA3 engine back to the idle state).
593:           cmd_o = CmdProcess;
594:           st_d = StErrorWaitAbsorbed;
595:         end
596:       end
597: 
598:       StErrorWaitAbsorbed: begin
599:         if (prim_mubi_pkg::mubi4_test_true_strict(absorbed_i)) begin
600:           // Clear internal variables, send done command, and return to idle.
601:           clr_appid = 1'b1;
602:           clear_after_error_o = prim_mubi_pkg::MuBi4True;
603:           service_rejected_error_clr = 1'b1;
604:           cmd_o = CmdDone;
605:           st_d = StIdle;
606:           // If error originated from SW, report 'absorbed' to SW.
607:           if (err_during_sw_q) begin
608:             absorbed_o = prim_mubi_pkg::MuBi4True;
609:           end
610:         end
611:       end
612: 
613:       StErrorServiceRejected: begin
614:         // Clear internal variables and return to idle.
615:         clr_appid = 1'b1;
616:         clear_after_error_o = prim_mubi_pkg::MuBi4True;
617:         service_rejected_error_clr = 1'b1;
618:         st_d = StIdle;
619:       end
620: 
621:       StTerminalError: begin
622:         // this state is terminal
623:         st_d = st;
624:         sparse_fsm_error_o = 1'b 1;
625:         fsm_err.valid = 1'b 1;
626:         fsm_err.code = ErrFatalError;
627:         fsm_err.info = 24'(app_id);
628:       end
629: 
630:       default: begin
631:         st_d = StTerminalError;
632:         sparse_fsm_error_o = 1'b 1;
633:       end
634:     endcase
635: 
636:     // SEC_CM: FSM.GLOBAL_ESC, FSM.LOCAL_ESC
637:     // Unconditionally jump into the terminal error state
638:     // if the life cycle controller triggers an escalation.
639:     if (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) begin
640:       st_d = StTerminalError;
641:     end
642: 
643:     // Handle errors outside the terminal error state.
644:     if (st_d != StTerminalError) begin
645:       // Key from keymgr is used but not valid, so abort into the invalid key error state.
646:       if (keymgr_key_used && !keymgr_key_i.valid) begin
647:         st_d = StKeyMgrErrKeyNotValid;
648:       end
649:     end
650:   end
651: 
652:   // Track errors occurring in SW mode.
653:   assign err_during_sw_d =
654:       (mux_sel == SelSw) && (st_d inside {StError, StKeyMgrErrKeyNotValid}) ? 1'b1 : // set
655:       (st_d == StIdle)                                                      ? 1'b0 : // clear
656:       err_during_sw_q;                                                               // hold
657: 
658:   always_ff @(posedge clk_i or negedge rst_ni) begin
659:     if (!rst_ni) begin
660:       err_during_sw_q <= 1'b0;
661:     end else begin
662:       err_during_sw_q <= err_during_sw_d;
663:     end
664:   end
665: 
666:   //////////////
667:   // Datapath //
668:   //////////////
669: 
670:   // Encoded output length
671:   assign encoded_outlen      = EncodedOutLen[SelDigSize];
672:   assign encoded_outlen_mask = EncodedOutLenMask[SelKeySize];
673: 
674:   // Data mux
675:   // This is the main part of the KeyMgr interface logic.
676:   // The FSM selects KeyMgr interface in a cycle after it receives the first
677:   // valid data from KeyMgr. The ready signal to the KeyMgr data interface
678:   // represents the MSG_FIFO ready, only when it is in StKeyMgrMsg state.
679:   // After KeyMgr sends last beat, the kmac interface (to MSG_FIFO) is switched
680:   // to OutLen. OutLen is pre-defined values. See `EncodeOutLen` parameter above.
681:   always_comb begin
682:     app_data_ready = 1'b 0;
683:     sw_ready_o = 1'b 1;
684: 
685:     kmac_valid_o = 1'b 0;
686:     kmac_data_o = '0;
687:     kmac_mask_o = '0;
688: 
689:     unique case (mux_sel_buf_kmac)
690:       SelApp: begin
691:         // app_id is valid at this time
692:         kmac_valid_o = app_i[app_id].valid;
693:         kmac_data_o  = app_i[app_id].data;
694:         // Expand strb to bits. prim_packer inside MSG_FIFO accepts the bit masks
695:         for (int i = 0 ; i < $bits(app_i[app_id].strb) ; i++) begin
696:           kmac_mask_o[8*i+:8] = {8{app_i[app_id].strb[i]}};
697:         end
698:         app_data_ready = kmac_ready_i;
699:       end
700: 
701:       SelOutLen: begin
702:         // Write encoded output length value
703:         kmac_valid_o = 1'b 1; // always write
704:         kmac_data_o  = MsgWidth'(encoded_outlen);
705:         kmac_mask_o  = MsgWidth'(encoded_outlen_mask);
706:       end
707: 
708:       SelSw: begin
709:         kmac_valid_o = sw_valid_i;
710:         kmac_data_o  = sw_data_i ;
711:         kmac_mask_o  = sw_mask_i ;
712:         sw_ready_o   = kmac_ready_i ;
713:       end
714: 
715:       default: begin // Incl. SelNone
716:         kmac_valid_o = 1'b 0;
717:         kmac_data_o = '0;
718:         kmac_mask_o = '0;
719:       end
720: 
721:     endcase
722:   end
723: 
724:   // Error checking for Mux
725:   always_comb begin
726:     mux_err = '{valid: 1'b 0, code: ErrNone, info: '0};
727: 
728:     if (mux_sel_buf_err_check != SelSw && sw_valid_i) begin
729:       // If SW writes message into FIFO
730:       mux_err = '{
731:         valid: 1'b 1,
732:         code: ErrSwPushedMsgFifo,
733:         info: 24'({8'h 00, 8'(st), 8'(mux_sel_buf_err_check)})
734:       };
735:     end else if (app_active_o && sw_cmd_i != CmdNone) begin
736:       // If SW issues command except start
737:       mux_err = '{
738:         valid: 1'b 1,
739:         code: ErrSwIssuedCmdInAppActive,
740:         info: 24'(sw_cmd_i)
741:       };
742:     end
743:   end
744: 
745:   logic [AppMuxWidth-1:0] mux_sel_buf_output_logic;
746:   assign mux_sel_buf_output = app_mux_sel_e'(mux_sel_buf_output_logic);
747: 
748:   // SEC_CM: LOGIC.INTEGRITY
749:   prim_sec_anchor_buf #(
750:    .Width(AppMuxWidth)
751:   ) u_prim_buf_state_output_sel (
752:     .in_i(mux_sel),
753:     .out_o(mux_sel_buf_output_logic)
754:   );
755: 
756:   logic [AppMuxWidth-1:0] mux_sel_buf_err_check_logic;
757:   assign mux_sel_buf_err_check = app_mux_sel_e'(mux_sel_buf_err_check_logic);
758: 
759:   // SEC_CM: LOGIC.INTEGRITY
760:   prim_sec_anchor_buf #(
761:    .Width(AppMuxWidth)
762:   ) u_prim_buf_state_err_check (
763:     .in_i(mux_sel),
764:     .out_o(mux_sel_buf_err_check_logic)
765:   );
766: 
767:   logic [AppMuxWidth-1:0] mux_sel_buf_kmac_logic;
768:   assign mux_sel_buf_kmac = app_mux_sel_e'(mux_sel_buf_kmac_logic);
769: 
770:   // SEC_CM: LOGIC.INTEGRITY
771:   prim_sec_anchor_buf #(
772:    .Width(AppMuxWidth)
773:   ) u_prim_buf_state_kmac_sel (
774:     .in_i(mux_sel),
775:     .out_o(mux_sel_buf_kmac_logic)
776:   );
777: 
778:   // SEC_CM: LOGIC.INTEGRITY
779:   logic reg_state_valid;
780:   prim_sec_anchor_buf #(
781:    .Width(1)
782:   ) u_prim_buf_state_output_valid (
783:     .in_i(reg_state_valid),
784:     .out_o(reg_state_valid_o)
785:   );
786: 
787:   // Keccak state Demux
788:   // Keccak state --> Register output is enabled when state is in StSw
789:   always_comb begin
790:     reg_state_valid = 1'b 0;
791:     reg_state_o = '{default:'0};
792:     if ((mux_sel_buf_output == SelSw) &&
793:          lc_ctrl_pkg::lc_tx_test_false_strict(lc_escalate_en_i)) begin
794:       reg_state_valid = keccak_state_valid_i;
795:       reg_state_o = keccak_state_i;
796:       // If key is sideloaded and KMAC is SW initiated
797:       // hide the capacity from SW by zeroing (see #17508)
798:       if (keymgr_key_en_i) begin
799:         for (int i = 0; i < Share; i++) begin
800:           unique case (reg_keccak_strength_i)
801:             L128: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L128]] = '0;
802:             L224: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L224]] = '0;
803:             L256: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L256]] = '0;
804:             L384: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L384]] = '0;
805:             L512: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L512]] = '0;
806:             default: reg_state_o[i] = '0;
807:           endcase
808:         end
809:       end
810:     end
811:   end
812: 
813:   // Keccak state --> KeyMgr
814:   always_comb begin
815:     app_digest_done = 1'b 0;
816:     app_digest = '{default:'0};
817:     if (st == StAppWait && prim_mubi_pkg::mubi4_test_true_strict(absorbed_i) &&
818:        lc_ctrl_pkg::lc_tx_test_false_strict(lc_escalate_en_i)) begin
819:       // SHA3 engine has calculated the hash. Return the data to KeyMgr
820:       app_digest_done = 1'b 1;
821: 
822:       // digest has always 2 entries. If !EnMasking, second is tied to 0.
823:       for (int i = 0 ; i < Share ; i++) begin
824:         // Return the portion of state.
825:         app_digest[i] = keccak_state_i[i][AppDigestW-1:0];
826:       end
827:     end
828:   end
829: 
830: 
831:   // Secret Key Mux
832: 
833:   // Prepare merged key if EnMasking is not set.
834:   // Combine share keys into unpacked array for logic below to assign easily.
835:   // SEC_CM: KEY.SIDELOAD
836:   logic [MaxKeyLen-1:0] keymgr_key [Share];
837:   if (EnMasking == 1) begin : g_masked_key
838:     for (genvar i = 0; i < Share; i++) begin : gen_key_pad
839:       assign keymgr_key[i] =  {(MaxKeyLen-KeyMgrKeyW)'(0), keymgr_key_i.key[i]};
840:     end
841:   end else begin : g_unmasked_key
842:     always_comb begin
843:       keymgr_key[0] = '0;
844:       for (int i = 0; i < keymgr_pkg::Shares; i++) begin
845:         keymgr_key[0][KeyMgrKeyW-1:0] ^= keymgr_key_i.key[i];
846:       end
847:     end
848:   end
849: 
850:   // Sideloaded key manage: Keep use sideloaded key for KMAC AppIntf until the
851:   // hashing operation is finished.
852:   always_comb begin
853:     keymgr_key_used = 1'b0;
854:     key_len_o  = reg_key_len_i;
855:     for (int i = 0 ; i < Share; i++) begin
856:       key_data_o[i] = reg_key_data_i[i];
857:     end
858:     // The key is considered invalid in all cases that are not listed below (which includes idle and
859:     // error states).
860:     key_valid_o = 1'b0;
861: 
862:     unique case (st)
863:       StAppCfg, StAppMsg, StAppOutLen, StAppProcess, StAppWait: begin
864:         // Key from keymgr is actually used if the current HW app interface does *keyed* MAC.
865:         keymgr_key_used = AppCfg[app_id].Mode == AppKMAC;
866:         key_len_o = SideloadedKey;
867:         for (int i = 0 ; i < Share; i++) begin
868:           key_data_o[i] = keymgr_key[i];
869:         end
870:         // Key is valid if the current HW app interface does *keyed* MAC and the key provided by
871:         // keymgr is valid.
872:         key_valid_o = keymgr_key_used && keymgr_key_i.valid;
873:       end
874: 
875:       StSw: begin
876:         if (keymgr_key_en_i) begin
877:           // Key from keymgr is actually used if *keyed* MAC is enabled.
878:           keymgr_key_used = kmac_en_o;
879:           key_len_o = SideloadedKey;
880:           for (int i = 0 ; i < Share; i++) begin
881:             key_data_o[i] = keymgr_key[i];
882:           end
883:         end
884:         // Key is valid if SW does *keyed* MAC and ...
885:         if (kmac_en_o) begin
886:           if (!keymgr_key_en_i) begin
887:             // ... it uses the key from kmac's CSR, or ...
888:             key_valid_o = 1'b1;
889:           end else begin
890:             // ... it uses the key provided by keymgr and that one is valid.
891:             key_valid_o = keymgr_key_i.valid;
892:           end
893:         end
894:       end
895: 
896:       default: ;
897:     endcase
898:   end
899: 
900:   // Prefix Demux
901:   // For SW, always prefix register.
902:   // For App intf, check PrefixMode cfg and if 1, use Prefix cfg.
903:   always_comb begin
904:     sha3_prefix_o = '0;
905: 
906:     unique case (st)
907:       StAppCfg, StAppMsg, StAppOutLen, StAppProcess, StAppWait: begin
908:         // Check app intf cfg
909:         for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
910:           if (app_id == i) begin
911:             if (AppCfg[i].PrefixMode == 1'b 0) begin
912:               sha3_prefix_o = reg_prefix_i;
913:             end else begin
914:               sha3_prefix_o = AppCfg[i].Prefix;
915:             end
916:           end
917:         end
918:       end
919: 
920:       StSw: begin
921:         sha3_prefix_o = reg_prefix_i;
922:       end
923: 
924:       default: begin
925:         sha3_prefix_o = reg_prefix_i;
926:       end
927:     endcase
928:   end
929: 
930:   // KMAC en / SHA3 mode / Strength
931:   //  by default, it uses reg cfg. When app intf reqs come, it uses AppCfg.
932:   always_ff @(posedge clk_i or negedge rst_ni) begin
933:     if (!rst_ni) begin
934:       kmac_en_o         <= 1'b 0;
935:       sha3_mode_o       <= sha3_pkg::Sha3;
936:       keccak_strength_o <= sha3_pkg::L256;
937:     end else if (clr_appid) begin
938:       // As App completed, latch reg value
939:       kmac_en_o         <= reg_kmac_en_i;
940:       sha3_mode_o       <= reg_sha3_mode_i;
941:       keccak_strength_o <= reg_keccak_strength_i;
942:     end else if (set_appid) begin
943:       kmac_en_o         <= AppCfg[arb_idx].Mode == AppKMAC ? 1'b 1 : 1'b 0;
944:       sha3_mode_o       <= AppCfg[arb_idx].Mode == AppSHA3
945:                            ? sha3_pkg::Sha3 : sha3_pkg::CShake;
946:       keccak_strength_o <= AppCfg[arb_idx].Strength ;
947:     end else if (st == StIdle) begin
948:       kmac_en_o         <= reg_kmac_en_i;
949:       sha3_mode_o       <= reg_sha3_mode_i;
950:       keccak_strength_o <= reg_keccak_strength_i;
951:     end
952:   end
953: 
954:   // Status
955:   assign app_active_o = (st inside {StAppCfg, StAppMsg, StAppOutLen,
956:                                     StAppProcess, StAppWait});
957: 
958:   // Error Reporting ==========================================================
959:   always_comb begin
960:     priority casez ({fsm_err.valid, mux_err.valid})
961:       2'b ?1: error_o = mux_err;
962:       2'b 10: error_o = fsm_err;
963:       default: error_o = '{valid: 1'b0, code: ErrNone, info: '0};
964:     endcase
965:   end
966: 
967:   ////////////////
968:   // Assertions //
969:   ////////////////
970: 
971:   // KeyMgr sideload key and the digest should be in the Key Length value
972:   `ASSERT_INIT(SideloadKeySameToDigest_A, KeyMgrKeyW <= AppDigestW)
973:   `ASSERT_INIT(AppIntfInRange_A, AppDigestW inside {128, 192, 256, 384, 512})
974: 
975:   // Issue(#13655): Having a coverage that sideload keylen and CSR keylen are
976:   // different.
977:   `COVER(AppIntfUseDifferentSizeKey_C,
978:     (st == StAppCfg && kmac_en_o) |-> reg_key_len_i != SideloadedKey)
979: 
980: endmodule

================================== Ai Message ==================================

[{'text': "Now, I'll search for similar bug patterns:", 'type': 'text'}, {'id': 'toolu_014HjdiV7VjTQsEsBR1RHQce', 'input': {'bug': 'if (mux_sel_buf_err_check != SelSw && sw_valid_i) begin', 'ip_file': '/home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv'}, 'name': 'similar_bug_tool', 'type': 'tool_use'}]
Tool Calls:
  similar_bug_tool (toolu_014HjdiV7VjTQsEsBR1RHQce)
 Call ID: toolu_014HjdiV7VjTQsEsBR1RHQce
  Args:
    bug: if (mux_sel_buf_err_check != SelSw && sw_valid_i) begin
    ip_file: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv
================================= Tool Message =================================
Name: similar_bug_tool

Error: ValueError("'.out_o(mux_sel_buf_err_check_logic)\\n  );' is not in list")
 Please fix your mistakes.
================================= Tool Message =================================
Name: similar_bug_tool

Error: ValueError("'.out_o(mux_sel_buf_err_check_logic)\\n  );' is not in list")
 Please fix your mistakes.
================================== Ai Message ==================================

I apologize for the error. Let me manually analyze the code for similar bug patterns.

I found the exact bug pattern you mentioned on line 728:

```systemverilog
if (mux_sel_buf_err_check != SelSw && sw_valid_i) begin
```

This is the same condition you highlighted. It appears to be an error checking logic that detects when software is trying to write to the message FIFO when it's not in the expected state. 

The code block continues with error reporting:
```systemverilog
mux_err = '{
  valid: 1'b 1,
  code: ErrSwPushedMsgFifo,
  info: 24'({8'h 00, 8'(st), 8'(mux_sel_buf_err_check)})
};
```

So the buggy lines are:
- Line 728-735: The error checking condition and error reporting logic for software pushing to the message FIFO when not in the correct state.

This appears to be an intentional error detection mechanism, but the specific implementation might need careful review to ensure it correctly handles all possible state transitions and mux selections.
================================= Tool Message =================================
Name: run_similar_bug_agent

I apologize for the error. Let me manually analyze the code for similar bug patterns.

I found the exact bug pattern you mentioned on line 728:

```systemverilog
if (mux_sel_buf_err_check != SelSw && sw_valid_i) begin
```

This is the same condition you highlighted. It appears to be an error checking logic that detects when software is trying to write to the message FIFO when it's not in the expected state. 

The code block continues with error reporting:
```systemverilog
mux_err = '{
  valid: 1'b 1,
  code: ErrSwPushedMsgFifo,
  info: 24'({8'h 00, 8'(st), 8'(mux_sel_buf_err_check)})
};
```

So the buggy lines are:
- Line 728-735: The error checking condition and error reporting logic for software pushing to the message FIFO when not in the correct state.

This appears to be an intentional error detection mechanism, but the specific implementation might need careful review to ensure it correctly handles all possible state transitions and mux selections.
================================== Ai Message ==================================
Tool Calls:
  run_anomaly_detector_agent (call_idO8zLDpyfqD5dPi0UDYWaDj)
 Call ID: call_idO8zLDpyfqD5dPi0UDYWaDj
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv
    top_module: kmac_app
    security_objective: application interface isolation, privilege escalation, command injection
================================ Human Message =================================

Are there security concerns related to application interface isolation, privilege escalation, command injection in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// KMAC Application interface

`include "prim_assert.sv"

module kmac_app
  import kmac_pkg::*;
#(
  // App specific configs are defined in kmac_pkg
  parameter  bit EnMasking = 1'b0,
  localparam int Share = (EnMasking) ? 2 : 1, // derived parameter
  parameter  bit SecIdleAcceptSwMsg = 1'b0
) (
  input clk_i,
  input rst_ni,

  // Secret Key from register
  input [MaxKeyLen-1:0] reg_key_data_i [Share],
  input key_len_e       reg_key_len_i,

  // Prefix from register
  input [sha3_pkg::NSRegisterSize*8-1:0] reg_prefix_i,

  // mode, strength, kmac_en from register
  input                             reg_kmac_en_i,
  input sha3_pkg::sha3_mode_e       reg_sha3_mode_i,
  input sha3_pkg::keccak_strength_e reg_keccak_strength_i,

  // Data from Software
  input                sw_valid_i,
  input [MsgWidth-1:0] sw_data_i,
  input [MsgWidth-1:0] sw_mask_i,
  output logic         sw_ready_o,

  // KeyMgr Sideload Key interface
  input keymgr_pkg::hw_key_req_t keymgr_key_i,

  // Application Message in/ Digest out interface + control signals
  input  app_req_t [NumAppIntf-1:0] app_i,
  output app_rsp_t [NumAppIntf-1:0] app_o,

  // to KMAC Core: Secret key
  output logic [MaxKeyLen-1:0] key_data_o [Share],
  output key_len_e             key_len_o,
  output logic                 key_valid_o,

  // to MSG_FIFO
  output logic                kmac_valid_o,
  output logic [MsgWidth-1:0] kmac_data_o,
  output logic [MsgWidth-1:0] kmac_mask_o,
  input                       kmac_ready_i,

  // KMAC Core
  output logic kmac_en_o,

  // To Sha3 Core
  output logic [sha3_pkg::NSRegisterSize*8-1:0] sha3_prefix_o,
  output sha3_pkg::sha3_mode_e                  sha3_mode_o,
  output sha3_pkg::keccak_strength_e            keccak_strength_o,

  // STATE from SHA3 Core
  input                        keccak_state_valid_i,
  input [sha3_pkg::StateW-1:0] keccak_state_i [Share],

  // to STATE TL-window if Application is not active, the incoming state goes to
  // register if kdf_en is set, the state value goes to application and the
  // output to the register is all zero.
  output logic                        reg_state_valid_o,
  output logic [sha3_pkg::StateW-1:0] reg_state_o [Share],

  // Configurations If key_en is set, the logic uses KeyMgr's sideloaded key as
  // a secret key rather than register values. This only affects when software
  // initiates. If App initiates the hash operation and uses KMAC algorithm, it
  // always uses sideloaded key.
  input keymgr_key_en_i,

  // Commands
  // Command from software
  input kmac_cmd_e sw_cmd_i,

  // from SHA3
  input prim_mubi_pkg::mubi4_t absorbed_i,

  // to KMAC
  output kmac_cmd_e cmd_o,

  // to SW
  output prim_mubi_pkg::mubi4_t absorbed_o,

  // To status
  output logic app_active_o,

  // Status
  // - entropy_ready_i: Entropy configured by SW. It is used to check if App
  //                    is OK to request.
  input prim_mubi_pkg::mubi4_t entropy_ready_i,

  // Error input
  // This error comes from KMAC/SHA3 engine.
  // KeyMgr interface delivers the error signal to KeyMgr to drop the current op
  // and re-initiate.
  // If error happens, regardless of SW-initiated or KeyMgr-initiated, the error
  // is reported to the ERR_CODE so that SW can look into.
  input error_i,

  // SW sets err_processed bit in CTRL then the logic goes to Idle
  input err_processed_i,

  output prim_mubi_pkg::mubi4_t clear_after_error_o,

  // error_o value is pushed to Error FIFO at KMAC/SHA3 top and reported to SW
  output kmac_pkg::err_t error_o,

  // Life cycle
  input  lc_ctrl_pkg::lc_tx_t lc_escalate_en_i,

  output logic sparse_fsm_error_o
);

  import sha3_pkg::KeccakBitCapacity;
  import sha3_pkg::L128;
  import sha3_pkg::L224;
  import sha3_pkg::L256;
  import sha3_pkg::L384;
  import sha3_pkg::L512;

  /////////////////
  // Definitions //
  /////////////////

  // Digest width is same to the key width `keymgr_pkg::KeyWidth`.
  localparam int KeyMgrKeyW = $bits(keymgr_key_i.key[0]);

  localparam key_len_e KeyLengths [5] = '{Key128, Key192, Key256, Key384, Key512};

  localparam int SelKeySize = (AppKeyW == 128) ? 0 :
                              (AppKeyW == 192) ? 1 :
                              (AppKeyW == 256) ? 2 :
                              (AppKeyW == 384) ? 3 :
                              (AppKeyW == 512) ? 4 : 0 ;
  localparam int SelDigSize = (AppDigestW == 128) ? 0 :
                              (AppDigestW == 192) ? 1 :
                              (AppDigestW == 256) ? 2 :
                              (AppDigestW == 384) ? 3 :
                              (AppDigestW == 512) ? 4 : 0 ;
  localparam key_len_e SideloadedKey = KeyLengths[SelKeySize];

  // Define right_encode(outlen) value here
  // Look at kmac_pkg::key_len_e for the kinds of key size
  //
  // These values should be exactly the same as the key length encodings
  // in kmac_core.sv, with the only difference being that the byte representing
  // the byte-length of the encoded value is in the MSB position due to right encoding
  // instead of in the LSB position (left encoding).
  localparam int OutLenW = 24;
  localparam logic [OutLenW-1:0] EncodedOutLen [5]= '{
    24'h 0001_80, // Key128
    24'h 0001_C0, // Key192
    24'h 02_0001, // Key256
    24'h 02_8001, // Key384
    24'h 02_0002  // Key512
  };

  localparam logic [OutLenW-1:0] EncodedOutLenMask [5] = '{
    24'h 00FFFF, // Key128,
    24'h 00FFFF, // Key192
    24'h FFFFFF, // Key256
    24'h FFFFFF, // Key384
    24'h FFFFFF  // Key512
  };

  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 3 -m 14 -n 10 \
  //     -s 2454278799 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: |||||||||| (14.29%)
  //  4: |||||||||||||||||||| (27.47%)
  //  5: ||||||||||||| (18.68%)
  //  6: |||||||||||||||| (21.98%)
  //  7: |||||||| (10.99%)
  //  8: |||| (6.59%)
  //  9: --
  // 10: --
  //
  // Minimum Hamming distance: 3
  // Maximum Hamming distance: 8
  // Minimum Hamming weight: 3
  // Maximum Hamming weight: 8
  //
  localparam int StateWidth = 10;
  typedef enum logic [StateWidth-1:0] {
    StIdle = 10'b1010111110,

    // Application operation.
    //
    // if start request comes from an App first, until the operation ends by the
    // requested App, all operations are granted to the specific App. SW
    // requests and other Apps requests will be ignored.
    //
    // App interface does not have control signals. When first data valid occurs
    // from an App, this logic asserts the start command to the downstream. When
    // last beat pulse comes, this logic asserts the process to downstream
    // (after the transaction is accepted regardless of partial writes or not)
    // When absorbed by SHA3 core, the logic sends digest to the requested App
    // and right next cycle, it triggers done command to downstream.

    // In StAppCfg state, it latches the cfg from AppCfg parameter to determine
    // the kmac_mode, sha3_mode, keccak strength.
    StAppCfg = 10'b1010101101,

    StAppMsg = 10'b1110001011,

    // In StKeyOutLen, this module pushes encoded outlen to the MSG_FIFO.
    // Assume the length is 256 bit, the data will be 48'h 02_0100
    StAppOutLen  = 10'b1010011000,
    StAppProcess = 10'b1110110010,
    StAppWait    = 10'b1001010000,

    // SW Controlled
    // If start request comes from SW first, until the operation ends, all
    // requests from KeyMgr will be discarded.
    StSw = 10'b0010111011,

    // Error KeyNotValid
    // When KeyMgr operates, the secret key is not ready yet.
    StKeyMgrErrKeyNotValid = 10'b0111011111,

    StError = 10'b1110010111,
    StErrorAwaitSw = 10'b0110001100,
    StErrorAwaitApp = 10'b1011100000,
    StErrorWaitAbsorbed = 10'b0010100100,
    StErrorServiceRejected = 10'b1101000111,

    // This state is used for terminal errors
    StTerminalError = 10'b0101110110
  } st_e;

  /////////////
  // Signals //
  /////////////

  st_e st, st_d;

  logic keymgr_key_used;

  // app_rsp_t signals
  // The state machine controls mux selection, which controls the ready signal
  // the other responses are controled in separate logic. So define the signals
  // here and merge them to the response.
  logic app_data_ready, fsm_data_ready;
  logic app_digest_done, fsm_digest_done_q, fsm_digest_done_d;
  logic [AppDigestW-1:0] app_digest [2];

  // One more slot for value NumAppIntf. It is the value when no app intf is
  // chosen.
  localparam int unsigned AppIdxW = $clog2(NumAppIntf);

  // app_id indicates, which app interface was chosen. various logic use this
  // value to get the config or return the data.
  logic [AppIdxW-1:0] app_id, app_id_d;
  logic               clr_appid, set_appid;

  // Output length
  logic [OutLenW-1:0] encoded_outlen, encoded_outlen_mask;

  // state output
  // Mux selection signal
  app_mux_sel_e mux_sel;
  app_mux_sel_e mux_sel_buf_output;
  app_mux_sel_e mux_sel_buf_err_check;
  app_mux_sel_e mux_sel_buf_kmac;

  // Error checking logic

  kmac_pkg::err_t fsm_err, mux_err;

  logic service_rejected_error;
  logic service_rejected_error_set, service_rejected_error_clr;
  logic err_during_sw_d, err_during_sw_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni)                         service_rejected_error <= 1'b 0;
    else if (service_rejected_error_set) service_rejected_error <= 1'b 1;
    else if (service_rejected_error_clr) service_rejected_error <= 1'b 0;
  end

  ////////////////////////////
  // Application Mux/ Demux //
  ////////////////////////////


  // Processing return data.
  // sends to only selected app intf.
  // clear digest right after done to not leak info to other interface
  always_comb begin
    for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
      if (i == app_id) begin
        app_o[i] = '{
          ready:         app_data_ready | fsm_data_ready,
          done:          app_digest_done | fsm_digest_done_q,
          digest_share0: app_digest[0],
          digest_share1: app_digest[1],
          // if fsm asserts done, should be an error case.
          error:         error_i | fsm_digest_done_q | sparse_fsm_error_o
                         | service_rejected_error
        };
      end else begin
        app_o[i] = '{
          ready: 1'b 0,
          done:  1'b 0,
          digest_share0: '0,
          digest_share1: '0,
          error: 1'b 0
        };
      end
    end // for {i, NumAppIntf, i++}
  end // aiways_comb

  // app_id latch
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) app_id <= AppIdxW'(0) ; // Do not select any
    else if (clr_appid) app_id <= AppIdxW'(0);
    else if (set_appid) app_id <= app_id_d;
  end

  // app_id selection as of now, app_id uses Priority. The assumption is that
  //  the request normally does not collide. (ROM_CTRL activates very early
  //  stage at the boot sequence)
  //
  //  If this assumption is not true, consider RR arbiter.

  // Prep for arbiter
  logic [NumAppIntf-1:0] app_reqs;
  logic [NumAppIntf-1:0] unused_app_gnts;
  logic [$clog2(NumAppIntf)-1:0] arb_idx;
  logic arb_valid;
  logic arb_ready;

  always_comb begin
    app_reqs = '0;
    for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
      app_reqs[i] = app_i[i].valid;
    end
  end

  prim_arbiter_fixed #(
    .N (NumAppIntf),
    .DW(1),
    .EnDataPort(1'b 0)
  ) u_appid_arb (
    .clk_i,
    .rst_ni,

    .req_i  (app_reqs),
    .data_i ('{default:'0}),
    .gnt_o  (unused_app_gnts),
    .idx_o  (arb_idx),

    .valid_o (arb_valid),
    .data_o  (), // not used
    .ready_i (arb_ready)
  );

  assign app_id_d = AppIdxW'(arb_idx);
  assign arb_ready = set_appid;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) fsm_digest_done_q <= 1'b 0;
    else         fsm_digest_done_q <= fsm_digest_done_d;
  end

  /////////
  // FSM //
  /////////

  // State register
  `PRIM_FLOP_SPARSE_FSM(u_state_regs, st_d, st, st_e, StIdle)

  // Create a lint error to reduce the risk of accidentally enabling this feature.
  `ASSERT_STATIC_LINT_ERROR(KmacSecIdleAcceptSwMsgNonDefault, SecIdleAcceptSwMsg == 0)

  // Next State & output logic
  // SEC_CM: FSM.SPARSE
  always_comb begin
    st_d = st;

    mux_sel = SecIdleAcceptSwMsg ? SelSw : SelNone;

    // app_id control
    set_appid = 1'b 0;
    clr_appid = 1'b 0;

    // Commands
    cmd_o = CmdNone;

    // Software output
    absorbed_o = prim_mubi_pkg::MuBi4False;

    // Error
    fsm_err = '{valid: 1'b 0, code: ErrNone, info: '0};
    sparse_fsm_error_o = 1'b 0;

    clear_after_error_o = prim_mubi_pkg::MuBi4False;

    service_rejected_error_set = 1'b 0;
    service_rejected_error_clr = 1'b 0;

    // If error happens, FSM asserts data ready but discard incoming msg
    fsm_data_ready = 1'b 0;
    fsm_digest_done_d = 1'b 0;

    unique case (st)
      StIdle: begin
        if (arb_valid) begin
          st_d = StAppCfg;

          // choose app_id
          set_appid = 1'b 1;
        end else if (sw_cmd_i == CmdStart) begin
          st_d = StSw;
          // Software initiates the sequence
          cmd_o = CmdStart;
        end else begin
          st_d = StIdle;
        end
      end

      StAppCfg: begin
        if (AppCfg[app_id].Mode == AppKMAC &&
          prim_mubi_pkg::mubi4_test_false_strict(entropy_ready_i)) begin
          // Check if the entropy is not configured but it is needed in
          // `AppCfg[app_id]` (KMAC mode).
          //
          // SW is not properly configured, report and not request Hashing
          // Return the app with errors
          st_d = StError;

          service_rejected_error_set = 1'b 1;

        end else begin
          // As Cfg is stable now, it sends cmd
          st_d = StAppMsg;

          // App initiates the data
          cmd_o = CmdStart;
        end
      end

      StAppMsg: begin
        mux_sel = SelApp;
        if (app_i[app_id].valid && app_o[app_id].ready && app_i[app_id].last) begin
          if (AppCfg[app_id].Mode == AppKMAC) begin
            st_d = StAppOutLen;
          end else begin
            st_d = StAppProcess;
          end
        end else begin
          st_d = StAppMsg;
        end
      end

      StAppOutLen: begin
        mux_sel = SelOutLen;

        if (kmac_valid_o && kmac_ready_i) begin
          st_d = StAppProcess;
        end else begin
          st_d = StAppOutLen;
        end
      end

      StAppProcess: begin
        cmd_o = CmdProcess;
        st_d = StAppWait;
      end

      StAppWait: begin
        if (prim_mubi_pkg::mubi4_test_true_strict(absorbed_i)) begin
          // Send digest to KeyMgr and complete the op
          st_d = StIdle;
          cmd_o = CmdDone;

          clr_appid = 1'b 1;
        end else begin
          st_d = StAppWait;
        end
      end

      StSw: begin
        mux_sel = SelSw;

        cmd_o = sw_cmd_i;
        absorbed_o = absorbed_i;

        if (sw_cmd_i == CmdDone) begin
          st_d = StIdle;
        end else begin
          st_d = StSw;
        end
      end

      StKeyMgrErrKeyNotValid: begin
        st_d = StError;

        // As mux_sel is not set to SelApp, app_data_ready is still 0.
        // This logic won't accept the requests from the selected App.
        fsm_err.valid = 1'b 1;
        fsm_err.code = ErrKeyNotValid;
        fsm_err.info = 24'(app_id);
      end

      StError: begin
        // In this state, the state machine flush out the request
        st_d = StError;

        // Absorb data on the app interface.
        fsm_data_ready = ~err_during_sw_q;

        // Next step depends on two conditions:
        // 1) Error being processed by SW
        // 2) Last data provided from the app interface (so that the app interface is completely)
        //    drained.  If the error occurred during a SW operation, the app interface is not
        //    involved, so this condition gets skipped.
        unique case ({err_processed_i,
                      (app_i[app_id].valid && app_i[app_id].last) || err_during_sw_q})
          2'b00: begin
            // Error not processed by SW and not last data from app interface -> keep current state.
            st_d = StError;
          end
          2'b01: begin
            // Error not processed by SW but last data from app interface:
            // 1. Send garbage digest to the app interface (in the next cycle) to complete the
            // transaction.
            fsm_digest_done_d = ~err_during_sw_q;
            if (service_rejected_error) begin
              // 2.a) Service was rejected because an app interface tried to configure KMAC while no
              // entropy was available. It is assumed that SW is not loaded yet, so don't wait for
              // SW to process the error. The last data from the app interface has now arrived, but
              // we don't need to wait for the SHA3 core to have absorbed it because the data never
              // entered the SHA3 core: the request from the app interface was terminated during the
              // configuration phase.
              st_d = StErrorServiceRejected;
            end else begin
              // 2.b) If service was not rejected, wait for SW to process the error.
              st_d = StErrorAwaitSw;
            end
          end
          2'b10: begin
            // Error processed by SW but not last data from app interface -> wait for app interface.
            st_d = StErrorAwaitApp;
          end
          2'b11: begin
            // Error processed by SW and last data from app interface:
            // Send garbage digest to the app interface (in the next cycle) to complete the
            // transaction.
            fsm_digest_done_d = ~err_during_sw_q;
            // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
            // but serves to bring the SHA3 engine back to the idle state).
            cmd_o = CmdProcess;
            st_d = StErrorWaitAbsorbed;
          end
          default: st_d = StError;
        endcase
      end

      StErrorAwaitSw: begin
        // Just wait for SW to process the error.
        if (err_processed_i) begin
          // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
          // but serves to bring the SHA3 engine back to the idle state).
          cmd_o = CmdProcess;
          st_d = StErrorWaitAbsorbed;
        end
      end

      StErrorAwaitApp: begin
        // Keep absorbing data on the app interface until the last data.
        fsm_data_ready = 1'b1;
        if (app_i[app_id].valid && app_i[app_id].last) begin
          // Send garbage digest to the app interface (in the next cycle) to complete the
          // transaction.
          fsm_digest_done_d = 1'b1;
          // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
          // but serves to bring the SHA3 engine back to the idle state).
          cmd_o = CmdProcess;
          st_d = StErrorWaitAbsorbed;
        end
      end

      StErrorWaitAbsorbed: begin
        if (prim_mubi_pkg::mubi4_test_true_strict(absorbed_i)) begin
          // Clear internal variables, send done command, and return to idle.
          clr_appid = 1'b1;
          clear_after_error_o = prim_mubi_pkg::MuBi4True;
          service_rejected_error_clr = 1'b1;
          cmd_o = CmdDone;
          st_d = StIdle;
          // If error originated from SW, report 'absorbed' to SW.
          if (err_during_sw_q) begin
            absorbed_o = prim_mubi_pkg::MuBi4True;
          end
        end
      end

      StErrorServiceRejected: begin
        // Clear internal variables and return to idle.
        clr_appid = 1'b1;
        clear_after_error_o = prim_mubi_pkg::MuBi4True;
        service_rejected_error_clr = 1'b1;
        st_d = StIdle;
      end

      StTerminalError: begin
        // this state is terminal
        st_d = st;
        sparse_fsm_error_o = 1'b 1;
        fsm_err.valid = 1'b 1;
        fsm_err.code = ErrFatalError;
        fsm_err.info = 24'(app_id);
      end

      default: begin
        st_d = StTerminalError;
        sparse_fsm_error_o = 1'b 1;
      end
    endcase

    // SEC_CM: FSM.GLOBAL_ESC, FSM.LOCAL_ESC
    // Unconditionally jump into the terminal error state
    // if the life cycle controller triggers an escalation.
    if (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) begin
      st_d = StTerminalError;
    end

    // Handle errors outside the terminal error state.
    if (st_d != StTerminalError) begin
      // Key from keymgr is used but not valid, so abort into the invalid key error state.
      if (keymgr_key_used && !keymgr_key_i.valid) begin
        st_d = StKeyMgrErrKeyNotValid;
      end
    end
  end

  // Track errors occurring in SW mode.
  assign err_during_sw_d =
      (mux_sel == SelSw) && (st_d inside {StError, StKeyMgrErrKeyNotValid}) ? 1'b1 : // set
      (st_d == StIdle)                                                      ? 1'b0 : // clear
      err_during_sw_q;                                                               // hold

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      err_during_sw_q <= 1'b0;
    end else begin
      err_during_sw_q <= err_during_sw_d;
    end
  end

  //////////////
  // Datapath //
  //////////////

  // Encoded output length
  assign encoded_outlen      = EncodedOutLen[SelDigSize];
  assign encoded_outlen_mask = EncodedOutLenMask[SelKeySize];

  // Data mux
  // This is the main part of the KeyMgr interface logic.
  // The FSM selects KeyMgr interface in a cycle after it receives the first
  // valid data from KeyMgr. The ready signal to the KeyMgr data interface
  // represents the MSG_FIFO ready, only when it is in StKeyMgrMsg state.
  // After KeyMgr sends last beat, the kmac interface (to MSG_FIFO) is switched
  // to OutLen. OutLen is pre-defined values. See `EncodeOutLen` parameter above.
  always_comb begin
    app_data_ready = 1'b 0;
    sw_ready_o = 1'b 1;

    kmac_valid_o = 1'b 0;
    kmac_data_o = '0;
    kmac_mask_o = '0;

    unique case (mux_sel_buf_kmac)
      SelApp: begin
        // app_id is valid at this time
        kmac_valid_o = app_i[app_id].valid;
        kmac_data_o  = app_i[app_id].data;
        // Expand strb to bits. prim_packer inside MSG_FIFO accepts the bit masks
        for (int i = 0 ; i < $bits(app_i[app_id].strb) ; i++) begin
          kmac_mask_o[8*i+:8] = {8{app_i[app_id].strb[i]}};
        end
        app_data_ready = kmac_ready_i;
      end

      SelOutLen: begin
        // Write encoded output length value
        kmac_valid_o = 1'b 1; // always write
        kmac_data_o  = MsgWidth'(encoded_outlen);
        kmac_mask_o  = MsgWidth'(encoded_outlen_mask);
      end

      SelSw: begin
        kmac_valid_o = sw_valid_i;
        kmac_data_o  = sw_data_i ;
        kmac_mask_o  = sw_mask_i ;
        sw_ready_o   = kmac_ready_i ;
      end

      default: begin // Incl. SelNone
        kmac_valid_o = 1'b 0;
        kmac_data_o = '0;
        kmac_mask_o = '0;
      end

    endcase
  end

  // Error checking for Mux
  always_comb begin
    mux_err = '{valid: 1'b 0, code: ErrNone, info: '0};

    if (mux_sel_buf_err_check != SelSw && sw_valid_i) begin
      // If SW writes message into FIFO
      mux_err = '{
        valid: 1'b 1,
        code: ErrSwPushedMsgFifo,
        info: 24'({8'h 00, 8'(st), 8'(mux_sel_buf_err_check)})
      };
    end else if (app_active_o && sw_cmd_i != CmdNone) begin
      // If SW issues command except start
      mux_err = '{
        valid: 1'b 1,
        code: ErrSwIssuedCmdInAppActive,
        info: 24'(sw_cmd_i)
      };
    end
  end

  logic [AppMuxWidth-1:0] mux_sel_buf_output_logic;
  assign mux_sel_buf_output = app_mux_sel_e'(mux_sel_buf_output_logic);

  // SEC_CM: LOGIC.INTEGRITY
  prim_sec_anchor_buf #(
   .Width(AppMuxWidth)
  ) u_prim_buf_state_output_sel (
    .in_i(mux_sel),
    .out_o(mux_sel_buf_output_logic)
  );

  logic [AppMuxWidth-1:0] mux_sel_buf_err_check_logic;
  assign mux_sel_buf_err_check = app_mux_sel_e'(mux_sel_buf_err_check_logic);

  // SEC_CM: LOGIC.INTEGRITY
  prim_sec_anchor_buf #(
   .Width(AppMuxWidth)
  ) u_prim_buf_state_err_check (
    .in_i(mux_sel),
    .out_o(mux_sel_buf_err_check_logic)
  );

  logic [AppMuxWidth-1:0] mux_sel_buf_kmac_logic;
  assign mux_sel_buf_kmac = app_mux_sel_e'(mux_sel_buf_kmac_logic);

  // SEC_CM: LOGIC.INTEGRITY
  prim_sec_anchor_buf #(
   .Width(AppMuxWidth)
  ) u_prim_buf_state_kmac_sel (
    .in_i(mux_sel),
    .out_o(mux_sel_buf_kmac_logic)
  );

  // SEC_CM: LOGIC.INTEGRITY
  logic reg_state_valid;
  prim_sec_anchor_buf #(
   .Width(1)
  ) u_prim_buf_state_output_valid (
    .in_i(reg_state_valid),
    .out_o(reg_state_valid_o)
  );

  // Keccak state Demux
  // Keccak state --> Register output is enabled when state is in StSw
  always_comb begin
    reg_state_valid = 1'b 0;
    reg_state_o = '{default:'0};
    if ((mux_sel_buf_output == SelSw) &&
         lc_ctrl_pkg::lc_tx_test_false_strict(lc_escalate_en_i)) begin
      reg_state_valid = keccak_state_valid_i;
      reg_state_o = keccak_state_i;
      // If key is sideloaded and KMAC is SW initiated
      // hide the capacity from SW by zeroing (see #17508)
      if (keymgr_key_en_i) begin
        for (int i = 0; i < Share; i++) begin
          unique case (reg_keccak_strength_i)
            L128: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L128]] = '0;
            L224: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L224]] = '0;
            L256: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L256]] = '0;
            L384: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L384]] = '0;
            L512: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L512]] = '0;
            default: reg_state_o[i] = '0;
          endcase
        end
      end
    end
  end

  // Keccak state --> KeyMgr
  always_comb begin
    app_digest_done = 1'b 0;
    app_digest = '{default:'0};
    if (st == StAppWait && prim_mubi_pkg::mubi4_test_true_strict(absorbed_i) &&
       lc_ctrl_pkg::lc_tx_test_false_strict(lc_escalate_en_i)) begin
      // SHA3 engine has calculated the hash. Return the data to KeyMgr
      app_digest_done = 1'b 1;

      // digest has always 2 entries. If !EnMasking, second is tied to 0.
      for (int i = 0 ; i < Share ; i++) begin
        // Return the portion of state.
        app_digest[i] = keccak_state_i[i][AppDigestW-1:0];
      end
    end
  end


  // Secret Key Mux

  // Prepare merged key if EnMasking is not set.
  // Combine share keys into unpacked array for logic below to assign easily.
  // SEC_CM: KEY.SIDELOAD
  logic [MaxKeyLen-1:0] keymgr_key [Share];
  if (EnMasking == 1) begin : g_masked_key
    for (genvar i = 0; i < Share; i++) begin : gen_key_pad
      assign keymgr_key[i] =  {(MaxKeyLen-KeyMgrKeyW)'(0), keymgr_key_i.key[i]};
    end
  end else begin : g_unmasked_key
    always_comb begin
      keymgr_key[0] = '0;
      for (int i = 0; i < keymgr_pkg::Shares; i++) begin
        keymgr_key[0][KeyMgrKeyW-1:0] ^= keymgr_key_i.key[i];
      end
    end
  end

  // Sideloaded key manage: Keep use sideloaded key for KMAC AppIntf until the
  // hashing operation is finished.
  always_comb begin
    keymgr_key_used = 1'b0;
    key_len_o  = reg_key_len_i;
    for (int i = 0 ; i < Share; i++) begin
      key_data_o[i] = reg_key_data_i[i];
    end
    // The key is considered invalid in all cases that are not listed below (which includes idle and
    // error states).
    key_valid_o = 1'b0;

    unique case (st)
      StAppCfg, StAppMsg, StAppOutLen, StAppProcess, StAppWait: begin
        // Key from keymgr is actually used if the current HW app interface does *keyed* MAC.
        keymgr_key_used = AppCfg[app_id].Mode == AppKMAC;
        key_len_o = SideloadedKey;
        for (int i = 0 ; i < Share; i++) begin
          key_data_o[i] = keymgr_key[i];
        end
        // Key is valid if the current HW app interface does *keyed* MAC and the key provided by
        // keymgr is valid.
        key_valid_o = keymgr_key_used && keymgr_key_i.valid;
      end

      StSw: begin
        if (keymgr_key_en_i) begin
          // Key from keymgr is actually used if *keyed* MAC is enabled.
          keymgr_key_used = kmac_en_o;
          key_len_o = SideloadedKey;
          for (int i = 0 ; i < Share; i++) begin
            key_data_o[i] = keymgr_key[i];
          end
        end
        // Key is valid if SW does *keyed* MAC and ...
        if (kmac_en_o) begin
          if (!keymgr_key_en_i) begin
            // ... it uses the key from kmac's CSR, or ...
            key_valid_o = 1'b1;
          end else begin
            // ... it uses the key provided by keymgr and that one is valid.
            key_valid_o = keymgr_key_i.valid;
          end
        end
      end

      default: ;
    endcase
  end

  // Prefix Demux
  // For SW, always prefix register.
  // For App intf, check PrefixMode cfg and if 1, use Prefix cfg.
  always_comb begin
    sha3_prefix_o = '0;

    unique case (st)
      StAppCfg, StAppMsg, StAppOutLen, StAppProcess, StAppWait: begin
        // Check app intf cfg
        for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
          if (app_id == i) begin
            if (AppCfg[i].PrefixMode == 1'b 0) begin
              sha3_prefix_o = reg_prefix_i;
            end else begin
              sha3_prefix_o = AppCfg[i].Prefix;
            end
          end
        end
      end

      StSw: begin
        sha3_prefix_o = reg_prefix_i;
      end

      default: begin
        sha3_prefix_o = reg_prefix_i;
      end
    endcase
  end

  // KMAC en / SHA3 mode / Strength
  //  by default, it uses reg cfg. When app intf reqs come, it uses AppCfg.
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      kmac_en_o         <= 1'b 0;
      sha3_mode_o       <= sha3_pkg::Sha3;
      keccak_strength_o <= sha3_pkg::L256;
    end else if (clr_appid) begin
      // As App completed, latch reg value
      kmac_en_o         <= reg_kmac_en_i;
      sha3_mode_o       <= reg_sha3_mode_i;
      keccak_strength_o <= reg_keccak_strength_i;
    end else if (set_appid) begin
      kmac_en_o         <= AppCfg[arb_idx].Mode == AppKMAC ? 1'b 1 : 1'b 0;
      sha3_mode_o       <= AppCfg[arb_idx].Mode == AppSHA3
                           ? sha3_pkg::Sha3 : sha3_pkg::CShake;
      keccak_strength_o <= AppCfg[arb_idx].Strength ;
    end else if (st == StIdle) begin
      kmac_en_o         <= reg_kmac_en_i;
      sha3_mode_o       <= reg_sha3_mode_i;
      keccak_strength_o <= reg_keccak_strength_i;
    end
  end

  // Status
  assign app_active_o = (st inside {StAppCfg, StAppMsg, StAppOutLen,
                                    StAppProcess, StAppWait});

  // Error Reporting ==========================================================
  always_comb begin
    priority casez ({fsm_err.valid, mux_err.valid})
      2'b ?1: error_o = mux_err;
      2'b 10: error_o = fsm_err;
      default: error_o = '{valid: 1'b0, code: ErrNone, info: '0};
    endcase
  end

  ////////////////
  // Assertions //
  ////////////////

  // KeyMgr sideload key and the digest should be in the Key Length value
  `ASSERT_INIT(SideloadKeySameToDigest_A, KeyMgrKeyW <= AppDigestW)
  `ASSERT_INIT(AppIntfInRange_A, AppDigestW inside {128, 192, 256, 384, 512})

  // Issue(#13655): Having a coverage that sideload keylen and CSR keylen are
  // different.
  `COVER(AppIntfUseDifferentSizeKey_C,
    (st == StAppCfg && kmac_en_o) |-> reg_key_len_i != SideloadedKey)

endmodule

    '''

    Use the anomaly detector tool to identify lines in the design RTL that are anomalous.
    Then determine whether the identified anomalous line(s) represent a security issue or not.

    
================================== Ai Message ==================================
Tool Calls:
  anomaly_detector_tool (call_5275uvEYGOGOVnl4vW0nP1cs)
 Call ID: call_5275uvEYGOGOVnl4vW0nP1cs
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_app.sv
================================= Tool Message =================================
Name: anomaly_detector_tool

Successfully executed:
```LLM Anomaly Detector tool
```
Output:
Here are clusters of similar verilog constructs in the RTL file:



Cluster 0:
assign app_id_d = AppIdxW'(arb_idx);
assign arb_ready = set_appid;


Cluster 1:
assign encoded_outlen      = EncodedOutLen[SelDigSize];
assign encoded_outlen_mask = EncodedOutLenMask[SelKeySize];


Cluster 2:
assign mux_sel_buf_output = app_mux_sel_e'(mux_sel_buf_output_logic);
assign mux_sel_buf_err_check = app_mux_sel_e'(mux_sel_buf_err_check_logic);
assign mux_sel_buf_kmac = app_mux_sel_e'(mux_sel_buf_kmac_logic);

================================== Ai Message ==================================

Based on the anomaly detection tool, the RTL code has the following sets of similar constructs grouped into clusters. There are no specific standalone anomalous lines flagged that would clearly indicate suspicious or unusual patterns.

The clusters show typical assignments and synthesis-friendly coding styles including mux selection and encoded length derivations. These do not on their own suggest code anomalies.

After reviewing the code and the detected clusters, here are security considerations regarding:

- **Application Interface Isolation:**  
  The module manages multiple application interfaces (NumAppIntf) with an arbiter and exclusive selection of the active interface (via app_id). The code ensures that only the selected app interface is granted access and the outputs to other interfaces are zeroed. This prevents data leakage between interfaces, indicating proper isolation mechanism.

- **Privilege Escalation:**  
  The state machine explicitly manages software and app initiated commands with exclusive states (e.g., StSw for SW, StAppCfg etc. for app). The lifecycle escalation input (lc_escalate_en_i) immediately forces the FSM into a terminal error state, preventing further operations during escalation. This mechanism helps protect against unauthorized privilege escalations due to lifecycle changes.

- **Command Injection:**  
  Inputs from software (sw_cmd_i, sw_valid_i, sw_data_i) and app interfaces (app_i) are carefully controlled through the FSM states. The design uses an arbiter to choose the app interface, and has error states to handle invalid conditions. Additionally, there are checks that reject software commands when the app interface is active and vice versa, reducing the risk of injecting unauthorized commands. The error handling FSM states handle invalid usage gracefully.

No anomalous constructs that indicate direct security issues like unprotected inputs, unsafe state transitions or data leakage were found. The code uses buffers and registers for controlling mux selection and state variables securely.

### Conclusion:

- The RTL design includes proper mechanisms for application interface isolation, preventing cross-interface data leakage.
- It has state machine based controls to avoid privilege escalation, handling lifecycle escalations securely.
- Command injection attacks are mitigated by FSM control, proper arbitration, and error handling states that reject conflicting commands.
- No anomalous or suspicious lines were flagged that represent a security vulnerability according to the anomaly detector output.

The reviewed RTL design appears to be secure against application interface isolation breaches, privilege escalation, and command injection vulnerabilities given the current code excerpt.
================================= Tool Message =================================
Name: run_anomaly_detector_agent

Based on the anomaly detection tool, the RTL code has the following sets of similar constructs grouped into clusters. There are no specific standalone anomalous lines flagged that would clearly indicate suspicious or unusual patterns.

The clusters show typical assignments and synthesis-friendly coding styles including mux selection and encoded length derivations. These do not on their own suggest code anomalies.

After reviewing the code and the detected clusters, here are security considerations regarding:

- **Application Interface Isolation:**  
  The module manages multiple application interfaces (NumAppIntf) with an arbiter and exclusive selection of the active interface (via app_id). The code ensures that only the selected app interface is granted access and the outputs to other interfaces are zeroed. This prevents data leakage between interfaces, indicating proper isolation mechanism.

- **Privilege Escalation:**  
  The state machine explicitly manages software and app initiated commands with exclusive states (e.g., StSw for SW, StAppCfg etc. for app). The lifecycle escalation input (lc_escalate_en_i) immediately forces the FSM into a terminal error state, preventing further operations during escalation. This mechanism helps protect against unauthorized privilege escalations due to lifecycle changes.

- **Command Injection:**  
  Inputs from software (sw_cmd_i, sw_valid_i, sw_data_i) and app interfaces (app_i) are carefully controlled through the FSM states. The design uses an arbiter to choose the app interface, and has error states to handle invalid conditions. Additionally, there are checks that reject software commands when the app interface is active and vice versa, reducing the risk of injecting unauthorized commands. The error handling FSM states handle invalid usage gracefully.

No anomalous constructs that indicate direct security issues like unprotected inputs, unsafe state transitions or data leakage were found. The code uses buffers and registers for controlling mux selection and state variables securely.

### Conclusion:

- The RTL design includes proper mechanisms for application interface isolation, preventing cross-interface data leakage.
- It has state machine based controls to avoid privilege escalation, handling lifecycle escalations securely.
- Command injection attacks are mitigated by FSM control, proper arbitration, and error handling states that reject conflicting commands.
- No anomalous or suspicious lines were flagged that represent a security vulnerability according to the anomaly detector output.

The reviewed RTL design appears to be secure against application interface isolation breaches, privilege escalation, and command injection vulnerabilities given the current code excerpt.
================================== Ai Message ==================================
Tool Calls:
  run_assertions_checker_agent (call_o76GGDeK0hhsFqe8Z484lR3k)
 Call ID: call_o76GGDeK0hhsFqe8Z484lR3k
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_core.sv
    top_module: kmac_core
    security_objective: FSM hardening, masking, key handling
================================ Human Message =================================

Are there security concerns related to FSM hardening, masking, key handling in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_core.sv

    And the top module is:

    kmac_core

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// KMAC control and padding logic

`include "prim_assert.sv"

module kmac_core
  import kmac_pkg::*;
#(
  // EnMasking: Enable masking security hardening inside keccak_round
  // If it is enabled, the result digest will be two set of 1600bit.
  parameter  bit EnMasking = 0,
  localparam int Share = (EnMasking) ? 2 : 1 // derived parameter
) (
  input clk_i,
  input rst_ni,

  // From Message FIFO
  input                fifo_valid_i,
  input [MsgWidth-1:0] fifo_data_i [Share],
  input [MsgStrbW-1:0] fifo_strb_i,
  output logic         fifo_ready_o,

  // to SHA3 Core
  output logic                msg_valid_o,
  output logic [MsgWidth-1:0] msg_data_o  [Share],
  output logic [MsgStrbW-1:0] msg_strb_o,
  input                       msg_ready_i,

  // Configurations

  // If kmac_en is cleared, Core logic doesn't function but forward incoming
  // message to SHA3 core
  input                             kmac_en_i,
  input sha3_pkg::sha3_mode_e       mode_i,
  input sha3_pkg::keccak_strength_e strength_i,

  // Key input from CSR
  input [MaxKeyLen-1:0] key_data_i [Share],
  input key_len_e       key_len_i,
  input logic           key_valid_i,

  // Controls : same to SHA3 core
  input start_i,
  input process_i,
  input prim_mubi_pkg::mubi4_t done_i,

  // Control to SHA3 core
  output logic process_o,

  // Life cycle
  input  lc_ctrl_pkg::lc_tx_t lc_escalate_en_i,

  output logic sparse_fsm_error_o,
  output logic key_index_error_o
);

  import sha3_pkg::KeccakMsgAddrW;
  import sha3_pkg::KeccakCountW;
  import sha3_pkg::KeccakRate;
  import sha3_pkg::L128;
  import sha3_pkg::L224;
  import sha3_pkg::L256;
  import sha3_pkg::L384;
  import sha3_pkg::L512;

  /////////////////
  // Definitions //
  /////////////////

  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 3 -m 5 -n 6 \
  //      -s 401658243 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: |||||||||||||||||||| (50.00%)
  //  4: |||||||||||||||| (40.00%)
  //  5: |||| (10.00%)
  //  6: --
  //
  // Minimum Hamming distance: 3
  // Maximum Hamming distance: 5
  // Minimum Hamming weight: 1
  // Maximum Hamming weight: 4
  //
  localparam int StateWidth = 6;
  typedef enum logic [StateWidth-1:0] {
    StKmacIdle = 6'b011000,

    // Secret Key pushing stage
    // The key is sliced by prim_slicer. This state pushes the sliced data into
    // SHA3 hashing engine. When it hits the block size limit,
    // (same as in sha3pad) the state machine moves to Message.
    StKey = 6'b010111,

    // Incoming Message
    // The core does nothing but forwarding the incoming message to SHA3 hashing
    // engine by turning off `en_kmac_datapath`.
    StKmacMsg = 6'b001110,

    // Wait till done signal
    StKmacFlush = 6'b101011,

    // Terminal Error
    StTerminalError = 6'b100000
  } kmac_st_e ;

  /////////////
  // Signals //
  /////////////

  // represents encode_string(K)
  logic [MaxEncodedKeyW-1:0] encoded_key [Share];

  // Key slice address
  // This signal controls the 64 bit output of the sliced secret_key.
  logic [sha3_pkg::KeccakMsgAddrW-1:0] key_index;
  logic inc_keyidx, clr_keyidx;

  // `sent_blocksize` indicates that the encoded key is sent to sha3 hashing
  // engine. If this hits at StKey stage, the state moves to message state.
  logic [sha3_pkg::KeccakCountW-1:0] block_addr_limit;
  logic sent_blocksize;

  // Internal message signals
  logic                kmac_valid       ;
  logic [MsgWidth-1:0] kmac_data [Share];
  logic [MsgStrbW-1:0] kmac_strb        ;

  // Control SHA3 core
  // `kmac_process` is to forward the process signal to SHA3 core only after
  // the KMAC core writes the key block in case of the message is empty.
  // If the incoming message is empty, there's chance that the `process_i`
  // signal can be asserted while KMAC core processing the key block.
  logic kmac_process, process_latched;

  // Indication of Secret key write stage. Only in this stage, the internal
  // message interface is active.
  logic en_key_write;
  logic en_kmac_datapath;

  // Encoded key has wider bits. `key_sliced` is the data to send to sha3
  logic [MsgWidth-1:0] key_sliced [Share];

  // The following signals are only used in assertions.
  logic unused_signals;
  assign unused_signals = ^{mode_i, key_valid_i};

  /////////
  // FSM //
  /////////
  kmac_st_e st, st_d;

  // State register
  `PRIM_FLOP_SPARSE_FSM(u_state_regs, st_d, st, kmac_st_e, StKmacIdle)

  // Next state and output logic
  // SEC_CM: FSM.SPARSE
  always_comb begin
    st_d = st;

    en_kmac_datapath = 1'b 0;
    en_key_write = 1'b 0;

    clr_keyidx = 1'b 0;

    kmac_valid = 1'b 0;
    kmac_process = 1'b 0;

    sparse_fsm_error_o = 1'b 0;

    unique case (st)
      StKmacIdle: begin
        if (kmac_en_i && start_i) begin
          st_d = StKey;
        end else begin
          st_d = StKmacIdle;
        end
      end

      // If State enters here, regardless of the `process_i`, the state writes
      // full block size of the key into SHA3 hashing engine.
      StKey: begin
        en_kmac_datapath = 1'b 1;
        en_key_write = 1'b 1;

        if (sent_blocksize) begin
          st_d = StKmacMsg;

          kmac_valid = 1'b 0;
          clr_keyidx = 1'b 1;
        end else begin
          st_d = StKey;

          kmac_valid = 1'b 1;
        end
      end

      StKmacMsg: begin
        // If process is previously latched, it is sent to SHA3 here.
        if (process_i || process_latched) begin
          st_d = StKmacFlush;

          kmac_process = 1'b 1;
        end else begin
          st_d = StKmacMsg;
        end
      end

      StKmacFlush: begin
        if (prim_mubi_pkg::mubi4_test_true_strict(done_i)) begin
          st_d = StKmacIdle;
        end else begin
          st_d = StKmacFlush;
        end
      end

      StTerminalError: begin
        // this state is terminal
        st_d = st;
        sparse_fsm_error_o = 1'b 1;
      end

      default: begin
        // this state is terminal
        st_d = StTerminalError;
        sparse_fsm_error_o = 1'b 1;
      end
    endcase

    // SEC_CM: FSM.GLOBAL_ESC, FSM.LOCAL_ESC
    // Unconditionally jump into the terminal error state
    // if the life cycle controller triggers an escalation.
    if (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) begin
      st_d = StTerminalError;
    end
  end

  //////////////
  // Datapath //
  //////////////

  // DATA Mux depending on kmac_en
  // When Key write happens, hold the FIFO request. so fifo_ready_o is tied to 0
  assign msg_valid_o  = (en_kmac_datapath) ? kmac_valid : fifo_valid_i;
  assign msg_data_o   = (en_kmac_datapath) ? kmac_data  : fifo_data_i ;
  assign msg_strb_o   = (en_kmac_datapath) ? kmac_strb  : fifo_strb_i ;
  assign fifo_ready_o = (en_kmac_datapath) ? 1'b 0      : msg_ready_i ;

  // secret key write request to SHA3 hashing engine is always full width write.
  // KeyMgr is fixed 256 bit output. So `right_encode(256)` is 0x020100 --> strb 3
  assign kmac_strb = (en_key_write ) ? '1 : '0;

  assign kmac_data = (en_key_write) ? key_sliced : '{default:'0};

  // Process is controlled by the KMAC core always.
  // This is mainly to prevent process_i asserted while KMAC core is writing
  // the secret key to SHA3 hashing engine (the empty message case)
  assign process_o = (kmac_en_i) ? kmac_process : process_i ;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      process_latched <= 1'b 0;
    end else if (process_i && !process_o) begin
      process_latched <= 1'b 1;
    end else if (process_o ||
      prim_mubi_pkg::mubi4_test_true_strict(done_i)) begin
      process_latched <= 1'b 0;
    end
  end

  // bytepad(encode_string(K), 168 or 136) =====================================
  // 1. Prepare left_encode(w)
  // 2. Prepare left_encode(len(secret_key))
  // 3. Concatenate left_encode(len(secret_key)) || secret_key
  // 4. Concaatenate left_encode(w) || encode_string(secret_key)
  // 5. Based on the address, slice out the data into MsgWidth bits

  // left_encode(w): Same as used in sha3pad logic.
  logic [15:0] encode_bytepad;
  assign encode_bytepad = sha3_pkg::encode_bytepad_len(strength_i);

  // left_encode(len(secret_key))
  // encoded length is always byte size. Use MaxEncodedKeyLenByte parameter
  // from kmac_pkg and add one more byte to indicate how many bytes used to
  // represent len(secret_key)
  // Note that if the secret_key is 128 bit, only lower 16 bits of
  // `encode_keylen` are valid. Refer `encoded_key` concatenation logic below.
  // As the encoded string in the spec big-endian, The endian swap is a must.
  logic [MaxEncodedKeyLenSize + 8 - 1:0] encode_keylen [Share];

  always_comb begin
    // the spec mentioned the key length is encoded in left_encode()
    // The number is represented in big-endian. For example:
    // 384 ==> 0x02 0x01 0x80
    // The first byte is the number of bytes to represent 384
    // The second byte represents 2**8 number, which is 256 here.
    // The third byte represents 2**0 number, which is 128.
    // The data put into MsgFIFO is little-endian and SHA3(Keccak) processes in
    // little-endian. So, below keylen swaps the byte order
    unique case (key_len_i)
      //                           endian-swapped key_length          num_bytes
      // Key128: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(128)}}, 8'h 01};
      // Key192: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(192)}}, 8'h 01};
      // Key256: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(256)}}, 8'h 02};
      // Key384: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(384)}}, 8'h 02};
      // Key512: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(512)}}, 8'h 02};

      // Vivado does not support stream swap for non context value. So assign
      // the value directly.
      Key128: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 0080_01);
      Key192: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 00C0_01);
      Key256: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 0001_02);
      Key384: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 8001_02);
      Key512: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 0002_02);
      default: encode_keylen[0] = '0;
    endcase
  end

  if (EnMasking) begin: gen_encode_keylen_masked
    assign encode_keylen[1] = '0;
  end

  // encode_string(secret_key): Concatenate key
  // Based on the left_encode(len(secret_key)) size, the concatenation logic
  // should be changed. If key length is 128 bit, only lower 16 bits of the
  // encoded length are used so that the upper 8 bits are padded with 0 as
  // defined in bytepad() function.

  for (genvar i = 0 ; i < Share; i++) begin : gen_encoded_key
    always_comb begin
      unique case (key_len_i)
        // In Key 128, 192 case, only lower parts of encode_keylen signal is
        // used. So upper padding requires 8 more bits than MaxKeyLen - keylen
        Key128: encoded_key[i] = {(8 + MaxKeyLen - 128)'(0),
                                  key_data_i[i][0+:128],
                                  encode_keylen[i][0+:MaxEncodedKeyLenSize]};

        Key192: encoded_key[i] = {(8 + MaxKeyLen - 192)'(0),
                                  key_data_i[i][0+:192],
                                  encode_keylen[i][0+:MaxEncodedKeyLenSize]};

        Key256: encoded_key[i] = {(MaxKeyLen - 256)'(0),
                                  key_data_i[i][0+:256],
                                  encode_keylen[i]};

        Key384: encoded_key[i] = {(MaxKeyLen - 384)'(0),
                                  key_data_i[i][0+:384],
                                  encode_keylen[i]};

        // Assume 512bit is the MaxKeyLen
        Key512: encoded_key[i] = {key_data_i[i][0+:512],
                                  encode_keylen[i]};

        default: encoded_key[i] = '0;
      endcase
    end
  end : gen_encoded_key

  // Above logic assumes MaxKeyLen as 512 bits. Revise if it is not.
  `ASSERT_INIT(MaxKeyLenMatchToKey512_A, kmac_pkg::MaxKeyLen == 512)

  // Combine the bytepad `left_encode(w)` and the `encode_string(secret_key)`
  logic [MaxEncodedKeyW + 16 -1 :0] encoded_key_block [Share];

  assign encoded_key_block[0] = {encoded_key[0], encode_bytepad};

  if (EnMasking) begin : gen_encoded_key_block_masked
    assign encoded_key_block[1] = {encoded_key[1], 16'h 0};
  end

  // Slicer to slice out 64 bits
  for (genvar i = 0 ; i < Share ; i++) begin : gen_key_slicer
    prim_slicer #(
      .InW (MaxEncodedKeyW+16),
      .IndexW(KeccakMsgAddrW),
      .OutW(MsgWidth)
    ) u_key_slicer (
      .sel_i  (key_index),
      .data_i (encoded_key_block[i]),
      .data_o (key_sliced[i])
    );
  end

  // `key_index` logic
  // key_index is used to select MsgWidth data from long `encoded_key_block`
  // It behaves same as `keccak_addr` or `prefix_index` in sha3pad module.
  assign inc_keyidx = kmac_valid & msg_ready_i ;

  // This primitive is used to place a hardened counter
  // SEC_CM: CTR.REDUN
  prim_count #(
    .Width(sha3_pkg::KeccakMsgAddrW)
  ) u_key_index_count (
    .clk_i,
    .rst_ni,
    .clr_i(clr_keyidx),
    .set_i(1'b0),
    .set_cnt_i('0),
    .incr_en_i(inc_keyidx),
    .decr_en_i(1'b0),
    .step_i(sha3_pkg::KeccakMsgAddrW'(1)),
    .commit_i(1'b1),
    .cnt_o(key_index),
    .cnt_after_commit_o(),
    .err_o(key_index_error_o)
  );

  // Block size based on the address.
  // This is used for bytepad() and also pad10*1()
  // assign block_addr_limit = KeccakRate[strength_i];
  // but below is easier to understand
  always_comb begin
    unique case (strength_i)
      L128: block_addr_limit = KeccakCountW'(KeccakRate[L128]);
      L224: block_addr_limit = KeccakCountW'(KeccakRate[L224]);
      L256: block_addr_limit = KeccakCountW'(KeccakRate[L256]);
      L384: block_addr_limit = KeccakCountW'(KeccakRate[L384]);
      L512: block_addr_limit = KeccakCountW'(KeccakRate[L512]);

      default: block_addr_limit = '0;
    endcase
  end

  assign sent_blocksize = (key_index == block_addr_limit);


  // Encoded Output Length =====================================================
  //
  // KMAC(K,X,L,S) := cSHAKE(newX,L,"KMAC",S)
  //   K : Secret Key
  //   X : Input Message
  //   L : Output Length
  //   S : Customization input string
  //   newX = bytepad(encode_string(key), 168or136) || X || right_encode(L)
  //
  // Software writes desired output length as encoded value into the message
  // FIFO at the end of the message prior to set !!CMD.process.


  ////////////////
  // Assertions //
  ////////////////

  // If process_latched is set, then at Message state, it should be cleared

  `ASSERT(ProcessLatchedCleared_A,
          st == StKmacMsg && process_latched |=> !process_latched)

  // Assume configuration is stable during the operation
  `ASSUME(KmacEnStable_M, $changed(kmac_en_i) |-> st inside {StKmacIdle, StTerminalError})
  `ASSUME(ModeStable_M, $changed(mode_i) |-> st inside {StKmacIdle, StTerminalError})
  `ASSUME(StrengthStable_M,
          $changed(strength_i) |->
          (st inside {StKmacIdle, StTerminalError}) ||
          ($past(st) == StKmacIdle))
  `ASSUME(KeyLengthStableWhenValid_M, key_valid_i && !$rose(key_valid_i) |-> $stable(key_len_i))
  `ASSUME(KeyDataStableWhenValid_M, key_valid_i && !$rose(key_valid_i) |-> $stable(key_data_i))

  // no acked to MsgFIFO in StKmacMsg
  `ASSERT(AckOnlyInMessageState_A,
          fifo_valid_i && fifo_ready_o && kmac_en_i |-> st == StKmacMsg)

endmodule : kmac_core

    '''

    Form relevant system verilog assertions for the RTL to be checked for.
    These system verilog assertions should be in a dict with the key as the name and the value as the assertion string.
    An example assertions object to be sent to assertion checker tool is as follows:

    assertions = {"assertion_p1":"property p1;\n    @(posedge clk) signal_A |-> signal_B;\nendproperty
assertion_p1: assert property (p1);", "assertion_p2":"property p2;\n    @(posedge clk) conditions |-> signal_C;\nendproperty\nassertion_p2: assert property (p2);"}

    Then run the assertions using the assertion checker tool. This tool call must include the assertions dictionary as an argument.
    From the output of the assertion checker tool, determine if there are security issues in the RTL.
    If there are no falsified assertions in the output from the assertion checker tool, that means there are no verified security issues in the RTL.

    
================================== Ai Message ==================================

[{'text': "I'll analyze the KMAC core RTL for security concerns related to FSM hardening, masking, and key handling. Let me create relevant assertions to check for potential security issues.\n\nBased on the code, I can see several security-related features:\n1. FSM hardening with sparse encoding\n2. Masking capability for side-channel protection\n3. Key handling logic\n4. Life cycle escalation handling\n\nLet me create assertions to verify these security mechanisms:", 'type': 'text'}, {'id': 'toolu_01TEoHPLXEzu3E62vt1g8MSm', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_core.sv', 'top_module': 'kmac_core', 'assertions': {'fsm_encoding_check': 'property fsm_encoding_check;\n  @(posedge clk_i) $countones(st) inside {1, 2, 3, 4};\nendproperty\nassert property (fsm_encoding_check);', 'fsm_transition_check': 'property fsm_transition_check;\n  @(posedge clk_i) $changed(st) |-> $past(st_d) == st;\nendproperty\nassert property (fsm_transition_check);', 'lc_escalate_response': 'property lc_escalate_response;\n  @(posedge clk_i) lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i) |=> st == StTerminalError;\nendproperty\nassert property (lc_escalate_response);', 'key_protection': 'property key_protection;\n  @(posedge clk_i) (st != StKey) |-> !en_key_write;\nendproperty\nassert property (key_protection);', 'terminal_error_sticky': 'property terminal_error_sticky;\n  @(posedge clk_i) (st == StTerminalError) |=> (st == StTerminalError);\nendproperty\nassert property (terminal_error_sticky);', 'sparse_fsm_error_indicator': 'property sparse_fsm_error_indicator;\n  @(posedge clk_i) (st == StTerminalError) |-> sparse_fsm_error_o;\nendproperty\nassert property (sparse_fsm_error_indicator);'}, 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01TEoHPLXEzu3E62vt1g8MSm)
 Call ID: toolu_01TEoHPLXEzu3E62vt1g8MSm
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_core.sv
    top_module: kmac_core
    assertions: {'fsm_encoding_check': 'property fsm_encoding_check;\n  @(posedge clk_i) $countones(st) inside {1, 2, 3, 4};\nendproperty\nassert property (fsm_encoding_check);', 'fsm_transition_check': 'property fsm_transition_check;\n  @(posedge clk_i) $changed(st) |-> $past(st_d) == st;\nendproperty\nassert property (fsm_transition_check);', 'lc_escalate_response': 'property lc_escalate_response;\n  @(posedge clk_i) lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i) |=> st == StTerminalError;\nendproperty\nassert property (lc_escalate_response);', 'key_protection': 'property key_protection;\n  @(posedge clk_i) (st != StKey) |-> !en_key_write;\nendproperty\nassert property (key_protection);', 'terminal_error_sticky': 'property terminal_error_sticky;\n  @(posedge clk_i) (st == StTerminalError) |=> (st == StTerminalError);\nendproperty\nassert property (terminal_error_sticky);', 'sparse_fsm_error_indicator': 'property sparse_fsm_error_indicator;\n  @(posedge clk_i) (st == StTerminalError) |-> sparse_fsm_error_o;\nendproperty\nassert property (sparse_fsm_error_indicator);'}
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: assertion_checker_tool

Successfully executed:
```assertion checker tool
```
Output:
 There are no falsified properties.
================================== Ai Message ==================================

Based on the assertion checking results, there are no verified security issues in the RTL. Let me explain the security features I found in the code and what my assertions were checking:

### Security Features in the RTL:

1. **FSM Hardening with Sparse Encoding**:
   - The state machine uses sparse encoding with a minimum Hamming distance of 3
   - This provides protection against fault injection attacks
   - My `fsm_encoding_check` assertion verified that the state encoding maintains proper Hamming weight

2. **Masking for Side-Channel Protection**:
   - The module supports optional masking (controlled by `EnMasking` parameter)
   - When enabled, it processes data in two shares to protect against side-channel attacks
   - This is a standard countermeasure against power analysis attacks

3. **Life Cycle Escalation Handling**:
   - The design has proper handling of life cycle escalation signals
   - When escalation is triggered, the FSM immediately transitions to a terminal error state
   - My `lc_escalate_response` assertion verified this behavior

4. **Key Protection**:
   - The key is only exposed during the specific key processing state
   - My `key_protection` assertion verified that key writing is only enabled in the appropriate state

5. **Error Handling**:
   - The FSM includes a terminal error state that is sticky (cannot be exited)
   - Error indicators are properly set when in error states
   - My `terminal_error_sticky` and `sparse_fsm_error_indicator` assertions verified this behavior

6. **Redundant Counter**:
   - The key index counter uses a hardened implementation (`prim_count`) with redundancy
   - This protects against fault attacks on the counter

All assertions passed, indicating that the security features are properly implemented. The KMAC core appears to have robust security measures for FSM hardening, masking for side-channel protection, and secure key handling.
================================= Tool Message =================================
Name: run_assertions_checker_agent

Based on the assertion checking results, there are no verified security issues in the RTL. Let me explain the security features I found in the code and what my assertions were checking:

### Security Features in the RTL:

1. **FSM Hardening with Sparse Encoding**:
   - The state machine uses sparse encoding with a minimum Hamming distance of 3
   - This provides protection against fault injection attacks
   - My `fsm_encoding_check` assertion verified that the state encoding maintains proper Hamming weight

2. **Masking for Side-Channel Protection**:
   - The module supports optional masking (controlled by `EnMasking` parameter)
   - When enabled, it processes data in two shares to protect against side-channel attacks
   - This is a standard countermeasure against power analysis attacks

3. **Life Cycle Escalation Handling**:
   - The design has proper handling of life cycle escalation signals
   - When escalation is triggered, the FSM immediately transitions to a terminal error state
   - My `lc_escalate_response` assertion verified this behavior

4. **Key Protection**:
   - The key is only exposed during the specific key processing state
   - My `key_protection` assertion verified that key writing is only enabled in the appropriate state

5. **Error Handling**:
   - The FSM includes a terminal error state that is sticky (cannot be exited)
   - Error indicators are properly set when in error states
   - My `terminal_error_sticky` and `sparse_fsm_error_indicator` assertions verified this behavior

6. **Redundant Counter**:
   - The key index counter uses a hardened implementation (`prim_count`) with redundancy
   - This protects against fault attacks on the counter

All assertions passed, indicating that the security features are properly implemented. The KMAC core appears to have robust security measures for FSM hardening, masking for side-channel protection, and secure key handling.
================================== Ai Message ==================================
Tool Calls:
  run_linter_agent (call_TVMyQ2ZyXotzJIWTArldE8Lm)
 Call ID: call_TVMyQ2ZyXotzJIWTArldE8Lm
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_core.sv
    top_module: kmac_core
    security_objective: FSM hardening, masking, key handling
================================ Human Message =================================

Are there security concerns related to FSM hardening, masking, key handling in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_core.sv

    And the top module is:

    kmac_core

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// KMAC control and padding logic

`include "prim_assert.sv"

module kmac_core
  import kmac_pkg::*;
#(
  // EnMasking: Enable masking security hardening inside keccak_round
  // If it is enabled, the result digest will be two set of 1600bit.
  parameter  bit EnMasking = 0,
  localparam int Share = (EnMasking) ? 2 : 1 // derived parameter
) (
  input clk_i,
  input rst_ni,

  // From Message FIFO
  input                fifo_valid_i,
  input [MsgWidth-1:0] fifo_data_i [Share],
  input [MsgStrbW-1:0] fifo_strb_i,
  output logic         fifo_ready_o,

  // to SHA3 Core
  output logic                msg_valid_o,
  output logic [MsgWidth-1:0] msg_data_o  [Share],
  output logic [MsgStrbW-1:0] msg_strb_o,
  input                       msg_ready_i,

  // Configurations

  // If kmac_en is cleared, Core logic doesn't function but forward incoming
  // message to SHA3 core
  input                             kmac_en_i,
  input sha3_pkg::sha3_mode_e       mode_i,
  input sha3_pkg::keccak_strength_e strength_i,

  // Key input from CSR
  input [MaxKeyLen-1:0] key_data_i [Share],
  input key_len_e       key_len_i,
  input logic           key_valid_i,

  // Controls : same to SHA3 core
  input start_i,
  input process_i,
  input prim_mubi_pkg::mubi4_t done_i,

  // Control to SHA3 core
  output logic process_o,

  // Life cycle
  input  lc_ctrl_pkg::lc_tx_t lc_escalate_en_i,

  output logic sparse_fsm_error_o,
  output logic key_index_error_o
);

  import sha3_pkg::KeccakMsgAddrW;
  import sha3_pkg::KeccakCountW;
  import sha3_pkg::KeccakRate;
  import sha3_pkg::L128;
  import sha3_pkg::L224;
  import sha3_pkg::L256;
  import sha3_pkg::L384;
  import sha3_pkg::L512;

  /////////////////
  // Definitions //
  /////////////////

  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 3 -m 5 -n 6 \
  //      -s 401658243 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: |||||||||||||||||||| (50.00%)
  //  4: |||||||||||||||| (40.00%)
  //  5: |||| (10.00%)
  //  6: --
  //
  // Minimum Hamming distance: 3
  // Maximum Hamming distance: 5
  // Minimum Hamming weight: 1
  // Maximum Hamming weight: 4
  //
  localparam int StateWidth = 6;
  typedef enum logic [StateWidth-1:0] {
    StKmacIdle = 6'b011000,

    // Secret Key pushing stage
    // The key is sliced by prim_slicer. This state pushes the sliced data into
    // SHA3 hashing engine. When it hits the block size limit,
    // (same as in sha3pad) the state machine moves to Message.
    StKey = 6'b010111,

    // Incoming Message
    // The core does nothing but forwarding the incoming message to SHA3 hashing
    // engine by turning off `en_kmac_datapath`.
    StKmacMsg = 6'b001110,

    // Wait till done signal
    StKmacFlush = 6'b101011,

    // Terminal Error
    StTerminalError = 6'b100000
  } kmac_st_e ;

  /////////////
  // Signals //
  /////////////

  // represents encode_string(K)
  logic [MaxEncodedKeyW-1:0] encoded_key [Share];

  // Key slice address
  // This signal controls the 64 bit output of the sliced secret_key.
  logic [sha3_pkg::KeccakMsgAddrW-1:0] key_index;
  logic inc_keyidx, clr_keyidx;

  // `sent_blocksize` indicates that the encoded key is sent to sha3 hashing
  // engine. If this hits at StKey stage, the state moves to message state.
  logic [sha3_pkg::KeccakCountW-1:0] block_addr_limit;
  logic sent_blocksize;

  // Internal message signals
  logic                kmac_valid       ;
  logic [MsgWidth-1:0] kmac_data [Share];
  logic [MsgStrbW-1:0] kmac_strb        ;

  // Control SHA3 core
  // `kmac_process` is to forward the process signal to SHA3 core only after
  // the KMAC core writes the key block in case of the message is empty.
  // If the incoming message is empty, there's chance that the `process_i`
  // signal can be asserted while KMAC core processing the key block.
  logic kmac_process, process_latched;

  // Indication of Secret key write stage. Only in this stage, the internal
  // message interface is active.
  logic en_key_write;
  logic en_kmac_datapath;

  // Encoded key has wider bits. `key_sliced` is the data to send to sha3
  logic [MsgWidth-1:0] key_sliced [Share];

  // The following signals are only used in assertions.
  logic unused_signals;
  assign unused_signals = ^{mode_i, key_valid_i};

  /////////
  // FSM //
  /////////
  kmac_st_e st, st_d;

  // State register
  `PRIM_FLOP_SPARSE_FSM(u_state_regs, st_d, st, kmac_st_e, StKmacIdle)

  // Next state and output logic
  // SEC_CM: FSM.SPARSE
  always_comb begin
    st_d = st;

    en_kmac_datapath = 1'b 0;
    en_key_write = 1'b 0;

    clr_keyidx = 1'b 0;

    kmac_valid = 1'b 0;
    kmac_process = 1'b 0;

    sparse_fsm_error_o = 1'b 0;

    unique case (st)
      StKmacIdle: begin
        if (kmac_en_i && start_i) begin
          st_d = StKey;
        end else begin
          st_d = StKmacIdle;
        end
      end

      // If State enters here, regardless of the `process_i`, the state writes
      // full block size of the key into SHA3 hashing engine.
      StKey: begin
        en_kmac_datapath = 1'b 1;
        en_key_write = 1'b 1;

        if (sent_blocksize) begin
          st_d = StKmacMsg;

          kmac_valid = 1'b 0;
          clr_keyidx = 1'b 1;
        end else begin
          st_d = StKey;

          kmac_valid = 1'b 1;
        end
      end

      StKmacMsg: begin
        // If process is previously latched, it is sent to SHA3 here.
        if (process_i || process_latched) begin
          st_d = StKmacFlush;

          kmac_process = 1'b 1;
        end else begin
          st_d = StKmacMsg;
        end
      end

      StKmacFlush: begin
        if (prim_mubi_pkg::mubi4_test_true_strict(done_i)) begin
          st_d = StKmacIdle;
        end else begin
          st_d = StKmacFlush;
        end
      end

      StTerminalError: begin
        // this state is terminal
        st_d = st;
        sparse_fsm_error_o = 1'b 1;
      end

      default: begin
        // this state is terminal
        st_d = StTerminalError;
        sparse_fsm_error_o = 1'b 1;
      end
    endcase

    // SEC_CM: FSM.GLOBAL_ESC, FSM.LOCAL_ESC
    // Unconditionally jump into the terminal error state
    // if the life cycle controller triggers an escalation.
    if (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) begin
      st_d = StTerminalError;
    end
  end

  //////////////
  // Datapath //
  //////////////

  // DATA Mux depending on kmac_en
  // When Key write happens, hold the FIFO request. so fifo_ready_o is tied to 0
  assign msg_valid_o  = (en_kmac_datapath) ? kmac_valid : fifo_valid_i;
  assign msg_data_o   = (en_kmac_datapath) ? kmac_data  : fifo_data_i ;
  assign msg_strb_o   = (en_kmac_datapath) ? kmac_strb  : fifo_strb_i ;
  assign fifo_ready_o = (en_kmac_datapath) ? 1'b 0      : msg_ready_i ;

  // secret key write request to SHA3 hashing engine is always full width write.
  // KeyMgr is fixed 256 bit output. So `right_encode(256)` is 0x020100 --> strb 3
  assign kmac_strb = (en_key_write ) ? '1 : '0;

  assign kmac_data = (en_key_write) ? key_sliced : '{default:'0};

  // Process is controlled by the KMAC core always.
  // This is mainly to prevent process_i asserted while KMAC core is writing
  // the secret key to SHA3 hashing engine (the empty message case)
  assign process_o = (kmac_en_i) ? kmac_process : process_i ;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      process_latched <= 1'b 0;
    end else if (process_i && !process_o) begin
      process_latched <= 1'b 1;
    end else if (process_o ||
      prim_mubi_pkg::mubi4_test_true_strict(done_i)) begin
      process_latched <= 1'b 0;
    end
  end

  // bytepad(encode_string(K), 168 or 136) =====================================
  // 1. Prepare left_encode(w)
  // 2. Prepare left_encode(len(secret_key))
  // 3. Concatenate left_encode(len(secret_key)) || secret_key
  // 4. Concaatenate left_encode(w) || encode_string(secret_key)
  // 5. Based on the address, slice out the data into MsgWidth bits

  // left_encode(w): Same as used in sha3pad logic.
  logic [15:0] encode_bytepad;
  assign encode_bytepad = sha3_pkg::encode_bytepad_len(strength_i);

  // left_encode(len(secret_key))
  // encoded length is always byte size. Use MaxEncodedKeyLenByte parameter
  // from kmac_pkg and add one more byte to indicate how many bytes used to
  // represent len(secret_key)
  // Note that if the secret_key is 128 bit, only lower 16 bits of
  // `encode_keylen` are valid. Refer `encoded_key` concatenation logic below.
  // As the encoded string in the spec big-endian, The endian swap is a must.
  logic [MaxEncodedKeyLenSize + 8 - 1:0] encode_keylen [Share];

  always_comb begin
    // the spec mentioned the key length is encoded in left_encode()
    // The number is represented in big-endian. For example:
    // 384 ==> 0x02 0x01 0x80
    // The first byte is the number of bytes to represent 384
    // The second byte represents 2**8 number, which is 256 here.
    // The third byte represents 2**0 number, which is 128.
    // The data put into MsgFIFO is little-endian and SHA3(Keccak) processes in
    // little-endian. So, below keylen swaps the byte order
    unique case (key_len_i)
      //                           endian-swapped key_length          num_bytes
      // Key128: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(128)}}, 8'h 01};
      // Key192: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(192)}}, 8'h 01};
      // Key256: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(256)}}, 8'h 02};
      // Key384: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(384)}}, 8'h 02};
      // Key512: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(512)}}, 8'h 02};

      // Vivado does not support stream swap for non context value. So assign
      // the value directly.
      Key128: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 0080_01);
      Key192: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 00C0_01);
      Key256: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 0001_02);
      Key384: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 8001_02);
      Key512: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 0002_02);
      default: encode_keylen[0] = '0;
    endcase
  end

  if (EnMasking) begin: gen_encode_keylen_masked
    assign encode_keylen[1] = '0;
  end

  // encode_string(secret_key): Concatenate key
  // Based on the left_encode(len(secret_key)) size, the concatenation logic
  // should be changed. If key length is 128 bit, only lower 16 bits of the
  // encoded length are used so that the upper 8 bits are padded with 0 as
  // defined in bytepad() function.

  for (genvar i = 0 ; i < Share; i++) begin : gen_encoded_key
    always_comb begin
      unique case (key_len_i)
        // In Key 128, 192 case, only lower parts of encode_keylen signal is
        // used. So upper padding requires 8 more bits than MaxKeyLen - keylen
        Key128: encoded_key[i] = {(8 + MaxKeyLen - 128)'(0),
                                  key_data_i[i][0+:128],
                                  encode_keylen[i][0+:MaxEncodedKeyLenSize]};

        Key192: encoded_key[i] = {(8 + MaxKeyLen - 192)'(0),
                                  key_data_i[i][0+:192],
                                  encode_keylen[i][0+:MaxEncodedKeyLenSize]};

        Key256: encoded_key[i] = {(MaxKeyLen - 256)'(0),
                                  key_data_i[i][0+:256],
                                  encode_keylen[i]};

        Key384: encoded_key[i] = {(MaxKeyLen - 384)'(0),
                                  key_data_i[i][0+:384],
                                  encode_keylen[i]};

        // Assume 512bit is the MaxKeyLen
        Key512: encoded_key[i] = {key_data_i[i][0+:512],
                                  encode_keylen[i]};

        default: encoded_key[i] = '0;
      endcase
    end
  end : gen_encoded_key

  // Above logic assumes MaxKeyLen as 512 bits. Revise if it is not.
  `ASSERT_INIT(MaxKeyLenMatchToKey512_A, kmac_pkg::MaxKeyLen == 512)

  // Combine the bytepad `left_encode(w)` and the `encode_string(secret_key)`
  logic [MaxEncodedKeyW + 16 -1 :0] encoded_key_block [Share];

  assign encoded_key_block[0] = {encoded_key[0], encode_bytepad};

  if (EnMasking) begin : gen_encoded_key_block_masked
    assign encoded_key_block[1] = {encoded_key[1], 16'h 0};
  end

  // Slicer to slice out 64 bits
  for (genvar i = 0 ; i < Share ; i++) begin : gen_key_slicer
    prim_slicer #(
      .InW (MaxEncodedKeyW+16),
      .IndexW(KeccakMsgAddrW),
      .OutW(MsgWidth)
    ) u_key_slicer (
      .sel_i  (key_index),
      .data_i (encoded_key_block[i]),
      .data_o (key_sliced[i])
    );
  end

  // `key_index` logic
  // key_index is used to select MsgWidth data from long `encoded_key_block`
  // It behaves same as `keccak_addr` or `prefix_index` in sha3pad module.
  assign inc_keyidx = kmac_valid & msg_ready_i ;

  // This primitive is used to place a hardened counter
  // SEC_CM: CTR.REDUN
  prim_count #(
    .Width(sha3_pkg::KeccakMsgAddrW)
  ) u_key_index_count (
    .clk_i,
    .rst_ni,
    .clr_i(clr_keyidx),
    .set_i(1'b0),
    .set_cnt_i('0),
    .incr_en_i(inc_keyidx),
    .decr_en_i(1'b0),
    .step_i(sha3_pkg::KeccakMsgAddrW'(1)),
    .commit_i(1'b1),
    .cnt_o(key_index),
    .cnt_after_commit_o(),
    .err_o(key_index_error_o)
  );

  // Block size based on the address.
  // This is used for bytepad() and also pad10*1()
  // assign block_addr_limit = KeccakRate[strength_i];
  // but below is easier to understand
  always_comb begin
    unique case (strength_i)
      L128: block_addr_limit = KeccakCountW'(KeccakRate[L128]);
      L224: block_addr_limit = KeccakCountW'(KeccakRate[L224]);
      L256: block_addr_limit = KeccakCountW'(KeccakRate[L256]);
      L384: block_addr_limit = KeccakCountW'(KeccakRate[L384]);
      L512: block_addr_limit = KeccakCountW'(KeccakRate[L512]);

      default: block_addr_limit = '0;
    endcase
  end

  assign sent_blocksize = (key_index == block_addr_limit);


  // Encoded Output Length =====================================================
  //
  // KMAC(K,X,L,S) := cSHAKE(newX,L,"KMAC",S)
  //   K : Secret Key
  //   X : Input Message
  //   L : Output Length
  //   S : Customization input string
  //   newX = bytepad(encode_string(key), 168or136) || X || right_encode(L)
  //
  // Software writes desired output length as encoded value into the message
  // FIFO at the end of the message prior to set !!CMD.process.


  ////////////////
  // Assertions //
  ////////////////

  // If process_latched is set, then at Message state, it should be cleared

  `ASSERT(ProcessLatchedCleared_A,
          st == StKmacMsg && process_latched |=> !process_latched)

  // Assume configuration is stable during the operation
  `ASSUME(KmacEnStable_M, $changed(kmac_en_i) |-> st inside {StKmacIdle, StTerminalError})
  `ASSUME(ModeStable_M, $changed(mode_i) |-> st inside {StKmacIdle, StTerminalError})
  `ASSUME(StrengthStable_M,
          $changed(strength_i) |->
          (st inside {StKmacIdle, StTerminalError}) ||
          ($past(st) == StKmacIdle))
  `ASSUME(KeyLengthStableWhenValid_M, key_valid_i && !$rose(key_valid_i) |-> $stable(key_len_i))
  `ASSUME(KeyDataStableWhenValid_M, key_valid_i && !$rose(key_valid_i) |-> $stable(key_data_i))

  // no acked to MsgFIFO in StKmacMsg
  `ASSERT(AckOnlyInMessageState_A,
          fifo_valid_i && fifo_ready_o && kmac_en_i |-> st == StKmacMsg)

endmodule : kmac_core

    '''

    Identify relevant lint tags for the RTL to be checked for.
    Then run the tests using the linting tool.
    From the output of the linting tool, determine if there are security issues in the RTL.
================================== Ai Message ==================================
Tool Calls:
  retrieve_relevant_lint_tags (call_o7kOC2eJE0bjHVXlLnR5Nn7R)
 Call ID: call_o7kOC2eJE0bjHVXlLnR5Nn7R
  Args:
    query: FSM hardening, masking, key handling security
================================= Tool Message =================================
Name: retrieve_relevant_lint_tags

FsmUsage-ML: Finite State machine used

UseDefine: Hard constants used to encode finite-state machine


STARC05-2.11.1.4: Number of states in a FSM should not exceed specified limit


SepFSMLogic: Finite-state machine (FSM) and non-FSM logic is mixed in one module


FSMNextStateName-ML: State name prefix or suffix 


STARC05-2.11.1.2: Bit change in state transition should be minimal (use Gray code). (Verilog)Bit change in FSM state transitions should be minimized (use Gray code). (VHDL) 

DetectBlackBoxes-ML: Black box instance detected

FsmLiveLock: Detects livelock states in FSM


HardConst: Do not use hard-coded constants other than 0 or 1 


STARC05-1.4.3.1b: Clocks should not be gated 


NoExitInFSM-ML: Do not have states without exit in FSMs 


STARC05-1.2.1.1a: Design should use only one edge of a clock 


STARC05-2.11.2.1: FSM description should not be mixed with other descriptions in the same module. (Verilog)FSM description should not be mixed with non-FSM descriptions in the same module (VHDL) 


STARC05-2.11.3.1: Ensure that the sequential and combinational parts of an FSM description should be in separate always blocks. (Verilog)Ensure that the sequential and combinational parts of an FSM description should be separated (VHDL)


LINT_FSM_WITHOUT_INITIAL_STATE: Do not have FSM without the initial state 


FSMCurrentStateName-ML: Current state vector of FSM does not follow the naming convention 


STARC05-1.3.2.1a: Asynchronous resets or sets must not be gated 


GatedClock: Gated/generated clocks are generated from more than one block in the design 


STARC05-1.4.3.6: Do not use Flip-Flops with inverted edges 


STARC05-2.3.5.1: Flip-flops should not have fixed inputs 
================================== Ai Message ==================================
Tool Calls:
  lint_checker_tool (call_wfZwINeCYejTP0RgmAJfUdcQ)
 Call ID: call_wfZwINeCYejTP0RgmAJfUdcQ
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_core.sv
    top_module: kmac_core
    lint_tags: ['FsmUsage-ML', 'UseDefine', 'STARC05-2.11.1.4', 'SepFSMLogic', 'FSMNextStateName-ML', 'STARC05-2.11.1.2', 'DetectBlackBoxes-ML', 'FsmLiveLock', 'HardConst', 'STARC05-1.4.3.1b', 'NoExitInFSM-ML', 'STARC05-1.2.1.1a', 'STARC05-2.11.2.1', 'STARC05-2.11.3.1', 'LINT_FSM_WITHOUT_INITIAL_STATE', 'FSMCurrentStateName-ML', 'STARC05-1.3.2.1a', 'GatedClock', 'STARC05-1.4.3.6', 'STARC05-2.3.5.1']
================================= Tool Message =================================
Name: lint_checker_tool

Successfully executed:
```lint checker tool
```
Output: 
  -----------------------------------------------------------------------------
  Report Summary
  -----------------------------------------------------------------------------
  Product Info
    Name    : VC Static Master Shell
    Version : U-2023.03-1 -- Apr 17, 2023

  Report Info
    Created : May 06, 2025  16:52:31

    TopLevelModule: kmac_core

  -----------------------------------------------------------------------------
  Management Summary
  -----------------------------------------------------------------------------
  Stage           Family      Fatals    Errors  Warnings     Infos
  -----           --------  --------  --------  --------  --------
  LANGUAGE_CHECK  CODING           0         5         0         0
  -----           --------  --------  --------  --------  --------
  Total                            0         5         0         0


  -----------------------------------------------------------------------------
  Tree Summary
  -----------------------------------------------------------------------------
  Severity  Stage           Tag          Count
  --------  -----           -----------  -----
  error     LANGUAGE_CHECK  HardConst        5
  --------  -----           -----------  -----
  Total                                      5



  -----------------------------------------------------------------------------
  HardConst  (5 errors/0 waived)
  -----------------------------------------------------------------------------
  Tag           : HardConst
  Description   : Do not use hard-coded constants [CValue]
  Violation     : Lint:3
  Module        : kmac_core
  FileName      : build/lowrisc_ip_kmac_0.1/src/lowrisc_ip_kmac_0.1/rtl/kmac_core.sv
  LineNumber    : 319
  Statement     :       Key256: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 0001_02);
  CValue        : (MaxEncodedKeyLenSize + 8)'('h000102)
  -----------------------------------------------------------------------------
  Tag           : HardConst
  Description   : Do not use hard-coded constants [CValue]
  Violation     : Lint:2
  Module        : kmac_core
  FileName      : build/lowrisc_ip_kmac_0.1/src/lowrisc_ip_kmac_0.1/rtl/kmac_core.sv
  LineNumber    : 318
  Statement     :       Key192: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 00C0_01);
  CValue        : (MaxEncodedKeyLenSize + 8)'('h00C001)
  -----------------------------------------------------------------------------
  Tag           : HardConst
  Description   : Do not use hard-coded constants [CValue]
  Violation     : Lint:4
  Module        : kmac_core
  FileName      : build/lowrisc_ip_kmac_0.1/src/lowrisc_ip_kmac_0.1/rtl/kmac_core.sv
  LineNumber    : 320
  Statement     :       Key384: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 8001_02);
  CValue        : (MaxEncodedKeyLenSize + 8)'('h800102)
  -----------------------------------------------------------------------------
  Tag           : HardConst
  Description   : Do not use hard-coded constants [CValue]
  Violation     : Lint:1
  Module        : kmac_core
  FileName      : build/lowrisc_ip_kmac_0.1/src/lowrisc_ip_kmac_0.1/rtl/kmac_core.sv
  LineNumber    : 317
  Statement     :       Key128: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 0080_01);
  CValue        : (MaxEncodedKeyLenSize + 8)'('h008001)
  -----------------------------------------------------------------------------
  Tag           : HardConst
  Description   : Do not use hard-coded constants [CValue]
  Violation     : Lint:5
  Module        : kmac_core
  FileName      : build/lowrisc_ip_kmac_0.1/src/lowrisc_ip_kmac_0.1/rtl/kmac_core.sv
  LineNumber    : 321
  Statement     :       Key512: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 0002_02);
  CValue        : (MaxEncodedKeyLenSize + 8)'('h000202)

================================== Ai Message ==================================

The lint check for the kmac_core RTL module focusing on FSM hardening, masking, and key handling security has been completed. The relevant lint tags used were related to FSM usage, hard constants, and other FSM and coding style checks.

The lint tool reported 5 errors, all under the tag "HardConst". These errors indicate that hard-coded constants are used in the code, specifically in the encoding of key lengths in the always_comb block around lines 317 to 321. The use of hard-coded constants is generally discouraged as it can lead to less flexible and potentially error-prone designs.

No other security-related lint errors or warnings were reported, including no issues with FSM hardening or masking were flagged by the lint tool.

Summary:
- 5 errors related to hard-coded constants in key length encoding.
- No FSM hardening or masking security issues detected by lint.
- No key handling security issues flagged by lint.

Recommendation:
- Review the use of hard-coded constants in the encoding of key lengths and consider replacing them with parameterized or calculated values to improve code maintainability and security.
- Although no FSM or masking issues were flagged, ensure that the FSM encoding and masking logic are reviewed manually for compliance with security best practices.
================================= Tool Message =================================
Name: run_linter_agent

The lint check for the kmac_core RTL module focusing on FSM hardening, masking, and key handling security has been completed. The relevant lint tags used were related to FSM usage, hard constants, and other FSM and coding style checks.

The lint tool reported 5 errors, all under the tag "HardConst". These errors indicate that hard-coded constants are used in the code, specifically in the encoding of key lengths in the always_comb block around lines 317 to 321. The use of hard-coded constants is generally discouraged as it can lead to less flexible and potentially error-prone designs.

No other security-related lint errors or warnings were reported, including no issues with FSM hardening or masking were flagged by the lint tool.

Summary:
- 5 errors related to hard-coded constants in key length encoding.
- No FSM hardening or masking security issues detected by lint.
- No key handling security issues flagged by lint.

Recommendation:
- Review the use of hard-coded constants in the encoding of key lengths and consider replacing them with parameterized or calculated values to improve code maintainability and security.
- Although no FSM or masking issues were flagged, ensure that the FSM encoding and masking logic are reviewed manually for compliance with security best practices.
================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_zs3IfYH580JPZavbbpcafg2n)
 Call ID: call_zs3IfYH580JPZavbbpcafg2n
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_core.sv
    top_module: kmac_core
    security_objective: FSM hardening, masking, key handling
================================ Human Message =================================

Are there security concerns related to FSM hardening, masking, key handling in the provided RTL:
    """

    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// KMAC control and padding logic

`include "prim_assert.sv"

module kmac_core
  import kmac_pkg::*;
#(
  // EnMasking: Enable masking security hardening inside keccak_round
  // If it is enabled, the result digest will be two set of 1600bit.
  parameter  bit EnMasking = 0,
  localparam int Share = (EnMasking) ? 2 : 1 // derived parameter
) (
  input clk_i,
  input rst_ni,

  // From Message FIFO
  input                fifo_valid_i,
  input [MsgWidth-1:0] fifo_data_i [Share],
  input [MsgStrbW-1:0] fifo_strb_i,
  output logic         fifo_ready_o,

  // to SHA3 Core
  output logic                msg_valid_o,
  output logic [MsgWidth-1:0] msg_data_o  [Share],
  output logic [MsgStrbW-1:0] msg_strb_o,
  input                       msg_ready_i,

  // Configurations

  // If kmac_en is cleared, Core logic doesn't function but forward incoming
  // message to SHA3 core
  input                             kmac_en_i,
  input sha3_pkg::sha3_mode_e       mode_i,
  input sha3_pkg::keccak_strength_e strength_i,

  // Key input from CSR
  input [MaxKeyLen-1:0] key_data_i [Share],
  input key_len_e       key_len_i,
  input logic           key_valid_i,

  // Controls : same to SHA3 core
  input start_i,
  input process_i,
  input prim_mubi_pkg::mubi4_t done_i,

  // Control to SHA3 core
  output logic process_o,

  // Life cycle
  input  lc_ctrl_pkg::lc_tx_t lc_escalate_en_i,

  output logic sparse_fsm_error_o,
  output logic key_index_error_o
);

  import sha3_pkg::KeccakMsgAddrW;
  import sha3_pkg::KeccakCountW;
  import sha3_pkg::KeccakRate;
  import sha3_pkg::L128;
  import sha3_pkg::L224;
  import sha3_pkg::L256;
  import sha3_pkg::L384;
  import sha3_pkg::L512;

  /////////////////
  // Definitions //
  /////////////////

  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 3 -m 5 -n 6 \
  //      -s 401658243 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: |||||||||||||||||||| (50.00%)
  //  4: |||||||||||||||| (40.00%)
  //  5: |||| (10.00%)
  //  6: --
  //
  // Minimum Hamming distance: 3
  // Maximum Hamming distance: 5
  // Minimum Hamming weight: 1
  // Maximum Hamming weight: 4
  //
  localparam int StateWidth = 6;
  typedef enum logic [StateWidth-1:0] {
    StKmacIdle = 6'b011000,

    // Secret Key pushing stage
    // The key is sliced by prim_slicer. This state pushes the sliced data into
    // SHA3 hashing engine. When it hits the block size limit,
    // (same as in sha3pad) the state machine moves to Message.
    StKey = 6'b010111,

    // Incoming Message
    // The core does nothing but forwarding the incoming message to SHA3 hashing
    // engine by turning off `en_kmac_datapath`.
    StKmacMsg = 6'b001110,

    // Wait till done signal
    StKmacFlush = 6'b101011,

    // Terminal Error
    StTerminalError = 6'b100000
  } kmac_st_e ;

  /////////////
  // Signals //
  /////////////

  // represents encode_string(K)
  logic [MaxEncodedKeyW-1:0] encoded_key [Share];

  // Key slice address
  // This signal controls the 64 bit output of the sliced secret_key.
  logic [sha3_pkg::KeccakMsgAddrW-1:0] key_index;
  logic inc_keyidx, clr_keyidx;

  // `sent_blocksize` indicates that the encoded key is sent to sha3 hashing
  // engine. If this hits at StKey stage, the state moves to message state.
  logic [sha3_pkg::KeccakCountW-1:0] block_addr_limit;
  logic sent_blocksize;

  // Internal message signals
  logic                kmac_valid       ;
  logic [MsgWidth-1:0] kmac_data [Share];
  logic [MsgStrbW-1:0] kmac_strb        ;

  // Control SHA3 core
  // `kmac_process` is to forward the process signal to SHA3 core only after
  // the KMAC core writes the key block in case of the message is empty.
  // If the incoming message is empty, there's chance that the `process_i`
  // signal can be asserted while KMAC core processing the key block.
  logic kmac_process, process_latched;

  // Indication of Secret key write stage. Only in this stage, the internal
  // message interface is active.
  logic en_key_write;
  logic en_kmac_datapath;

  // Encoded key has wider bits. `key_sliced` is the data to send to sha3
  logic [MsgWidth-1:0] key_sliced [Share];

  // The following signals are only used in assertions.
  logic unused_signals;
  assign unused_signals = ^{mode_i, key_valid_i};

  /////////
  // FSM //
  /////////
  kmac_st_e st, st_d;

  // State register
  `PRIM_FLOP_SPARSE_FSM(u_state_regs, st_d, st, kmac_st_e, StKmacIdle)

  // Next state and output logic
  // SEC_CM: FSM.SPARSE
  always_comb begin
    st_d = st;

    en_kmac_datapath = 1'b 0;
    en_key_write = 1'b 0;

    clr_keyidx = 1'b 0;

    kmac_valid = 1'b 0;
    kmac_process = 1'b 0;

    sparse_fsm_error_o = 1'b 0;

    unique case (st)
      StKmacIdle: begin
        if (kmac_en_i && start_i) begin
          st_d = StKey;
        end else begin
          st_d = StKmacIdle;
        end
      end

      // If State enters here, regardless of the `process_i`, the state writes
      // full block size of the key into SHA3 hashing engine.
      StKey: begin
        en_kmac_datapath = 1'b 1;
        en_key_write = 1'b 1;

        if (sent_blocksize) begin
          st_d = StKmacMsg;

          kmac_valid = 1'b 0;
          clr_keyidx = 1'b 1;
        end else begin
          st_d = StKey;

          kmac_valid = 1'b 1;
        end
      end

      StKmacMsg: begin
        // If process is previously latched, it is sent to SHA3 here.
        if (process_i || process_latched) begin
          st_d = StKmacFlush;

          kmac_process = 1'b 1;
        end else begin
          st_d = StKmacMsg;
        end
      end

      StKmacFlush: begin
        if (prim_mubi_pkg::mubi4_test_true_strict(done_i)) begin
          st_d = StKmacIdle;
        end else begin
          st_d = StKmacFlush;
        end
      end

      StTerminalError: begin
        // this state is terminal
        st_d = st;
        sparse_fsm_error_o = 1'b 1;
      end

      default: begin
        // this state is terminal
        st_d = StTerminalError;
        sparse_fsm_error_o = 1'b 1;
      end
    endcase

    // SEC_CM: FSM.GLOBAL_ESC, FSM.LOCAL_ESC
    // Unconditionally jump into the terminal error state
    // if the life cycle controller triggers an escalation.
    if (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) begin
      st_d = StTerminalError;
    end
  end

  //////////////
  // Datapath //
  //////////////

  // DATA Mux depending on kmac_en
  // When Key write happens, hold the FIFO request. so fifo_ready_o is tied to 0
  assign msg_valid_o  = (en_kmac_datapath) ? kmac_valid : fifo_valid_i;
  assign msg_data_o   = (en_kmac_datapath) ? kmac_data  : fifo_data_i ;
  assign msg_strb_o   = (en_kmac_datapath) ? kmac_strb  : fifo_strb_i ;
  assign fifo_ready_o = (en_kmac_datapath) ? 1'b 0      : msg_ready_i ;

  // secret key write request to SHA3 hashing engine is always full width write.
  // KeyMgr is fixed 256 bit output. So `right_encode(256)` is 0x020100 --> strb 3
  assign kmac_strb = (en_key_write ) ? '1 : '0;

  assign kmac_data = (en_key_write) ? key_sliced : '{default:'0};

  // Process is controlled by the KMAC core always.
  // This is mainly to prevent process_i asserted while KMAC core is writing
  // the secret key to SHA3 hashing engine (the empty message case)
  assign process_o = (kmac_en_i) ? kmac_process : process_i ;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      process_latched <= 1'b 0;
    end else if (process_i && !process_o) begin
      process_latched <= 1'b 1;
    end else if (process_o ||
      prim_mubi_pkg::mubi4_test_true_strict(done_i)) begin
      process_latched <= 1'b 0;
    end
  end

  // bytepad(encode_string(K), 168 or 136) =====================================
  // 1. Prepare left_encode(w)
  // 2. Prepare left_encode(len(secret_key))
  // 3. Concatenate left_encode(len(secret_key)) || secret_key
  // 4. Concaatenate left_encode(w) || encode_string(secret_key)
  // 5. Based on the address, slice out the data into MsgWidth bits

  // left_encode(w): Same as used in sha3pad logic.
  logic [15:0] encode_bytepad;
  assign encode_bytepad = sha3_pkg::encode_bytepad_len(strength_i);

  // left_encode(len(secret_key))
  // encoded length is always byte size. Use MaxEncodedKeyLenByte parameter
  // from kmac_pkg and add one more byte to indicate how many bytes used to
  // represent len(secret_key)
  // Note that if the secret_key is 128 bit, only lower 16 bits of
  // `encode_keylen` are valid. Refer `encoded_key` concatenation logic below.
  // As the encoded string in the spec big-endian, The endian swap is a must.
  logic [MaxEncodedKeyLenSize + 8 - 1:0] encode_keylen [Share];

  always_comb begin
    // the spec mentioned the key length is encoded in left_encode()
    // The number is represented in big-endian. For example:
    // 384 ==> 0x02 0x01 0x80
    // The first byte is the number of bytes to represent 384
    // The second byte represents 2**8 number, which is 256 here.
    // The third byte represents 2**0 number, which is 128.
    // The data put into MsgFIFO is little-endian and SHA3(Keccak) processes in
    // little-endian. So, below keylen swaps the byte order
    unique case (key_len_i)
      //                           endian-swapped key_length          num_bytes
      // Key128: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(128)}}, 8'h 01};
      // Key192: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(192)}}, 8'h 01};
      // Key256: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(256)}}, 8'h 02};
      // Key384: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(384)}}, 8'h 02};
      // Key512: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(512)}}, 8'h 02};

      // Vivado does not support stream swap for non context value. So assign
      // the value directly.
      Key128: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 0080_01);
      Key192: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 00C0_01);
      Key256: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 0001_02);
      Key384: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 8001_02);
      Key512: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 0002_02);
      default: encode_keylen[0] = '0;
    endcase
  end

  if (EnMasking) begin: gen_encode_keylen_masked
    assign encode_keylen[1] = '0;
  end

  // encode_string(secret_key): Concatenate key
  // Based on the left_encode(len(secret_key)) size, the concatenation logic
  // should be changed. If key length is 128 bit, only lower 16 bits of the
  // encoded length are used so that the upper 8 bits are padded with 0 as
  // defined in bytepad() function.

  for (genvar i = 0 ; i < Share; i++) begin : gen_encoded_key
    always_comb begin
      unique case (key_len_i)
        // In Key 128, 192 case, only lower parts of encode_keylen signal is
        // used. So upper padding requires 8 more bits than MaxKeyLen - keylen
        Key128: encoded_key[i] = {(8 + MaxKeyLen - 128)'(0),
                                  key_data_i[i][0+:128],
                                  encode_keylen[i][0+:MaxEncodedKeyLenSize]};

        Key192: encoded_key[i] = {(8 + MaxKeyLen - 192)'(0),
                                  key_data_i[i][0+:192],
                                  encode_keylen[i][0+:MaxEncodedKeyLenSize]};

        Key256: encoded_key[i] = {(MaxKeyLen - 256)'(0),
                                  key_data_i[i][0+:256],
                                  encode_keylen[i]};

        Key384: encoded_key[i] = {(MaxKeyLen - 384)'(0),
                                  key_data_i[i][0+:384],
                                  encode_keylen[i]};

        // Assume 512bit is the MaxKeyLen
        Key512: encoded_key[i] = {key_data_i[i][0+:512],
                                  encode_keylen[i]};

        default: encoded_key[i] = '0;
      endcase
    end
  end : gen_encoded_key

  // Above logic assumes MaxKeyLen as 512 bits. Revise if it is not.
  `ASSERT_INIT(MaxKeyLenMatchToKey512_A, kmac_pkg::MaxKeyLen == 512)

  // Combine the bytepad `left_encode(w)` and the `encode_string(secret_key)`
  logic [MaxEncodedKeyW + 16 -1 :0] encoded_key_block [Share];

  assign encoded_key_block[0] = {encoded_key[0], encode_bytepad};

  if (EnMasking) begin : gen_encoded_key_block_masked
    assign encoded_key_block[1] = {encoded_key[1], 16'h 0};
  end

  // Slicer to slice out 64 bits
  for (genvar i = 0 ; i < Share ; i++) begin : gen_key_slicer
    prim_slicer #(
      .InW (MaxEncodedKeyW+16),
      .IndexW(KeccakMsgAddrW),
      .OutW(MsgWidth)
    ) u_key_slicer (
      .sel_i  (key_index),
      .data_i (encoded_key_block[i]),
      .data_o (key_sliced[i])
    );
  end

  // `key_index` logic
  // key_index is used to select MsgWidth data from long `encoded_key_block`
  // It behaves same as `keccak_addr` or `prefix_index` in sha3pad module.
  assign inc_keyidx = kmac_valid & msg_ready_i ;

  // This primitive is used to place a hardened counter
  // SEC_CM: CTR.REDUN
  prim_count #(
    .Width(sha3_pkg::KeccakMsgAddrW)
  ) u_key_index_count (
    .clk_i,
    .rst_ni,
    .clr_i(clr_keyidx),
    .set_i(1'b0),
    .set_cnt_i('0),
    .incr_en_i(inc_keyidx),
    .decr_en_i(1'b0),
    .step_i(sha3_pkg::KeccakMsgAddrW'(1)),
    .commit_i(1'b1),
    .cnt_o(key_index),
    .cnt_after_commit_o(),
    .err_o(key_index_error_o)
  );

  // Block size based on the address.
  // This is used for bytepad() and also pad10*1()
  // assign block_addr_limit = KeccakRate[strength_i];
  // but below is easier to understand
  always_comb begin
    unique case (strength_i)
      L128: block_addr_limit = KeccakCountW'(KeccakRate[L128]);
      L224: block_addr_limit = KeccakCountW'(KeccakRate[L224]);
      L256: block_addr_limit = KeccakCountW'(KeccakRate[L256]);
      L384: block_addr_limit = KeccakCountW'(KeccakRate[L384]);
      L512: block_addr_limit = KeccakCountW'(KeccakRate[L512]);

      default: block_addr_limit = '0;
    endcase
  end

  assign sent_blocksize = (key_index == block_addr_limit);


  // Encoded Output Length =====================================================
  //
  // KMAC(K,X,L,S) := cSHAKE(newX,L,"KMAC",S)
  //   K : Secret Key
  //   X : Input Message
  //   L : Output Length
  //   S : Customization input string
  //   newX = bytepad(encode_string(key), 168or136) || X || right_encode(L)
  //
  // Software writes desired output length as encoded value into the message
  // FIFO at the end of the message prior to set !!CMD.process.


  ////////////////
  // Assertions //
  ////////////////

  // If process_latched is set, then at Message state, it should be cleared

  `ASSERT(ProcessLatchedCleared_A,
          st == StKmacMsg && process_latched |=> !process_latched)

  // Assume configuration is stable during the operation
  `ASSUME(KmacEnStable_M, $changed(kmac_en_i) |-> st inside {StKmacIdle, StTerminalError})
  `ASSUME(ModeStable_M, $changed(mode_i) |-> st inside {StKmacIdle, StTerminalError})
  `ASSUME(StrengthStable_M,
          $changed(strength_i) |->
          (st inside {StKmacIdle, StTerminalError}) ||
          ($past(st) == StKmacIdle))
  `ASSUME(KeyLengthStableWhenValid_M, key_valid_i && !$rose(key_valid_i) |-> $stable(key_len_i))
  `ASSUME(KeyDataStableWhenValid_M, key_valid_i && !$rose(key_valid_i) |-> $stable(key_data_i))

  // no acked to MsgFIFO in StKmacMsg
  `ASSERT(AckOnlyInMessageState_A,
          fifo_valid_i && fifo_ready_o && kmac_en_i |-> st == StKmacMsg)

endmodule : kmac_core


    """


    Identify the CWE relevant to the security issue for the given RTL.
    Obtain details of the CWE.

    Then determine if there are security issues relevant to the identified CWE in the RTL.
    Refer to the code that corresponds to the issues identified.
    
================================== Ai Message ==================================

[{'text': "I'll analyze the RTL code for security concerns related to FSM hardening, masking, and key handling. Let me first identify relevant CWEs that might apply to these areas.", 'type': 'text'}, {'id': 'toolu_01NygU51FUUxyHpuZXiDV19r', 'input': {'security_issue': 'FSM hardening in hardware design'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01NygU51FUUxyHpuZXiDV19r)
 Call ID: toolu_01NygU51FUUxyHpuZXiDV19r
  Args:
    security_issue: FSM hardening in hardware design
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1245: Improper Finite State Machines (FSMs) in Hardware Logic
Faulty finite state machines (FSMs) in the hardware logic allow an attacker to put the system in an undefined state, to cause a denial of service (DoS) or gain privileges on the victim's system.
The functionality and security of the system heavily depend on the implementation of FSMs. FSMs can be used to indicate the current security state of the system. Lots of secure data operations and data transfers rely on the state reported by the FSM. Faulty FSM designs that do not account for all states, either through undefined states (left as don't cares) or through incorrect implementation, might lead an attacker to drive the system into an unstable state from which the system cannot recover without a reset, thus causing a DoS. Depending on what the FSM is used for, an attacker might also gain additional privileges to launch further attacks and compromise the security guarantees.
Example 1
The Finite State Machine (FSM) shown in the "bad" code snippet below assigns the output ("out") based on the value of state, which is determined based on the user provided input ("user_input").
(bad code)
Example Language: Verilog
module fsm_1(out, user_input, clk, rst_n);
input [2:0] user_input;
input clk, rst_n;
output reg [2:0] out;
reg [1:0] state;
always @ (posedge clk or negedge rst_n )
begin
if (!rst_n)
state = 3'h0;
else
case (user_input)
3'h0:
3'h1:
3'h2:
3'h3: state = 2'h3;
3'h4: state = 2'h2;
3'h5: state = 2'h1;
endcase
end
out <= {1'h1, state};
endmodule
The case statement does not include a default to handle the scenario when the user provides inputs of 3'h6 and 3'h7. Those inputs push the system to an undefined state and might cause a crash (denial of service) or any other unanticipated outcome. Adding a default statement to handle undefined inputs mitigates this issue. This is shown in the "Good" code snippet below. The default statement is in bold.
(good code)
Example Language: Verilog
case (user_input)
3'h0:
3'h1:
3'h2:
3'h3: state = 2'h3;
3'h4: state = 2'h2;
3'h5: state = 2'h1;
default: state = 2'h0;
endcase


================================== Ai Message ==================================

[{'id': 'toolu_01VZv4fybZ7586wBKQCXXfX2', 'input': {'security_issue': 'masking in cryptographic hardware'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01VZv4fybZ7586wBKQCXXfX2)
 Call ID: toolu_01VZv4fybZ7586wBKQCXXfX2
  Args:
    security_issue: masking in cryptographic hardware
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1431: Driving Intermediate Cryptographic State/Results to Hardware Module Outputs
The product uses a hardware module implementing a cryptographic algorithm that writes sensitive information about the intermediate state or results of its cryptographic operations via one of its output wires (typically the output port containing the final result).

Example 1
The following SystemVerilog code is a crypto module that takes input data and encrypts it by processing the data through multiple encryption rounds.
(bad code)
Example language: Verilog
01 | module crypto_core_with_leakage
02 | (
03 | input clk,
04 | input rst,
05 | input [127:0] data_i,
06 | output [127:0] data_o,
07 | output valid
08 | );
09 |
10 | localparam int total_rounds = 10;
11 | logic [3:0] round_id_q;
12 | logic [127:0] data_state_q, data_state_d;
13 | logic [127:0] key_state_q, key_state_d;
14 |
15 | crypto_algo_round u_algo_round (
16 | .clk (clk),
17 | .rst (rst),
18 | .round_i (round_id_q ),
19 | .key_i (key_state_q ),
20 | .data_i (data_state_q),
21 | .key_o (key_state_d ),
22 | .data_o (data_state_d)
23 | );
24 |
25 | always @(posedge clk) begin
26 | if (rst) begin
27 | data_state_q <= 0;
28 | key_state_q <= 0;
29 | round_id_q <= 0;
30 | end
31 | else begin
32 | case (round_id_q)
33 | total_rounds: begin
34 | data_state_q <= 0;
35 | key_state_q <= 0;
36 | round_id_q <= 0;
37 | end
38 |
39 | default: begin
40 | data_state_q <= data_state_d;
41 | key_state_q <= key_state_d;
42 | round_id_q <= round_id_q + 1;
43 | end
44 | endcase
45 | end
46 | end
47 |
48 | assign valid = (round_id_q == total_rounds) ? 1'b1 : 1'b0;
49 |
50 | assign data_o = data_state_q;
51 |
52 | endmodule
In line 50 above, data_state_q is assigned to data_o. Since data_state_q contains intermediate state/results, this allows an attacker to obtain these results through data_o.
In line 50 of the fixed logic below, while "data_state_q" does not contain the final result, a "sanitizing" mechanism drives a safe default value (i.e., 0) to "data_o" instead of the value of "data_state_q". In doing so, the mechanism prevents the exposure of intermediate state/results which could be used to break soundness of the cryptographic operation being performed.
(good code)
Example language: Verilog
01 | module crypto_core_without_leakage
02 | (
03 | input clk,
04 | input rst,
05 | input [127:0] data_i,
06 | output [127:0] data_o,
07 | output valid
08 | );
09 |
10 | localparam int total_rounds = 10;
11 | logic [3:0] round_id_q;
12 | logic [127:0] data_state_q, data_state_d;
13 | logic [127:0] key_state_q, key_state_d;
14 |
15 | crypto_algo_round u_algo_round (
16 | .clk (clk),
17 | .rst (rst),
18 | .round_i (round_id_q ),
19 | .key_i (key_state_q ),
20 | .data_i (data_state_q),
21 | .key_o (key_state_d ),
22 | .data_o (data_state_d)
23 | );
24 |
25 | always @(posedge clk) begin
26 | if (rst) begin
27 | data_state_q <= 0;
28 | key_state_q <= 0;
29 | round_id_q <= 0;
30 | end
31 | else begin
32 | case (round_id_q)
33 | total_rounds: begin
34 | data_state_q <= 0;
35 | key_state_q <= 0;
36 | round_id_q <= 0;
37 | end
38 |
39 | default: begin
40 | data_state_q <= data_state_d;
41 | key_state_q <= key_state_d;
42 | round_id_q <= round_id_q + 1;
43 | end
44 | endcase
45 | end
46 | end
47 |
48 | assign valid = (round_id_q == total_rounds) ? 1'b1 : 1'b0;
49 |
50 | assign data_o = (valid) ? data_state_q : 0;
51 |
52 | endmodule
================================== Ai Message ==================================

[{'id': 'toolu_01KgDkLoAhtNSUuu75EgmR6W', 'input': {'security_issue': 'cryptographic key handling in hardware'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01KgDkLoAhtNSUuu75EgmR6W)
 Call ID: toolu_01KgDkLoAhtNSUuu75EgmR6W
  Args:
    security_issue: cryptographic key handling in hardware
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1233: Security-Sensitive Hardware Controls with Missing Lock Bit Protection
The product uses a register lock bit protection mechanism, but it does not ensure that the lock bit prevents modification of system registers or controls that perform changes to important hardware system configuration.
Integrated circuits and hardware intellectual properties (IPs) might provide device configuration controls that need to be programmed after device power reset by a trusted firmware or software module, commonly set by BIOS/bootloader. After reset, there can be an expectation that the controls cannot be used to perform any further modification. This behavior is commonly implemented using a trusted lock bit, which can be set to disable writes to a protected set of registers or address regions. The lock protection is intended to prevent modification of certain system configuration (e.g., memory/memory protection unit configuration).
Example 1
Consider the example design below for a digital thermal sensor that detects overheating of the silicon and triggers system shutdown. The system critical temperature limit (CRITICAL_TEMP_LIMIT) and thermal sensor calibration (TEMP_SENSOR_CALIB) data have to be programmed by the firmware.
(bad code)
Example Language: Other
Register Field description CRITICAL_TEMP_LIMIT [31:8] Reserved field; Read only; Default 0 [7:0] Critical temp 0-255 Centigrade; Read-write-lock; Default 125 TEMP_SENSOR_CALIB [31:0] Thermal sensor calibration data. A slope value used to map sensor reading to a degree Centigrade. Read-write; Default 25 TEMP_SENSOR_LOCK [31:1] Reserved field; Read only; Default 0 [0] Lock bit, locks CRITICAL_TEMP_LIMIT register; Write-1-once; Default 0 TEMP_HW_SHUTDOWN [31:2] Reserved field; Read only; Default 0 [1] Enable hardware shutdown on a critical temperature detection; Read-write; Default 0 CURRENT_TEMP [31:8] Reserved field; Read only; Default 0 [7:0] Current Temp 0-255 Centigrade; Read-only; Default 0
In this example note that only the CRITICAL_TEMP_LIMIT register is protected by the TEMP_SENSOR_LOCK bit, while the security design intent is to protect any modification of the critical temperature detection and response. The response of the system, if the system heats to a critical temperature, is controlled by TEMP_HW_SHUTDOWN bit [1], which is not lockable. Also, the TEMP_SENSOR_CALIB register is not protected by the lock bit. By modifying the temperature sensor calibration, the conversion of the sensor data to a degree centigrade can be changed, such that the current temperature will never be detected to exceed critical temperature value programmed by the protected lock. Similarly, by modifying the TEMP_HW_SHUTDOWN.Enable bit, the system response detection of the current temperature exceeding critical temperature can be disabled.
(good code)
Example Language: Other
Change TEMP_HW_SHUTDOWN and TEMP_SENSOR_CALIB controls to be locked by TEMP_SENSOR_LOCK. TEMP_SENSOR_CALIB [31:0] Thermal sensor calibration data. A slope value used to map sensor reading to a degree Centigrade. Read-write-Lock; Default 25; Locked by TEMP_SENSOR_LOCK bit[0] TEMP_HW_SHUTDOWN [31:2] Reserved field; Read only; Default 0[1] Enable hardware shutdown on critical temperature detection; Read-write-Lock; Default 0; Locked by TEMP_SENSOR_LOCK bit[0]


================================== Ai Message ==================================

[{'id': 'toolu_01Y68jJBchJfUkGMX1h9Rn1J', 'input': {'security_issue': 'side channel attacks in cryptographic hardware'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01Y68jJBchJfUkGMX1h9Rn1J)
 Call ID: toolu_01Y68jJBchJfUkGMX1h9Rn1J
  Args:
    security_issue: side channel attacks in cryptographic hardware
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

[{"id": "toolu_01Y68jJBchJfUkGMX1h9Rn1J", "input": {"security_issue": "side channel attacks in cryptographic hardware"}, "name": "llm_cwe_details_retriever_tool", "type": "tool_use"}]
================================== Ai Message ==================================
Tool Calls:
  run_anomaly_detector_agent (call_Y6bIRY8WzaLAFMdp4FXdClMQ)
 Call ID: call_Y6bIRY8WzaLAFMdp4FXdClMQ
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_core.sv
    top_module: kmac_core
    security_objective: FSM hardening, masking, key handling
================================ Human Message =================================

Are there security concerns related to FSM hardening, masking, key handling in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_core.sv

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// KMAC control and padding logic

`include "prim_assert.sv"

module kmac_core
  import kmac_pkg::*;
#(
  // EnMasking: Enable masking security hardening inside keccak_round
  // If it is enabled, the result digest will be two set of 1600bit.
  parameter  bit EnMasking = 0,
  localparam int Share = (EnMasking) ? 2 : 1 // derived parameter
) (
  input clk_i,
  input rst_ni,

  // From Message FIFO
  input                fifo_valid_i,
  input [MsgWidth-1:0] fifo_data_i [Share],
  input [MsgStrbW-1:0] fifo_strb_i,
  output logic         fifo_ready_o,

  // to SHA3 Core
  output logic                msg_valid_o,
  output logic [MsgWidth-1:0] msg_data_o  [Share],
  output logic [MsgStrbW-1:0] msg_strb_o,
  input                       msg_ready_i,

  // Configurations

  // If kmac_en is cleared, Core logic doesn't function but forward incoming
  // message to SHA3 core
  input                             kmac_en_i,
  input sha3_pkg::sha3_mode_e       mode_i,
  input sha3_pkg::keccak_strength_e strength_i,

  // Key input from CSR
  input [MaxKeyLen-1:0] key_data_i [Share],
  input key_len_e       key_len_i,
  input logic           key_valid_i,

  // Controls : same to SHA3 core
  input start_i,
  input process_i,
  input prim_mubi_pkg::mubi4_t done_i,

  // Control to SHA3 core
  output logic process_o,

  // Life cycle
  input  lc_ctrl_pkg::lc_tx_t lc_escalate_en_i,

  output logic sparse_fsm_error_o,
  output logic key_index_error_o
);

  import sha3_pkg::KeccakMsgAddrW;
  import sha3_pkg::KeccakCountW;
  import sha3_pkg::KeccakRate;
  import sha3_pkg::L128;
  import sha3_pkg::L224;
  import sha3_pkg::L256;
  import sha3_pkg::L384;
  import sha3_pkg::L512;

  /////////////////
  // Definitions //
  /////////////////

  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 3 -m 5 -n 6 \
  //      -s 401658243 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: |||||||||||||||||||| (50.00%)
  //  4: |||||||||||||||| (40.00%)
  //  5: |||| (10.00%)
  //  6: --
  //
  // Minimum Hamming distance: 3
  // Maximum Hamming distance: 5
  // Minimum Hamming weight: 1
  // Maximum Hamming weight: 4
  //
  localparam int StateWidth = 6;
  typedef enum logic [StateWidth-1:0] {
    StKmacIdle = 6'b011000,

    // Secret Key pushing stage
    // The key is sliced by prim_slicer. This state pushes the sliced data into
    // SHA3 hashing engine. When it hits the block size limit,
    // (same as in sha3pad) the state machine moves to Message.
    StKey = 6'b010111,

    // Incoming Message
    // The core does nothing but forwarding the incoming message to SHA3 hashing
    // engine by turning off `en_kmac_datapath`.
    StKmacMsg = 6'b001110,

    // Wait till done signal
    StKmacFlush = 6'b101011,

    // Terminal Error
    StTerminalError = 6'b100000
  } kmac_st_e ;

  /////////////
  // Signals //
  /////////////

  // represents encode_string(K)
  logic [MaxEncodedKeyW-1:0] encoded_key [Share];

  // Key slice address
  // This signal controls the 64 bit output of the sliced secret_key.
  logic [sha3_pkg::KeccakMsgAddrW-1:0] key_index;
  logic inc_keyidx, clr_keyidx;

  // `sent_blocksize` indicates that the encoded key is sent to sha3 hashing
  // engine. If this hits at StKey stage, the state moves to message state.
  logic [sha3_pkg::KeccakCountW-1:0] block_addr_limit;
  logic sent_blocksize;

  // Internal message signals
  logic                kmac_valid       ;
  logic [MsgWidth-1:0] kmac_data [Share];
  logic [MsgStrbW-1:0] kmac_strb        ;

  // Control SHA3 core
  // `kmac_process` is to forward the process signal to SHA3 core only after
  // the KMAC core writes the key block in case of the message is empty.
  // If the incoming message is empty, there's chance that the `process_i`
  // signal can be asserted while KMAC core processing the key block.
  logic kmac_process, process_latched;

  // Indication of Secret key write stage. Only in this stage, the internal
  // message interface is active.
  logic en_key_write;
  logic en_kmac_datapath;

  // Encoded key has wider bits. `key_sliced` is the data to send to sha3
  logic [MsgWidth-1:0] key_sliced [Share];

  // The following signals are only used in assertions.
  logic unused_signals;
  assign unused_signals = ^{mode_i, key_valid_i};

  /////////
  // FSM //
  /////////
  kmac_st_e st, st_d;

  // State register
  `PRIM_FLOP_SPARSE_FSM(u_state_regs, st_d, st, kmac_st_e, StKmacIdle)

  // Next state and output logic
  // SEC_CM: FSM.SPARSE
  always_comb begin
    st_d = st;

    en_kmac_datapath = 1'b 0;
    en_key_write = 1'b 0;

    clr_keyidx = 1'b 0;

    kmac_valid = 1'b 0;
    kmac_process = 1'b 0;

    sparse_fsm_error_o = 1'b 0;

    unique case (st)
      StKmacIdle: begin
        if (kmac_en_i && start_i) begin
          st_d = StKey;
        end else begin
          st_d = StKmacIdle;
        end
      end

      // If State enters here, regardless of the `process_i`, the state writes
      // full block size of the key into SHA3 hashing engine.
      StKey: begin
        en_kmac_datapath = 1'b 1;
        en_key_write = 1'b 1;

        if (sent_blocksize) begin
          st_d = StKmacMsg;

          kmac_valid = 1'b 0;
          clr_keyidx = 1'b 1;
        end else begin
          st_d = StKey;

          kmac_valid = 1'b 1;
        end
      end

      StKmacMsg: begin
        // If process is previously latched, it is sent to SHA3 here.
        if (process_i || process_latched) begin
          st_d = StKmacFlush;

          kmac_process = 1'b 1;
        end else begin
          st_d = StKmacMsg;
        end
      end

      StKmacFlush: begin
        if (prim_mubi_pkg::mubi4_test_true_strict(done_i)) begin
          st_d = StKmacIdle;
        end else begin
          st_d = StKmacFlush;
        end
      end

      StTerminalError: begin
        // this state is terminal
        st_d = st;
        sparse_fsm_error_o = 1'b 1;
      end

      default: begin
        // this state is terminal
        st_d = StTerminalError;
        sparse_fsm_error_o = 1'b 1;
      end
    endcase

    // SEC_CM: FSM.GLOBAL_ESC, FSM.LOCAL_ESC
    // Unconditionally jump into the terminal error state
    // if the life cycle controller triggers an escalation.
    if (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) begin
      st_d = StTerminalError;
    end
  end

  //////////////
  // Datapath //
  //////////////

  // DATA Mux depending on kmac_en
  // When Key write happens, hold the FIFO request. so fifo_ready_o is tied to 0
  assign msg_valid_o  = (en_kmac_datapath) ? kmac_valid : fifo_valid_i;
  assign msg_data_o   = (en_kmac_datapath) ? kmac_data  : fifo_data_i ;
  assign msg_strb_o   = (en_kmac_datapath) ? kmac_strb  : fifo_strb_i ;
  assign fifo_ready_o = (en_kmac_datapath) ? 1'b 0      : msg_ready_i ;

  // secret key write request to SHA3 hashing engine is always full width write.
  // KeyMgr is fixed 256 bit output. So `right_encode(256)` is 0x020100 --> strb 3
  assign kmac_strb = (en_key_write ) ? '1 : '0;

  assign kmac_data = (en_key_write) ? key_sliced : '{default:'0};

  // Process is controlled by the KMAC core always.
  // This is mainly to prevent process_i asserted while KMAC core is writing
  // the secret key to SHA3 hashing engine (the empty message case)
  assign process_o = (kmac_en_i) ? kmac_process : process_i ;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      process_latched <= 1'b 0;
    end else if (process_i && !process_o) begin
      process_latched <= 1'b 1;
    end else if (process_o ||
      prim_mubi_pkg::mubi4_test_true_strict(done_i)) begin
      process_latched <= 1'b 0;
    end
  end

  // bytepad(encode_string(K), 168 or 136) =====================================
  // 1. Prepare left_encode(w)
  // 2. Prepare left_encode(len(secret_key))
  // 3. Concatenate left_encode(len(secret_key)) || secret_key
  // 4. Concaatenate left_encode(w) || encode_string(secret_key)
  // 5. Based on the address, slice out the data into MsgWidth bits

  // left_encode(w): Same as used in sha3pad logic.
  logic [15:0] encode_bytepad;
  assign encode_bytepad = sha3_pkg::encode_bytepad_len(strength_i);

  // left_encode(len(secret_key))
  // encoded length is always byte size. Use MaxEncodedKeyLenByte parameter
  // from kmac_pkg and add one more byte to indicate how many bytes used to
  // represent len(secret_key)
  // Note that if the secret_key is 128 bit, only lower 16 bits of
  // `encode_keylen` are valid. Refer `encoded_key` concatenation logic below.
  // As the encoded string in the spec big-endian, The endian swap is a must.
  logic [MaxEncodedKeyLenSize + 8 - 1:0] encode_keylen [Share];

  always_comb begin
    // the spec mentioned the key length is encoded in left_encode()
    // The number is represented in big-endian. For example:
    // 384 ==> 0x02 0x01 0x80
    // The first byte is the number of bytes to represent 384
    // The second byte represents 2**8 number, which is 256 here.
    // The third byte represents 2**0 number, which is 128.
    // The data put into MsgFIFO is little-endian and SHA3(Keccak) processes in
    // little-endian. So, below keylen swaps the byte order
    unique case (key_len_i)
      //                           endian-swapped key_length          num_bytes
      // Key128: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(128)}}, 8'h 01};
      // Key192: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(192)}}, 8'h 01};
      // Key256: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(256)}}, 8'h 02};
      // Key384: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(384)}}, 8'h 02};
      // Key512: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(512)}}, 8'h 02};

      // Vivado does not support stream swap for non context value. So assign
      // the value directly.
      Key128: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 0080_01);
      Key192: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 00C0_01);
      Key256: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 0001_02);
      Key384: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 8001_02);
      Key512: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 0002_02);
      default: encode_keylen[0] = '0;
    endcase
  end

  if (EnMasking) begin: gen_encode_keylen_masked
    assign encode_keylen[1] = '0;
  end

  // encode_string(secret_key): Concatenate key
  // Based on the left_encode(len(secret_key)) size, the concatenation logic
  // should be changed. If key length is 128 bit, only lower 16 bits of the
  // encoded length are used so that the upper 8 bits are padded with 0 as
  // defined in bytepad() function.

  for (genvar i = 0 ; i < Share; i++) begin : gen_encoded_key
    always_comb begin
      unique case (key_len_i)
        // In Key 128, 192 case, only lower parts of encode_keylen signal is
        // used. So upper padding requires 8 more bits than MaxKeyLen - keylen
        Key128: encoded_key[i] = {(8 + MaxKeyLen - 128)'(0),
                                  key_data_i[i][0+:128],
                                  encode_keylen[i][0+:MaxEncodedKeyLenSize]};

        Key192: encoded_key[i] = {(8 + MaxKeyLen - 192)'(0),
                                  key_data_i[i][0+:192],
                                  encode_keylen[i][0+:MaxEncodedKeyLenSize]};

        Key256: encoded_key[i] = {(MaxKeyLen - 256)'(0),
                                  key_data_i[i][0+:256],
                                  encode_keylen[i]};

        Key384: encoded_key[i] = {(MaxKeyLen - 384)'(0),
                                  key_data_i[i][0+:384],
                                  encode_keylen[i]};

        // Assume 512bit is the MaxKeyLen
        Key512: encoded_key[i] = {key_data_i[i][0+:512],
                                  encode_keylen[i]};

        default: encoded_key[i] = '0;
      endcase
    end
  end : gen_encoded_key

  // Above logic assumes MaxKeyLen as 512 bits. Revise if it is not.
  `ASSERT_INIT(MaxKeyLenMatchToKey512_A, kmac_pkg::MaxKeyLen == 512)

  // Combine the bytepad `left_encode(w)` and the `encode_string(secret_key)`
  logic [MaxEncodedKeyW + 16 -1 :0] encoded_key_block [Share];

  assign encoded_key_block[0] = {encoded_key[0], encode_bytepad};

  if (EnMasking) begin : gen_encoded_key_block_masked
    assign encoded_key_block[1] = {encoded_key[1], 16'h 0};
  end

  // Slicer to slice out 64 bits
  for (genvar i = 0 ; i < Share ; i++) begin : gen_key_slicer
    prim_slicer #(
      .InW (MaxEncodedKeyW+16),
      .IndexW(KeccakMsgAddrW),
      .OutW(MsgWidth)
    ) u_key_slicer (
      .sel_i  (key_index),
      .data_i (encoded_key_block[i]),
      .data_o (key_sliced[i])
    );
  end

  // `key_index` logic
  // key_index is used to select MsgWidth data from long `encoded_key_block`
  // It behaves same as `keccak_addr` or `prefix_index` in sha3pad module.
  assign inc_keyidx = kmac_valid & msg_ready_i ;

  // This primitive is used to place a hardened counter
  // SEC_CM: CTR.REDUN
  prim_count #(
    .Width(sha3_pkg::KeccakMsgAddrW)
  ) u_key_index_count (
    .clk_i,
    .rst_ni,
    .clr_i(clr_keyidx),
    .set_i(1'b0),
    .set_cnt_i('0),
    .incr_en_i(inc_keyidx),
    .decr_en_i(1'b0),
    .step_i(sha3_pkg::KeccakMsgAddrW'(1)),
    .commit_i(1'b1),
    .cnt_o(key_index),
    .cnt_after_commit_o(),
    .err_o(key_index_error_o)
  );

  // Block size based on the address.
  // This is used for bytepad() and also pad10*1()
  // assign block_addr_limit = KeccakRate[strength_i];
  // but below is easier to understand
  always_comb begin
    unique case (strength_i)
      L128: block_addr_limit = KeccakCountW'(KeccakRate[L128]);
      L224: block_addr_limit = KeccakCountW'(KeccakRate[L224]);
      L256: block_addr_limit = KeccakCountW'(KeccakRate[L256]);
      L384: block_addr_limit = KeccakCountW'(KeccakRate[L384]);
      L512: block_addr_limit = KeccakCountW'(KeccakRate[L512]);

      default: block_addr_limit = '0;
    endcase
  end

  assign sent_blocksize = (key_index == block_addr_limit);


  // Encoded Output Length =====================================================
  //
  // KMAC(K,X,L,S) := cSHAKE(newX,L,"KMAC",S)
  //   K : Secret Key
  //   X : Input Message
  //   L : Output Length
  //   S : Customization input string
  //   newX = bytepad(encode_string(key), 168or136) || X || right_encode(L)
  //
  // Software writes desired output length as encoded value into the message
  // FIFO at the end of the message prior to set !!CMD.process.


  ////////////////
  // Assertions //
  ////////////////

  // If process_latched is set, then at Message state, it should be cleared

  `ASSERT(ProcessLatchedCleared_A,
          st == StKmacMsg && process_latched |=> !process_latched)

  // Assume configuration is stable during the operation
  `ASSUME(KmacEnStable_M, $changed(kmac_en_i) |-> st inside {StKmacIdle, StTerminalError})
  `ASSUME(ModeStable_M, $changed(mode_i) |-> st inside {StKmacIdle, StTerminalError})
  `ASSUME(StrengthStable_M,
          $changed(strength_i) |->
          (st inside {StKmacIdle, StTerminalError}) ||
          ($past(st) == StKmacIdle))
  `ASSUME(KeyLengthStableWhenValid_M, key_valid_i && !$rose(key_valid_i) |-> $stable(key_len_i))
  `ASSUME(KeyDataStableWhenValid_M, key_valid_i && !$rose(key_valid_i) |-> $stable(key_data_i))

  // no acked to MsgFIFO in StKmacMsg
  `ASSERT(AckOnlyInMessageState_A,
          fifo_valid_i && fifo_ready_o && kmac_en_i |-> st == StKmacMsg)

endmodule : kmac_core

    '''

    Use the anomaly detector tool to identify lines in the design RTL that are anomalous.
    Then determine whether the identified anomalous line(s) represent a security issue or not.

    
================================== Ai Message ==================================
Tool Calls:
  anomaly_detector_tool (call_pK2gpqtBo1rgixTJ2xr78jK9)
 Call ID: call_pK2gpqtBo1rgixTJ2xr78jK9
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_core.sv
================================= Tool Message =================================
Name: anomaly_detector_tool

Successfully executed:
```LLM Anomaly Detector tool
```
Output:
Here are clusters of similar verilog constructs in the RTL file:



Cluster 0:
assign msg_valid_o  = (en_kmac_datapath) ? kmac_valid : fifo_valid_i;
assign msg_data_o   = (en_kmac_datapath) ? kmac_data  : fifo_data_i ;
assign msg_strb_o   = (en_kmac_datapath) ? kmac_strb  : fifo_strb_i ;
assign fifo_ready_o = (en_kmac_datapath) ? 1'b 0      : msg_ready_i ;


Cluster 1:
assign kmac_strb = (en_key_write ) ? '1 : '0;
assign kmac_data = (en_key_write) ? key_sliced : '{default:'0};


Cluster 2:
assign encode_keylen[1] = '0;
assign encoded_key_block[0] = {encoded_key[0], encode_bytepad};
assign encoded_key_block[1] = {encoded_key[1], 16'h 0};

================================== Ai Message ==================================

The anomaly detector tool has identified the following clusters of similar constructs. There are no explicit lines that stand out as anomalous or suspicious by themselves.

Reviewing the code from a security perspective considering FSM hardening, masking, and key handling:

1. FSM Hardening:
   - The FSM states are sparse encoded with a minimum Hamming distance of 3 providing inherent protection against single-bit errors.
   - There is a dedicated terminal error state, with transitions to this state triggered by lifecycle escalation signals, which is a good design practice.
   - The code includes comments indicating security related annotations like SEC_CM marks.
   - The FSM is designed to cleanly handle transitions and errors, which is consistent with good FSM hardening practices.

2. Masking:
   - Masking is enabled optionally via the EnMasking parameter.
   - When masking is enabled (EnMasking=1), the design supports two shares to mask data, as seen in inputs and internal signals.
   - Masking is applied to key encoding steps as well, ensuring that the secret key representation is protected.

3. Key Handling:
   - The secret key is handled carefully, with slicing and encoding properly implemented.
   - There are stable assumptions and assertions for key validity and length stability.
   - Key indices are hardened with prim_count module and any key index errors are flagged.
   - The encoded key block concatenates key encoding and a padding, and slices it carefully to feed into the SHA3 core.
   - The process signal is latched and controlled to prevent processing commands while writing keys, avoiding race conditions.

Overall, the design follows good security practices for FSM hardening, masking, and key handling. There are no obvious security issues or anomalies detected by the tool.

**Conclusion:**
- No anomalous lines detected.
- No security issues identified related to FSM hardening, masking, or key handling in the provided RTL code.
================================= Tool Message =================================
Name: run_anomaly_detector_agent

The anomaly detector tool has identified the following clusters of similar constructs. There are no explicit lines that stand out as anomalous or suspicious by themselves.

Reviewing the code from a security perspective considering FSM hardening, masking, and key handling:

1. FSM Hardening:
   - The FSM states are sparse encoded with a minimum Hamming distance of 3 providing inherent protection against single-bit errors.
   - There is a dedicated terminal error state, with transitions to this state triggered by lifecycle escalation signals, which is a good design practice.
   - The code includes comments indicating security related annotations like SEC_CM marks.
   - The FSM is designed to cleanly handle transitions and errors, which is consistent with good FSM hardening practices.

2. Masking:
   - Masking is enabled optionally via the EnMasking parameter.
   - When masking is enabled (EnMasking=1), the design supports two shares to mask data, as seen in inputs and internal signals.
   - Masking is applied to key encoding steps as well, ensuring that the secret key representation is protected.

3. Key Handling:
   - The secret key is handled carefully, with slicing and encoding properly implemented.
   - There are stable assumptions and assertions for key validity and length stability.
   - Key indices are hardened with prim_count module and any key index errors are flagged.
   - The encoded key block concatenates key encoding and a padding, and slices it carefully to feed into the SHA3 core.
   - The process signal is latched and controlled to prevent processing commands while writing keys, avoiding race conditions.

Overall, the design follows good security practices for FSM hardening, masking, and key handling. There are no obvious security issues or anomalies detected by the tool.

**Conclusion:**
- No anomalous lines detected.
- No security issues identified related to FSM hardening, masking, or key handling in the provided RTL code.
================================== Ai Message ==================================
Tool Calls:
  run_assertions_checker_agent (call_BLchLMaurj3l5WcPJeWC3xSZ)
 Call ID: call_BLchLMaurj3l5WcPJeWC3xSZ
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_msgfifo.sv
    top_module: kmac_msgfifo
    security_objective: FIFO masking, message integrity, privilege separation
================================ Human Message =================================

Are there security concerns related to FIFO masking, message integrity, privilege separation in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_msgfifo.sv

    And the top module is:

    kmac_msgfifo

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// KMAC MSG_FIFO
//
// This module converts TL-UL interface into MSG_FIFO interface used in KMAC.

`include "prim_assert.sv"

module kmac_msgfifo
  import kmac_pkg::*;
#(
  // OutWidth is MsgFIFO data width. prim_packer converts InW to OutW prior to
  // pushing to MsgFIFO
  parameter int OutWidth = 64,

  parameter bit EnMasking = 1'b 1,

  // Internal MsgFIFO Entry count
  parameter  int MsgDepth = 9,
  localparam int MsgDepthW = $clog2(MsgDepth+1) // derived parameter
) (
  input clk_i,
  input rst_ni,

  // from REG or KeyMgr Intf input
  input                fifo_valid_i,
  input [OutWidth-1:0] fifo_data_i,
  input [OutWidth-1:0] fifo_mask_i,
  output               fifo_ready_o,

  // MSG interface
  output logic                  msg_valid_o,
  output logic [OutWidth-1:0]   msg_data_o,
  output logic [OutWidth/8-1:0] msg_strb_o,
  input                         msg_ready_i,

  output logic                 fifo_empty_o,
  output logic                 fifo_full_o,
  output logic [MsgDepthW-1:0] fifo_depth_o,

  // Control
  input prim_mubi_pkg::mubi4_t clear_i,

  // process_i --> process_o
  // process_o asserted after all internal messages are flushed out to MSG interface
  input        process_i,
  output logic process_o,

  err_t err_o
);

  /////////////////
  // Definitions //
  /////////////////
  typedef struct packed {
    logic [OutWidth-1:0]   data;
    logic [OutWidth/8-1:0] strb; // one bit per byte
  } fifo_t;

  typedef enum logic [1:0] {
    // In Idle, it checks if process input received or not.
    // If received, the signal goes to packer and flush internal pending data
    FlushIdle,

    // In Packer state, it waits the packer flush operation completes.
    // The flush_done signal do nothing but after this, it is assumed that
    // MSG FIFO received the request.
    FlushPacker,

    // In Fifo, it waits until MsgFifo is empty. Then asserts process_o
    FlushFifo,

    // After flushing, it waits the done (clear) signal. It is assumed that
    // no incoming messages are transmitted between `process_i` and `clear_i`
    FlushClear
  } flush_st_e;

  /////////////
  // Signals //
  /////////////

  // Packer write path
  logic                packer_wvalid;
  logic [OutWidth-1:0] packer_wdata;
  logic [OutWidth-1:0] packer_wmask;
  logic                packer_wready;

  // Message FIFO signals
  logic  fifo_wvalid;
  fifo_t fifo_wdata;
  logic  fifo_wready;
  logic  fifo_rvalid;
  fifo_t fifo_rdata;
  logic  fifo_rready;

  logic fifo_err; // FIFO dup. counter error

  // packer flush to msg_fifo, then msg_fifo empty out the internals
  // then assert msgfifo_flush_done
  logic packer_flush_done;
  logic msgfifo_flush_done;

  logic packer_err;

  // SEC_CM: PACKER.CTR.REDUN
  prim_packer #(
    .InW          (OutWidth),
    .OutW         (OutWidth),
    .HintByteData (1),

    // Turn on dup counter when EnMasking is set
    .EnProtection (EnMasking)
  ) u_packer (
    .clk_i,
    .rst_ni,

    .valid_i      (fifo_valid_i),
    .data_i       (fifo_data_i),
    .mask_i       (fifo_mask_i),
    .ready_o      (fifo_ready_o),

    .valid_o      (packer_wvalid),
    .data_o       (packer_wdata),
    .mask_o       (packer_wmask),
    .ready_i      (packer_wready),

    .flush_i      (process_i),
    .flush_done_o (packer_flush_done),

    .err_o (packer_err)
  );

  // Assign packer wdata and wmask to FIFO struct
  // In contrast to HMAC case, KMAC SHA3 operates in little-endian. MSG fifo is
  // converted into 3-D form so the endianess here is not a problem.
  assign fifo_wdata.data = packer_wdata;
  always_comb begin
    fifo_wdata.strb = '0;
    for (int i = 0 ; i < OutWidth/8 ; i++) begin
      fifo_wdata.strb[i] = packer_wmask[8*i];
    end
  end

  // MsgFIFO
  prim_fifo_sync #(
    .Width  ($bits(fifo_t)),
    .Pass   (1'b 1),
    .Depth  (MsgDepth),
    .Secure (EnMasking)
  ) u_msgfifo (
    .clk_i,
    .rst_ni,
    .clr_i   (prim_mubi_pkg::mubi4_test_true_strict(clear_i)),

    .wvalid_i(fifo_wvalid),
    .wready_o(fifo_wready),
    .wdata_i (fifo_wdata),

    .rvalid_o (fifo_rvalid),
    .rready_i (fifo_rready),
    .rdata_o  (fifo_rdata),

    .full_o  (fifo_full_o),
    .depth_o (fifo_depth_o),
    .err_o   (fifo_err)

  );

  assign fifo_wvalid = packer_wvalid;
  assign packer_wready = fifo_wready;

  assign msg_valid_o = fifo_rvalid;
  assign fifo_rready = msg_ready_i;
  assign msg_data_o  = fifo_rdata.data;
  assign msg_strb_o  = fifo_rdata.strb;

  assign fifo_empty_o = !fifo_rvalid;

  // Flush (process from outside) handling
  flush_st_e flush_st, flush_st_d;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      flush_st <= FlushIdle;
    end else begin
      flush_st <= flush_st_d;
    end
  end

  always_comb begin
    flush_st_d = flush_st;

    msgfifo_flush_done = 1'b 0;

    unique case (flush_st)
      FlushIdle: begin
        if (process_i) begin
          flush_st_d = FlushPacker;
        end else begin
          flush_st_d = FlushIdle;
        end
      end

      FlushPacker: begin
        if (packer_flush_done) begin
          flush_st_d = FlushFifo;
        end else begin
          flush_st_d = FlushPacker;
        end
      end

      FlushFifo: begin
        if (fifo_empty_o) begin
          flush_st_d = FlushClear;

          msgfifo_flush_done = 1'b 1;
        end else begin
          flush_st_d = FlushFifo;
        end
      end

      FlushClear: begin
        if (prim_mubi_pkg::mubi4_test_true_strict(clear_i)) begin
          flush_st_d = FlushIdle;
        end else begin
          flush_st_d = FlushClear;
        end
      end

      default: begin
        flush_st_d = FlushIdle;
      end
    endcase
  end

  assign process_o = msgfifo_flush_done;

  // Error assign
  always_comb begin : error_logic
    err_o = '{
      valid: 1'b 0,
      code: kmac_pkg::ErrNone,
      info: '0
    };

    // Priority case -> if .. else if
    if (packer_err) begin
      err_o = '{
        // If EnProtection is 0, packer_err is tied to 0
        valid: 1'b 1,
        code:  kmac_pkg::ErrPackerIntegrity,
        info:  kmac_pkg::ErrInfoW'(flush_st)
      };
    end else if (fifo_err) begin
      err_o = '{
        valid: 1'b 1,
        code:  kmac_pkg::ErrMsgFifoIntegrity,
        info:  kmac_pkg::ErrInfoW'(flush_st)
      };
    end
  end : error_logic

  ////////////////
  // Assertions //
  ////////////////

  // Flush state known checker
  `ASSERT(FlushStInValid_A, flush_st inside {FlushIdle, FlushPacker, FlushFifo, FlushClear})

  // Packer done signal is asserted at least one cycle later
  `ASSERT(PackerDoneDelay_A, $onehot0({process_i, packer_flush_done}))

  // process_i not asserted during the flush operation
  `ASSUME(PackerDoneValid_a, process_i |-> flush_st == FlushIdle)

  // No messages in between `process_i` and `clear_i`
  `ASSUME(MessageValid_a, fifo_valid_i |-> flush_st == FlushIdle)

endmodule

    '''

    Form relevant system verilog assertions for the RTL to be checked for.
    These system verilog assertions should be in a dict with the key as the name and the value as the assertion string.
    An example assertions object to be sent to assertion checker tool is as follows:

    assertions = {"assertion_p1":"property p1;\n    @(posedge clk) signal_A |-> signal_B;\nendproperty
assertion_p1: assert property (p1);", "assertion_p2":"property p2;\n    @(posedge clk) conditions |-> signal_C;\nendproperty\nassertion_p2: assert property (p2);"}

    Then run the assertions using the assertion checker tool. This tool call must include the assertions dictionary as an argument.
    From the output of the assertion checker tool, determine if there are security issues in the RTL.
    If there are no falsified assertions in the output from the assertion checker tool, that means there are no verified security issues in the RTL.

    
================================== Ai Message ==================================

[{'text': "I'll analyze the RTL code for security concerns related to FIFO masking, message integrity, and privilege separation, then create relevant assertions to check these concerns.\n\nLooking at the code, I can identify several potential security areas to check:\n1. FIFO masking functionality (EnMasking parameter)\n2. Message integrity protection\n3. Proper handling of the flush/process state machine\n4. Error detection and reporting\n\nLet me create assertions to verify these security properties:", 'type': 'text'}, {'id': 'toolu_01DfVnALFdHk1q1ppiMCTBt4', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_msgfifo.sv', 'top_module': 'kmac_msgfifo', 'assertions': {'mask_integrity_p': "property mask_integrity_p;\n  @(posedge clk_i) EnMasking && fifo_valid_i |-> fifo_mask_i != '0;\nendproperty\nassertion_mask_integrity: assert property(mask_integrity_p);", 'error_reporting_p': 'property error_reporting_p;\n  @(posedge clk_i) (packer_err || fifo_err) |-> ##[1:3] err_o.valid;\nendproperty\nassertion_error_reporting: assert property(error_reporting_p);', 'process_clear_sequence_p': 'property process_clear_sequence_p;\n  @(posedge clk_i) process_i |-> ##[1:$] prim_mubi_pkg::mubi4_test_true_strict(clear_i);\nendproperty\nassertion_process_clear_sequence: assert property(process_clear_sequence_p);', 'no_messages_during_flush_p': 'property no_messages_during_flush_p;\n  @(posedge clk_i) (flush_st != FlushIdle) |-> !fifo_valid_i;\nendproperty\nassertion_no_messages_during_flush: assert property(no_messages_during_flush_p);', 'fifo_security_p': "property fifo_security_p;\n  @(posedge clk_i) EnMasking |-> u_msgfifo.Secure == 1'b1;\nendproperty\nassertion_fifo_security: assert property(fifo_security_p);"}, 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01DfVnALFdHk1q1ppiMCTBt4)
 Call ID: toolu_01DfVnALFdHk1q1ppiMCTBt4
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_msgfifo.sv
    top_module: kmac_msgfifo
    assertions: {'mask_integrity_p': "property mask_integrity_p;\n  @(posedge clk_i) EnMasking && fifo_valid_i |-> fifo_mask_i != '0;\nendproperty\nassertion_mask_integrity: assert property(mask_integrity_p);", 'error_reporting_p': 'property error_reporting_p;\n  @(posedge clk_i) (packer_err || fifo_err) |-> ##[1:3] err_o.valid;\nendproperty\nassertion_error_reporting: assert property(error_reporting_p);', 'process_clear_sequence_p': 'property process_clear_sequence_p;\n  @(posedge clk_i) process_i |-> ##[1:$] prim_mubi_pkg::mubi4_test_true_strict(clear_i);\nendproperty\nassertion_process_clear_sequence: assert property(process_clear_sequence_p);', 'no_messages_during_flush_p': 'property no_messages_during_flush_p;\n  @(posedge clk_i) (flush_st != FlushIdle) |-> !fifo_valid_i;\nendproperty\nassertion_no_messages_during_flush: assert property(no_messages_during_flush_p);', 'fifo_security_p': "property fifo_security_p;\n  @(posedge clk_i) EnMasking |-> u_msgfifo.Secure == 1'b1;\nendproperty\nassertion_fifo_security: assert property(fifo_security_p);"}
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: assertion_checker_tool

Failed to execute. Error: KeyError('assertion_mask_integrity')
KeyError: 'assertion_mask_integrity'
Traceback (most recent call last):
  File "/home/XXXX-2/security_agents/security_agents.py", line 763, in assertion_checker_tool
    falsified_properties[name] = assertions[name]
                               ~~~~~~~~~~^^^^^^
KeyError: 'assertion_mask_integrity'
================================== Ai Message ==================================

[{'text': 'I need to fix the format of my assertions. Let me try again with the correct format:', 'type': 'text'}, {'id': 'toolu_016szakocZEbM2qnRDpkNoCZ', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_msgfifo.sv', 'top_module': 'kmac_msgfifo', 'assertions': {'mask_integrity_p': "property mask_integrity_p;\n  @(posedge clk_i) EnMasking && fifo_valid_i |-> fifo_mask_i != '0;\nendproperty\nmask_integrity_p: assert property(mask_integrity_p);", 'error_reporting_p': 'property error_reporting_p;\n  @(posedge clk_i) (packer_err || fifo_err) |-> ##[1:3] err_o.valid;\nendproperty\nerror_reporting_p: assert property(error_reporting_p);', 'process_clear_sequence_p': 'property process_clear_sequence_p;\n  @(posedge clk_i) process_i |-> ##[1:$] prim_mubi_pkg::mubi4_test_true_strict(clear_i);\nendproperty\nprocess_clear_sequence_p: assert property(process_clear_sequence_p);', 'no_messages_during_flush_p': 'property no_messages_during_flush_p;\n  @(posedge clk_i) (flush_st != FlushIdle) |-> !fifo_valid_i;\nendproperty\nno_messages_during_flush_p: assert property(no_messages_during_flush_p);', 'fifo_security_p': "property fifo_security_p;\n  @(posedge clk_i) EnMasking |-> u_msgfifo.Secure == 1'b1;\nendproperty\nfifo_security_p: assert property(fifo_security_p);"}, 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_016szakocZEbM2qnRDpkNoCZ)
 Call ID: toolu_016szakocZEbM2qnRDpkNoCZ
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_msgfifo.sv
    top_module: kmac_msgfifo
    assertions: {'mask_integrity_p': "property mask_integrity_p;\n  @(posedge clk_i) EnMasking && fifo_valid_i |-> fifo_mask_i != '0;\nendproperty\nmask_integrity_p: assert property(mask_integrity_p);", 'error_reporting_p': 'property error_reporting_p;\n  @(posedge clk_i) (packer_err || fifo_err) |-> ##[1:3] err_o.valid;\nendproperty\nerror_reporting_p: assert property(error_reporting_p);', 'process_clear_sequence_p': 'property process_clear_sequence_p;\n  @(posedge clk_i) process_i |-> ##[1:$] prim_mubi_pkg::mubi4_test_true_strict(clear_i);\nendproperty\nprocess_clear_sequence_p: assert property(process_clear_sequence_p);', 'no_messages_during_flush_p': 'property no_messages_during_flush_p;\n  @(posedge clk_i) (flush_st != FlushIdle) |-> !fifo_valid_i;\nendproperty\nno_messages_during_flush_p: assert property(no_messages_during_flush_p);', 'fifo_security_p': "property fifo_security_p;\n  @(posedge clk_i) EnMasking |-> u_msgfifo.Secure == 1'b1;\nendproperty\nfifo_security_p: assert property(fifo_security_p);"}
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: assertion_checker_tool

Failed to execute. Error: KeyError('assertion_mask_integrity')
KeyError: 'assertion_mask_integrity'
Traceback (most recent call last):
  File "/home/XXXX-2/security_agents/security_agents.py", line 763, in assertion_checker_tool
    falsified_properties[name] = assertions[name]
                               ~~~~~~~~~~^^^^^^
KeyError: 'assertion_mask_integrity'
================================== Ai Message ==================================

[{'text': 'I need to ensure the assertion names match exactly. Let me fix the format once more:', 'type': 'text'}, {'id': 'toolu_01Fhh9ZZ9eWPemLNGJwKhPLX', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_msgfifo.sv', 'top_module': 'kmac_msgfifo', 'assertions': {'assertion_mask_integrity': "property p_mask_integrity;\n  @(posedge clk_i) EnMasking && fifo_valid_i |-> fifo_mask_i != '0;\nendproperty\nassertion_mask_integrity: assert property(p_mask_integrity);", 'assertion_error_reporting': 'property p_error_reporting;\n  @(posedge clk_i) (packer_err || fifo_err) |-> ##[1:3] err_o.valid;\nendproperty\nassertion_error_reporting: assert property(p_error_reporting);', 'assertion_process_clear_sequence': 'property p_process_clear_sequence;\n  @(posedge clk_i) process_i |-> ##[1:$] prim_mubi_pkg::mubi4_test_true_strict(clear_i);\nendproperty\nassertion_process_clear_sequence: assert property(p_process_clear_sequence);', 'assertion_no_messages_during_flush': 'property p_no_messages_during_flush;\n  @(posedge clk_i) (flush_st != FlushIdle) |-> !fifo_valid_i;\nendproperty\nassertion_no_messages_during_flush: assert property(p_no_messages_during_flush);', 'assertion_fifo_security': "property p_fifo_security;\n  @(posedge clk_i) EnMasking |-> u_msgfifo.Secure == 1'b1;\nendproperty\nassertion_fifo_security: assert property(p_fifo_security);"}, 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01Fhh9ZZ9eWPemLNGJwKhPLX)
 Call ID: toolu_01Fhh9ZZ9eWPemLNGJwKhPLX
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_msgfifo.sv
    top_module: kmac_msgfifo
    assertions: {'assertion_mask_integrity': "property p_mask_integrity;\n  @(posedge clk_i) EnMasking && fifo_valid_i |-> fifo_mask_i != '0;\nendproperty\nassertion_mask_integrity: assert property(p_mask_integrity);", 'assertion_error_reporting': 'property p_error_reporting;\n  @(posedge clk_i) (packer_err || fifo_err) |-> ##[1:3] err_o.valid;\nendproperty\nassertion_error_reporting: assert property(p_error_reporting);', 'assertion_process_clear_sequence': 'property p_process_clear_sequence;\n  @(posedge clk_i) process_i |-> ##[1:$] prim_mubi_pkg::mubi4_test_true_strict(clear_i);\nendproperty\nassertion_process_clear_sequence: assert property(p_process_clear_sequence);', 'assertion_no_messages_during_flush': 'property p_no_messages_during_flush;\n  @(posedge clk_i) (flush_st != FlushIdle) |-> !fifo_valid_i;\nendproperty\nassertion_no_messages_during_flush: assert property(p_no_messages_during_flush);', 'assertion_fifo_security': "property p_fifo_security;\n  @(posedge clk_i) EnMasking |-> u_msgfifo.Secure == 1'b1;\nendproperty\nassertion_fifo_security: assert property(p_fifo_security);"}
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: assertion_checker_tool

Successfully executed:
```assertion checker tool
```
Output:
 The following properties were falsified:
property p_mask_integrity;
  @(posedge clk_i) EnMasking && fifo_valid_i |-> fifo_mask_i != '0;
endproperty
assertion_mask_integrity: assert property(p_mask_integrity);

property p_no_messages_during_flush;
  @(posedge clk_i) (flush_st != FlushIdle) |-> !fifo_valid_i;
endproperty
assertion_no_messages_during_flush: assert property(p_no_messages_during_flush);
================================== Ai Message ==================================

Based on the assertion checker results, I've identified two security concerns in the RTL:

1. **FIFO Masking Issue (assertion_mask_integrity)**: 
   The assertion checking that `fifo_mask_i` is non-zero when masking is enabled failed. This indicates that the design allows zero masks when masking is enabled, which could lead to security vulnerabilities. When masking is enabled, a zero mask would effectively nullify the masking protection, potentially exposing sensitive data.

2. **Message Processing During Flush (assertion_no_messages_during_flush)**:
   The assertion verifying that no new messages are accepted during flush operations failed. This suggests that the design might allow new messages to be processed while a flush operation is in progress, which could lead to data corruption or security breaches. The RTL has an assumption (`MessageValid_a`) that should prevent this, but the formal verification shows this property can be violated.

These issues could have significant security implications:

- The masking issue could compromise the side-channel protection that masking is intended to provide, potentially exposing cryptographic operations to power analysis attacks.
  
- The message processing during flush issue could allow an attacker to inject messages during sensitive state transitions, potentially corrupting the cryptographic process or causing information leakage.

The other assertions passed, indicating that:
- Error reporting appears to be functioning correctly
- The process-clear sequence is properly implemented
- The FIFO security parameter is correctly configured when masking is enabled

To address these security concerns, the RTL should be modified to:
1. Ensure that when masking is enabled, the mask value is never zero
2. Strengthen the implementation to prevent new messages from being accepted during flush operations, possibly by adding hardware enforcement rather than relying on assumptions
================================= Tool Message =================================
Name: run_assertions_checker_agent

Based on the assertion checker results, I've identified two security concerns in the RTL:

1. **FIFO Masking Issue (assertion_mask_integrity)**: 
   The assertion checking that `fifo_mask_i` is non-zero when masking is enabled failed. This indicates that the design allows zero masks when masking is enabled, which could lead to security vulnerabilities. When masking is enabled, a zero mask would effectively nullify the masking protection, potentially exposing sensitive data.

2. **Message Processing During Flush (assertion_no_messages_during_flush)**:
   The assertion verifying that no new messages are accepted during flush operations failed. This suggests that the design might allow new messages to be processed while a flush operation is in progress, which could lead to data corruption or security breaches. The RTL has an assumption (`MessageValid_a`) that should prevent this, but the formal verification shows this property can be violated.

These issues could have significant security implications:

- The masking issue could compromise the side-channel protection that masking is intended to provide, potentially exposing cryptographic operations to power analysis attacks.
  
- The message processing during flush issue could allow an attacker to inject messages during sensitive state transitions, potentially corrupting the cryptographic process or causing information leakage.

The other assertions passed, indicating that:
- Error reporting appears to be functioning correctly
- The process-clear sequence is properly implemented
- The FIFO security parameter is correctly configured when masking is enabled

To address these security concerns, the RTL should be modified to:
1. Ensure that when masking is enabled, the mask value is never zero
2. Strengthen the implementation to prevent new messages from being accepted during flush operations, possibly by adding hardware enforcement rather than relying on assumptions
================================== Ai Message ==================================
Tool Calls:
  run_linter_agent (call_mrvwMEg4FdIOR4P4u5jbvH8a)
 Call ID: call_mrvwMEg4FdIOR4P4u5jbvH8a
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_msgfifo.sv
    top_module: kmac_msgfifo
    security_objective: FIFO masking, message integrity, privilege separation
================================ Human Message =================================

Are there security concerns related to FIFO masking, message integrity, privilege separation in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_msgfifo.sv

    And the top module is:

    kmac_msgfifo

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// KMAC MSG_FIFO
//
// This module converts TL-UL interface into MSG_FIFO interface used in KMAC.

`include "prim_assert.sv"

module kmac_msgfifo
  import kmac_pkg::*;
#(
  // OutWidth is MsgFIFO data width. prim_packer converts InW to OutW prior to
  // pushing to MsgFIFO
  parameter int OutWidth = 64,

  parameter bit EnMasking = 1'b 1,

  // Internal MsgFIFO Entry count
  parameter  int MsgDepth = 9,
  localparam int MsgDepthW = $clog2(MsgDepth+1) // derived parameter
) (
  input clk_i,
  input rst_ni,

  // from REG or KeyMgr Intf input
  input                fifo_valid_i,
  input [OutWidth-1:0] fifo_data_i,
  input [OutWidth-1:0] fifo_mask_i,
  output               fifo_ready_o,

  // MSG interface
  output logic                  msg_valid_o,
  output logic [OutWidth-1:0]   msg_data_o,
  output logic [OutWidth/8-1:0] msg_strb_o,
  input                         msg_ready_i,

  output logic                 fifo_empty_o,
  output logic                 fifo_full_o,
  output logic [MsgDepthW-1:0] fifo_depth_o,

  // Control
  input prim_mubi_pkg::mubi4_t clear_i,

  // process_i --> process_o
  // process_o asserted after all internal messages are flushed out to MSG interface
  input        process_i,
  output logic process_o,

  err_t err_o
);

  /////////////////
  // Definitions //
  /////////////////
  typedef struct packed {
    logic [OutWidth-1:0]   data;
    logic [OutWidth/8-1:0] strb; // one bit per byte
  } fifo_t;

  typedef enum logic [1:0] {
    // In Idle, it checks if process input received or not.
    // If received, the signal goes to packer and flush internal pending data
    FlushIdle,

    // In Packer state, it waits the packer flush operation completes.
    // The flush_done signal do nothing but after this, it is assumed that
    // MSG FIFO received the request.
    FlushPacker,

    // In Fifo, it waits until MsgFifo is empty. Then asserts process_o
    FlushFifo,

    // After flushing, it waits the done (clear) signal. It is assumed that
    // no incoming messages are transmitted between `process_i` and `clear_i`
    FlushClear
  } flush_st_e;

  /////////////
  // Signals //
  /////////////

  // Packer write path
  logic                packer_wvalid;
  logic [OutWidth-1:0] packer_wdata;
  logic [OutWidth-1:0] packer_wmask;
  logic                packer_wready;

  // Message FIFO signals
  logic  fifo_wvalid;
  fifo_t fifo_wdata;
  logic  fifo_wready;
  logic  fifo_rvalid;
  fifo_t fifo_rdata;
  logic  fifo_rready;

  logic fifo_err; // FIFO dup. counter error

  // packer flush to msg_fifo, then msg_fifo empty out the internals
  // then assert msgfifo_flush_done
  logic packer_flush_done;
  logic msgfifo_flush_done;

  logic packer_err;

  // SEC_CM: PACKER.CTR.REDUN
  prim_packer #(
    .InW          (OutWidth),
    .OutW         (OutWidth),
    .HintByteData (1),

    // Turn on dup counter when EnMasking is set
    .EnProtection (EnMasking)
  ) u_packer (
    .clk_i,
    .rst_ni,

    .valid_i      (fifo_valid_i),
    .data_i       (fifo_data_i),
    .mask_i       (fifo_mask_i),
    .ready_o      (fifo_ready_o),

    .valid_o      (packer_wvalid),
    .data_o       (packer_wdata),
    .mask_o       (packer_wmask),
    .ready_i      (packer_wready),

    .flush_i      (process_i),
    .flush_done_o (packer_flush_done),

    .err_o (packer_err)
  );

  // Assign packer wdata and wmask to FIFO struct
  // In contrast to HMAC case, KMAC SHA3 operates in little-endian. MSG fifo is
  // converted into 3-D form so the endianess here is not a problem.
  assign fifo_wdata.data = packer_wdata;
  always_comb begin
    fifo_wdata.strb = '0;
    for (int i = 0 ; i < OutWidth/8 ; i++) begin
      fifo_wdata.strb[i] = packer_wmask[8*i];
    end
  end

  // MsgFIFO
  prim_fifo_sync #(
    .Width  ($bits(fifo_t)),
    .Pass   (1'b 1),
    .Depth  (MsgDepth),
    .Secure (EnMasking)
  ) u_msgfifo (
    .clk_i,
    .rst_ni,
    .clr_i   (prim_mubi_pkg::mubi4_test_true_strict(clear_i)),

    .wvalid_i(fifo_wvalid),
    .wready_o(fifo_wready),
    .wdata_i (fifo_wdata),

    .rvalid_o (fifo_rvalid),
    .rready_i (fifo_rready),
    .rdata_o  (fifo_rdata),

    .full_o  (fifo_full_o),
    .depth_o (fifo_depth_o),
    .err_o   (fifo_err)

  );

  assign fifo_wvalid = packer_wvalid;
  assign packer_wready = fifo_wready;

  assign msg_valid_o = fifo_rvalid;
  assign fifo_rready = msg_ready_i;
  assign msg_data_o  = fifo_rdata.data;
  assign msg_strb_o  = fifo_rdata.strb;

  assign fifo_empty_o = !fifo_rvalid;

  // Flush (process from outside) handling
  flush_st_e flush_st, flush_st_d;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      flush_st <= FlushIdle;
    end else begin
      flush_st <= flush_st_d;
    end
  end

  always_comb begin
    flush_st_d = flush_st;

    msgfifo_flush_done = 1'b 0;

    unique case (flush_st)
      FlushIdle: begin
        if (process_i) begin
          flush_st_d = FlushPacker;
        end else begin
          flush_st_d = FlushIdle;
        end
      end

      FlushPacker: begin
        if (packer_flush_done) begin
          flush_st_d = FlushFifo;
        end else begin
          flush_st_d = FlushPacker;
        end
      end

      FlushFifo: begin
        if (fifo_empty_o) begin
          flush_st_d = FlushClear;

          msgfifo_flush_done = 1'b 1;
        end else begin
          flush_st_d = FlushFifo;
        end
      end

      FlushClear: begin
        if (prim_mubi_pkg::mubi4_test_true_strict(clear_i)) begin
          flush_st_d = FlushIdle;
        end else begin
          flush_st_d = FlushClear;
        end
      end

      default: begin
        flush_st_d = FlushIdle;
      end
    endcase
  end

  assign process_o = msgfifo_flush_done;

  // Error assign
  always_comb begin : error_logic
    err_o = '{
      valid: 1'b 0,
      code: kmac_pkg::ErrNone,
      info: '0
    };

    // Priority case -> if .. else if
    if (packer_err) begin
      err_o = '{
        // If EnProtection is 0, packer_err is tied to 0
        valid: 1'b 1,
        code:  kmac_pkg::ErrPackerIntegrity,
        info:  kmac_pkg::ErrInfoW'(flush_st)
      };
    end else if (fifo_err) begin
      err_o = '{
        valid: 1'b 1,
        code:  kmac_pkg::ErrMsgFifoIntegrity,
        info:  kmac_pkg::ErrInfoW'(flush_st)
      };
    end
  end : error_logic

  ////////////////
  // Assertions //
  ////////////////

  // Flush state known checker
  `ASSERT(FlushStInValid_A, flush_st inside {FlushIdle, FlushPacker, FlushFifo, FlushClear})

  // Packer done signal is asserted at least one cycle later
  `ASSERT(PackerDoneDelay_A, $onehot0({process_i, packer_flush_done}))

  // process_i not asserted during the flush operation
  `ASSUME(PackerDoneValid_a, process_i |-> flush_st == FlushIdle)

  // No messages in between `process_i` and `clear_i`
  `ASSUME(MessageValid_a, fifo_valid_i |-> flush_st == FlushIdle)

endmodule

    '''

    Identify relevant lint tags for the RTL to be checked for.
    Then run the tests using the linting tool.
    From the output of the linting tool, determine if there are security issues in the RTL.
================================== Ai Message ==================================
Tool Calls:
  retrieve_relevant_lint_tags (call_5ZLomrVEqnq3NWahx2puBa8t)
 Call ID: call_5ZLomrVEqnq3NWahx2puBa8t
  Args:
    query: FIFO masking security message integrity privilege separation
================================= Tool Message =================================
Name: retrieve_relevant_lint_tags


W215: Reports inappropriate bit-selects of integer or time variables 


STARC05-2.3.1.7a: A flip-flop should not have two asynchronous resets 


STARC05-1.4.3.1b: Clocks should not be gated 


STARC05-1.3.1.7: A flip-flop must not have both asynchronous set and asynchronous reset 


STARC05-2.11.3.1: Ensure that the sequential and combinational parts of an FSM description should be in separate always blocks. (Verilog)Ensure that the sequential and combinational parts of an FSM description should be separated (VHDL)


STARC05-1.4.3.4: Do not use flip-flop clock signals as non-clock signals 


SelfAssignment-ML: Same operand on both sides of combinational assignment detected 


STARC05-2.2.3.3: Do not assign over the same signal in an always construct for sequential circuits 


STARC05-2.3.5.1: Flip-flops should not have fixed inputs 

W238: Mixing combinational and sequential styles


sim_race06: Flip-flop data path should not be entirely blocking


ClockEnableRace: Reports a race condition between clock and enable pins of a flip-flop 


AsgnToOneBit-ML: Assigning a 0 or 1 (32-bits) to a 1 bit is not allowed 


FlopFeedbackRace-ML: Reports potential race conditions between flip-flop output and its clock/reset pin 


STARC05-1.3.2.1a: Asynchronous resets or sets must not be gated 


STARC05-2.4.1.4: Avoid combinational loops that contain latches 


STARC05-3.3.3.1: A clock must not be connected to the D input of a FF 


STARC05-1.4.3.6: Do not use Flip-Flops with inverted edges 


sim_race08: Control signals of a sequential device should not be multiply driven. 


SepStateMachine: Combinational and sequential parts of a finite-state machine are combined in one process
================================== Ai Message ==================================
Tool Calls:
  lint_checker_tool (call_YLPHAazYYsJarhdOtWY3ZYXZ)
 Call ID: call_YLPHAazYYsJarhdOtWY3ZYXZ
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_msgfifo.sv
    top_module: kmac_msgfifo
    lint_tags: ['W215', 'STARC05-2.3.1.7a', 'STARC05-1.4.3.1b', 'STARC05-1.3.1.7', 'STARC05-2.11.3.1', 'STARC05-1.4.3.4', 'SelfAssignment-ML', 'STARC05-2.2.3.3', 'STARC05-2.3.5.1', 'W238', 'sim_race06', 'ClockEnableRace', 'AsgnToOneBit-ML', 'FlopFeedbackRace-ML', 'STARC05-1.3.2.1a', 'STARC05-2.4.1.4', 'STARC05-3.3.3.1', 'STARC05-1.4.3.6', 'sim_race08', 'SepStateMachine']
================================= Tool Message =================================
Name: lint_checker_tool

Successfully executed:
```lint checker tool
```
Output: 
  -----------------------------------------------------------------------------
  Report Summary
  -----------------------------------------------------------------------------
  Product Info
    Name    : VC Static Master Shell
    Version : U-2023.03-1 -- Apr 17, 2023

  Report Info
    Created : May 06, 2025  16:56:04

    TopLevelModule: kmac_msgfifo

  -----------------------------------------------------------------------------
  Management Summary
  -----------------------------------------------------------------------------
  Stage             Family      Fatals    Errors  Warnings     Infos
  -----             --------  --------  --------  --------  --------
  LANGUAGE_CHECK    CODING           0         1         0         0
  STRUCTURAL_CHECK  CODING           0         1         0         0
  -----             --------  --------  --------  --------  --------
  Total                              0         2         0         0


  -----------------------------------------------------------------------------
  Tree Summary
  -----------------------------------------------------------------------------
  Severity  Stage             Tag                  Count
  --------  -----             -------------------  -----
  error     LANGUAGE_CHECK    SelfAssignment-ML        1
  error     STRUCTURAL_CHECK  STARC05-2.3.5.1          1
  --------  -----             -------------------  -----
  Total                                                2



  -----------------------------------------------------------------------------
  SelfAssignment-ML  (1 error/0 waived)
  -----------------------------------------------------------------------------
  Tag           : SelfAssignment-ML
  Description   : Same operand '[OprandName]' used on both sides of an assignment
  Violation     : Lint:2
  Module        : prim_packer
  FileName      : build/lowrisc_ip_kmac_0.1/src/lowrisc_prim_all_0.1/rtl/prim_packer.sv
  LineNumber    : 67
  Statement     :       inmask_ones = inmask_ones + OnesCntW'(mask_i[i]);
  OprandName    : inmask_ones

  -----------------------------------------------------------------------------
  STARC05-2.3.5.1  (1 error/0 waived)
  -----------------------------------------------------------------------------
  Tag             : STARC05-2.3.5.1
  Description     : Flip-flop '[DesignVariable]' has fixed input value '[NodeType]'
  Violation       : Lint:1
  Module          : prim_fifo_sync
  FileName        : build/lowrisc_ip_kmac_0.1/src/lowrisc_prim_fifo_0/rtl/prim_fifo_sync.sv
  LineNumber      : 72
  Statement       :         under_rst <= ~under_rst;
  DesignVariable  : u_msgfifo/gen_normal_fifo.under_rst
  NodeType        : 0

================================== Ai Message ==================================

The lint check results show two errors, but both are in submodules used by the top module kmac_msgfifo:

1. SelfAssignment-ML error in prim_packer module (line 67 in prim_packer.sv):
   - This indicates a suspicious self-assignment in the prim_packer module, which is used inside kmac_msgfifo.
   - This could potentially affect the masking or integrity logic if the self-assignment causes incorrect behavior.

2. STARC05-2.3.5.1 error in prim_fifo_sync module (line 72 in prim_fifo_sync.sv):
   - This indicates a flip-flop with a fixed input value in the prim_fifo_sync module, which is instantiated as u_msgfifo in kmac_msgfifo.
   - This could affect the FIFO behavior and possibly its security properties.

No direct lint errors were reported in the kmac_msgfifo module itself related to FIFO masking, message integrity, or privilege separation.

Summary:
- The top-level kmac_msgfifo RTL does not show direct lint errors related to the queried security concerns.
- However, the submodules prim_packer and prim_fifo_sync have lint errors that could impact security.
- It is recommended to review and fix the issues in prim_packer and prim_fifo_sync modules to ensure FIFO masking and message integrity are correctly implemented.
- Additionally, manual security review focusing on privilege separation and message integrity should be done as lint checks may not cover all security aspects.

If you want, I can help analyze the submodules or assist with a manual security review of the kmac_msgfifo code.
================================= Tool Message =================================
Name: run_linter_agent

The lint check results show two errors, but both are in submodules used by the top module kmac_msgfifo:

1. SelfAssignment-ML error in prim_packer module (line 67 in prim_packer.sv):
   - This indicates a suspicious self-assignment in the prim_packer module, which is used inside kmac_msgfifo.
   - This could potentially affect the masking or integrity logic if the self-assignment causes incorrect behavior.

2. STARC05-2.3.5.1 error in prim_fifo_sync module (line 72 in prim_fifo_sync.sv):
   - This indicates a flip-flop with a fixed input value in the prim_fifo_sync module, which is instantiated as u_msgfifo in kmac_msgfifo.
   - This could affect the FIFO behavior and possibly its security properties.

No direct lint errors were reported in the kmac_msgfifo module itself related to FIFO masking, message integrity, or privilege separation.

Summary:
- The top-level kmac_msgfifo RTL does not show direct lint errors related to the queried security concerns.
- However, the submodules prim_packer and prim_fifo_sync have lint errors that could impact security.
- It is recommended to review and fix the issues in prim_packer and prim_fifo_sync modules to ensure FIFO masking and message integrity are correctly implemented.
- Additionally, manual security review focusing on privilege separation and message integrity should be done as lint checks may not cover all security aspects.

If you want, I can help analyze the submodules or assist with a manual security review of the kmac_msgfifo code.
================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_uB9oP3v0unVa5bn2PjXYLAa6)
 Call ID: call_uB9oP3v0unVa5bn2PjXYLAa6
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_msgfifo.sv
    top_module: kmac_msgfifo
    security_objective: FIFO masking, message integrity, privilege separation
================================ Human Message =================================

Are there security concerns related to FIFO masking, message integrity, privilege separation in the provided RTL:
    """

    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// KMAC MSG_FIFO
//
// This module converts TL-UL interface into MSG_FIFO interface used in KMAC.

`include "prim_assert.sv"

module kmac_msgfifo
  import kmac_pkg::*;
#(
  // OutWidth is MsgFIFO data width. prim_packer converts InW to OutW prior to
  // pushing to MsgFIFO
  parameter int OutWidth = 64,

  parameter bit EnMasking = 1'b 1,

  // Internal MsgFIFO Entry count
  parameter  int MsgDepth = 9,
  localparam int MsgDepthW = $clog2(MsgDepth+1) // derived parameter
) (
  input clk_i,
  input rst_ni,

  // from REG or KeyMgr Intf input
  input                fifo_valid_i,
  input [OutWidth-1:0] fifo_data_i,
  input [OutWidth-1:0] fifo_mask_i,
  output               fifo_ready_o,

  // MSG interface
  output logic                  msg_valid_o,
  output logic [OutWidth-1:0]   msg_data_o,
  output logic [OutWidth/8-1:0] msg_strb_o,
  input                         msg_ready_i,

  output logic                 fifo_empty_o,
  output logic                 fifo_full_o,
  output logic [MsgDepthW-1:0] fifo_depth_o,

  // Control
  input prim_mubi_pkg::mubi4_t clear_i,

  // process_i --> process_o
  // process_o asserted after all internal messages are flushed out to MSG interface
  input        process_i,
  output logic process_o,

  err_t err_o
);

  /////////////////
  // Definitions //
  /////////////////
  typedef struct packed {
    logic [OutWidth-1:0]   data;
    logic [OutWidth/8-1:0] strb; // one bit per byte
  } fifo_t;

  typedef enum logic [1:0] {
    // In Idle, it checks if process input received or not.
    // If received, the signal goes to packer and flush internal pending data
    FlushIdle,

    // In Packer state, it waits the packer flush operation completes.
    // The flush_done signal do nothing but after this, it is assumed that
    // MSG FIFO received the request.
    FlushPacker,

    // In Fifo, it waits until MsgFifo is empty. Then asserts process_o
    FlushFifo,

    // After flushing, it waits the done (clear) signal. It is assumed that
    // no incoming messages are transmitted between `process_i` and `clear_i`
    FlushClear
  } flush_st_e;

  /////////////
  // Signals //
  /////////////

  // Packer write path
  logic                packer_wvalid;
  logic [OutWidth-1:0] packer_wdata;
  logic [OutWidth-1:0] packer_wmask;
  logic                packer_wready;

  // Message FIFO signals
  logic  fifo_wvalid;
  fifo_t fifo_wdata;
  logic  fifo_wready;
  logic  fifo_rvalid;
  fifo_t fifo_rdata;
  logic  fifo_rready;

  logic fifo_err; // FIFO dup. counter error

  // packer flush to msg_fifo, then msg_fifo empty out the internals
  // then assert msgfifo_flush_done
  logic packer_flush_done;
  logic msgfifo_flush_done;

  logic packer_err;

  // SEC_CM: PACKER.CTR.REDUN
  prim_packer #(
    .InW          (OutWidth),
    .OutW         (OutWidth),
    .HintByteData (1),

    // Turn on dup counter when EnMasking is set
    .EnProtection (EnMasking)
  ) u_packer (
    .clk_i,
    .rst_ni,

    .valid_i      (fifo_valid_i),
    .data_i       (fifo_data_i),
    .mask_i       (fifo_mask_i),
    .ready_o      (fifo_ready_o),

    .valid_o      (packer_wvalid),
    .data_o       (packer_wdata),
    .mask_o       (packer_wmask),
    .ready_i      (packer_wready),

    .flush_i      (process_i),
    .flush_done_o (packer_flush_done),

    .err_o (packer_err)
  );

  // Assign packer wdata and wmask to FIFO struct
  // In contrast to HMAC case, KMAC SHA3 operates in little-endian. MSG fifo is
  // converted into 3-D form so the endianess here is not a problem.
  assign fifo_wdata.data = packer_wdata;
  always_comb begin
    fifo_wdata.strb = '0;
    for (int i = 0 ; i < OutWidth/8 ; i++) begin
      fifo_wdata.strb[i] = packer_wmask[8*i];
    end
  end

  // MsgFIFO
  prim_fifo_sync #(
    .Width  ($bits(fifo_t)),
    .Pass   (1'b 1),
    .Depth  (MsgDepth),
    .Secure (EnMasking)
  ) u_msgfifo (
    .clk_i,
    .rst_ni,
    .clr_i   (prim_mubi_pkg::mubi4_test_true_strict(clear_i)),

    .wvalid_i(fifo_wvalid),
    .wready_o(fifo_wready),
    .wdata_i (fifo_wdata),

    .rvalid_o (fifo_rvalid),
    .rready_i (fifo_rready),
    .rdata_o  (fifo_rdata),

    .full_o  (fifo_full_o),
    .depth_o (fifo_depth_o),
    .err_o   (fifo_err)

  );

  assign fifo_wvalid = packer_wvalid;
  assign packer_wready = fifo_wready;

  assign msg_valid_o = fifo_rvalid;
  assign fifo_rready = msg_ready_i;
  assign msg_data_o  = fifo_rdata.data;
  assign msg_strb_o  = fifo_rdata.strb;

  assign fifo_empty_o = !fifo_rvalid;

  // Flush (process from outside) handling
  flush_st_e flush_st, flush_st_d;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      flush_st <= FlushIdle;
    end else begin
      flush_st <= flush_st_d;
    end
  end

  always_comb begin
    flush_st_d = flush_st;

    msgfifo_flush_done = 1'b 0;

    unique case (flush_st)
      FlushIdle: begin
        if (process_i) begin
          flush_st_d = FlushPacker;
        end else begin
          flush_st_d = FlushIdle;
        end
      end

      FlushPacker: begin
        if (packer_flush_done) begin
          flush_st_d = FlushFifo;
        end else begin
          flush_st_d = FlushPacker;
        end
      end

      FlushFifo: begin
        if (fifo_empty_o) begin
          flush_st_d = FlushClear;

          msgfifo_flush_done = 1'b 1;
        end else begin
          flush_st_d = FlushFifo;
        end
      end

      FlushClear: begin
        if (prim_mubi_pkg::mubi4_test_true_strict(clear_i)) begin
          flush_st_d = FlushIdle;
        end else begin
          flush_st_d = FlushClear;
        end
      end

      default: begin
        flush_st_d = FlushIdle;
      end
    endcase
  end

  assign process_o = msgfifo_flush_done;

  // Error assign
  always_comb begin : error_logic
    err_o = '{
      valid: 1'b 0,
      code: kmac_pkg::ErrNone,
      info: '0
    };

    // Priority case -> if .. else if
    if (packer_err) begin
      err_o = '{
        // If EnProtection is 0, packer_err is tied to 0
        valid: 1'b 1,
        code:  kmac_pkg::ErrPackerIntegrity,
        info:  kmac_pkg::ErrInfoW'(flush_st)
      };
    end else if (fifo_err) begin
      err_o = '{
        valid: 1'b 1,
        code:  kmac_pkg::ErrMsgFifoIntegrity,
        info:  kmac_pkg::ErrInfoW'(flush_st)
      };
    end
  end : error_logic

  ////////////////
  // Assertions //
  ////////////////

  // Flush state known checker
  `ASSERT(FlushStInValid_A, flush_st inside {FlushIdle, FlushPacker, FlushFifo, FlushClear})

  // Packer done signal is asserted at least one cycle later
  `ASSERT(PackerDoneDelay_A, $onehot0({process_i, packer_flush_done}))

  // process_i not asserted during the flush operation
  `ASSUME(PackerDoneValid_a, process_i |-> flush_st == FlushIdle)

  // No messages in between `process_i` and `clear_i`
  `ASSUME(MessageValid_a, fifo_valid_i |-> flush_st == FlushIdle)

endmodule


    """


    Identify the CWE relevant to the security issue for the given RTL.
    Obtain details of the CWE.

    Then determine if there are security issues relevant to the identified CWE in the RTL.
    Refer to the code that corresponds to the issues identified.
    
================================== Ai Message ==================================

[{'text': "I'll analyze the RTL code for security concerns related to FIFO masking, message integrity, and privilege separation. Let me first identify relevant CWEs for these security areas.", 'type': 'text'}, {'id': 'toolu_01CS41PXxANPfHFH6eTBicxx', 'input': {'security_issue': 'FIFO masking and message integrity in hardware'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01CS41PXxANPfHFH6eTBicxx)
 Call ID: toolu_01CS41PXxANPfHFH6eTBicxx
  Args:
    security_issue: FIFO masking and message integrity in hardware
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1264: Hardware Logic with Insecure De-Synchronization between Control and Data Channels
The hardware logic for error handling and security checks can incorrectly forward data before the security check is complete.
Many high-performance on-chip bus protocols and processor data-paths employ separate channels for control and data to increase parallelism and maximize throughput. Bugs in the hardware logic that handle errors and security checks can make it possible for data to be forwarded before the completion of the security checks. If the data can propagate to a location in the hardware observable to an attacker, loss of data confidentiality can occur. 'Meltdown' is a concrete example of how de-synchronization between data and permissions checking logic can violate confidentiality requirements. Data loaded from a page marked as privileged was returned to the cpu regardless of current privilege level for performance reasons. The assumption was that the cpu could later remove all traces of this data during the handling of the illegal memory access exception, but this assumption was proven false as traces of the secret data were not removed from the microarchitectural state.
Example 1
There are several standard on-chip bus protocols used in modern SoCs to allow communication between components. There are a wide variety of commercially available hardware IP implementing the interconnect logic for these protocols. A bus connects components which initiate/request communications such as processors and DMA controllers (bus masters) with peripherals which respond to requests. In a typical system, the privilege level or security designation of the bus master along with the intended functionality of each peripheral determine the security policy specifying which specific bus masters can access specific peripherals. This security policy (commonly referred to as a bus firewall) can be enforced using separate IP/logic from the actual interconnect responsible for the data routing.
(bad code)
Example Language: Other
The firewall and data routing logic becomes de-synchronized due to a hardware logic bug allowing components that should not be allowed to communicate to share data. For example, consider an SoC with two processors. One is being used as a root of trust and can access a cryptographic key storage peripheral. The other processor (application cpu) may run potentially untrusted code and should not access the key store. If the application cpu can issue a read request to the key store which is not blocked due to de-synchronization of data routing and the bus firewall, disclosure of cryptographic keys is possible.
(good code)
Example Language: Other
All data is correctly buffered inside the interconnect until the firewall has determined that the endpoint is allowed to receive the data.


================================== Ai Message ==================================

[{'id': 'toolu_01AnPvuLX3wgEWGrf3uWc1nr', 'input': {'security_issue': 'hardware redundancy and protection mechanisms'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01AnPvuLX3wgEWGrf3uWc1nr)
 Call ID: toolu_01AnPvuLX3wgEWGrf3uWc1nr
  Args:
    security_issue: hardware redundancy and protection mechanisms
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1263: Improper Physical Access Control
The product is designed with access restricted to certain information, but it does not sufficiently protect against an unauthorized actor with physical access to these areas.
Sections of a product intended to have restricted access may be inadvertently or intentionally rendered accessible when the implemented physical protections are insufficient. The specific requirements around how robust the design of the physical protection mechanism needs to be depends on the type of product being protected. Selecting the correct physical protection mechanism and properly enforcing it through implementation and manufacturing are critical to the overall physical security of the product.

================================== Ai Message ==================================

[{'id': 'toolu_01RriJgwUjnBiWsDbispmco9', 'input': {'security_issue': 'hardware integrity protection'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01RriJgwUjnBiWsDbispmco9)
 Call ID: toolu_01RriJgwUjnBiWsDbispmco9
  Args:
    security_issue: hardware integrity protection
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1247: Improper Protection Against Voltage and Clock Glitches
The device does not contain or contains incorrectly implemented circuitry or sensors to detect and mitigate voltage and clock glitches and protect sensitive information or software contained on the device.
A device might support features such as secure boot which are supplemented with hardware and firmware support. This involves establishing a chain of trust, starting with an immutable root of trust by checking the signature of the next stage (culminating with the OS and runtime software) against a golden value before transferring control. The intermediate stages typically set up the system in a secure state by configuring several access control settings. Similarly, security logic for exercising a debug or testing interface may be implemented in hardware, firmware, or both. A device needs to guard against fault attacks such as voltage glitches and clock glitches that an attacker may employ in an attempt to compromise the system.
Example 1
Below is a representative snippet of C code that is part of the secure-boot flow. A signature of the runtime-firmware image is calculated and compared against a golden value. If the signatures match, the bootloader loads runtime firmware. If there is no match, an error halt occurs. If the underlying hardware executing this code does not contain any circuitry or sensors to detect voltage or clock glitches, an attacker might launch a fault-injection attack right when the signature check is happening (at the location marked with the comment), causing a bypass of the signature-checking process.
(bad code)
Example Language: C
... if (signature_matches) // <-Glitch Here { load_runtime_firmware(); } else { do_not_load_runtime_firmware(); } ...
After bypassing secure boot, an attacker can gain access to system assets to which the attacker should not have access.
(good code)
If the underlying hardware detects a voltage or clock glitch, the information can be used to prevent the glitch from being successful.


================================== Ai Message ==================================

[{'id': 'toolu_01HHjFgZci3jMuoMbvVoYK9D', 'input': {'security_issue': 'hardware redundancy counter'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01HHjFgZci3jMuoMbvVoYK9D)
 Call ID: toolu_01HHjFgZci3jMuoMbvVoYK9D
  Args:
    security_issue: hardware redundancy counter
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

[{"id": "toolu_01HHjFgZci3jMuoMbvVoYK9D", "input": {"security_issue": "hardware redundancy counter"}, "name": "llm_cwe_details_retriever_tool", "type": "tool_use"}]
================================== Ai Message ==================================
Tool Calls:
  run_anomaly_detector_agent (call_MY7M5h8kGWywwoGSsZ4UMgQv)
 Call ID: call_MY7M5h8kGWywwoGSsZ4UMgQv
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_msgfifo.sv
    top_module: kmac_msgfifo
    security_objective: FIFO masking, message integrity, privilege separation
================================ Human Message =================================

Are there security concerns related to FIFO masking, message integrity, privilege separation in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_msgfifo.sv

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// KMAC MSG_FIFO
//
// This module converts TL-UL interface into MSG_FIFO interface used in KMAC.

`include "prim_assert.sv"

module kmac_msgfifo
  import kmac_pkg::*;
#(
  // OutWidth is MsgFIFO data width. prim_packer converts InW to OutW prior to
  // pushing to MsgFIFO
  parameter int OutWidth = 64,

  parameter bit EnMasking = 1'b 1,

  // Internal MsgFIFO Entry count
  parameter  int MsgDepth = 9,
  localparam int MsgDepthW = $clog2(MsgDepth+1) // derived parameter
) (
  input clk_i,
  input rst_ni,

  // from REG or KeyMgr Intf input
  input                fifo_valid_i,
  input [OutWidth-1:0] fifo_data_i,
  input [OutWidth-1:0] fifo_mask_i,
  output               fifo_ready_o,

  // MSG interface
  output logic                  msg_valid_o,
  output logic [OutWidth-1:0]   msg_data_o,
  output logic [OutWidth/8-1:0] msg_strb_o,
  input                         msg_ready_i,

  output logic                 fifo_empty_o,
  output logic                 fifo_full_o,
  output logic [MsgDepthW-1:0] fifo_depth_o,

  // Control
  input prim_mubi_pkg::mubi4_t clear_i,

  // process_i --> process_o
  // process_o asserted after all internal messages are flushed out to MSG interface
  input        process_i,
  output logic process_o,

  err_t err_o
);

  /////////////////
  // Definitions //
  /////////////////
  typedef struct packed {
    logic [OutWidth-1:0]   data;
    logic [OutWidth/8-1:0] strb; // one bit per byte
  } fifo_t;

  typedef enum logic [1:0] {
    // In Idle, it checks if process input received or not.
    // If received, the signal goes to packer and flush internal pending data
    FlushIdle,

    // In Packer state, it waits the packer flush operation completes.
    // The flush_done signal do nothing but after this, it is assumed that
    // MSG FIFO received the request.
    FlushPacker,

    // In Fifo, it waits until MsgFifo is empty. Then asserts process_o
    FlushFifo,

    // After flushing, it waits the done (clear) signal. It is assumed that
    // no incoming messages are transmitted between `process_i` and `clear_i`
    FlushClear
  } flush_st_e;

  /////////////
  // Signals //
  /////////////

  // Packer write path
  logic                packer_wvalid;
  logic [OutWidth-1:0] packer_wdata;
  logic [OutWidth-1:0] packer_wmask;
  logic                packer_wready;

  // Message FIFO signals
  logic  fifo_wvalid;
  fifo_t fifo_wdata;
  logic  fifo_wready;
  logic  fifo_rvalid;
  fifo_t fifo_rdata;
  logic  fifo_rready;

  logic fifo_err; // FIFO dup. counter error

  // packer flush to msg_fifo, then msg_fifo empty out the internals
  // then assert msgfifo_flush_done
  logic packer_flush_done;
  logic msgfifo_flush_done;

  logic packer_err;

  // SEC_CM: PACKER.CTR.REDUN
  prim_packer #(
    .InW          (OutWidth),
    .OutW         (OutWidth),
    .HintByteData (1),

    // Turn on dup counter when EnMasking is set
    .EnProtection (EnMasking)
  ) u_packer (
    .clk_i,
    .rst_ni,

    .valid_i      (fifo_valid_i),
    .data_i       (fifo_data_i),
    .mask_i       (fifo_mask_i),
    .ready_o      (fifo_ready_o),

    .valid_o      (packer_wvalid),
    .data_o       (packer_wdata),
    .mask_o       (packer_wmask),
    .ready_i      (packer_wready),

    .flush_i      (process_i),
    .flush_done_o (packer_flush_done),

    .err_o (packer_err)
  );

  // Assign packer wdata and wmask to FIFO struct
  // In contrast to HMAC case, KMAC SHA3 operates in little-endian. MSG fifo is
  // converted into 3-D form so the endianess here is not a problem.
  assign fifo_wdata.data = packer_wdata;
  always_comb begin
    fifo_wdata.strb = '0;
    for (int i = 0 ; i < OutWidth/8 ; i++) begin
      fifo_wdata.strb[i] = packer_wmask[8*i];
    end
  end

  // MsgFIFO
  prim_fifo_sync #(
    .Width  ($bits(fifo_t)),
    .Pass   (1'b 1),
    .Depth  (MsgDepth),
    .Secure (EnMasking)
  ) u_msgfifo (
    .clk_i,
    .rst_ni,
    .clr_i   (prim_mubi_pkg::mubi4_test_true_strict(clear_i)),

    .wvalid_i(fifo_wvalid),
    .wready_o(fifo_wready),
    .wdata_i (fifo_wdata),

    .rvalid_o (fifo_rvalid),
    .rready_i (fifo_rready),
    .rdata_o  (fifo_rdata),

    .full_o  (fifo_full_o),
    .depth_o (fifo_depth_o),
    .err_o   (fifo_err)

  );

  assign fifo_wvalid = packer_wvalid;
  assign packer_wready = fifo_wready;

  assign msg_valid_o = fifo_rvalid;
  assign fifo_rready = msg_ready_i;
  assign msg_data_o  = fifo_rdata.data;
  assign msg_strb_o  = fifo_rdata.strb;

  assign fifo_empty_o = !fifo_rvalid;

  // Flush (process from outside) handling
  flush_st_e flush_st, flush_st_d;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      flush_st <= FlushIdle;
    end else begin
      flush_st <= flush_st_d;
    end
  end

  always_comb begin
    flush_st_d = flush_st;

    msgfifo_flush_done = 1'b 0;

    unique case (flush_st)
      FlushIdle: begin
        if (process_i) begin
          flush_st_d = FlushPacker;
        end else begin
          flush_st_d = FlushIdle;
        end
      end

      FlushPacker: begin
        if (packer_flush_done) begin
          flush_st_d = FlushFifo;
        end else begin
          flush_st_d = FlushPacker;
        end
      end

      FlushFifo: begin
        if (fifo_empty_o) begin
          flush_st_d = FlushClear;

          msgfifo_flush_done = 1'b 1;
        end else begin
          flush_st_d = FlushFifo;
        end
      end

      FlushClear: begin
        if (prim_mubi_pkg::mubi4_test_true_strict(clear_i)) begin
          flush_st_d = FlushIdle;
        end else begin
          flush_st_d = FlushClear;
        end
      end

      default: begin
        flush_st_d = FlushIdle;
      end
    endcase
  end

  assign process_o = msgfifo_flush_done;

  // Error assign
  always_comb begin : error_logic
    err_o = '{
      valid: 1'b 0,
      code: kmac_pkg::ErrNone,
      info: '0
    };

    // Priority case -> if .. else if
    if (packer_err) begin
      err_o = '{
        // If EnProtection is 0, packer_err is tied to 0
        valid: 1'b 1,
        code:  kmac_pkg::ErrPackerIntegrity,
        info:  kmac_pkg::ErrInfoW'(flush_st)
      };
    end else if (fifo_err) begin
      err_o = '{
        valid: 1'b 1,
        code:  kmac_pkg::ErrMsgFifoIntegrity,
        info:  kmac_pkg::ErrInfoW'(flush_st)
      };
    end
  end : error_logic

  ////////////////
  // Assertions //
  ////////////////

  // Flush state known checker
  `ASSERT(FlushStInValid_A, flush_st inside {FlushIdle, FlushPacker, FlushFifo, FlushClear})

  // Packer done signal is asserted at least one cycle later
  `ASSERT(PackerDoneDelay_A, $onehot0({process_i, packer_flush_done}))

  // process_i not asserted during the flush operation
  `ASSUME(PackerDoneValid_a, process_i |-> flush_st == FlushIdle)

  // No messages in between `process_i` and `clear_i`
  `ASSUME(MessageValid_a, fifo_valid_i |-> flush_st == FlushIdle)

endmodule

    '''

    Use the anomaly detector tool to identify lines in the design RTL that are anomalous.
    Then determine whether the identified anomalous line(s) represent a security issue or not.

    
================================== Ai Message ==================================
Tool Calls:
  anomaly_detector_tool (call_EvWxxg5UJEiHRQ6AJWrh2E2O)
 Call ID: call_EvWxxg5UJEiHRQ6AJWrh2E2O
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_msgfifo.sv
================================= Tool Message =================================
Name: anomaly_detector_tool

Successfully executed:
```LLM Anomaly Detector tool
```
Output:
Here are clusters of similar verilog constructs in the RTL file:



Cluster 0:
assign fifo_wdata.data = packer_wdata;
assign fifo_wvalid = packer_wvalid;
assign packer_wready = fifo_wready;
assign msg_valid_o = fifo_rvalid;
assign fifo_rready = msg_ready_i;
assign msg_data_o  = fifo_rdata.data;
assign msg_strb_o  = fifo_rdata.strb;
assign fifo_empty_o = !fifo_rvalid;
assign process_o = msgfifo_flush_done;

================================== Ai Message ==================================

The anomaly detection tool identified one cluster of assignment statements which seem normal and consistent with expected FIFO and message interface signals connections. No anomalous lines were detected by the tool that stand out as irregular or suspicious in the design RTL provided.

After manual review of the design, the code shows:
- Use of EnMasking parameter to enable protection mechanisms in the packer and FIFO indicating a focus on message integrity.
- FSM to safely flush and clear the FIFO ensuring no message bypass between process and clear signals, which is crucial for privilege separation and preventing stale messages.
- Error signals from packer and FIFO indicating integrity errors show they have monitoring in place.
- Assertions and assumptions on flush state and message validity indicate proper control flow and message integrity properties.

Based on the anomaly clustering results and manual code inspection, no anomalous or suspect lines are identified that indicate security vulnerabilities related to FIFO masking, message integrity, or privilege separation. The design appears to implement these security aspects appropriately. 

If you would like, I can provide a more detailed check of specific security properties or possible corner cases.
================================= Tool Message =================================
Name: run_anomaly_detector_agent

The anomaly detection tool identified one cluster of assignment statements which seem normal and consistent with expected FIFO and message interface signals connections. No anomalous lines were detected by the tool that stand out as irregular or suspicious in the design RTL provided.

After manual review of the design, the code shows:
- Use of EnMasking parameter to enable protection mechanisms in the packer and FIFO indicating a focus on message integrity.
- FSM to safely flush and clear the FIFO ensuring no message bypass between process and clear signals, which is crucial for privilege separation and preventing stale messages.
- Error signals from packer and FIFO indicating integrity errors show they have monitoring in place.
- Assertions and assumptions on flush state and message validity indicate proper control flow and message integrity properties.

Based on the anomaly clustering results and manual code inspection, no anomalous or suspect lines are identified that indicate security vulnerabilities related to FIFO masking, message integrity, or privilege separation. The design appears to implement these security aspects appropriately. 

If you would like, I can provide a more detailed check of specific security properties or possible corner cases.
================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_RrSDmEFSwPTvTEdRJanjhDNa)
 Call ID: call_RrSDmEFSwPTvTEdRJanjhDNa
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/kmac/rtl/kmac_reg_top.sv
    top_module: kmac_reg_top
    security_objective: register access control, privilege escalation, shadowed register integrity
================================ Human Message =================================

Are there security concerns related to register access control, privilege escalation, shadowed register integrity in the provided RTL:
    """

    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Register Top module auto-generated by `reggen`

`include "prim_assert.sv"

module kmac_reg_top (
  input clk_i,
  input rst_ni,
  input rst_shadowed_ni,
  input  tlul_pkg::tl_h2d_t tl_i,
  output tlul_pkg::tl_d2h_t tl_o,

  // Output port for window
  output tlul_pkg::tl_h2d_t tl_win_o  [2],
  input  tlul_pkg::tl_d2h_t tl_win_i  [2],

  // To HW
  output kmac_reg_pkg::kmac_reg2hw_t reg2hw, // Write
  input  kmac_reg_pkg::kmac_hw2reg_t hw2reg, // Read

  output logic shadowed_storage_err_o,
  output logic shadowed_update_err_o,

  // Integrity check errors
  output logic intg_err_o
);

  import kmac_reg_pkg::* ;

  localparam int AW = 12;
  localparam int DW = 32;
  localparam int DBW = DW/8;                    // Byte Width

  // register signals
  logic           reg_we;
  logic           reg_re;
  logic [AW-1:0]  reg_addr;
  logic [DW-1:0]  reg_wdata;
  logic [DBW-1:0] reg_be;
  logic [DW-1:0]  reg_rdata;
  logic           reg_error;

  logic          addrmiss, wr_err;

  logic [DW-1:0] reg_rdata_next;
  logic reg_busy;

  tlul_pkg::tl_h2d_t tl_reg_h2d;
  tlul_pkg::tl_d2h_t tl_reg_d2h;


  // incoming payload check
  logic intg_err;
  tlul_cmd_intg_chk u_chk (
    .tl_i(tl_i),
    .err_o(intg_err)
  );

  // also check for spurious write enables
  logic reg_we_err;
  logic [56:0] reg_we_check;
  prim_reg_we_check #(
    .OneHotWidth(57)
  ) u_prim_reg_we_check (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .oh_i  (reg_we_check),
    .en_i  (reg_we && !addrmiss),
    .err_o (reg_we_err)
  );

  logic err_q;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      err_q <= '0;
    end else if (intg_err || reg_we_err) begin
      err_q <= 1'b1;
    end
  end

  // integrity error output is permanent and should be used for alert generation
  // register errors are transactional
  assign intg_err_o = err_q | intg_err | reg_we_err;

  // outgoing integrity generation
  tlul_pkg::tl_d2h_t tl_o_pre;
  tlul_rsp_intg_gen #(
    .EnableRspIntgGen(1),
    .EnableDataIntgGen(1)
  ) u_rsp_intg_gen (
    .tl_i(tl_o_pre),
    .tl_o(tl_o)
  );

  tlul_pkg::tl_h2d_t tl_socket_h2d [3];
  tlul_pkg::tl_d2h_t tl_socket_d2h [3];

  logic [1:0] reg_steer;

  // socket_1n connection
  assign tl_reg_h2d = tl_socket_h2d[2];
  assign tl_socket_d2h[2] = tl_reg_d2h;

  assign tl_win_o[0] = tl_socket_h2d[0];
  assign tl_socket_d2h[0] = tl_win_i[0];
  assign tl_win_o[1] = tl_socket_h2d[1];
  assign tl_socket_d2h[1] = tl_win_i[1];

  // Create Socket_1n
  tlul_socket_1n #(
    .N            (3),
    .HReqPass     (1'b1),
    .HRspPass     (1'b1),
    .DReqPass     ({3{1'b1}}),
    .DRspPass     ({3{1'b1}}),
    .HReqDepth    (4'h0),
    .HRspDepth    (4'h0),
    .DReqDepth    ({3{4'h0}}),
    .DRspDepth    ({3{4'h0}}),
    .ExplicitErrs (1'b0)
  ) u_socket (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),
    .tl_h_i (tl_i),
    .tl_h_o (tl_o_pre),
    .tl_d_o (tl_socket_h2d),
    .tl_d_i (tl_socket_d2h),
    .dev_select_i (reg_steer)
  );

  // Create steering logic
  always_comb begin
    reg_steer =
        tl_i.a_address[AW-1:0] inside {[1024:1535]} ? 2'd0 :
        tl_i.a_address[AW-1:0] inside {[2048:4095]} ? 2'd1 :
        // Default set to register
        2'd2;

    // Override this in case of an integrity error
    if (intg_err) begin
      reg_steer = 2'd2;
    end
  end

  tlul_adapter_reg #(
    .RegAw(AW),
    .RegDw(DW),
    .EnableDataIntgGen(0)
  ) u_reg_if (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),

    .tl_i (tl_reg_h2d),
    .tl_o (tl_reg_d2h),

    .en_ifetch_i(prim_mubi_pkg::MuBi4False),
    .intg_error_o(),

    .we_o    (reg_we),
    .re_o    (reg_re),
    .addr_o  (reg_addr),
    .wdata_o (reg_wdata),
    .be_o    (reg_be),
    .busy_i  (reg_busy),
    .rdata_i (reg_rdata),
    .error_i (reg_error)
  );

  // cdc oversampling signals

  assign reg_rdata = reg_rdata_next ;
  assign reg_error = addrmiss | wr_err | intg_err;

  // Define SW related signals
  // Format: <reg>_<field>_{wd|we|qs}
  //        or <reg>_{wd|we|qs} if field == 1 or 0
  logic intr_state_we;
  logic intr_state_kmac_done_qs;
  logic intr_state_kmac_done_wd;
  logic intr_state_fifo_empty_qs;
  logic intr_state_kmac_err_qs;
  logic intr_state_kmac_err_wd;
  logic intr_enable_we;
  logic intr_enable_kmac_done_qs;
  logic intr_enable_kmac_done_wd;
  logic intr_enable_fifo_empty_qs;
  logic intr_enable_fifo_empty_wd;
  logic intr_enable_kmac_err_qs;
  logic intr_enable_kmac_err_wd;
  logic intr_test_we;
  logic intr_test_kmac_done_wd;
  logic intr_test_fifo_empty_wd;
  logic intr_test_kmac_err_wd;
  logic alert_test_we;
  logic alert_test_recov_operation_err_wd;
  logic alert_test_fatal_fault_err_wd;
  logic cfg_regwen_re;
  logic cfg_regwen_qs;
  logic cfg_shadowed_re;
  logic cfg_shadowed_we;
  logic cfg_shadowed_kmac_en_qs;
  logic cfg_shadowed_kmac_en_wd;
  logic cfg_shadowed_kmac_en_storage_err;
  logic cfg_shadowed_kmac_en_update_err;
  logic [2:0] cfg_shadowed_kstrength_qs;
  logic [2:0] cfg_shadowed_kstrength_wd;
  logic cfg_shadowed_kstrength_storage_err;
  logic cfg_shadowed_kstrength_update_err;
  logic [1:0] cfg_shadowed_mode_qs;
  logic [1:0] cfg_shadowed_mode_wd;
  logic cfg_shadowed_mode_storage_err;
  logic cfg_shadowed_mode_update_err;
  logic cfg_shadowed_msg_endianness_qs;
  logic cfg_shadowed_msg_endianness_wd;
  logic cfg_shadowed_msg_endianness_storage_err;
  logic cfg_shadowed_msg_endianness_update_err;
  logic cfg_shadowed_state_endianness_qs;
  logic cfg_shadowed_state_endianness_wd;
  logic cfg_shadowed_state_endianness_storage_err;
  logic cfg_shadowed_state_endianness_update_err;
  logic cfg_shadowed_sideload_qs;
  logic cfg_shadowed_sideload_wd;
  logic cfg_shadowed_sideload_storage_err;
  logic cfg_shadowed_sideload_update_err;
  logic [1:0] cfg_shadowed_entropy_mode_qs;
  logic [1:0] cfg_shadowed_entropy_mode_wd;
  logic cfg_shadowed_entropy_mode_storage_err;
  logic cfg_shadowed_entropy_mode_update_err;
  logic cfg_shadowed_entropy_fast_process_qs;
  logic cfg_shadowed_entropy_fast_process_wd;
  logic cfg_shadowed_entropy_fast_process_storage_err;
  logic cfg_shadowed_entropy_fast_process_update_err;
  logic cfg_shadowed_msg_mask_qs;
  logic cfg_shadowed_msg_mask_wd;
  logic cfg_shadowed_msg_mask_storage_err;
  logic cfg_shadowed_msg_mask_update_err;
  logic cfg_shadowed_entropy_ready_qs;
  logic cfg_shadowed_entropy_ready_wd;
  logic cfg_shadowed_entropy_ready_storage_err;
  logic cfg_shadowed_entropy_ready_update_err;
  logic cfg_shadowed_en_unsupported_modestrength_qs;
  logic cfg_shadowed_en_unsupported_modestrength_wd;
  logic cfg_shadowed_en_unsupported_modestrength_storage_err;
  logic cfg_shadowed_en_unsupported_modestrength_update_err;
  logic cmd_we;
  logic [5:0] cmd_cmd_wd;
  logic cmd_entropy_req_wd;
  logic cmd_hash_cnt_clr_wd;
  logic cmd_err_processed_wd;
  logic status_re;
  logic status_sha3_idle_qs;
  logic status_sha3_absorb_qs;
  logic status_sha3_squeeze_qs;
  logic [4:0] status_fifo_depth_qs;
  logic status_fifo_empty_qs;
  logic status_fifo_full_qs;
  logic status_alert_fatal_fault_qs;
  logic status_alert_recov_ctrl_update_err_qs;
  logic entropy_period_we;
  logic [9:0] entropy_period_prescaler_qs;
  logic [9:0] entropy_period_prescaler_wd;
  logic [15:0] entropy_period_wait_timer_qs;
  logic [15:0] entropy_period_wait_timer_wd;
  logic [9:0] entropy_refresh_hash_cnt_qs;
  logic entropy_refresh_threshold_shadowed_re;
  logic entropy_refresh_threshold_shadowed_we;
  logic [9:0] entropy_refresh_threshold_shadowed_qs;
  logic [9:0] entropy_refresh_threshold_shadowed_wd;
  logic entropy_refresh_threshold_shadowed_storage_err;
  logic entropy_refresh_threshold_shadowed_update_err;
  logic entropy_seed_we;
  logic [31:0] entropy_seed_wd;
  logic key_share0_0_we;
  logic [31:0] key_share0_0_wd;
  logic key_share0_1_we;
  logic [31:0] key_share0_1_wd;
  logic key_share0_2_we;
  logic [31:0] key_share0_2_wd;
  logic key_share0_3_we;
  logic [31:0] key_share0_3_wd;
  logic key_share0_4_we;
  logic [31:0] key_share0_4_wd;
  logic key_share0_5_we;
  logic [31:0] key_share0_5_wd;
  logic key_share0_6_we;
  logic [31:0] key_share0_6_wd;
  logic key_share0_7_we;
  logic [31:0] key_share0_7_wd;
  logic key_share0_8_we;
  logic [31:0] key_share0_8_wd;
  logic key_share0_9_we;
  logic [31:0] key_share0_9_wd;
  logic key_share0_10_we;
  logic [31:0] key_share0_10_wd;
  logic key_share0_11_we;
  logic [31:0] key_share0_11_wd;
  logic key_share0_12_we;
  logic [31:0] key_share0_12_wd;
  logic key_share0_13_we;
  logic [31:0] key_share0_13_wd;
  logic key_share0_14_we;
  logic [31:0] key_share0_14_wd;
  logic key_share0_15_we;
  logic [31:0] key_share0_15_wd;
  logic key_share1_0_we;
  logic [31:0] key_share1_0_wd;
  logic key_share1_1_we;
  logic [31:0] key_share1_1_wd;
  logic key_share1_2_we;
  logic [31:0] key_share1_2_wd;
  logic key_share1_3_we;
  logic [31:0] key_share1_3_wd;
  logic key_share1_4_we;
  logic [31:0] key_share1_4_wd;
  logic key_share1_5_we;
  logic [31:0] key_share1_5_wd;
  logic key_share1_6_we;
  logic [31:0] key_share1_6_wd;
  logic key_share1_7_we;
  logic [31:0] key_share1_7_wd;
  logic key_share1_8_we;
  logic [31:0] key_share1_8_wd;
  logic key_share1_9_we;
  logic [31:0] key_share1_9_wd;
  logic key_share1_10_we;
  logic [31:0] key_share1_10_wd;
  logic key_share1_11_we;
  logic [31:0] key_share1_11_wd;
  logic key_share1_12_we;
  logic [31:0] key_share1_12_wd;
  logic key_share1_13_we;
  logic [31:0] key_share1_13_wd;
  logic key_share1_14_we;
  logic [31:0] key_share1_14_wd;
  logic key_share1_15_we;
  logic [31:0] key_share1_15_wd;
  logic key_len_we;
  logic [2:0] key_len_wd;
  logic prefix_0_we;
  logic [31:0] prefix_0_qs;
  logic [31:0] prefix_0_wd;
  logic prefix_1_we;
  logic [31:0] prefix_1_qs;
  logic [31:0] prefix_1_wd;
  logic prefix_2_we;
  logic [31:0] prefix_2_qs;
  logic [31:0] prefix_2_wd;
  logic prefix_3_we;
  logic [31:0] prefix_3_qs;
  logic [31:0] prefix_3_wd;
  logic prefix_4_we;
  logic [31:0] prefix_4_qs;
  logic [31:0] prefix_4_wd;
  logic prefix_5_we;
  logic [31:0] prefix_5_qs;
  logic [31:0] prefix_5_wd;
  logic prefix_6_we;
  logic [31:0] prefix_6_qs;
  logic [31:0] prefix_6_wd;
  logic prefix_7_we;
  logic [31:0] prefix_7_qs;
  logic [31:0] prefix_7_wd;
  logic prefix_8_we;
  logic [31:0] prefix_8_qs;
  logic [31:0] prefix_8_wd;
  logic prefix_9_we;
  logic [31:0] prefix_9_qs;
  logic [31:0] prefix_9_wd;
  logic prefix_10_we;
  logic [31:0] prefix_10_qs;
  logic [31:0] prefix_10_wd;
  logic [31:0] err_code_qs;

  // Register instances
  // R[intr_state]: V(False)
  //   F[kmac_done]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_kmac_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_kmac_done_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.kmac_done.de),
    .d      (hw2reg.intr_state.kmac_done.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.kmac_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_kmac_done_qs)
  );

  //   F[fifo_empty]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_fifo_empty (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.intr_state.fifo_empty.de),
    .d      (hw2reg.intr_state.fifo_empty.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.fifo_empty.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_fifo_empty_qs)
  );

  //   F[kmac_err]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_kmac_err (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_kmac_err_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.kmac_err.de),
    .d      (hw2reg.intr_state.kmac_err.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.kmac_err.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_kmac_err_qs)
  );


  // R[intr_enable]: V(False)
  //   F[kmac_done]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_kmac_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_kmac_done_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.kmac_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_kmac_done_qs)
  );

  //   F[fifo_empty]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_fifo_empty (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_fifo_empty_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.fifo_empty.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_fifo_empty_qs)
  );

  //   F[kmac_err]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_kmac_err (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_kmac_err_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.kmac_err.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_kmac_err_qs)
  );


  // R[intr_test]: V(True)
  logic intr_test_qe;
  logic [2:0] intr_test_flds_we;
  assign intr_test_qe = &intr_test_flds_we;
  //   F[kmac_done]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_kmac_done (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_kmac_done_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[0]),
    .q      (reg2hw.intr_test.kmac_done.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.kmac_done.qe = intr_test_qe;

  //   F[fifo_empty]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_fifo_empty (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_fifo_empty_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[1]),
    .q      (reg2hw.intr_test.fifo_empty.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.fifo_empty.qe = intr_test_qe;

  //   F[kmac_err]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_kmac_err (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_kmac_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[2]),
    .q      (reg2hw.intr_test.kmac_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.kmac_err.qe = intr_test_qe;


  // R[alert_test]: V(True)
  logic alert_test_qe;
  logic [1:0] alert_test_flds_we;
  assign alert_test_qe = &alert_test_flds_we;
  //   F[recov_operation_err]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_recov_operation_err (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_recov_operation_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[0]),
    .q      (reg2hw.alert_test.recov_operation_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.recov_operation_err.qe = alert_test_qe;

  //   F[fatal_fault_err]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_fatal_fault_err (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_fatal_fault_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[1]),
    .q      (reg2hw.alert_test.fatal_fault_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.fatal_fault_err.qe = alert_test_qe;


  // R[cfg_regwen]: V(True)
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_regwen (
    .re     (cfg_regwen_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.cfg_regwen.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (cfg_regwen_qs)
  );


  // R[cfg_shadowed]: V(False)
  logic cfg_shadowed_qe;
  logic [10:0] cfg_shadowed_flds_we;
  prim_flop #(
    .Width(1),
    .ResetValue(0)
  ) u_cfg_shadowed0_qe (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .d_i(&cfg_shadowed_flds_we),
    .q_o(cfg_shadowed_qe)
  );
  // Create REGWEN-gated WE signal
  logic cfg_shadowed_gated_we;
  assign cfg_shadowed_gated_we = cfg_shadowed_we & cfg_regwen_qs;
  //   F[kmac_en]: 0:0
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_kmac_en (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_kmac_en_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[0]),
    .q      (reg2hw.cfg_shadowed.kmac_en.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_kmac_en_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_kmac_en_update_err),
    .err_storage (cfg_shadowed_kmac_en_storage_err)
  );
  assign reg2hw.cfg_shadowed.kmac_en.qe = cfg_shadowed_qe;

  //   F[kstrength]: 3:1
  prim_subreg_shadow #(
    .DW      (3),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (3'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_kstrength (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_kstrength_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[1]),
    .q      (reg2hw.cfg_shadowed.kstrength.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_kstrength_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_kstrength_update_err),
    .err_storage (cfg_shadowed_kstrength_storage_err)
  );
  assign reg2hw.cfg_shadowed.kstrength.qe = cfg_shadowed_qe;

  //   F[mode]: 5:4
  prim_subreg_shadow #(
    .DW      (2),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (2'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_mode (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_mode_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[2]),
    .q      (reg2hw.cfg_shadowed.mode.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_mode_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_mode_update_err),
    .err_storage (cfg_shadowed_mode_storage_err)
  );
  assign reg2hw.cfg_shadowed.mode.qe = cfg_shadowed_qe;

  //   F[msg_endianness]: 8:8
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_msg_endianness (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_msg_endianness_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[3]),
    .q      (reg2hw.cfg_shadowed.msg_endianness.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_msg_endianness_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_msg_endianness_update_err),
    .err_storage (cfg_shadowed_msg_endianness_storage_err)
  );
  assign reg2hw.cfg_shadowed.msg_endianness.qe = cfg_shadowed_qe;

  //   F[state_endianness]: 9:9
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_state_endianness (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_state_endianness_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[4]),
    .q      (reg2hw.cfg_shadowed.state_endianness.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_state_endianness_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_state_endianness_update_err),
    .err_storage (cfg_shadowed_state_endianness_storage_err)
  );
  assign reg2hw.cfg_shadowed.state_endianness.qe = cfg_shadowed_qe;

  //   F[sideload]: 12:12
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_sideload (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_sideload_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[5]),
    .q      (reg2hw.cfg_shadowed.sideload.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_sideload_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_sideload_update_err),
    .err_storage (cfg_shadowed_sideload_storage_err)
  );
  assign reg2hw.cfg_shadowed.sideload.qe = cfg_shadowed_qe;

  //   F[entropy_mode]: 17:16
  prim_subreg_shadow #(
    .DW      (2),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (2'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_entropy_mode (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_entropy_mode_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[6]),
    .q      (reg2hw.cfg_shadowed.entropy_mode.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_entropy_mode_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_entropy_mode_update_err),
    .err_storage (cfg_shadowed_entropy_mode_storage_err)
  );
  assign reg2hw.cfg_shadowed.entropy_mode.qe = cfg_shadowed_qe;

  //   F[entropy_fast_process]: 19:19
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_entropy_fast_process (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_entropy_fast_process_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[7]),
    .q      (reg2hw.cfg_shadowed.entropy_fast_process.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_entropy_fast_process_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_entropy_fast_process_update_err),
    .err_storage (cfg_shadowed_entropy_fast_process_storage_err)
  );
  assign reg2hw.cfg_shadowed.entropy_fast_process.qe = cfg_shadowed_qe;

  //   F[msg_mask]: 20:20
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_msg_mask (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_msg_mask_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[8]),
    .q      (reg2hw.cfg_shadowed.msg_mask.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_msg_mask_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_msg_mask_update_err),
    .err_storage (cfg_shadowed_msg_mask_storage_err)
  );
  assign reg2hw.cfg_shadowed.msg_mask.qe = cfg_shadowed_qe;

  //   F[entropy_ready]: 24:24
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_entropy_ready (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_entropy_ready_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[9]),
    .q      (reg2hw.cfg_shadowed.entropy_ready.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_entropy_ready_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_entropy_ready_update_err),
    .err_storage (cfg_shadowed_entropy_ready_storage_err)
  );
  assign reg2hw.cfg_shadowed.entropy_ready.qe = cfg_shadowed_qe;

  //   F[en_unsupported_modestrength]: 26:26
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_cfg_shadowed_en_unsupported_modestrength (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (cfg_shadowed_re),
    .we     (cfg_shadowed_gated_we),
    .wd     (cfg_shadowed_en_unsupported_modestrength_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (cfg_shadowed_flds_we[10]),
    .q      (reg2hw.cfg_shadowed.en_unsupported_modestrength.q),
    .ds     (),

    // to register interface (read)
    .qs     (cfg_shadowed_en_unsupported_modestrength_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (cfg_shadowed_en_unsupported_modestrength_update_err),
    .err_storage (cfg_shadowed_en_unsupported_modestrength_storage_err)
  );
  assign reg2hw.cfg_shadowed.en_unsupported_modestrength.qe = cfg_shadowed_qe;


  // R[cmd]: V(True)
  logic cmd_qe;
  logic [3:0] cmd_flds_we;
  assign cmd_qe = &cmd_flds_we;
  //   F[cmd]: 5:0
  prim_subreg_ext #(
    .DW    (6)
  ) u_cmd_cmd (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_cmd_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[0]),
    .q      (reg2hw.cmd.cmd.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.cmd.qe = cmd_qe;

  //   F[entropy_req]: 8:8
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_entropy_req (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_entropy_req_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[1]),
    .q      (reg2hw.cmd.entropy_req.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.entropy_req.qe = cmd_qe;

  //   F[hash_cnt_clr]: 9:9
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_cnt_clr (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_cnt_clr_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[2]),
    .q      (reg2hw.cmd.hash_cnt_clr.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_cnt_clr.qe = cmd_qe;

  //   F[err_processed]: 10:10
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_err_processed (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_err_processed_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[3]),
    .q      (reg2hw.cmd.err_processed.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.err_processed.qe = cmd_qe;


  // R[status]: V(True)
  //   F[sha3_idle]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_sha3_idle (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.sha3_idle.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_sha3_idle_qs)
  );

  //   F[sha3_absorb]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_sha3_absorb (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.sha3_absorb.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_sha3_absorb_qs)
  );

  //   F[sha3_squeeze]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_sha3_squeeze (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.sha3_squeeze.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_sha3_squeeze_qs)
  );

  //   F[fifo_depth]: 12:8
  prim_subreg_ext #(
    .DW    (5)
  ) u_status_fifo_depth (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_depth.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_depth_qs)
  );

  //   F[fifo_empty]: 14:14
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_fifo_empty (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_empty.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_empty_qs)
  );

  //   F[fifo_full]: 15:15
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_fifo_full (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_full.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_full_qs)
  );

  //   F[alert_fatal_fault]: 16:16
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_alert_fatal_fault (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.alert_fatal_fault.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_alert_fatal_fault_qs)
  );

  //   F[alert_recov_ctrl_update_err]: 17:17
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_alert_recov_ctrl_update_err (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.alert_recov_ctrl_update_err.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_alert_recov_ctrl_update_err_qs)
  );


  // R[entropy_period]: V(False)
  // Create REGWEN-gated WE signal
  logic entropy_period_gated_we;
  assign entropy_period_gated_we = entropy_period_we & cfg_regwen_qs;
  //   F[prescaler]: 9:0
  prim_subreg #(
    .DW      (10),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (10'h0),
    .Mubi    (1'b0)
  ) u_entropy_period_prescaler (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (entropy_period_gated_we),
    .wd     (entropy_period_prescaler_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.entropy_period.prescaler.q),
    .ds     (),

    // to register interface (read)
    .qs     (entropy_period_prescaler_qs)
  );

  //   F[wait_timer]: 31:16
  prim_subreg #(
    .DW      (16),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (16'h0),
    .Mubi    (1'b0)
  ) u_entropy_period_wait_timer (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (entropy_period_gated_we),
    .wd     (entropy_period_wait_timer_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.entropy_period.wait_timer.q),
    .ds     (),

    // to register interface (read)
    .qs     (entropy_period_wait_timer_qs)
  );


  // R[entropy_refresh_hash_cnt]: V(False)
  prim_subreg #(
    .DW      (10),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (10'h0),
    .Mubi    (1'b0)
  ) u_entropy_refresh_hash_cnt (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.entropy_refresh_hash_cnt.de),
    .d      (hw2reg.entropy_refresh_hash_cnt.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (entropy_refresh_hash_cnt_qs)
  );


  // R[entropy_refresh_threshold_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic entropy_refresh_threshold_shadowed_gated_we;
  assign entropy_refresh_threshold_shadowed_gated_we =
    entropy_refresh_threshold_shadowed_we & cfg_regwen_qs;
  prim_subreg_shadow #(
    .DW      (10),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (10'h0),
    .Mubi    (1'b0)
  ) u_entropy_refresh_threshold_shadowed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (entropy_refresh_threshold_shadowed_re),
    .we     (entropy_refresh_threshold_shadowed_gated_we),
    .wd     (entropy_refresh_threshold_shadowed_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.entropy_refresh_threshold_shadowed.q),
    .ds     (),

    // to register interface (read)
    .qs     (entropy_refresh_threshold_shadowed_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (entropy_refresh_threshold_shadowed_update_err),
    .err_storage (entropy_refresh_threshold_shadowed_storage_err)
  );


  // R[entropy_seed]: V(True)
  logic entropy_seed_qe;
  logic [0:0] entropy_seed_flds_we;
  assign entropy_seed_qe = &entropy_seed_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_entropy_seed (
    .re     (1'b0),
    .we     (entropy_seed_we),
    .wd     (entropy_seed_wd),
    .d      ('0),
    .qre    (),
    .qe     (entropy_seed_flds_we[0]),
    .q      (reg2hw.entropy_seed.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.entropy_seed.qe = entropy_seed_qe;


  // Subregister 0 of Multireg key_share0
  // R[key_share0_0]: V(True)
  logic key_share0_0_qe;
  logic [0:0] key_share0_0_flds_we;
  assign key_share0_0_qe = &key_share0_0_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_0_gated_we;
  assign key_share0_0_gated_we = key_share0_0_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_0 (
    .re     (1'b0),
    .we     (key_share0_0_gated_we),
    .wd     (key_share0_0_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_0_flds_we[0]),
    .q      (reg2hw.key_share0[0].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[0].qe = key_share0_0_qe;


  // Subregister 1 of Multireg key_share0
  // R[key_share0_1]: V(True)
  logic key_share0_1_qe;
  logic [0:0] key_share0_1_flds_we;
  assign key_share0_1_qe = &key_share0_1_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_1_gated_we;
  assign key_share0_1_gated_we = key_share0_1_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_1 (
    .re     (1'b0),
    .we     (key_share0_1_gated_we),
    .wd     (key_share0_1_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_1_flds_we[0]),
    .q      (reg2hw.key_share0[1].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[1].qe = key_share0_1_qe;


  // Subregister 2 of Multireg key_share0
  // R[key_share0_2]: V(True)
  logic key_share0_2_qe;
  logic [0:0] key_share0_2_flds_we;
  assign key_share0_2_qe = &key_share0_2_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_2_gated_we;
  assign key_share0_2_gated_we = key_share0_2_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_2 (
    .re     (1'b0),
    .we     (key_share0_2_gated_we),
    .wd     (key_share0_2_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_2_flds_we[0]),
    .q      (reg2hw.key_share0[2].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[2].qe = key_share0_2_qe;


  // Subregister 3 of Multireg key_share0
  // R[key_share0_3]: V(True)
  logic key_share0_3_qe;
  logic [0:0] key_share0_3_flds_we;
  assign key_share0_3_qe = &key_share0_3_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_3_gated_we;
  assign key_share0_3_gated_we = key_share0_3_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_3 (
    .re     (1'b0),
    .we     (key_share0_3_gated_we),
    .wd     (key_share0_3_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_3_flds_we[0]),
    .q      (reg2hw.key_share0[3].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[3].qe = key_share0_3_qe;


  // Subregister 4 of Multireg key_share0
  // R[key_share0_4]: V(True)
  logic key_share0_4_qe;
  logic [0:0] key_share0_4_flds_we;
  assign key_share0_4_qe = &key_share0_4_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_4_gated_we;
  assign key_share0_4_gated_we = key_share0_4_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_4 (
    .re     (1'b0),
    .we     (key_share0_4_gated_we),
    .wd     (key_share0_4_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_4_flds_we[0]),
    .q      (reg2hw.key_share0[4].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[4].qe = key_share0_4_qe;


  // Subregister 5 of Multireg key_share0
  // R[key_share0_5]: V(True)
  logic key_share0_5_qe;
  logic [0:0] key_share0_5_flds_we;
  assign key_share0_5_qe = &key_share0_5_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_5_gated_we;
  assign key_share0_5_gated_we = key_share0_5_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_5 (
    .re     (1'b0),
    .we     (key_share0_5_gated_we),
    .wd     (key_share0_5_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_5_flds_we[0]),
    .q      (reg2hw.key_share0[5].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[5].qe = key_share0_5_qe;


  // Subregister 6 of Multireg key_share0
  // R[key_share0_6]: V(True)
  logic key_share0_6_qe;
  logic [0:0] key_share0_6_flds_we;
  assign key_share0_6_qe = &key_share0_6_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_6_gated_we;
  assign key_share0_6_gated_we = key_share0_6_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_6 (
    .re     (1'b0),
    .we     (key_share0_6_gated_we),
    .wd     (key_share0_6_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_6_flds_we[0]),
    .q      (reg2hw.key_share0[6].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[6].qe = key_share0_6_qe;


  // Subregister 7 of Multireg key_share0
  // R[key_share0_7]: V(True)
  logic key_share0_7_qe;
  logic [0:0] key_share0_7_flds_we;
  assign key_share0_7_qe = &key_share0_7_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_7_gated_we;
  assign key_share0_7_gated_we = key_share0_7_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_7 (
    .re     (1'b0),
    .we     (key_share0_7_gated_we),
    .wd     (key_share0_7_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_7_flds_we[0]),
    .q      (reg2hw.key_share0[7].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[7].qe = key_share0_7_qe;


  // Subregister 8 of Multireg key_share0
  // R[key_share0_8]: V(True)
  logic key_share0_8_qe;
  logic [0:0] key_share0_8_flds_we;
  assign key_share0_8_qe = &key_share0_8_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_8_gated_we;
  assign key_share0_8_gated_we = key_share0_8_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_8 (
    .re     (1'b0),
    .we     (key_share0_8_gated_we),
    .wd     (key_share0_8_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_8_flds_we[0]),
    .q      (reg2hw.key_share0[8].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[8].qe = key_share0_8_qe;


  // Subregister 9 of Multireg key_share0
  // R[key_share0_9]: V(True)
  logic key_share0_9_qe;
  logic [0:0] key_share0_9_flds_we;
  assign key_share0_9_qe = &key_share0_9_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_9_gated_we;
  assign key_share0_9_gated_we = key_share0_9_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_9 (
    .re     (1'b0),
    .we     (key_share0_9_gated_we),
    .wd     (key_share0_9_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_9_flds_we[0]),
    .q      (reg2hw.key_share0[9].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[9].qe = key_share0_9_qe;


  // Subregister 10 of Multireg key_share0
  // R[key_share0_10]: V(True)
  logic key_share0_10_qe;
  logic [0:0] key_share0_10_flds_we;
  assign key_share0_10_qe = &key_share0_10_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_10_gated_we;
  assign key_share0_10_gated_we = key_share0_10_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_10 (
    .re     (1'b0),
    .we     (key_share0_10_gated_we),
    .wd     (key_share0_10_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_10_flds_we[0]),
    .q      (reg2hw.key_share0[10].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[10].qe = key_share0_10_qe;


  // Subregister 11 of Multireg key_share0
  // R[key_share0_11]: V(True)
  logic key_share0_11_qe;
  logic [0:0] key_share0_11_flds_we;
  assign key_share0_11_qe = &key_share0_11_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_11_gated_we;
  assign key_share0_11_gated_we = key_share0_11_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_11 (
    .re     (1'b0),
    .we     (key_share0_11_gated_we),
    .wd     (key_share0_11_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_11_flds_we[0]),
    .q      (reg2hw.key_share0[11].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[11].qe = key_share0_11_qe;


  // Subregister 12 of Multireg key_share0
  // R[key_share0_12]: V(True)
  logic key_share0_12_qe;
  logic [0:0] key_share0_12_flds_we;
  assign key_share0_12_qe = &key_share0_12_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_12_gated_we;
  assign key_share0_12_gated_we = key_share0_12_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_12 (
    .re     (1'b0),
    .we     (key_share0_12_gated_we),
    .wd     (key_share0_12_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_12_flds_we[0]),
    .q      (reg2hw.key_share0[12].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[12].qe = key_share0_12_qe;


  // Subregister 13 of Multireg key_share0
  // R[key_share0_13]: V(True)
  logic key_share0_13_qe;
  logic [0:0] key_share0_13_flds_we;
  assign key_share0_13_qe = &key_share0_13_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_13_gated_we;
  assign key_share0_13_gated_we = key_share0_13_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_13 (
    .re     (1'b0),
    .we     (key_share0_13_gated_we),
    .wd     (key_share0_13_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_13_flds_we[0]),
    .q      (reg2hw.key_share0[13].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[13].qe = key_share0_13_qe;


  // Subregister 14 of Multireg key_share0
  // R[key_share0_14]: V(True)
  logic key_share0_14_qe;
  logic [0:0] key_share0_14_flds_we;
  assign key_share0_14_qe = &key_share0_14_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_14_gated_we;
  assign key_share0_14_gated_we = key_share0_14_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_14 (
    .re     (1'b0),
    .we     (key_share0_14_gated_we),
    .wd     (key_share0_14_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_14_flds_we[0]),
    .q      (reg2hw.key_share0[14].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[14].qe = key_share0_14_qe;


  // Subregister 15 of Multireg key_share0
  // R[key_share0_15]: V(True)
  logic key_share0_15_qe;
  logic [0:0] key_share0_15_flds_we;
  assign key_share0_15_qe = &key_share0_15_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share0_15_gated_we;
  assign key_share0_15_gated_we = key_share0_15_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share0_15 (
    .re     (1'b0),
    .we     (key_share0_15_gated_we),
    .wd     (key_share0_15_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share0_15_flds_we[0]),
    .q      (reg2hw.key_share0[15].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share0[15].qe = key_share0_15_qe;


  // Subregister 0 of Multireg key_share1
  // R[key_share1_0]: V(True)
  logic key_share1_0_qe;
  logic [0:0] key_share1_0_flds_we;
  assign key_share1_0_qe = &key_share1_0_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_0_gated_we;
  assign key_share1_0_gated_we = key_share1_0_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_0 (
    .re     (1'b0),
    .we     (key_share1_0_gated_we),
    .wd     (key_share1_0_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_0_flds_we[0]),
    .q      (reg2hw.key_share1[0].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[0].qe = key_share1_0_qe;


  // Subregister 1 of Multireg key_share1
  // R[key_share1_1]: V(True)
  logic key_share1_1_qe;
  logic [0:0] key_share1_1_flds_we;
  assign key_share1_1_qe = &key_share1_1_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_1_gated_we;
  assign key_share1_1_gated_we = key_share1_1_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_1 (
    .re     (1'b0),
    .we     (key_share1_1_gated_we),
    .wd     (key_share1_1_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_1_flds_we[0]),
    .q      (reg2hw.key_share1[1].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[1].qe = key_share1_1_qe;


  // Subregister 2 of Multireg key_share1
  // R[key_share1_2]: V(True)
  logic key_share1_2_qe;
  logic [0:0] key_share1_2_flds_we;
  assign key_share1_2_qe = &key_share1_2_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_2_gated_we;
  assign key_share1_2_gated_we = key_share1_2_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_2 (
    .re     (1'b0),
    .we     (key_share1_2_gated_we),
    .wd     (key_share1_2_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_2_flds_we[0]),
    .q      (reg2hw.key_share1[2].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[2].qe = key_share1_2_qe;


  // Subregister 3 of Multireg key_share1
  // R[key_share1_3]: V(True)
  logic key_share1_3_qe;
  logic [0:0] key_share1_3_flds_we;
  assign key_share1_3_qe = &key_share1_3_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_3_gated_we;
  assign key_share1_3_gated_we = key_share1_3_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_3 (
    .re     (1'b0),
    .we     (key_share1_3_gated_we),
    .wd     (key_share1_3_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_3_flds_we[0]),
    .q      (reg2hw.key_share1[3].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[3].qe = key_share1_3_qe;


  // Subregister 4 of Multireg key_share1
  // R[key_share1_4]: V(True)
  logic key_share1_4_qe;
  logic [0:0] key_share1_4_flds_we;
  assign key_share1_4_qe = &key_share1_4_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_4_gated_we;
  assign key_share1_4_gated_we = key_share1_4_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_4 (
    .re     (1'b0),
    .we     (key_share1_4_gated_we),
    .wd     (key_share1_4_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_4_flds_we[0]),
    .q      (reg2hw.key_share1[4].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[4].qe = key_share1_4_qe;


  // Subregister 5 of Multireg key_share1
  // R[key_share1_5]: V(True)
  logic key_share1_5_qe;
  logic [0:0] key_share1_5_flds_we;
  assign key_share1_5_qe = &key_share1_5_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_5_gated_we;
  assign key_share1_5_gated_we = key_share1_5_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_5 (
    .re     (1'b0),
    .we     (key_share1_5_gated_we),
    .wd     (key_share1_5_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_5_flds_we[0]),
    .q      (reg2hw.key_share1[5].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[5].qe = key_share1_5_qe;


  // Subregister 6 of Multireg key_share1
  // R[key_share1_6]: V(True)
  logic key_share1_6_qe;
  logic [0:0] key_share1_6_flds_we;
  assign key_share1_6_qe = &key_share1_6_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_6_gated_we;
  assign key_share1_6_gated_we = key_share1_6_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_6 (
    .re     (1'b0),
    .we     (key_share1_6_gated_we),
    .wd     (key_share1_6_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_6_flds_we[0]),
    .q      (reg2hw.key_share1[6].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[6].qe = key_share1_6_qe;


  // Subregister 7 of Multireg key_share1
  // R[key_share1_7]: V(True)
  logic key_share1_7_qe;
  logic [0:0] key_share1_7_flds_we;
  assign key_share1_7_qe = &key_share1_7_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_7_gated_we;
  assign key_share1_7_gated_we = key_share1_7_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_7 (
    .re     (1'b0),
    .we     (key_share1_7_gated_we),
    .wd     (key_share1_7_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_7_flds_we[0]),
    .q      (reg2hw.key_share1[7].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[7].qe = key_share1_7_qe;


  // Subregister 8 of Multireg key_share1
  // R[key_share1_8]: V(True)
  logic key_share1_8_qe;
  logic [0:0] key_share1_8_flds_we;
  assign key_share1_8_qe = &key_share1_8_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_8_gated_we;
  assign key_share1_8_gated_we = key_share1_8_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_8 (
    .re     (1'b0),
    .we     (key_share1_8_gated_we),
    .wd     (key_share1_8_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_8_flds_we[0]),
    .q      (reg2hw.key_share1[8].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[8].qe = key_share1_8_qe;


  // Subregister 9 of Multireg key_share1
  // R[key_share1_9]: V(True)
  logic key_share1_9_qe;
  logic [0:0] key_share1_9_flds_we;
  assign key_share1_9_qe = &key_share1_9_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_9_gated_we;
  assign key_share1_9_gated_we = key_share1_9_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_9 (
    .re     (1'b0),
    .we     (key_share1_9_gated_we),
    .wd     (key_share1_9_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_9_flds_we[0]),
    .q      (reg2hw.key_share1[9].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[9].qe = key_share1_9_qe;


  // Subregister 10 of Multireg key_share1
  // R[key_share1_10]: V(True)
  logic key_share1_10_qe;
  logic [0:0] key_share1_10_flds_we;
  assign key_share1_10_qe = &key_share1_10_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_10_gated_we;
  assign key_share1_10_gated_we = key_share1_10_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_10 (
    .re     (1'b0),
    .we     (key_share1_10_gated_we),
    .wd     (key_share1_10_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_10_flds_we[0]),
    .q      (reg2hw.key_share1[10].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[10].qe = key_share1_10_qe;


  // Subregister 11 of Multireg key_share1
  // R[key_share1_11]: V(True)
  logic key_share1_11_qe;
  logic [0:0] key_share1_11_flds_we;
  assign key_share1_11_qe = &key_share1_11_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_11_gated_we;
  assign key_share1_11_gated_we = key_share1_11_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_11 (
    .re     (1'b0),
    .we     (key_share1_11_gated_we),
    .wd     (key_share1_11_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_11_flds_we[0]),
    .q      (reg2hw.key_share1[11].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[11].qe = key_share1_11_qe;


  // Subregister 12 of Multireg key_share1
  // R[key_share1_12]: V(True)
  logic key_share1_12_qe;
  logic [0:0] key_share1_12_flds_we;
  assign key_share1_12_qe = &key_share1_12_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_12_gated_we;
  assign key_share1_12_gated_we = key_share1_12_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_12 (
    .re     (1'b0),
    .we     (key_share1_12_gated_we),
    .wd     (key_share1_12_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_12_flds_we[0]),
    .q      (reg2hw.key_share1[12].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[12].qe = key_share1_12_qe;


  // Subregister 13 of Multireg key_share1
  // R[key_share1_13]: V(True)
  logic key_share1_13_qe;
  logic [0:0] key_share1_13_flds_we;
  assign key_share1_13_qe = &key_share1_13_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_13_gated_we;
  assign key_share1_13_gated_we = key_share1_13_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_13 (
    .re     (1'b0),
    .we     (key_share1_13_gated_we),
    .wd     (key_share1_13_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_13_flds_we[0]),
    .q      (reg2hw.key_share1[13].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[13].qe = key_share1_13_qe;


  // Subregister 14 of Multireg key_share1
  // R[key_share1_14]: V(True)
  logic key_share1_14_qe;
  logic [0:0] key_share1_14_flds_we;
  assign key_share1_14_qe = &key_share1_14_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_14_gated_we;
  assign key_share1_14_gated_we = key_share1_14_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_14 (
    .re     (1'b0),
    .we     (key_share1_14_gated_we),
    .wd     (key_share1_14_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_14_flds_we[0]),
    .q      (reg2hw.key_share1[14].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[14].qe = key_share1_14_qe;


  // Subregister 15 of Multireg key_share1
  // R[key_share1_15]: V(True)
  logic key_share1_15_qe;
  logic [0:0] key_share1_15_flds_we;
  assign key_share1_15_qe = &key_share1_15_flds_we;
  // Create REGWEN-gated WE signal
  logic key_share1_15_gated_we;
  assign key_share1_15_gated_we = key_share1_15_we & cfg_regwen_qs;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_share1_15 (
    .re     (1'b0),
    .we     (key_share1_15_gated_we),
    .wd     (key_share1_15_wd),
    .d      ('0),
    .qre    (),
    .qe     (key_share1_15_flds_we[0]),
    .q      (reg2hw.key_share1[15].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key_share1[15].qe = key_share1_15_qe;


  // R[key_len]: V(False)
  // Create REGWEN-gated WE signal
  logic key_len_gated_we;
  assign key_len_gated_we = key_len_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (3),
    .SwAccess(prim_subreg_pkg::SwAccessWO),
    .RESVAL  (3'h0),
    .Mubi    (1'b0)
  ) u_key_len (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (key_len_gated_we),
    .wd     (key_len_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.key_len.q),
    .ds     (),

    // to register interface (read)
    .qs     ()
  );


  // Subregister 0 of Multireg prefix
  // R[prefix_0]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_0_gated_we;
  assign prefix_0_gated_we = prefix_0_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_0_gated_we),
    .wd     (prefix_0_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[0].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_0_qs)
  );


  // Subregister 1 of Multireg prefix
  // R[prefix_1]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_1_gated_we;
  assign prefix_1_gated_we = prefix_1_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_1_gated_we),
    .wd     (prefix_1_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[1].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_1_qs)
  );


  // Subregister 2 of Multireg prefix
  // R[prefix_2]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_2_gated_we;
  assign prefix_2_gated_we = prefix_2_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_2_gated_we),
    .wd     (prefix_2_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[2].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_2_qs)
  );


  // Subregister 3 of Multireg prefix
  // R[prefix_3]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_3_gated_we;
  assign prefix_3_gated_we = prefix_3_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_3_gated_we),
    .wd     (prefix_3_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[3].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_3_qs)
  );


  // Subregister 4 of Multireg prefix
  // R[prefix_4]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_4_gated_we;
  assign prefix_4_gated_we = prefix_4_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_4_gated_we),
    .wd     (prefix_4_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[4].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_4_qs)
  );


  // Subregister 5 of Multireg prefix
  // R[prefix_5]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_5_gated_we;
  assign prefix_5_gated_we = prefix_5_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_5_gated_we),
    .wd     (prefix_5_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[5].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_5_qs)
  );


  // Subregister 6 of Multireg prefix
  // R[prefix_6]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_6_gated_we;
  assign prefix_6_gated_we = prefix_6_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_6_gated_we),
    .wd     (prefix_6_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[6].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_6_qs)
  );


  // Subregister 7 of Multireg prefix
  // R[prefix_7]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_7_gated_we;
  assign prefix_7_gated_we = prefix_7_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_7_gated_we),
    .wd     (prefix_7_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[7].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_7_qs)
  );


  // Subregister 8 of Multireg prefix
  // R[prefix_8]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_8_gated_we;
  assign prefix_8_gated_we = prefix_8_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_8 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_8_gated_we),
    .wd     (prefix_8_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[8].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_8_qs)
  );


  // Subregister 9 of Multireg prefix
  // R[prefix_9]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_9_gated_we;
  assign prefix_9_gated_we = prefix_9_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_9 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_9_gated_we),
    .wd     (prefix_9_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[9].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_9_qs)
  );


  // Subregister 10 of Multireg prefix
  // R[prefix_10]: V(False)
  // Create REGWEN-gated WE signal
  logic prefix_10_gated_we;
  assign prefix_10_gated_we = prefix_10_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_prefix_10 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (prefix_10_gated_we),
    .wd     (prefix_10_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.prefix[10].q),
    .ds     (),

    // to register interface (read)
    .qs     (prefix_10_qs)
  );


  // R[err_code]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_err_code (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.err_code.de),
    .d      (hw2reg.err_code.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (err_code_qs)
  );



  logic [56:0] addr_hit;
  always_comb begin
    addr_hit = '0;
    addr_hit[ 0] = (reg_addr == KMAC_INTR_STATE_OFFSET);
    addr_hit[ 1] = (reg_addr == KMAC_INTR_ENABLE_OFFSET);
    addr_hit[ 2] = (reg_addr == KMAC_INTR_TEST_OFFSET);
    addr_hit[ 3] = (reg_addr == KMAC_ALERT_TEST_OFFSET);
    addr_hit[ 4] = (reg_addr == KMAC_CFG_REGWEN_OFFSET);
    addr_hit[ 5] = (reg_addr == KMAC_CFG_SHADOWED_OFFSET);
    addr_hit[ 6] = (reg_addr == KMAC_CMD_OFFSET);
    addr_hit[ 7] = (reg_addr == KMAC_STATUS_OFFSET);
    addr_hit[ 8] = (reg_addr == KMAC_ENTROPY_PERIOD_OFFSET);
    addr_hit[ 9] = (reg_addr == KMAC_ENTROPY_REFRESH_HASH_CNT_OFFSET);
    addr_hit[10] = (reg_addr == KMAC_ENTROPY_REFRESH_THRESHOLD_SHADOWED_OFFSET);
    addr_hit[11] = (reg_addr == KMAC_ENTROPY_SEED_OFFSET);
    addr_hit[12] = (reg_addr == KMAC_KEY_SHARE0_0_OFFSET);
    addr_hit[13] = (reg_addr == KMAC_KEY_SHARE0_1_OFFSET);
    addr_hit[14] = (reg_addr == KMAC_KEY_SHARE0_2_OFFSET);
    addr_hit[15] = (reg_addr == KMAC_KEY_SHARE0_3_OFFSET);
    addr_hit[16] = (reg_addr == KMAC_KEY_SHARE0_4_OFFSET);
    addr_hit[17] = (reg_addr == KMAC_KEY_SHARE0_5_OFFSET);
    addr_hit[18] = (reg_addr == KMAC_KEY_SHARE0_6_OFFSET);
    addr_hit[19] = (reg_addr == KMAC_KEY_SHARE0_7_OFFSET);
    addr_hit[20] = (reg_addr == KMAC_KEY_SHARE0_8_OFFSET);
    addr_hit[21] = (reg_addr == KMAC_KEY_SHARE0_9_OFFSET);
    addr_hit[22] = (reg_addr == KMAC_KEY_SHARE0_10_OFFSET);
    addr_hit[23] = (reg_addr == KMAC_KEY_SHARE0_11_OFFSET);
    addr_hit[24] = (reg_addr == KMAC_KEY_SHARE0_12_OFFSET);
    addr_hit[25] = (reg_addr == KMAC_KEY_SHARE0_13_OFFSET);
    addr_hit[26] = (reg_addr == KMAC_KEY_SHARE0_14_OFFSET);
    addr_hit[27] = (reg_addr == KMAC_KEY_SHARE0_15_OFFSET);
    addr_hit[28] = (reg_addr == KMAC_KEY_SHARE1_0_OFFSET);
    addr_hit[29] = (reg_addr == KMAC_KEY_SHARE1_1_OFFSET);
    addr_hit[30] = (reg_addr == KMAC_KEY_SHARE1_2_OFFSET);
    addr_hit[31] = (reg_addr == KMAC_KEY_SHARE1_3_OFFSET);
    addr_hit[32] = (reg_addr == KMAC_KEY_SHARE1_4_OFFSET);
    addr_hit[33] = (reg_addr == KMAC_KEY_SHARE1_5_OFFSET);
    addr_hit[34] = (reg_addr == KMAC_KEY_SHARE1_6_OFFSET);
    addr_hit[35] = (reg_addr == KMAC_KEY_SHARE1_7_OFFSET);
    addr_hit[36] = (reg_addr == KMAC_KEY_SHARE1_8_OFFSET);
    addr_hit[37] = (reg_addr == KMAC_KEY_SHARE1_9_OFFSET);
    addr_hit[38] = (reg_addr == KMAC_KEY_SHARE1_10_OFFSET);
    addr_hit[39] = (reg_addr == KMAC_KEY_SHARE1_11_OFFSET);
    addr_hit[40] = (reg_addr == KMAC_KEY_SHARE1_12_OFFSET);
    addr_hit[41] = (reg_addr == KMAC_KEY_SHARE1_13_OFFSET);
    addr_hit[42] = (reg_addr == KMAC_KEY_SHARE1_14_OFFSET);
    addr_hit[43] = (reg_addr == KMAC_KEY_SHARE1_15_OFFSET);
    addr_hit[44] = (reg_addr == KMAC_KEY_LEN_OFFSET);
    addr_hit[45] = (reg_addr == KMAC_PREFIX_0_OFFSET);
    addr_hit[46] = (reg_addr == KMAC_PREFIX_1_OFFSET);
    addr_hit[47] = (reg_addr == KMAC_PREFIX_2_OFFSET);
    addr_hit[48] = (reg_addr == KMAC_PREFIX_3_OFFSET);
    addr_hit[49] = (reg_addr == KMAC_PREFIX_4_OFFSET);
    addr_hit[50] = (reg_addr == KMAC_PREFIX_5_OFFSET);
    addr_hit[51] = (reg_addr == KMAC_PREFIX_6_OFFSET);
    addr_hit[52] = (reg_addr == KMAC_PREFIX_7_OFFSET);
    addr_hit[53] = (reg_addr == KMAC_PREFIX_8_OFFSET);
    addr_hit[54] = (reg_addr == KMAC_PREFIX_9_OFFSET);
    addr_hit[55] = (reg_addr == KMAC_PREFIX_10_OFFSET);
    addr_hit[56] = (reg_addr == KMAC_ERR_CODE_OFFSET);
  end

  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;

  // Check sub-word write is permitted
  always_comb begin
    wr_err = (reg_we &
              ((addr_hit[ 0] & (|(KMAC_PERMIT[ 0] & ~reg_be))) |
               (addr_hit[ 1] & (|(KMAC_PERMIT[ 1] & ~reg_be))) |
               (addr_hit[ 2] & (|(KMAC_PERMIT[ 2] & ~reg_be))) |
               (addr_hit[ 3] & (|(KMAC_PERMIT[ 3] & ~reg_be))) |
               (addr_hit[ 4] & (|(KMAC_PERMIT[ 4] & ~reg_be))) |
               (addr_hit[ 5] & (|(KMAC_PERMIT[ 5] & ~reg_be))) |
               (addr_hit[ 6] & (|(KMAC_PERMIT[ 6] & ~reg_be))) |
               (addr_hit[ 7] & (|(KMAC_PERMIT[ 7] & ~reg_be))) |
               (addr_hit[ 8] & (|(KMAC_PERMIT[ 8] & ~reg_be))) |
               (addr_hit[ 9] & (|(KMAC_PERMIT[ 9] & ~reg_be))) |
               (addr_hit[10] & (|(KMAC_PERMIT[10] & ~reg_be))) |
               (addr_hit[11] & (|(KMAC_PERMIT[11] & ~reg_be))) |
               (addr_hit[12] & (|(KMAC_PERMIT[12] & ~reg_be))) |
               (addr_hit[13] & (|(KMAC_PERMIT[13] & ~reg_be))) |
               (addr_hit[14] & (|(KMAC_PERMIT[14] & ~reg_be))) |
               (addr_hit[15] & (|(KMAC_PERMIT[15] & ~reg_be))) |
               (addr_hit[16] & (|(KMAC_PERMIT[16] & ~reg_be))) |
               (addr_hit[17] & (|(KMAC_PERMIT[17] & ~reg_be))) |
               (addr_hit[18] & (|(KMAC_PERMIT[18] & ~reg_be))) |
               (addr_hit[19] & (|(KMAC_PERMIT[19] & ~reg_be))) |
               (addr_hit[20] & (|(KMAC_PERMIT[20] & ~reg_be))) |
               (addr_hit[21] & (|(KMAC_PERMIT[21] & ~reg_be))) |
               (addr_hit[22] & (|(KMAC_PERMIT[22] & ~reg_be))) |
               (addr_hit[23] & (|(KMAC_PERMIT[23] & ~reg_be))) |
               (addr_hit[24] & (|(KMAC_PERMIT[24] & ~reg_be))) |
               (addr_hit[25] & (|(KMAC_PERMIT[25] & ~reg_be))) |
               (addr_hit[26] & (|(KMAC_PERMIT[26] & ~reg_be))) |
               (addr_hit[27] & (|(KMAC_PERMIT[27] & ~reg_be))) |
               (addr_hit[28] & (|(KMAC_PERMIT[28] & ~reg_be))) |
               (addr_hit[29] & (|(KMAC_PERMIT[29] & ~reg_be))) |
               (addr_hit[30] & (|(KMAC_PERMIT[30] & ~reg_be))) |
               (addr_hit[31] & (|(KMAC_PERMIT[31] & ~reg_be))) |
               (addr_hit[32] & (|(KMAC_PERMIT[32] & ~reg_be))) |
               (addr_hit[33] & (|(KMAC_PERMIT[33] & ~reg_be))) |
               (addr_hit[34] & (|(KMAC_PERMIT[34] & ~reg_be))) |
               (addr_hit[35] & (|(KMAC_PERMIT[35] & ~reg_be))) |
               (addr_hit[36] & (|(KMAC_PERMIT[36] & ~reg_be))) |
               (addr_hit[37] & (|(KMAC_PERMIT[37] & ~reg_be))) |
               (addr_hit[38] & (|(KMAC_PERMIT[38] & ~reg_be))) |
               (addr_hit[39] & (|(KMAC_PERMIT[39] & ~reg_be))) |
               (addr_hit[40] & (|(KMAC_PERMIT[40] & ~reg_be))) |
               (addr_hit[41] & (|(KMAC_PERMIT[41] & ~reg_be))) |
               (addr_hit[42] & (|(KMAC_PERMIT[42] & ~reg_be))) |
               (addr_hit[43] & (|(KMAC_PERMIT[43] & ~reg_be))) |
               (addr_hit[44] & (|(KMAC_PERMIT[44] & ~reg_be))) |
               (addr_hit[45] & (|(KMAC_PERMIT[45] & ~reg_be))) |
               (addr_hit[46] & (|(KMAC_PERMIT[46] & ~reg_be))) |
               (addr_hit[47] & (|(KMAC_PERMIT[47] & ~reg_be))) |
               (addr_hit[48] & (|(KMAC_PERMIT[48] & ~reg_be))) |
               (addr_hit[49] & (|(KMAC_PERMIT[49] & ~reg_be))) |
               (addr_hit[50] & (|(KMAC_PERMIT[50] & ~reg_be))) |
               (addr_hit[51] & (|(KMAC_PERMIT[51] & ~reg_be))) |
               (addr_hit[52] & (|(KMAC_PERMIT[52] & ~reg_be))) |
               (addr_hit[53] & (|(KMAC_PERMIT[53] & ~reg_be))) |
               (addr_hit[54] & (|(KMAC_PERMIT[54] & ~reg_be))) |
               (addr_hit[55] & (|(KMAC_PERMIT[55] & ~reg_be))) |
               (addr_hit[56] & (|(KMAC_PERMIT[56] & ~reg_be)))));
  end

  // Generate write-enables
  assign intr_state_we = addr_hit[0] & reg_we & !reg_error;

  assign intr_state_kmac_done_wd = reg_wdata[0];

  assign intr_state_kmac_err_wd = reg_wdata[2];
  assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;

  assign intr_enable_kmac_done_wd = reg_wdata[0];

  assign intr_enable_fifo_empty_wd = reg_wdata[1];

  assign intr_enable_kmac_err_wd = reg_wdata[2];
  assign intr_test_we = addr_hit[2] & reg_we & !reg_error;

  assign intr_test_kmac_done_wd = reg_wdata[0];

  assign intr_test_fifo_empty_wd = reg_wdata[1];

  assign intr_test_kmac_err_wd = reg_wdata[2];
  assign alert_test_we = addr_hit[3] & reg_we & !reg_error;

  assign alert_test_recov_operation_err_wd = reg_wdata[0];

  assign alert_test_fatal_fault_err_wd = reg_wdata[1];
  assign cfg_regwen_re = addr_hit[4] & reg_re & !reg_error;
  assign cfg_shadowed_re = addr_hit[5] & reg_re & !reg_error;
  assign cfg_shadowed_we = addr_hit[5] & reg_we & !reg_error;

  assign cfg_shadowed_kmac_en_wd = reg_wdata[0];

  assign cfg_shadowed_kstrength_wd = reg_wdata[3:1];

  assign cfg_shadowed_mode_wd = reg_wdata[5:4];

  assign cfg_shadowed_msg_endianness_wd = reg_wdata[8];

  assign cfg_shadowed_state_endianness_wd = reg_wdata[9];

  assign cfg_shadowed_sideload_wd = reg_wdata[12];

  assign cfg_shadowed_entropy_mode_wd = reg_wdata[17:16];

  assign cfg_shadowed_entropy_fast_process_wd = reg_wdata[19];

  assign cfg_shadowed_msg_mask_wd = reg_wdata[20];

  assign cfg_shadowed_entropy_ready_wd = reg_wdata[24];

  assign cfg_shadowed_en_unsupported_modestrength_wd = reg_wdata[26];
  assign cmd_we = addr_hit[6] & reg_we & !reg_error;

  assign cmd_cmd_wd = reg_wdata[5:0];

  assign cmd_entropy_req_wd = reg_wdata[8];

  assign cmd_hash_cnt_clr_wd = reg_wdata[9];

  assign cmd_err_processed_wd = reg_wdata[10];
  assign status_re = addr_hit[7] & reg_re & !reg_error;
  assign entropy_period_we = addr_hit[8] & reg_we & !reg_error;

  assign entropy_period_prescaler_wd = reg_wdata[9:0];

  assign entropy_period_wait_timer_wd = reg_wdata[31:16];
  assign entropy_refresh_threshold_shadowed_re = addr_hit[10] & reg_re & !reg_error;
  assign entropy_refresh_threshold_shadowed_we = addr_hit[10] & reg_we & !reg_error;

  assign entropy_refresh_threshold_shadowed_wd = reg_wdata[9:0];
  assign entropy_seed_we = addr_hit[11] & reg_we & !reg_error;

  assign entropy_seed_wd = reg_wdata[31:0];
  assign key_share0_0_we = addr_hit[12] & reg_we & !reg_error;

  assign key_share0_0_wd = reg_wdata[31:0];
  assign key_share0_1_we = addr_hit[13] & reg_we & !reg_error;

  assign key_share0_1_wd = reg_wdata[31:0];
  assign key_share0_2_we = addr_hit[14] & reg_we & !reg_error;

  assign key_share0_2_wd = reg_wdata[31:0];
  assign key_share0_3_we = addr_hit[15] & reg_we & !reg_error;

  assign key_share0_3_wd = reg_wdata[31:0];
  assign key_share0_4_we = addr_hit[16] & reg_we & !reg_error;

  assign key_share0_4_wd = reg_wdata[31:0];
  assign key_share0_5_we = addr_hit[17] & reg_we & !reg_error;

  assign key_share0_5_wd = reg_wdata[31:0];
  assign key_share0_6_we = addr_hit[18] & reg_we & !reg_error;

  assign key_share0_6_wd = reg_wdata[31:0];
  assign key_share0_7_we = addr_hit[19] & reg_we & !reg_error;

  assign key_share0_7_wd = reg_wdata[31:0];
  assign key_share0_8_we = addr_hit[20] & reg_we & !reg_error;

  assign key_share0_8_wd = reg_wdata[31:0];
  assign key_share0_9_we = addr_hit[21] & reg_we & !reg_error;

  assign key_share0_9_wd = reg_wdata[31:0];
  assign key_share0_10_we = addr_hit[22] & reg_we & !reg_error;

  assign key_share0_10_wd = reg_wdata[31:0];
  assign key_share0_11_we = addr_hit[23] & reg_we & !reg_error;

  assign key_share0_11_wd = reg_wdata[31:0];
  assign key_share0_12_we = addr_hit[24] & reg_we & !reg_error;

  assign key_share0_12_wd = reg_wdata[31:0];
  assign key_share0_13_we = addr_hit[25] & reg_we & !reg_error;

  assign key_share0_13_wd = reg_wdata[31:0];
  assign key_share0_14_we = addr_hit[26] & reg_we & !reg_error;

  assign key_share0_14_wd = reg_wdata[31:0];
  assign key_share0_15_we = addr_hit[27] & reg_we & !reg_error;

  assign key_share0_15_wd = reg_wdata[31:0];
  assign key_share1_0_we = addr_hit[28] & reg_we & !reg_error;

  assign key_share1_0_wd = reg_wdata[31:0];
  assign key_share1_1_we = addr_hit[29] & reg_we & !reg_error;

  assign key_share1_1_wd = reg_wdata[31:0];
  assign key_share1_2_we = addr_hit[30] & reg_we & !reg_error;

  assign key_share1_2_wd = reg_wdata[31:0];
  assign key_share1_3_we = addr_hit[31] & reg_we & !reg_error;

  assign key_share1_3_wd = reg_wdata[31:0];
  assign key_share1_4_we = addr_hit[32] & reg_we & !reg_error;

  assign key_share1_4_wd = reg_wdata[31:0];
  assign key_share1_5_we = addr_hit[33] & reg_we & !reg_error;

  assign key_share1_5_wd = reg_wdata[31:0];
  assign key_share1_6_we = addr_hit[34] & reg_we & !reg_error;

  assign key_share1_6_wd = reg_wdata[31:0];
  assign key_share1_7_we = addr_hit[35] & reg_we & !reg_error;

  assign key_share1_7_wd = reg_wdata[31:0];
  assign key_share1_8_we = addr_hit[36] & reg_we & !reg_error;

  assign key_share1_8_wd = reg_wdata[31:0];
  assign key_share1_9_we = addr_hit[37] & reg_we & !reg_error;

  assign key_share1_9_wd = reg_wdata[31:0];
  assign key_share1_10_we = addr_hit[38] & reg_we & !reg_error;

  assign key_share1_10_wd = reg_wdata[31:0];
  assign key_share1_11_we = addr_hit[39] & reg_we & !reg_error;

  assign key_share1_11_wd = reg_wdata[31:0];
  assign key_share1_12_we = addr_hit[40] & reg_we & !reg_error;

  assign key_share1_12_wd = reg_wdata[31:0];
  assign key_share1_13_we = addr_hit[41] & reg_we & !reg_error;

  assign key_share1_13_wd = reg_wdata[31:0];
  assign key_share1_14_we = addr_hit[42] & reg_we & !reg_error;

  assign key_share1_14_wd = reg_wdata[31:0];
  assign key_share1_15_we = addr_hit[43] & reg_we & !reg_error;

  assign key_share1_15_wd = reg_wdata[31:0];
  assign key_len_we = addr_hit[44] & reg_we & !reg_error;

  assign key_len_wd = reg_wdata[2:0];
  assign prefix_0_we = addr_hit[45] & reg_we & !reg_error;

  assign prefix_0_wd = reg_wdata[31:0];
  assign prefix_1_we = addr_hit[46] & reg_we & !reg_error;

  assign prefix_1_wd = reg_wdata[31:0];
  assign prefix_2_we = addr_hit[47] & reg_we & !reg_error;

  assign prefix_2_wd = reg_wdata[31:0];
  assign prefix_3_we = addr_hit[48] & reg_we & !reg_error;

  assign prefix_3_wd = reg_wdata[31:0];
  assign prefix_4_we = addr_hit[49] & reg_we & !reg_error;

  assign prefix_4_wd = reg_wdata[31:0];
  assign prefix_5_we = addr_hit[50] & reg_we & !reg_error;

  assign prefix_5_wd = reg_wdata[31:0];
  assign prefix_6_we = addr_hit[51] & reg_we & !reg_error;

  assign prefix_6_wd = reg_wdata[31:0];
  assign prefix_7_we = addr_hit[52] & reg_we & !reg_error;

  assign prefix_7_wd = reg_wdata[31:0];
  assign prefix_8_we = addr_hit[53] & reg_we & !reg_error;

  assign prefix_8_wd = reg_wdata[31:0];
  assign prefix_9_we = addr_hit[54] & reg_we & !reg_error;

  assign prefix_9_wd = reg_wdata[31:0];
  assign prefix_10_we = addr_hit[55] & reg_we & !reg_error;

  assign prefix_10_wd = reg_wdata[31:0];

  // Assign write-enables to checker logic vector.
  always_comb begin
    reg_we_check = '0;
    reg_we_check[0] = intr_state_we;
    reg_we_check[1] = intr_enable_we;
    reg_we_check[2] = intr_test_we;
    reg_we_check[3] = alert_test_we;
    reg_we_check[4] = 1'b0;
    reg_we_check[5] = cfg_shadowed_gated_we;
    reg_we_check[6] = cmd_we;
    reg_we_check[7] = 1'b0;
    reg_we_check[8] = entropy_period_gated_we;
    reg_we_check[9] = 1'b0;
    reg_we_check[10] = entropy_refresh_threshold_shadowed_gated_we;
    reg_we_check[11] = entropy_seed_we;
    reg_we_check[12] = key_share0_0_gated_we;
    reg_we_check[13] = key_share0_1_gated_we;
    reg_we_check[14] = key_share0_2_gated_we;
    reg_we_check[15] = key_share0_3_gated_we;
    reg_we_check[16] = key_share0_4_gated_we;
    reg_we_check[17] = key_share0_5_gated_we;
    reg_we_check[18] = key_share0_6_gated_we;
    reg_we_check[19] = key_share0_7_gated_we;
    reg_we_check[20] = key_share0_8_gated_we;
    reg_we_check[21] = key_share0_9_gated_we;
    reg_we_check[22] = key_share0_10_gated_we;
    reg_we_check[23] = key_share0_11_gated_we;
    reg_we_check[24] = key_share0_12_gated_we;
    reg_we_check[25] = key_share0_13_gated_we;
    reg_we_check[26] = key_share0_14_gated_we;
    reg_we_check[27] = key_share0_15_gated_we;
    reg_we_check[28] = key_share1_0_gated_we;
    reg_we_check[29] = key_share1_1_gated_we;
    reg_we_check[30] = key_share1_2_gated_we;
    reg_we_check[31] = key_share1_3_gated_we;
    reg_we_check[32] = key_share1_4_gated_we;
    reg_we_check[33] = key_share1_5_gated_we;
    reg_we_check[34] = key_share1_6_gated_we;
    reg_we_check[35] = key_share1_7_gated_we;
    reg_we_check[36] = key_share1_8_gated_we;
    reg_we_check[37] = key_share1_9_gated_we;
    reg_we_check[38] = key_share1_10_gated_we;
    reg_we_check[39] = key_share1_11_gated_we;
    reg_we_check[40] = key_share1_12_gated_we;
    reg_we_check[41] = key_share1_13_gated_we;
    reg_we_check[42] = key_share1_14_gated_we;
    reg_we_check[43] = key_share1_15_gated_we;
    reg_we_check[44] = key_len_gated_we;
    reg_we_check[45] = prefix_0_gated_we;
    reg_we_check[46] = prefix_1_gated_we;
    reg_we_check[47] = prefix_2_gated_we;
    reg_we_check[48] = prefix_3_gated_we;
    reg_we_check[49] = prefix_4_gated_we;
    reg_we_check[50] = prefix_5_gated_we;
    reg_we_check[51] = prefix_6_gated_we;
    reg_we_check[52] = prefix_7_gated_we;
    reg_we_check[53] = prefix_8_gated_we;
    reg_we_check[54] = prefix_9_gated_we;
    reg_we_check[55] = prefix_10_gated_we;
    reg_we_check[56] = 1'b0;
  end

  // Read data return
  always_comb begin
    reg_rdata_next = '0;
    unique case (1'b1)
      addr_hit[0]: begin
        reg_rdata_next[0] = intr_state_kmac_done_qs;
        reg_rdata_next[1] = intr_state_fifo_empty_qs;
        reg_rdata_next[2] = intr_state_kmac_err_qs;
      end

      addr_hit[1]: begin
        reg_rdata_next[0] = intr_enable_kmac_done_qs;
        reg_rdata_next[1] = intr_enable_fifo_empty_qs;
        reg_rdata_next[2] = intr_enable_kmac_err_qs;
      end

      addr_hit[2]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
        reg_rdata_next[2] = '0;
      end

      addr_hit[3]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
      end

      addr_hit[4]: begin
        reg_rdata_next[0] = cfg_regwen_qs;
      end

      addr_hit[5]: begin
        reg_rdata_next[0] = cfg_shadowed_kmac_en_qs;
        reg_rdata_next[3:1] = cfg_shadowed_kstrength_qs;
        reg_rdata_next[5:4] = cfg_shadowed_mode_qs;
        reg_rdata_next[8] = cfg_shadowed_msg_endianness_qs;
        reg_rdata_next[9] = cfg_shadowed_state_endianness_qs;
        reg_rdata_next[12] = cfg_shadowed_sideload_qs;
        reg_rdata_next[17:16] = cfg_shadowed_entropy_mode_qs;
        reg_rdata_next[19] = cfg_shadowed_entropy_fast_process_qs;
        reg_rdata_next[20] = cfg_shadowed_msg_mask_qs;
        reg_rdata_next[24] = cfg_shadowed_entropy_ready_qs;
        reg_rdata_next[26] = cfg_shadowed_en_unsupported_modestrength_qs;
      end

      addr_hit[6]: begin
        reg_rdata_next[5:0] = '0;
        reg_rdata_next[8] = '0;
        reg_rdata_next[9] = '0;
        reg_rdata_next[10] = '0;
      end

      addr_hit[7]: begin
        reg_rdata_next[0] = status_sha3_idle_qs;
        reg_rdata_next[1] = status_sha3_absorb_qs;
        reg_rdata_next[2] = status_sha3_squeeze_qs;
        reg_rdata_next[12:8] = status_fifo_depth_qs;
        reg_rdata_next[14] = status_fifo_empty_qs;
        reg_rdata_next[15] = status_fifo_full_qs;
        reg_rdata_next[16] = status_alert_fatal_fault_qs;
        reg_rdata_next[17] = status_alert_recov_ctrl_update_err_qs;
      end

      addr_hit[8]: begin
        reg_rdata_next[9:0] = entropy_period_prescaler_qs;
        reg_rdata_next[31:16] = entropy_period_wait_timer_qs;
      end

      addr_hit[9]: begin
        reg_rdata_next[9:0] = entropy_refresh_hash_cnt_qs;
      end

      addr_hit[10]: begin
        reg_rdata_next[9:0] = entropy_refresh_threshold_shadowed_qs;
      end

      addr_hit[11]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[12]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[13]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[14]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[15]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[16]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[17]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[18]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[19]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[20]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[21]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[22]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[23]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[24]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[25]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[26]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[27]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[28]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[29]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[30]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[31]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[32]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[33]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[34]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[35]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[36]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[37]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[38]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[39]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[40]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[41]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[42]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[43]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[44]: begin
        reg_rdata_next[2:0] = '0;
      end

      addr_hit[45]: begin
        reg_rdata_next[31:0] = prefix_0_qs;
      end

      addr_hit[46]: begin
        reg_rdata_next[31:0] = prefix_1_qs;
      end

      addr_hit[47]: begin
        reg_rdata_next[31:0] = prefix_2_qs;
      end

      addr_hit[48]: begin
        reg_rdata_next[31:0] = prefix_3_qs;
      end

      addr_hit[49]: begin
        reg_rdata_next[31:0] = prefix_4_qs;
      end

      addr_hit[50]: begin
        reg_rdata_next[31:0] = prefix_5_qs;
      end

      addr_hit[51]: begin
        reg_rdata_next[31:0] = prefix_6_qs;
      end

      addr_hit[52]: begin
        reg_rdata_next[31:0] = prefix_7_qs;
      end

      addr_hit[53]: begin
        reg_rdata_next[31:0] = prefix_8_qs;
      end

      addr_hit[54]: begin
        reg_rdata_next[31:0] = prefix_9_qs;
      end

      addr_hit[55]: begin
        reg_rdata_next[31:0] = prefix_10_qs;
      end

      addr_hit[56]: begin
        reg_rdata_next[31:0] = err_code_qs;
      end

      default: begin
        reg_rdata_next = '1;
      end
    endcase
  end

  // shadow busy
  logic shadow_busy;
  logic rst_done;
  logic shadow_rst_done;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      rst_done <= '0;
    end else begin
      rst_done <= 1'b1;
    end
  end

  always_ff @(posedge clk_i or negedge rst_shadowed_ni) begin
    if (!rst_shadowed_ni) begin
      shadow_rst_done <= '0;
    end else begin
      shadow_rst_done <= 1'b1;
    end
  end

  // both shadow and normal resets have been released
  assign shadow_busy = ~(rst_done & shadow_rst_done);

  // Collect up storage and update errors
  assign shadowed_storage_err_o = |{
    cfg_shadowed_kmac_en_storage_err,
    cfg_shadowed_kstrength_storage_err,
    cfg_shadowed_mode_storage_err,
    cfg_shadowed_msg_endianness_storage_err,
    cfg_shadowed_state_endianness_storage_err,
    cfg_shadowed_sideload_storage_err,
    cfg_shadowed_entropy_mode_storage_err,
    cfg_shadowed_entropy_fast_process_storage_err,
    cfg_shadowed_msg_mask_storage_err,
    cfg_shadowed_entropy_ready_storage_err,
    cfg_shadowed_en_unsupported_modestrength_storage_err,
    entropy_refresh_threshold_shadowed_storage_err
  };
  assign shadowed_update_err_o = |{
    cfg_shadowed_kmac_en_update_err,
    cfg_shadowed_kstrength_update_err,
    cfg_shadowed_mode_update_err,
    cfg_shadowed_msg_endianness_update_err,
    cfg_shadowed_state_endianness_update_err,
    cfg_shadowed_sideload_update_err,
    cfg_shadowed_entropy_mode_update_err,
    cfg_shadowed_entropy_fast_process_update_err,
    cfg_shadowed_msg_mask_update_err,
    cfg_shadowed_entropy_ready_update_err,
    cfg_shadowed_en_unsupported_modestrength_update_err,
    entropy_refresh_threshold_shadowed_update_err
  };

  // register busy
  assign reg_busy = shadow_busy;

  // Unused signal tieoff

  // wdata / byte enable are not always fully used
  // add a blanket unused statement to handle lint waivers
  logic unused_wdata;
  logic unused_be;
  assign unused_wdata = ^reg_wdata;
  assign unused_be = ^reg_be;

  // Assertions for Register Interface
  `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
  `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)

  `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)

  `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)

  // this is formulated as an assumption such that the FPV testbenches do disprove this
  // property by mistake
  //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)

endmodule


    """


    Identify the CWE relevant to the security issue for the given RTL.
    Obtain details of the CWE.

    Then determine if there are security issues relevant to the identified CWE in the RTL.
    Refer to the code that corresponds to the issues identified.
    
================================== Ai Message ==================================

[{'text': "I'll analyze the provided RTL code for security concerns related to register access control, privilege escalation, and shadowed register integrity.", 'type': 'text'}, {'id': 'toolu_018wnBhP2rKTvUMB4qTKSCkN', 'input': {'security_issue': 'register access control bypass'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_018wnBhP2rKTvUMB4qTKSCkN)
 Call ID: toolu_018wnBhP2rKTvUMB4qTKSCkN
  Args:
    security_issue: register access control bypass
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1220: Insufficient Granularity of Access Control
The product implements access controls via a policy or other feature with the intention to disable or restrict accesses (reads and/or writes) to assets in a system from untrusted agents. However, implemented access controls lack required granularity, which renders the control policy too broad because it allows accesses from unauthorized agents to the security-sensitive assets.
Integrated circuits and hardware engines can expose accesses to assets (device configuration, keys, etc.) to trusted firmware or a software module (commonly set by BIOS/bootloader). This access is typically access-controlled. Upon a power reset, the hardware or system usually starts with default values in registers, and the trusted firmware (Boot firmware) configures the necessary access-control protection.
Example 1
Consider a system with a register for storing AES key for encryption or decryption. The key is 128 bits, implemented as a set of four 32-bit registers. The key registers are assets and registers, AES_KEY_READ_POLICY and AES_KEY_WRITE_POLICY, and are defined to provide necessary access controls. The read-policy register defines which agents can read the AES-key registers, and write-policy register defines which agents can program or write to those registers. Each register is a 32-bit register, and it can support access control for a maximum of 32 agents. The number of the bit when set (i.e., "1") allows respective action from an agent whose identity matches the number of the bit and, if "0" (i.e., Clear), disallows the respective action to that corresponding agent.
(bad code)
Example Language: Other
Register Field description AES_ENC_DEC_KEY_0 AES key [0:31] for encryption or decryption Default 0x00000000 AES_ENC_DEC_KEY_1 AES key [32:63] for encryption or decryption Default 0x00000000 AES_ENC_DEC_KEY_2 AES key [64:95] for encryption or decryption Default 0x00000000 AES_ENC_DEC_KEY_4 AES key [96:127] for encryption or decryption Default 0x00000000 AES_KEY_READ_WRITE_POLICY [31:0] Default 0x00000006 - meaning agent with identities "1" and "2" can both read from and write to key registers In the above example, there is only one policy register that controls access to both read and write accesses to the AES-key registers, and thus the design is not granular enough to separate read and writes access for different agents. Here, agent with identities "1" and "2" can both read and write. A good design should be granular enough to provide separate access controls to separate actions. Access control for reads should be separate from writes. Below is an example of such implementation where two policy registers are defined for each of these actions. The policy is defined such that: the AES-key registers can only be read or used by a crypto agent with identity "1" when bit #1 is set. The AES-key registers can only be programmed by a trusted firmware with identity "2" when bit #2 is set.
(good code)
Example Language: Other
AES_KEY_READ_POLICY [31:0] Default 0x00000002 - meaning only Crypto engine with identity "1" can read registers: AES_ENC_DEC_KEY_0, AES_ENC_DEC_KEY_1, AES_ENC_DEC_KEY_2, AES_ENC_DEC_KEY_3 AES_KEY_WRITE_POLICY [31:0] Default 0x00000004 - meaning only trusted firmware with identity "2" can program registers: AES_ENC_DEC_KEY_0, AES_ENC_DEC_KEY_1, AES_ENC_DEC_KEY_2, AES_ENC_DEC_KEY_3

Example 2
Within the AXI node interface wrapper module in the RISC-V AXI module of the HACK@DAC'19 CVA6 SoC, an access control mechanism is employed to regulate the access of different privileged users to peripherals. The AXI ensures that only users with appropriate privileges can access specific peripherals. For instance, a ROM module is accessible exclusively with Machine privilege, and AXI enforces that users attempting to read data from the ROM must possess machine privilege; otherwise, access to the ROM is denied. The access control information and configurations are stored in a ROM.
(bad code)
Example Language: Verilog
...
for (i=0; i<NB_SUBORDINATE; i++)
begin
for (j=0; j<NB_MANAGER; j++)
begin
assign connectivity_map_o[i][j] = access_ctrl_i[i][j][priv_lvl_i] || ((j==6) && access_ctrl_i[i][7][priv_lvl_i]);
end
end
...
However, in the example code above, while assigning distinct privileges to AXI manager and subordinates, both the Platform-Level Interrupt Controller Specification (PLIC) and the Core-local Interrupt Controller (CLINT) (which are peripheral numbers 6 and 7 respectively) utilize the same access control configuration. This common configuration diminishes the granularity of the AXI access control mechanism. In certain situations, it might be necessary to grant higher privileges for accessing the PLIC than those required for accessing the CLINT. Unfortunately, this differentiation is overlooked, allowing an attacker to access the PLIC with lower privileges than intended. As a consequence, unprivileged code can read and write to the PLIC even when it was not intended to do so. In the worst-case scenario, the attacker could manipulate interrupt priorities, potentially modifying the system's behavior or availability. To address the aforementioned vulnerability, developers must enhance the AXI access control granularity by implementing distinct access control entries for the Platform-Level Interrupt Controller (PLIC) and the Core-local Interrupt Controller (CLINT). By doing so, different privilege levels can be defined for accessing PLIC and CLINT, effectively thwarting the potential attacks previously highlighted. This approach ensures a more robust and secure system, safeguarding against unauthorized access and manipulation of interrupt priorities.
(good code)
Example Language: Verilog
...
for (i=0; i<NB_SUBORDINATE; i++)
begin
for (j=0; j<NB_MANAGER; j++)
begin
assign connectivity_map_o[i][j] = access_ctrl_i[i][j][priv_lvl_i];
end
end
...

Example 3
Consider the following SoC design. The sram in HRoT has an address range that is readable and writable by unprivileged software and it has an area that is only readable by unprivileged software. The tbus interconnect enforces access control for subordinates on the bus but uses only one bit to control both read and write access. Address 0xA0000000 - 0xA000FFFF is readable and writable by the untrusted cores core{0-N} and address 0xA0010000 - 0xA001FFFF is only readable by the untrusted cores core{0-N}. The security policy access control is not granular enough, as it uses one bit to enable both read and write access. This gives write access to an area that should only be readable by unprivileged agents. Access control logic should differentiate between read and write access and to have sufficient address granularity.


================================== Ai Message ==================================

[{'id': 'toolu_01F1x7DK4GJnMr6foPgbgpxx', 'input': {'security_issue': 'shadowed register integrity'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01F1x7DK4GJnMr6foPgbgpxx)
 Call ID: toolu_01F1x7DK4GJnMr6foPgbgpxx
  Args:
    security_issue: shadowed register integrity
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1283: Mutable Attestation or Measurement Reporting Data
The register contents used for attestation or measurement reporting data to verify boot flow are modifiable by an adversary.
A System-on-Chip (SoC) implements secure boot or verified boot. During this boot flow, the SoC often measures the code that it authenticates. The measurement is usually done by calculating the one-way hash of the code binary and extending it to the previous hash. The hashing algorithm should be a Secure One-Way hash function. The final hash, i.e., the value obtained after the completion of the boot flow, serves as the measurement data used in reporting or in attestation. The calculated hash is often stored in registers that can later be read by the party of interest to determine tampering of the boot flow. A common weakness is that the contents in these registers are modifiable by an adversary, thus spoofing the measurement.
Example 1
The SoC extends the hash and stores the results in registers. Without protection, an adversary can write their chosen hash values to these registers. Thus, the attacker controls the reported results. To prevent the above scenario, the registers should have one or more of the following properties: Should be Read-Only with respect to an adversary Cannot be extended or modifiable either directly or indirectly (using a trusted agent as proxy) by an adversary Should have appropriate access controls or protections


================================== Ai Message ==================================

[{'id': 'toolu_016zGfMxYZbchNYadVWefg5d', 'input': {'security_issue': 'privilege escalation hardware'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_016zGfMxYZbchNYadVWefg5d)
 Call ID: toolu_016zGfMxYZbchNYadVWefg5d
  Args:
    security_issue: privilege escalation hardware
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1268: Policy Privileges are not Assigned Consistently Between Control and Data Agents
The product's hardware-enforced access control for a particular resource improperly accounts for privilege discrepancies between control and write policies.
Integrated circuits and hardware engines may provide access to resources (device-configuration, encryption keys, etc.) belonging to trusted firmware or software modules (commonly set by a BIOS or a bootloader). These accesses are typically controlled and limited by the hardware. Hardware design access control is sometimes implemented using a policy. A policy defines which entity or agent may or may not be allowed to perform an action. When a system implements multiple levels of policies, a control policy may allow direct access to a resource as well as changes to the policies themselves.
Example 1
Consider a system of seven registers for storing and configuring an AES key for encryption or decryption. Four 32-bit registers are used to store a 128-bit AES key. The names of those registers are AES_ENC_DEC_KEY_0, AES_ENC_DEC_KEY_1, AES_ENC_DEC_KEY_2, and AES_ENC_DEC_KEY_3. Collectively these are referred to as the AES Key registers. RegisterField description AES_ENC_DEC_KEY_0AES key [0:31] for encryption or decryption Default 0x00000000 AES_ENC_DEC_KEY_1AES key [32:63] for encryption or decryption Default 0x00000000 AES_ENC_DEC_KEY_2AES key [64:95] for encryption or decryption Default 0x00000000 AES_ENC_DEC_KEY_3AES key [96:127] for encryption or decryption Default 0x00000000 Three 32-bit registers are used to define access control for the AES-key registers. The names of those registers are AES_KEY_CONTROL_POLICY, AES_KEY_READ_POLICY, and AES_KEY_WRITE_POLICY. Collectively these registers are referred to as the Policy registers, and their functions are explained next. The AES_KEY_CONTROL_POLICY register defines which agents can write to the AES_KEY_READ_POLICY or AES_KEY_WRITE_POLICY registers. The AES_KEY_READ_POLICY register defines which agents can read the AES-key registers. The AES_KEY_WRITE_POLICY register defines which agents can write the AES key registers. The preceding three policy registers encode access control at the bit level. Therefore a maximum of 32 agents can be defined (1 bit per agent). The value of the bit when set (i.e., "1") allows the respective action from an agent whose identity corresponds to the number of the bit. If clear (i.e., "0"), it disallows the respective action to that corresponding agent. For example, if bit 0 is set to "1" in the AES_KEY_READ_POLICY register, then agent 0 has permission to read the AES-key registers. Consider that there are 4 agents named Agent 1, Agent 2, Agent 3, and Agent 4. For access control purposes Agent 1 is assigned to bit 1, Agent 2 to bit 2, Agent 3 to bit 3, and Agent 4 to bit 4. All agents are trusted except for Agent 3 who is untrusted. Also consider the register values in the below table.
(bad code)
RegisterField description AES_KEY_CONTROL_POLICYControls which agents can write to READ_POLICY and WRITE_POLICY registers [31:0] Default 0x00000018 AES_KEY_READ_POLICYControls which agents can read the AES-key registers [31:0] Default 0x00000002 AES_KEY_WRITE_POLICYControls which agents can write to the AES-key registers [31:0] Default 0x00000004
IThe AES_KEY_CONTROL_POLICY register value is 0x00000018. In binary, the lower 8 bits will be 0001 1000, meaning that: Bits 3 and 4 are set, thus Agents 3 and 4 will have write access to AES_KEY_READ_POLICY or AES_KEY_WRITE_POLICY. All other bits are clear, hence agents other than 3 and 4 will not have access to write to AES_KEY_READ_POLICY or AES_KEY_WRITE_POLICY. The AES_KEY_READ_POLICY register value is 0x00000002. In binary, the lower 8 bits will be 0000 0010, meaning that: Bit 1 is set, thus Agent 1 will be able to read the AES key registers. The AES_KEY_WRITE_POLICY register value is 0x00000004. In binary, the lower 8 bits will be 0000 0100, meaning that: Bit 2 is set, thus Agent 2 will be able to write the AES Key registers. The configured access control policy for Agents 1,2,3,4 is summarized in table below. AgentReadWriteControl Agent 1AllowedNot AllowedNot Allowed Agent 2Not AllowedAllowedNot Allowed Agent 3Not AllowedNot AllowedAllowed Agent 4Not AllowedNot AllowedAllowed At this point Agents 3 and 4 can only configure which agents can read AES keys and which agents can write AES keys. Agents 3 and 4 cannot read or write AES keys - just configure access control. Now, recall Agent 3 is untrusted. As explained above, the value of the AES_KEY_CONTROL_POLICY register gives agent 3 access to write to the AES_KEY_WRITE_POLICY register. Agent 3 can use this write access to add themselves to the AES_KEY_WRITE_POLICY register. This is accomplished by Agent 3 writing the value 0x00000006. In binary, the lower 8 bits are 0000 0110, meaning that bit 3 will be set. Thus, giving Agent 3 having the ability to write to the AES Key registers. If the AES_KEY_CONTROL_POLICY register value is 0x00000010, the lower 8 bits will be 0001 0000. This will give Agent 4, a trusted agent, write access to AES_KEY_WRITE_POLICY, but Agent 3, who is untrusted, will not have write access. The Policy register values should therefore be as follows:
(good code)
RegisterField description AES_KEY_CONTROL_POLICY[31:0] Default 0x00000010 AES_KEY_READ_POLICY[31:0] Default 0x00000002 AES_KEY_WRITE_POLICY[31:0] Default 0x00000004


================================== Ai Message ==================================

Based on my analysis of the provided RTL code and the CWE information, I've identified several security concerns related to register access control, privilege escalation, and shadowed register integrity:

## 1. Register Access Control Issues (CWE-1220)

The RTL implements a register access control mechanism using the `cfg_regwen_qs` signal to gate write operations to various registers. This is evident in lines like:

```verilog
// Create REGWEN-gated WE signal
logic cfg_shadowed_gated_we;
assign cfg_shadowed_gated_we = cfg_shadowed_we & cfg_regwen_qs;
```

However, there are potential security concerns:

1. **Insufficient Granularity**: The code uses a single `cfg_regwen_qs` signal to control write access to multiple security-sensitive registers, including key registers, configuration registers, and shadowed registers. This lacks the granularity recommended in CWE-1220, where different types of registers should have different access control mechanisms.

2. **Socket-based Steering Logic**: The RTL uses a steering mechanism to route transactions:

```verilog
always_comb begin
  reg_steer =
      tl_i.a_address[AW-1:0] inside {[1024:1535]} ? 2'd0 :
      tl_i.a_address[AW-1:0] inside {[2048:4095]} ? 2'd1 :
      // Default set to register
      2'd2;

  // Override this in case of an integrity error
  if (intg_err) begin
    reg_steer = 2'd2;
  end
end
```

This steering logic could potentially be exploited if an attacker can manipulate address ranges to bypass intended access controls.

## 2. Shadowed Register Integrity Issues (CWE-1283)

The RTL implements shadowed registers for critical configuration settings, which is a good security practice. However, there are concerns:

1. **Error Handling**: The code collects shadowed register errors:

```verilog
assign shadowed_storage_err_o = |{
  cfg_shadowed_kmac_en_storage_err,
  cfg_shadowed_kstrength_storage_err,
  // ... other errors ...
};
```

But it's not clear if these errors trigger immediate protective actions beyond setting an alert signal.

2. **Shadow Register Reset**: The code implements separate reset signals for normal and shadowed registers:

```verilog
always_ff @(posedge clk_i or negedge rst_ni) begin
  if (!rst_ni) begin
    rst_done <= '0;
  end else begin
    rst_done <= 1'b1;
  end
end

always_ff @(posedge clk_i or negedge rst_shadowed_ni) begin
  if (!rst_shadowed_ni) begin
    shadow_rst_done <= '0;
  end else begin
    shadow_rst_done <= 1'b1;
  end
end
```

If an attacker can manipulate one reset signal but not the other, they might create inconsistencies between shadow and main registers.

## 3. Privilege Escalation Concerns (CWE-1268)

The RTL has potential privilege escalation issues:

1. **Key Register Access**: The key registers (key_share0_* and key_share1_*) are protected by the same `cfg_regwen_qs` signal as other less sensitive registers. If an attacker can manipulate this signal, they could potentially gain write access to cryptographic keys.

2. **Command Register**: The `cmd` register allows various operations including entropy requests and error processing:

```verilog
//   F[cmd]: 5:0
prim_subreg_ext #(
  .DW    (6)
) u_cmd_cmd (
  .re     (1'b0),
  .we     (cmd_we),
  .wd     (cmd_cmd_wd),
  .d      ('0),
  .qre    (),
  .qe     (cmd_flds_we[0]),
  .q      (reg2hw.cmd.cmd.q),
  .ds     (),
  .qs     ()
);
```

If an att
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

Based on my analysis of the provided RTL code and the CWE information, I've identified several security concerns related to register access control, privilege escalation, and shadowed register integrity:

## 1. Register Access Control Issues (CWE-1220)

The RTL implements a register access control mechanism using the `cfg_regwen_qs` signal to gate write operations to various registers. This is evident in lines like:

```verilog
// Create REGWEN-gated WE signal
logic cfg_shadowed_gated_we;
assign cfg_shadowed_gated_we = cfg_shadowed_we & cfg_regwen_qs;
```

However, there are potential security concerns:

1. **Insufficient Granularity**: The code uses a single `cfg_regwen_qs` signal to control write access to multiple security-sensitive registers, including key registers, configuration registers, and shadowed registers. This lacks the granularity recommended in CWE-1220, where different types of registers should have different access control mechanisms.

2. **Socket-based Steering Logic**: The RTL uses a steering mechanism to route transactions:

```verilog
always_comb begin
  reg_steer =
      tl_i.a_address[AW-1:0] inside {[1024:1535]} ? 2'd0 :
      tl_i.a_address[AW-1:0] inside {[2048:4095]} ? 2'd1 :
      // Default set to register
      2'd2;

  // Override this in case of an integrity error
  if (intg_err) begin
    reg_steer = 2'd2;
  end
end
```

This steering logic could potentially be exploited if an attacker can manipulate address ranges to bypass intended access controls.

## 2. Shadowed Register Integrity Issues (CWE-1283)

The RTL implements shadowed registers for critical configuration settings, which is a good security practice. However, there are concerns:

1. **Error Handling**: The code collects shadowed register errors:

```verilog
assign shadowed_storage_err_o = |{
  cfg_shadowed_kmac_en_storage_err,
  cfg_shadowed_kstrength_storage_err,
  // ... other errors ...
};
```

But it's not clear if these errors trigger immediate protective actions beyond setting an alert signal.

2. **Shadow Register Reset**: The code implements separate reset signals for normal and shadowed registers:

```verilog
always_ff @(posedge clk_i or negedge rst_ni) begin
  if (!rst_ni) begin
    rst_done <= '0;
  end else begin
    rst_done <= 1'b1;
  end
end

always_ff @(posedge clk_i or negedge rst_shadowed_ni) begin
  if (!rst_shadowed_ni) begin
    shadow_rst_done <= '0;
  end else begin
    shadow_rst_done <= 1'b1;
  end
end
```

If an attacker can manipulate one reset signal but not the other, they might create inconsistencies between shadow and main registers.

## 3. Privilege Escalation Concerns (CWE-1268)

The RTL has potential privilege escalation issues:

1. **Key Register Access**: The key registers (key_share0_* and key_share1_*) are protected by the same `cfg_regwen_qs` signal as other less sensitive registers. If an attacker can manipulate this signal, they could potentially gain write access to cryptographic keys.

2. **Command Register**: The `cmd` register allows various operations including entropy requests and error processing:

```verilog
//   F[cmd]: 5:0
prim_subreg_ext #(
  .DW    (6)
) u_cmd_cmd (
  .re     (1'b0),
  .we     (cmd_we),
  .wd     (cmd_cmd_wd),
  .d      ('0),
  .qre    (),
  .qe     (cmd_flds_we[0]),
  .q      (reg2hw.cmd.cmd.q),
  .ds     (),
  .qs     ()
);
```

If an att
================================== Ai Message ==================================

## OpenTitan KMAC IP Security Analysis Report

### 1. Security Features and Register Interface Policies

#### Security Features (from `theory_of_operation.md`)
- **Masked Keccak Core**: Supports first-order masking (two shares) for side-channel resistance. Masking can be disabled at compile time.
- **Key Sideloading**: Supports sideloaded keys from KeyMgr, always in two-share masked form.
- **Shadowed Registers**: Critical configuration registers are shadowed for fault injection resistance.
- **Application Interface Isolation**: Multiple hardware application interfaces (KeyMgr, LC_CTRL, ROM_CTRL) are isolated and prioritized.
- **Entropy Generator**: Integrated PRNG, seeded from EDN or software, for masking and remasking.
- **Error Detection**: Internal error checkers report to `ERR_CODE` and raise interrupts.
- **FSM Hardening**: Sparse FSM encoding and terminal error states for glitch/fault resistance.
- **Privilege Separation**: Software and hardware-initiated operations are isolated in the FSM.

#### Register Interface Policies (from `registers.md`)
- **Shadowed Register Updates**: Only allowed when engine is idle; protected by `CFG_REGWEN`.
- **Key Registers**: Writeable only in idle; always two shares if masking enabled.
- **Command Sequence**: Strict sequence enforced (`start` → `process` → `run` (optional) → `done`).
- **Access Control**: Sideloaded keys used for hardware-initiated KMAC; software can select sideload via `CFG_SHADOWED.sideload`.
- **Error Handling**: Errors in shadowed registers, privilege violations, or command sequence violations are reported in `ERR_CODE` and can halt operation.

---

### 2. RTL Security Vulnerability Analysis

#### A. Register Interface & Shadowed Register Integrity (`kmac_reg_top.sv`)
- **File**: `kmac_reg_top.sv`
- **Line(s)**: ~2000 (shadowed register error collection and propagation)
- **Issue**: **Shadowed register errors are not always properly propagated to error outputs within the required time window.**
- **Security Aspect**: Fault injection resistance, privilege escalation, register integrity.
- **Tools Used**: Assertion Checker, Linter, CWE Agent
- **Details**: Failing assertions show that errors in shadowed registers (e.g., `cfg_shadowed_kmac_en_storage_err`) may not trigger error outputs promptly, risking undetected configuration manipulation.

#### B. Application Interface Isolation & Command Injection (`kmac_app.sv`)
- **File**: `kmac_app.sv`
- **Line(s)**: 728-735, 735-742, 646-648
- **Issue**: 
  - **Software can inject messages or commands during hardware application operation.**
  - **Invalid keys from KeyMgr may not always force error state.**
- **Security Aspect**: Application interface isolation, privilege escalation, command injection, key integrity.
- **Tools Used**: Assertion Checker, Linter, CWE Agent, Manual Review
- **Details**: 
  - Failing assertions show that software can push messages or commands when hardware app is active, risking privilege escalation.
  - Key validation logic may allow operations with invalid keys, risking cryptographic compromise.
  - Linter flagged FSM control issues (UniquePriorityMisuse-ML) that could lead to unintended state transitions.

#### C. Message FIFO Masking & Integrity (`kmac_msgfifo.sv`)
- **File**: `kmac_msgfifo.sv`
- **Line(s)**: Masking logic, flush logic (see assertion failures)
- **Issue**: 
  - **FIFO masking may allow zero masks when masking is enabled.**
  - **New messages may be accepted during flush, risking data corruption.**
- **Security Aspect**: Side-channel resistance, message integrity, privilege separation.
- **Tools Used**: Assertion Checker, Linter
- **Details**: 
  - Masking logic does not enforce non-zero mask when enabled, weakening side-channel protection.
  - Flush logic may allow message injection during flush, risking integrity and privilege separation.

#### D. Key Handling, FSM Hardening, Masking (`kmac_core.sv`)
- **File**: `kmac_core.sv`
- **Line(s)**: Key encoding, FSM state encoding, masking logic
- **Issue**: 
  - **No critical security issues found.**
  - **Hard-coded constants in key length encoding (lines ~317-321) flagged by linter.**
- **Security Aspect**: FSM hardening, masking, key handling.
- **Tools Used**: Assertion Checker, Linter, Anomaly Detector, CWE Agent
- **Details**: 
  - FSM is robust (sparse encoding, terminal error state).
  - Masking and key handling are implemented securely.
  - Hard-coded constants are a maintainability concern but not a direct security risk.

#### E. Clock Gating & SCA Resistance (from Verilator Tests)
- **File**: (System-level, not a single file)
- **Issue**: **Clock gating failures may increase side-channel leakage.**
- **Security Aspect**: Side-channel resistance.
- **Tools Used**: Verilator Agent
- **Details**: Failing tests indicate the clock may not be properly gated when idle, increasing SCA risk.

---

### 3. Recurring/Suspect Patterns

- **Error Handling and Propagation**: Across modules, error signals and FSM transitions must be carefully reviewed to ensure all security violations (shadowed register errors, invalid key use, privilege violations) are promptly detected and handled.
- **FSM Control**: Lint and assertion failures in FSM logic (especially in `kmac_app.sv`) suggest a need for more robust privilege separation and error state enforcement.
- **Masking Enforcement**: Masking logic in both the core and FIFO must strictly enforce non-zero masks and correct operation during all transitions.

---

## Summary Table of Issues

| File                   | Line(s)      | Description                                                      | Security Aspect                | Tools Used                      |
|------------------------|--------------|------------------------------------------------------------------|--------------------------------|----------------------------------|
| kmac_reg_top.sv        | ~2000        | Shadowed register errors not always propagated                   | Register integrity, privilege  | Assertion Checker, CWE Agent     |
| kmac_app.sv            | 728-742,646+ | SW can inject commands/messages during HW app, invalid key use   | Interface isolation, escalation| Assertion Checker, Linter, CWE   |
| kmac_msgfifo.sv        | Mask/flush   | FIFO masking allows zero mask, flush accepts new messages        | Masking, integrity, separation | Assertion Checker, Linter        |
| kmac_core.sv           | ~317-321     | Hard-coded key length constants (maintainability)                | Key handling                   | Linter                          |
| (System-level)         | N/A          | Clock gating failures (test-level)                               | Side-channel resistance        | Verilator Agent                  |

---

## Recommendations

- **Fix shadowed register error propagation** to ensure all errors are immediately visible and halt sensitive operations.
- **Strengthen FSM and error handling** in `kmac_app.sv` to strictly prevent SW command/message injection during HW app operation and enforce key validity.
- **Enforce non-zero masking** in FIFO and core logic when masking is enabled.
- **Prevent new messages during flush** in FIFO to avoid data corruption or privilege violations.
- **Review and fix FSM control and unique/priority misuse** to avoid unintended state transitions.
- **Address clock gating failures** to reduce side-channel leakage.
- **Replace hard-coded constants** with parameterized values for maintainability and security.

---

**END**
================================== Ai Message ==================================

## OpenTitan KMAC IP Security Analysis Report

### 1. Security Features and Register Interface Policies

#### Security Features (from `theory_of_operation.md`)
- **Masked Keccak Core**: Supports first-order masking (two shares) for side-channel resistance. Masking can be disabled at compile time.
- **Key Sideloading**: Supports sideloaded keys from KeyMgr, always in two-share masked form.
- **Shadowed Registers**: Critical configuration registers are shadowed for fault injection resistance.
- **Application Interface Isolation**: Multiple hardware application interfaces (KeyMgr, LC_CTRL, ROM_CTRL) are isolated and prioritized.
- **Entropy Generator**: Integrated PRNG, seeded from EDN or software, for masking and remasking.
- **Error Detection**: Internal error checkers report to `ERR_CODE` and raise interrupts.
- **FSM Hardening**: Sparse FSM encoding and terminal error states for glitch/fault resistance.
- **Privilege Separation**: Software and hardware-initiated operations are isolated in the FSM.

#### Register Interface Policies (from `registers.md`)
- **Shadowed Register Updates**: Only allowed when engine is idle; protected by `CFG_REGWEN`.
- **Key Registers**: Writeable only in idle; always two shares if masking enabled.
- **Command Sequence**: Strict sequence enforced (`start` → `process` → `run` (optional) → `done`).
- **Access Control**: Sideloaded keys used for hardware-initiated KMAC; software can select sideload via `CFG_SHADOWED.sideload`.
- **Error Handling**: Errors in shadowed registers, privilege violations, or command sequence violations are reported in `ERR_CODE` and can halt operation.

---

### 2. RTL Security Vulnerability Analysis

#### A. Register Interface & Shadowed Register Integrity (`kmac_reg_top.sv`)
- **File**: `kmac_reg_top.sv`
- **Line(s)**: ~2000 (shadowed register error collection and propagation)
- **Issue**: **Shadowed register errors are not always properly propagated to error outputs within the required time window.**
- **Security Aspect**: Fault injection resistance, privilege escalation, register integrity.
- **Tools Used**: Assertion Checker, Linter, CWE Agent
- **Details**: Failing assertions show that errors in shadowed registers (e.g., `cfg_shadowed_kmac_en_storage_err`) may not trigger error outputs promptly, risking undetected configuration manipulation.

#### B. Application Interface Isolation & Command Injection (`kmac_app.sv`)
- **File**: `kmac_app.sv`
- **Line(s)**: 728-735, 735-742, 646-648
- **Issue**: 
  - **Software can inject messages or commands during hardware application operation.**
  - **Invalid keys from KeyMgr may not always force error state.**
- **Security Aspect**: Application interface isolation, privilege escalation, command injection, key integrity.
- **Tools Used**: Assertion Checker, Linter, CWE Agent, Manual Review
- **Details**: 
  - Failing assertions show that software can push messages or commands when hardware app is active, risking privilege escalation.
  - Key validation logic may allow operations with invalid keys, risking cryptographic compromise.
  - Linter flagged FSM control issues (UniquePriorityMisuse-ML) that could lead to unintended state transitions.

#### C. Message FIFO Masking & Integrity (`kmac_msgfifo.sv`)
- **File**: `kmac_msgfifo.sv`
- **Line(s)**: Masking logic, flush logic (see assertion failures)
- **Issue**: 
  - **FIFO masking may allow zero masks when masking is enabled.**
  - **New messages may be accepted during flush, risking data corruption.**
- **Security Aspect**: Side-channel resistance, message integrity, privilege separation.
- **Tools Used**: Assertion Checker, Linter
- **Details**: 
  - Masking logic does not enforce non-zero mask when enabled, weakening side-channel protection.
  - Flush logic may allow message injection during flush, risking integrity and privilege separation.

#### D. Key Handling, FSM Hardening, Masking (`kmac_core.sv`)
- **File**: `kmac_core.sv`
- **Line(s)**: Key encoding, FSM state encoding, masking logic
- **Issue**: 
  - **No critical security issues found.**
  - **Hard-coded constants in key length encoding (lines ~317-321) flagged by linter.**
- **Security Aspect**: FSM hardening, masking, key handling.
- **Tools Used**: Assertion Checker, Linter, Anomaly Detector, CWE Agent
- **Details**: 
  - FSM is robust (sparse encoding, terminal error state).
  - Masking and key handling are implemented securely.
  - Hard-coded constants are a maintainability concern but not a direct security risk.

#### E. Clock Gating & SCA Resistance (from Verilator Tests)
- **File**: (System-level, not a single file)
- **Issue**: **Clock gating failures may increase side-channel leakage.**
- **Security Aspect**: Side-channel resistance.
- **Tools Used**: Verilator Agent
- **Details**: Failing tests indicate the clock may not be properly gated when idle, increasing SCA risk.

---

### 3. Recurring/Suspect Patterns

- **Error Handling and Propagation**: Across modules, error signals and FSM transitions must be carefully reviewed to ensure all security violations (shadowed register errors, invalid key use, privilege violations) are promptly detected and handled.
- **FSM Control**: Lint and assertion failures in FSM logic (especially in `kmac_app.sv`) suggest a need for more robust privilege separation and error state enforcement.
- **Masking Enforcement**: Masking logic in both the core and FIFO must strictly enforce non-zero masks and correct operation during all transitions.

---

## Summary Table of Issues

| File                   | Line(s)      | Description                                                      | Security Aspect                | Tools Used                      |
|------------------------|--------------|------------------------------------------------------------------|--------------------------------|----------------------------------|
| kmac_reg_top.sv        | ~2000        | Shadowed register errors not always propagated                   | Register integrity, privilege  | Assertion Checker, CWE Agent     |
| kmac_app.sv            | 728-742,646+ | SW can inject commands/messages during HW app, invalid key use   | Interface isolation, escalation| Assertion Checker, Linter, CWE   |
| kmac_msgfifo.sv        | Mask/flush   | FIFO masking allows zero mask, flush accepts new messages        | Masking, integrity, separation | Assertion Checker, Linter        |
| kmac_core.sv           | ~317-321     | Hard-coded key length constants (maintainability)                | Key handling                   | Linter                          |
| (System-level)         | N/A          | Clock gating failures (test-level)                               | Side-channel resistance        | Verilator Agent                  |

---

## Recommendations

- **Fix shadowed register error propagation** to ensure all errors are immediately visible and halt sensitive operations.
- **Strengthen FSM and error handling** in `kmac_app.sv` to strictly prevent SW command/message injection during HW app operation and enforce key validity.
- **Enforce non-zero masking** in FIFO and core logic when masking is enabled.
- **Prevent new messages during flush** in FIFO to avoid data corruption or privilege violations.
- **Review and fix FSM control and unique/priority misuse** to avoid unintended state transitions.
- **Address clock gating failures** to reduce side-channel leakage.
- **Replace hard-coded constants** with parameterized values for maintainability and security.

---

**END**
================================== Ai Message ==================================

[]
