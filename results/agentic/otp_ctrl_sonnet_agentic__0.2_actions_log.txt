Listing directory: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/doc
Reading file: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/doc/theory_of_operation.md
Reading file: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/doc/registers.md
Listing directory: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl
Running verilator agent on otp_ctrl
Running verilator tests for otp_ctrl
Running linter agent on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_core_reg_top.sv for otp_ctrl_core_reg_top with security objective: register interface security and access control
Running lint checker tool on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_core_reg_top.sv for otp_ctrl_core_reg_top with lint tags: ['RegInputOutput-ML', 'RegInput-ML', 'Rule_41', 'STARC05-2.1.9.5', 'W240', 'RegisterInfo-ML', 'InterfaceNameConflicts-ML', 'STARC05-1.4.3.1b', 'W500', 'CheckPortType-ML', 'W110', 'STARC05-1.2.1.1a', 'W401', 'Rule_2', 'STARC05-1.1.1.9c', 'AutomaticFuncTask-ML', 'W188', 'PortOrder_A']
Running linter agent on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_dai.sv for otp_ctrl_dai with security objective: direct access interface security, partition locking, and error handling
Running lint checker tool on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_dai.sv for otp_ctrl_dai with lint tags: ['STARC05-1.4.3.1b', 'STARC05-1.3.2.1a', 'STARC05-2.10.5.3b', 'STARC05-2.4.1.4', 'sim_race07', 'SafeLatch-ML', 'sim_race06', 'STARC05-1.2.1.1a', 'W280', 'W188', 'W240', 'STARC05-1.3.1.2', 'STARC05-2.1.9.5', 'STARC05-2.2.1.2', 'STARC05-2.4.1.5']
Running linter agent on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv for otp_ctrl_part_buf with security objective: partition integrity, ECC, and error state handling
Running lint checker tool on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv for otp_ctrl_part_buf with lint tags: ['STARC05-1.2.1.1a', 'STARC05-1.3.2.1a', 'STARC05-1.4.3.1b', 'STARC05-2.11.1.2', 'STARC05-2.11.1.4', 'STARC05-1.3.1.2', 'STARC05-1.4.3.6', 'SepStateMachine', 'STARC05-2.10.8.2', 'STARC05-2.3.5.1']
Running linter agent on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_unbuf.sv for otp_ctrl_part_unbuf with security objective: partition access control, error state handling
Running lint checker tool on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_unbuf.sv for otp_ctrl_part_unbuf with lint tags: ['STARC05-2.11.1.4', 'STARC05-1.4.3.1b', 'STARC05-2.11.4.1', 'STARC05-2.10.5.3b', 'STARC05-1.3.2.1a', 'STARC05-2.4.1.4', 'STARC05-3.3.1.4a', 'STARC05-1.2.1.1a']
Running linter agent on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_lci.sv for otp_ctrl_lci with security objective: life cycle interface access control and error handling
Running lint checker tool on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_lci.sv for otp_ctrl_lci with lint tags: ['STARC05-2.4.1.4', 'DisallowCaseZ-ML', 'ReEntrantOutput-ML', 'STARC05-1.4.3.1b', 'noCombinatorialFeedBack', 'DisallowCaseX-ML', 'STARC05-1.3.2.1a', 'CAPA-ML', 'FlopFeedbackRace-ML', 'STARC05-1.3.1.2', 'STARC05-2.1.9.5', 'STARC05-2.2.1.2', 'STARC05-1.6.1.2', 'STARC05-2.4.1.5', 'UniqueInputOutputSampling-ML', 'SafeLatch-ML', 'DeadCode', 'W336L', 'STARC05-1.4.3.6', 'STARC05-2.3.5.1']
Running assertions checker agent on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_core_reg_top.sv for otp_ctrl_core_reg_top with security objective: register access policy enforcement, privilege escalation prevention
Running assertions checker agent on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_dai.sv for otp_ctrl_dai with security objective: partition locking, privilege escalation, error propagation
Running assertion checker tool on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_dai.sv for otp_ctrl_dai with assertions: {'lock_bypass_read_p': 'property lock_bypass_read_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (part_sel_valid && mubi8_test_true_strict(part_access_i[part_idx].read_lock) && lock_cnt == Predictor_Mask) |-> !otp_access_grant;\nendproperty\nassert property (lock_bypass_read_p);', 'lock_bypass_write_p': 'property lock_bypass_write_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (part_sel_valid && mubi8_test_true_strict(part_access_i[part_idx].write_lock) && lock_cnt == Predictor_Mask) |-> !otp_access_grant;\nendproperty\nassert property (lock_bypass_write_p);', 'lock_counter_increment_p': 'property lock_counter_increment_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  otp_access_grant && (lock_cnt != Predictor_Mask) |=> (lock_cnt == $past(lock_cnt) + 1);\nendproperty\nassert property (lock_counter_increment_p);', 'escalation_error_p': 'property escalation_error_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) |=> (state_q == ErrorSt);\nendproperty\nassert property (escalation_error_p);', 'error_propagation_p': 'property error_propagation_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (state_q != ErrorSt && error_d != NoError && error_d != AccessError && error_d != MacroEccCorrError && error_d != MacroWriteBlankError) |=> (state_q == ErrorSt);\nendproperty\nassert property (error_propagation_p);'}
Running assertion checker tool on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_dai.sv for otp_ctrl_dai with assertions: {'lock_bypass_read_p': 'property lock_bypass_read_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (part_sel_valid && mubi8_test_true_strict(part_access_i[part_idx].read_lock) && lock_cnt == Predictor_Mask) |-> !otp_access_grant;\nendproperty\nlock_bypass_read_a: assert property (lock_bypass_read_p);', 'lock_bypass_write_p': 'property lock_bypass_write_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (part_sel_valid && mubi8_test_true_strict(part_access_i[part_idx].write_lock) && lock_cnt == Predictor_Mask) |-> !otp_access_grant;\nendproperty\nlock_bypass_write_a: assert property (lock_bypass_write_p);', 'lock_counter_increment_p': 'property lock_counter_increment_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  otp_access_grant && (lock_cnt != Predictor_Mask) |=> (lock_cnt == $past(lock_cnt) + 1);\nendproperty\nlock_counter_increment_a: assert property (lock_counter_increment_p);', 'escalation_error_p': 'property escalation_error_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) |=> (state_q == ErrorSt);\nendproperty\nescalation_error_a: assert property (escalation_error_p);', 'error_propagation_p': 'property error_propagation_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (state_q != ErrorSt && error_d != NoError && error_d != AccessError && error_d != MacroEccCorrError && error_d != MacroWriteBlankError) |=> (state_q == ErrorSt);\nendproperty\nerror_propagation_a: assert property (error_propagation_p);'}
Running assertion checker tool on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_dai.sv for otp_ctrl_dai with assertions: {'lock_bypass_read': 'property lock_bypass_read;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (part_sel_valid && mubi8_test_true_strict(part_access_i[part_idx].read_lock) && lock_cnt == Predictor_Mask) |-> !otp_access_grant;\nendproperty\nassert property (lock_bypass_read);', 'lock_bypass_write': 'property lock_bypass_write;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (part_sel_valid && mubi8_test_true_strict(part_access_i[part_idx].write_lock) && lock_cnt == Predictor_Mask) |-> !otp_access_grant;\nendproperty\nassert property (lock_bypass_write);', 'lock_counter_increment': 'property lock_counter_increment;\n  @(posedge clk_i) disable iff (!rst_ni)\n  otp_access_grant && (lock_cnt != Predictor_Mask) |=> (lock_cnt == $past(lock_cnt) + 1);\nendproperty\nassert property (lock_counter_increment);', 'escalation_error': 'property escalation_error;\n  @(posedge clk_i) disable iff (!rst_ni)\n  lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) |=> (state_q == ErrorSt);\nendproperty\nassert property (escalation_error);', 'error_propagation': 'property error_propagation;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (state_q != ErrorSt && error_d != NoError && error_d != AccessError && error_d != MacroEccCorrError && error_d != MacroWriteBlankError) |=> (state_q == ErrorSt);\nendproperty\nassert property (error_propagation);'}
Running assertions checker agent on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv for otp_ctrl_part_buf with security objective: integrity error handling, ECC error propagation, terminal error state enforcement
Running assertion checker tool on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv for otp_ctrl_part_buf with assertions: {'ecc_error_propagation': 'property ecc_error_propagation;\n  @(posedge clk_i) ecc_err |=> state_q == ErrorSt;\nendproperty\nassertion_ecc_error_propagation: assert property(ecc_error_propagation);', 'otp_error_propagation': 'property otp_error_propagation;\n  @(posedge clk_i) (state_q inside {InitWaitSt, CnstyReadWaitSt} && otp_rvalid_i && !(otp_err inside {NoError, MacroEccCorrError})) |=> state_q == ErrorSt;\nendproperty\nassertion_otp_error_propagation: assert property(otp_error_propagation);', 'escalation_terminal_state': 'property escalation_terminal_state;\n  @(posedge clk_i) lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) |=> state_q == ErrorSt;\nendproperty\nassertion_escalation_terminal_state: assert property(escalation_terminal_state);', 'counter_error_terminal_state': 'property counter_error_terminal_state;\n  @(posedge clk_i) cnt_err |=> state_q == ErrorSt;\nendproperty\nassertion_counter_error_terminal_state: assert property(counter_error_terminal_state);', 'error_state_lock': 'property error_state_lock;\n  @(posedge clk_i) (state_q == ErrorSt) |-> mubi8_test_true_strict(dout_locked_q);\nendproperty\nassertion_error_state_lock: assert property(error_state_lock);', 'integrity_check_fail_terminal': "property integrity_check_fail_terminal;\n  @(posedge clk_i) (state_q == IntegDigWaitSt && scrmbl_valid_i && digest_o != data_mux && digest_o != '0) |=> state_q == ErrorSt && error_q == CheckFailError;\nendproperty\nassertion_integrity_check_fail_terminal: assert property(integrity_check_fail_terminal);", 'consistency_check_fail_terminal': "property consistency_check_fail_terminal;\n  @(posedge clk_i) (state_q == CnstyReadWaitSt && otp_rvalid_i && otp_err inside {NoError, MacroEccCorrError} && Info.hw_digest && digest_o != data_mux && digest_o != '0) |=> state_q == ErrorSt && error_q == CheckFailError;\nendproperty\nassertion_consistency_check_fail_terminal: assert property(consistency_check_fail_terminal);"}
Running assertion checker tool on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv for otp_ctrl_part_buf with assertions: {'assertion_ecc_error_propagation': 'property ecc_error_propagation;\n  @(posedge clk_i) ecc_err |=> state_q == ErrorSt;\nendproperty\nassertion_ecc_error_propagation: assert property(ecc_error_propagation);', 'assertion_otp_error_propagation': 'property otp_error_propagation;\n  @(posedge clk_i) (state_q inside {InitWaitSt, CnstyReadWaitSt} && otp_rvalid_i && !(otp_err inside {NoError, MacroEccCorrError})) |=> state_q == ErrorSt;\nendproperty\nassertion_otp_error_propagation: assert property(otp_error_propagation);', 'assertion_escalation_terminal_state': 'property escalation_terminal_state;\n  @(posedge clk_i) lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) |=> state_q == ErrorSt;\nendproperty\nassertion_escalation_terminal_state: assert property(escalation_terminal_state);', 'assertion_counter_error_terminal_state': 'property counter_error_terminal_state;\n  @(posedge clk_i) cnt_err |=> state_q == ErrorSt;\nendproperty\nassertion_counter_error_terminal_state: assert property(counter_error_terminal_state);', 'assertion_error_state_lock': 'property error_state_lock;\n  @(posedge clk_i) (state_q == ErrorSt) |-> mubi8_test_true_strict(dout_locked_q);\nendproperty\nassertion_error_state_lock: assert property(error_state_lock);', 'assertion_integrity_check_fail_terminal': "property integrity_check_fail_terminal;\n  @(posedge clk_i) (state_q == IntegDigWaitSt && scrmbl_valid_i && digest_o != data_mux && digest_o != '0) |=> state_q == ErrorSt && error_q == CheckFailError;\nendproperty\nassertion_integrity_check_fail_terminal: assert property(integrity_check_fail_terminal);", 'assertion_consistency_check_fail_terminal': "property consistency_check_fail_terminal;\n  @(posedge clk_i) (state_q == CnstyReadWaitSt && otp_rvalid_i && otp_err inside {NoError, MacroEccCorrError} && Info.hw_digest && digest_o != data_mux && digest_o != '0) |=> state_q == ErrorSt && error_q == CheckFailError;\nendproperty\nassertion_consistency_check_fail_terminal: assert property(consistency_check_fail_terminal);"}
Running llm cwe checker agent on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv for otp_ctrl_part_buf with security objective: partition lock enforcement and error state handling
Running llm cwe details retriever tool on partition lock enforcement hardware security
Running llm cwe details retriever tool on hardware error state handling
Running llm cwe details retriever tool on hardware state machine security
Reading file with line numbers: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv
Running similar bug agent on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv for bug: dout_locked_d = MuBi8True;
Running similar bug tool on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv for bug: dout_locked_d = MuBi8True;
Reading file with line numbers: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv
Running similar bug tool on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv for bug: dout_locked_d = MuBi8True;
Running anomaly detector agent on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv for otp_ctrl_part_buf with security objective: partition lock enforcement and error state handling
Running llm cwe checker agent on /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv for otp_ctrl_part_buf with security objective: hardware state machine glitch attack
Running llm cwe details retriever tool on hardware state machine glitch attack
