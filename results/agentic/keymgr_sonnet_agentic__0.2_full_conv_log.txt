================================ System Message ================================


    You are a supervisor agent in a multi-agent system focused on identifying hardware security vulnerabilities in RTL code. 
    Your objective is to analyze the given SoC and generate a detailed security report.

    You have access to the following tools: ['run_anomaly_detector_agent', 'run_verilator_agent', 'run_llm_cwe_checker_agent', 'run_assertions_checker_agent', 'run_linter_agent', 'run_similar_bug_agent', 'list_dir', 'read_file', 'read_file_with_line_numbers']. Each tool specializes in a specific task:

    - Verilator Agent: Runs Verilator tests on the given IP and analyzes failing test reports to detect potential security issues.
    - Assertion Agent: Takes a Verilog file, a top module name, and a security aspect to check. It generates and runs security assertions on the RTL. Failing assertions indicate potential issues that require further localization.
    - Linter Agent: Accepts a Verilog file, top module, and security focus. It selects relevant lint checks and flags design violations tied to security concerns.
    - CWE Agent: Given a Verilog file, a top module, and a security aspect, this agent maps the RTL code to relevant CWEs and detects CWE-related vulnerabilities.
    - Similar Bug Agent: Accepts a file path and a line number (where a bug was found) to locate similar patterns or recurring bugs throughout the RTL code.

    Instructions for analysis:

    - Read the documentataion to identify security features and register interfaces policies.
    - Use Verilator, Assertion, Anomaly and Linter agents to uncover initial issues in the design.
    - If a bug is detected but not localized, use the CWE Agent to further inspect the related security aspect in the surrounding RTL.
    - After detecting any bugs, use the Similar Bug Agent to scan similar files (of the same or of different IPs) for similar vulnerabilities.

    Output Format:

    - For each identified issue, report:
    - File name
    - Line number(s)
    - Brief description of the issue
    - Security aspect affected
    - Tools used to identify the issue

    When your analysis is complete, end your response with "END".
    
================================ Human Message =================================

Identify security issues in the keymgr IP of the OpenTitan SoC, located at /home/XXXX-2/hackdate.

    - All IPs are located in the 'hw/ip' directory.
    - RTL code for each IP is located in its 'rtl' subdirectory, with source files having the '.sv' extension.
        - reg_top files contain the register interface for the IP.
        - control/fsm files contain the control logic for the IP.
        - core files contain the core logic for the IP.
    - Documentation files (.md) are located in the 'doc' directories of each IP.
        - theory_of_operation explains the properties of the IP and its security features.
        - registers.md files contain the register interface and its read/write access policies.
    - Ignore '.core' files; they are used by build tools and are not relevant for security analysis.

    Focus on the keymgr IP and make sure to analyze it thoroughly.

    First, identify the relevant security properties and read/write policies of the register interfaces from the documentation. 
    Then, use all available tools to perform a comprehensive security analysis on the RTL code.
    
================================== Ai Message ==================================
Tool Calls:
  list_dir (call_m5V0SfNLMPGqo5pBTL9zSX0h)
 Call ID: call_m5V0SfNLMPGqo5pBTL9zSX0h
  Args:
    dir_path: /home/XXXX-2/hackdate/hw/ip/keymgr
================================= Tool Message =================================
Name: list_dir

Files in /home/XXXX-2/hackdate/hw/ip/keymgr:
BUILD keymgr.core keymgr_pkg.core README.md

Directories in /home/XXXX-2/hackdate/hw/ip/keymgr:
data doc dv lint rtl syn
================================== Ai Message ==================================
Tool Calls:
  list_dir (call_vxYtnhWN7ezalUqFw9Snn2wY)
 Call ID: call_vxYtnhWN7ezalUqFw9Snn2wY
  Args:
    dir_path: /home/XXXX-2/hackdate/hw/ip/keymgr/doc
================================= Tool Message =================================
Name: list_dir

Files in /home/XXXX-2/hackdate/hw/ip/keymgr/doc:
checklist.md interfaces.md keymgr_block_diagram.svg keymgr_control_diagram.svg keymgr_functional_model.svg keymgr_kmac_if_diagram.svg programmers_guide.md registers.md theory_of_operation.md

Directories in /home/XXXX-2/hackdate/hw/ip/keymgr/doc:

================================== Ai Message ==================================
Tool Calls:
  read_file (call_tCwpJyfrFtJynH7XC9vCbjXz)
 Call ID: call_tCwpJyfrFtJynH7XC9vCbjXz
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/keymgr/doc/theory_of_operation.md
================================= Tool Message =================================
Name: read_file

# Theory of Operation

Key manager behavior can be summarized by the functional model below.

![Key Manager Functional Model](../doc/keymgr_functional_model.svg)

In the diagram, the red boxes represent the working state and the associated internal key, the black ovals represent derivation functions, the green squares represent software inputs, and the remaining green / purple shapes represent outputs to both software and hardware.

In OpenTitan, the derivation method selected is [KMAC](../../kmac/README.md).
Each valid operation involves a KMAC invocation using the key manager internal key and other HW / SW supplied inputs as data.
While KMAC can generate outputs of arbitrary length, this design fixes the size to 256b.

Effectively, the key manager behavior is divided into 3 classes of functions
*  Key manager state advancement
   *  The results are never visible to software and not directly usable by any software controlled hardware

*  Output key generation
   *  Results can be visible to software or consumed by hardware (sideload)

*  Identity / seed generation
   *  Results are always visible to software and used for asymmetric cryptography

In general, the key generation and seed generation functions are identical.
They differ only in how software chooses to deploy the outputs.

For clarity, all commands issued to the key manager by software are referred to as operations.
Transactions refer to the interaction between key manager and KMAC if a valid operation is issued.

## Key Manager State

The key manager working state (red boxes in the functional model) represents both the current state of the key manager as well as its related internal key.
Each valid state (`Initialized` / `CreatorRootKey` / `OwnerIntermediateKey` / `OwnerRootKey`), supplies its secret material as the "key" input to a KMAC operation.
Invalid states, such as `Reset / Disabled` on the other hand, either do not honor operation requests, or supplies random data when invoked.

The data input is dependent on each state, see below.

### Reset
To begin operation, the state must first transition to Initialize.
The advancement from `Reset` to `Initialized` is irreversible during the current power cycle.
Until the initialize command is invoked, the key manager rejects all other software commands.

### Initialized

When transitioning from `Reset` to `Initialized`, random values obtained from the entropy source are used to populate the internal key first.
Then the root key stored in OTP, if valid, is loaded into the internal key.
This ensures that the hamming delta from the previous value to the next value is non-deterministic.
The advancement from `Initialized` to `CreatorRootKey` is irreversible during the current power cycle.

### CreatorRootKey

`CreatorRootKey` is the first operational state of the key manager.
When transitioning from `Initialized` to this state, a KMAC operation is invoked using the `RootKey` as the key (from OTP), and the remaining inputs as data.
The output of the KMAC operation replaces the previous value of the internal key, and the new value becomes the `CreatorRootKey`.

Inputs to the derivation function are:
*  `DiversificationKey`: Secret seed from flash
*  `HealthMeasurement`: Current life cycle state
   *  To avoid a state value corresponding to each life cycle state, the raw life cycle value is not used.
   *  Instead, certain life cycle states diversify the same way.
   *  Please see the life cycle controller for more details.
*  `DeviceIdentifier`: Unique device identification.
*  `HardwareRevisionSecret`: A global design time constant.

Other than the `DiversificationKey` and `HardwareRevisionSecret`, none of the values above are considered secret.

Once the `CreatorRootKey` is reached, software can request key manager to advance state, generate output key or generate output identity.
The key used for all 3 functions is the `CreatorRootKey`.

The advancement from `CreatorRootKey` to the `OwnerIntermediateKey` is irreversible during the current power cycle.

Keymgr reads the root key from OTP in a single clock cycle. It assumes that when keymgr's internal FSM reaches to this clock cycle, OTP root key is already available (`valid` is set to 1). Otherwise, keymgr skips loading the root key.

### OwnerIntermediateKey

This is the second operational state of the key manager.
This state is reached through another invocation of the KMAC operation using the previous internal key, and other inputs as data.
The output of the KMAC operation replaces the previous value of the internal key, and the new value becomes the `OwnerIntermediateKey`.

The relevant data inputs are:
*  `OwnerRootSecret`: Secret seed from flash.
*  `SoftwareBinding`: A software programmed value representing the first owner code to be run.

Once the `OwnerIntermediateKey` is created, software can request key manager to advance state, generate output key or generate output identity.
The key used for all 3 functions is the `OwnerIntermediateKey`.

The advancement from `OwnerIntermediateKey` to the `OwnerRootKey` is irreversible during the current power cycle.

### OwnerRootKey

This is the last operational state of the key manager.
This state is reached through another invocation of the KMAC operation using the previous internal key, and other inputs as data.
The output of the KMAC operation replaces the previous value of the internal key, and the new value becomes the `OwnerRootKey`.

The relevant inputs are:
*   `SoftwareBinding` - A software programmed value representing the owner kernel code.

Once the `OwnerRootKey` is created, software can request key manager to advance state, generate output key or generate output identity.
An advance command invoked from `OwnerRootKey` state simply moves the state to `Disabled`.

The generate output and generate identity functions use `OwnerRootKey` as the KMAC key.
The advancement from `OwnerRootKey` to the `Disabled` is irreversible during the current power cycle.

### Disabled
`Disabled` is a state where the key manager is no longer operational.
Upon `Disabled` entry, the internal key is updated with KMAC computed random values; however, previously generated sideload key slots and software key slots are preserved.
This allows the software to keep the last valid keys while preventing the system from further advancing the valid key.

When advance and generate calls are invoked from this state, the outputs and keys are indiscriminately updated with randomly computed values.
Key manager enters disabled state based on direct invocation by software:
* Advance from `OwnerRootKey`
* Disable operation

### Invalid
`Invalid` state is entered whenever key manager is deactivated through the [life cycle connection](#life-cycle-connection) or when an operation encounters a [fault](#faults-and-operational-faults) .
Upon `Invalid` entry, the internal key, the sideload key slots and the software keys are all wiped with entropy directly.

#### Invalid Entry Wiping
Since the life cycle controller can deactivate the key manager at any time, the key manager attempts to gracefully handle the wiping process.
When deactivated, the key manager immediately begins wiping all keys (internal key, hardware sideload key, software key) with entropy.
However, if an operation was already ongoing, the key manager waits for the operation to complete gracefully before transitioning to invalid state.

While waiting for the operation to complete, the key manager continuously wipes all keys with entropy.

### Invalid and Disabled State

`Invalid` and `Disabled` states are functionally very similar.
The main difference between the two is "how" the states were reached and the entry behavior.

`Disabled` state is reached through intentional software commands where the sideload key slots and software key are not wiped, while `Invalid` state is reached through life cycle deactivation or operational faults where the internal key, sideload key slots and software key are wiped.

This also means that only `Invalid` is a terminal state.
If after entering `Disabled` life cycle is deactivated or a fault is encountered, the same [invalid entry procedure](#Invalid) is followed to bring the system to a terminal `Invalid` state.

If ever multiple conditions collide (a fault is detected at the same time software issues disable command), the `Invalid` entry path always takes precedence.

## Life Cycle Connection
The function of the key manager is directly managed by the [life cycle controller](../../lc_ctrl/README.md#key_manager_en).

Until the life cycle controller activates the key manager, the key manager does not accept any software commands.
Once the key manager is activated by the life cycle controller, it is then allowed to transition to the various states previously [described](#key-manager-states).

When the life cycle controller deactivates the key manager, the key manager transitions to the `Invalid` state.

## Commands in Each State
During each state, there are 3 valid commands software can issue:
*  Advance state
*  Output generation
*  Identity generation

The software is able to select a command and trigger the key manager FSM to process one of the commands.
If a command is valid during the current working state, it is processed and acknowledged when complete.

If a command is invalid, the behavior depends on the current state.
If the current state is `Reset`, the invalid command is immediately rejected as the key manager FSM has not yet been initialized.
If the current state is any other state, the key manager sequences random, dummy data to the KMAC module, but does not update internal key, sideload key slots or software keys.
For each valid command, a set of inputs are selected and sequenced to the KMAC module.

During `Disable` and `Invalid` states, the internal key, sideload key slots and software key are updated based on the input commands as with normal states.
There are however a few differences:
-  The updates are made regardless of any error status to ensure their values are further scrambled.
-  Instead of normal input data, random data is selected for KMAC processing.
-  All operations return an invalid operations error, in addition to any other error that might naturally occur.

## Generating Output Key
The generate output command is composed of 2 options
*  Generate output key for software, referred to as `generate-output-sw`
*  Generate output key for hardware, referred to as `generate-output-hw`

The hardware option is meant specifically for symmetric sideload use cases.
When this option is issued, the output of the KMAC invocation is not stored in software visible registers, but instead in hardware registers that directly output to symmetric primitives such as AES, KMAC and OTBN.

## KMAC Operations
All invoked KMAC operations expect the key in two shares.
This means the internal key, even though functionally 256b, is maintained as 512b.
The KMAC processed outputs are also in 2-shares.
For `generate-output-sw` commands, software is responsible for determining whether the key manager output should be preserved in shares or combined.

## Errors, Faults and Alerts

The key manager has two overall categories of errors:
* Recoverable errors
* Fatal errors

Recoverable errors are those likely to have been introduced by software and not fatal to the key manager or the system.
Fatal errors are logically impossible errors that have a high likelihood of being a fault and thus fatal.

Each category of error can be further divided into two:
* Synchronous errors
* Asynchronous errors

Synchronous errors happen only during a key manager operation.
Asynchronous errors can happen at any time.

Given the above, we have 4 total categories of errors:
* Synchronous recoverable errors
* Asynchronous recoverable errors
* Synchronous fatal errors
* Asynchronous fatal errors

All recoverable errors (synchronous and asynchronous) are captured in [`ERR_CODE`](registers.md#err_code).
All fatal errors (synchronous and asynchronous) are captured in [`FAULT_STATUS`](registers.md#fault_status).

Recoverable errors cause a recoverable alert to be sent from the key manager.
Fatal errors cause a fatal alert to be sent from the key manager.

Below, the behavior of each category and its constituent errors are described in detail.

### Synchronous Recoverable Errors

These errors can only happen when a key manager operation is invoked and are typically associated with incorrect software programming.
At the end of the operation, key manager reports whether there was an error in [`ERR_CODE`](registers.md#err_code) and sends a recoverable alert.

* [`ERR_CODE.INVALID_OP`](registers.md#err_code) Software issued an invalid operation given the current key manager state.
* [`ERR_CODE.INVALID_KMAC_INPUT`](registers.md#err_code) Software supplied invalid input (for example a key greater than the max version) for a key manager operation.

### Asynchronous Recoverable Errors

These errors can happen at any time regardless of whether there is a key manager operation.
The error is reported in [`ERR_CODE`](registers.md#err_code) and the key manager sends a recoverable alert.

* [`ERR_CODE.INVALID_SHADOW_UPDATE`](registers.md#err_code) Software performed an invalid sequence while trying to update a key manager shadow register.

### Synchronous Fatal Errors

These errors can only happen when a key manager operation is invoked and receives malformed operation results that are not logically possible.
At the end of the operation, key manager reports whether there was an error in [`FAULT_STATUS`](registers.md#fault_status) and continuously sends fatal alerts .

Note, these errors are synchronous from the perspective of the key manager, but they may be asynchronous from the perspective of another module.

### Asynchronous Fatal Errors

These errors can happen at any time regardless of whether there is a key manager operation.
The error is reported in [`FAULT_STATUS`](registers.md#fault_status) and the key manager continuously sends fatal alerts.


### Faults and Operational Faults

When a fatal error is encountered, the key manager transitions to the `Invalid` [state](#invalid-entry-wiping).
The following are a few examples of when the error occurs and how the key manager behaves.

#### Example 1: Fault During Initialization
The key manager is in the `Reset` state and receives an advance operation.
After it has reseeded its internal PRNG with entropy, it will try to load the Creator Root Key from OTP.
If not both shares of the Creator Root Key are valid at that point, key manager will wipe its secrets and transition to the `Invalid` state.

#### Example 2: Fault During Operation
The key manager is running a generate operation and a non-onehot command was observed by the KMAC interface.
Since the non-onehot condition is a fault, it is reflected in [`FAULT_STATUS`](registers.md#fault_status) and a fatal alert is generated.
The key manager transitions to `Invalid` state, wipes internal storage and reports an invalid operation in [`ERR_CODE.INVALID_OP`](registers.md#err_code).

#### Example 3: Fault During Idle
The key manager is NOT running an operation and is idle.
During this time, a fault is observed on the regfile (shadow storage error) and FSM (control FSM integrity error).
The faults are reflected in [`FAULT_STATUS`](registers.md#fault_status).
The key manager transitions to `Invalid` state, wipes internal storage but does not report an invalid operation.

#### Example 4: Operation after Fault Detection
Continuing from the example above, the key manager now begins an operation.
Since the key manager is already in `Invalid` state, it does not wipe internal storage and reports an invalid operation in [`ERR_CODE.INVALID_OP`](registers.md#err_code).

#### Additional Details on Invalid Input

What is considered invalid input changes based on current state and operation.

When an advance operation is invoked:
- The internal key is checked for all 0's and all 1's.
- During the `Reset` state, both shares of the the Creator Root Key provided by OTP are checked to be valid.
- During `Initialized` state, creator seed, device ID and health state data is checked for all 0's and all 1's.
- During `CreatorRootKey` state, the owner seed is checked for all 0's and all 1's.
- During all other states, nothing is explicitly checked.

When a generate output key operation is invoked:
- The internal key is checked for all 0's and all 1's.
- The key version is less than or equal to the max key version.

When a generate output identity is invoked:
- The internal key is checked for all 0's and all 1's.

#### Invalid Operation

The table below enumerates the legal operations in a given state.
When an illegal operation is supplied, the error code is updated and the operation is flagged as `done with error`.

| Current State    | Legal Operations               |
| -------------    | ------------------------------ |
| Reset            | Advance                        |
| Initialized      | Disable / Advance              |
| CreatorRootKey   | Disable / Advance / Generate   |
| OwnerIntKey      | Disable / Advance / Generate   |
| OwnerRootKey     | Disable / Advance / Generate   |
| Invalid/Disabled | None                           |

*  All operations invoked during `Invalid` and `Disabled` states lead to invalid operation error.

### Error Response
In addition to alerts and interrupts, key manager may also update the internal key and relevant outputs based on current state.
See the tables below for an enumeration.

| Current State    | Invalid States  | Invalid Output | Invalid Input | Invalid Operation   |
| -------------    | ----------------| ---------------|---------------|---------------------|
| Reset            | Not Possible    | Not Possible   | Not possible  | Not updated         |
| Initialized      | Updated         | Updated        | Not updated   | Not updated         |
| CreatorRootKey   | Updated         | Updated        | Not updated   | Not possible        |
| OwnerIntKey      | Updated         | Updated        | Not updated   | Not possible        |
| OwnerRootKey     | Updated         | Updated        | Not updated   | Not possible        |
| Invalid/Disabled | Updated         | Updated        | Updated       | Updated             |

*  During `Reset` state, the KMAC module is never invoked, thus certain errors are not possible.
*  During `Initialized`, `CreatorRootKey`, `OwnerIntermediateKey` and `OwnerRootKey` states, a fault error causes the relevant key / outputs to be updated; however an operational error does not.
*  During `Invalid` and `Disabled` states, the relevant key / outputs are updated regardless of the error.
*  Only the relevant collateral is updated -> ie, advance / disable command leads to working key update, and generate command leads to software or sideload key update.
*  During `Disabled` state, if life cycle deactivation or an operational fault is encountered, the key manager transitions to `Invalid` state, see [here](#invalid-and-disabled-state)

## DICE Support

The key manager supports [DICE open profile](XXXX).
Specifically, the open profile has two compound device identifiers.
* Attestation CDI
* Sealing CDI

The attestation CDI is used to attest hardware and software configuration and is thus expected to change between updates.
The sealing CDI on the other hand, is used to attest the authority of the hardware and software configuration.
The sealing version is thus expected to remain stable across software updates.

To support these features, the key manager maintains two versions of the working state and associated internal key.
There is one version for attestation and one version for sealing.

The main difference between the two CDIs is the different usage of `SW_BINDING`.
For the Sealing CDI, the [`"SEALING_SW_BINDING"`](registers.md#sealing_sw_binding) is used, all other inputs are the same.
For the Attestation CDI, the [`"ATTEST_SW_BINDING"`](registers.md#attest_sw_binding) is used, all other inputs are the same.

When invoking an advance operation, both versions are advanced, one after the other.
There are thus two KMAC transactions.
The first transaction uses the Sealing CDI internal key, [`"SEALING_SW_BINDING"`](registers.md#sealing_sw_binding) and other common inputs.
The second transaction uses the Attestation CDI internal key, [`"ATTEST_SW_BINDING"`](registers.md#attest_sw_binding) and other common inputs.

When invoking a generate operation, the software must specify which CDI to use as the source key.
This is done through [`"CONTROL.CDI_SEL"`](registers.md#control).
Unlike the advance operation, there is only 1 KMAC transaction since we pick a specific CDI to operate.

When disabling, both versions are disabled together.


## Block Diagram
The following is a high level block diagram of the key manager.

![Key Manager Block Diagram](../doc/keymgr_block_diagram.svg)

## Design Details

Key manager is primarily composed of two components:
*  keymgr_ctrl
*  keymgr_kmac_if

### Key Manager Control

The key manager control block manages the working state, sideload key updates, as well as what commands are valid in each state.
It also handles the life cycle `keymgr_en` input, which deactivates the entire key manager function in the event of an escalation.

![Key Manager Control Block Diagram](../doc/keymgr_control_diagram.svg)


### KMAC Interface Control

The KMAC interface control represents the bulk of key manager logic.
Based on input from key manager control, this module selects the inputs for each given command and sequences the data to KMAC.

![Key Manager KMAC Interface Block Diagram](../doc/keymgr_kmac_if_diagram.svg)

The KMAC interface works on a simple `valid / ready` protocol.
When there is data to send, the KMAC interface sends out a `valid` and keeps it active.
When the destination accepts the transaction, the `ready` is asserted.
Note just like with any bus interface, the `ready` may already be asserted when `valid` asserts, or it may assert some time later, there are no restrictions.
Since the data to be sent is always pre-buffered in key manager, the valid, once asserted, does not de-assert until the entire transaction is complete.

The data interface itself is 64b wide.
However, there may not always be 64b multiple aligned data to be sent.
In these situations, the last transfer beat sent to KMAC has a byte mask / strobe attached.
The byte mask indicates on the last beat which bytes are actually valid, and which are not.
Not beats prior to the last always have fully asserted byte masks.

Once KMAC receives all the required data and the last indication, it begins processing the data into a digest.
This process may take an arbitrary number of cycles.
When this process is complete, a `done` indication pulse is sent back with the digest.
Note, the acceptance of `done` has no back-pressure and `keymgr` must accept it within one cycle.

See diagram below for an example transfer:

```wavejson
{signal: [
  {name: 'kmac_data_o.valid',     wave: '01...........|....0..'},
  {name: 'kmac_data_i.ready',     wave: '1...0..101...|.......'},
  {name: 'kmac_data_o.data',      wave: 'x2222...2.222|2222x..'},
  {name: 'kmac_data_o.last',      wave: '0................10..'},
  {name: 'kmac_data_o.strb',      wave: 'x2...............2x..'},
  {name: 'kmac_data_i.done',      wave: '0..................10'},
  {name: 'kmac_data_i.digest*',   wave: 'x..................3x'},
  ],
}
```

### Sideload Keys

There are three sideload keys.
One for AES, one for KMAC and one for OTBN.
When a sideload key is generated successfully through the `generate-output-hw` command, the derived data is loaded into key storage registers.
There is a set of storage registers for each destination.

The KMAC key however is further overloaded as it is the main derivation mechanism for key manager internal stage.
The KMAC key thus has two possible outputs, one is the sideload key, and the other is internal state key.

When a valid operation is called, the internal state key is sent over the KMAC key.
During all other times, the sideloaded value is presented.
Note, there may not be a valid key in the sideload register if it has been cleared or never generated.
The sideload key can be overwritten with another generate command, or cleared with entropy through [`SIDELOAD_CLEAR`](registers.md#sideload_clear).

The clearing can be done one slot at a time, or all at once.
Once a clearing bit is enabled for a particular key slot, its value is continuously re-randomized every clock cycle.
Therefore, SW is responsible for toggling this bit back to disabled state, which makes the last random value remain stable on the sideload slot.
Otherwise, the sideload key slot is continuously randomized which prevents sideloading an actual key to the target HWIP.

The following diagram illustrates an example when there is no valid key in the KMAC sideload registers and an operation is called.
During the duration of the operation, the key is valid and shows the internal key state.
Once the operation is complete, it falls back to the sideload key state, which is invalid in this case.

```wavejson
{signal: [
  {name: 'u_sideload_ctrl.u_kmac_key.key_o.valid',     wave: '0................'},
  {name: 'u_sideload_ctrl.u_kmac_key.key_o.key_share', wave: 'x................'},
  {name: 'u_ctrl.key_o.valid',                         wave: '0................'},
  {name: 'u_ctrl.key_o.key_share',                     wave: 'x................'},
  {name: 'u_ctrl.op_start_i',                          wave: '0....1.....0.....'},
  {name: 'kmac_key_o.valid',                           wave: '0....1.....0.....'},
  {name: 'kmac_key_o.key_share*',                      wave: 'x....3.....x.....'},
  ],
}
```

The following diagram illustrates an example when there is a valid key in the KMAC sideload registers and an operation is called.
During the duration of the operation, the key is valid and shows the internal key state.
Once the operation is complete, it falls back to the sideload key state, which is valid and contains a different value.

```wavejson
{signal: [
  {name: 'u_sideload_ctrl.u_kmac_key.key_o.valid',     wave: '01...............'},
  {name: 'u_sideload_ctrl.u_kmac_key.key_o.key_share', wave: 'x4...............'},
  {name: 'u_ctrl.key_o.valid',                         wave: '0....1.....0.....'},
  {name: 'u_ctrl.key_o.key_share',                     wave: 'x................'},
  {name: 'u_ctrl.op_start_i',                          wave: '0....1.....0.....'},
  {name: 'kmac_key_o.valid',                           wave: '01...............'},
  {name: 'kmac_key_o.key_share*',                      wave: 'x4...3.....4.....'},
  ],
}
```


### Software Binding

The identities flow employs an idea called [software binding](XXXX) to ensure that a particular key derivation scheme is only reproducible for a given software configuration.
The binding is created through the secure boot flow, where each stage sets the binding used for the next verified stage before advancing to it.
The software binding is used during the following state transitions only:
-  `Initialized` to `CreatorRootKey`
-  `CreatorRootKey` to `OwnerIntermedaiteKey`
-  `OwnerIntermediateKey` to `OwnerRootKey`

In order to save on storage and not have a duplicate copy per stage, the software binding registers [`SOFTWARE_BINDING`](registers.md#software_binding) are shared between key manager stages.

Software sets the appropriate values and locks it by clearing [`SOFT_BINDING_EN`](registers.md#soft_binding_en).
When later a successful `advance` call is made, the key manager then unlocks by setting [`SOFT_BINDING_EN`](registers.md#soft_binding_en) to 1.
An unsuccessful advance call (errors) does not unlock the binding.
This allows the next stage of software to re-use the binding registers.

### Custom Security Checks

The keymgr has several custom security checks.

#### One-Hot Command Check
The command received by the KMAC interface must always be in one-hot form and unchanging during the life time of a KMAC transaction.
If this check fails, an error is reflected in [`FAULT_STATUS.CMD`](registers.md#fault_status).

#### Unexpected KMAC Done
The `kmac_done` signal can only happen during the expected transaction window.
If this check fails, an error is reflected in [`FAULT_STATUS.KMAC_DONE`](registers.md#fault_status).

#### Control State Machine Check
This error checks for two things:
-  The key manager can advance to one of the key states (e.g. RootKey, OwnerIntermediateKey) only when there is a legal advanced operation.
-  The key manager can issue an advance or generate operation to the KMAC interface only if the original software request is an advanced or generate command.

If these checks fail, an error is reflected in [`FAULT_STATUS.CTRL_FSM_CHK`](registers.md#fault_status).

#### Sideload Select Check
A sideload key slot is selected for update only if the original software request targeted that key slot.

If this check fails, an error is reflected in [`FAULT_STATUS.SIDE_CTRL_SEL`](registers.md#fault_status).

================================== Ai Message ==================================
Tool Calls:
  read_file (call_uGhIxJn7hO6GzxfVs177rfGh)
 Call ID: call_uGhIxJn7hO6GzxfVs177rfGh
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/keymgr/doc/registers.md
================================= Tool Message =================================
Name: read_file

# Registers

<!-- BEGIN CMDGEN util/regtool.py -d ./hw/ip/keymgr/data/keymgr.hjson -->
## Summary

| Name                                                                       | Offset   |   Length | Description                                                                |
|:---------------------------------------------------------------------------|:---------|---------:|:---------------------------------------------------------------------------|
| keymgr.[`INTR_STATE`](#intr_state)                                         | 0x0      |        4 | Interrupt State Register                                                   |
| keymgr.[`INTR_ENABLE`](#intr_enable)                                       | 0x4      |        4 | Interrupt Enable Register                                                  |
| keymgr.[`INTR_TEST`](#intr_test)                                           | 0x8      |        4 | Interrupt Test Register                                                    |
| keymgr.[`ALERT_TEST`](#alert_test)                                         | 0xc      |        4 | Alert Test Register                                                        |
| keymgr.[`CFG_REGWEN`](#cfg_regwen)                                         | 0x10     |        4 | Key manager configuration enable                                           |
| keymgr.[`START`](#start)                                                   | 0x14     |        4 | Key manager operation start                                                |
| keymgr.[`CONTROL_SHADOWED`](#control_shadowed)                             | 0x18     |        4 | Key manager operation controls                                             |
| keymgr.[`SIDELOAD_CLEAR`](#sideload_clear)                                 | 0x1c     |        4 | sideload key slots clear                                                   |
| keymgr.[`RESEED_INTERVAL_REGWEN`](#reseed_interval_regwen)                 | 0x20     |        4 | regwen for reseed interval                                                 |
| keymgr.[`RESEED_INTERVAL_SHADOWED`](#reseed_interval_shadowed)             | 0x24     |        4 | Reseed interval for key manager entropy reseed                             |
| keymgr.[`SW_BINDING_REGWEN`](#sw_binding_regwen)                           | 0x28     |        4 | Register write enable for SOFTWARE_BINDING                                 |
| keymgr.[`SEALING_SW_BINDING_0`](#sealing_sw_binding)                       | 0x2c     |        4 | Software binding input to sealing portion of the key manager.              |
| keymgr.[`SEALING_SW_BINDING_1`](#sealing_sw_binding)                       | 0x30     |        4 | Software binding input to sealing portion of the key manager.              |
| keymgr.[`SEALING_SW_BINDING_2`](#sealing_sw_binding)                       | 0x34     |        4 | Software binding input to sealing portion of the key manager.              |
| keymgr.[`SEALING_SW_BINDING_3`](#sealing_sw_binding)                       | 0x38     |        4 | Software binding input to sealing portion of the key manager.              |
| keymgr.[`SEALING_SW_BINDING_4`](#sealing_sw_binding)                       | 0x3c     |        4 | Software binding input to sealing portion of the key manager.              |
| keymgr.[`SEALING_SW_BINDING_5`](#sealing_sw_binding)                       | 0x40     |        4 | Software binding input to sealing portion of the key manager.              |
| keymgr.[`SEALING_SW_BINDING_6`](#sealing_sw_binding)                       | 0x44     |        4 | Software binding input to sealing portion of the key manager.              |
| keymgr.[`SEALING_SW_BINDING_7`](#sealing_sw_binding)                       | 0x48     |        4 | Software binding input to sealing portion of the key manager.              |
| keymgr.[`ATTEST_SW_BINDING_0`](#attest_sw_binding)                         | 0x4c     |        4 | Software binding input to the attestation portion of the key manager.      |
| keymgr.[`ATTEST_SW_BINDING_1`](#attest_sw_binding)                         | 0x50     |        4 | Software binding input to the attestation portion of the key manager.      |
| keymgr.[`ATTEST_SW_BINDING_2`](#attest_sw_binding)                         | 0x54     |        4 | Software binding input to the attestation portion of the key manager.      |
| keymgr.[`ATTEST_SW_BINDING_3`](#attest_sw_binding)                         | 0x58     |        4 | Software binding input to the attestation portion of the key manager.      |
| keymgr.[`ATTEST_SW_BINDING_4`](#attest_sw_binding)                         | 0x5c     |        4 | Software binding input to the attestation portion of the key manager.      |
| keymgr.[`ATTEST_SW_BINDING_5`](#attest_sw_binding)                         | 0x60     |        4 | Software binding input to the attestation portion of the key manager.      |
| keymgr.[`ATTEST_SW_BINDING_6`](#attest_sw_binding)                         | 0x64     |        4 | Software binding input to the attestation portion of the key manager.      |
| keymgr.[`ATTEST_SW_BINDING_7`](#attest_sw_binding)                         | 0x68     |        4 | Software binding input to the attestation portion of the key manager.      |
| keymgr.[`Salt_0`](#salt)                                                   | 0x6c     |        4 | Salt value used as part of output generation                               |
| keymgr.[`Salt_1`](#salt)                                                   | 0x70     |        4 | Salt value used as part of output generation                               |
| keymgr.[`Salt_2`](#salt)                                                   | 0x74     |        4 | Salt value used as part of output generation                               |
| keymgr.[`Salt_3`](#salt)                                                   | 0x78     |        4 | Salt value used as part of output generation                               |
| keymgr.[`Salt_4`](#salt)                                                   | 0x7c     |        4 | Salt value used as part of output generation                               |
| keymgr.[`Salt_5`](#salt)                                                   | 0x80     |        4 | Salt value used as part of output generation                               |
| keymgr.[`Salt_6`](#salt)                                                   | 0x84     |        4 | Salt value used as part of output generation                               |
| keymgr.[`Salt_7`](#salt)                                                   | 0x88     |        4 | Salt value used as part of output generation                               |
| keymgr.[`KEY_VERSION`](#key_version)                                       | 0x8c     |        4 | Version used as part of output generation                                  |
| keymgr.[`MAX_CREATOR_KEY_VER_REGWEN`](#max_creator_key_ver_regwen)         | 0x90     |        4 | Register write enable for MAX_CREATOR_KEY_VERSION                          |
| keymgr.[`MAX_CREATOR_KEY_VER_SHADOWED`](#max_creator_key_ver_shadowed)     | 0x94     |        4 | Max creator key version                                                    |
| keymgr.[`MAX_OWNER_INT_KEY_VER_REGWEN`](#max_owner_int_key_ver_regwen)     | 0x98     |        4 | Register write enable for MAX_OWNER_INT_KEY_VERSION                        |
| keymgr.[`MAX_OWNER_INT_KEY_VER_SHADOWED`](#max_owner_int_key_ver_shadowed) | 0x9c     |        4 | Max owner intermediate key version                                         |
| keymgr.[`MAX_OWNER_KEY_VER_REGWEN`](#max_owner_key_ver_regwen)             | 0xa0     |        4 | Register write enable for MAX_OWNER_KEY_VERSION                            |
| keymgr.[`MAX_OWNER_KEY_VER_SHADOWED`](#max_owner_key_ver_shadowed)         | 0xa4     |        4 | Max owner key version                                                      |
| keymgr.[`SW_SHARE0_OUTPUT_0`](#sw_share0_output)                           | 0xa8     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE0_OUTPUT_1`](#sw_share0_output)                           | 0xac     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE0_OUTPUT_2`](#sw_share0_output)                           | 0xb0     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE0_OUTPUT_3`](#sw_share0_output)                           | 0xb4     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE0_OUTPUT_4`](#sw_share0_output)                           | 0xb8     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE0_OUTPUT_5`](#sw_share0_output)                           | 0xbc     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE0_OUTPUT_6`](#sw_share0_output)                           | 0xc0     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE0_OUTPUT_7`](#sw_share0_output)                           | 0xc4     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE1_OUTPUT_0`](#sw_share1_output)                           | 0xc8     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE1_OUTPUT_1`](#sw_share1_output)                           | 0xcc     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE1_OUTPUT_2`](#sw_share1_output)                           | 0xd0     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE1_OUTPUT_3`](#sw_share1_output)                           | 0xd4     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE1_OUTPUT_4`](#sw_share1_output)                           | 0xd8     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE1_OUTPUT_5`](#sw_share1_output)                           | 0xdc     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE1_OUTPUT_6`](#sw_share1_output)                           | 0xe0     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE1_OUTPUT_7`](#sw_share1_output)                           | 0xe4     |        4 | Key manager software output.                                               |
| keymgr.[`WORKING_STATE`](#working_state)                                   | 0xe8     |        4 | Key manager working state.                                                 |
| keymgr.[`OP_STATUS`](#op_status)                                           | 0xec     |        4 | Key manager status.                                                        |
| keymgr.[`ERR_CODE`](#err_code)                                             | 0xf0     |        4 | Key manager error code.                                                    |
| keymgr.[`FAULT_STATUS`](#fault_status)                                     | 0xf4     |        4 | This register represents both synchronous and asynchronous fatal faults.   |
| keymgr.[`DEBUG`](#debug)                                                   | 0xf8     |        4 | The register holds some debug information that may be convenient if keymgr |

## INTR_STATE
Interrupt State Register
- Offset: `0x0`
- Reset default: `0x0`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "op_done", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 90}}
```

|  Bits  |  Type  |  Reset  | Name    | Description        |
|:------:|:------:|:-------:|:--------|:-------------------|
|  31:1  |        |         |         | Reserved           |
|   0    |  rw1c  |   0x0   | op_done | Operation complete |

## INTR_ENABLE
Interrupt Enable Register
- Offset: `0x4`
- Reset default: `0x0`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "op_done", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 90}}
```

|  Bits  |  Type  |  Reset  | Name    | Description                                                       |
|:------:|:------:|:-------:|:--------|:------------------------------------------------------------------|
|  31:1  |        |         |         | Reserved                                                          |
|   0    |   rw   |   0x0   | op_done | Enable interrupt when [`INTR_STATE.op_done`](#intr_state) is set. |

## INTR_TEST
Interrupt Test Register
- Offset: `0x8`
- Reset default: `0x0`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "op_done", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 90}}
```

|  Bits  |  Type  |  Reset  | Name    | Description                                                |
|:------:|:------:|:-------:|:--------|:-----------------------------------------------------------|
|  31:1  |        |         |         | Reserved                                                   |
|   0    |   wo   |   0x0   | op_done | Write 1 to force [`INTR_STATE.op_done`](#intr_state) to 1. |

## ALERT_TEST
Alert Test Register
- Offset: `0xc`
- Reset default: `0x0`
- Reset mask: `0x3`

### Fields

```wavejson
{"reg": [{"name": "recov_operation_err", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "fatal_fault_err", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 30}], "config": {"lanes": 1, "fontsize": 10, "vspace": 210}}
```

|  Bits  |  Type  |  Reset  | Name                | Description                                      |
|:------:|:------:|:-------:|:--------------------|:-------------------------------------------------|
|  31:2  |        |         |                     | Reserved                                         |
|   1    |   wo   |   0x0   | fatal_fault_err     | Write 1 to trigger one alert event of this kind. |
|   0    |   wo   |   0x0   | recov_operation_err | Write 1 to trigger one alert event of this kind. |

## CFG_REGWEN
Key manager configuration enable
- Offset: `0x10`
- Reset default: `0x1`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "EN", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                                                                                                                                                                   |
|:------:|:------:|:-------:|:-------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  31:1  |        |         |        | Reserved                                                                                                                                                                      |
|   0    |   ro   |   0x1   | EN     | key manager configuration enable. When key manager operation is started (see CONTROL), registers protected by this EN are no longer modifiable until the operation completes. |

## START
Key manager operation start
- Offset: `0x14`
- Reset default: `0x0`
- Reset mask: `0x1`
- Register enable: [`CFG_REGWEN`](#cfg_regwen)

### Fields

```wavejson
{"reg": [{"name": "EN", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name             |
|:------:|:------:|:-------:|:-----------------|
|  31:1  |        |         | Reserved         |
|   0    |   rw   |   0x0   | [EN](#start--en) |

### START . EN
Start key manager operations

| Value   | Name        | Description                                                                                             |
|:--------|:------------|:--------------------------------------------------------------------------------------------------------|
| 0x1     | Valid state | To trigger a start, this value must be programmed.  All other values are considered no operation start. |

Other values are reserved.

## CONTROL_SHADOWED
Key manager operation controls
- Offset: `0x18`
- Reset default: `0x10`
- Reset mask: `0x30f0`
- Register enable: [`CFG_REGWEN`](#cfg_regwen)

### Fields

```wavejson
{"reg": [{"bits": 4}, {"name": "OPERATION", "bits": 3, "attr": ["rw"], "rotate": -90}, {"name": "CDI_SEL", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 4}, {"name": "DEST_SEL", "bits": 2, "attr": ["rw"], "rotate": -90}, {"bits": 18}], "config": {"lanes": 1, "fontsize": 10, "vspace": 110}}
```

|  Bits  |  Type  |  Reset  | Name                                      |
|:------:|:------:|:-------:|:------------------------------------------|
| 31:14  |        |         | Reserved                                  |
| 13:12  |   rw   |   0x0   | [DEST_SEL](#control_shadowed--dest_sel)   |
|  11:8  |        |         | Reserved                                  |
|   7    |   rw   |   0x0   | [CDI_SEL](#control_shadowed--cdi_sel)     |
|  6:4   |   rw   |   0x1   | [OPERATION](#control_shadowed--operation) |
|  3:0   |        |         | Reserved                                  |

### CONTROL_SHADOWED . DEST_SEL
When the OPERATION field is programmed to generate output, this field selects
the appropriate crypto cipher target.

This field should be programmed for both hw / sw generation, as this helps diverisifies the output.

| Value   | Name   | Description                                                                                                                                                                                                                                                                                                                                   |
|:--------|:-------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0x0     | None   | No target selected                                                                                                                                                                                                                                                                                                                            |
| 0x1     | AES    | AES selected                                                                                                                                                                                                                                                                                                                                  |
| 0x2     | KMAC   | KMAC selected                                                                                                                                                                                                                                                                                                                                 |
| 0x3     | OTBN   | OTBN selected.  Note for OTBN hardware operations, the generated output is 384-bits, while for all other operations (including OTBN software), it is 256-bits. Generating a hardware 384-bit seed directly for OTBN sideload reduces some of the OTBN code burden for entropy expansion. When generating for software, this is not a concern. |


### CONTROL_SHADOWED . CDI_SEL
When the OPERATION field is programmed to generate output, this field selects
the appropriate CDI to use.

This field should be programmed for both hw / sw generation.

| Value   | Name            | Description                 |
|:--------|:----------------|:----------------------------|
| 0x0     | Sealing CDI     | Sealing CDI is selected     |
| 0x1     | Attestation CDI | Attestation CDI is selected |


### CONTROL_SHADOWED . OPERATION
Key manager operation selection. All values not enumerated below behave the same as disable

| Value   | Name               | Description                                                                                                                                                                          |
|:--------|:-------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0x0     | Advance            | Advance key manager state. Advances key manager to the next stage. If key manager is already at last functional state, the advance operation is equivalent to the disable operation. |
| 0x1     | Generate ID        | Generates an identity seed from the current state.                                                                                                                                   |
| 0x2     | Generate SW Output | Generates a key manager output that is visible to software from the current state.                                                                                                   |
| 0x3     | Generate HW Output | Generates a key manager output that is visible only to hardware crypto blocks.                                                                                                       |
| 0x4     | Disable            | Disables key manager operation and moves it to the disabled state. Note the disabled state is terminal and cannot be recovered without a reset.                                      |

Other values are reserved.

## SIDELOAD_CLEAR
sideload key slots clear
- Offset: `0x1c`
- Reset default: `0x0`
- Reset mask: `0x7`
- Register enable: [`CFG_REGWEN`](#cfg_regwen)

### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 3, "attr": ["rw"], "rotate": 0}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                        |
|:------:|:------:|:-------:|:----------------------------|
|  31:3  |        |         | Reserved                    |
|  2:0   |   rw   |   0x0   | [VAL](#sideload_clear--val) |

### SIDELOAD_CLEAR . VAL
Depending on the value programmed, a different sideload key slot is cleared.
If the value programmed is not one of the enumerated values below, ALL sideload
key slots are continuously cleared. In order to stop continuous clearing, SW should
toggle the clear bit again (i.e. disable continuous clearing).

| Value   | Name   | Description                                                 |
|:--------|:-------|:------------------------------------------------------------|
| 0x0     | None   | No sideload keys cleared.                                   |
| 0x1     | AES    | The AES sideload key is continuously cleared with entropy.  |
| 0x2     | KMAC   | The KMAC sideload key is continuously cleared with entropy. |
| 0x3     | OTBN   | The OTBN sideload key is continuously cleared with entropy. |

Other values are reserved.

## RESEED_INTERVAL_REGWEN
regwen for reseed interval
- Offset: `0x20`
- Reset default: `0x1`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "EN", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                              |
|:------:|:------:|:-------:|:-------|:-----------------------------------------|
|  31:1  |        |         |        | Reserved                                 |
|   0    |  rw0c  |   0x1   | EN     | Configuration enable for reseed interval |

## RESEED_INTERVAL_SHADOWED
Reseed interval for key manager entropy reseed
- Offset: `0x24`
- Reset default: `0x100`
- Reset mask: `0xffff`
- Register enable: [`RESEED_INTERVAL_REGWEN`](#reseed_interval_regwen)

### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 16, "attr": ["rw"], "rotate": 0}, {"bits": 16}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                                                   |
|:------:|:------:|:-------:|:-------|:--------------------------------------------------------------|
| 31:16  |        |         |        | Reserved                                                      |
|  15:0  |   rw   |  0x100  | VAL    | Number of internal PRNG updates before a reseed is requested. |

## SW_BINDING_REGWEN
Register write enable for SOFTWARE_BINDING
- Offset: `0x28`
- Reset default: `0x1`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "EN", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                                                                                                                                                                                                                            |
|:------:|:------:|:-------:|:-------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  31:1  |        |         |        | Reserved                                                                                                                                                                                                                               |
|   0    |  rw0c  |   0x1   | EN     | Software binding register write enable. This is locked by software and unlocked by hardware upon a successful advance call. Software binding resets to 1, and its value cannot be altered by software until advancement to Init state. |

## SEALING_SW_BINDING
Software binding input to sealing portion of the key manager.
This register is lockable and shared between key manager stages.
This binding value is not considered secret, however its integrity is very important.

The software binding is locked by software and unlocked by hardware upon a successful advance operation.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name                 | Offset   |
|:---------------------|:---------|
| SEALING_SW_BINDING_0 | 0x2c     |
| SEALING_SW_BINDING_1 | 0x30     |
| SEALING_SW_BINDING_2 | 0x34     |
| SEALING_SW_BINDING_3 | 0x38     |
| SEALING_SW_BINDING_4 | 0x3c     |
| SEALING_SW_BINDING_5 | 0x40     |
| SEALING_SW_BINDING_6 | 0x44     |
| SEALING_SW_BINDING_7 | 0x48     |


### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description            |
|:------:|:------:|:-------:|:-------|:-----------------------|
|  31:0  |   rw   |   0x0   | VAL    | Software binding value |

## ATTEST_SW_BINDING
Software binding input to the attestation portion of the key manager.
This register is lockable and shared between key manager stages.
This binding value is not considered secret, however its integrity is very important.

The software binding is locked by software and unlocked by hardware upon a successful advance operation.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name                | Offset   |
|:--------------------|:---------|
| ATTEST_SW_BINDING_0 | 0x4c     |
| ATTEST_SW_BINDING_1 | 0x50     |
| ATTEST_SW_BINDING_2 | 0x54     |
| ATTEST_SW_BINDING_3 | 0x58     |
| ATTEST_SW_BINDING_4 | 0x5c     |
| ATTEST_SW_BINDING_5 | 0x60     |
| ATTEST_SW_BINDING_6 | 0x64     |
| ATTEST_SW_BINDING_7 | 0x68     |


### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description            |
|:------:|:------:|:-------:|:-------|:-----------------------|
|  31:0  |   rw   |   0x0   | VAL    | Software binding value |

## Salt
Salt value used as part of output generation
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name   | Offset   |
|:-------|:---------|
| Salt_0 | 0x6c     |
| Salt_1 | 0x70     |
| Salt_2 | 0x74     |
| Salt_3 | 0x78     |
| Salt_4 | 0x7c     |
| Salt_5 | 0x80     |
| Salt_6 | 0x84     |
| Salt_7 | 0x88     |


### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description   |
|:------:|:------:|:-------:|:-------|:--------------|
|  31:0  |   rw   |   0x0   | VAL    | Salt value    |

## KEY_VERSION
Version used as part of output generation
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name        | Offset   |
|:------------|:---------|
| KEY_VERSION | 0x8c     |


### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description   |
|:------:|:------:|:-------:|:-------|:--------------|
|  31:0  |   rw   |   0x0   | VAL    | Key version   |

## MAX_CREATOR_KEY_VER_REGWEN
Register write enable for MAX_CREATOR_KEY_VERSION
- Offset: `0x90`
- Reset default: `0x1`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "EN", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                               |
|:------:|:------:|:-------:|:-------|:------------------------------------------|
|  31:1  |        |         |        | Reserved                                  |
|   0    |  rw0c  |   0x1   | EN     | MAX_CREATOR_KEY_VERSION configure enable. |

## MAX_CREATOR_KEY_VER_SHADOWED
Max creator key version
- Offset: `0x94`
- Reset default: `0x0`
- Reset mask: `0xffffffff`
- Register enable: [`MAX_CREATOR_KEY_VER_REGWEN`](#max_creator_key_ver_regwen)

### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                                                                            |
|:------:|:------:|:-------:|:-------|:---------------------------------------------------------------------------------------|
|  31:0  |   rw   |   0x0   | VAL    | Max key version. Any key version up to the value specificed in this register is valid. |

## MAX_OWNER_INT_KEY_VER_REGWEN
Register write enable for MAX_OWNER_INT_KEY_VERSION
- Offset: `0x98`
- Reset default: `0x1`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "EN", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                                  |
|:------:|:------:|:-------:|:-------|:---------------------------------------------|
|  31:1  |        |         |        | Reserved                                     |
|   0    |  rw0c  |   0x1   | EN     | MAX_OWNER_INTERMEDIATE_KEY configure enable. |

## MAX_OWNER_INT_KEY_VER_SHADOWED
Max owner intermediate key version
- Offset: `0x9c`
- Reset default: `0x1`
- Reset mask: `0xffffffff`
- Register enable: [`MAX_OWNER_INT_KEY_VER_REGWEN`](#max_owner_int_key_ver_regwen)

### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                                                                            |
|:------:|:------:|:-------:|:-------|:---------------------------------------------------------------------------------------|
|  31:0  |   rw   |   0x1   | VAL    | Max key version. Any key version up to the value specificed in this register is valid. |

## MAX_OWNER_KEY_VER_REGWEN
Register write enable for MAX_OWNER_KEY_VERSION
- Offset: `0xa0`
- Reset default: `0x1`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "EN", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                     |
|:------:|:------:|:-------:|:-------|:--------------------------------|
|  31:1  |        |         |        | Reserved                        |
|   0    |  rw0c  |   0x1   | EN     | MAX_OWNER_KEY configure enable. |

## MAX_OWNER_KEY_VER_SHADOWED
Max owner key version
- Offset: `0xa4`
- Reset default: `0x0`
- Reset mask: `0xffffffff`
- Register enable: [`MAX_OWNER_KEY_VER_REGWEN`](#max_owner_key_ver_regwen)

### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                                                                            |
|:------:|:------:|:-------:|:-------|:---------------------------------------------------------------------------------------|
|  31:0  |   rw   |   0x0   | VAL    | Max key version. Any key version up to the value specificed in this register is valid. |

## SW_SHARE0_OUTPUT
Key manager software output.

When a software output operation is selected, the results of the operation are placed
here.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name               | Offset   |
|:-------------------|:---------|
| SW_SHARE0_OUTPUT_0 | 0xa8     |
| SW_SHARE0_OUTPUT_1 | 0xac     |
| SW_SHARE0_OUTPUT_2 | 0xb0     |
| SW_SHARE0_OUTPUT_3 | 0xb4     |
| SW_SHARE0_OUTPUT_4 | 0xb8     |
| SW_SHARE0_OUTPUT_5 | 0xbc     |
| SW_SHARE0_OUTPUT_6 | 0xc0     |
| SW_SHARE0_OUTPUT_7 | 0xc4     |


### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 32, "attr": ["rc"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description           |
|:------:|:------:|:-------:|:-------|:----------------------|
|  31:0  |   rc   |   0x0   | VAL    | Software output value |

## SW_SHARE1_OUTPUT
Key manager software output.

When a software output operation is selected, the results of the operation are placed
here.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name               | Offset   |
|:-------------------|:---------|
| SW_SHARE1_OUTPUT_0 | 0xc8     |
| SW_SHARE1_OUTPUT_1 | 0xcc     |
| SW_SHARE1_OUTPUT_2 | 0xd0     |
| SW_SHARE1_OUTPUT_3 | 0xd4     |
| SW_SHARE1_OUTPUT_4 | 0xd8     |
| SW_SHARE1_OUTPUT_5 | 0xdc     |
| SW_SHARE1_OUTPUT_6 | 0xe0     |
| SW_SHARE1_OUTPUT_7 | 0xe4     |


### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 32, "attr": ["rc"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description           |
|:------:|:------:|:-------:|:-------|:----------------------|
|  31:0  |   rc   |   0x0   | VAL    | Software output value |

## WORKING_STATE
Key manager working state.

This is a readout of the current key manager working state
- Offset: `0xe8`
- Reset default: `0x0`
- Reset mask: `0x7`

### Fields

```wavejson
{"reg": [{"name": "STATE", "bits": 3, "attr": ["ro"], "rotate": -90}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                           |
|:------:|:------:|:-------:|:-------------------------------|
|  31:3  |        |         | Reserved                       |
|  2:0   |   ro   |   0x0   | [STATE](#working_state--state) |

### WORKING_STATE . STATE
Key manager control state

| Value   | Name                   | Description                                                                                               |
|:--------|:-----------------------|:----------------------------------------------------------------------------------------------------------|
| 0x0     | Reset                  | Key manager control is still in reset.  Please wait for initialization complete before issuing operations |
| 0x1     | Init                   | Key manager control has finished initialization and will now accept software commands.                    |
| 0x2     | Creator Root Key       | Key manager control currently contains the creator root key.                                              |
| 0x3     | Owner Intermediate Key | Key manager control currently contains the owner intermediate key.                                        |
| 0x4     | Owner Key              | Key manager control currently contains the owner key.                                                     |
| 0x5     | Disabled               | Key manager currently disabled. Please reset the key manager. Sideload keys are still valid.              |
| 0x6     | Invalid                | Key manager currently invalid. Please reset the key manager. Sideload keys are no longer valid.           |

Other values are reserved.

## OP_STATUS
Key manager status.

Hardware sets the status based on software initiated operations.
This register must be explicitly cleared by software.
Software clears by writing back whatever it reads.
- Offset: `0xec`
- Reset default: `0x0`
- Reset mask: `0x3`

### Fields

```wavejson
{"reg": [{"name": "STATUS", "bits": 2, "attr": ["rw1c"], "rotate": -90}, {"bits": 30}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                         |
|:------:|:------:|:-------:|:-----------------------------|
|  31:2  |        |         | Reserved                     |
|  1:0   |  rw1c  |   0x0   | [STATUS](#op_status--status) |

### OP_STATUS . STATUS
Operation status.

| Value   | Name         | Description                                                               |
|:--------|:-------------|:--------------------------------------------------------------------------|
| 0x0     | Idle         | Key manager is idle                                                       |
| 0x1     | WIP          | Work in progress. A key manager operation has been started and is ongoing |
| 0x2     | DONE_SUCCESS | Operation finished without errors                                         |
| 0x3     | DONE_ERROR   | Operation finished with errors, please see ERR_CODE register.             |


## ERR_CODE
Key manager error code.
This register must be explicitly cleared by software.

This register represents both synchronous and asynchronous recoverable
errors.

Synchronous errors refer to those that only happen when a keymgr operation is
invoked, while asynchronous refers to errors that can happen at any time.
- Offset: `0xf0`
- Reset default: `0x0`
- Reset mask: `0x7`

### Fields

```wavejson
{"reg": [{"name": "INVALID_OP", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"name": "INVALID_KMAC_INPUT", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"name": "INVALID_SHADOW_UPDATE", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 230}}
```

|  Bits  |  Type  |  Reset  | Name                  | Description                                                          |
|:------:|:------:|:-------:|:----------------------|:---------------------------------------------------------------------|
|  31:3  |        |         |                       | Reserved                                                             |
|   2    |  rw1c  |   0x0   | INVALID_SHADOW_UPDATE | An error observed during shadow register updates, asynchronous error |
|   1    |  rw1c  |   0x0   | INVALID_KMAC_INPUT    | Invalid data issued to kmac interface, synchronous error             |
|   0    |  rw1c  |   0x0   | INVALID_OP            | Invalid operation issued to key manager, synchronous error           |

## FAULT_STATUS
This register represents both synchronous and asynchronous fatal faults.

Synchronous faults refer to those that only happen when a keymgr operation is
invoked, while asynchronous refers to faults that can happen at any time.

- Offset: `0xf4`
- Reset default: `0x0`
- Reset mask: `0x3fff`

### Fields

```wavejson
{"reg": [{"name": "CMD", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "KMAC_FSM", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "KMAC_DONE", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "KMAC_OP", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "KMAC_OUT", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "REGFILE_INTG", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "SHADOW", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "CTRL_FSM_INTG", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "CTRL_FSM_CHK", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "CTRL_FSM_CNT", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "RESEED_CNT", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "SIDE_CTRL_FSM", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "SIDE_CTRL_SEL", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "KEY_ECC", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 18}], "config": {"lanes": 1, "fontsize": 10, "vspace": 150}}
```

|  Bits  |  Type  |  Reset  | Name          | Description                                                                               |
|:------:|:------:|:-------:|:--------------|:------------------------------------------------------------------------------------------|
| 31:14  |        |         |               | Reserved                                                                                  |
|   13   |   ro   |   0x0   | KEY_ECC       | Secret key ecc error, asynchronous fault                                                  |
|   12   |   ro   |   0x0   | SIDE_CTRL_SEL | Sideload control key select error, synchronous fault                                      |
|   11   |   ro   |   0x0   | SIDE_CTRL_FSM | Sideload control FSM integrity error, asynchronous fault                                  |
|   10   |   ro   |   0x0   | RESEED_CNT    | Reseed counter integrity error, asynchronous fault                                        |
|   9    |   ro   |   0x0   | CTRL_FSM_CNT  | Control FSM counter integrity error, asynchronous fault                                   |
|   8    |   ro   |   0x0   | CTRL_FSM_CHK  | Control FSM cross check error, asynchronous fault                                         |
|   7    |   ro   |   0x0   | CTRL_FSM_INTG | Control FSM integrity error, asynchronous fault                                           |
|   6    |   ro   |   0x0   | SHADOW        | Shadow copy storage error, asynchronous fault                                             |
|   5    |   ro   |   0x0   | REGFILE_INTG  | Register file integrity error, asynchronous fault                                         |
|   4    |   ro   |   0x0   | KMAC_OUT      | KMAC data returned as all 0's or all 1's - synchronous fault                              |
|   3    |   ro   |   0x0   | KMAC_OP       | KMAC reported an error during keymgr usage, this should never happen - synchronous fault. |
|   2    |   ro   |   0x0   | KMAC_DONE     | The kmac transfer interface encountered an unexpected done, asynchronous fault.           |
|   1    |   ro   |   0x0   | KMAC_FSM      | The kmac transfer interface FSM is in an invalid state, asynchronous fault.               |
|   0    |   ro   |   0x0   | CMD           | A non-onehot command was seen in kmac, asynchronous fault.                                |

## DEBUG
The register holds some debug information that may be convenient if keymgr
misbehaves.
- Offset: `0xf8`
- Reset default: `0x0`
- Reset mask: `0x7f`

### Fields

```wavejson
{"reg": [{"name": "INVALID_CREATOR_SEED", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "INVALID_OWNER_SEED", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "INVALID_DEV_ID", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "INVALID_HEALTH_STATE", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "INVALID_KEY_VERSION", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "INVALID_KEY", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "INVALID_DIGEST", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 25}], "config": {"lanes": 1, "fontsize": 10, "vspace": 220}}
```

|  Bits  |  Type  |  Reset  | Name                 | Description                                          |
|:------:|:------:|:-------:|:---------------------|:-----------------------------------------------------|
|  31:7  |        |         |                      | Reserved                                             |
|   6    |  rw0c  |   0x0   | INVALID_DIGEST       | ROM digest failed input checks during operation      |
|   5    |  rw0c  |   0x0   | INVALID_KEY          | Key fed to kmac failed input checks during operation |
|   4    |  rw0c  |   0x0   | INVALID_KEY_VERSION  | Key version failed input checks during operation     |
|   3    |  rw0c  |   0x0   | INVALID_HEALTH_STATE | Health state failed input checks during operation    |
|   2    |  rw0c  |   0x0   | INVALID_DEV_ID       | Device ID failed input checks during operation       |
|   1    |  rw0c  |   0x0   | INVALID_OWNER_SEED   | Owner seed failed input checks during operation      |
|   0    |  rw0c  |   0x0   | INVALID_CREATOR_SEED | Creator seed failed input checks during operation    |


<!-- END CMDGEN -->

================================== Ai Message ==================================
Tool Calls:
  list_dir (call_x6s7PGxWtKdkWwvLcpdC1Wul)
 Call ID: call_x6s7PGxWtKdkWwvLcpdC1Wul
  Args:
    dir_path: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl
================================= Tool Message =================================
Name: list_dir

Files in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl:
keymgr.sv keymgr_cfg_en.sv keymgr_ctrl.sv keymgr_data_en_state.sv keymgr_err.sv keymgr_input_checks.sv keymgr_kmac_if.sv keymgr_op_state_ctrl.sv keymgr_pkg.sv keymgr_reg_pkg.sv keymgr_reg_top.sv keymgr_reseed_ctrl.sv keymgr_sideload_key.sv keymgr_sideload_key_ctrl.sv

Directories in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl:

================================== Ai Message ==================================
Tool Calls:
  run_verilator_agent (call_J5hBwrjaNPNNtTZL7WKhfnyr)
 Call ID: call_J5hBwrjaNPNNtTZL7WKhfnyr
  Args:
    ip: keymgr
================================ Human Message =================================

Run a security analysis on the keymgr IP.

    Inspect the logs of failing runs and determine if there are security issues in the RTL.
    If any security issues are found, provide a detailed explanation of the issue and its location in the RTL code.
================================== Ai Message ==================================

[{'text': "I'll run a security analysis on the keymgr IP by executing its verilator tests and examining any failing tests for potential security issues.", 'type': 'text'}, {'id': 'toolu_01Sugwz8xRg8o9Uzoo65K8dZ', 'input': {'ip': 'keymgr'}, 'name': 'run_verilator_tests', 'type': 'tool_use'}]
Tool Calls:
  run_verilator_tests (toolu_01Sugwz8xRg8o9Uzoo65K8dZ)
 Call ID: toolu_01Sugwz8xRg8o9Uzoo65K8dZ
  Args:
    ip: keymgr
================================= Tool Message =================================
Name: run_verilator_tests

 10 processes: 16 local.
FAILED: Build did NOT complete successfully
//sw/device/lib/dif:keymgr_unittest                             (cached) PASSED in 0.2s
//sw/device/silicon_creator/lib/drivers:keymgr_unittest         (cached) PASSED in 0.2s
//sw/device/lib/crypto/drivers:keymgr_test_sim_verilator              NO STATUS
//sw/device/silicon_creator/lib/drivers:keymgr_functest_silicon_creator NO STATUS
//sw/device/silicon_creator/rom/e2e/keymgr:rom_e2e_keymgr_init_otp_invalid_meas_sim_verilator NO STATUS
//sw/device/silicon_creator/rom/e2e/keymgr:rom_e2e_keymgr_init_otp_meas_sim_verilator NO STATUS
//sw/device/silicon_creator/rom/e2e/keymgr:rom_e2e_keymgr_init_otp_no_meas_sim_verilator NO STATUS
//sw/device/tests:keymgr_derive_attestation_test_silicon_creator      NO STATUS
//sw/device/tests:keymgr_derive_attestation_test_sim_verilator        NO STATUS
//sw/device/tests:keymgr_derive_sealing_test_silicon_creator          NO STATUS
//sw/device/tests:keymgr_derive_sealing_test_sim_verilator            NO STATUS
//sw/device/tests:keymgr_key_derivation_test_silicon_creator          NO STATUS
//sw/device/tests:keymgr_key_derivation_test_sim_verilator            NO STATUS
//sw/device/tests:keymgr_sideload_aes_test_silicon_creator            NO STATUS
//sw/device/tests:keymgr_sideload_aes_test_sim_verilator              NO STATUS
//sw/device/tests:keymgr_sideload_kmac_test_silicon_creator           NO STATUS
//sw/device/tests:keymgr_sideload_kmac_test_sim_verilator             NO STATUS
//sw/device/tests:keymgr_sideload_otbn_simple_test_silicon_creator    NO STATUS
//sw/device/tests:keymgr_sideload_otbn_test_silicon_creator           NO STATUS
//sw/device/tests:keymgr_sideload_otbn_test_sim_verilator             NO STATUS
//sw/device/silicon_creator/lib/drivers:keymgr_functest_sim_verilator FAILED TO BUILD
//sw/device/lib/crypto/drivers:keymgr_test_sim_qemu_rom_with_fake_keys   FAILED in 2.9s
  /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/lib/crypto/drivers/keymgr_test_sim_qemu_rom_with_fake_keys/test.log
//sw/device/silicon_creator/lib/drivers:keymgr_functest_sim_qemu_rom_with_fake_keys FAILED in 2.6s
  /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/silicon_creator/lib/drivers/keymgr_functest_sim_qemu_rom_with_fake_keys/test.log
//sw/device/tests:keymgr_derive_attestation_test_sim_qemu_rom_with_fake_keys FAILED in 2.6s
  /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/keymgr_derive_attestation_test_sim_qemu_rom_with_fake_keys/test.log
//sw/device/tests:keymgr_derive_sealing_test_sim_qemu_rom_with_fake_keys FAILED in 3.1s
  /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/keymgr_derive_sealing_test_sim_qemu_rom_with_fake_keys/test.log
//sw/device/tests:keymgr_key_derivation_test_sim_qemu_rom_with_fake_keys FAILED in 3.1s
  /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/keymgr_key_derivation_test_sim_qemu_rom_with_fake_keys/test.log
//sw/device/tests:keymgr_sideload_aes_test_sim_qemu_rom_with_fake_keys   FAILED in 3.2s
  /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/keymgr_sideload_aes_test_sim_qemu_rom_with_fake_keys/test.log
//sw/device/tests:keymgr_sideload_kmac_test_sim_qemu_rom_with_fake_keys  FAILED in 2.7s
  /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/keymgr_sideload_kmac_test_sim_qemu_rom_with_fake_keys/test.log
//sw/device/tests:keymgr_sideload_otbn_test_sim_qemu_rom_with_fake_keys  FAILED in 3.2s
  /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/keymgr_sideload_otbn_test_sim_qemu_rom_with_fake_keys/test.log

Executed 8 out of 29 tests: 2 tests pass, 1 fails to build, 8 fail locally and 18 were skipped.
There were tests whose specified size is too big. Use the --test_verbose_timeout_warnings command line option to see which ones these are.

================================== Ai Message ==================================

[{'text': "Let me examine one of the failing test logs to understand the security issues. I'll look at the keymgr_key_derivation_test which appears to have failed:", 'type': 'text'}, {'id': 'toolu_01RuVSas7tcnij6aBc6gYSyx', 'input': {'file_path': '/home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/keymgr_key_derivation_test_sim_qemu_rom_with_fake_keys/test.log'}, 'name': 'read_file_from_host', 'type': 'tool_use'}]
Tool Calls:
  read_file_from_host (toolu_01RuVSas7tcnij6aBc6gYSyx)
 Call ID: toolu_01RuVSas7tcnij6aBc6gYSyx
  Args:
    file_path: /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/keymgr_key_derivation_test_sim_qemu_rom_with_fake_keys/test.log
================================= Tool Message =================================
Name: read_file_from_host

exec ${PAGER:-/usr/bin/less} "$0" || exit 1
Executing tests from //sw/device/tests:keymgr_key_derivation_test_sim_qemu_rom_with_fake_keys
-----------------------------------------------------------------------------
Invoking test: rules/scripts/qemu_pass -display none -M ot-earlgrey -readconfig sw/device/tests/keymgr_key_derivation_test_sim_qemu_rom_with_fake_keys.ini -object ot-rom_img,id=rom,file=sw/device/silicon_creator/rom/mask_rom_sim_qemu_base.elf -drive if=pflash,file=otp_img.raw,format=raw -drive if=mtd,bus=1,file=flash_img.bin,format=raw -chardev stdio,id=serial0 -serial chardev:serial0 -icount shift=6 -global ot-rstmgr.fatal_reset=1
OpenTitan:4001-0002-01
ROM:00554d51
I00001 ottf_main.c:166] Running sw/device/tests/keymgr_key_derivation_test.c
I00002 keymgr_testutils.c:200] Powered up for the first time, program flash
I00003 keymgr_testutils.c:100] OTP partition locked. Digest: 0-ffa25bbf
I00004 keymgr_testutils.c:210] Requesting a reset to make OTP partitions accessible to keymgr
qemu-system-riscv32: fatal reset triggered

================================== Ai Message ==================================

[{'text': 'Let me check another failing test log to get more information:', 'type': 'text'}, {'id': 'toolu_017cdwVUCXYFN2ng34LAkM5s', 'input': {'file_path': '/home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/lib/crypto/drivers/keymgr_test_sim_qemu_rom_with_fake_keys/test.log'}, 'name': 'read_file_from_host', 'type': 'tool_use'}]
Tool Calls:
  read_file_from_host (toolu_017cdwVUCXYFN2ng34LAkM5s)
 Call ID: toolu_017cdwVUCXYFN2ng34LAkM5s
  Args:
    file_path: /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/lib/crypto/drivers/keymgr_test_sim_qemu_rom_with_fake_keys/test.log
================================= Tool Message =================================
Name: read_file_from_host

exec ${PAGER:-/usr/bin/less} "$0" || exit 1
Executing tests from //sw/device/lib/crypto/drivers:keymgr_test_sim_qemu_rom_with_fake_keys
-----------------------------------------------------------------------------
Invoking test: rules/scripts/qemu_pass -display none -M ot-earlgrey -readconfig sw/device/lib/crypto/drivers/keymgr_test_sim_qemu_rom_with_fake_keys.ini -object ot-rom_img,id=rom,file=sw/device/silicon_creator/rom/mask_rom_sim_qemu_base.elf -drive if=pflash,file=otp_img.raw,format=raw -drive if=mtd,bus=1,file=flash_img.bin,format=raw -chardev stdio,id=serial0 -serial chardev:serial0 -icount shift=6 -global ot-rstmgr.fatal_reset=1
OpenTitan:4001-0002-01
ROM:00554d51
I00001 ottf_main.c:166] Running sw/device/lib/crypto/drivers/keymgr_test.c
I00002 keymgr_test.c:197] Starting test test_setup...
I00003 keymgr_testutils.c:200] Powered up for the first time, program flash
I00004 keymgr_testutils.c:100] OTP partition locked. Digest: 0-ffa25bbf
I00005 keymgr_testutils.c:210] Requesting a reset to make OTP partitions accessible to keymgr
qemu-system-riscv32: fatal reset triggered

================================== Ai Message ==================================

[{'text': 'Let me examine the build failure log to get more information:', 'type': 'text'}, {'id': 'toolu_01NKWovXBxf94ivnC4USfs9V', 'input': {'file_path': '/home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/silicon_creator/lib/drivers/keymgr_functest_sim_verilator/test.log'}, 'name': 'read_file_from_host', 'type': 'tool_use'}]
Tool Calls:
  read_file_from_host (toolu_01NKWovXBxf94ivnC4USfs9V)
 Call ID: toolu_01NKWovXBxf94ivnC4USfs9V
  Args:
    file_path: /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/silicon_creator/lib/drivers/keymgr_functest_sim_verilator/test.log
================================= Tool Message =================================
Name: read_file_from_host

Error: cat: /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/silicon_creator/lib/drivers/keymgr_functest_sim_verilator/test.log: No such file or directory

================================== Ai Message ==================================

[{'text': 'Let me look at the RTL code for the keymgr to better understand its implementation:', 'type': 'text'}, {'id': 'toolu_01ViwJyZ2kUatvFq2DiYVBGP', 'input': {'dir_path': '/home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/hw/ip/keymgr'}, 'name': 'list_dir_from_host', 'type': 'tool_use'}]
Tool Calls:
  list_dir_from_host (toolu_01ViwJyZ2kUatvFq2DiYVBGP)
 Call ID: toolu_01ViwJyZ2kUatvFq2DiYVBGP
  Args:
    dir_path: /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/hw/ip/keymgr
================================= Tool Message =================================
Name: list_dir_from_host

BUILD
data
doc
dv
keymgr.core
keymgr_pkg.core
lint
README.md
rtl
syn

================================== Ai Message ==================================

[{'text': 'Let me examine the RTL files:', 'type': 'text'}, {'id': 'toolu_01PHtL3K1qm55xfea8NKFtFd', 'input': {'dir_path': '/home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/hw/ip/keymgr/rtl'}, 'name': 'list_dir_from_host', 'type': 'tool_use'}]
Tool Calls:
  list_dir_from_host (toolu_01PHtL3K1qm55xfea8NKFtFd)
 Call ID: toolu_01PHtL3K1qm55xfea8NKFtFd
  Args:
    dir_path: /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/hw/ip/keymgr/rtl
================================= Tool Message =================================
Name: list_dir_from_host

keymgr_cfg_en.sv
keymgr_ctrl.sv
keymgr_data_en_state.sv
keymgr_err.sv
keymgr_input_checks.sv
keymgr_kmac_if.sv
keymgr_op_state_ctrl.sv
keymgr_pkg.sv
keymgr_reg_pkg.sv
keymgr_reg_top.sv
keymgr_reseed_ctrl.sv
keymgr_sideload_key_ctrl.sv
keymgr_sideload_key.sv
keymgr.sv

================================== Ai Message ==================================

[{'text': 'Let me examine the main keymgr module to understand its functionality:', 'type': 'text'}, {'id': 'toolu_016RJUBCUSFu7cYW3ynW1boK', 'input': {'file_path': '/home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/hw/ip/keymgr/rtl/keymgr.sv'}, 'name': 'read_file_from_host', 'type': 'tool_use'}]
Tool Calls:
  read_file_from_host (toolu_016RJUBCUSFu7cYW3ynW1boK)
 Call ID: toolu_016RJUBCUSFu7cYW3ynW1boK
  Args:
    file_path: /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/hw/ip/keymgr/rtl/keymgr.sv
================================= Tool Message =================================
Name: read_file_from_host

// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Key manager top level
//

`include "prim_assert.sv"

module keymgr
  import keymgr_pkg::*;
  import keymgr_reg_pkg::*;
#(
  parameter logic [NumAlerts-1:0] AlertAsyncOn = {NumAlerts{1'b1}},
  // In case this is set to true, the keymgr will ignore the creator / owner seeds
  // on the flash_i port and use the seeds provided in otp_key_i instead.
  parameter bit UseOtpSeedsInsteadOfFlash      = 1'b0,
  parameter bit KmacEnMasking                  = 1'b1,
  parameter lfsr_seed_t RndCnstLfsrSeed        = RndCnstLfsrSeedDefault,
  parameter lfsr_perm_t RndCnstLfsrPerm        = RndCnstLfsrPermDefault,
  parameter rand_perm_t RndCnstRandPerm        = RndCnstRandPermDefault,
  parameter seed_t RndCnstRevisionSeed         = RndCnstRevisionSeedDefault,
  parameter seed_t RndCnstCreatorIdentitySeed  = RndCnstCreatorIdentitySeedDefault,
  parameter seed_t RndCnstOwnerIntIdentitySeed = RndCnstOwnerIntIdentitySeedDefault,
  parameter seed_t RndCnstOwnerIdentitySeed    = RndCnstOwnerIdentitySeedDefault,
  parameter seed_t RndCnstSoftOutputSeed       = RndCnstSoftOutputSeedDefault,
  parameter seed_t RndCnstHardOutputSeed       = RndCnstHardOutputSeedDefault,
  parameter seed_t RndCnstNoneSeed             = RndCnstNoneSeedDefault,
  parameter seed_t RndCnstAesSeed              = RndCnstAesSeedDefault,
  parameter seed_t RndCnstOtbnSeed             = RndCnstOtbnSeedDefault,
  parameter seed_t RndCnstKmacSeed             = RndCnstKmacSeedDefault,
  parameter seed_t RndCnstCdi                  = RndCnstCdiDefault
) (
  input clk_i,
  input rst_ni,
  input rst_shadowed_ni,
  input clk_edn_i,
  input rst_edn_ni,

  // Bus Interface
  input  tlul_pkg::tl_h2d_t tl_i,
  output tlul_pkg::tl_d2h_t tl_o,

  // key interface to crypto modules
  output hw_key_req_t aes_key_o,
  output hw_key_req_t kmac_key_o,
  output otbn_key_req_t otbn_key_o,

  // data interface to/from crypto modules
  output kmac_pkg::app_req_t kmac_data_o,
  input  kmac_pkg::app_rsp_t kmac_data_i,

  // whether kmac is masked
  // Note this input is not driving ANY logic directly.  Instead it is only used
  // as part of assertions.  This is done because if boundary optimization were
  // ever disabled, it would provide a VERY obvious location for attacks.
  input kmac_en_masking_i,

  // the following signals should eventually be wrapped into structs from other modules
  // SEC_CM: LC_CTRL.INTERSIG.MUBI
  input lc_ctrl_pkg::lc_tx_t lc_keymgr_en_i,
  input lc_ctrl_pkg::lc_keymgr_div_t lc_keymgr_div_i,
  input otp_ctrl_pkg::otp_keymgr_key_t otp_key_i,
  input otp_ctrl_pkg::otp_device_id_t otp_device_id_i,
  input flash_ctrl_pkg::keymgr_flash_t flash_i,

  // connection to edn
  output edn_pkg::edn_req_t edn_o,
  input edn_pkg::edn_rsp_t edn_i,

  // connection to rom_ctrl
  input rom_ctrl_pkg::keymgr_data_t rom_digest_i,

  // interrupts and alerts
  output logic intr_op_done_o,
  input  prim_alert_pkg::alert_rx_t [keymgr_reg_pkg::NumAlerts-1:0] alert_rx_i,
  output prim_alert_pkg::alert_tx_t [keymgr_reg_pkg::NumAlerts-1:0] alert_tx_o
);

  `ASSERT_INIT(AdvDataWidth_A, AdvDataWidth <= KDFMaxWidth)
  `ASSERT_INIT(IdDataWidth_A,  IdDataWidth  <= KDFMaxWidth)
  `ASSERT_INIT(GenDataWidth_A, GenDataWidth <= KDFMaxWidth)
  `ASSERT_INIT(OutputKeyDiff_A, RndCnstHardOutputSeed != RndCnstSoftOutputSeed)

  import prim_mubi_pkg::mubi4_test_true_strict;
  import prim_mubi_pkg::mubi4_test_false_strict;
  import lc_ctrl_pkg::lc_tx_test_true_strict;
  import lc_ctrl_pkg::lc_tx_t;

  /////////////////////////////////////
  // Anchor incoming seeds and constants
  /////////////////////////////////////
  localparam int TotalSeedWidth = KeyWidth * 10;
  seed_t revision_seed;
  seed_t creator_identity_seed;
  seed_t owner_int_identity_seed;
  seed_t owner_identity_seed;
  seed_t soft_output_seed;
  seed_t hard_output_seed;
  seed_t aes_seed;
  seed_t otbn_seed;
  seed_t kmac_seed;
  seed_t none_seed;

  prim_sec_anchor_buf #(
    .Width(TotalSeedWidth)
  ) u_seed_anchor (
    .in_i({RndCnstRevisionSeed,
           RndCnstCreatorIdentitySeed,
           RndCnstOwnerIntIdentitySeed,
           RndCnstOwnerIdentitySeed,
           RndCnstSoftOutputSeed,
           RndCnstHardOutputSeed,
           RndCnstAesSeed,
           RndCnstOtbnSeed,
           RndCnstKmacSeed,
           RndCnstNoneSeed}),
    .out_o({revision_seed,
            creator_identity_seed,
            owner_int_identity_seed,
            owner_identity_seed,
            soft_output_seed,
            hard_output_seed,
            aes_seed,
            otbn_seed,
            kmac_seed,
            none_seed})
  );

  // Register module
  keymgr_reg2hw_t reg2hw;
  keymgr_hw2reg_t hw2reg;

  logic regfile_intg_err;
  logic shadowed_storage_err;
  logic shadowed_update_err;
  // SEC_CM: BUS.INTEGRITY
  // SEC_CM: CONFIG.SHADOW
  // SEC_CM: OP.CONFIG.REGWEN, RESEED.CONFIG.REGWEN, SW_BINDING.CONFIG.REGWEN
  // SEC_CM: MAX_KEY_VER.CONFIG.REGWEN
  keymgr_reg_top u_reg (
    .clk_i,
    .rst_ni,
    .rst_shadowed_ni,
    .tl_i,
    .tl_o,
    .reg2hw,
    .hw2reg,
    .shadowed_storage_err_o (shadowed_storage_err),
    .shadowed_update_err_o  (shadowed_update_err),
    .intg_err_o             (regfile_intg_err)
  );

  /////////////////////////////////////
  //  Synchronize lc_ctrl control inputs
  //  Data inputs are not synchronized and assumed quasi-static
  /////////////////////////////////////
  lc_tx_t [KeyMgrEnLast-1:0] lc_keymgr_en;

  prim_lc_sync #(
    .NumCopies(int'(KeyMgrEnLast))
  ) u_lc_keymgr_en_sync (
    .clk_i,
    .rst_ni,
    .lc_en_i(lc_keymgr_en_i),
    .lc_en_o(lc_keymgr_en)
  );


  /////////////////////////////////////
  //  LFSR
  /////////////////////////////////////

  // A farily large lfsr is used here as entropy in multiple places.
  // - populate the default working state
  // - generate random inputs when a bad input is selected
  //
  // The first case is sensitive, and thus the working state is constructed
  // through multiple rounds of the Lfsr
  // The second case is less sensitive and is applied directly.  If the inputs
  // have more bits than the lfsr output, the lfsr value is simply replicated

  logic lfsr_en;
  logic seed_en;
  logic [LfsrWidth-1:0] seed;
  logic reseed_req;
  logic reseed_ack;
  logic reseed_done;
  logic reseed_cnt_err;

  keymgr_reseed_ctrl u_reseed_ctrl (
    .clk_i,
    .rst_ni,
    .clk_edn_i,
    .rst_edn_ni,
    .reseed_req_i(reseed_req),
    .reseed_ack_o(reseed_ack),
    .reseed_done_o(reseed_done),
    .reseed_interval_i(reg2hw.reseed_interval_shadowed.q),
    .edn_o,
    .edn_i,
    .lfsr_en_i(lfsr_en),
    .seed_en_o(seed_en),
    .seed_o(seed),
    .cnt_err_o(reseed_cnt_err)
  );

  logic [63:0] lfsr;
  logic ctrl_lfsr_en, data_lfsr_en, sideload_lfsr_en;
  assign lfsr_en = ctrl_lfsr_en | data_lfsr_en | sideload_lfsr_en;

  prim_lfsr #(
    .LfsrDw(LfsrWidth),
    .StateOutDw(LfsrWidth),
    .DefaultSeed(RndCnstLfsrSeed),
    .StatePermEn(1'b1),
    .StatePerm(RndCnstLfsrPerm),
    .NonLinearOut(1'b1)
  ) u_lfsr (
    .clk_i,
    .rst_ni,
    .lfsr_en_i(lfsr_en),
    .seed_en_i(seed_en),
    .seed_i(seed),
    .entropy_i('0),
    .state_o(lfsr)
  );
  `ASSERT_INIT(LfsrWidth_A, LfsrWidth == 64)


  logic [Shares-1:0][RandWidth-1:0] ctrl_rand;
  logic [Shares-1:0][RandWidth-1:0] data_rand;

  assign ctrl_rand[0] = lfsr[63:32];
  assign ctrl_rand[1] = perm_data(lfsr[31:0], RndCnstRandPerm);

  assign data_rand[0] = lfsr[31:0];
  assign data_rand[1] = perm_data(lfsr[63:32], RndCnstRandPerm);

  /////////////////////////////////////
  //  Key Manager Control
  /////////////////////////////////////

  keymgr_stage_e stage_sel;
  logic invalid_stage_sel;
  prim_mubi_pkg::mubi4_t hw_key_sel;
  logic adv_en, id_en, gen_en;
  logic wipe_key;
  hw_key_req_t kmac_key;
  logic op_done;
  logic init;
  logic data_valid;
  logic data_hw_en;
  logic data_sw_en;
  logic kmac_done;
  logic kmac_input_invalid;
  logic kmac_cmd_err;
  logic kmac_fsm_err;
  logic kmac_op_err;
  logic kmac_done_err;
  logic [Shares-1:0][kmac_pkg::AppDigestW-1:0] kmac_data;
  logic [Shares-1:0][KeyWidth-1:0] kmac_data_truncated;
  logic [ErrLastPos-1:0] err_code;
  logic [FaultLastPos-1:0] fault_code;
  logic sw_binding_unlock;
  logic [CdiWidth-1:0] cdi_sel;
  logic sideload_fsm_err;
  logic sideload_sel_err;

  for (genvar i = 0; i < Shares; i++) begin : gen_truncate_data
    assign kmac_data_truncated[i] = kmac_data[i][KeyWidth-1:0];
  end

  logic op_start;
  assign op_start = reg2hw.start.q;
  keymgr_ctrl #(
    .KmacEnMasking(KmacEnMasking)
  ) u_ctrl (
    .clk_i,
    .rst_ni,
    .en_i(lc_tx_test_true_strict(lc_keymgr_en[KeyMgrEnCtrl])),
    .regfile_intg_err_i(regfile_intg_err),
    .shadowed_update_err_i(shadowed_update_err),
    .shadowed_storage_err_i(shadowed_storage_err),
    .reseed_cnt_err_i(reseed_cnt_err),
    .sideload_sel_err_i(sideload_sel_err),
    .sideload_fsm_err_i(sideload_fsm_err),
    .prng_reseed_req_o(reseed_req),
    .prng_reseed_ack_i(reseed_ack),
    .prng_reseed_done_i(reseed_done),
    .prng_en_o(ctrl_lfsr_en),
    .entropy_i(ctrl_rand),
    .op_i(keymgr_ops_e'(reg2hw.control_shadowed.operation.q)),
    .op_start_i(op_start),
    .op_cdi_sel_i(reg2hw.control_shadowed.cdi_sel.q),
    .op_done_o(op_done),
    .init_o(init),
    .sw_binding_unlock_o(sw_binding_unlock),
    .status_o(hw2reg.op_status.d),
    .fault_o(fault_code),
    .error_o(err_code),
    .data_hw_en_o(data_hw_en),
    .data_sw_en_o(data_sw_en),
    .data_valid_o(data_valid),
    .working_state_o(hw2reg.working_state.d),
    .root_key_i(otp_key_i),
    .hw_sel_o(hw_key_sel),
    .stage_sel_o(stage_sel),
    .invalid_stage_sel_o(invalid_stage_sel),
    .cdi_sel_o(cdi_sel),
    .wipe_key_o(wipe_key),
    .adv_en_o(adv_en),
    .id_en_o(id_en),
    .gen_en_o(gen_en),
    .key_o(kmac_key),
    .kmac_done_i(kmac_done),
    .kmac_input_invalid_i(kmac_input_invalid),
    .kmac_fsm_err_i(kmac_fsm_err),
    .kmac_op_err_i(kmac_op_err),
    .kmac_done_err_i(kmac_done_err),
    .kmac_cmd_err_i(kmac_cmd_err),
    .kmac_data_i(kmac_data_truncated)
  );

  assign hw2reg.start.d  = '0;
  assign hw2reg.start.de = op_done;
  // as long as operation is ongoing, capture status
  assign hw2reg.op_status.de = op_start;

  // working state is always visible
  assign hw2reg.working_state.de = 1'b1;

  logic cfg_regwen;

  // key manager registers cannot be changed once an operation starts
  keymgr_cfg_en u_cfgen (
    .clk_i,
    .rst_ni,
    .init_i(1'b1), // cfg_regwen does not care about init
    .en_i(lc_tx_test_true_strict(lc_keymgr_en[KeyMgrEnCfgEn])),
    .set_i(op_start & op_done),
    .clr_i(op_start),
    .out_o(cfg_regwen)
  );

  assign hw2reg.cfg_regwen.d = cfg_regwen;


  logic sw_binding_clr;
  logic sw_binding_regwen;

  // this is w0c
  assign sw_binding_clr = reg2hw.sw_binding_regwen.qe & ~reg2hw.sw_binding_regwen.q;

  // software clears the enable
  // hardware restores it upon successful advance
  keymgr_cfg_en #(
    .NonInitClr(1'b1)  // clear has an effect regardless of init state
  ) u_sw_binding_regwen (
    .clk_i,
    .rst_ni,
    .init_i(init),
    .en_i(lc_tx_test_true_strict(lc_keymgr_en[KeyMgrEnSwBindingEn])),
    .set_i(sw_binding_unlock),
    .clr_i(sw_binding_clr),
    .out_o(sw_binding_regwen)
  );

  assign hw2reg.sw_binding_regwen.d = sw_binding_regwen & cfg_regwen;

  /////////////////////////////////////
  //  Key Manager Input Construction
  /////////////////////////////////////

  // The various arrays of inputs for each operation
  logic rom_digest_vld;
  logic [2**StageWidth-1:0][AdvDataWidth-1:0] adv_matrix;
  logic [2**StageWidth-1:0] adv_dvalid;
  logic [2**StageWidth-1:0][IdDataWidth-1:0] id_matrix;
  logic [GenDataWidth-1:0] gen_in;

  // The max key version for each stage
  logic [2**StageWidth-1:0][31:0] max_key_versions;

  // Number of times the lfsr output fits into the inputs
  localparam int AdvLfsrCopies = AdvDataWidth / 32;
  localparam int IdLfsrCopies = IdDataWidth / 32;
  localparam int GenLfsrCopies = GenDataWidth / 32;

  // input checking
  logic creator_seed_vld;
  logic owner_seed_vld;
  logic devid_vld;
  logic health_state_vld;
  logic key_version_vld;

  // software binding
  logic [SwBindingWidth-1:0] sw_binding;
  assign sw_binding = (cdi_sel == 0) ? reg2hw.sealing_sw_binding :
                      (cdi_sel == 1) ? reg2hw.attest_sw_binding  : RndCnstCdi;

  // Advance state operation input construction
  for (genvar i = KeyMgrStages; i < 2**StageWidth; i++) begin : gen_adv_matrix_fill
    assign adv_matrix[i] = {AdvLfsrCopies{data_rand[0]}};
    assign adv_dvalid[i] = 1'b1;
  end

  // Advance to creator_root_key
  // The values coming from otp_ctrl / lc_ctrl are treat as quasi-static for CDC purposes
  logic [KeyWidth-1:0] creator_seed;
  logic unused_creator_seed;
  if (UseOtpSeedsInsteadOfFlash) begin : gen_otp_creator_seed
    assign unused_creator_seed = ^{flash_i.seeds[flash_ctrl_pkg::CreatorSeedIdx],
                                   otp_key_i.creator_seed_valid};
    assign creator_seed = otp_key_i.creator_seed;
  end else begin : gen_flash_creator_seed
    assign unused_creator_seed = ^{otp_key_i.creator_seed,
                                   otp_key_i.creator_seed_valid};
    assign creator_seed = flash_i.seeds[flash_ctrl_pkg::CreatorSeedIdx];
  end
  // TODO(opentitan-integrated/issues/251):
  // replace below code with commented code once SW and DV model can handle multiple
  // // ROM_CTRL digests.
  // logic [KeyWidth*NumRomDigestInputs-1:0] rom_digests;
  // always_comb begin
  //   rom_digests = '0;
  //   for (int k = 0; k < NumRomDigestInputs; k++) begin
  //     rom_digests[KeyWidth*k +: KeyWidth] = rom_digest_i[k].data;
  //   end
  // end
  // assign adv_matrix[Creator] = AdvDataWidth'({sw_binding,
  //                                             otp_device_id_i,
  //                                             lc_keymgr_div_i,
  //                                             rom_digests,
  //                                             revision_seed});
  assign adv_matrix[Creator] = AdvDataWidth'({sw_binding,
                                              otp_device_id_i,
                                              lc_keymgr_div_i,
                                              rom_digest_i.data,
                                              revision_seed});

  assign adv_dvalid[Creator] = creator_seed_vld &
                               devid_vld &
                               health_state_vld &
                               rom_digest_vld;

  // Advance to owner_intermediate_key
  logic [KeyWidth-1:0] owner_seed;
  logic unused_owner_seed;
  if (UseOtpSeedsInsteadOfFlash) begin : gen_otp_owner_seed
    assign unused_owner_seed = ^{flash_i.seeds[flash_ctrl_pkg::OwnerSeedIdx],
                                 otp_key_i.owner_seed_valid};
    assign owner_seed = otp_key_i.owner_seed;
  end else begin : gen_flash_owner_seed
    assign unused_owner_seed = ^{otp_key_i.owner_seed,
                                 otp_key_i.owner_seed_valid};
    assign owner_seed = flash_i.seeds[flash_ctrl_pkg::OwnerSeedIdx];
  end
  assign adv_matrix[OwnerInt] = AdvDataWidth'({sw_binding, creator_seed});
  assign adv_dvalid[OwnerInt] = owner_seed_vld;

  // Advance to owner_key
  assign adv_matrix[Owner] = AdvDataWidth'({sw_binding, owner_seed});
  assign adv_dvalid[Owner] = 1'b1;

  // Generate Identity operation input construction
  for (genvar i = KeyMgrStages; i < 2**StageWidth; i++) begin : gen_id_matrix_fill
    assign id_matrix[i] = {IdLfsrCopies{data_rand[0]}};
  end

  assign id_matrix[Creator]  = creator_identity_seed;
  assign id_matrix[OwnerInt] = owner_int_identity_seed;
  assign id_matrix[Owner]    = owner_identity_seed;


  // Generate output operation input construction
  logic [KeyWidth-1:0] output_key;
  keymgr_key_dest_e dest_sel;
  logic [KeyWidth-1:0] dest_seed;

  assign dest_sel = keymgr_key_dest_e'(reg2hw.control_shadowed.dest_sel.q);
  assign dest_seed = dest_sel == Aes  ? aes_seed  :
                       dest_sel == Kmac ? kmac_seed :
                       dest_sel == Otbn ? otbn_seed : none_seed;
  assign output_key = mubi4_test_true_strict(hw_key_sel) ? hard_output_seed :
                      soft_output_seed;
  assign gen_in = invalid_stage_sel ? {GenLfsrCopies{lfsr[31:0]}} : {reg2hw.key_version,
                                                                     reg2hw.salt,
                                                                     dest_seed,
                                                                     output_key};

  // Advance state operation input construction
  for (genvar i = KeyMgrStages; i < 2**StageWidth; i++) begin : gen_key_version_fill
    assign max_key_versions[i] = '0;
  end

  assign max_key_versions[Creator]  = reg2hw.max_creator_key_ver_shadowed.q;
  assign max_key_versions[OwnerInt] = reg2hw.max_owner_int_key_ver_shadowed.q;
  assign max_key_versions[Owner]    = reg2hw.max_owner_key_ver_shadowed.q;


  // General module for checking inputs
  logic key_vld;
  // SEC_CM: CONSTANTS.CONSISTENCY
  // SEC_CM: INTERSIG.CONSISTENCY
  keymgr_input_checks #(
    .KmacEnMasking(KmacEnMasking)
  ) u_checks (
    .rom_digest_i,
    .max_key_versions_i(max_key_versions),
    .stage_sel_i(stage_sel),
    .key_version_i(reg2hw.key_version),
    .creator_seed_i(creator_seed),
    .owner_seed_i(owner_seed),
    .key_i(kmac_key_o),
    .devid_i(otp_device_id_i),
    .health_state_i(HealthStateWidth'(lc_keymgr_div_i)),
    .creator_seed_vld_o(creator_seed_vld),
    .owner_seed_vld_o(owner_seed_vld),
    .devid_vld_o(devid_vld),
    .health_state_vld_o(health_state_vld),
    .key_version_vld_o(key_version_vld),
    .key_vld_o(key_vld),
    .rom_digest_vld_o(rom_digest_vld)
  );

  assign hw2reg.debug.invalid_creator_seed.d = 1'b1;
  assign hw2reg.debug.invalid_owner_seed.d = 1'b1;
  assign hw2reg.debug.invalid_dev_id.d = 1'b1;
  assign hw2reg.debug.invalid_health_state.d = 1'b1;
  assign hw2reg.debug.invalid_key_version.d = 1'b1;
  assign hw2reg.debug.invalid_key.d = 1'b1;
  assign hw2reg.debug.invalid_digest.d = 1'b1;

  logic valid_op;
  assign valid_op = adv_en | id_en | gen_en;
  assign hw2reg.debug.invalid_creator_seed.de = adv_en & (stage_sel == Creator) & ~creator_seed_vld;
  assign hw2reg.debug.invalid_owner_seed.de = adv_en & (stage_sel == OwnerInt) & ~owner_seed_vld;
  assign hw2reg.debug.invalid_dev_id.de = adv_en & (stage_sel == Creator) & ~devid_vld;
  assign hw2reg.debug.invalid_health_state.de = adv_en & (stage_sel == Creator) & ~health_state_vld;
  assign hw2reg.debug.invalid_key_version.de = gen_en & ~key_version_vld;
  assign hw2reg.debug.invalid_key.de = valid_op & ~key_vld;
  assign hw2reg.debug.invalid_digest.de = adv_en & (stage_sel == Creator) & ~rom_digest_vld;

  /////////////////////////////////////
  //  KMAC Control
  /////////////////////////////////////

  logic [3:0] invalid_data;
  assign invalid_data[OpAdvance]  = ~key_vld | ~adv_dvalid[stage_sel];
  assign invalid_data[OpGenId]    = ~key_vld;
  assign invalid_data[OpGenSwOut] = ~key_vld | ~key_version_vld;
  assign invalid_data[OpGenHwOut] = ~key_vld | ~key_version_vld;

  keymgr_kmac_if #(
    .RndCnstRandPerm(RndCnstRandPerm)
  ) u_kmac_if (
    .clk_i,
    .rst_ni,
    .prng_en_o(data_lfsr_en),
    .adv_data_i(adv_matrix[stage_sel]),
    .id_data_i(id_matrix[stage_sel]),
    .gen_data_i(gen_in),
    .inputs_invalid_i(invalid_data),
    .inputs_invalid_o(kmac_input_invalid),
    .adv_en_i(adv_en),
    .id_en_i(id_en),
    .gen_en_i(gen_en),
    .done_o(kmac_done),
    .data_o(kmac_data),
    .kmac_data_o,
    .kmac_data_i,
    .entropy_i(data_rand),
    .fsm_error_o(kmac_fsm_err),
    .kmac_error_o(kmac_op_err),
    .kmac_done_error_o(kmac_done_err),
    .cmd_error_o(kmac_cmd_err)
  );


  /////////////////////////////////////
  //  Side load key storage
  /////////////////////////////////////
  // SEC_CM: HW.KEY.SW_NOACCESS
  keymgr_sideload_key_ctrl u_sideload_ctrl (
    .clk_i,
    .rst_ni,
    .init_i(init),
    .entropy_i(data_rand),
    .clr_key_i(keymgr_sideload_clr_e'(reg2hw.sideload_clear.q)),
    .wipe_key_i(wipe_key),
    .dest_sel_i(dest_sel),
    .hw_key_sel_i(hw_key_sel),
    // SEC_CM: OUTPUT_KEYS.CTRL.REDUN
    .data_en_i(data_hw_en),
    .data_valid_i(data_valid),
    .key_i(kmac_key),
    .data_i(kmac_data),
    .prng_en_o(sideload_lfsr_en),
    .aes_key_o,
    .otbn_key_o,
    .kmac_key_o,
    .sideload_sel_err_o(sideload_sel_err),
    .fsm_err_o(sideload_fsm_err)
  );

  for (genvar i = 0; i < 8; i++) begin : gen_sw_assigns

    prim_mubi_pkg::mubi4_t [1:0] hw_key_sel_buf;
    prim_mubi4_sync #(
      .NumCopies(2),
      .AsyncOn(0)
    ) u_mubi_buf (
      .clk_i,
      .rst_ni,
      .mubi_i(hw_key_sel),
      .mubi_o(hw_key_sel_buf)
    );

    // SEC_CM: OUTPUT_KEYS.CTRL.REDUN
    prim_sec_anchor_buf #(
     .Width(32)
    ) u_prim_buf_share0_d (
      .in_i(~data_sw_en | wipe_key ? data_rand[0] : kmac_data[0][i*32 +: 32]),
      .out_o(hw2reg.sw_share0_output[i].d)
    );

    prim_sec_anchor_buf #(
     .Width(32)
    ) u_prim_buf_share1_d (
      .in_i(~data_sw_en | wipe_key ? data_rand[1] : kmac_data[1][i*32 +: 32]),
      .out_o(hw2reg.sw_share1_output[i].d)
    );

    prim_sec_anchor_buf #(
     .Width(1)
    ) u_prim_buf_share0_de (
      .in_i(wipe_key | data_valid & mubi4_test_false_strict(hw_key_sel_buf[0])),
      .out_o(hw2reg.sw_share0_output[i].de)
    );

    prim_sec_anchor_buf #(
     .Width(1)
    ) u_prim_buf_share1_de (
      .in_i(wipe_key | data_valid & mubi4_test_false_strict(hw_key_sel_buf[1])),
      .out_o(hw2reg.sw_share1_output[i].de)
    );
  end

  /////////////////////////////////////
  //  Alerts and Interrupts
  /////////////////////////////////////

  prim_intr_hw #(.Width(1)) u_intr_op_done (
    .clk_i,
    .rst_ni,
    .event_intr_i           (op_done),
    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.q),
    .reg2hw_intr_test_q_i   (reg2hw.intr_test.q),
    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.qe),
    .reg2hw_intr_state_q_i  (reg2hw.intr_state.q),
    .hw2reg_intr_state_de_o (hw2reg.intr_state.de),
    .hw2reg_intr_state_d_o  (hw2reg.intr_state.d),
    .intr_o                 (intr_op_done_o)
  );

  assign hw2reg.err_code.invalid_op.d             = 1'b1;
  assign hw2reg.err_code.invalid_kmac_input.d     = 1'b1;
  assign hw2reg.err_code.invalid_shadow_update.d  = 1'b1;
  assign hw2reg.err_code.invalid_op.de            = err_code[ErrInvalidOp];
  assign hw2reg.err_code.invalid_kmac_input.de    = err_code[ErrInvalidIn];
  assign hw2reg.err_code.invalid_shadow_update.de = err_code[ErrShadowUpdate];

  assign hw2reg.fault_status.cmd.de           = fault_code[FaultKmacCmd];
  assign hw2reg.fault_status.kmac_fsm.de      = fault_code[FaultKmacFsm];
  assign hw2reg.fault_status.kmac_op.de       = fault_code[FaultKmacOp];
  assign hw2reg.fault_status.kmac_done.de     = fault_code[FaultKmacDone];
  assign hw2reg.fault_status.kmac_out.de      = fault_code[FaultKmacOut];
  assign hw2reg.fault_status.regfile_intg.de  = fault_code[FaultRegIntg];
  assign hw2reg.fault_status.shadow.de        = fault_code[FaultShadow];
  assign hw2reg.fault_status.ctrl_fsm_intg.de = fault_code[FaultCtrlFsm];
  assign hw2reg.fault_status.ctrl_fsm_chk.de  = fault_code[FaultCtrlFsmChk];
  assign hw2reg.fault_status.ctrl_fsm_cnt.de  = fault_code[FaultCtrlCnt];
  assign hw2reg.fault_status.reseed_cnt.de    = fault_code[FaultReseedCnt];
  assign hw2reg.fault_status.side_ctrl_fsm.de = fault_code[FaultSideFsm];
  assign hw2reg.fault_status.side_ctrl_sel.de = fault_code[FaultSideSel];
  assign hw2reg.fault_status.key_ecc.de       = fault_code[FaultKeyEcc];
  assign hw2reg.fault_status.cmd.d            = 1'b1;
  assign hw2reg.fault_status.kmac_fsm.d       = 1'b1;
  assign hw2reg.fault_status.kmac_done.d      = 1'b1;
  assign hw2reg.fault_status.kmac_op.d        = 1'b1;
  assign hw2reg.fault_status.kmac_out.d       = 1'b1;
  assign hw2reg.fault_status.regfile_intg.d   = 1'b1;
  assign hw2reg.fault_status.shadow.d         = 1'b1;
  assign hw2reg.fault_status.ctrl_fsm_intg.d  = 1'b1;
  assign hw2reg.fault_status.ctrl_fsm_chk.d   = 1'b1;
  assign hw2reg.fault_status.ctrl_fsm_cnt.d   = 1'b1;
  assign hw2reg.fault_status.reseed_cnt.d     = 1'b1;
  assign hw2reg.fault_status.side_ctrl_fsm.d  = 1'b1;
  assign hw2reg.fault_status.side_ctrl_sel.d  = 1'b1;
  assign hw2reg.fault_status.key_ecc.d        = 1'b1;

  // There are two types of alerts
  // - alerts for hardware errors, these could not have been generated by software.
  // - alerts for errors that may have been generated by software.

  logic fault_errs, fault_err_req_q, fault_err_req_d, fault_err_ack;
  logic op_errs, op_err_req_q, op_err_req_d, op_err_ack;

  // Fault status can happen independently of any operation
  assign fault_errs = |reg2hw.fault_status;

  assign fault_err_req_d = fault_errs    ? 1'b1 :
                           fault_err_ack ? 1'b0 : fault_err_req_q;

  assign op_errs = |err_code;
  assign op_err_req_d = op_errs    ? 1'b1 :
                        op_err_ack ? 1'b0 : op_err_req_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      fault_err_req_q <= '0;
      op_err_req_q <= '0;
    end else begin
      fault_err_req_q <= fault_err_req_d;
      op_err_req_q <= op_err_req_d;
    end
  end

  logic fault_alert_test;
  assign fault_alert_test = reg2hw.alert_test.fatal_fault_err.q &
                            reg2hw.alert_test.fatal_fault_err.qe;
  prim_alert_sender #(
    .AsyncOn(AlertAsyncOn[1]),
    .IsFatal(1)
  ) u_fault_alert (
    .clk_i,
    .rst_ni,
    .alert_test_i(fault_alert_test),
    .alert_req_i(fault_err_req_q),
    .alert_ack_o(fault_err_ack),
    .alert_state_o(),
    .alert_rx_i(alert_rx_i[1]),
    .alert_tx_o(alert_tx_o[1])
  );

  logic op_err_alert_test;
  assign op_err_alert_test = reg2hw.alert_test.recov_operation_err.q &
                             reg2hw.alert_test.recov_operation_err.qe;
  prim_alert_sender #(
    .AsyncOn(AlertAsyncOn[0]),
    .IsFatal(0)
  ) u_op_err_alert (
    .clk_i,
    .rst_ni,
    .alert_test_i(op_err_alert_test),
    .alert_req_i(op_err_req_q),
    .alert_ack_o(op_err_ack),
    .alert_state_o(),
    .alert_rx_i(alert_rx_i[0]),
    .alert_tx_o(alert_tx_o[0])
  );

  // known asserts
  `ASSERT_KNOWN(TlDValidKnownO_A, tl_o.d_valid)
  `ASSERT_KNOWN(TlAReadyKnownO_A, tl_o.a_ready)
  `ASSERT_KNOWN(IntrKnownO_A, intr_op_done_o)
  `ASSERT_KNOWN(AlertKnownO_A, alert_tx_o)

  `ASSERT_KNOWN(AesKeyKnownO_A,  aes_key_o)
  `ASSERT_KNOWN(KmacKeyKnownO_A, kmac_key_o)
  `ASSERT_KNOWN(OtbnKeyKnownO_A, otbn_key_o)
  `ASSERT_KNOWN(KmacDataKnownO_A, kmac_data_o)


  // kmac parameter consistency
  // Both modules must be consistent with regards to masking assumptions
  logic unused_kmac_en_masking;
  assign unused_kmac_en_masking = kmac_en_masking_i;

  `ASSERT_INIT_NET(KmacMaskCheck_A, KmacEnMasking == kmac_en_masking_i)

  // Ensure all parameters are consistent
  `ASSERT_INIT(FaultCntMatch_A, FaultLastPos == AsyncFaultLastIdx + SyncFaultLastIdx)
  `ASSERT_INIT(ErrCntMatch_A, ErrLastPos == AsyncErrLastIdx + SyncErrLastIdx)
  `ASSERT_INIT(StageMatch_A, KeyMgrStages == Disable)

  `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CtrlCntAlertCheck_A, u_ctrl.u_cnt, alert_tx_o[1])
  `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(KmacIfCntAlertCheck_A, u_kmac_if.u_cnt, alert_tx_o[1])
  `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(ReseedCtrlCntAlertCheck_A, u_reseed_ctrl.u_reseed_cnt,
                                         alert_tx_o[1])
  `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(CtrlMainFsmCheck_A, u_ctrl.u_state_regs, alert_tx_o[1])
  `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(CtrlDataFsmCheck_A,
      u_ctrl.u_data_en.u_state_regs, alert_tx_o[1])
  `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(CtrlOpFsmCheck_A,
      u_ctrl.u_op_state.u_state_regs, alert_tx_o[1])
  `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(KmacIfFsmCheck_A, u_kmac_if.u_state_regs, alert_tx_o[1])
  `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(SideloadCtrlFsmCheck_A,
      u_sideload_ctrl.u_state_regs, alert_tx_o[1])

  // Alert assertions for reg_we onehot check
  `ASSERT_PRIM_REG_WE_ONEHOT_ERROR_TRIGGER_ALERT(RegWeOnehotCheck_A, u_reg, alert_tx_o[1])
endmodule // keymgr

================================== Ai Message ==================================

[{'text': 'Let me also examine the keymgr_input_checks module to understand the security checks:', 'type': 'text'}, {'id': 'toolu_01FmNMphx2fZRRL7N8HTBC6v', 'input': {'file_path': '/home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/hw/ip/keymgr/rtl/keymgr_input_checks.sv'}, 'name': 'read_file_from_host', 'type': 'tool_use'}]
Tool Calls:
  read_file_from_host (toolu_01FmNMphx2fZRRL7N8HTBC6v)
 Call ID: toolu_01FmNMphx2fZRRL7N8HTBC6v
  Args:
    file_path: /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/hw/ip/keymgr/rtl/keymgr_input_checks.sv
================================= Tool Message =================================
Name: read_file_from_host

// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Key manager input checks
// Checks input data for errors

`include "prim_assert.sv"

// We should also check for input validity
module keymgr_input_checks import keymgr_pkg::*; #(
  parameter bit KmacEnMasking = 1'b1
) (
  input rom_ctrl_pkg::keymgr_data_t rom_digest_i,
  input [2**StageWidth-1:0][31:0] max_key_versions_i,
  input keymgr_stage_e stage_sel_i,
  input hw_key_req_t key_i,
  input [31:0] key_version_i,
  input [KeyWidth-1:0] creator_seed_i,
  input [KeyWidth-1:0] owner_seed_i,
  input [DevIdWidth-1:0] devid_i,
  input [HealthStateWidth-1:0] health_state_i,
  output logic creator_seed_vld_o,
  output logic owner_seed_vld_o,
  output logic devid_vld_o,
  output logic health_state_vld_o,
  output logic key_version_vld_o,
  output logic key_vld_o,
  output logic rom_digest_vld_o
);

  logic [31:0] cur_max_key_version;
  assign cur_max_key_version = max_key_versions_i[stage_sel_i];

  // key version must be smaller than or equal to max version
  assign key_version_vld_o = key_version_i <= cur_max_key_version;

  // general data check
  logic [MaxWidth-1:0] creator_seed_padded, owner_seed_padded, devid_padded, health_state_padded;

  prim_msb_extend #(
    .InWidth(KeyWidth),
    .OutWidth(MaxWidth)
  ) u_creator_seed (
    .in_i(creator_seed_i),
    .out_o(creator_seed_padded)
  );

  prim_msb_extend #(
    .InWidth(KeyWidth),
    .OutWidth(MaxWidth)
  ) u_owner_seed (
    .in_i(owner_seed_i),
    .out_o(owner_seed_padded)
  );

  prim_msb_extend #(
    .InWidth(DevIdWidth),
    .OutWidth(MaxWidth)
  ) u_devid (
    .in_i(devid_i),
    .out_o(devid_padded)
  );

  prim_msb_extend #(
    .InWidth(HealthStateWidth),
    .OutWidth(MaxWidth)
  ) u_health_state (
    .in_i(health_state_i),
    .out_o(health_state_padded)
  );

  assign creator_seed_vld_o = valid_chk(creator_seed_padded);
  assign owner_seed_vld_o = valid_chk(owner_seed_padded);
  assign devid_vld_o = valid_chk(devid_padded);
  assign health_state_vld_o = valid_chk(health_state_padded);

  // key check
  logic unused_key_vld;
  assign unused_key_vld = key_i.valid;

  localparam int KeyShares = KmacEnMasking ? Shares : 1;
  logic [KeyShares-1:0][MaxWidth-1:0] key_padded;
  logic [KeyShares-1:0] key_chk;

  for (genvar i = 0; i < KeyShares; i++) begin : gen_key_chk
    prim_msb_extend #(
      .InWidth(KeyWidth),
      .OutWidth(MaxWidth)
    ) u_key_pad (
      .in_i(key_i.key[i]),
      .out_o(key_padded[i])
    );

    assign key_chk[i] = valid_chk(key_padded[i]);
  end

  assign key_vld_o = &key_chk;

  // rom digest check
  assign rom_digest_vld_o = rom_digest_i.valid &
                            valid_chk(MaxWidth'(rom_digest_i.data));

  // checks for all 0's or all 1's of value
  function automatic logic valid_chk (logic [MaxWidth-1:0] value);

    return |value & ~&value;

  endfunction // valid_chk


endmodule // keymgr_input_checks

================================== Ai Message ==================================

Based on my analysis of the keymgr IP and the test results, I can provide the following security assessment:

# Security Analysis of the keymgr IP

## Summary of Findings

The verilator tests for the keymgr IP show several failing tests, but these failures appear to be related to test environment setup rather than actual security vulnerabilities in the RTL code. The tests are failing with "fatal reset triggered" messages, which is expected behavior when the tests are requesting resets to make OTP partitions accessible.

## Key Security Features Identified

After examining the RTL code, I can identify several security features implemented in the keymgr IP:

1. **Input Validation Checks**: The `keymgr_input_checks` module performs comprehensive validation of input data, including:
   - Checking key versions against maximum allowed versions
   - Validating creator and owner seeds
   - Validating device ID and health state
   - Ensuring keys are not all 0's or all 1's (which would be weak keys)

2. **Secure State Machine**: The keymgr implements a secure state machine with proper transitions between key states (Creator, OwnerInt, Owner).

3. **Side-Channel Attack Protections**:
   - Masking is implemented for KMAC operations (controlled by `KmacEnMasking` parameter)
   - The design uses share-based operations to protect against power analysis attacks

4. **Fault Detection**:
   - Multiple error detection mechanisms are implemented
   - Alerts are generated for both hardware errors and potential software-induced errors
   - FSM integrity checks using `prim_fsm` modules with error detection

5. **Key Isolation**:
   - Hardware keys are isolated from software access
   - Separate key derivation paths for different purposes (attestation, sealing, etc.)

6. **Redundancy and Consistency Checks**:
   - The code includes several SEC_CM (Security Countermeasure) annotations indicating redundancy checks
   - Shadow registers are used for critical configuration values

## No Critical Security Issues Found

The failing tests do not indicate security vulnerabilities in the RTL code itself. The failures appear to be related to the test environment setup, where tests are requesting resets to make OTP partitions accessible, which is expected behavior.

The RTL code shows a well-designed security architecture with multiple layers of protection:
- Input validation
- Secure state transitions
- Protection against side-channel attacks
- Fault detection and alerts
- Key isolation

## Recommendations

While no critical security issues were identified, here are some recommendations for further security assurance:

1. Complete the verilator tests to ensure full coverage of the keymgr functionality
2. Ensure that the key derivation paths are properly isolated and cannot be manipulated
3. Verify that the alert mechanisms are properly connected to the system-level alert handler
4. Conduct formal verification of the security properties of the keymgr IP

In conclusion, the keymgr IP appears to be well-designed from a security perspective, with multiple layers of protection against various attack vectors. The failing tests do not indicate security vulnerabilities in the RTL code itself.
================================= Tool Message =================================
Name: run_verilator_agent

Based on my analysis of the keymgr IP and the test results, I can provide the following security assessment:

# Security Analysis of the keymgr IP

## Summary of Findings

The verilator tests for the keymgr IP show several failing tests, but these failures appear to be related to test environment setup rather than actual security vulnerabilities in the RTL code. The tests are failing with "fatal reset triggered" messages, which is expected behavior when the tests are requesting resets to make OTP partitions accessible.

## Key Security Features Identified

After examining the RTL code, I can identify several security features implemented in the keymgr IP:

1. **Input Validation Checks**: The `keymgr_input_checks` module performs comprehensive validation of input data, including:
   - Checking key versions against maximum allowed versions
   - Validating creator and owner seeds
   - Validating device ID and health state
   - Ensuring keys are not all 0's or all 1's (which would be weak keys)

2. **Secure State Machine**: The keymgr implements a secure state machine with proper transitions between key states (Creator, OwnerInt, Owner).

3. **Side-Channel Attack Protections**:
   - Masking is implemented for KMAC operations (controlled by `KmacEnMasking` parameter)
   - The design uses share-based operations to protect against power analysis attacks

4. **Fault Detection**:
   - Multiple error detection mechanisms are implemented
   - Alerts are generated for both hardware errors and potential software-induced errors
   - FSM integrity checks using `prim_fsm` modules with error detection

5. **Key Isolation**:
   - Hardware keys are isolated from software access
   - Separate key derivation paths for different purposes (attestation, sealing, etc.)

6. **Redundancy and Consistency Checks**:
   - The code includes several SEC_CM (Security Countermeasure) annotations indicating redundancy checks
   - Shadow registers are used for critical configuration values

## No Critical Security Issues Found

The failing tests do not indicate security vulnerabilities in the RTL code itself. The failures appear to be related to the test environment setup, where tests are requesting resets to make OTP partitions accessible, which is expected behavior.

The RTL code shows a well-designed security architecture with multiple layers of protection:
- Input validation
- Secure state transitions
- Protection against side-channel attacks
- Fault detection and alerts
- Key isolation

## Recommendations

While no critical security issues were identified, here are some recommendations for further security assurance:

1. Complete the verilator tests to ensure full coverage of the keymgr functionality
2. Ensure that the key derivation paths are properly isolated and cannot be manipulated
3. Verify that the alert mechanisms are properly connected to the system-level alert handler
4. Conduct formal verification of the security properties of the keymgr IP

In conclusion, the keymgr IP appears to be well-designed from a security perspective, with multiple layers of protection against various attack vectors. The failing tests do not indicate security vulnerabilities in the RTL code itself.
================================== Ai Message ==================================
Tool Calls:
  run_linter_agent (call_LCmgws9acFYKVRu5lWjjP3M6)
 Call ID: call_LCmgws9acFYKVRu5lWjjP3M6
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv
    top_module: keymgr_reg_top
    security_objective: register interface security, shadow register, access policy, privilege escalation
================================ Human Message =================================

Are there security concerns related to register interface security, shadow register, access policy, privilege escalation in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv

    And the top module is:

    keymgr_reg_top

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Register Top module auto-generated by `reggen`

`include "prim_assert.sv"

module keymgr_reg_top (
  input clk_i,
  input rst_ni,
  input rst_shadowed_ni,
  input  tlul_pkg::tl_h2d_t tl_i,
  output tlul_pkg::tl_d2h_t tl_o,
  // To HW
  output keymgr_reg_pkg::keymgr_reg2hw_t reg2hw, // Write
  input  keymgr_reg_pkg::keymgr_hw2reg_t hw2reg, // Read

  output logic shadowed_storage_err_o,
  output logic shadowed_update_err_o,

  // Integrity check errors
  output logic intg_err_o
);

  import keymgr_reg_pkg::* ;

  localparam int AW = 8;
  localparam int DW = 32;
  localparam int DBW = DW/8;                    // Byte Width

  // register signals
  logic           reg_we;
  logic           reg_re;
  logic [AW-1:0]  reg_addr;
  logic [DW-1:0]  reg_wdata;
  logic [DBW-1:0] reg_be;
  logic [DW-1:0]  reg_rdata;
  logic           reg_error;

  logic          addrmiss, wr_err;

  logic [DW-1:0] reg_rdata_next;
  logic reg_busy;

  tlul_pkg::tl_h2d_t tl_reg_h2d;
  tlul_pkg::tl_d2h_t tl_reg_d2h;


  // incoming payload check
  logic intg_err;
  tlul_cmd_intg_chk u_chk (
    .tl_i(tl_i),
    .err_o(intg_err)
  );

  // also check for spurious write enables
  logic reg_we_err;
  logic [62:0] reg_we_check;
  prim_reg_we_check #(
    .OneHotWidth(63)
  ) u_prim_reg_we_check (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .oh_i  (reg_we_check),
    .en_i  (reg_we && !addrmiss),
    .err_o (reg_we_err)
  );

  logic err_q;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      err_q <= '0;
    end else if (intg_err || reg_we_err) begin
      err_q <= 1'b1;
    end
  end

  // integrity error output is permanent and should be used for alert generation
  // register errors are transactional
  assign intg_err_o = err_q | intg_err | reg_we_err;

  // outgoing integrity generation
  tlul_pkg::tl_d2h_t tl_o_pre;
  tlul_rsp_intg_gen #(
    .EnableRspIntgGen(1),
    .EnableDataIntgGen(1)
  ) u_rsp_intg_gen (
    .tl_i(tl_o_pre),
    .tl_o(tl_o)
  );

  assign tl_reg_h2d = tl_i;
  assign tl_o_pre   = tl_reg_d2h;

  tlul_adapter_reg #(
    .RegAw(AW),
    .RegDw(DW),
    .EnableDataIntgGen(0)
  ) u_reg_if (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),

    .tl_i (tl_reg_h2d),
    .tl_o (tl_reg_d2h),

    .en_ifetch_i(prim_mubi_pkg::MuBi4False),
    .intg_error_o(),

    .we_o    (reg_we),
    .re_o    (reg_re),
    .addr_o  (reg_addr),
    .wdata_o (reg_wdata),
    .be_o    (reg_be),
    .busy_i  (reg_busy),
    .rdata_i (reg_rdata),
    .error_i (reg_error)
  );

  // cdc oversampling signals

  assign reg_rdata = reg_rdata_next ;
  assign reg_error = addrmiss | wr_err | intg_err;

  // Define SW related signals
  // Format: <reg>_<field>_{wd|we|qs}
  //        or <reg>_{wd|we|qs} if field == 1 or 0
  logic intr_state_we;
  logic intr_state_qs;
  logic intr_state_wd;
  logic intr_enable_we;
  logic intr_enable_qs;
  logic intr_enable_wd;
  logic intr_test_we;
  logic intr_test_wd;
  logic alert_test_we;
  logic alert_test_recov_operation_err_wd;
  logic alert_test_fatal_fault_err_wd;
  logic cfg_regwen_re;
  logic cfg_regwen_qs;
  logic start_we;
  logic start_qs;
  logic start_wd;
  logic control_shadowed_re;
  logic control_shadowed_we;
  logic [2:0] control_shadowed_operation_qs;
  logic [2:0] control_shadowed_operation_wd;
  logic control_shadowed_operation_storage_err;
  logic control_shadowed_operation_update_err;
  logic control_shadowed_cdi_sel_qs;
  logic control_shadowed_cdi_sel_wd;
  logic control_shadowed_cdi_sel_storage_err;
  logic control_shadowed_cdi_sel_update_err;
  logic [1:0] control_shadowed_dest_sel_qs;
  logic [1:0] control_shadowed_dest_sel_wd;
  logic control_shadowed_dest_sel_storage_err;
  logic control_shadowed_dest_sel_update_err;
  logic sideload_clear_we;
  logic [2:0] sideload_clear_qs;
  logic [2:0] sideload_clear_wd;
  logic reseed_interval_regwen_we;
  logic reseed_interval_regwen_qs;
  logic reseed_interval_regwen_wd;
  logic reseed_interval_shadowed_re;
  logic reseed_interval_shadowed_we;
  logic [15:0] reseed_interval_shadowed_qs;
  logic [15:0] reseed_interval_shadowed_wd;
  logic reseed_interval_shadowed_storage_err;
  logic reseed_interval_shadowed_update_err;
  logic sw_binding_regwen_re;
  logic sw_binding_regwen_we;
  logic sw_binding_regwen_qs;
  logic sw_binding_regwen_wd;
  logic sealing_sw_binding_0_we;
  logic [31:0] sealing_sw_binding_0_qs;
  logic [31:0] sealing_sw_binding_0_wd;
  logic sealing_sw_binding_1_we;
  logic [31:0] sealing_sw_binding_1_qs;
  logic [31:0] sealing_sw_binding_1_wd;
  logic sealing_sw_binding_2_we;
  logic [31:0] sealing_sw_binding_2_qs;
  logic [31:0] sealing_sw_binding_2_wd;
  logic sealing_sw_binding_3_we;
  logic [31:0] sealing_sw_binding_3_qs;
  logic [31:0] sealing_sw_binding_3_wd;
  logic sealing_sw_binding_4_we;
  logic [31:0] sealing_sw_binding_4_qs;
  logic [31:0] sealing_sw_binding_4_wd;
  logic sealing_sw_binding_5_we;
  logic [31:0] sealing_sw_binding_5_qs;
  logic [31:0] sealing_sw_binding_5_wd;
  logic sealing_sw_binding_6_we;
  logic [31:0] sealing_sw_binding_6_qs;
  logic [31:0] sealing_sw_binding_6_wd;
  logic sealing_sw_binding_7_we;
  logic [31:0] sealing_sw_binding_7_qs;
  logic [31:0] sealing_sw_binding_7_wd;
  logic attest_sw_binding_0_we;
  logic [31:0] attest_sw_binding_0_qs;
  logic [31:0] attest_sw_binding_0_wd;
  logic attest_sw_binding_1_we;
  logic [31:0] attest_sw_binding_1_qs;
  logic [31:0] attest_sw_binding_1_wd;
  logic attest_sw_binding_2_we;
  logic [31:0] attest_sw_binding_2_qs;
  logic [31:0] attest_sw_binding_2_wd;
  logic attest_sw_binding_3_we;
  logic [31:0] attest_sw_binding_3_qs;
  logic [31:0] attest_sw_binding_3_wd;
  logic attest_sw_binding_4_we;
  logic [31:0] attest_sw_binding_4_qs;
  logic [31:0] attest_sw_binding_4_wd;
  logic attest_sw_binding_5_we;
  logic [31:0] attest_sw_binding_5_qs;
  logic [31:0] attest_sw_binding_5_wd;
  logic attest_sw_binding_6_we;
  logic [31:0] attest_sw_binding_6_qs;
  logic [31:0] attest_sw_binding_6_wd;
  logic attest_sw_binding_7_we;
  logic [31:0] attest_sw_binding_7_qs;
  logic [31:0] attest_sw_binding_7_wd;
  logic salt_0_we;
  logic [31:0] salt_0_qs;
  logic [31:0] salt_0_wd;
  logic salt_1_we;
  logic [31:0] salt_1_qs;
  logic [31:0] salt_1_wd;
  logic salt_2_we;
  logic [31:0] salt_2_qs;
  logic [31:0] salt_2_wd;
  logic salt_3_we;
  logic [31:0] salt_3_qs;
  logic [31:0] salt_3_wd;
  logic salt_4_we;
  logic [31:0] salt_4_qs;
  logic [31:0] salt_4_wd;
  logic salt_5_we;
  logic [31:0] salt_5_qs;
  logic [31:0] salt_5_wd;
  logic salt_6_we;
  logic [31:0] salt_6_qs;
  logic [31:0] salt_6_wd;
  logic salt_7_we;
  logic [31:0] salt_7_qs;
  logic [31:0] salt_7_wd;
  logic key_version_we;
  logic [31:0] key_version_qs;
  logic [31:0] key_version_wd;
  logic max_creator_key_ver_regwen_we;
  logic max_creator_key_ver_regwen_qs;
  logic max_creator_key_ver_regwen_wd;
  logic max_creator_key_ver_shadowed_re;
  logic max_creator_key_ver_shadowed_we;
  logic [31:0] max_creator_key_ver_shadowed_qs;
  logic [31:0] max_creator_key_ver_shadowed_wd;
  logic max_creator_key_ver_shadowed_storage_err;
  logic max_creator_key_ver_shadowed_update_err;
  logic max_owner_int_key_ver_regwen_we;
  logic max_owner_int_key_ver_regwen_qs;
  logic max_owner_int_key_ver_regwen_wd;
  logic max_owner_int_key_ver_shadowed_re;
  logic max_owner_int_key_ver_shadowed_we;
  logic [31:0] max_owner_int_key_ver_shadowed_qs;
  logic [31:0] max_owner_int_key_ver_shadowed_wd;
  logic max_owner_int_key_ver_shadowed_storage_err;
  logic max_owner_int_key_ver_shadowed_update_err;
  logic max_owner_key_ver_regwen_we;
  logic max_owner_key_ver_regwen_qs;
  logic max_owner_key_ver_regwen_wd;
  logic max_owner_key_ver_shadowed_re;
  logic max_owner_key_ver_shadowed_we;
  logic [31:0] max_owner_key_ver_shadowed_qs;
  logic [31:0] max_owner_key_ver_shadowed_wd;
  logic max_owner_key_ver_shadowed_storage_err;
  logic max_owner_key_ver_shadowed_update_err;
  logic sw_share0_output_0_re;
  logic [31:0] sw_share0_output_0_qs;
  logic [31:0] sw_share0_output_0_wd;
  logic sw_share0_output_1_re;
  logic [31:0] sw_share0_output_1_qs;
  logic [31:0] sw_share0_output_1_wd;
  logic sw_share0_output_2_re;
  logic [31:0] sw_share0_output_2_qs;
  logic [31:0] sw_share0_output_2_wd;
  logic sw_share0_output_3_re;
  logic [31:0] sw_share0_output_3_qs;
  logic [31:0] sw_share0_output_3_wd;
  logic sw_share0_output_4_re;
  logic [31:0] sw_share0_output_4_qs;
  logic [31:0] sw_share0_output_4_wd;
  logic sw_share0_output_5_re;
  logic [31:0] sw_share0_output_5_qs;
  logic [31:0] sw_share0_output_5_wd;
  logic sw_share0_output_6_re;
  logic [31:0] sw_share0_output_6_qs;
  logic [31:0] sw_share0_output_6_wd;
  logic sw_share0_output_7_re;
  logic [31:0] sw_share0_output_7_qs;
  logic [31:0] sw_share0_output_7_wd;
  logic sw_share1_output_0_re;
  logic [31:0] sw_share1_output_0_qs;
  logic [31:0] sw_share1_output_0_wd;
  logic sw_share1_output_1_re;
  logic [31:0] sw_share1_output_1_qs;
  logic [31:0] sw_share1_output_1_wd;
  logic sw_share1_output_2_re;
  logic [31:0] sw_share1_output_2_qs;
  logic [31:0] sw_share1_output_2_wd;
  logic sw_share1_output_3_re;
  logic [31:0] sw_share1_output_3_qs;
  logic [31:0] sw_share1_output_3_wd;
  logic sw_share1_output_4_re;
  logic [31:0] sw_share1_output_4_qs;
  logic [31:0] sw_share1_output_4_wd;
  logic sw_share1_output_5_re;
  logic [31:0] sw_share1_output_5_qs;
  logic [31:0] sw_share1_output_5_wd;
  logic sw_share1_output_6_re;
  logic [31:0] sw_share1_output_6_qs;
  logic [31:0] sw_share1_output_6_wd;
  logic sw_share1_output_7_re;
  logic [31:0] sw_share1_output_7_qs;
  logic [31:0] sw_share1_output_7_wd;
  logic [2:0] working_state_qs;
  logic op_status_we;
  logic [1:0] op_status_qs;
  logic [1:0] op_status_wd;
  logic err_code_we;
  logic err_code_invalid_op_qs;
  logic err_code_invalid_op_wd;
  logic err_code_invalid_kmac_input_qs;
  logic err_code_invalid_kmac_input_wd;
  logic err_code_invalid_shadow_update_qs;
  logic err_code_invalid_shadow_update_wd;
  logic fault_status_cmd_qs;
  logic fault_status_kmac_fsm_qs;
  logic fault_status_kmac_done_qs;
  logic fault_status_kmac_op_qs;
  logic fault_status_kmac_out_qs;
  logic fault_status_regfile_intg_qs;
  logic fault_status_shadow_qs;
  logic fault_status_ctrl_fsm_intg_qs;
  logic fault_status_ctrl_fsm_chk_qs;
  logic fault_status_ctrl_fsm_cnt_qs;
  logic fault_status_reseed_cnt_qs;
  logic fault_status_side_ctrl_fsm_qs;
  logic fault_status_side_ctrl_sel_qs;
  logic fault_status_key_ecc_qs;
  logic debug_we;
  logic debug_invalid_creator_seed_qs;
  logic debug_invalid_creator_seed_wd;
  logic debug_invalid_owner_seed_qs;
  logic debug_invalid_owner_seed_wd;
  logic debug_invalid_dev_id_qs;
  logic debug_invalid_dev_id_wd;
  logic debug_invalid_health_state_qs;
  logic debug_invalid_health_state_wd;
  logic debug_invalid_key_version_qs;
  logic debug_invalid_key_version_wd;
  logic debug_invalid_key_qs;
  logic debug_invalid_key_wd;
  logic debug_invalid_digest_qs;
  logic debug_invalid_digest_wd;

  // Register instances
  // R[intr_state]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.de),
    .d      (hw2reg.intr_state.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_qs)
  );


  // R[intr_enable]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_qs)
  );


  // R[intr_test]: V(True)
  logic intr_test_qe;
  logic [0:0] intr_test_flds_we;
  assign intr_test_qe = &intr_test_flds_we;
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[0]),
    .q      (reg2hw.intr_test.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.qe = intr_test_qe;


  // R[alert_test]: V(True)
  logic alert_test_qe;
  logic [1:0] alert_test_flds_we;
  assign alert_test_qe = &alert_test_flds_we;
  //   F[recov_operation_err]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_recov_operation_err (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_recov_operation_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[0]),
    .q      (reg2hw.alert_test.recov_operation_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.recov_operation_err.qe = alert_test_qe;

  //   F[fatal_fault_err]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_fatal_fault_err (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_fatal_fault_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[1]),
    .q      (reg2hw.alert_test.fatal_fault_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.fatal_fault_err.qe = alert_test_qe;


  // R[cfg_regwen]: V(True)
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_regwen (
    .re     (cfg_regwen_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.cfg_regwen.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (cfg_regwen_qs)
  );


  // R[start]: V(False)
  // Create REGWEN-gated WE signal
  logic start_gated_we;
  assign start_gated_we = start_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_start (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (start_gated_we),
    .wd     (start_wd),

    // from internal hardware
    .de     (hw2reg.start.de),
    .d      (hw2reg.start.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.start.q),
    .ds     (),

    // to register interface (read)
    .qs     (start_qs)
  );


  // R[control_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic control_shadowed_gated_we;
  assign control_shadowed_gated_we = control_shadowed_we & cfg_regwen_qs;
  //   F[operation]: 6:4
  prim_subreg_shadow #(
    .DW      (3),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (3'h1),
    .Mubi    (1'b0)
  ) u_control_shadowed_operation (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (control_shadowed_re),
    .we     (control_shadowed_gated_we),
    .wd     (control_shadowed_operation_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.control_shadowed.operation.q),
    .ds     (),

    // to register interface (read)
    .qs     (control_shadowed_operation_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (control_shadowed_operation_update_err),
    .err_storage (control_shadowed_operation_storage_err)
  );

  //   F[cdi_sel]: 7:7
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_control_shadowed_cdi_sel (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (control_shadowed_re),
    .we     (control_shadowed_gated_we),
    .wd     (control_shadowed_cdi_sel_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.control_shadowed.cdi_sel.q),
    .ds     (),

    // to register interface (read)
    .qs     (control_shadowed_cdi_sel_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (control_shadowed_cdi_sel_update_err),
    .err_storage (control_shadowed_cdi_sel_storage_err)
  );

  //   F[dest_sel]: 13:12
  prim_subreg_shadow #(
    .DW      (2),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (2'h0),
    .Mubi    (1'b0)
  ) u_control_shadowed_dest_sel (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (control_shadowed_re),
    .we     (control_shadowed_gated_we),
    .wd     (control_shadowed_dest_sel_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.control_shadowed.dest_sel.q),
    .ds     (),

    // to register interface (read)
    .qs     (control_shadowed_dest_sel_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (control_shadowed_dest_sel_update_err),
    .err_storage (control_shadowed_dest_sel_storage_err)
  );


  // R[sideload_clear]: V(False)
  // Create REGWEN-gated WE signal
  logic sideload_clear_gated_we;
  assign sideload_clear_gated_we = sideload_clear_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (3),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (3'h0),
    .Mubi    (1'b0)
  ) u_sideload_clear (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sideload_clear_gated_we),
    .wd     (sideload_clear_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sideload_clear.q),
    .ds     (),

    // to register interface (read)
    .qs     (sideload_clear_qs)
  );


  // R[reseed_interval_regwen]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_reseed_interval_regwen (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (reseed_interval_regwen_we),
    .wd     (reseed_interval_regwen_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (reseed_interval_regwen_qs)
  );


  // R[reseed_interval_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic reseed_interval_shadowed_gated_we;
  assign reseed_interval_shadowed_gated_we =
    reseed_interval_shadowed_we & reseed_interval_regwen_qs;
  prim_subreg_shadow #(
    .DW      (16),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (16'h100),
    .Mubi    (1'b0)
  ) u_reseed_interval_shadowed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (reseed_interval_shadowed_re),
    .we     (reseed_interval_shadowed_gated_we),
    .wd     (reseed_interval_shadowed_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.reseed_interval_shadowed.q),
    .ds     (),

    // to register interface (read)
    .qs     (reseed_interval_shadowed_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (reseed_interval_shadowed_update_err),
    .err_storage (reseed_interval_shadowed_storage_err)
  );


  // R[sw_binding_regwen]: V(True)
  logic sw_binding_regwen_qe;
  logic [0:0] sw_binding_regwen_flds_we;
  assign sw_binding_regwen_qe = &sw_binding_regwen_flds_we;
  prim_subreg_ext #(
    .DW    (1)
  ) u_sw_binding_regwen (
    .re     (sw_binding_regwen_re),
    .we     (sw_binding_regwen_we),
    .wd     (sw_binding_regwen_wd),
    .d      (hw2reg.sw_binding_regwen.d),
    .qre    (),
    .qe     (sw_binding_regwen_flds_we[0]),
    .q      (reg2hw.sw_binding_regwen.q),
    .ds     (),
    .qs     (sw_binding_regwen_qs)
  );
  assign reg2hw.sw_binding_regwen.qe = sw_binding_regwen_qe;


  // Subregister 0 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_0]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_0_gated_we;
  assign sealing_sw_binding_0_gated_we = sealing_sw_binding_0_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_0_gated_we),
    .wd     (sealing_sw_binding_0_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[0].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_0_qs)
  );


  // Subregister 1 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_1]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_1_gated_we;
  assign sealing_sw_binding_1_gated_we = sealing_sw_binding_1_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_1_gated_we),
    .wd     (sealing_sw_binding_1_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[1].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_1_qs)
  );


  // Subregister 2 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_2]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_2_gated_we;
  assign sealing_sw_binding_2_gated_we = sealing_sw_binding_2_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_2_gated_we),
    .wd     (sealing_sw_binding_2_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[2].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_2_qs)
  );


  // Subregister 3 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_3]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_3_gated_we;
  assign sealing_sw_binding_3_gated_we = sealing_sw_binding_3_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_3_gated_we),
    .wd     (sealing_sw_binding_3_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[3].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_3_qs)
  );


  // Subregister 4 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_4]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_4_gated_we;
  assign sealing_sw_binding_4_gated_we = sealing_sw_binding_4_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_4_gated_we),
    .wd     (sealing_sw_binding_4_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[4].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_4_qs)
  );


  // Subregister 5 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_5]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_5_gated_we;
  assign sealing_sw_binding_5_gated_we = sealing_sw_binding_5_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_5_gated_we),
    .wd     (sealing_sw_binding_5_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[5].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_5_qs)
  );


  // Subregister 6 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_6]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_6_gated_we;
  assign sealing_sw_binding_6_gated_we = sealing_sw_binding_6_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_6_gated_we),
    .wd     (sealing_sw_binding_6_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[6].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_6_qs)
  );


  // Subregister 7 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_7]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_7_gated_we;
  assign sealing_sw_binding_7_gated_we = sealing_sw_binding_7_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_7_gated_we),
    .wd     (sealing_sw_binding_7_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[7].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_7_qs)
  );


  // Subregister 0 of Multireg attest_sw_binding
  // R[attest_sw_binding_0]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_0_gated_we;
  assign attest_sw_binding_0_gated_we = attest_sw_binding_0_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_0_gated_we),
    .wd     (attest_sw_binding_0_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[0].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_0_qs)
  );


  // Subregister 1 of Multireg attest_sw_binding
  // R[attest_sw_binding_1]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_1_gated_we;
  assign attest_sw_binding_1_gated_we = attest_sw_binding_1_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_1_gated_we),
    .wd     (attest_sw_binding_1_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[1].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_1_qs)
  );


  // Subregister 2 of Multireg attest_sw_binding
  // R[attest_sw_binding_2]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_2_gated_we;
  assign attest_sw_binding_2_gated_we = attest_sw_binding_2_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_2_gated_we),
    .wd     (attest_sw_binding_2_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[2].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_2_qs)
  );


  // Subregister 3 of Multireg attest_sw_binding
  // R[attest_sw_binding_3]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_3_gated_we;
  assign attest_sw_binding_3_gated_we = attest_sw_binding_3_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_3_gated_we),
    .wd     (attest_sw_binding_3_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[3].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_3_qs)
  );


  // Subregister 4 of Multireg attest_sw_binding
  // R[attest_sw_binding_4]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_4_gated_we;
  assign attest_sw_binding_4_gated_we = attest_sw_binding_4_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_4_gated_we),
    .wd     (attest_sw_binding_4_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[4].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_4_qs)
  );


  // Subregister 5 of Multireg attest_sw_binding
  // R[attest_sw_binding_5]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_5_gated_we;
  assign attest_sw_binding_5_gated_we = attest_sw_binding_5_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_5_gated_we),
    .wd     (attest_sw_binding_5_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[5].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_5_qs)
  );


  // Subregister 6 of Multireg attest_sw_binding
  // R[attest_sw_binding_6]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_6_gated_we;
  assign attest_sw_binding_6_gated_we = attest_sw_binding_6_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_6_gated_we),
    .wd     (attest_sw_binding_6_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[6].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_6_qs)
  );


  // Subregister 7 of Multireg attest_sw_binding
  // R[attest_sw_binding_7]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_7_gated_we;
  assign attest_sw_binding_7_gated_we = attest_sw_binding_7_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_7_gated_we),
    .wd     (attest_sw_binding_7_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[7].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_7_qs)
  );


  // Subregister 0 of Multireg salt
  // R[salt_0]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_0_gated_we;
  assign salt_0_gated_we = salt_0_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_0_gated_we),
    .wd     (salt_0_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[0].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_0_qs)
  );


  // Subregister 1 of Multireg salt
  // R[salt_1]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_1_gated_we;
  assign salt_1_gated_we = salt_1_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_1_gated_we),
    .wd     (salt_1_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[1].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_1_qs)
  );


  // Subregister 2 of Multireg salt
  // R[salt_2]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_2_gated_we;
  assign salt_2_gated_we = salt_2_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_2_gated_we),
    .wd     (salt_2_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[2].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_2_qs)
  );


  // Subregister 3 of Multireg salt
  // R[salt_3]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_3_gated_we;
  assign salt_3_gated_we = salt_3_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_3_gated_we),
    .wd     (salt_3_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[3].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_3_qs)
  );


  // Subregister 4 of Multireg salt
  // R[salt_4]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_4_gated_we;
  assign salt_4_gated_we = salt_4_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_4_gated_we),
    .wd     (salt_4_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[4].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_4_qs)
  );


  // Subregister 5 of Multireg salt
  // R[salt_5]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_5_gated_we;
  assign salt_5_gated_we = salt_5_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_5_gated_we),
    .wd     (salt_5_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[5].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_5_qs)
  );


  // Subregister 6 of Multireg salt
  // R[salt_6]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_6_gated_we;
  assign salt_6_gated_we = salt_6_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_6_gated_we),
    .wd     (salt_6_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[6].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_6_qs)
  );


  // Subregister 7 of Multireg salt
  // R[salt_7]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_7_gated_we;
  assign salt_7_gated_we = salt_7_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_7_gated_we),
    .wd     (salt_7_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[7].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_7_qs)
  );


  // Subregister 0 of Multireg key_version
  // R[key_version]: V(False)
  // Create REGWEN-gated WE signal
  logic key_version_gated_we;
  assign key_version_gated_we = key_version_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_key_version (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (key_version_gated_we),
    .wd     (key_version_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.key_version[0].q),
    .ds     (),

    // to register interface (read)
    .qs     (key_version_qs)
  );


  // R[max_creator_key_ver_regwen]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_max_creator_key_ver_regwen (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (max_creator_key_ver_regwen_we),
    .wd     (max_creator_key_ver_regwen_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (max_creator_key_ver_regwen_qs)
  );


  // R[max_creator_key_ver_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic max_creator_key_ver_shadowed_gated_we;
  assign max_creator_key_ver_shadowed_gated_we =
    max_creator_key_ver_shadowed_we & max_creator_key_ver_regwen_qs;
  prim_subreg_shadow #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_max_creator_key_ver_shadowed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (max_creator_key_ver_shadowed_re),
    .we     (max_creator_key_ver_shadowed_gated_we),
    .wd     (max_creator_key_ver_shadowed_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.max_creator_key_ver_shadowed.q),
    .ds     (),

    // to register interface (read)
    .qs     (max_creator_key_ver_shadowed_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (max_creator_key_ver_shadowed_update_err),
    .err_storage (max_creator_key_ver_shadowed_storage_err)
  );


  // R[max_owner_int_key_ver_regwen]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_max_owner_int_key_ver_regwen (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (max_owner_int_key_ver_regwen_we),
    .wd     (max_owner_int_key_ver_regwen_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (max_owner_int_key_ver_regwen_qs)
  );


  // R[max_owner_int_key_ver_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic max_owner_int_key_ver_shadowed_gated_we;
  assign max_owner_int_key_ver_shadowed_gated_we =
    max_owner_int_key_ver_shadowed_we & max_owner_int_key_ver_regwen_qs;
  prim_subreg_shadow #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h1),
    .Mubi    (1'b0)
  ) u_max_owner_int_key_ver_shadowed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (max_owner_int_key_ver_shadowed_re),
    .we     (max_owner_int_key_ver_shadowed_gated_we),
    .wd     (max_owner_int_key_ver_shadowed_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.max_owner_int_key_ver_shadowed.q),
    .ds     (),

    // to register interface (read)
    .qs     (max_owner_int_key_ver_shadowed_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (max_owner_int_key_ver_shadowed_update_err),
    .err_storage (max_owner_int_key_ver_shadowed_storage_err)
  );


  // R[max_owner_key_ver_regwen]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_max_owner_key_ver_regwen (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (max_owner_key_ver_regwen_we),
    .wd     (max_owner_key_ver_regwen_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (max_owner_key_ver_regwen_qs)
  );


  // R[max_owner_key_ver_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic max_owner_key_ver_shadowed_gated_we;
  assign max_owner_key_ver_shadowed_gated_we =
    max_owner_key_ver_shadowed_we & max_owner_key_ver_regwen_qs;
  prim_subreg_shadow #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_max_owner_key_ver_shadowed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (max_owner_key_ver_shadowed_re),
    .we     (max_owner_key_ver_shadowed_gated_we),
    .wd     (max_owner_key_ver_shadowed_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.max_owner_key_ver_shadowed.q),
    .ds     (),

    // to register interface (read)
    .qs     (max_owner_key_ver_shadowed_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (max_owner_key_ver_shadowed_update_err),
    .err_storage (max_owner_key_ver_shadowed_storage_err)
  );


  // Subregister 0 of Multireg sw_share0_output
  // R[sw_share0_output_0]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_0_re),
    .wd     (sw_share0_output_0_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[0].de),
    .d      (hw2reg.sw_share0_output[0].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_0_qs)
  );


  // Subregister 1 of Multireg sw_share0_output
  // R[sw_share0_output_1]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_1_re),
    .wd     (sw_share0_output_1_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[1].de),
    .d      (hw2reg.sw_share0_output[1].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_1_qs)
  );


  // Subregister 2 of Multireg sw_share0_output
  // R[sw_share0_output_2]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_2_re),
    .wd     (sw_share0_output_2_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[2].de),
    .d      (hw2reg.sw_share0_output[2].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_2_qs)
  );


  // Subregister 3 of Multireg sw_share0_output
  // R[sw_share0_output_3]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_3_re),
    .wd     (sw_share0_output_3_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[3].de),
    .d      (hw2reg.sw_share0_output[3].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_3_qs)
  );


  // Subregister 4 of Multireg sw_share0_output
  // R[sw_share0_output_4]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_4_re),
    .wd     (sw_share0_output_4_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[4].de),
    .d      (hw2reg.sw_share0_output[4].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_4_qs)
  );


  // Subregister 5 of Multireg sw_share0_output
  // R[sw_share0_output_5]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_5_re),
    .wd     (sw_share0_output_5_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[5].de),
    .d      (hw2reg.sw_share0_output[5].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_5_qs)
  );


  // Subregister 6 of Multireg sw_share0_output
  // R[sw_share0_output_6]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_6_re),
    .wd     (sw_share0_output_6_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[6].de),
    .d      (hw2reg.sw_share0_output[6].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_6_qs)
  );


  // Subregister 7 of Multireg sw_share0_output
  // R[sw_share0_output_7]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_7_re),
    .wd     (sw_share0_output_7_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[7].de),
    .d      (hw2reg.sw_share0_output[7].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_7_qs)
  );


  // Subregister 0 of Multireg sw_share1_output
  // R[sw_share1_output_0]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_0_re),
    .wd     (sw_share1_output_0_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[0].de),
    .d      (hw2reg.sw_share1_output[0].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_0_qs)
  );


  // Subregister 1 of Multireg sw_share1_output
  // R[sw_share1_output_1]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_1_re),
    .wd     (sw_share1_output_1_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[1].de),
    .d      (hw2reg.sw_share1_output[1].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_1_qs)
  );


  // Subregister 2 of Multireg sw_share1_output
  // R[sw_share1_output_2]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_2_re),
    .wd     (sw_share1_output_2_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[2].de),
    .d      (hw2reg.sw_share1_output[2].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_2_qs)
  );


  // Subregister 3 of Multireg sw_share1_output
  // R[sw_share1_output_3]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_3_re),
    .wd     (sw_share1_output_3_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[3].de),
    .d      (hw2reg.sw_share1_output[3].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_3_qs)
  );


  // Subregister 4 of Multireg sw_share1_output
  // R[sw_share1_output_4]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_4_re),
    .wd     (sw_share1_output_4_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[4].de),
    .d      (hw2reg.sw_share1_output[4].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_4_qs)
  );


  // Subregister 5 of Multireg sw_share1_output
  // R[sw_share1_output_5]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_5_re),
    .wd     (sw_share1_output_5_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[5].de),
    .d      (hw2reg.sw_share1_output[5].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_5_qs)
  );


  // Subregister 6 of Multireg sw_share1_output
  // R[sw_share1_output_6]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_6_re),
    .wd     (sw_share1_output_6_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[6].de),
    .d      (hw2reg.sw_share1_output[6].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_6_qs)
  );


  // Subregister 7 of Multireg sw_share1_output
  // R[sw_share1_output_7]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_7_re),
    .wd     (sw_share1_output_7_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[7].de),
    .d      (hw2reg.sw_share1_output[7].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_7_qs)
  );


  // R[working_state]: V(False)
  prim_subreg #(
    .DW      (3),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (3'h0),
    .Mubi    (1'b0)
  ) u_working_state (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.working_state.de),
    .d      (hw2reg.working_state.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (working_state_qs)
  );


  // R[op_status]: V(False)
  prim_subreg #(
    .DW      (2),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (2'h0),
    .Mubi    (1'b0)
  ) u_op_status (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (op_status_we),
    .wd     (op_status_wd),

    // from internal hardware
    .de     (hw2reg.op_status.de),
    .d      (hw2reg.op_status.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (op_status_qs)
  );


  // R[err_code]: V(False)
  //   F[invalid_op]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_err_code_invalid_op (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (err_code_we),
    .wd     (err_code_invalid_op_wd),

    // from internal hardware
    .de     (hw2reg.err_code.invalid_op.de),
    .d      (hw2reg.err_code.invalid_op.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (err_code_invalid_op_qs)
  );

  //   F[invalid_kmac_input]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_err_code_invalid_kmac_input (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (err_code_we),
    .wd     (err_code_invalid_kmac_input_wd),

    // from internal hardware
    .de     (hw2reg.err_code.invalid_kmac_input.de),
    .d      (hw2reg.err_code.invalid_kmac_input.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (err_code_invalid_kmac_input_qs)
  );

  //   F[invalid_shadow_update]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_err_code_invalid_shadow_update (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (err_code_we),
    .wd     (err_code_invalid_shadow_update_wd),

    // from internal hardware
    .de     (hw2reg.err_code.invalid_shadow_update.de),
    .d      (hw2reg.err_code.invalid_shadow_update.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (err_code_invalid_shadow_update_qs)
  );


  // R[fault_status]: V(False)
  //   F[cmd]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_cmd (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.cmd.de),
    .d      (hw2reg.fault_status.cmd.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.cmd.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_cmd_qs)
  );

  //   F[kmac_fsm]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_kmac_fsm (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.kmac_fsm.de),
    .d      (hw2reg.fault_status.kmac_fsm.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.kmac_fsm.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_kmac_fsm_qs)
  );

  //   F[kmac_done]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_kmac_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.kmac_done.de),
    .d      (hw2reg.fault_status.kmac_done.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.kmac_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_kmac_done_qs)
  );

  //   F[kmac_op]: 3:3
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_kmac_op (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.kmac_op.de),
    .d      (hw2reg.fault_status.kmac_op.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.kmac_op.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_kmac_op_qs)
  );

  //   F[kmac_out]: 4:4
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_kmac_out (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.kmac_out.de),
    .d      (hw2reg.fault_status.kmac_out.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.kmac_out.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_kmac_out_qs)
  );

  //   F[regfile_intg]: 5:5
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_regfile_intg (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.regfile_intg.de),
    .d      (hw2reg.fault_status.regfile_intg.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.regfile_intg.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_regfile_intg_qs)
  );

  //   F[shadow]: 6:6
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_shadow (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.shadow.de),
    .d      (hw2reg.fault_status.shadow.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.shadow.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_shadow_qs)
  );

  //   F[ctrl_fsm_intg]: 7:7
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_ctrl_fsm_intg (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.ctrl_fsm_intg.de),
    .d      (hw2reg.fault_status.ctrl_fsm_intg.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.ctrl_fsm_intg.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_ctrl_fsm_intg_qs)
  );

  //   F[ctrl_fsm_chk]: 8:8
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_ctrl_fsm_chk (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.ctrl_fsm_chk.de),
    .d      (hw2reg.fault_status.ctrl_fsm_chk.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.ctrl_fsm_chk.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_ctrl_fsm_chk_qs)
  );

  //   F[ctrl_fsm_cnt]: 9:9
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_ctrl_fsm_cnt (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.ctrl_fsm_cnt.de),
    .d      (hw2reg.fault_status.ctrl_fsm_cnt.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.ctrl_fsm_cnt.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_ctrl_fsm_cnt_qs)
  );

  //   F[reseed_cnt]: 10:10
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_reseed_cnt (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.reseed_cnt.de),
    .d      (hw2reg.fault_status.reseed_cnt.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.reseed_cnt.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_reseed_cnt_qs)
  );

  //   F[side_ctrl_fsm]: 11:11
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_side_ctrl_fsm (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.side_ctrl_fsm.de),
    .d      (hw2reg.fault_status.side_ctrl_fsm.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.side_ctrl_fsm.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_side_ctrl_fsm_qs)
  );

  //   F[side_ctrl_sel]: 12:12
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_side_ctrl_sel (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.side_ctrl_sel.de),
    .d      (hw2reg.fault_status.side_ctrl_sel.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.side_ctrl_sel.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_side_ctrl_sel_qs)
  );

  //   F[key_ecc]: 13:13
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_key_ecc (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.key_ecc.de),
    .d      (hw2reg.fault_status.key_ecc.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.key_ecc.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_key_ecc_qs)
  );


  // R[debug]: V(False)
  //   F[invalid_creator_seed]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_creator_seed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_creator_seed_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_creator_seed.de),
    .d      (hw2reg.debug.invalid_creator_seed.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_creator_seed_qs)
  );

  //   F[invalid_owner_seed]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_owner_seed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_owner_seed_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_owner_seed.de),
    .d      (hw2reg.debug.invalid_owner_seed.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_owner_seed_qs)
  );

  //   F[invalid_dev_id]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_dev_id (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_dev_id_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_dev_id.de),
    .d      (hw2reg.debug.invalid_dev_id.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_dev_id_qs)
  );

  //   F[invalid_health_state]: 3:3
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_health_state (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_health_state_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_health_state.de),
    .d      (hw2reg.debug.invalid_health_state.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_health_state_qs)
  );

  //   F[invalid_key_version]: 4:4
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_key_version (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_key_version_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_key_version.de),
    .d      (hw2reg.debug.invalid_key_version.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_key_version_qs)
  );

  //   F[invalid_key]: 5:5
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_key (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_key_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_key.de),
    .d      (hw2reg.debug.invalid_key.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_key_qs)
  );

  //   F[invalid_digest]: 6:6
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_digest (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_digest_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_digest.de),
    .d      (hw2reg.debug.invalid_digest.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_digest_qs)
  );



  logic [62:0] addr_hit;
  always_comb begin
    addr_hit = '0;
    addr_hit[ 0] = (reg_addr == KEYMGR_INTR_STATE_OFFSET);
    addr_hit[ 1] = (reg_addr == KEYMGR_INTR_ENABLE_OFFSET);
    addr_hit[ 2] = (reg_addr == KEYMGR_INTR_TEST_OFFSET);
    addr_hit[ 3] = (reg_addr == KEYMGR_ALERT_TEST_OFFSET);
    addr_hit[ 4] = (reg_addr == KEYMGR_CFG_REGWEN_OFFSET);
    addr_hit[ 5] = (reg_addr == KEYMGR_START_OFFSET);
    addr_hit[ 6] = (reg_addr == KEYMGR_CONTROL_SHADOWED_OFFSET);
    addr_hit[ 7] = (reg_addr == KEYMGR_SIDELOAD_CLEAR_OFFSET);
    addr_hit[ 8] = (reg_addr == KEYMGR_RESEED_INTERVAL_REGWEN_OFFSET);
    addr_hit[ 9] = (reg_addr == KEYMGR_RESEED_INTERVAL_SHADOWED_OFFSET);
    addr_hit[10] = (reg_addr == KEYMGR_SW_BINDING_REGWEN_OFFSET);
    addr_hit[11] = (reg_addr == KEYMGR_SEALING_SW_BINDING_0_OFFSET);
    addr_hit[12] = (reg_addr == KEYMGR_SEALING_SW_BINDING_1_OFFSET);
    addr_hit[13] = (reg_addr == KEYMGR_SEALING_SW_BINDING_2_OFFSET);
    addr_hit[14] = (reg_addr == KEYMGR_SEALING_SW_BINDING_3_OFFSET);
    addr_hit[15] = (reg_addr == KEYMGR_SEALING_SW_BINDING_4_OFFSET);
    addr_hit[16] = (reg_addr == KEYMGR_SEALING_SW_BINDING_5_OFFSET);
    addr_hit[17] = (reg_addr == KEYMGR_SEALING_SW_BINDING_6_OFFSET);
    addr_hit[18] = (reg_addr == KEYMGR_SEALING_SW_BINDING_7_OFFSET);
    addr_hit[19] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_0_OFFSET);
    addr_hit[20] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_1_OFFSET);
    addr_hit[21] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_2_OFFSET);
    addr_hit[22] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_3_OFFSET);
    addr_hit[23] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_4_OFFSET);
    addr_hit[24] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_5_OFFSET);
    addr_hit[25] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_6_OFFSET);
    addr_hit[26] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_7_OFFSET);
    addr_hit[27] = (reg_addr == KEYMGR_SALT_0_OFFSET);
    addr_hit[28] = (reg_addr == KEYMGR_SALT_1_OFFSET);
    addr_hit[29] = (reg_addr == KEYMGR_SALT_2_OFFSET);
    addr_hit[30] = (reg_addr == KEYMGR_SALT_3_OFFSET);
    addr_hit[31] = (reg_addr == KEYMGR_SALT_4_OFFSET);
    addr_hit[32] = (reg_addr == KEYMGR_SALT_5_OFFSET);
    addr_hit[33] = (reg_addr == KEYMGR_SALT_6_OFFSET);
    addr_hit[34] = (reg_addr == KEYMGR_SALT_7_OFFSET);
    addr_hit[35] = (reg_addr == KEYMGR_KEY_VERSION_OFFSET);
    addr_hit[36] = (reg_addr == KEYMGR_MAX_CREATOR_KEY_VER_REGWEN_OFFSET);
    addr_hit[37] = (reg_addr == KEYMGR_MAX_CREATOR_KEY_VER_SHADOWED_OFFSET);
    addr_hit[38] = (reg_addr == KEYMGR_MAX_OWNER_INT_KEY_VER_REGWEN_OFFSET);
    addr_hit[39] = (reg_addr == KEYMGR_MAX_OWNER_INT_KEY_VER_SHADOWED_OFFSET);
    addr_hit[40] = (reg_addr == KEYMGR_MAX_OWNER_KEY_VER_REGWEN_OFFSET);
    addr_hit[41] = (reg_addr == KEYMGR_MAX_OWNER_KEY_VER_SHADOWED_OFFSET);
    addr_hit[42] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_0_OFFSET);
    addr_hit[43] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_1_OFFSET);
    addr_hit[44] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_2_OFFSET);
    addr_hit[45] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_3_OFFSET);
    addr_hit[46] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_4_OFFSET);
    addr_hit[47] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_5_OFFSET);
    addr_hit[48] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_6_OFFSET);
    addr_hit[49] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_7_OFFSET);
    addr_hit[50] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_0_OFFSET);
    addr_hit[51] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_1_OFFSET);
    addr_hit[52] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_2_OFFSET);
    addr_hit[53] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_3_OFFSET);
    addr_hit[54] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_4_OFFSET);
    addr_hit[55] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_5_OFFSET);
    addr_hit[56] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_6_OFFSET);
    addr_hit[57] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_7_OFFSET);
    addr_hit[58] = (reg_addr == KEYMGR_WORKING_STATE_OFFSET);
    addr_hit[59] = (reg_addr == KEYMGR_OP_STATUS_OFFSET);
    addr_hit[60] = (reg_addr == KEYMGR_ERR_CODE_OFFSET);
    addr_hit[61] = (reg_addr == KEYMGR_FAULT_STATUS_OFFSET);
    addr_hit[62] = (reg_addr == KEYMGR_DEBUG_OFFSET);
  end

  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;

  // Check sub-word write is permitted
  always_comb begin
    wr_err = (reg_we &
              ((addr_hit[ 0] & (|(KEYMGR_PERMIT[ 0] & ~reg_be))) |
               (addr_hit[ 1] & (|(KEYMGR_PERMIT[ 1] & ~reg_be))) |
               (addr_hit[ 2] & (|(KEYMGR_PERMIT[ 2] & ~reg_be))) |
               (addr_hit[ 3] & (|(KEYMGR_PERMIT[ 3] & ~reg_be))) |
               (addr_hit[ 4] & (|(KEYMGR_PERMIT[ 4] & ~reg_be))) |
               (addr_hit[ 5] & (|(KEYMGR_PERMIT[ 5] & ~reg_be))) |
               (addr_hit[ 6] & (|(KEYMGR_PERMIT[ 6] & ~reg_be))) |
               (addr_hit[ 7] & (|(KEYMGR_PERMIT[ 7] & ~reg_be))) |
               (addr_hit[ 8] & (|(KEYMGR_PERMIT[ 8] & ~reg_be))) |
               (addr_hit[ 9] & (|(KEYMGR_PERMIT[ 9] & ~reg_be))) |
               (addr_hit[10] & (|(KEYMGR_PERMIT[10] & ~reg_be))) |
               (addr_hit[11] & (|(KEYMGR_PERMIT[11] & ~reg_be))) |
               (addr_hit[12] & (|(KEYMGR_PERMIT[12] & ~reg_be))) |
               (addr_hit[13] & (|(KEYMGR_PERMIT[13] & ~reg_be))) |
               (addr_hit[14] & (|(KEYMGR_PERMIT[14] & ~reg_be))) |
               (addr_hit[15] & (|(KEYMGR_PERMIT[15] & ~reg_be))) |
               (addr_hit[16] & (|(KEYMGR_PERMIT[16] & ~reg_be))) |
               (addr_hit[17] & (|(KEYMGR_PERMIT[17] & ~reg_be))) |
               (addr_hit[18] & (|(KEYMGR_PERMIT[18] & ~reg_be))) |
               (addr_hit[19] & (|(KEYMGR_PERMIT[19] & ~reg_be))) |
               (addr_hit[20] & (|(KEYMGR_PERMIT[20] & ~reg_be))) |
               (addr_hit[21] & (|(KEYMGR_PERMIT[21] & ~reg_be))) |
               (addr_hit[22] & (|(KEYMGR_PERMIT[22] & ~reg_be))) |
               (addr_hit[23] & (|(KEYMGR_PERMIT[23] & ~reg_be))) |
               (addr_hit[24] & (|(KEYMGR_PERMIT[24] & ~reg_be))) |
               (addr_hit[25] & (|(KEYMGR_PERMIT[25] & ~reg_be))) |
               (addr_hit[26] & (|(KEYMGR_PERMIT[26] & ~reg_be))) |
               (addr_hit[27] & (|(KEYMGR_PERMIT[27] & ~reg_be))) |
               (addr_hit[28] & (|(KEYMGR_PERMIT[28] & ~reg_be))) |
               (addr_hit[29] & (|(KEYMGR_PERMIT[29] & ~reg_be))) |
               (addr_hit[30] & (|(KEYMGR_PERMIT[30] & ~reg_be))) |
               (addr_hit[31] & (|(KEYMGR_PERMIT[31] & ~reg_be))) |
               (addr_hit[32] & (|(KEYMGR_PERMIT[32] & ~reg_be))) |
               (addr_hit[33] & (|(KEYMGR_PERMIT[33] & ~reg_be))) |
               (addr_hit[34] & (|(KEYMGR_PERMIT[34] & ~reg_be))) |
               (addr_hit[35] & (|(KEYMGR_PERMIT[35] & ~reg_be))) |
               (addr_hit[36] & (|(KEYMGR_PERMIT[36] & ~reg_be))) |
               (addr_hit[37] & (|(KEYMGR_PERMIT[37] & ~reg_be))) |
               (addr_hit[38] & (|(KEYMGR_PERMIT[38] & ~reg_be))) |
               (addr_hit[39] & (|(KEYMGR_PERMIT[39] & ~reg_be))) |
               (addr_hit[40] & (|(KEYMGR_PERMIT[40] & ~reg_be))) |
               (addr_hit[41] & (|(KEYMGR_PERMIT[41] & ~reg_be))) |
               (addr_hit[42] & (|(KEYMGR_PERMIT[42] & ~reg_be))) |
               (addr_hit[43] & (|(KEYMGR_PERMIT[43] & ~reg_be))) |
               (addr_hit[44] & (|(KEYMGR_PERMIT[44] & ~reg_be))) |
               (addr_hit[45] & (|(KEYMGR_PERMIT[45] & ~reg_be))) |
               (addr_hit[46] & (|(KEYMGR_PERMIT[46] & ~reg_be))) |
               (addr_hit[47] & (|(KEYMGR_PERMIT[47] & ~reg_be))) |
               (addr_hit[48] & (|(KEYMGR_PERMIT[48] & ~reg_be))) |
               (addr_hit[49] & (|(KEYMGR_PERMIT[49] & ~reg_be))) |
               (addr_hit[50] & (|(KEYMGR_PERMIT[50] & ~reg_be))) |
               (addr_hit[51] & (|(KEYMGR_PERMIT[51] & ~reg_be))) |
               (addr_hit[52] & (|(KEYMGR_PERMIT[52] & ~reg_be))) |
               (addr_hit[53] & (|(KEYMGR_PERMIT[53] & ~reg_be))) |
               (addr_hit[54] & (|(KEYMGR_PERMIT[54] & ~reg_be))) |
               (addr_hit[55] & (|(KEYMGR_PERMIT[55] & ~reg_be))) |
               (addr_hit[56] & (|(KEYMGR_PERMIT[56] & ~reg_be))) |
               (addr_hit[57] & (|(KEYMGR_PERMIT[57] & ~reg_be))) |
               (addr_hit[58] & (|(KEYMGR_PERMIT[58] & ~reg_be))) |
               (addr_hit[59] & (|(KEYMGR_PERMIT[59] & ~reg_be))) |
               (addr_hit[60] & (|(KEYMGR_PERMIT[60] & ~reg_be))) |
               (addr_hit[61] & (|(KEYMGR_PERMIT[61] & ~reg_be))) |
               (addr_hit[62] & (|(KEYMGR_PERMIT[62] & ~reg_be)))));
  end

  // Generate write-enables
  assign intr_state_we = addr_hit[0] & reg_we & !reg_error;

  assign intr_state_wd = reg_wdata[0];
  assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;

  assign intr_enable_wd = reg_wdata[0];
  assign intr_test_we = addr_hit[2] & reg_we & !reg_error;

  assign intr_test_wd = reg_wdata[0];
  assign alert_test_we = addr_hit[3] & reg_we & !reg_error;

  assign alert_test_recov_operation_err_wd = reg_wdata[0];

  assign alert_test_fatal_fault_err_wd = reg_wdata[1];
  assign cfg_regwen_re = addr_hit[4] & reg_re & !reg_error;
  assign start_we = addr_hit[5] & reg_we & !reg_error;

  assign start_wd = reg_wdata[0];
  assign control_shadowed_re = addr_hit[6] & reg_re & !reg_error;
  assign control_shadowed_we = addr_hit[6] & reg_we & !reg_error;

  assign control_shadowed_operation_wd = reg_wdata[6:4];

  assign control_shadowed_cdi_sel_wd = reg_wdata[7];

  assign control_shadowed_dest_sel_wd = reg_wdata[13:12];
  assign sideload_clear_we = addr_hit[7] & reg_we & !reg_error;

  assign sideload_clear_wd = reg_wdata[2:0];
  assign reseed_interval_regwen_we = addr_hit[8] & reg_we & !reg_error;

  assign reseed_interval_regwen_wd = reg_wdata[0];
  assign reseed_interval_shadowed_re = addr_hit[9] & reg_re & !reg_error;
  assign reseed_interval_shadowed_we = addr_hit[9] & reg_we & !reg_error;

  assign reseed_interval_shadowed_wd = reg_wdata[15:0];
  assign sw_binding_regwen_re = addr_hit[10] & reg_re & !reg_error;
  assign sw_binding_regwen_we = addr_hit[10] & reg_we & !reg_error;

  assign sw_binding_regwen_wd = reg_wdata[0];
  assign sealing_sw_binding_0_we = addr_hit[11] & reg_we & !reg_error;

  assign sealing_sw_binding_0_wd = reg_wdata[31:0];
  assign sealing_sw_binding_1_we = addr_hit[12] & reg_we & !reg_error;

  assign sealing_sw_binding_1_wd = reg_wdata[31:0];
  assign sealing_sw_binding_2_we = addr_hit[13] & reg_we & !reg_error;

  assign sealing_sw_binding_2_wd = reg_wdata[31:0];
  assign sealing_sw_binding_3_we = addr_hit[14] & reg_we & !reg_error;

  assign sealing_sw_binding_3_wd = reg_wdata[31:0];
  assign sealing_sw_binding_4_we = addr_hit[15] & reg_we & !reg_error;

  assign sealing_sw_binding_4_wd = reg_wdata[31:0];
  assign sealing_sw_binding_5_we = addr_hit[16] & reg_we & !reg_error;

  assign sealing_sw_binding_5_wd = reg_wdata[31:0];
  assign sealing_sw_binding_6_we = addr_hit[17] & reg_we & !reg_error;

  assign sealing_sw_binding_6_wd = reg_wdata[31:0];
  assign sealing_sw_binding_7_we = addr_hit[18] & reg_we & !reg_error;

  assign sealing_sw_binding_7_wd = reg_wdata[31:0];
  assign attest_sw_binding_0_we = addr_hit[19] & reg_we & !reg_error;

  assign attest_sw_binding_0_wd = reg_wdata[31:0];
  assign attest_sw_binding_1_we = addr_hit[20] & reg_we & !reg_error;

  assign attest_sw_binding_1_wd = reg_wdata[31:0];
  assign attest_sw_binding_2_we = addr_hit[21] & reg_we & !reg_error;

  assign attest_sw_binding_2_wd = reg_wdata[31:0];
  assign attest_sw_binding_3_we = addr_hit[22] & reg_we & !reg_error;

  assign attest_sw_binding_3_wd = reg_wdata[31:0];
  assign attest_sw_binding_4_we = addr_hit[23] & reg_we & !reg_error;

  assign attest_sw_binding_4_wd = reg_wdata[31:0];
  assign attest_sw_binding_5_we = addr_hit[24] & reg_we & !reg_error;

  assign attest_sw_binding_5_wd = reg_wdata[31:0];
  assign attest_sw_binding_6_we = addr_hit[25] & reg_we & !reg_error;

  assign attest_sw_binding_6_wd = reg_wdata[31:0];
  assign attest_sw_binding_7_we = addr_hit[26] & reg_we & !reg_error;

  assign attest_sw_binding_7_wd = reg_wdata[31:0];
  assign salt_0_we = addr_hit[27] & reg_we & !reg_error;

  assign salt_0_wd = reg_wdata[31:0];
  assign salt_1_we = addr_hit[28] & reg_we & !reg_error;

  assign salt_1_wd = reg_wdata[31:0];
  assign salt_2_we = addr_hit[29] & reg_we & !reg_error;

  assign salt_2_wd = reg_wdata[31:0];
  assign salt_3_we = addr_hit[30] & reg_we & !reg_error;

  assign salt_3_wd = reg_wdata[31:0];
  assign salt_4_we = addr_hit[31] & reg_we & !reg_error;

  assign salt_4_wd = reg_wdata[31:0];
  assign salt_5_we = addr_hit[32] & reg_we & !reg_error;

  assign salt_5_wd = reg_wdata[31:0];
  assign salt_6_we = addr_hit[33] & reg_we & !reg_error;

  assign salt_6_wd = reg_wdata[31:0];
  assign salt_7_we = addr_hit[34] & reg_we & !reg_error;

  assign salt_7_wd = reg_wdata[31:0];
  assign key_version_we = addr_hit[35] & reg_we & !reg_error;

  assign key_version_wd = reg_wdata[31:0];
  assign max_creator_key_ver_regwen_we = addr_hit[36] & reg_we & !reg_error;

  assign max_creator_key_ver_regwen_wd = reg_wdata[0];
  assign max_creator_key_ver_shadowed_re = addr_hit[37] & reg_re & !reg_error;
  assign max_creator_key_ver_shadowed_we = addr_hit[37] & reg_we & !reg_error;

  assign max_creator_key_ver_shadowed_wd = reg_wdata[31:0];
  assign max_owner_int_key_ver_regwen_we = addr_hit[38] & reg_we & !reg_error;

  assign max_owner_int_key_ver_regwen_wd = reg_wdata[0];
  assign max_owner_int_key_ver_shadowed_re = addr_hit[39] & reg_re & !reg_error;
  assign max_owner_int_key_ver_shadowed_we = addr_hit[39] & reg_we & !reg_error;

  assign max_owner_int_key_ver_shadowed_wd = reg_wdata[31:0];
  assign max_owner_key_ver_regwen_we = addr_hit[40] & reg_we & !reg_error;

  assign max_owner_key_ver_regwen_wd = reg_wdata[0];
  assign max_owner_key_ver_shadowed_re = addr_hit[41] & reg_re & !reg_error;
  assign max_owner_key_ver_shadowed_we = addr_hit[41] & reg_we & !reg_error;

  assign max_owner_key_ver_shadowed_wd = reg_wdata[31:0];
  assign sw_share0_output_0_re = addr_hit[42] & reg_re & !reg_error;

  assign sw_share0_output_0_wd = '1;
  assign sw_share0_output_1_re = addr_hit[43] & reg_re & !reg_error;

  assign sw_share0_output_1_wd = '1;
  assign sw_share0_output_2_re = addr_hit[44] & reg_re & !reg_error;

  assign sw_share0_output_2_wd = '1;
  assign sw_share0_output_3_re = addr_hit[45] & reg_re & !reg_error;

  assign sw_share0_output_3_wd = '1;
  assign sw_share0_output_4_re = addr_hit[46] & reg_re & !reg_error;

  assign sw_share0_output_4_wd = '1;
  assign sw_share0_output_5_re = addr_hit[47] & reg_re & !reg_error;

  assign sw_share0_output_5_wd = '1;
  assign sw_share0_output_6_re = addr_hit[48] & reg_re & !reg_error;

  assign sw_share0_output_6_wd = '1;
  assign sw_share0_output_7_re = addr_hit[49] & reg_re & !reg_error;

  assign sw_share0_output_7_wd = '1;
  assign sw_share1_output_0_re = addr_hit[50] & reg_re & !reg_error;

  assign sw_share1_output_0_wd = '1;
  assign sw_share1_output_1_re = addr_hit[51] & reg_re & !reg_error;

  assign sw_share1_output_1_wd = '1;
  assign sw_share1_output_2_re = addr_hit[52] & reg_re & !reg_error;

  assign sw_share1_output_2_wd = '1;
  assign sw_share1_output_3_re = addr_hit[53] & reg_re & !reg_error;

  assign sw_share1_output_3_wd = '1;
  assign sw_share1_output_4_re = addr_hit[54] & reg_re & !reg_error;

  assign sw_share1_output_4_wd = '1;
  assign sw_share1_output_5_re = addr_hit[55] & reg_re & !reg_error;

  assign sw_share1_output_5_wd = '1;
  assign sw_share1_output_6_re = addr_hit[56] & reg_re & !reg_error;

  assign sw_share1_output_6_wd = '1;
  assign sw_share1_output_7_re = addr_hit[57] & reg_re & !reg_error;

  assign sw_share1_output_7_wd = '1;
  assign op_status_we = addr_hit[59] & reg_we & !reg_error;

  assign op_status_wd = reg_wdata[1:0];
  assign err_code_we = addr_hit[60] & reg_we & !reg_error;

  assign err_code_invalid_op_wd = reg_wdata[0];

  assign err_code_invalid_kmac_input_wd = reg_wdata[1];

  assign err_code_invalid_shadow_update_wd = reg_wdata[2];
  assign debug_we = addr_hit[62] & reg_we & !reg_error;

  assign debug_invalid_creator_seed_wd = reg_wdata[0];

  assign debug_invalid_owner_seed_wd = reg_wdata[1];

  assign debug_invalid_dev_id_wd = reg_wdata[2];

  assign debug_invalid_health_state_wd = reg_wdata[3];

  assign debug_invalid_key_version_wd = reg_wdata[4];

  assign debug_invalid_key_wd = reg_wdata[5];

  assign debug_invalid_digest_wd = reg_wdata[6];

  // Assign write-enables to checker logic vector.
  always_comb begin
    reg_we_check = '0;
    reg_we_check[0] = intr_state_we;
    reg_we_check[1] = intr_enable_we;
    reg_we_check[2] = intr_test_we;
    reg_we_check[3] = alert_test_we;
    reg_we_check[4] = 1'b0;
    reg_we_check[5] = start_gated_we;
    reg_we_check[6] = control_shadowed_gated_we;
    reg_we_check[7] = sideload_clear_gated_we;
    reg_we_check[8] = reseed_interval_regwen_we;
    reg_we_check[9] = reseed_interval_shadowed_gated_we;
    reg_we_check[10] = sw_binding_regwen_we;
    reg_we_check[11] = sealing_sw_binding_0_gated_we;
    reg_we_check[12] = sealing_sw_binding_1_gated_we;
    reg_we_check[13] = sealing_sw_binding_2_gated_we;
    reg_we_check[14] = sealing_sw_binding_3_gated_we;
    reg_we_check[15] = sealing_sw_binding_4_gated_we;
    reg_we_check[16] = sealing_sw_binding_5_gated_we;
    reg_we_check[17] = sealing_sw_binding_6_gated_we;
    reg_we_check[18] = sealing_sw_binding_7_gated_we;
    reg_we_check[19] = attest_sw_binding_0_gated_we;
    reg_we_check[20] = attest_sw_binding_1_gated_we;
    reg_we_check[21] = attest_sw_binding_2_gated_we;
    reg_we_check[22] = attest_sw_binding_3_gated_we;
    reg_we_check[23] = attest_sw_binding_4_gated_we;
    reg_we_check[24] = attest_sw_binding_5_gated_we;
    reg_we_check[25] = attest_sw_binding_6_gated_we;
    reg_we_check[26] = attest_sw_binding_7_gated_we;
    reg_we_check[27] = salt_0_gated_we;
    reg_we_check[28] = salt_1_gated_we;
    reg_we_check[29] = salt_2_gated_we;
    reg_we_check[30] = salt_3_gated_we;
    reg_we_check[31] = salt_4_gated_we;
    reg_we_check[32] = salt_5_gated_we;
    reg_we_check[33] = salt_6_gated_we;
    reg_we_check[34] = salt_7_gated_we;
    reg_we_check[35] = key_version_gated_we;
    reg_we_check[36] = max_creator_key_ver_regwen_we;
    reg_we_check[37] = max_creator_key_ver_shadowed_gated_we;
    reg_we_check[38] = max_owner_int_key_ver_regwen_we;
    reg_we_check[39] = max_owner_int_key_ver_shadowed_gated_we;
    reg_we_check[40] = max_owner_key_ver_regwen_we;
    reg_we_check[41] = max_owner_key_ver_shadowed_gated_we;
    reg_we_check[42] = 1'b0;
    reg_we_check[43] = 1'b0;
    reg_we_check[44] = 1'b0;
    reg_we_check[45] = 1'b0;
    reg_we_check[46] = 1'b0;
    reg_we_check[47] = 1'b0;
    reg_we_check[48] = 1'b0;
    reg_we_check[49] = 1'b0;
    reg_we_check[50] = 1'b0;
    reg_we_check[51] = 1'b0;
    reg_we_check[52] = 1'b0;
    reg_we_check[53] = 1'b0;
    reg_we_check[54] = 1'b0;
    reg_we_check[55] = 1'b0;
    reg_we_check[56] = 1'b0;
    reg_we_check[57] = 1'b0;
    reg_we_check[58] = 1'b0;
    reg_we_check[59] = op_status_we;
    reg_we_check[60] = err_code_we;
    reg_we_check[61] = 1'b0;
    reg_we_check[62] = debug_we;
  end

  // Read data return
  always_comb begin
    reg_rdata_next = '0;
    unique case (1'b1)
      addr_hit[0]: begin
        reg_rdata_next[0] = intr_state_qs;
      end

      addr_hit[1]: begin
        reg_rdata_next[0] = intr_enable_qs;
      end

      addr_hit[2]: begin
        reg_rdata_next[0] = '0;
      end

      addr_hit[3]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
      end

      addr_hit[4]: begin
        reg_rdata_next[0] = cfg_regwen_qs;
      end

      addr_hit[5]: begin
        reg_rdata_next[0] = start_qs;
      end

      addr_hit[6]: begin
        reg_rdata_next[6:4] = control_shadowed_operation_qs;
        reg_rdata_next[7] = control_shadowed_cdi_sel_qs;
        reg_rdata_next[13:12] = control_shadowed_dest_sel_qs;
      end

      addr_hit[7]: begin
        reg_rdata_next[2:0] = sideload_clear_qs;
      end

      addr_hit[8]: begin
        reg_rdata_next[0] = reseed_interval_regwen_qs;
      end

      addr_hit[9]: begin
        reg_rdata_next[15:0] = reseed_interval_shadowed_qs;
      end

      addr_hit[10]: begin
        reg_rdata_next[0] = sw_binding_regwen_qs;
      end

      addr_hit[11]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_0_qs;
      end

      addr_hit[12]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_1_qs;
      end

      addr_hit[13]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_2_qs;
      end

      addr_hit[14]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_3_qs;
      end

      addr_hit[15]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_4_qs;
      end

      addr_hit[16]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_5_qs;
      end

      addr_hit[17]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_6_qs;
      end

      addr_hit[18]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_7_qs;
      end

      addr_hit[19]: begin
        reg_rdata_next[31:0] = attest_sw_binding_0_qs;
      end

      addr_hit[20]: begin
        reg_rdata_next[31:0] = attest_sw_binding_1_qs;
      end

      addr_hit[21]: begin
        reg_rdata_next[31:0] = attest_sw_binding_2_qs;
      end

      addr_hit[22]: begin
        reg_rdata_next[31:0] = attest_sw_binding_3_qs;
      end

      addr_hit[23]: begin
        reg_rdata_next[31:0] = attest_sw_binding_4_qs;
      end

      addr_hit[24]: begin
        reg_rdata_next[31:0] = attest_sw_binding_5_qs;
      end

      addr_hit[25]: begin
        reg_rdata_next[31:0] = attest_sw_binding_6_qs;
      end

      addr_hit[26]: begin
        reg_rdata_next[31:0] = attest_sw_binding_7_qs;
      end

      addr_hit[27]: begin
        reg_rdata_next[31:0] = salt_0_qs;
      end

      addr_hit[28]: begin
        reg_rdata_next[31:0] = salt_1_qs;
      end

      addr_hit[29]: begin
        reg_rdata_next[31:0] = salt_2_qs;
      end

      addr_hit[30]: begin
        reg_rdata_next[31:0] = salt_3_qs;
      end

      addr_hit[31]: begin
        reg_rdata_next[31:0] = salt_4_qs;
      end

      addr_hit[32]: begin
        reg_rdata_next[31:0] = salt_5_qs;
      end

      addr_hit[33]: begin
        reg_rdata_next[31:0] = salt_6_qs;
      end

      addr_hit[34]: begin
        reg_rdata_next[31:0] = salt_7_qs;
      end

      addr_hit[35]: begin
        reg_rdata_next[31:0] = key_version_qs;
      end

      addr_hit[36]: begin
        reg_rdata_next[0] = max_creator_key_ver_regwen_qs;
      end

      addr_hit[37]: begin
        reg_rdata_next[31:0] = max_creator_key_ver_shadowed_qs;
      end

      addr_hit[38]: begin
        reg_rdata_next[0] = max_owner_int_key_ver_regwen_qs;
      end

      addr_hit[39]: begin
        reg_rdata_next[31:0] = max_owner_int_key_ver_shadowed_qs;
      end

      addr_hit[40]: begin
        reg_rdata_next[0] = max_owner_key_ver_regwen_qs;
      end

      addr_hit[41]: begin
        reg_rdata_next[31:0] = max_owner_key_ver_shadowed_qs;
      end

      addr_hit[42]: begin
        reg_rdata_next[31:0] = sw_share0_output_0_qs;
      end

      addr_hit[43]: begin
        reg_rdata_next[31:0] = sw_share0_output_1_qs;
      end

      addr_hit[44]: begin
        reg_rdata_next[31:0] = sw_share0_output_2_qs;
      end

      addr_hit[45]: begin
        reg_rdata_next[31:0] = sw_share0_output_3_qs;
      end

      addr_hit[46]: begin
        reg_rdata_next[31:0] = sw_share0_output_4_qs;
      end

      addr_hit[47]: begin
        reg_rdata_next[31:0] = sw_share0_output_5_qs;
      end

      addr_hit[48]: begin
        reg_rdata_next[31:0] = sw_share0_output_6_qs;
      end

      addr_hit[49]: begin
        reg_rdata_next[31:0] = sw_share0_output_7_qs;
      end

      addr_hit[50]: begin
        reg_rdata_next[31:0] = sw_share1_output_0_qs;
      end

      addr_hit[51]: begin
        reg_rdata_next[31:0] = sw_share1_output_1_qs;
      end

      addr_hit[52]: begin
        reg_rdata_next[31:0] = sw_share1_output_2_qs;
      end

      addr_hit[53]: begin
        reg_rdata_next[31:0] = sw_share1_output_3_qs;
      end

      addr_hit[54]: begin
        reg_rdata_next[31:0] = sw_share1_output_4_qs;
      end

      addr_hit[55]: begin
        reg_rdata_next[31:0] = sw_share1_output_5_qs;
      end

      addr_hit[56]: begin
        reg_rdata_next[31:0] = sw_share1_output_6_qs;
      end

      addr_hit[57]: begin
        reg_rdata_next[31:0] = sw_share1_output_7_qs;
      end

      addr_hit[58]: begin
        reg_rdata_next[2:0] = working_state_qs;
      end

      addr_hit[59]: begin
        reg_rdata_next[1:0] = op_status_qs;
      end

      addr_hit[60]: begin
        reg_rdata_next[0] = err_code_invalid_op_qs;
        reg_rdata_next[1] = err_code_invalid_kmac_input_qs;
        reg_rdata_next[2] = err_code_invalid_shadow_update_qs;
      end

      addr_hit[61]: begin
        reg_rdata_next[0] = fault_status_cmd_qs;
        reg_rdata_next[1] = fault_status_kmac_fsm_qs;
        reg_rdata_next[2] = fault_status_kmac_done_qs;
        reg_rdata_next[3] = fault_status_kmac_op_qs;
        reg_rdata_next[4] = fault_status_kmac_out_qs;
        reg_rdata_next[5] = fault_status_regfile_intg_qs;
        reg_rdata_next[6] = fault_status_shadow_qs;
        reg_rdata_next[7] = fault_status_ctrl_fsm_intg_qs;
        reg_rdata_next[8] = fault_status_ctrl_fsm_chk_qs;
        reg_rdata_next[9] = fault_status_ctrl_fsm_cnt_qs;
        reg_rdata_next[10] = fault_status_reseed_cnt_qs;
        reg_rdata_next[11] = fault_status_side_ctrl_fsm_qs;
        reg_rdata_next[12] = fault_status_side_ctrl_sel_qs;
        reg_rdata_next[13] = fault_status_key_ecc_qs;
      end

      addr_hit[62]: begin
        reg_rdata_next[0] = debug_invalid_creator_seed_qs;
        reg_rdata_next[1] = debug_invalid_owner_seed_qs;
        reg_rdata_next[2] = debug_invalid_dev_id_qs;
        reg_rdata_next[3] = debug_invalid_health_state_qs;
        reg_rdata_next[4] = debug_invalid_key_version_qs;
        reg_rdata_next[5] = debug_invalid_key_qs;
        reg_rdata_next[6] = debug_invalid_digest_qs;
      end

      default: begin
        reg_rdata_next = '1;
      end
    endcase
  end

  // shadow busy
  logic shadow_busy;
  logic rst_done;
  logic shadow_rst_done;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      rst_done <= '0;
    end else begin
      rst_done <= 1'b1;
    end
  end

  always_ff @(posedge clk_i or negedge rst_shadowed_ni) begin
    if (!rst_shadowed_ni) begin
      shadow_rst_done <= '0;
    end else begin
      shadow_rst_done <= 1'b1;
    end
  end

  // both shadow and normal resets have been released
  assign shadow_busy = ~(rst_done & shadow_rst_done);

  // Collect up storage and update errors
  assign shadowed_storage_err_o = |{
    control_shadowed_operation_storage_err,
    control_shadowed_cdi_sel_storage_err,
    control_shadowed_dest_sel_storage_err,
    reseed_interval_shadowed_storage_err,
    max_creator_key_ver_shadowed_storage_err,
    max_owner_int_key_ver_shadowed_storage_err,
    max_owner_key_ver_shadowed_storage_err
  };
  assign shadowed_update_err_o = |{
    control_shadowed_operation_update_err,
    control_shadowed_cdi_sel_update_err,
    control_shadowed_dest_sel_update_err,
    reseed_interval_shadowed_update_err,
    max_creator_key_ver_shadowed_update_err,
    max_owner_int_key_ver_shadowed_update_err,
    max_owner_key_ver_shadowed_update_err
  };

  // register busy
  assign reg_busy = shadow_busy;

  // Unused signal tieoff

  // wdata / byte enable are not always fully used
  // add a blanket unused statement to handle lint waivers
  logic unused_wdata;
  logic unused_be;
  assign unused_wdata = ^reg_wdata;
  assign unused_be = ^reg_be;

  // Assertions for Register Interface
  `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
  `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)

  `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)

  `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)

  // this is formulated as an assumption such that the FPV testbenches do disprove this
  // property by mistake
  //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)

endmodule

    '''

    Identify relevant lint tags for the RTL to be checked for.
    Then run the tests using the linting tool.
    From the output of the linting tool, determine if there are security issues in the RTL.
================================== Ai Message ==================================
Tool Calls:
  retrieve_relevant_lint_tags (call_qLlPaBPZuL5ETCcl3Y6wzout)
 Call ID: call_qLlPaBPZuL5ETCcl3Y6wzout
  Args:
    query: register interface security shadow register access policy privilege escalation
================================= Tool Message =================================
Name: retrieve_relevant_lint_tags


W215: Reports inappropriate bit-selects of integer or time variables 

ShiftReg: Large shift register detected

W243: Recursive task enable


RegisterInfo-ML: Generate a report which includes all registers in RTL design 

W486: Reports shift overflow operations


STARC05-1.2.1.1a: Design should use only one edge of a clock 


STARC05-1.4.3.1b: Clocks should not be gated 


W502: Ensure that a variable in the sensitivity list is not modified inside the xxxviiiSynopsys, Inc. Feedbackalways block 

ExplicitSignExtend-ML: Reports explicit sign extension


sim_race07: Non-blocking assignment should not be used in clock or enable path 


STARC05-1.4.3.1a: Clocks should not be inverted 


STARC05-2.10.5.3b: Reports violation when there are three or more arithmetic operations in Always block 


Rule_41: Primary port of a block is tied to global signal 


W336L: Blocking assignment to latch output should be avoided 


ClockEnableRace: Reports a race condition between clock and enable pins of a flip-flop 


W450L: Reports multi-bit expression used as latch enable condition 


W213: Reports PLI tasks or functions that are not synthesizable 

W143: Macro has been redefined


STARC05-2.1.9.5: Do not use user-defined attributes in the design 


STARC05-1.4.1.1: Preferably get all clock nets from primary or centrally generated clock 
================================== Ai Message ==================================
Tool Calls:
  lint_checker_tool (call_uVpMVaubeVLnIYNgqovbCAVF)
 Call ID: call_uVpMVaubeVLnIYNgqovbCAVF
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv
    top_module: keymgr_reg_top
    lint_tags: ['RegisterInfo-ML', 'STARC05-1.2.1.1a', 'STARC05-1.4.3.1b', 'ClockEnableRace']
================================= Tool Message =================================
Name: lint_checker_tool

Successfully executed:
```lint checker tool
```
Output: 
  -----------------------------------------------------------------------------
  Report Summary
  -----------------------------------------------------------------------------
  Product Info
    Name    : VC Static Master Shell
    Version : U-2023.03-1 -- Apr 17, 2023

  Report Info
    Created : May 06, 2025  16:26:07

    TopLevelModule: keymgr_reg_top

  -----------------------------------------------------------------------------
  Management Summary
  -----------------------------------------------------------------------------
  Stage             Family      Fatals    Errors  Warnings     Infos
  -----             --------  --------  --------  --------  --------
  STRUCTURAL_CHECK  CODING           0         1         0         0
  -----             --------  --------  --------  --------  --------
  Total                              0         1         0         0


  -----------------------------------------------------------------------------
  Tree Summary
  -----------------------------------------------------------------------------
  Severity  Stage             Tag                Count
  --------  -----             -----------------  -----
  error     STRUCTURAL_CHECK  RegisterInfo-ML        1
  --------  -----             -----------------  -----
  Total                                              1



  -----------------------------------------------------------------------------
  RegisterInfo-ML  (1 error/0 waived)
  -----------------------------------------------------------------------------
  Tag             : RegisterInfo-ML
  Description     : Please check the report 'all_register_info.rpt' for details on all registers in design
  Violation       : Lint:1
  Module          : keymgr_reg_top
  FileName        : /home/XXXX-2/security_agents/vcst_rtdb/reports/all_register_info.rpt
  LineNumber      : 0

================================== Ai Message ==================================

I have identified relevant lint tags related to register interface security, shadow registers, access policy, and privilege escalation. The relevant lint tags include "RegisterInfo-ML", "STARC05-1.2.1.1a", "STARC05-1.4.3.1b", and "ClockEnableRace".

I ran the lint checks on the provided RTL code with these tags. The lint tool reported one error under the "RegisterInfo-ML" tag. The error message suggests checking the report file 'all_register_info.rpt' for details on all registers in the design. There were no warnings or other errors reported.

Summary:
- One error related to register information was found.
- No warnings or other errors related to clock gating or race conditions were found.

Based on this lint output, there is a register-related issue that needs further investigation by reviewing the detailed register report. However, no explicit security issues related to clock gating or race conditions were detected by the lint checks.

To conclude, the RTL may have some register interface issues that could potentially impact security, but no direct privilege escalation or access policy violations were flagged by the lint tool. Further manual review of the register report is recommended to assess any security implications.
================================= Tool Message =================================
Name: run_linter_agent

I have identified relevant lint tags related to register interface security, shadow registers, access policy, and privilege escalation. The relevant lint tags include "RegisterInfo-ML", "STARC05-1.2.1.1a", "STARC05-1.4.3.1b", and "ClockEnableRace".

I ran the lint checks on the provided RTL code with these tags. The lint tool reported one error under the "RegisterInfo-ML" tag. The error message suggests checking the report file 'all_register_info.rpt' for details on all registers in the design. There were no warnings or other errors reported.

Summary:
- One error related to register information was found.
- No warnings or other errors related to clock gating or race conditions were found.

Based on this lint output, there is a register-related issue that needs further investigation by reviewing the detailed register report. However, no explicit security issues related to clock gating or race conditions were detected by the lint checks.

To conclude, the RTL may have some register interface issues that could potentially impact security, but no direct privilege escalation or access policy violations were flagged by the lint tool. Further manual review of the register report is recommended to assess any security implications.
================================== Ai Message ==================================
Tool Calls:
  run_linter_agent (call_e4r5Gx1xxLdub6GAQruLYfVF)
 Call ID: call_e4r5Gx1xxLdub6GAQruLYfVF
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_ctrl.sv
    top_module: keymgr_ctrl
    security_objective: FSM security, privilege escalation, illegal state transitions, stuck-at faults
================================ Human Message =================================

Are there security concerns related to FSM security, privilege escalation, illegal state transitions, stuck-at faults in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_ctrl.sv

    And the top module is:

    keymgr_ctrl

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Key manager top level
//

`include "prim_assert.sv"

module keymgr_ctrl
  import keymgr_pkg::*;
  import keymgr_reg_pkg::*;
#(
  parameter bit KmacEnMasking = 1'b1
) (
  input clk_i,
  input rst_ni,

  // lifecycle enforcement
  // SEC_CM: CTRL.FSM.GLOBAL_ESC
  input en_i,

  // faults that can occur outside of operations
  input regfile_intg_err_i,
  input shadowed_update_err_i,
  input shadowed_storage_err_i,
  input reseed_cnt_err_i,
  input sideload_sel_err_i,
  input sideload_fsm_err_i,

  // Software interface
  input op_start_i,
  input keymgr_ops_e op_i,
  input [CdiWidth-1:0] op_cdi_sel_i,
  output logic op_done_o,
  output keymgr_op_status_e status_o,
  output logic [ErrLastPos-1:0] error_o,
  output logic [FaultLastPos-1:0] fault_o,
  output logic data_hw_en_o,
  output logic data_sw_en_o,
  output logic data_valid_o,
  output logic wipe_key_o,
  output keymgr_working_state_e working_state_o,
  output logic sw_binding_unlock_o,
  output logic init_o,

  // Data input
  input  otp_ctrl_pkg::otp_keymgr_key_t root_key_i,
  output prim_mubi_pkg::mubi4_t hw_sel_o,
  output keymgr_stage_e stage_sel_o,
  output logic invalid_stage_sel_o,
  output logic [CdiWidth-1:0] cdi_sel_o,

  // KMAC ctrl interface
  output logic adv_en_o,
  output logic id_en_o,
  output logic gen_en_o,
  output hw_key_req_t key_o,
  input kmac_done_i,
  input kmac_input_invalid_i, // asserted when selected data fails criteria check
  input kmac_fsm_err_i, // asserted when kmac fsm reaches unexpected state
  input kmac_op_err_i,  // asserted when kmac itself reports an error
  input kmac_done_err_i,// asserted when kmac unexpectedly toggles done
  input kmac_cmd_err_i, // asserted when more than one command given to kmac
  input [Shares-1:0][KeyWidth-1:0] kmac_data_i,

  // prng control interface
  input [Shares-1:0][RandWidth-1:0] entropy_i,
  input prng_reseed_done_i,
  input prng_reseed_ack_i,
  output logic prng_reseed_req_o,
  output logic prng_en_o
);

  localparam int EntropyWidth = LfsrWidth / 2;
  localparam int EntropyRounds = KeyWidth / EntropyWidth;
  localparam int EntropyRndWidth = prim_util_pkg::vbits(EntropyRounds);
  localparam int CntWidth = EntropyRounds > CDIs ? EntropyRndWidth : CdiWidth;
  localparam int EccDataWidth = 64;
  localparam int EccWidth = 8;
  localparam int EccWords = KeyWidth / EccDataWidth;
  localparam int TotalEccWords = EccWords * Shares * CDIs;


  // Enumeration for working state
  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 5 -m 11 -n 10 \
  //      -s 4101887575 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: --
  //  4: --
  //  5: |||||||||||||||||||| (54.55%)
  //  6: |||||||||||||||| (45.45%)
  //  7: --
  //  8: --
  //  9: --
  // 10: --
  //
  // Minimum Hamming distance: 5
  // Maximum Hamming distance: 6
  // Minimum Hamming weight: 2
  // Maximum Hamming weight: 8
  //
  localparam int StateWidth = 10;
  typedef enum logic [StateWidth-1:0] {
    StCtrlReset          = 10'b1101100001,
    StCtrlEntropyReseed  = 10'b1110010010,
    StCtrlRandom         = 10'b0011110100,
    StCtrlRootKey        = 10'b0110101111,
    StCtrlInit           = 10'b0100000100,
    StCtrlCreatorRootKey = 10'b1000011101,
    StCtrlOwnerIntKey    = 10'b0001001010,
    StCtrlOwnerKey       = 10'b1101111110,
    StCtrlDisabled       = 10'b1010101000,
    StCtrlWipe           = 10'b0000110011,
    StCtrlInvalid        = 10'b1011000111
  } state_e;
  state_e state_q, state_d;

  // A variable that represents differentiates states before root key and after root key.
  logic initialized;

  // There are two versions of the key state, one for sealing one for attestation
  // Among each version, there are multiple shares
  // Each share is a fixed multiple of the entropy width
  logic [CDIs-1:0][Shares-1:0][EntropyRounds-1:0][EntropyWidth-1:0] key_state_d;
  logic [CDIs-1:0][Shares-1:0][EccWords-1:0][EccDataWidth-1:0] key_state_ecc_words_d;
  logic [CDIs-1:0][Shares-1:0][EccWords-1:0][EccDataWidth-1:0] key_state_q;
  logic [CDIs-1:0][Shares-1:0][EccWords-1:0][EccWidth-1:0] key_state_ecc_q;
  logic [CntWidth-1:0] cnt;
  logic [CdiWidth-1:0] cdi_cnt;

  // error conditions
  logic invalid_kmac_out;
  logic invalid_op;
  logic cnt_err;
  // states fall out of sparsely encoded range
  logic state_intg_err_q, state_intg_err_d;

  ///////////////////////////
  //  General operation decode
  ///////////////////////////

  logic adv_op, dis_op, gen_id_op, gen_sw_op, gen_hw_op, gen_op;
  assign adv_op    = (op_i == OpAdvance);
  assign gen_id_op = (op_i == OpGenId);
  assign gen_sw_op = (op_i == OpGenSwOut);
  assign gen_hw_op = (op_i == OpGenHwOut);
  assign dis_op    = ~(op_i inside {OpAdvance, OpGenId, OpGenSwOut, OpGenHwOut});
  assign gen_op    = (gen_id_op | gen_sw_op | gen_hw_op);

  ///////////////////////////
  //  interaction between software and main fsm
  ///////////////////////////
  // disable is treated like an advanced call
  logic advance_sel;
  logic disable_sel;
  logic gen_out_hw_sel;

  assign advance_sel    = op_start_i & adv_op    & en_i;
  assign gen_out_hw_sel = op_start_i & gen_hw_op & en_i;

  // disable is selected whenever a normal operation is not set
  assign disable_sel    = (op_start_i & dis_op) | !en_i;


  ///////////////////////////
  //  interaction between main control fsm and operation fsm
  ///////////////////////////

  // req/ack interface with op handling fsm
  logic op_req;
  logic op_ack;
  logic op_update;
  logic op_busy;
  logic disabled;
  logic invalid;

  logic adv_req, dis_req, id_req, gen_req;
  assign adv_req = op_req & adv_op;
  assign dis_req = op_req & dis_op;
  assign id_req  = op_req & gen_id_op;
  assign gen_req = op_req & (gen_sw_op | gen_hw_op);

  ///////////////////////////
  //  interaction between operation fsm and software
  ///////////////////////////
  // categories of keymgr errors
  logic [SyncErrLastIdx-1:0] sync_err;
  logic [SyncFaultLastIdx-1:0] sync_fault;
  logic [AsyncFaultLastIdx-1:0] async_fault;

  logic op_err;
  logic op_fault_err;

  // unlock sw binding configuration whenever an advance call is made without errors
  assign sw_binding_unlock_o = adv_req & op_ack & ~(op_err | op_fault_err);

  // error definition
  // check incoming kmac data validity
  // Only check during the periods when there is actual kmac output
  assign invalid_kmac_out = (op_update | op_ack) &
                            (~valid_data_chk(kmac_data_i[0]) |
                            (~valid_data_chk(kmac_data_i[1]) & KmacEnMasking));

  // async errors have nothing to do with the operation and thus should not
  // impact operation results.
  assign op_err = |sync_err;

  assign op_fault_err = |{sync_fault, async_fault};

  ///////////////////////////
  //  key update controls
  ///////////////////////////

  // update select can come from both main and operation fsm's
  keymgr_key_update_e update_sel, op_update_sel;

  // req from main control fsm to key update controls
  logic wipe_req;
  logic random_req;
  logic random_ack;

  // wipe and initialize take precedence
  assign update_sel = wipe_req             ? KeyUpdateWipe   :
                      random_req           ? KeyUpdateRandom :
                      init_o               ? KeyUpdateRoot   : op_update_sel;

  ///////////////////////////
  //  interaction between main fsm and prng
  ///////////////////////////

  // Upon entering StCtrlDisabled or StCtrlInvalid, the PRNG is kept advancing until it has been
  // reseeded twice (through the reseeding mechansism inside keymgr_reseed_ctrl.sv).
  logic [1:0] prng_en_dis_inv_d, prng_en_dis_inv_q;
  logic prng_en_dis_inv_set;

  assign prng_en_dis_inv_d =
      prng_en_dis_inv_set ? 2'b11 :
      prng_reseed_done_i  ? {1'b0, prng_en_dis_inv_q[1]} : prng_en_dis_inv_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      prng_en_dis_inv_q <= '0;
    end else begin
      prng_en_dis_inv_q <= prng_en_dis_inv_d;
    end
  end

  assign prng_en_o = random_req | wipe_req | prng_en_dis_inv_q[0];

  //////////////////////////
  // Main Control FSM
  //////////////////////////
  // SEC_CM: CTRL.FSM.SPARSE
  `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, state_e, StCtrlReset)

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      state_intg_err_q <= '0;
    end else begin
      state_intg_err_q <= state_intg_err_d;
    end
  end

  // prevents unknowns from reaching the outside world.
  // - whatever operation causes the input data select to be disabled should not expose the key
  //   state.
  // - when there are no operations, the key state also should be exposed.
  assign key_o.valid = op_req;

  assign cdi_sel_o = advance_sel ? cdi_cnt : op_cdi_sel_i;

  assign invalid_stage_sel_o = ~(stage_sel_o inside {Creator, OwnerInt, Owner});
  for (genvar i = 0; i < Shares; i++) begin : gen_key_out_assign
    assign key_o.key[i] = invalid_stage_sel_o ?
                          {EntropyRounds{entropy_i[i]}} :
                          key_state_q[cdi_sel_o][i];
  end


  //SEC_CM: CTRL.KEY.INTEGRITY
  assign key_state_ecc_words_d = key_state_d;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      key_state_q <= '0;
      key_state_ecc_q <= {TotalEccWords{prim_secded_pkg::SecdedInv7264ZeroEcc}};
    end else begin
      for (int i = 0; i < CDIs; i++) begin
        for (int j = 0; j < Shares; j++) begin
          for (int k = 0; k < EccWords; k++) begin
            {key_state_ecc_q[i][j][k]} <=
                prim_secded_pkg::prim_secded_inv_72_64_enc(key_state_ecc_words_d[i][j][k]);
          end
        end
      end
    end
  end

  logic [CDIs-1:0][Shares-1:0][EccWords-1:0] ecc_errs;
  for (genvar i = 0; i < CDIs; i++) begin : gen_ecc_loop_cdi
    for (genvar j = 0; j < Shares; j++) begin : gen_ecc_loop_shares
      for (genvar k = 0; k < EccWords; k++) begin : gen_ecc_loop_words
        logic [1:0] errs;
        prim_secded_inv_72_64_dec u_dec (
          .data_i({key_state_ecc_q[i][j][k], key_state_q[i][j][k]}),
          .data_o(),
          .syndrome_o(),
          .err_o(errs)
        );
        assign ecc_errs[i][j][k] = |errs;
      end
    end
  end

  // These are consumed one level above in keymgr.sv
  logic unused_otp_sigs;
  assign unused_otp_sigs = ^{root_key_i.creator_seed,
                             root_key_i.creator_seed_valid,
                             root_key_i.owner_seed,
                             root_key_i.owner_seed_valid};

  // root key valid sync
  logic root_key_valid_q;

  prim_flop_2sync # (
    .Width(1)
  ) u_key_valid_sync (
    .clk_i,
    .rst_ni,
    // Both valid signals are flopped in OTP_CTRL, and they only ever transition from 0 -> 1.
    // It is hence ok to AND them here before the synchronizer, since we don't expect this
    // to create glitches.
    .d_i(root_key_i.creator_root_key_share0_valid &&
         root_key_i.creator_root_key_share1_valid),
    .q_o(root_key_valid_q)
  );

  // Do not let the count toggle unless an advance operation is
  // selected
  assign cdi_cnt = op_req ? cnt[CdiWidth-1:0] : '0;

  always_comb begin
    key_state_d = key_state_q;
    data_valid_o = 1'b0;
    wipe_key_o = 1'b0;

    // if a wipe request arrives, immediately destroy the
    // keys regardless of current state
    unique case (update_sel)
      KeyUpdateRandom: begin
        for (int i = 0; i < CDIs; i++) begin
          for (int j = 0; j < Shares; j++) begin
            // Load each share with the same randomness so we can
            // later simply XOR root key on them
            key_state_d[i][j][cnt[EntropyRndWidth-1:0]] = entropy_i[i];
          end
        end
      end

      KeyUpdateRoot: begin
        if (root_key_valid_q) begin
          for (int i = 0; i < CDIs; i++) begin
            if (KmacEnMasking) begin : gen_two_share_key
              key_state_d[i][0] ^= root_key_i.creator_root_key_share0;
              key_state_d[i][1] ^= root_key_i.creator_root_key_share1;
            end else begin : gen_one_share_key
              key_state_d[i][0] = root_key_i.creator_root_key_share0 ^
                                  root_key_i.creator_root_key_share1;
              key_state_d[i][1] = '0;
            end
          end
        end else begin
          // if root key is not valid, load and invalid value
          for (int i = 0; i < CDIs; i++) begin
              key_state_d[i][0] = '0;
              key_state_d[i][1] = '{default: '1};
          end
        end
      end

      KeyUpdateKmac: begin
        data_valid_o = gen_op;
        key_state_d[cdi_sel_o] = (adv_op || dis_op) ? kmac_data_i : key_state_q[cdi_sel_o];
      end

      KeyUpdateWipe: begin
        wipe_key_o = 1'b1;
        for (int i = 0; i < CDIs; i++) begin
          for (int j = 0; j < Shares; j++) begin
            key_state_d[i][j] = {EntropyRounds{entropy_i[j]}};
          end
        end
      end

      default:;
    endcase // unique case (update_sel)
  end

  // SEC_CM: CTRL.CTR.REDUN
  prim_count #(
    .Width(CntWidth)
  ) u_cnt (
    .clk_i,
    .rst_ni,
    .clr_i(op_ack | random_ack),
    .set_i('0),
    .set_cnt_i('0),
    .incr_en_i(op_update | random_req),
    .decr_en_i(1'b0),
    .step_i(CntWidth'(1'b1)),
    .commit_i(1'b1),
    .cnt_o(cnt),
    .cnt_after_commit_o(),
    .err_o(cnt_err)
  );


  prim_mubi4_sender u_hw_sel (
    .clk_i,
    .rst_ni,
    .mubi_i (prim_mubi_pkg::mubi4_bool_to_mubi(gen_out_hw_sel)),
    .mubi_o (hw_sel_o)
  );

  // when in a state that accepts commands, look at op_ack for completion
  // when in a state that does not accept commands, wait for other triggers.
  assign op_done_o = op_req ? op_ack :
                     (init_o | invalid_op);


  // There are 3 possibilities
  // advance to next state (software command)
  // advance to disabled state (software command)
  // advance to invalid state (detected fault)
  logic adv_state;
  logic dis_state;
  logic inv_state;
  assign adv_state = op_ack & adv_req & ~op_err;
  assign dis_state = op_ack & dis_req;

  // SEC_CM: CTRL.FSM.LOCAL_ESC
  // begin invalidation when faults are observed.
  // sync faults only invalidate on transaction boudaries
  // async faults begin invalidating immediately
  assign inv_state = |fault_o;

  always_comb begin
    // persistent data
    state_d = state_q;

    // request to op handling
    op_req = 1'b0;
    random_req = 1'b0;
    random_ack = 1'b0;

    // request to key updates
    wipe_req = 1'b0;

    // invalid operation issued
    invalid_op = '0;

    // data update and select signals
    stage_sel_o = Disable;

    // indication that state is disabled
    disabled = 1'b0;

    // indication that state is invalid
    invalid = 1'b0;

    // Don't request final PRNG updating and reseeding.
    prng_en_dis_inv_set = 1'b0;

    // Request PRNG reseeding.
    prng_reseed_req_o = 1'b0;

    // initialization complete
    init_o = 1'b0;

    // Most states are initialized, mark the exceptions
    initialized = 1'b1;

    // if state is ever faulted, hold on to this indication
    // until reset.
    state_intg_err_d = state_intg_err_q;

    unique case (state_q)
      // Only advance can be called from reset state
      StCtrlReset: begin
        initialized = 1'b0;

        // always use random data for advance, since out of reset state
        // the key state will be randomized.
        stage_sel_o = Disable;

        // key state is updated when it is an advance call
        // all other operations are invalid, including disable
        invalid_op = op_start_i & ~advance_sel;

        // if there was a structural fault before anything began, wipe immediately
        if (inv_state) begin
          state_d = StCtrlWipe;
        end else if (advance_sel) begin
          state_d = StCtrlEntropyReseed;
        end
      end

      // reseed entropy
      StCtrlEntropyReseed: begin
        initialized = 1'b0;
        prng_reseed_req_o = 1'b1;

        if (prng_reseed_ack_i) begin
          state_d = StCtrlRandom;
        end
      end

      // This state does not accept any command.
      StCtrlRandom: begin
        initialized = 1'b0;
        random_req = 1'b1;

        // when mask population is complete, xor the root_key into the zero share
        // if in the future the root key is updated to 2 shares, it will direclty overwrite
        // the values here
        if (int'(cnt) == EntropyRounds-1) begin
          random_ack = 1'b1;
          state_d = StCtrlRootKey;
        end
      end

      // load the root key.
      StCtrlRootKey: begin
        init_o = 1'b1;
        initialized = 1'b1;
        state_d = (en_i && root_key_valid_q) ? StCtrlInit : StCtrlWipe;
      end

      // Beginning from the Init state, operations are accepted.
      // Only valid operation is advance state. If invalid command received,
      // random data is selected for operation and no persistent state is changed.
      StCtrlInit: begin
        op_req = op_start_i;

        // when advancing select creator data, otherwise use random input
        stage_sel_o = advance_sel ? Creator : Disable;
        invalid_op = op_start_i & ~(advance_sel | disable_sel);

        if (!en_i || inv_state) begin
          state_d = StCtrlWipe;
        end else if (dis_state) begin
          state_d = StCtrlDisabled;
          prng_en_dis_inv_set = 1'b1;
        end else if (adv_state) begin
          state_d = StCtrlCreatorRootKey;
        end
      end

      // all commands  are valid during this stage
      StCtrlCreatorRootKey: begin
        op_req = op_start_i;

        // when generating, select creator data input
        // when advancing, select owner intermediate key as target
        // when disabling, select random data input
        stage_sel_o = disable_sel ? Disable  :
                      advance_sel ? OwnerInt : Creator;

        if (!en_i || inv_state) begin
          state_d = StCtrlWipe;
        end else if (dis_state) begin
          state_d = StCtrlDisabled;
          prng_en_dis_inv_set = 1'b1;
        end else if (adv_state) begin
          state_d = StCtrlOwnerIntKey;
        end
      end

      // all commands are valid during this stage
      StCtrlOwnerIntKey: begin
        op_req = op_start_i;

        // when generating, select owner intermediate data input
        // when advancing, select owner as target
        // when disabling, select random data input
        stage_sel_o = disable_sel ? Disable  :
                      advance_sel ? Owner : OwnerInt;

        if (!en_i || inv_state) begin
          state_d = StCtrlWipe;
        end else if (dis_state) begin
          state_d = StCtrlDisabled;
          prng_en_dis_inv_set = 1'b1;
        end else if (adv_state) begin
          state_d = StCtrlOwnerKey;
        end
      end

      // all commands are valid during this stage
      // however advance goes directly to disabled state
      StCtrlOwnerKey: begin
        op_req = op_start_i;

        // when generating, select owner data input
        // when advancing, select disable as target
        // when disabling, select random data input
        stage_sel_o = disable_sel | advance_sel ? Disable : Owner;

        if (!en_i || inv_state) begin
          state_d = StCtrlWipe;
        end else if (adv_state || dis_state) begin
          state_d = StCtrlDisabled;
          prng_en_dis_inv_set = 1'b1;
        end
      end

      // The wipe state immediately clears out the key state, but waits for any ongoing
      // transaction to finish before going to disabled state.
      // Unlike the random state, this is an immedaite shutdown request, so all parts of the
      // key are wiped.
      StCtrlWipe: begin
        wipe_req = 1'b1;
        // if there was already an operation ongoing, maintain the request until completion
        op_req = op_busy;
        invalid_op = op_start_i;

        // If the enable is dropped during the middle of a transaction, we clear and wait for that
        // transaction to gracefully complete (if it can).
        // There are two scenarios:
        // 1. the operation completed right when we started wiping, in which case the done would
        //    clear the start.
        // 2. the operation completed before we started wiping, or there was never an operation to
        //    begin with (op_start_i == 0), in this case, don't wait and immediately transition
        if (!op_start_i) begin
          state_d = StCtrlInvalid;
          prng_en_dis_inv_set = 1'b1;
        end
      end

      // StCtrlDisabled and StCtrlInvalid are almost functionally equivalent
      // The only difference is that Disabled is entered through software invocation,
      // while Invalid is entered through life cycle disable or operational fault.
      //
      // Both states continue to kick off random transactions
      // All transactions are treated as invalid despite completing
      StCtrlDisabled: begin
        op_req = op_start_i;
        disabled = 1'b1;

        if (!en_i || inv_state) begin
          state_d = StCtrlWipe;
        end
      end

      StCtrlInvalid: begin
        invalid_op = op_start_i;
        invalid = 1'b1;
      end

      // latch the fault indication and start to wipe the key manager
      default: begin
        state_intg_err_d = 1'b1;
        state_d = StCtrlWipe;
      end

    endcase // unique case (state_q)
  end // always_comb

  // Current working state provided for software read
  // Certain states are collapsed for simplicity
  keymgr_working_state_e last_working_st;
  logic update_en;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      last_working_st <= StReset;
    end else if (update_en) begin
      last_working_st <= working_state_o;
    end
  end

  always_comb begin
    update_en = 1'b1;
    working_state_o = StInvalid;

    unique case (state_q)
      StCtrlReset, StCtrlEntropyReseed, StCtrlRandom:
        working_state_o = StReset;

      StCtrlRootKey, StCtrlInit:
        working_state_o = StInit;

      StCtrlCreatorRootKey:
        working_state_o = StCreatorRootKey;

      StCtrlOwnerIntKey:
        working_state_o = StOwnerIntKey;

      StCtrlOwnerKey:
        working_state_o = StOwnerKey;

      StCtrlDisabled:
        working_state_o = StDisabled;

      StCtrlWipe: begin
        update_en = 1'b0;
        working_state_o = last_working_st;
      end

      StCtrlInvalid:
        working_state_o = StInvalid;

      default:
        working_state_o = StInvalid;
    endcase // unique case (state_q)
  end

  always_comb begin
    status_o = OpIdle;
    if (op_done_o) begin
      // It is possible for an operation to finish the same cycle en_i goes low.
      // The main fsm handling is one cycle behind, but still report operation
      // fail.
      status_o = |{error_o, fault_o} ? OpDoneFail : OpDoneSuccess;
    end else if (op_start_i) begin
      status_o = OpWip;
    end
  end


  /////////////////////////
  // Operateion state, handle advance and generate
  /////////////////////////

  logic op_fsm_err;
  keymgr_op_state_ctrl u_op_state (
    .clk_i,
    .rst_ni,
    .adv_req_i(adv_req),
    .dis_req_i(dis_req),
    .id_req_i(id_req),
    .gen_req_i(gen_req),
    .cnt_i(cdi_cnt),
    .op_ack_o(op_ack),
    .op_busy_o(op_busy),
    .op_update_o(op_update),
    .kmac_done_i,
    .adv_en_o,
    .id_en_o,
    .gen_en_o,
    .op_fsm_err_o(op_fsm_err)
  );

  // operational state cross check.  The state value must be consistent with
  // the input operations.
  logic op_state_cmd_err;
  assign op_state_cmd_err = (adv_en_o & ~(advance_sel | disable_sel)) |
                            (gen_en_o & ~gen_op);

  // operations fsm update precedence
  // when in invalid state, always update.
  // when in disabled state, always update unless a fault is encountered.
  assign op_update_sel = (op_ack | op_update) & invalid      ? KeyUpdateKmac :
                         (op_ack | op_update) & op_fault_err ? KeyUpdateWipe :
                         (op_ack | op_update) & disabled     ? KeyUpdateKmac :
                         (op_ack | op_update) & op_err       ? KeyUpdateIdle :
                         (op_ack | op_update)                ? KeyUpdateKmac : KeyUpdateIdle;


  ///////////////////////////////
  // Suppress kmac return data
  ///////////////////////////////

  logic data_fsm_err;
  keymgr_data_en_state u_data_en (
    .clk_i,
    .rst_ni,
    .hw_sel_i(hw_sel_o),
    .adv_en_i(adv_en_o),
    .id_en_i(id_en_o),
    .gen_en_i(gen_en_o),
    .op_done_i(op_done_o),
    .op_start_i,
    .data_hw_en_o,
    .data_sw_en_o,
    .fsm_err_o(data_fsm_err)
  );

  /////////////////////////
  // Cross-checks, errors and faults
  /////////////////////////

  logic vld_state_change_d, vld_state_change_q;
  assign vld_state_change_d = (state_d != state_q) &
                              (state_d inside {StCtrlRootKey,
                                               StCtrlCreatorRootKey,
                                               StCtrlOwnerIntKey,
                                               StCtrlOwnerKey});

  // capture for cross check in following cycle
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      vld_state_change_q <= '0;
    end else begin
      vld_state_change_q <= vld_state_change_d;
    end
  end

  // state cross check
  // if the state advanced, ensure that it was due to an advanced operation
  logic state_change_err;
  assign state_change_err = vld_state_change_q & !adv_op;

  keymgr_err u_err (
    .clk_i,
    .rst_ni,
    .invalid_op_i(invalid_op),
    .disabled_i(disabled | (initialized & ~en_i)),
    .invalid_i(invalid),
    .kmac_input_invalid_i,
    .shadowed_update_err_i,
    .kmac_op_err_i,
    .invalid_kmac_out_i(invalid_kmac_out),
    .sideload_sel_err_i,
    .kmac_cmd_err_i,
    .kmac_fsm_err_i,
    .kmac_done_err_i,
    .regfile_intg_err_i,
    .shadowed_storage_err_i,
    .ctrl_fsm_err_i(state_intg_err_q | state_intg_err_d),
    .data_fsm_err_i(data_fsm_err),
    .op_fsm_err_i(op_fsm_err),
    .ecc_err_i(|ecc_errs),
    .state_change_err_i(state_change_err),
    .op_state_cmd_err_i(op_state_cmd_err),
    .cnt_err_i(cnt_err),
    .reseed_cnt_err_i,
    .sideload_fsm_err_i,

    .op_update_i(op_update),
    .op_done_i(op_done_o),

    .sync_err_o(sync_err),
    .async_err_o(),
    .sync_fault_o(sync_fault),
    .async_fault_o(async_fault),
    .error_o,
    .fault_o
  );

  ///////////////////////////////
  // Functions
  ///////////////////////////////

  // unclear what this is supposed to be yet
  // right now just check to see if it not all 0's and not all 1's
 function automatic logic valid_data_chk (logic [KeyWidth-1:0] value);

    return |value & ~&value;

  endfunction // byte_mask

  /////////////////////////////////
  // Assertions
  /////////////////////////////////

  // This assertion will not work if fault_status ever takes on metafields such as
  // qe / re etc.
  `ASSERT_INIT(SameErrCnt_A, $bits(keymgr_reg2hw_fault_status_reg_t) ==
                             (SyncFaultLastIdx + AsyncFaultLastIdx))

  // stage select should always be Disable whenever it is not enabled
  `ASSERT(StageDisableSel_A, !en_i |-> stage_sel_o == Disable)

  // Unless it is a legal command, only select disable
  `ASSERT(InitLegalCommands_A, op_start_i & en_i & state_q inside {StCtrlInit} &
                               !(op_i inside {OpAdvance}) |-> stage_sel_o == Disable)

  // All commands are legal, so select disable only if operation is disable
  `ASSERT(GeneralLegalCommands_A, op_start_i & en_i &
                                  state_q inside {StCtrlCreatorRootKey, StCtrlOwnerIntKey} &
                                  (op_i inside {OpDisable}) |-> stage_sel_o == Disable)

  `ASSERT(OwnerLegalCommands_A, op_start_i & en_i & state_q inside {StCtrlOwnerKey} &
                                (op_i inside {OpAdvance, OpDisable}) |-> stage_sel_o == Disable)

  // load_key should not be high if there is no ongoing operation
  `ASSERT(LoadKey_A, key_o.valid |-> op_start_i)

  // The count value should always be 0 when a transaction start
  `ASSERT(CntZero_A, $rose(op_start_i) |-> cnt == '0)

  // Whenever a transaction completes, data_en must return to 0 on the next cycle
  `ASSERT(DataEnDis_A, op_start_i & op_done_o |=> ~data_hw_en_o && ~data_sw_en_o)

  // Whenever data enable asserts, it must be the case that there was a generate or
  // id operation
  `ASSERT(DataEn_A, data_hw_en_o | data_sw_en_o |-> (id_en_o | gen_en_o) & ~adv_en_o)

  // Check that the FSM is linear and does not contain any loops
  `ASSERT_FPV_LINEAR_FSM(SecCmCFILinear_A, state_q, state_e)

endmodule

    '''

    Identify relevant lint tags for the RTL to be checked for.
    Then run the tests using the linting tool.
    From the output of the linting tool, determine if there are security issues in the RTL.
================================== Ai Message ==================================
Tool Calls:
  retrieve_relevant_lint_tags (call_xDwbPvcRgXdHQPe1EONlNqf3)
 Call ID: call_xDwbPvcRgXdHQPe1EONlNqf3
  Args:
    query: FSM security privilege escalation illegal state transitions stuck-at faults
================================= Tool Message =================================
Name: retrieve_relevant_lint_tags


MissingFsmStateTransition: Reports violation for a missing state transitions, which are not possible in FSM 


STARC05-2.11.1.4: Number of states in a FSM should not exceed specified limit


NoExitFsmState: Reports violation if a state is reachable, and no other transition is possible in any of the clock cycle 


NotReachableFsmState: Reports violation for not reachable state in FSM


UnreachableStatesInFSM-ML: Next state assignment is not reached 


LINT_FSM_UNREACHABLE_STATES: Do not have unreachable states in FSMs


NoExitInFSM-ML: Do not have states without exit in FSMs 

FsmLiveLock: Detects livelock states in FSM

FsmUsage-ML: Finite State machine used


AsgnNextSt-ML: Next state variable is not assigned in the default state of Finite-state machine (FSM) 


FSMCurrentStateName-ML: Current state vector of FSM does not follow the naming convention 


LINT_FSM_WITHOUT_EXIT_STATE: Do not have states without exit in FSMs


LINT_FSM_WITHOUT_INITIAL_STATE: Do not have FSM without the initial state 


RegisterStuckInResetState-ML: Reports violation for the registers that are stuck in a constant initial state due to bad coding style 


FSMNextStateName-ML: State name prefix or suffix 


STARC05-2.11.1.2: Bit change in state transition should be minimal (use Gray code). (Verilog)Bit change in FSM state transitions should be minimized (use Gray code). (VHDL) 


STARC05-2.11.2.1: FSM description should not be mixed with other descriptions in the same module. (Verilog)FSM description should not be mixed with non-FSM descriptions in the same module (VHDL) 


STARC05-2.3.5.1: Flip-flops should not have fixed inputs 


STARC05-2.3.1.7a: A flip-flop should not have two asynchronous resets 


STARC05-1.4.3.1b: Clocks should not be gated 
================================== Ai Message ==================================
Tool Calls:
  lint_checker_tool (call_3dImkUQMEYZuOalqSOpq4552)
 Call ID: call_3dImkUQMEYZuOalqSOpq4552
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_ctrl.sv
    top_module: keymgr_ctrl
    lint_tags: ['MissingFsmStateTransition', 'NoExitFsmState', 'NotReachableFsmState', 'LINT_FSM_UNREACHABLE_STATES', 'NoExitInFSM-ML', 'FsmLiveLock', 'AsgnNextSt-ML', 'LINT_FSM_WITHOUT_EXIT_STATE', 'LINT_FSM_WITHOUT_INITIAL_STATE', 'RegisterStuckInResetState-ML']
================================= Tool Message =================================
Name: lint_checker_tool

Successfully executed:
```lint checker tool
```
Output: 
  -----------------------------------------------------------------------------
  Report Summary
  -----------------------------------------------------------------------------
  Product Info
    Name    : VC Static Master Shell
    Version : U-2023.03-1 -- Apr 17, 2023

  Report Info
    Created : May 06, 2025  16:26:52

    TopLevelModule: keymgr_ctrl

================================== Ai Message ==================================

The lint checks related to FSM security, privilege escalation, illegal state transitions, and stuck-at faults were executed on the RTL module "keymgr_ctrl" located at "/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_ctrl.sv".

No issues were reported by the lint tool. This indicates that the FSM in this RTL code does not have missing state transitions, unreachable states, livelocks, or states without exits. Also, no registers are stuck in reset state, and the FSM has an initial state.

Based on the lint check results, there are no apparent security issues related to FSM security, privilege escalation, illegal state transitions, or stuck-at faults in the provided RTL code.
================================= Tool Message =================================
Name: run_linter_agent

The lint checks related to FSM security, privilege escalation, illegal state transitions, and stuck-at faults were executed on the RTL module "keymgr_ctrl" located at "/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_ctrl.sv".

No issues were reported by the lint tool. This indicates that the FSM in this RTL code does not have missing state transitions, unreachable states, livelocks, or states without exits. Also, no registers are stuck in reset state, and the FSM has an initial state.

Based on the lint check results, there are no apparent security issues related to FSM security, privilege escalation, illegal state transitions, or stuck-at faults in the provided RTL code.
================================== Ai Message ==================================
Tool Calls:
  run_linter_agent (call_kUcyU3bXvsvSZAFrKZWXjT36)
 Call ID: call_kUcyU3bXvsvSZAFrKZWXjT36
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv
    top_module: keymgr_kmac_if
    security_objective: interface security, data leakage, privilege escalation, masking enforcement
================================ Human Message =================================

Are there security concerns related to interface security, data leakage, privilege escalation, masking enforcement in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv

    And the top module is:

    keymgr_kmac_if

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Key manager interface to kmac
//

`include "prim_assert.sv"

module keymgr_kmac_if
  import keymgr_pkg::*;
#(
  parameter rand_perm_t RndCnstRandPerm = RndCnstRandPermDefault
) (
  input clk_i,
  input rst_ni,

  // data input interfaces
  input [AdvDataWidth-1:0] adv_data_i,
  input [IdDataWidth-1:0] id_data_i,
  input [GenDataWidth-1:0] gen_data_i,
  input [3:0] inputs_invalid_i,
  output logic inputs_invalid_o,

  // keymgr control to select appropriate inputs
  input adv_en_i,
  input id_en_i,
  input gen_en_i,
  output logic done_o,
  output logic [Shares-1:0][kmac_pkg::AppDigestW-1:0] data_o,

  // actual connection to kmac
  output kmac_pkg::app_req_t kmac_data_o,
  input  kmac_pkg::app_rsp_t kmac_data_i,

  // entropy input
  output logic prng_en_o,
  input [Shares-1:0][RandWidth-1:0] entropy_i,

  // error outputs
  output logic fsm_error_o,
  output logic kmac_error_o,
  output logic kmac_done_error_o,
  output logic cmd_error_o
);


  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 5 -m 6 -n 10 \
  //      -s 2292624416 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: --
  //  4: --
  //  5: |||||||||||||||||||| (46.67%)
  //  6: ||||||||||||||||| (40.00%)
  //  7: ||||| (13.33%)
  //  8: --
  //  9: --
  // 10: --
  //
  // Minimum Hamming distance: 5
  // Maximum Hamming distance: 7
  // Minimum Hamming weight: 2
  // Maximum Hamming weight: 9
  //
  localparam int StateWidth = 10;
  typedef enum logic [StateWidth-1:0] {
    StIdle    = 10'b1110100010,
    StTx      = 10'b0010011011,
    StTxLast  = 10'b0101000000,
    StOpWait  = 10'b1000101001,
    StClean   = 10'b1111111101,
    StError   = 10'b0011101110
  } data_state_e;

  localparam int AdvRem = AdvDataWidth % KmacDataIfWidth;
  localparam int IdRem  = IdDataWidth  % KmacDataIfWidth;
  localparam int GenRem = GenDataWidth % KmacDataIfWidth;

  // the remainder must be in number of bytes
  `ASSERT_INIT(AdvRemBytes_A, AdvRem % 8 == 0)
  `ASSERT_INIT(IdRemBytes_A,  IdRem  % 8 == 0)
  `ASSERT_INIT(GenRemBytes_A, GenRem % 8 == 0)

  // Number of kmac transactions required
  localparam int AdvRounds = (AdvDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
  localparam int IdRounds  = (IdDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
  localparam int GenRounds = (GenDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
  localparam int MaxRounds = KDFMaxWidth  / KmacDataIfWidth;

  // calculated parameters for number of roudns and interface width
  localparam int CntWidth = $clog2(MaxRounds);
  localparam int IfBytes = KmacDataIfWidth / 8;
  localparam int DecoyCopies = KmacDataIfWidth / RandWidth;
  localparam int DecoyOutputCopies = (kmac_pkg::AppDigestW / RandWidth);

  localparam int unsigned LastAdvRoundInt = AdvRounds - 1;
  localparam int unsigned LastIdRoundInt = IdRounds - 1;
  localparam int unsigned LastGenRoundInt = GenRounds - 1;
  localparam bit [CntWidth-1:0] LastAdvRound = LastAdvRoundInt[CntWidth-1:0];
  localparam bit [CntWidth-1:0] LastIdRound = LastIdRoundInt[CntWidth-1:0];
  localparam bit [CntWidth-1:0] LastGenRound = LastGenRoundInt[CntWidth-1:0];

  // byte mask for the last transfer
  localparam logic [IfBytes-1:0] AdvByteMask = (AdvRem > 0) ? (2**(AdvRem/8)-1) : {IfBytes{1'b1}};
  localparam logic [IfBytes-1:0] IdByteMask  = (IdRem > 0)  ? (2**(IdRem/8)-1)  : {IfBytes{1'b1}};
  localparam logic [IfBytes-1:0] GenByteMask = (GenRem > 0) ? (2**(GenRem/8)-1) : {IfBytes{1'b1}};

  logic [MaxRounds-1:0][KmacDataIfWidth-1:0] adv_data;
  logic [MaxRounds-1:0][KmacDataIfWidth-1:0] id_data;
  logic [MaxRounds-1:0][KmacDataIfWidth-1:0] gen_data;
  logic [CntWidth-1:0] cnt;
  logic [CntWidth-1:0] rounds;
  logic [KmacDataIfWidth-1:0] decoy_data;
  logic valid;
  logic last;
  logic [IfBytes-1:0] strb;
  logic cnt_clr, cnt_set, cnt_en;
  logic start;
  logic [3:0] inputs_invalid_d, inputs_invalid_q;
  logic clr_err;
  logic kmac_done_vld;
  logic cmd_chk;

  data_state_e state_q, state_d;

  // 0 pad to the appropriate width
  // this is basically for scenarios where *DataWidth % KmacDataIfWidth != 0
  assign adv_data = KDFMaxWidth'(adv_data_i);
  assign id_data  = KDFMaxWidth'(id_data_i);
  assign gen_data = KDFMaxWidth'(gen_data_i);

  assign start = adv_en_i | id_en_i | gen_en_i;

  logic cnt_err;
  // SEC_CM: KMAC_IF.CTR.REDUN
  prim_count #(
    .Width(CntWidth),
    .ResetValue({CntWidth{1'b1}})
  ) u_cnt (
    .clk_i,
    .rst_ni,
    .clr_i(cnt_clr),
    .set_i(cnt_set),
    .set_cnt_i(rounds),
    .incr_en_i(1'b0),
    .decr_en_i(cnt_en),
    .step_i(CntWidth'(1'b1)),
    .commit_i(1'b1),
    .cnt_o(cnt),
    .cnt_after_commit_o(),
    .err_o(cnt_err)
  );

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      inputs_invalid_q <= '0;
    end else begin
      inputs_invalid_q <= inputs_invalid_d;
    end
   end

  // SEC_CM: KMAC_IF.FSM.SPARSE
  `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, data_state_e, StIdle)

  always_comb begin
    cnt_clr = 1'b0;
    cnt_set = 1'b0;
    cnt_en  = 1'b0;
    valid   = 1'b0;
    last    = 1'b0;
    strb    = '0;
    done_o  = 1'b0;
    state_d = state_q;
    rounds  = '0;

    clr_err = '0;
    fsm_error_o = '0;
    kmac_error_o = '0;

    kmac_done_vld = '0;

    cmd_chk = 1'b1;

    unique case (state_q)

      StIdle: begin
        // if for some reason multiple bits are set, adv_en has priority
        // as the current key state will be destroyed

        // cross check for commands once transaction begins
        cmd_chk = '0;
        if (start) begin
          cnt_set = 1'b1;
          if (adv_en_i) begin
            rounds = LastAdvRound;
          end else if (id_en_i) begin
            rounds = LastIdRound;
          end else if (gen_en_i) begin
            rounds = LastGenRound;
          end
          // in case we are sending only 1 entry
          state_d = (rounds == 0) ? StTxLast : StTx;
        end
      end

      StTx: begin
        valid = 1'b1;
        strb = {IfBytes{1'b1}};

        // transaction accepted
        if (kmac_data_i.ready) begin
          cnt_en = 1'b1;

          // second to last beat
          if (cnt == CntWidth'(1'b1)) begin
            state_d = StTxLast;
          end
        end

      end

      StTxLast: begin
        valid = 1'b1;
        last = 1'b1;

        if (adv_en_i) begin
          strb = AdvByteMask;
        end else if (id_en_i) begin
          strb = IdByteMask;
        end else if (gen_en_i) begin
          strb = GenByteMask;
        end

        // transaction accepted
        cnt_clr = kmac_data_i.ready;
        state_d = kmac_data_i.ready ? StOpWait : StTxLast;

      end

      StOpWait: begin
        kmac_done_vld = 1'b1;
        if (kmac_data_i.done) begin
          kmac_error_o = kmac_data_i.error;
          done_o = 1'b1;
          state_d = StClean;
        end
      end

      StClean: begin
        cmd_chk = '0;
        done_o = 1'b1;

        // wait for control side to ack done by waiting start de-assertion
        if (!start) begin
          done_o = 1'b0;
          clr_err = 1'b1;
          state_d = StIdle;
        end
      end

      // trigger error
      default: begin
        // This state is terminal
        done_o = 1'b1;
        fsm_error_o = 1'b1;
      end

    endcase // unique case (state_q)

    // unconditional error transitions
    // counter errors may disturb the fsm flow and are
    // treated like fsm errors
    if (cnt_err) begin
      state_d = StError;
      fsm_error_o = 1;
      done_o = 1'b1;
    end
  end

  // when transaction is not complete, populate the data with random
  assign data_o = start && done_o ?
                  {kmac_data_i.digest_share1,
                   kmac_data_i.digest_share0} :
                  {{DecoyOutputCopies{entropy_i[1]}},
                   {DecoyOutputCopies{entropy_i[0]}}};

  // The input invalid check is done whenever transactions are ongoing with kmac
  // once set, it cannot be unset until transactions are fully complete
  always_comb begin
    inputs_invalid_d = inputs_invalid_q;

    if (clr_err) begin
      inputs_invalid_d = '0;
    end else if (valid) begin
      inputs_invalid_d[OpAdvance]  = adv_en_i & (inputs_invalid_i[OpAdvance] |
                                                 inputs_invalid_q[OpAdvance]);
      inputs_invalid_d[OpGenId]    = id_en_i  & (inputs_invalid_i[OpGenId]   |
                                                 inputs_invalid_q[OpGenId]);
      inputs_invalid_d[OpGenSwOut] = gen_en_i & (inputs_invalid_i[OpGenSwOut]|
                                                 inputs_invalid_q[OpGenSwOut]);
      inputs_invalid_d[OpGenHwOut] = gen_en_i & (inputs_invalid_i[OpGenHwOut]|
                                                 inputs_invalid_q[OpGenHwOut]);
    end
  end

  // immediately assert errors
  assign inputs_invalid_o = |inputs_invalid_d;

  // Permute Share 1 of the entropy input once more to get the decoy data.
  // Share 0 and 1 are used as is for data_o (connected to the sideload ports).
  logic [RandWidth-1:0] decoy_entropy;
  assign decoy_entropy = perm_data(entropy_i[1], RndCnstRandPerm);
  assign decoy_data = {DecoyCopies{decoy_entropy}};

  logic [CntWidth-1:0] adv_sel, id_sel, gen_sel;
  assign adv_sel = LastAdvRound - cnt;
  assign id_sel = LastIdRound - cnt;
  assign gen_sel = LastGenRound - cnt;

  // The count is maintained as a downcount
  // so a subtract is necessary to send the right byte
  // alternatively we can also reverse the order of the input
  always_comb begin
    kmac_data_o.data  = decoy_data;
    if (|cmd_error_o || inputs_invalid_o || fsm_error_o) begin
      kmac_data_o.data  = decoy_data;
    end else if (valid && adv_en_i) begin
      kmac_data_o.data  = adv_data[adv_sel];
    end else if (valid && id_en_i) begin
      kmac_data_o.data  = id_data[id_sel];
    end else if (valid && gen_en_i) begin
      kmac_data_o.data  = gen_data[gen_sel];
    end
  end

  assign kmac_data_o.valid = valid;
  assign kmac_data_o.last  = last;
  assign kmac_data_o.strb  = strb;

  // kmac done is asserted outside of expected window
  // SEC_CM: KMAC_IF_DONE.CTRL.CONSISTENCY
  logic kmac_done_err_q, kmac_done_err_d;
  assign kmac_done_err_d = ~kmac_done_vld & kmac_data_i.done |
                           kmac_done_err_q;
  assign kmac_done_error_o = kmac_done_err_q;


  // the enables must be 1 hot
  logic [2:0] enables_d, enables_q, enables_sub;
  assign enables_d = {adv_en_i, id_en_i, gen_en_i};
  assign enables_sub = enables_d - 1'b1;

  // cross check to ensure the one-hot command that kicked off
  // the transaction remains consistent throughout.
  logic cmd_consty_err_q, cmd_consty_err_d;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      enables_q <= '0;
    end else if (cnt_set) begin
      enables_q <= enables_d;
    end
  end
  assign cmd_consty_err_d = (cmd_chk & (enables_q != enables_d)) |
                            cmd_consty_err_q;

  // if a one hot error occurs, latch onto it permanently
  // SEC_CM: KMAC_IF_CMD.CTRL.CONSISTENCY
  logic one_hot_err_q, one_hot_err_d;
  assign one_hot_err_d = |(enables_d & enables_sub) |
                         one_hot_err_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      one_hot_err_q <= '0;
      kmac_done_err_q <= '0;
      cmd_consty_err_q <= '0;
    end else begin
      one_hot_err_q <= one_hot_err_d;
      kmac_done_err_q <= kmac_done_err_d;
      cmd_consty_err_q <= cmd_consty_err_d;
    end
  end

  // command error occurs if kmac errors or if the command itself is invalid
  assign cmd_error_o = one_hot_err_q | cmd_consty_err_q;

  // request entropy to churn whenever a transaction is accepted
  assign prng_en_o = kmac_data_o.valid & kmac_data_i.ready;

  // as long as we are transmitting, the strobe should never be 0.
  `ASSERT(LastStrb_A, valid |-> strb != '0)


endmodule // keymgr_kmac_if

    '''

    Identify relevant lint tags for the RTL to be checked for.
    Then run the tests using the linting tool.
    From the output of the linting tool, determine if there are security issues in the RTL.
================================== Ai Message ==================================
Tool Calls:
  retrieve_relevant_lint_tags (call_85GkswYngbA8hMCAthM74mJv)
 Call ID: call_85GkswYngbA8hMCAthM74mJv
  Args:
    query: interface security data leakage privilege escalation masking enforcement
================================= Tool Message =================================
Name: retrieve_relevant_lint_tags


W215: Reports inappropriate bit-selects of integer or time variables 

ExplicitSignExtend-ML: Reports explicit sign extension

DetectBlackBoxes-ML: Black box instance detected


STARC05-2.10.5.3b: Reports violation when there are three or more arithmetic operations in Always block 


W502: Ensure that a variable in the sensitivity list is not modified inside the xxxviiiSynopsys, Inc. Feedbackalways block 


UniquePriorityMisuse-ML: Detects if unique, unique0, and priority keywords are misused in case constructs 


STARC05-1.4.3.1b: Clocks should not be gated 


SelfAssignment-ML: Same operand on both sides of combinational assignment detected 

W243: Recursive task enable


STARC05-1.2.1.1a: Design should use only one edge of a clock 


DetectUnderAndOverFlows-ML: Capture underflows and overflows due to castings 


W450L: Reports multi-bit expression used as latch enable condition 


STARC05-2.2.2.2b: Do not define constants in the sensitivity list 


AssignPatInInst-ML: Detect assignment patterns in parameter override or port connection area 


MemConflict-ML: Possible memory conflict (overwrite) detected 


STARC05-1.3.2.1a: Asynchronous resets or sets must not be gated 


DisallowCaseZ-ML: Do not use casez constructs in the design 

DeepMux: Deep MUX detected - potential performance problem


NonBlockingCounters-ML: Non-blocking counter assignment found 


SafeLatch-ML: Identifies the unsafe latch triplets 
================================== Ai Message ==================================
Tool Calls:
  lint_checker_tool (call_AcITH7RDaMzK0fXxWiq5NGXG)
 Call ID: call_AcITH7RDaMzK0fXxWiq5NGXG
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv
    top_module: keymgr_kmac_if
    lint_tags: ['W215', 'ExplicitSignExtend-ML', 'DetectBlackBoxes-ML', 'STARC05-2.10.5.3b', 'W502', 'UniquePriorityMisuse-ML', 'STARC05-1.4.3.1b', 'SelfAssignment-ML', 'W243', 'STARC05-1.2.1.1a', 'DetectUnderAndOverFlows-ML', 'W450L', 'STARC05-2.2.2.2b', 'AssignPatInInst-ML', 'MemConflict-ML', 'STARC05-1.3.2.1a', 'DisallowCaseZ-ML', 'DeepMux', 'NonBlockingCounters-ML', 'SafeLatch-ML']
================================= Tool Message =================================
Name: lint_checker_tool

Successfully executed:
```lint checker tool
```
Output: 
  -----------------------------------------------------------------------------
  Report Summary
  -----------------------------------------------------------------------------
  Product Info
    Name    : VC Static Master Shell
    Version : U-2023.03-1 -- Apr 17, 2023

  Report Info
    Created : May 06, 2025  16:27:40

    TopLevelModule: keymgr_kmac_if

  -----------------------------------------------------------------------------
  Management Summary
  -----------------------------------------------------------------------------
  Stage           Family      Fatals    Errors  Warnings     Infos
  -----           --------  --------  --------  --------  --------
  LANGUAGE_CHECK  CODING           0         6         0         0
  -----           --------  --------  --------  --------  --------
  Total                            0         6         0         0


  -----------------------------------------------------------------------------
  Tree Summary
  -----------------------------------------------------------------------------
  Severity  Stage           Tag                           Count
  --------  -----           ----------------------------  -----
  error     LANGUAGE_CHECK  DetectUnderAndOverFlows-ML        5
  error     LANGUAGE_CHECK  UniquePriorityMisuse-ML           1
  --------  -----           ----------------------------  -----
  Total                                                       6



  -----------------------------------------------------------------------------
  DetectUnderAndOverFlows-ML  (5 errors/0 waived)
  -----------------------------------------------------------------------------
  Tag           : DetectUnderAndOverFlows-ML
  Description   : Casting of '[NodeName]' causes padding of '[ConstValue]' bits. [Hierarchy: '[HIERARCHY]']
  Violation     : Lint:5
  Module        : keymgr_kmac_if
  FileName      : build/lowrisc_ip_keymgr_0.1/src/lowrisc_ip_keymgr_0.1/rtl/keymgr_kmac_if.sv
  LineNumber    : 153
  Statement     :     .step_i(CntWidth'(1'b1)),
  NodeName      : CntWidth'(1'b1)
  ConstValue    : 4
  HIERARCHY     : :keymgr_kmac_if
  -----------------------------------------------------------------------------
  Tag           : DetectUnderAndOverFlows-ML
  Description   : Casting of '[NodeName]' causes padding of '[ConstValue]' bits. [Hierarchy: '[HIERARCHY]']
  Violation     : Lint:4
  Module        : keymgr_kmac_if
  FileName      : build/lowrisc_ip_keymgr_0.1/src/lowrisc_ip_keymgr_0.1/rtl/keymgr_kmac_if.sv
  LineNumber    : 136
  Statement     :   assign gen_data = KDFMaxWidth'(gen_data_i);
  NodeName      : KDFMaxWidth'(gen_data_i)
  ConstValue    : 800
  HIERARCHY     : :keymgr_kmac_if
  -----------------------------------------------------------------------------
  Tag           : DetectUnderAndOverFlows-ML
  Description   : Casting of '[NodeName]' causes padding of '[ConstValue]' bits. [Hierarchy: '[HIERARCHY]']
  Violation     : Lint:3
  Module        : keymgr_kmac_if
  FileName      : build/lowrisc_ip_keymgr_0.1/src/lowrisc_ip_keymgr_0.1/rtl/keymgr_kmac_if.sv
  LineNumber    : 135
  Statement     :   assign id_data  = KDFMaxWidth'(id_data_i);
  NodeName      : KDFMaxWidth'(id_data_i)
  ConstValue    : 1344
  HIERARCHY     : :keymgr_kmac_if
  -----------------------------------------------------------------------------
  Tag           : DetectUnderAndOverFlows-ML
  Description   : Casting of '[NodeName]' causes padding of '[ConstValue]' bits. [Hierarchy: '[HIERARCHY]']
  Violation     : Lint:2
  Module        : keymgr_kmac_if
  FileName      : build/lowrisc_ip_keymgr_0.1/src/lowrisc_ip_keymgr_0.1/rtl/keymgr_kmac_if.sv
  LineNumber    : 134
  Statement     :   assign adv_data = KDFMaxWidth'(adv_data_i);
  NodeName      : KDFMaxWidth'(adv_data_i)
  ConstValue    : 448
  HIERARCHY     : :keymgr_kmac_if
  -----------------------------------------------------------------------------
  Tag           : DetectUnderAndOverFlows-ML
  Description   : Casting of '[NodeName]' causes padding of '[ConstValue]' bits. [Hierarchy: '[HIERARCHY]']
  Violation     : Lint:6
  Module        : keymgr_kmac_if
  FileName      : build/lowrisc_ip_keymgr_0.1/src/lowrisc_ip_keymgr_0.1/rtl/keymgr_kmac_if.sv
  LineNumber    : 221
  Statement     :           if (cnt == CntWidth'(1'b1)) begin
  NodeName      : CntWidth'(1'b1)
  ConstValue    : 4
  HIERARCHY     : :keymgr_kmac_if

  -----------------------------------------------------------------------------
  UniquePriorityMisuse-ML  (1 error/0 waived)
  -----------------------------------------------------------------------------
  Tag           : UniquePriorityMisuse-ML
  Description   : Use of [NodeType] construct in [NodeType1] block
  Violation     : Lint:1
  Module        : keymgr_kmac_if
  FileName      : build/lowrisc_ip_keymgr_0.1/src/lowrisc_ip_keymgr_0.1/rtl/keymgr_kmac_if.sv
  LineNumber    : 190
  Statement     :     unique case (state_q)
  NodeType      : unique
  NodeType1     : Case

================================== Ai Message ==================================

The lint check on the RTL module keymgr_kmac_if reported the following issues:

1. DetectUnderAndOverFlows-ML (5 errors):
   - These errors are related to casting operations causing padding of bits. For example, casting expressions like KDFMaxWidth'(adv_data_i) cause padding of bits. This is seen in multiple lines (134, 135, 136, 153, 221).
   - While these are errors, they are related to data width casting and padding, which may not directly indicate a security vulnerability but could potentially cause functional issues or unintended data handling.

2. UniquePriorityMisuse-ML (1 error):
   - There is a misuse of the 'unique' keyword in a case statement at line 190.
   - This could lead to unintended behavior in the FSM state transitions, which might affect the control flow and potentially cause security issues if the FSM does not behave as expected.

No direct lint warnings or errors specifically indicating interface security, data leakage, privilege escalation, or masking enforcement issues were reported by the lint tool.

Summary:
- The main issues are related to casting and the use of 'unique' in the case statement.
- There are no explicit lint errors indicating security vulnerabilities such as data leakage or privilege escalation.
- However, the casting issues and FSM control flow misuse should be reviewed and fixed to ensure correct and secure operation.

Recommendation:
- Review and correct the casting operations to avoid unintended padding.
- Fix the misuse of 'unique' in the case statement to ensure proper FSM behavior.
- Conduct further security-specific reviews or formal verification if needed to confirm no security issues exist.
================================= Tool Message =================================
Name: run_linter_agent

The lint check on the RTL module keymgr_kmac_if reported the following issues:

1. DetectUnderAndOverFlows-ML (5 errors):
   - These errors are related to casting operations causing padding of bits. For example, casting expressions like KDFMaxWidth'(adv_data_i) cause padding of bits. This is seen in multiple lines (134, 135, 136, 153, 221).
   - While these are errors, they are related to data width casting and padding, which may not directly indicate a security vulnerability but could potentially cause functional issues or unintended data handling.

2. UniquePriorityMisuse-ML (1 error):
   - There is a misuse of the 'unique' keyword in a case statement at line 190.
   - This could lead to unintended behavior in the FSM state transitions, which might affect the control flow and potentially cause security issues if the FSM does not behave as expected.

No direct lint warnings or errors specifically indicating interface security, data leakage, privilege escalation, or masking enforcement issues were reported by the lint tool.

Summary:
- The main issues are related to casting and the use of 'unique' in the case statement.
- There are no explicit lint errors indicating security vulnerabilities such as data leakage or privilege escalation.
- However, the casting issues and FSM control flow misuse should be reviewed and fixed to ensure correct and secure operation.

Recommendation:
- Review and correct the casting operations to avoid unintended padding.
- Fix the misuse of 'unique' in the case statement to ensure proper FSM behavior.
- Conduct further security-specific reviews or formal verification if needed to confirm no security issues exist.
================================== Ai Message ==================================
Tool Calls:
  run_assertions_checker_agent (call_mjyHKNEiOcoW0iZsVx4OcKRr)
 Call ID: call_mjyHKNEiOcoW0iZsVx4OcKRr
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv
    top_module: keymgr_reg_top
    security_objective: register access policy, privilege escalation, shadow register integrity
================================ Human Message =================================

Are there security concerns related to register access policy, privilege escalation, shadow register integrity in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv

    And the top module is:

    keymgr_reg_top

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Register Top module auto-generated by `reggen`

`include "prim_assert.sv"

module keymgr_reg_top (
  input clk_i,
  input rst_ni,
  input rst_shadowed_ni,
  input  tlul_pkg::tl_h2d_t tl_i,
  output tlul_pkg::tl_d2h_t tl_o,
  // To HW
  output keymgr_reg_pkg::keymgr_reg2hw_t reg2hw, // Write
  input  keymgr_reg_pkg::keymgr_hw2reg_t hw2reg, // Read

  output logic shadowed_storage_err_o,
  output logic shadowed_update_err_o,

  // Integrity check errors
  output logic intg_err_o
);

  import keymgr_reg_pkg::* ;

  localparam int AW = 8;
  localparam int DW = 32;
  localparam int DBW = DW/8;                    // Byte Width

  // register signals
  logic           reg_we;
  logic           reg_re;
  logic [AW-1:0]  reg_addr;
  logic [DW-1:0]  reg_wdata;
  logic [DBW-1:0] reg_be;
  logic [DW-1:0]  reg_rdata;
  logic           reg_error;

  logic          addrmiss, wr_err;

  logic [DW-1:0] reg_rdata_next;
  logic reg_busy;

  tlul_pkg::tl_h2d_t tl_reg_h2d;
  tlul_pkg::tl_d2h_t tl_reg_d2h;


  // incoming payload check
  logic intg_err;
  tlul_cmd_intg_chk u_chk (
    .tl_i(tl_i),
    .err_o(intg_err)
  );

  // also check for spurious write enables
  logic reg_we_err;
  logic [62:0] reg_we_check;
  prim_reg_we_check #(
    .OneHotWidth(63)
  ) u_prim_reg_we_check (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .oh_i  (reg_we_check),
    .en_i  (reg_we && !addrmiss),
    .err_o (reg_we_err)
  );

  logic err_q;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      err_q <= '0;
    end else if (intg_err || reg_we_err) begin
      err_q <= 1'b1;
    end
  end

  // integrity error output is permanent and should be used for alert generation
  // register errors are transactional
  assign intg_err_o = err_q | intg_err | reg_we_err;

  // outgoing integrity generation
  tlul_pkg::tl_d2h_t tl_o_pre;
  tlul_rsp_intg_gen #(
    .EnableRspIntgGen(1),
    .EnableDataIntgGen(1)
  ) u_rsp_intg_gen (
    .tl_i(tl_o_pre),
    .tl_o(tl_o)
  );

  assign tl_reg_h2d = tl_i;
  assign tl_o_pre   = tl_reg_d2h;

  tlul_adapter_reg #(
    .RegAw(AW),
    .RegDw(DW),
    .EnableDataIntgGen(0)
  ) u_reg_if (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),

    .tl_i (tl_reg_h2d),
    .tl_o (tl_reg_d2h),

    .en_ifetch_i(prim_mubi_pkg::MuBi4False),
    .intg_error_o(),

    .we_o    (reg_we),
    .re_o    (reg_re),
    .addr_o  (reg_addr),
    .wdata_o (reg_wdata),
    .be_o    (reg_be),
    .busy_i  (reg_busy),
    .rdata_i (reg_rdata),
    .error_i (reg_error)
  );

  // cdc oversampling signals

  assign reg_rdata = reg_rdata_next ;
  assign reg_error = addrmiss | wr_err | intg_err;

  // Define SW related signals
  // Format: <reg>_<field>_{wd|we|qs}
  //        or <reg>_{wd|we|qs} if field == 1 or 0
  logic intr_state_we;
  logic intr_state_qs;
  logic intr_state_wd;
  logic intr_enable_we;
  logic intr_enable_qs;
  logic intr_enable_wd;
  logic intr_test_we;
  logic intr_test_wd;
  logic alert_test_we;
  logic alert_test_recov_operation_err_wd;
  logic alert_test_fatal_fault_err_wd;
  logic cfg_regwen_re;
  logic cfg_regwen_qs;
  logic start_we;
  logic start_qs;
  logic start_wd;
  logic control_shadowed_re;
  logic control_shadowed_we;
  logic [2:0] control_shadowed_operation_qs;
  logic [2:0] control_shadowed_operation_wd;
  logic control_shadowed_operation_storage_err;
  logic control_shadowed_operation_update_err;
  logic control_shadowed_cdi_sel_qs;
  logic control_shadowed_cdi_sel_wd;
  logic control_shadowed_cdi_sel_storage_err;
  logic control_shadowed_cdi_sel_update_err;
  logic [1:0] control_shadowed_dest_sel_qs;
  logic [1:0] control_shadowed_dest_sel_wd;
  logic control_shadowed_dest_sel_storage_err;
  logic control_shadowed_dest_sel_update_err;
  logic sideload_clear_we;
  logic [2:0] sideload_clear_qs;
  logic [2:0] sideload_clear_wd;
  logic reseed_interval_regwen_we;
  logic reseed_interval_regwen_qs;
  logic reseed_interval_regwen_wd;
  logic reseed_interval_shadowed_re;
  logic reseed_interval_shadowed_we;
  logic [15:0] reseed_interval_shadowed_qs;
  logic [15:0] reseed_interval_shadowed_wd;
  logic reseed_interval_shadowed_storage_err;
  logic reseed_interval_shadowed_update_err;
  logic sw_binding_regwen_re;
  logic sw_binding_regwen_we;
  logic sw_binding_regwen_qs;
  logic sw_binding_regwen_wd;
  logic sealing_sw_binding_0_we;
  logic [31:0] sealing_sw_binding_0_qs;
  logic [31:0] sealing_sw_binding_0_wd;
  logic sealing_sw_binding_1_we;
  logic [31:0] sealing_sw_binding_1_qs;
  logic [31:0] sealing_sw_binding_1_wd;
  logic sealing_sw_binding_2_we;
  logic [31:0] sealing_sw_binding_2_qs;
  logic [31:0] sealing_sw_binding_2_wd;
  logic sealing_sw_binding_3_we;
  logic [31:0] sealing_sw_binding_3_qs;
  logic [31:0] sealing_sw_binding_3_wd;
  logic sealing_sw_binding_4_we;
  logic [31:0] sealing_sw_binding_4_qs;
  logic [31:0] sealing_sw_binding_4_wd;
  logic sealing_sw_binding_5_we;
  logic [31:0] sealing_sw_binding_5_qs;
  logic [31:0] sealing_sw_binding_5_wd;
  logic sealing_sw_binding_6_we;
  logic [31:0] sealing_sw_binding_6_qs;
  logic [31:0] sealing_sw_binding_6_wd;
  logic sealing_sw_binding_7_we;
  logic [31:0] sealing_sw_binding_7_qs;
  logic [31:0] sealing_sw_binding_7_wd;
  logic attest_sw_binding_0_we;
  logic [31:0] attest_sw_binding_0_qs;
  logic [31:0] attest_sw_binding_0_wd;
  logic attest_sw_binding_1_we;
  logic [31:0] attest_sw_binding_1_qs;
  logic [31:0] attest_sw_binding_1_wd;
  logic attest_sw_binding_2_we;
  logic [31:0] attest_sw_binding_2_qs;
  logic [31:0] attest_sw_binding_2_wd;
  logic attest_sw_binding_3_we;
  logic [31:0] attest_sw_binding_3_qs;
  logic [31:0] attest_sw_binding_3_wd;
  logic attest_sw_binding_4_we;
  logic [31:0] attest_sw_binding_4_qs;
  logic [31:0] attest_sw_binding_4_wd;
  logic attest_sw_binding_5_we;
  logic [31:0] attest_sw_binding_5_qs;
  logic [31:0] attest_sw_binding_5_wd;
  logic attest_sw_binding_6_we;
  logic [31:0] attest_sw_binding_6_qs;
  logic [31:0] attest_sw_binding_6_wd;
  logic attest_sw_binding_7_we;
  logic [31:0] attest_sw_binding_7_qs;
  logic [31:0] attest_sw_binding_7_wd;
  logic salt_0_we;
  logic [31:0] salt_0_qs;
  logic [31:0] salt_0_wd;
  logic salt_1_we;
  logic [31:0] salt_1_qs;
  logic [31:0] salt_1_wd;
  logic salt_2_we;
  logic [31:0] salt_2_qs;
  logic [31:0] salt_2_wd;
  logic salt_3_we;
  logic [31:0] salt_3_qs;
  logic [31:0] salt_3_wd;
  logic salt_4_we;
  logic [31:0] salt_4_qs;
  logic [31:0] salt_4_wd;
  logic salt_5_we;
  logic [31:0] salt_5_qs;
  logic [31:0] salt_5_wd;
  logic salt_6_we;
  logic [31:0] salt_6_qs;
  logic [31:0] salt_6_wd;
  logic salt_7_we;
  logic [31:0] salt_7_qs;
  logic [31:0] salt_7_wd;
  logic key_version_we;
  logic [31:0] key_version_qs;
  logic [31:0] key_version_wd;
  logic max_creator_key_ver_regwen_we;
  logic max_creator_key_ver_regwen_qs;
  logic max_creator_key_ver_regwen_wd;
  logic max_creator_key_ver_shadowed_re;
  logic max_creator_key_ver_shadowed_we;
  logic [31:0] max_creator_key_ver_shadowed_qs;
  logic [31:0] max_creator_key_ver_shadowed_wd;
  logic max_creator_key_ver_shadowed_storage_err;
  logic max_creator_key_ver_shadowed_update_err;
  logic max_owner_int_key_ver_regwen_we;
  logic max_owner_int_key_ver_regwen_qs;
  logic max_owner_int_key_ver_regwen_wd;
  logic max_owner_int_key_ver_shadowed_re;
  logic max_owner_int_key_ver_shadowed_we;
  logic [31:0] max_owner_int_key_ver_shadowed_qs;
  logic [31:0] max_owner_int_key_ver_shadowed_wd;
  logic max_owner_int_key_ver_shadowed_storage_err;
  logic max_owner_int_key_ver_shadowed_update_err;
  logic max_owner_key_ver_regwen_we;
  logic max_owner_key_ver_regwen_qs;
  logic max_owner_key_ver_regwen_wd;
  logic max_owner_key_ver_shadowed_re;
  logic max_owner_key_ver_shadowed_we;
  logic [31:0] max_owner_key_ver_shadowed_qs;
  logic [31:0] max_owner_key_ver_shadowed_wd;
  logic max_owner_key_ver_shadowed_storage_err;
  logic max_owner_key_ver_shadowed_update_err;
  logic sw_share0_output_0_re;
  logic [31:0] sw_share0_output_0_qs;
  logic [31:0] sw_share0_output_0_wd;
  logic sw_share0_output_1_re;
  logic [31:0] sw_share0_output_1_qs;
  logic [31:0] sw_share0_output_1_wd;
  logic sw_share0_output_2_re;
  logic [31:0] sw_share0_output_2_qs;
  logic [31:0] sw_share0_output_2_wd;
  logic sw_share0_output_3_re;
  logic [31:0] sw_share0_output_3_qs;
  logic [31:0] sw_share0_output_3_wd;
  logic sw_share0_output_4_re;
  logic [31:0] sw_share0_output_4_qs;
  logic [31:0] sw_share0_output_4_wd;
  logic sw_share0_output_5_re;
  logic [31:0] sw_share0_output_5_qs;
  logic [31:0] sw_share0_output_5_wd;
  logic sw_share0_output_6_re;
  logic [31:0] sw_share0_output_6_qs;
  logic [31:0] sw_share0_output_6_wd;
  logic sw_share0_output_7_re;
  logic [31:0] sw_share0_output_7_qs;
  logic [31:0] sw_share0_output_7_wd;
  logic sw_share1_output_0_re;
  logic [31:0] sw_share1_output_0_qs;
  logic [31:0] sw_share1_output_0_wd;
  logic sw_share1_output_1_re;
  logic [31:0] sw_share1_output_1_qs;
  logic [31:0] sw_share1_output_1_wd;
  logic sw_share1_output_2_re;
  logic [31:0] sw_share1_output_2_qs;
  logic [31:0] sw_share1_output_2_wd;
  logic sw_share1_output_3_re;
  logic [31:0] sw_share1_output_3_qs;
  logic [31:0] sw_share1_output_3_wd;
  logic sw_share1_output_4_re;
  logic [31:0] sw_share1_output_4_qs;
  logic [31:0] sw_share1_output_4_wd;
  logic sw_share1_output_5_re;
  logic [31:0] sw_share1_output_5_qs;
  logic [31:0] sw_share1_output_5_wd;
  logic sw_share1_output_6_re;
  logic [31:0] sw_share1_output_6_qs;
  logic [31:0] sw_share1_output_6_wd;
  logic sw_share1_output_7_re;
  logic [31:0] sw_share1_output_7_qs;
  logic [31:0] sw_share1_output_7_wd;
  logic [2:0] working_state_qs;
  logic op_status_we;
  logic [1:0] op_status_qs;
  logic [1:0] op_status_wd;
  logic err_code_we;
  logic err_code_invalid_op_qs;
  logic err_code_invalid_op_wd;
  logic err_code_invalid_kmac_input_qs;
  logic err_code_invalid_kmac_input_wd;
  logic err_code_invalid_shadow_update_qs;
  logic err_code_invalid_shadow_update_wd;
  logic fault_status_cmd_qs;
  logic fault_status_kmac_fsm_qs;
  logic fault_status_kmac_done_qs;
  logic fault_status_kmac_op_qs;
  logic fault_status_kmac_out_qs;
  logic fault_status_regfile_intg_qs;
  logic fault_status_shadow_qs;
  logic fault_status_ctrl_fsm_intg_qs;
  logic fault_status_ctrl_fsm_chk_qs;
  logic fault_status_ctrl_fsm_cnt_qs;
  logic fault_status_reseed_cnt_qs;
  logic fault_status_side_ctrl_fsm_qs;
  logic fault_status_side_ctrl_sel_qs;
  logic fault_status_key_ecc_qs;
  logic debug_we;
  logic debug_invalid_creator_seed_qs;
  logic debug_invalid_creator_seed_wd;
  logic debug_invalid_owner_seed_qs;
  logic debug_invalid_owner_seed_wd;
  logic debug_invalid_dev_id_qs;
  logic debug_invalid_dev_id_wd;
  logic debug_invalid_health_state_qs;
  logic debug_invalid_health_state_wd;
  logic debug_invalid_key_version_qs;
  logic debug_invalid_key_version_wd;
  logic debug_invalid_key_qs;
  logic debug_invalid_key_wd;
  logic debug_invalid_digest_qs;
  logic debug_invalid_digest_wd;

  // Register instances
  // R[intr_state]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.de),
    .d      (hw2reg.intr_state.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_qs)
  );


  // R[intr_enable]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_qs)
  );


  // R[intr_test]: V(True)
  logic intr_test_qe;
  logic [0:0] intr_test_flds_we;
  assign intr_test_qe = &intr_test_flds_we;
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[0]),
    .q      (reg2hw.intr_test.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.qe = intr_test_qe;


  // R[alert_test]: V(True)
  logic alert_test_qe;
  logic [1:0] alert_test_flds_we;
  assign alert_test_qe = &alert_test_flds_we;
  //   F[recov_operation_err]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_recov_operation_err (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_recov_operation_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[0]),
    .q      (reg2hw.alert_test.recov_operation_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.recov_operation_err.qe = alert_test_qe;

  //   F[fatal_fault_err]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_fatal_fault_err (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_fatal_fault_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[1]),
    .q      (reg2hw.alert_test.fatal_fault_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.fatal_fault_err.qe = alert_test_qe;


  // R[cfg_regwen]: V(True)
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_regwen (
    .re     (cfg_regwen_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.cfg_regwen.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (cfg_regwen_qs)
  );


  // R[start]: V(False)
  // Create REGWEN-gated WE signal
  logic start_gated_we;
  assign start_gated_we = start_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_start (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (start_gated_we),
    .wd     (start_wd),

    // from internal hardware
    .de     (hw2reg.start.de),
    .d      (hw2reg.start.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.start.q),
    .ds     (),

    // to register interface (read)
    .qs     (start_qs)
  );


  // R[control_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic control_shadowed_gated_we;
  assign control_shadowed_gated_we = control_shadowed_we & cfg_regwen_qs;
  //   F[operation]: 6:4
  prim_subreg_shadow #(
    .DW      (3),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (3'h1),
    .Mubi    (1'b0)
  ) u_control_shadowed_operation (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (control_shadowed_re),
    .we     (control_shadowed_gated_we),
    .wd     (control_shadowed_operation_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.control_shadowed.operation.q),
    .ds     (),

    // to register interface (read)
    .qs     (control_shadowed_operation_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (control_shadowed_operation_update_err),
    .err_storage (control_shadowed_operation_storage_err)
  );

  //   F[cdi_sel]: 7:7
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_control_shadowed_cdi_sel (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (control_shadowed_re),
    .we     (control_shadowed_gated_we),
    .wd     (control_shadowed_cdi_sel_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.control_shadowed.cdi_sel.q),
    .ds     (),

    // to register interface (read)
    .qs     (control_shadowed_cdi_sel_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (control_shadowed_cdi_sel_update_err),
    .err_storage (control_shadowed_cdi_sel_storage_err)
  );

  //   F[dest_sel]: 13:12
  prim_subreg_shadow #(
    .DW      (2),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (2'h0),
    .Mubi    (1'b0)
  ) u_control_shadowed_dest_sel (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (control_shadowed_re),
    .we     (control_shadowed_gated_we),
    .wd     (control_shadowed_dest_sel_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.control_shadowed.dest_sel.q),
    .ds     (),

    // to register interface (read)
    .qs     (control_shadowed_dest_sel_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (control_shadowed_dest_sel_update_err),
    .err_storage (control_shadowed_dest_sel_storage_err)
  );


  // R[sideload_clear]: V(False)
  // Create REGWEN-gated WE signal
  logic sideload_clear_gated_we;
  assign sideload_clear_gated_we = sideload_clear_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (3),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (3'h0),
    .Mubi    (1'b0)
  ) u_sideload_clear (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sideload_clear_gated_we),
    .wd     (sideload_clear_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sideload_clear.q),
    .ds     (),

    // to register interface (read)
    .qs     (sideload_clear_qs)
  );


  // R[reseed_interval_regwen]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_reseed_interval_regwen (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (reseed_interval_regwen_we),
    .wd     (reseed_interval_regwen_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (reseed_interval_regwen_qs)
  );


  // R[reseed_interval_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic reseed_interval_shadowed_gated_we;
  assign reseed_interval_shadowed_gated_we =
    reseed_interval_shadowed_we & reseed_interval_regwen_qs;
  prim_subreg_shadow #(
    .DW      (16),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (16'h100),
    .Mubi    (1'b0)
  ) u_reseed_interval_shadowed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (reseed_interval_shadowed_re),
    .we     (reseed_interval_shadowed_gated_we),
    .wd     (reseed_interval_shadowed_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.reseed_interval_shadowed.q),
    .ds     (),

    // to register interface (read)
    .qs     (reseed_interval_shadowed_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (reseed_interval_shadowed_update_err),
    .err_storage (reseed_interval_shadowed_storage_err)
  );


  // R[sw_binding_regwen]: V(True)
  logic sw_binding_regwen_qe;
  logic [0:0] sw_binding_regwen_flds_we;
  assign sw_binding_regwen_qe = &sw_binding_regwen_flds_we;
  prim_subreg_ext #(
    .DW    (1)
  ) u_sw_binding_regwen (
    .re     (sw_binding_regwen_re),
    .we     (sw_binding_regwen_we),
    .wd     (sw_binding_regwen_wd),
    .d      (hw2reg.sw_binding_regwen.d),
    .qre    (),
    .qe     (sw_binding_regwen_flds_we[0]),
    .q      (reg2hw.sw_binding_regwen.q),
    .ds     (),
    .qs     (sw_binding_regwen_qs)
  );
  assign reg2hw.sw_binding_regwen.qe = sw_binding_regwen_qe;


  // Subregister 0 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_0]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_0_gated_we;
  assign sealing_sw_binding_0_gated_we = sealing_sw_binding_0_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_0_gated_we),
    .wd     (sealing_sw_binding_0_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[0].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_0_qs)
  );


  // Subregister 1 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_1]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_1_gated_we;
  assign sealing_sw_binding_1_gated_we = sealing_sw_binding_1_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_1_gated_we),
    .wd     (sealing_sw_binding_1_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[1].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_1_qs)
  );


  // Subregister 2 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_2]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_2_gated_we;
  assign sealing_sw_binding_2_gated_we = sealing_sw_binding_2_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_2_gated_we),
    .wd     (sealing_sw_binding_2_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[2].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_2_qs)
  );


  // Subregister 3 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_3]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_3_gated_we;
  assign sealing_sw_binding_3_gated_we = sealing_sw_binding_3_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_3_gated_we),
    .wd     (sealing_sw_binding_3_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[3].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_3_qs)
  );


  // Subregister 4 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_4]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_4_gated_we;
  assign sealing_sw_binding_4_gated_we = sealing_sw_binding_4_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_4_gated_we),
    .wd     (sealing_sw_binding_4_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[4].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_4_qs)
  );


  // Subregister 5 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_5]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_5_gated_we;
  assign sealing_sw_binding_5_gated_we = sealing_sw_binding_5_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_5_gated_we),
    .wd     (sealing_sw_binding_5_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[5].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_5_qs)
  );


  // Subregister 6 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_6]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_6_gated_we;
  assign sealing_sw_binding_6_gated_we = sealing_sw_binding_6_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_6_gated_we),
    .wd     (sealing_sw_binding_6_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[6].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_6_qs)
  );


  // Subregister 7 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_7]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_7_gated_we;
  assign sealing_sw_binding_7_gated_we = sealing_sw_binding_7_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_7_gated_we),
    .wd     (sealing_sw_binding_7_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[7].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_7_qs)
  );


  // Subregister 0 of Multireg attest_sw_binding
  // R[attest_sw_binding_0]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_0_gated_we;
  assign attest_sw_binding_0_gated_we = attest_sw_binding_0_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_0_gated_we),
    .wd     (attest_sw_binding_0_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[0].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_0_qs)
  );


  // Subregister 1 of Multireg attest_sw_binding
  // R[attest_sw_binding_1]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_1_gated_we;
  assign attest_sw_binding_1_gated_we = attest_sw_binding_1_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_1_gated_we),
    .wd     (attest_sw_binding_1_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[1].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_1_qs)
  );


  // Subregister 2 of Multireg attest_sw_binding
  // R[attest_sw_binding_2]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_2_gated_we;
  assign attest_sw_binding_2_gated_we = attest_sw_binding_2_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_2_gated_we),
    .wd     (attest_sw_binding_2_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[2].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_2_qs)
  );


  // Subregister 3 of Multireg attest_sw_binding
  // R[attest_sw_binding_3]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_3_gated_we;
  assign attest_sw_binding_3_gated_we = attest_sw_binding_3_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_3_gated_we),
    .wd     (attest_sw_binding_3_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[3].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_3_qs)
  );


  // Subregister 4 of Multireg attest_sw_binding
  // R[attest_sw_binding_4]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_4_gated_we;
  assign attest_sw_binding_4_gated_we = attest_sw_binding_4_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_4_gated_we),
    .wd     (attest_sw_binding_4_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[4].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_4_qs)
  );


  // Subregister 5 of Multireg attest_sw_binding
  // R[attest_sw_binding_5]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_5_gated_we;
  assign attest_sw_binding_5_gated_we = attest_sw_binding_5_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_5_gated_we),
    .wd     (attest_sw_binding_5_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[5].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_5_qs)
  );


  // Subregister 6 of Multireg attest_sw_binding
  // R[attest_sw_binding_6]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_6_gated_we;
  assign attest_sw_binding_6_gated_we = attest_sw_binding_6_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_6_gated_we),
    .wd     (attest_sw_binding_6_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[6].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_6_qs)
  );


  // Subregister 7 of Multireg attest_sw_binding
  // R[attest_sw_binding_7]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_7_gated_we;
  assign attest_sw_binding_7_gated_we = attest_sw_binding_7_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_7_gated_we),
    .wd     (attest_sw_binding_7_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[7].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_7_qs)
  );


  // Subregister 0 of Multireg salt
  // R[salt_0]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_0_gated_we;
  assign salt_0_gated_we = salt_0_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_0_gated_we),
    .wd     (salt_0_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[0].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_0_qs)
  );


  // Subregister 1 of Multireg salt
  // R[salt_1]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_1_gated_we;
  assign salt_1_gated_we = salt_1_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_1_gated_we),
    .wd     (salt_1_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[1].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_1_qs)
  );


  // Subregister 2 of Multireg salt
  // R[salt_2]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_2_gated_we;
  assign salt_2_gated_we = salt_2_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_2_gated_we),
    .wd     (salt_2_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[2].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_2_qs)
  );


  // Subregister 3 of Multireg salt
  // R[salt_3]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_3_gated_we;
  assign salt_3_gated_we = salt_3_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_3_gated_we),
    .wd     (salt_3_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[3].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_3_qs)
  );


  // Subregister 4 of Multireg salt
  // R[salt_4]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_4_gated_we;
  assign salt_4_gated_we = salt_4_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_4_gated_we),
    .wd     (salt_4_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[4].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_4_qs)
  );


  // Subregister 5 of Multireg salt
  // R[salt_5]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_5_gated_we;
  assign salt_5_gated_we = salt_5_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_5_gated_we),
    .wd     (salt_5_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[5].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_5_qs)
  );


  // Subregister 6 of Multireg salt
  // R[salt_6]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_6_gated_we;
  assign salt_6_gated_we = salt_6_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_6_gated_we),
    .wd     (salt_6_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[6].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_6_qs)
  );


  // Subregister 7 of Multireg salt
  // R[salt_7]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_7_gated_we;
  assign salt_7_gated_we = salt_7_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_7_gated_we),
    .wd     (salt_7_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[7].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_7_qs)
  );


  // Subregister 0 of Multireg key_version
  // R[key_version]: V(False)
  // Create REGWEN-gated WE signal
  logic key_version_gated_we;
  assign key_version_gated_we = key_version_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_key_version (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (key_version_gated_we),
    .wd     (key_version_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.key_version[0].q),
    .ds     (),

    // to register interface (read)
    .qs     (key_version_qs)
  );


  // R[max_creator_key_ver_regwen]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_max_creator_key_ver_regwen (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (max_creator_key_ver_regwen_we),
    .wd     (max_creator_key_ver_regwen_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (max_creator_key_ver_regwen_qs)
  );


  // R[max_creator_key_ver_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic max_creator_key_ver_shadowed_gated_we;
  assign max_creator_key_ver_shadowed_gated_we =
    max_creator_key_ver_shadowed_we & max_creator_key_ver_regwen_qs;
  prim_subreg_shadow #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_max_creator_key_ver_shadowed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (max_creator_key_ver_shadowed_re),
    .we     (max_creator_key_ver_shadowed_gated_we),
    .wd     (max_creator_key_ver_shadowed_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.max_creator_key_ver_shadowed.q),
    .ds     (),

    // to register interface (read)
    .qs     (max_creator_key_ver_shadowed_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (max_creator_key_ver_shadowed_update_err),
    .err_storage (max_creator_key_ver_shadowed_storage_err)
  );


  // R[max_owner_int_key_ver_regwen]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_max_owner_int_key_ver_regwen (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (max_owner_int_key_ver_regwen_we),
    .wd     (max_owner_int_key_ver_regwen_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (max_owner_int_key_ver_regwen_qs)
  );


  // R[max_owner_int_key_ver_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic max_owner_int_key_ver_shadowed_gated_we;
  assign max_owner_int_key_ver_shadowed_gated_we =
    max_owner_int_key_ver_shadowed_we & max_owner_int_key_ver_regwen_qs;
  prim_subreg_shadow #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h1),
    .Mubi    (1'b0)
  ) u_max_owner_int_key_ver_shadowed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (max_owner_int_key_ver_shadowed_re),
    .we     (max_owner_int_key_ver_shadowed_gated_we),
    .wd     (max_owner_int_key_ver_shadowed_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.max_owner_int_key_ver_shadowed.q),
    .ds     (),

    // to register interface (read)
    .qs     (max_owner_int_key_ver_shadowed_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (max_owner_int_key_ver_shadowed_update_err),
    .err_storage (max_owner_int_key_ver_shadowed_storage_err)
  );


  // R[max_owner_key_ver_regwen]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_max_owner_key_ver_regwen (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (max_owner_key_ver_regwen_we),
    .wd     (max_owner_key_ver_regwen_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (max_owner_key_ver_regwen_qs)
  );


  // R[max_owner_key_ver_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic max_owner_key_ver_shadowed_gated_we;
  assign max_owner_key_ver_shadowed_gated_we =
    max_owner_key_ver_shadowed_we & max_owner_key_ver_regwen_qs;
  prim_subreg_shadow #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_max_owner_key_ver_shadowed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (max_owner_key_ver_shadowed_re),
    .we     (max_owner_key_ver_shadowed_gated_we),
    .wd     (max_owner_key_ver_shadowed_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.max_owner_key_ver_shadowed.q),
    .ds     (),

    // to register interface (read)
    .qs     (max_owner_key_ver_shadowed_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (max_owner_key_ver_shadowed_update_err),
    .err_storage (max_owner_key_ver_shadowed_storage_err)
  );


  // Subregister 0 of Multireg sw_share0_output
  // R[sw_share0_output_0]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_0_re),
    .wd     (sw_share0_output_0_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[0].de),
    .d      (hw2reg.sw_share0_output[0].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_0_qs)
  );


  // Subregister 1 of Multireg sw_share0_output
  // R[sw_share0_output_1]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_1_re),
    .wd     (sw_share0_output_1_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[1].de),
    .d      (hw2reg.sw_share0_output[1].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_1_qs)
  );


  // Subregister 2 of Multireg sw_share0_output
  // R[sw_share0_output_2]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_2_re),
    .wd     (sw_share0_output_2_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[2].de),
    .d      (hw2reg.sw_share0_output[2].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_2_qs)
  );


  // Subregister 3 of Multireg sw_share0_output
  // R[sw_share0_output_3]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_3_re),
    .wd     (sw_share0_output_3_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[3].de),
    .d      (hw2reg.sw_share0_output[3].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_3_qs)
  );


  // Subregister 4 of Multireg sw_share0_output
  // R[sw_share0_output_4]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_4_re),
    .wd     (sw_share0_output_4_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[4].de),
    .d      (hw2reg.sw_share0_output[4].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_4_qs)
  );


  // Subregister 5 of Multireg sw_share0_output
  // R[sw_share0_output_5]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_5_re),
    .wd     (sw_share0_output_5_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[5].de),
    .d      (hw2reg.sw_share0_output[5].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_5_qs)
  );


  // Subregister 6 of Multireg sw_share0_output
  // R[sw_share0_output_6]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_6_re),
    .wd     (sw_share0_output_6_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[6].de),
    .d      (hw2reg.sw_share0_output[6].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_6_qs)
  );


  // Subregister 7 of Multireg sw_share0_output
  // R[sw_share0_output_7]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_7_re),
    .wd     (sw_share0_output_7_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[7].de),
    .d      (hw2reg.sw_share0_output[7].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_7_qs)
  );


  // Subregister 0 of Multireg sw_share1_output
  // R[sw_share1_output_0]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_0_re),
    .wd     (sw_share1_output_0_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[0].de),
    .d      (hw2reg.sw_share1_output[0].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_0_qs)
  );


  // Subregister 1 of Multireg sw_share1_output
  // R[sw_share1_output_1]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_1_re),
    .wd     (sw_share1_output_1_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[1].de),
    .d      (hw2reg.sw_share1_output[1].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_1_qs)
  );


  // Subregister 2 of Multireg sw_share1_output
  // R[sw_share1_output_2]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_2_re),
    .wd     (sw_share1_output_2_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[2].de),
    .d      (hw2reg.sw_share1_output[2].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_2_qs)
  );


  // Subregister 3 of Multireg sw_share1_output
  // R[sw_share1_output_3]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_3_re),
    .wd     (sw_share1_output_3_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[3].de),
    .d      (hw2reg.sw_share1_output[3].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_3_qs)
  );


  // Subregister 4 of Multireg sw_share1_output
  // R[sw_share1_output_4]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_4_re),
    .wd     (sw_share1_output_4_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[4].de),
    .d      (hw2reg.sw_share1_output[4].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_4_qs)
  );


  // Subregister 5 of Multireg sw_share1_output
  // R[sw_share1_output_5]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_5_re),
    .wd     (sw_share1_output_5_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[5].de),
    .d      (hw2reg.sw_share1_output[5].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_5_qs)
  );


  // Subregister 6 of Multireg sw_share1_output
  // R[sw_share1_output_6]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_6_re),
    .wd     (sw_share1_output_6_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[6].de),
    .d      (hw2reg.sw_share1_output[6].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_6_qs)
  );


  // Subregister 7 of Multireg sw_share1_output
  // R[sw_share1_output_7]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_7_re),
    .wd     (sw_share1_output_7_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[7].de),
    .d      (hw2reg.sw_share1_output[7].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_7_qs)
  );


  // R[working_state]: V(False)
  prim_subreg #(
    .DW      (3),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (3'h0),
    .Mubi    (1'b0)
  ) u_working_state (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.working_state.de),
    .d      (hw2reg.working_state.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (working_state_qs)
  );


  // R[op_status]: V(False)
  prim_subreg #(
    .DW      (2),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (2'h0),
    .Mubi    (1'b0)
  ) u_op_status (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (op_status_we),
    .wd     (op_status_wd),

    // from internal hardware
    .de     (hw2reg.op_status.de),
    .d      (hw2reg.op_status.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (op_status_qs)
  );


  // R[err_code]: V(False)
  //   F[invalid_op]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_err_code_invalid_op (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (err_code_we),
    .wd     (err_code_invalid_op_wd),

    // from internal hardware
    .de     (hw2reg.err_code.invalid_op.de),
    .d      (hw2reg.err_code.invalid_op.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (err_code_invalid_op_qs)
  );

  //   F[invalid_kmac_input]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_err_code_invalid_kmac_input (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (err_code_we),
    .wd     (err_code_invalid_kmac_input_wd),

    // from internal hardware
    .de     (hw2reg.err_code.invalid_kmac_input.de),
    .d      (hw2reg.err_code.invalid_kmac_input.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (err_code_invalid_kmac_input_qs)
  );

  //   F[invalid_shadow_update]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_err_code_invalid_shadow_update (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (err_code_we),
    .wd     (err_code_invalid_shadow_update_wd),

    // from internal hardware
    .de     (hw2reg.err_code.invalid_shadow_update.de),
    .d      (hw2reg.err_code.invalid_shadow_update.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (err_code_invalid_shadow_update_qs)
  );


  // R[fault_status]: V(False)
  //   F[cmd]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_cmd (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.cmd.de),
    .d      (hw2reg.fault_status.cmd.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.cmd.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_cmd_qs)
  );

  //   F[kmac_fsm]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_kmac_fsm (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.kmac_fsm.de),
    .d      (hw2reg.fault_status.kmac_fsm.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.kmac_fsm.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_kmac_fsm_qs)
  );

  //   F[kmac_done]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_kmac_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.kmac_done.de),
    .d      (hw2reg.fault_status.kmac_done.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.kmac_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_kmac_done_qs)
  );

  //   F[kmac_op]: 3:3
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_kmac_op (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.kmac_op.de),
    .d      (hw2reg.fault_status.kmac_op.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.kmac_op.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_kmac_op_qs)
  );

  //   F[kmac_out]: 4:4
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_kmac_out (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.kmac_out.de),
    .d      (hw2reg.fault_status.kmac_out.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.kmac_out.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_kmac_out_qs)
  );

  //   F[regfile_intg]: 5:5
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_regfile_intg (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.regfile_intg.de),
    .d      (hw2reg.fault_status.regfile_intg.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.regfile_intg.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_regfile_intg_qs)
  );

  //   F[shadow]: 6:6
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_shadow (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.shadow.de),
    .d      (hw2reg.fault_status.shadow.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.shadow.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_shadow_qs)
  );

  //   F[ctrl_fsm_intg]: 7:7
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_ctrl_fsm_intg (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.ctrl_fsm_intg.de),
    .d      (hw2reg.fault_status.ctrl_fsm_intg.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.ctrl_fsm_intg.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_ctrl_fsm_intg_qs)
  );

  //   F[ctrl_fsm_chk]: 8:8
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_ctrl_fsm_chk (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.ctrl_fsm_chk.de),
    .d      (hw2reg.fault_status.ctrl_fsm_chk.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.ctrl_fsm_chk.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_ctrl_fsm_chk_qs)
  );

  //   F[ctrl_fsm_cnt]: 9:9
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_ctrl_fsm_cnt (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.ctrl_fsm_cnt.de),
    .d      (hw2reg.fault_status.ctrl_fsm_cnt.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.ctrl_fsm_cnt.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_ctrl_fsm_cnt_qs)
  );

  //   F[reseed_cnt]: 10:10
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_reseed_cnt (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.reseed_cnt.de),
    .d      (hw2reg.fault_status.reseed_cnt.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.reseed_cnt.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_reseed_cnt_qs)
  );

  //   F[side_ctrl_fsm]: 11:11
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_side_ctrl_fsm (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.side_ctrl_fsm.de),
    .d      (hw2reg.fault_status.side_ctrl_fsm.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.side_ctrl_fsm.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_side_ctrl_fsm_qs)
  );

  //   F[side_ctrl_sel]: 12:12
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_side_ctrl_sel (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.side_ctrl_sel.de),
    .d      (hw2reg.fault_status.side_ctrl_sel.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.side_ctrl_sel.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_side_ctrl_sel_qs)
  );

  //   F[key_ecc]: 13:13
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_key_ecc (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.key_ecc.de),
    .d      (hw2reg.fault_status.key_ecc.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.key_ecc.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_key_ecc_qs)
  );


  // R[debug]: V(False)
  //   F[invalid_creator_seed]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_creator_seed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_creator_seed_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_creator_seed.de),
    .d      (hw2reg.debug.invalid_creator_seed.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_creator_seed_qs)
  );

  //   F[invalid_owner_seed]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_owner_seed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_owner_seed_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_owner_seed.de),
    .d      (hw2reg.debug.invalid_owner_seed.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_owner_seed_qs)
  );

  //   F[invalid_dev_id]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_dev_id (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_dev_id_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_dev_id.de),
    .d      (hw2reg.debug.invalid_dev_id.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_dev_id_qs)
  );

  //   F[invalid_health_state]: 3:3
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_health_state (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_health_state_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_health_state.de),
    .d      (hw2reg.debug.invalid_health_state.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_health_state_qs)
  );

  //   F[invalid_key_version]: 4:4
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_key_version (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_key_version_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_key_version.de),
    .d      (hw2reg.debug.invalid_key_version.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_key_version_qs)
  );

  //   F[invalid_key]: 5:5
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_key (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_key_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_key.de),
    .d      (hw2reg.debug.invalid_key.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_key_qs)
  );

  //   F[invalid_digest]: 6:6
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_digest (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_digest_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_digest.de),
    .d      (hw2reg.debug.invalid_digest.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_digest_qs)
  );



  logic [62:0] addr_hit;
  always_comb begin
    addr_hit = '0;
    addr_hit[ 0] = (reg_addr == KEYMGR_INTR_STATE_OFFSET);
    addr_hit[ 1] = (reg_addr == KEYMGR_INTR_ENABLE_OFFSET);
    addr_hit[ 2] = (reg_addr == KEYMGR_INTR_TEST_OFFSET);
    addr_hit[ 3] = (reg_addr == KEYMGR_ALERT_TEST_OFFSET);
    addr_hit[ 4] = (reg_addr == KEYMGR_CFG_REGWEN_OFFSET);
    addr_hit[ 5] = (reg_addr == KEYMGR_START_OFFSET);
    addr_hit[ 6] = (reg_addr == KEYMGR_CONTROL_SHADOWED_OFFSET);
    addr_hit[ 7] = (reg_addr == KEYMGR_SIDELOAD_CLEAR_OFFSET);
    addr_hit[ 8] = (reg_addr == KEYMGR_RESEED_INTERVAL_REGWEN_OFFSET);
    addr_hit[ 9] = (reg_addr == KEYMGR_RESEED_INTERVAL_SHADOWED_OFFSET);
    addr_hit[10] = (reg_addr == KEYMGR_SW_BINDING_REGWEN_OFFSET);
    addr_hit[11] = (reg_addr == KEYMGR_SEALING_SW_BINDING_0_OFFSET);
    addr_hit[12] = (reg_addr == KEYMGR_SEALING_SW_BINDING_1_OFFSET);
    addr_hit[13] = (reg_addr == KEYMGR_SEALING_SW_BINDING_2_OFFSET);
    addr_hit[14] = (reg_addr == KEYMGR_SEALING_SW_BINDING_3_OFFSET);
    addr_hit[15] = (reg_addr == KEYMGR_SEALING_SW_BINDING_4_OFFSET);
    addr_hit[16] = (reg_addr == KEYMGR_SEALING_SW_BINDING_5_OFFSET);
    addr_hit[17] = (reg_addr == KEYMGR_SEALING_SW_BINDING_6_OFFSET);
    addr_hit[18] = (reg_addr == KEYMGR_SEALING_SW_BINDING_7_OFFSET);
    addr_hit[19] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_0_OFFSET);
    addr_hit[20] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_1_OFFSET);
    addr_hit[21] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_2_OFFSET);
    addr_hit[22] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_3_OFFSET);
    addr_hit[23] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_4_OFFSET);
    addr_hit[24] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_5_OFFSET);
    addr_hit[25] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_6_OFFSET);
    addr_hit[26] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_7_OFFSET);
    addr_hit[27] = (reg_addr == KEYMGR_SALT_0_OFFSET);
    addr_hit[28] = (reg_addr == KEYMGR_SALT_1_OFFSET);
    addr_hit[29] = (reg_addr == KEYMGR_SALT_2_OFFSET);
    addr_hit[30] = (reg_addr == KEYMGR_SALT_3_OFFSET);
    addr_hit[31] = (reg_addr == KEYMGR_SALT_4_OFFSET);
    addr_hit[32] = (reg_addr == KEYMGR_SALT_5_OFFSET);
    addr_hit[33] = (reg_addr == KEYMGR_SALT_6_OFFSET);
    addr_hit[34] = (reg_addr == KEYMGR_SALT_7_OFFSET);
    addr_hit[35] = (reg_addr == KEYMGR_KEY_VERSION_OFFSET);
    addr_hit[36] = (reg_addr == KEYMGR_MAX_CREATOR_KEY_VER_REGWEN_OFFSET);
    addr_hit[37] = (reg_addr == KEYMGR_MAX_CREATOR_KEY_VER_SHADOWED_OFFSET);
    addr_hit[38] = (reg_addr == KEYMGR_MAX_OWNER_INT_KEY_VER_REGWEN_OFFSET);
    addr_hit[39] = (reg_addr == KEYMGR_MAX_OWNER_INT_KEY_VER_SHADOWED_OFFSET);
    addr_hit[40] = (reg_addr == KEYMGR_MAX_OWNER_KEY_VER_REGWEN_OFFSET);
    addr_hit[41] = (reg_addr == KEYMGR_MAX_OWNER_KEY_VER_SHADOWED_OFFSET);
    addr_hit[42] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_0_OFFSET);
    addr_hit[43] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_1_OFFSET);
    addr_hit[44] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_2_OFFSET);
    addr_hit[45] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_3_OFFSET);
    addr_hit[46] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_4_OFFSET);
    addr_hit[47] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_5_OFFSET);
    addr_hit[48] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_6_OFFSET);
    addr_hit[49] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_7_OFFSET);
    addr_hit[50] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_0_OFFSET);
    addr_hit[51] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_1_OFFSET);
    addr_hit[52] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_2_OFFSET);
    addr_hit[53] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_3_OFFSET);
    addr_hit[54] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_4_OFFSET);
    addr_hit[55] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_5_OFFSET);
    addr_hit[56] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_6_OFFSET);
    addr_hit[57] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_7_OFFSET);
    addr_hit[58] = (reg_addr == KEYMGR_WORKING_STATE_OFFSET);
    addr_hit[59] = (reg_addr == KEYMGR_OP_STATUS_OFFSET);
    addr_hit[60] = (reg_addr == KEYMGR_ERR_CODE_OFFSET);
    addr_hit[61] = (reg_addr == KEYMGR_FAULT_STATUS_OFFSET);
    addr_hit[62] = (reg_addr == KEYMGR_DEBUG_OFFSET);
  end

  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;

  // Check sub-word write is permitted
  always_comb begin
    wr_err = (reg_we &
              ((addr_hit[ 0] & (|(KEYMGR_PERMIT[ 0] & ~reg_be))) |
               (addr_hit[ 1] & (|(KEYMGR_PERMIT[ 1] & ~reg_be))) |
               (addr_hit[ 2] & (|(KEYMGR_PERMIT[ 2] & ~reg_be))) |
               (addr_hit[ 3] & (|(KEYMGR_PERMIT[ 3] & ~reg_be))) |
               (addr_hit[ 4] & (|(KEYMGR_PERMIT[ 4] & ~reg_be))) |
               (addr_hit[ 5] & (|(KEYMGR_PERMIT[ 5] & ~reg_be))) |
               (addr_hit[ 6] & (|(KEYMGR_PERMIT[ 6] & ~reg_be))) |
               (addr_hit[ 7] & (|(KEYMGR_PERMIT[ 7] & ~reg_be))) |
               (addr_hit[ 8] & (|(KEYMGR_PERMIT[ 8] & ~reg_be))) |
               (addr_hit[ 9] & (|(KEYMGR_PERMIT[ 9] & ~reg_be))) |
               (addr_hit[10] & (|(KEYMGR_PERMIT[10] & ~reg_be))) |
               (addr_hit[11] & (|(KEYMGR_PERMIT[11] & ~reg_be))) |
               (addr_hit[12] & (|(KEYMGR_PERMIT[12] & ~reg_be))) |
               (addr_hit[13] & (|(KEYMGR_PERMIT[13] & ~reg_be))) |
               (addr_hit[14] & (|(KEYMGR_PERMIT[14] & ~reg_be))) |
               (addr_hit[15] & (|(KEYMGR_PERMIT[15] & ~reg_be))) |
               (addr_hit[16] & (|(KEYMGR_PERMIT[16] & ~reg_be))) |
               (addr_hit[17] & (|(KEYMGR_PERMIT[17] & ~reg_be))) |
               (addr_hit[18] & (|(KEYMGR_PERMIT[18] & ~reg_be))) |
               (addr_hit[19] & (|(KEYMGR_PERMIT[19] & ~reg_be))) |
               (addr_hit[20] & (|(KEYMGR_PERMIT[20] & ~reg_be))) |
               (addr_hit[21] & (|(KEYMGR_PERMIT[21] & ~reg_be))) |
               (addr_hit[22] & (|(KEYMGR_PERMIT[22] & ~reg_be))) |
               (addr_hit[23] & (|(KEYMGR_PERMIT[23] & ~reg_be))) |
               (addr_hit[24] & (|(KEYMGR_PERMIT[24] & ~reg_be))) |
               (addr_hit[25] & (|(KEYMGR_PERMIT[25] & ~reg_be))) |
               (addr_hit[26] & (|(KEYMGR_PERMIT[26] & ~reg_be))) |
               (addr_hit[27] & (|(KEYMGR_PERMIT[27] & ~reg_be))) |
               (addr_hit[28] & (|(KEYMGR_PERMIT[28] & ~reg_be))) |
               (addr_hit[29] & (|(KEYMGR_PERMIT[29] & ~reg_be))) |
               (addr_hit[30] & (|(KEYMGR_PERMIT[30] & ~reg_be))) |
               (addr_hit[31] & (|(KEYMGR_PERMIT[31] & ~reg_be))) |
               (addr_hit[32] & (|(KEYMGR_PERMIT[32] & ~reg_be))) |
               (addr_hit[33] & (|(KEYMGR_PERMIT[33] & ~reg_be))) |
               (addr_hit[34] & (|(KEYMGR_PERMIT[34] & ~reg_be))) |
               (addr_hit[35] & (|(KEYMGR_PERMIT[35] & ~reg_be))) |
               (addr_hit[36] & (|(KEYMGR_PERMIT[36] & ~reg_be))) |
               (addr_hit[37] & (|(KEYMGR_PERMIT[37] & ~reg_be))) |
               (addr_hit[38] & (|(KEYMGR_PERMIT[38] & ~reg_be))) |
               (addr_hit[39] & (|(KEYMGR_PERMIT[39] & ~reg_be))) |
               (addr_hit[40] & (|(KEYMGR_PERMIT[40] & ~reg_be))) |
               (addr_hit[41] & (|(KEYMGR_PERMIT[41] & ~reg_be))) |
               (addr_hit[42] & (|(KEYMGR_PERMIT[42] & ~reg_be))) |
               (addr_hit[43] & (|(KEYMGR_PERMIT[43] & ~reg_be))) |
               (addr_hit[44] & (|(KEYMGR_PERMIT[44] & ~reg_be))) |
               (addr_hit[45] & (|(KEYMGR_PERMIT[45] & ~reg_be))) |
               (addr_hit[46] & (|(KEYMGR_PERMIT[46] & ~reg_be))) |
               (addr_hit[47] & (|(KEYMGR_PERMIT[47] & ~reg_be))) |
               (addr_hit[48] & (|(KEYMGR_PERMIT[48] & ~reg_be))) |
               (addr_hit[49] & (|(KEYMGR_PERMIT[49] & ~reg_be))) |
               (addr_hit[50] & (|(KEYMGR_PERMIT[50] & ~reg_be))) |
               (addr_hit[51] & (|(KEYMGR_PERMIT[51] & ~reg_be))) |
               (addr_hit[52] & (|(KEYMGR_PERMIT[52] & ~reg_be))) |
               (addr_hit[53] & (|(KEYMGR_PERMIT[53] & ~reg_be))) |
               (addr_hit[54] & (|(KEYMGR_PERMIT[54] & ~reg_be))) |
               (addr_hit[55] & (|(KEYMGR_PERMIT[55] & ~reg_be))) |
               (addr_hit[56] & (|(KEYMGR_PERMIT[56] & ~reg_be))) |
               (addr_hit[57] & (|(KEYMGR_PERMIT[57] & ~reg_be))) |
               (addr_hit[58] & (|(KEYMGR_PERMIT[58] & ~reg_be))) |
               (addr_hit[59] & (|(KEYMGR_PERMIT[59] & ~reg_be))) |
               (addr_hit[60] & (|(KEYMGR_PERMIT[60] & ~reg_be))) |
               (addr_hit[61] & (|(KEYMGR_PERMIT[61] & ~reg_be))) |
               (addr_hit[62] & (|(KEYMGR_PERMIT[62] & ~reg_be)))));
  end

  // Generate write-enables
  assign intr_state_we = addr_hit[0] & reg_we & !reg_error;

  assign intr_state_wd = reg_wdata[0];
  assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;

  assign intr_enable_wd = reg_wdata[0];
  assign intr_test_we = addr_hit[2] & reg_we & !reg_error;

  assign intr_test_wd = reg_wdata[0];
  assign alert_test_we = addr_hit[3] & reg_we & !reg_error;

  assign alert_test_recov_operation_err_wd = reg_wdata[0];

  assign alert_test_fatal_fault_err_wd = reg_wdata[1];
  assign cfg_regwen_re = addr_hit[4] & reg_re & !reg_error;
  assign start_we = addr_hit[5] & reg_we & !reg_error;

  assign start_wd = reg_wdata[0];
  assign control_shadowed_re = addr_hit[6] & reg_re & !reg_error;
  assign control_shadowed_we = addr_hit[6] & reg_we & !reg_error;

  assign control_shadowed_operation_wd = reg_wdata[6:4];

  assign control_shadowed_cdi_sel_wd = reg_wdata[7];

  assign control_shadowed_dest_sel_wd = reg_wdata[13:12];
  assign sideload_clear_we = addr_hit[7] & reg_we & !reg_error;

  assign sideload_clear_wd = reg_wdata[2:0];
  assign reseed_interval_regwen_we = addr_hit[8] & reg_we & !reg_error;

  assign reseed_interval_regwen_wd = reg_wdata[0];
  assign reseed_interval_shadowed_re = addr_hit[9] & reg_re & !reg_error;
  assign reseed_interval_shadowed_we = addr_hit[9] & reg_we & !reg_error;

  assign reseed_interval_shadowed_wd = reg_wdata[15:0];
  assign sw_binding_regwen_re = addr_hit[10] & reg_re & !reg_error;
  assign sw_binding_regwen_we = addr_hit[10] & reg_we & !reg_error;

  assign sw_binding_regwen_wd = reg_wdata[0];
  assign sealing_sw_binding_0_we = addr_hit[11] & reg_we & !reg_error;

  assign sealing_sw_binding_0_wd = reg_wdata[31:0];
  assign sealing_sw_binding_1_we = addr_hit[12] & reg_we & !reg_error;

  assign sealing_sw_binding_1_wd = reg_wdata[31:0];
  assign sealing_sw_binding_2_we = addr_hit[13] & reg_we & !reg_error;

  assign sealing_sw_binding_2_wd = reg_wdata[31:0];
  assign sealing_sw_binding_3_we = addr_hit[14] & reg_we & !reg_error;

  assign sealing_sw_binding_3_wd = reg_wdata[31:0];
  assign sealing_sw_binding_4_we = addr_hit[15] & reg_we & !reg_error;

  assign sealing_sw_binding_4_wd = reg_wdata[31:0];
  assign sealing_sw_binding_5_we = addr_hit[16] & reg_we & !reg_error;

  assign sealing_sw_binding_5_wd = reg_wdata[31:0];
  assign sealing_sw_binding_6_we = addr_hit[17] & reg_we & !reg_error;

  assign sealing_sw_binding_6_wd = reg_wdata[31:0];
  assign sealing_sw_binding_7_we = addr_hit[18] & reg_we & !reg_error;

  assign sealing_sw_binding_7_wd = reg_wdata[31:0];
  assign attest_sw_binding_0_we = addr_hit[19] & reg_we & !reg_error;

  assign attest_sw_binding_0_wd = reg_wdata[31:0];
  assign attest_sw_binding_1_we = addr_hit[20] & reg_we & !reg_error;

  assign attest_sw_binding_1_wd = reg_wdata[31:0];
  assign attest_sw_binding_2_we = addr_hit[21] & reg_we & !reg_error;

  assign attest_sw_binding_2_wd = reg_wdata[31:0];
  assign attest_sw_binding_3_we = addr_hit[22] & reg_we & !reg_error;

  assign attest_sw_binding_3_wd = reg_wdata[31:0];
  assign attest_sw_binding_4_we = addr_hit[23] & reg_we & !reg_error;

  assign attest_sw_binding_4_wd = reg_wdata[31:0];
  assign attest_sw_binding_5_we = addr_hit[24] & reg_we & !reg_error;

  assign attest_sw_binding_5_wd = reg_wdata[31:0];
  assign attest_sw_binding_6_we = addr_hit[25] & reg_we & !reg_error;

  assign attest_sw_binding_6_wd = reg_wdata[31:0];
  assign attest_sw_binding_7_we = addr_hit[26] & reg_we & !reg_error;

  assign attest_sw_binding_7_wd = reg_wdata[31:0];
  assign salt_0_we = addr_hit[27] & reg_we & !reg_error;

  assign salt_0_wd = reg_wdata[31:0];
  assign salt_1_we = addr_hit[28] & reg_we & !reg_error;

  assign salt_1_wd = reg_wdata[31:0];
  assign salt_2_we = addr_hit[29] & reg_we & !reg_error;

  assign salt_2_wd = reg_wdata[31:0];
  assign salt_3_we = addr_hit[30] & reg_we & !reg_error;

  assign salt_3_wd = reg_wdata[31:0];
  assign salt_4_we = addr_hit[31] & reg_we & !reg_error;

  assign salt_4_wd = reg_wdata[31:0];
  assign salt_5_we = addr_hit[32] & reg_we & !reg_error;

  assign salt_5_wd = reg_wdata[31:0];
  assign salt_6_we = addr_hit[33] & reg_we & !reg_error;

  assign salt_6_wd = reg_wdata[31:0];
  assign salt_7_we = addr_hit[34] & reg_we & !reg_error;

  assign salt_7_wd = reg_wdata[31:0];
  assign key_version_we = addr_hit[35] & reg_we & !reg_error;

  assign key_version_wd = reg_wdata[31:0];
  assign max_creator_key_ver_regwen_we = addr_hit[36] & reg_we & !reg_error;

  assign max_creator_key_ver_regwen_wd = reg_wdata[0];
  assign max_creator_key_ver_shadowed_re = addr_hit[37] & reg_re & !reg_error;
  assign max_creator_key_ver_shadowed_we = addr_hit[37] & reg_we & !reg_error;

  assign max_creator_key_ver_shadowed_wd = reg_wdata[31:0];
  assign max_owner_int_key_ver_regwen_we = addr_hit[38] & reg_we & !reg_error;

  assign max_owner_int_key_ver_regwen_wd = reg_wdata[0];
  assign max_owner_int_key_ver_shadowed_re = addr_hit[39] & reg_re & !reg_error;
  assign max_owner_int_key_ver_shadowed_we = addr_hit[39] & reg_we & !reg_error;

  assign max_owner_int_key_ver_shadowed_wd = reg_wdata[31:0];
  assign max_owner_key_ver_regwen_we = addr_hit[40] & reg_we & !reg_error;

  assign max_owner_key_ver_regwen_wd = reg_wdata[0];
  assign max_owner_key_ver_shadowed_re = addr_hit[41] & reg_re & !reg_error;
  assign max_owner_key_ver_shadowed_we = addr_hit[41] & reg_we & !reg_error;

  assign max_owner_key_ver_shadowed_wd = reg_wdata[31:0];
  assign sw_share0_output_0_re = addr_hit[42] & reg_re & !reg_error;

  assign sw_share0_output_0_wd = '1;
  assign sw_share0_output_1_re = addr_hit[43] & reg_re & !reg_error;

  assign sw_share0_output_1_wd = '1;
  assign sw_share0_output_2_re = addr_hit[44] & reg_re & !reg_error;

  assign sw_share0_output_2_wd = '1;
  assign sw_share0_output_3_re = addr_hit[45] & reg_re & !reg_error;

  assign sw_share0_output_3_wd = '1;
  assign sw_share0_output_4_re = addr_hit[46] & reg_re & !reg_error;

  assign sw_share0_output_4_wd = '1;
  assign sw_share0_output_5_re = addr_hit[47] & reg_re & !reg_error;

  assign sw_share0_output_5_wd = '1;
  assign sw_share0_output_6_re = addr_hit[48] & reg_re & !reg_error;

  assign sw_share0_output_6_wd = '1;
  assign sw_share0_output_7_re = addr_hit[49] & reg_re & !reg_error;

  assign sw_share0_output_7_wd = '1;
  assign sw_share1_output_0_re = addr_hit[50] & reg_re & !reg_error;

  assign sw_share1_output_0_wd = '1;
  assign sw_share1_output_1_re = addr_hit[51] & reg_re & !reg_error;

  assign sw_share1_output_1_wd = '1;
  assign sw_share1_output_2_re = addr_hit[52] & reg_re & !reg_error;

  assign sw_share1_output_2_wd = '1;
  assign sw_share1_output_3_re = addr_hit[53] & reg_re & !reg_error;

  assign sw_share1_output_3_wd = '1;
  assign sw_share1_output_4_re = addr_hit[54] & reg_re & !reg_error;

  assign sw_share1_output_4_wd = '1;
  assign sw_share1_output_5_re = addr_hit[55] & reg_re & !reg_error;

  assign sw_share1_output_5_wd = '1;
  assign sw_share1_output_6_re = addr_hit[56] & reg_re & !reg_error;

  assign sw_share1_output_6_wd = '1;
  assign sw_share1_output_7_re = addr_hit[57] & reg_re & !reg_error;

  assign sw_share1_output_7_wd = '1;
  assign op_status_we = addr_hit[59] & reg_we & !reg_error;

  assign op_status_wd = reg_wdata[1:0];
  assign err_code_we = addr_hit[60] & reg_we & !reg_error;

  assign err_code_invalid_op_wd = reg_wdata[0];

  assign err_code_invalid_kmac_input_wd = reg_wdata[1];

  assign err_code_invalid_shadow_update_wd = reg_wdata[2];
  assign debug_we = addr_hit[62] & reg_we & !reg_error;

  assign debug_invalid_creator_seed_wd = reg_wdata[0];

  assign debug_invalid_owner_seed_wd = reg_wdata[1];

  assign debug_invalid_dev_id_wd = reg_wdata[2];

  assign debug_invalid_health_state_wd = reg_wdata[3];

  assign debug_invalid_key_version_wd = reg_wdata[4];

  assign debug_invalid_key_wd = reg_wdata[5];

  assign debug_invalid_digest_wd = reg_wdata[6];

  // Assign write-enables to checker logic vector.
  always_comb begin
    reg_we_check = '0;
    reg_we_check[0] = intr_state_we;
    reg_we_check[1] = intr_enable_we;
    reg_we_check[2] = intr_test_we;
    reg_we_check[3] = alert_test_we;
    reg_we_check[4] = 1'b0;
    reg_we_check[5] = start_gated_we;
    reg_we_check[6] = control_shadowed_gated_we;
    reg_we_check[7] = sideload_clear_gated_we;
    reg_we_check[8] = reseed_interval_regwen_we;
    reg_we_check[9] = reseed_interval_shadowed_gated_we;
    reg_we_check[10] = sw_binding_regwen_we;
    reg_we_check[11] = sealing_sw_binding_0_gated_we;
    reg_we_check[12] = sealing_sw_binding_1_gated_we;
    reg_we_check[13] = sealing_sw_binding_2_gated_we;
    reg_we_check[14] = sealing_sw_binding_3_gated_we;
    reg_we_check[15] = sealing_sw_binding_4_gated_we;
    reg_we_check[16] = sealing_sw_binding_5_gated_we;
    reg_we_check[17] = sealing_sw_binding_6_gated_we;
    reg_we_check[18] = sealing_sw_binding_7_gated_we;
    reg_we_check[19] = attest_sw_binding_0_gated_we;
    reg_we_check[20] = attest_sw_binding_1_gated_we;
    reg_we_check[21] = attest_sw_binding_2_gated_we;
    reg_we_check[22] = attest_sw_binding_3_gated_we;
    reg_we_check[23] = attest_sw_binding_4_gated_we;
    reg_we_check[24] = attest_sw_binding_5_gated_we;
    reg_we_check[25] = attest_sw_binding_6_gated_we;
    reg_we_check[26] = attest_sw_binding_7_gated_we;
    reg_we_check[27] = salt_0_gated_we;
    reg_we_check[28] = salt_1_gated_we;
    reg_we_check[29] = salt_2_gated_we;
    reg_we_check[30] = salt_3_gated_we;
    reg_we_check[31] = salt_4_gated_we;
    reg_we_check[32] = salt_5_gated_we;
    reg_we_check[33] = salt_6_gated_we;
    reg_we_check[34] = salt_7_gated_we;
    reg_we_check[35] = key_version_gated_we;
    reg_we_check[36] = max_creator_key_ver_regwen_we;
    reg_we_check[37] = max_creator_key_ver_shadowed_gated_we;
    reg_we_check[38] = max_owner_int_key_ver_regwen_we;
    reg_we_check[39] = max_owner_int_key_ver_shadowed_gated_we;
    reg_we_check[40] = max_owner_key_ver_regwen_we;
    reg_we_check[41] = max_owner_key_ver_shadowed_gated_we;
    reg_we_check[42] = 1'b0;
    reg_we_check[43] = 1'b0;
    reg_we_check[44] = 1'b0;
    reg_we_check[45] = 1'b0;
    reg_we_check[46] = 1'b0;
    reg_we_check[47] = 1'b0;
    reg_we_check[48] = 1'b0;
    reg_we_check[49] = 1'b0;
    reg_we_check[50] = 1'b0;
    reg_we_check[51] = 1'b0;
    reg_we_check[52] = 1'b0;
    reg_we_check[53] = 1'b0;
    reg_we_check[54] = 1'b0;
    reg_we_check[55] = 1'b0;
    reg_we_check[56] = 1'b0;
    reg_we_check[57] = 1'b0;
    reg_we_check[58] = 1'b0;
    reg_we_check[59] = op_status_we;
    reg_we_check[60] = err_code_we;
    reg_we_check[61] = 1'b0;
    reg_we_check[62] = debug_we;
  end

  // Read data return
  always_comb begin
    reg_rdata_next = '0;
    unique case (1'b1)
      addr_hit[0]: begin
        reg_rdata_next[0] = intr_state_qs;
      end

      addr_hit[1]: begin
        reg_rdata_next[0] = intr_enable_qs;
      end

      addr_hit[2]: begin
        reg_rdata_next[0] = '0;
      end

      addr_hit[3]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
      end

      addr_hit[4]: begin
        reg_rdata_next[0] = cfg_regwen_qs;
      end

      addr_hit[5]: begin
        reg_rdata_next[0] = start_qs;
      end

      addr_hit[6]: begin
        reg_rdata_next[6:4] = control_shadowed_operation_qs;
        reg_rdata_next[7] = control_shadowed_cdi_sel_qs;
        reg_rdata_next[13:12] = control_shadowed_dest_sel_qs;
      end

      addr_hit[7]: begin
        reg_rdata_next[2:0] = sideload_clear_qs;
      end

      addr_hit[8]: begin
        reg_rdata_next[0] = reseed_interval_regwen_qs;
      end

      addr_hit[9]: begin
        reg_rdata_next[15:0] = reseed_interval_shadowed_qs;
      end

      addr_hit[10]: begin
        reg_rdata_next[0] = sw_binding_regwen_qs;
      end

      addr_hit[11]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_0_qs;
      end

      addr_hit[12]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_1_qs;
      end

      addr_hit[13]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_2_qs;
      end

      addr_hit[14]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_3_qs;
      end

      addr_hit[15]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_4_qs;
      end

      addr_hit[16]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_5_qs;
      end

      addr_hit[17]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_6_qs;
      end

      addr_hit[18]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_7_qs;
      end

      addr_hit[19]: begin
        reg_rdata_next[31:0] = attest_sw_binding_0_qs;
      end

      addr_hit[20]: begin
        reg_rdata_next[31:0] = attest_sw_binding_1_qs;
      end

      addr_hit[21]: begin
        reg_rdata_next[31:0] = attest_sw_binding_2_qs;
      end

      addr_hit[22]: begin
        reg_rdata_next[31:0] = attest_sw_binding_3_qs;
      end

      addr_hit[23]: begin
        reg_rdata_next[31:0] = attest_sw_binding_4_qs;
      end

      addr_hit[24]: begin
        reg_rdata_next[31:0] = attest_sw_binding_5_qs;
      end

      addr_hit[25]: begin
        reg_rdata_next[31:0] = attest_sw_binding_6_qs;
      end

      addr_hit[26]: begin
        reg_rdata_next[31:0] = attest_sw_binding_7_qs;
      end

      addr_hit[27]: begin
        reg_rdata_next[31:0] = salt_0_qs;
      end

      addr_hit[28]: begin
        reg_rdata_next[31:0] = salt_1_qs;
      end

      addr_hit[29]: begin
        reg_rdata_next[31:0] = salt_2_qs;
      end

      addr_hit[30]: begin
        reg_rdata_next[31:0] = salt_3_qs;
      end

      addr_hit[31]: begin
        reg_rdata_next[31:0] = salt_4_qs;
      end

      addr_hit[32]: begin
        reg_rdata_next[31:0] = salt_5_qs;
      end

      addr_hit[33]: begin
        reg_rdata_next[31:0] = salt_6_qs;
      end

      addr_hit[34]: begin
        reg_rdata_next[31:0] = salt_7_qs;
      end

      addr_hit[35]: begin
        reg_rdata_next[31:0] = key_version_qs;
      end

      addr_hit[36]: begin
        reg_rdata_next[0] = max_creator_key_ver_regwen_qs;
      end

      addr_hit[37]: begin
        reg_rdata_next[31:0] = max_creator_key_ver_shadowed_qs;
      end

      addr_hit[38]: begin
        reg_rdata_next[0] = max_owner_int_key_ver_regwen_qs;
      end

      addr_hit[39]: begin
        reg_rdata_next[31:0] = max_owner_int_key_ver_shadowed_qs;
      end

      addr_hit[40]: begin
        reg_rdata_next[0] = max_owner_key_ver_regwen_qs;
      end

      addr_hit[41]: begin
        reg_rdata_next[31:0] = max_owner_key_ver_shadowed_qs;
      end

      addr_hit[42]: begin
        reg_rdata_next[31:0] = sw_share0_output_0_qs;
      end

      addr_hit[43]: begin
        reg_rdata_next[31:0] = sw_share0_output_1_qs;
      end

      addr_hit[44]: begin
        reg_rdata_next[31:0] = sw_share0_output_2_qs;
      end

      addr_hit[45]: begin
        reg_rdata_next[31:0] = sw_share0_output_3_qs;
      end

      addr_hit[46]: begin
        reg_rdata_next[31:0] = sw_share0_output_4_qs;
      end

      addr_hit[47]: begin
        reg_rdata_next[31:0] = sw_share0_output_5_qs;
      end

      addr_hit[48]: begin
        reg_rdata_next[31:0] = sw_share0_output_6_qs;
      end

      addr_hit[49]: begin
        reg_rdata_next[31:0] = sw_share0_output_7_qs;
      end

      addr_hit[50]: begin
        reg_rdata_next[31:0] = sw_share1_output_0_qs;
      end

      addr_hit[51]: begin
        reg_rdata_next[31:0] = sw_share1_output_1_qs;
      end

      addr_hit[52]: begin
        reg_rdata_next[31:0] = sw_share1_output_2_qs;
      end

      addr_hit[53]: begin
        reg_rdata_next[31:0] = sw_share1_output_3_qs;
      end

      addr_hit[54]: begin
        reg_rdata_next[31:0] = sw_share1_output_4_qs;
      end

      addr_hit[55]: begin
        reg_rdata_next[31:0] = sw_share1_output_5_qs;
      end

      addr_hit[56]: begin
        reg_rdata_next[31:0] = sw_share1_output_6_qs;
      end

      addr_hit[57]: begin
        reg_rdata_next[31:0] = sw_share1_output_7_qs;
      end

      addr_hit[58]: begin
        reg_rdata_next[2:0] = working_state_qs;
      end

      addr_hit[59]: begin
        reg_rdata_next[1:0] = op_status_qs;
      end

      addr_hit[60]: begin
        reg_rdata_next[0] = err_code_invalid_op_qs;
        reg_rdata_next[1] = err_code_invalid_kmac_input_qs;
        reg_rdata_next[2] = err_code_invalid_shadow_update_qs;
      end

      addr_hit[61]: begin
        reg_rdata_next[0] = fault_status_cmd_qs;
        reg_rdata_next[1] = fault_status_kmac_fsm_qs;
        reg_rdata_next[2] = fault_status_kmac_done_qs;
        reg_rdata_next[3] = fault_status_kmac_op_qs;
        reg_rdata_next[4] = fault_status_kmac_out_qs;
        reg_rdata_next[5] = fault_status_regfile_intg_qs;
        reg_rdata_next[6] = fault_status_shadow_qs;
        reg_rdata_next[7] = fault_status_ctrl_fsm_intg_qs;
        reg_rdata_next[8] = fault_status_ctrl_fsm_chk_qs;
        reg_rdata_next[9] = fault_status_ctrl_fsm_cnt_qs;
        reg_rdata_next[10] = fault_status_reseed_cnt_qs;
        reg_rdata_next[11] = fault_status_side_ctrl_fsm_qs;
        reg_rdata_next[12] = fault_status_side_ctrl_sel_qs;
        reg_rdata_next[13] = fault_status_key_ecc_qs;
      end

      addr_hit[62]: begin
        reg_rdata_next[0] = debug_invalid_creator_seed_qs;
        reg_rdata_next[1] = debug_invalid_owner_seed_qs;
        reg_rdata_next[2] = debug_invalid_dev_id_qs;
        reg_rdata_next[3] = debug_invalid_health_state_qs;
        reg_rdata_next[4] = debug_invalid_key_version_qs;
        reg_rdata_next[5] = debug_invalid_key_qs;
        reg_rdata_next[6] = debug_invalid_digest_qs;
      end

      default: begin
        reg_rdata_next = '1;
      end
    endcase
  end

  // shadow busy
  logic shadow_busy;
  logic rst_done;
  logic shadow_rst_done;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      rst_done <= '0;
    end else begin
      rst_done <= 1'b1;
    end
  end

  always_ff @(posedge clk_i or negedge rst_shadowed_ni) begin
    if (!rst_shadowed_ni) begin
      shadow_rst_done <= '0;
    end else begin
      shadow_rst_done <= 1'b1;
    end
  end

  // both shadow and normal resets have been released
  assign shadow_busy = ~(rst_done & shadow_rst_done);

  // Collect up storage and update errors
  assign shadowed_storage_err_o = |{
    control_shadowed_operation_storage_err,
    control_shadowed_cdi_sel_storage_err,
    control_shadowed_dest_sel_storage_err,
    reseed_interval_shadowed_storage_err,
    max_creator_key_ver_shadowed_storage_err,
    max_owner_int_key_ver_shadowed_storage_err,
    max_owner_key_ver_shadowed_storage_err
  };
  assign shadowed_update_err_o = |{
    control_shadowed_operation_update_err,
    control_shadowed_cdi_sel_update_err,
    control_shadowed_dest_sel_update_err,
    reseed_interval_shadowed_update_err,
    max_creator_key_ver_shadowed_update_err,
    max_owner_int_key_ver_shadowed_update_err,
    max_owner_key_ver_shadowed_update_err
  };

  // register busy
  assign reg_busy = shadow_busy;

  // Unused signal tieoff

  // wdata / byte enable are not always fully used
  // add a blanket unused statement to handle lint waivers
  logic unused_wdata;
  logic unused_be;
  assign unused_wdata = ^reg_wdata;
  assign unused_be = ^reg_be;

  // Assertions for Register Interface
  `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
  `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)

  `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)

  `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)

  // this is formulated as an assumption such that the FPV testbenches do disprove this
  // property by mistake
  //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)

endmodule

    '''

    Form relevant system verilog assertions for the RTL to be checked for.
    These system verilog assertions should be in a dict with the key as the name and the value as the assertion string.
    An example assertions object to be sent to assertion checker tool is as follows:

    assertions = {"assertion_p1":"property p1;\n    @(posedge clk) signal_A |-> signal_B;\nendproperty
assertion_p1: assert property (p1);", "assertion_p2":"property p2;\n    @(posedge clk) conditions |-> signal_C;\nendproperty\nassertion_p2: assert property (p2);"}

    Then run the assertions using the assertion checker tool. This tool call must include the assertions dictionary as an argument.
    From the output of the assertion checker tool, determine if there are security issues in the RTL.
    If there are no falsified assertions in the output from the assertion checker tool, that means there are no verified security issues in the RTL.

    
================================== Ai Message ==================================

[{'text': "I'll analyze the provided RTL code for security concerns related to register access policy, privilege escalation, and shadow register integrity. Let me create relevant assertions to check for these issues.\n\nBased on the RTL code, I can see this is a register top module for a key manager (`keymgr_reg_top`). It contains several security-critical elements:\n1. Shadow registers (which have redundancy for security)\n2. Register access control mechanisms (REGWEN gates)\n3. Integrity checking logic\n\nLet me create assertions to verify these security properties:", 'type': 'text'}, {'id': 'toolu_019ST7H9LZY4UxWhcRrxVvCY', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv', 'top_module': 'keymgr_reg_top', 'assertions': {'shadow_storage_err_propagation': 'property shadow_storage_err_propagation;\n  @(posedge clk_i) \n  (control_shadowed_operation_storage_err || control_shadowed_cdi_sel_storage_err || \n   control_shadowed_dest_sel_storage_err || reseed_interval_shadowed_storage_err || \n   max_creator_key_ver_shadowed_storage_err || max_owner_int_key_ver_shadowed_storage_err || \n   max_owner_key_ver_shadowed_storage_err) |-> ##1 shadowed_storage_err_o;\nendproperty\nassert property (shadow_storage_err_propagation);', 'shadow_update_err_propagation': 'property shadow_update_err_propagation;\n  @(posedge clk_i) \n  (control_shadowed_operation_update_err || control_shadowed_cdi_sel_update_err || \n   control_shadowed_dest_sel_update_err || reseed_interval_shadowed_update_err || \n   max_creator_key_ver_shadowed_update_err || max_owner_int_key_ver_shadowed_update_err || \n   max_owner_key_ver_shadowed_update_err) |-> ##1 shadowed_update_err_o;\nendproperty\nassert property (shadow_update_err_propagation);', 'regwen_control_shadowed': 'property regwen_control_shadowed;\n  @(posedge clk_i) \n  (control_shadowed_we && !cfg_regwen_qs) |-> !control_shadowed_gated_we;\nendproperty\nassert property (regwen_control_shadowed);', 'regwen_start': 'property regwen_start;\n  @(posedge clk_i) \n  (start_we && !cfg_regwen_qs) |-> !start_gated_we;\nendproperty\nassert property (regwen_start);', 'intg_err_propagation': 'property intg_err_propagation;\n  @(posedge clk_i) \n  (intg_err || reg_we_err) |=> intg_err_o;\nendproperty\nassert property (intg_err_propagation);', 'shadow_busy_blocks_access': 'property shadow_busy_blocks_access;\n  @(posedge clk_i) \n  shadow_busy |-> reg_busy;\nendproperty\nassert property (shadow_busy_blocks_access);'}, 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_019ST7H9LZY4UxWhcRrxVvCY)
 Call ID: toolu_019ST7H9LZY4UxWhcRrxVvCY
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv
    top_module: keymgr_reg_top
    assertions: {'shadow_storage_err_propagation': 'property shadow_storage_err_propagation;\n  @(posedge clk_i) \n  (control_shadowed_operation_storage_err || control_shadowed_cdi_sel_storage_err || \n   control_shadowed_dest_sel_storage_err || reseed_interval_shadowed_storage_err || \n   max_creator_key_ver_shadowed_storage_err || max_owner_int_key_ver_shadowed_storage_err || \n   max_owner_key_ver_shadowed_storage_err) |-> ##1 shadowed_storage_err_o;\nendproperty\nassert property (shadow_storage_err_propagation);', 'shadow_update_err_propagation': 'property shadow_update_err_propagation;\n  @(posedge clk_i) \n  (control_shadowed_operation_update_err || control_shadowed_cdi_sel_update_err || \n   control_shadowed_dest_sel_update_err || reseed_interval_shadowed_update_err || \n   max_creator_key_ver_shadowed_update_err || max_owner_int_key_ver_shadowed_update_err || \n   max_owner_key_ver_shadowed_update_err) |-> ##1 shadowed_update_err_o;\nendproperty\nassert property (shadow_update_err_propagation);', 'regwen_control_shadowed': 'property regwen_control_shadowed;\n  @(posedge clk_i) \n  (control_shadowed_we && !cfg_regwen_qs) |-> !control_shadowed_gated_we;\nendproperty\nassert property (regwen_control_shadowed);', 'regwen_start': 'property regwen_start;\n  @(posedge clk_i) \n  (start_we && !cfg_regwen_qs) |-> !start_gated_we;\nendproperty\nassert property (regwen_start);', 'intg_err_propagation': 'property intg_err_propagation;\n  @(posedge clk_i) \n  (intg_err || reg_we_err) |=> intg_err_o;\nendproperty\nassert property (intg_err_propagation);', 'shadow_busy_blocks_access': 'property shadow_busy_blocks_access;\n  @(posedge clk_i) \n  shadow_busy |-> reg_busy;\nendproperty\nassert property (shadow_busy_blocks_access);'}
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: assertion_checker_tool

Failed to execute. Error: KeyError('unnamed$$_77')
KeyError: 'unnamed$$_77'
Traceback (most recent call last):
  File "/home/XXXX-2/security_agents/security_agents.py", line 763, in assertion_checker_tool
    falsified_properties[name] = assertions[name]
                               ~~~~~~~~~~^^^^^^
KeyError: 'unnamed$$_77'
================================== Ai Message ==================================

[{'text': 'I apologize for the error. Let me try again with properly formatted assertions:', 'type': 'text'}, {'id': 'toolu_01RFSMhXG3y4yq4gnSVDRV6C', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv', 'top_module': 'keymgr_reg_top', 'assertions': {'shadow_storage_err_prop': 'property shadow_storage_err_prop;\n  @(posedge clk_i) \n  (control_shadowed_operation_storage_err || control_shadowed_cdi_sel_storage_err || \n   control_shadowed_dest_sel_storage_err || reseed_interval_shadowed_storage_err || \n   max_creator_key_ver_shadowed_storage_err || max_owner_int_key_ver_shadowed_storage_err || \n   max_owner_key_ver_shadowed_storage_err) |-> ##1 shadowed_storage_err_o;\nendproperty\nshadow_storage_err_prop_assert: assert property (shadow_storage_err_prop);', 'shadow_update_err_prop': 'property shadow_update_err_prop;\n  @(posedge clk_i) \n  (control_shadowed_operation_update_err || control_shadowed_cdi_sel_update_err || \n   control_shadowed_dest_sel_update_err || reseed_interval_shadowed_update_err || \n   max_creator_key_ver_shadowed_update_err || max_owner_int_key_ver_shadowed_update_err || \n   max_owner_key_ver_shadowed_update_err) |-> ##1 shadowed_update_err_o;\nendproperty\nshadow_update_err_prop_assert: assert property (shadow_update_err_prop);', 'regwen_control_prop': 'property regwen_control_prop;\n  @(posedge clk_i) \n  (control_shadowed_we && !cfg_regwen_qs) |-> !control_shadowed_gated_we;\nendproperty\nregwen_control_prop_assert: assert property (regwen_control_prop);', 'regwen_start_prop': 'property regwen_start_prop;\n  @(posedge clk_i) \n  (start_we && !cfg_regwen_qs) |-> !start_gated_we;\nendproperty\nregwen_start_prop_assert: assert property (regwen_start_prop);', 'intg_err_prop': 'property intg_err_prop;\n  @(posedge clk_i) \n  (intg_err || reg_we_err) |=> intg_err_o;\nendproperty\nintg_err_prop_assert: assert property (intg_err_prop);', 'shadow_busy_prop': 'property shadow_busy_prop;\n  @(posedge clk_i) \n  shadow_busy |-> reg_busy;\nendproperty\nshadow_busy_prop_assert: assert property (shadow_busy_prop);'}, 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01RFSMhXG3y4yq4gnSVDRV6C)
 Call ID: toolu_01RFSMhXG3y4yq4gnSVDRV6C
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv
    top_module: keymgr_reg_top
    assertions: {'shadow_storage_err_prop': 'property shadow_storage_err_prop;\n  @(posedge clk_i) \n  (control_shadowed_operation_storage_err || control_shadowed_cdi_sel_storage_err || \n   control_shadowed_dest_sel_storage_err || reseed_interval_shadowed_storage_err || \n   max_creator_key_ver_shadowed_storage_err || max_owner_int_key_ver_shadowed_storage_err || \n   max_owner_key_ver_shadowed_storage_err) |-> ##1 shadowed_storage_err_o;\nendproperty\nshadow_storage_err_prop_assert: assert property (shadow_storage_err_prop);', 'shadow_update_err_prop': 'property shadow_update_err_prop;\n  @(posedge clk_i) \n  (control_shadowed_operation_update_err || control_shadowed_cdi_sel_update_err || \n   control_shadowed_dest_sel_update_err || reseed_interval_shadowed_update_err || \n   max_creator_key_ver_shadowed_update_err || max_owner_int_key_ver_shadowed_update_err || \n   max_owner_key_ver_shadowed_update_err) |-> ##1 shadowed_update_err_o;\nendproperty\nshadow_update_err_prop_assert: assert property (shadow_update_err_prop);', 'regwen_control_prop': 'property regwen_control_prop;\n  @(posedge clk_i) \n  (control_shadowed_we && !cfg_regwen_qs) |-> !control_shadowed_gated_we;\nendproperty\nregwen_control_prop_assert: assert property (regwen_control_prop);', 'regwen_start_prop': 'property regwen_start_prop;\n  @(posedge clk_i) \n  (start_we && !cfg_regwen_qs) |-> !start_gated_we;\nendproperty\nregwen_start_prop_assert: assert property (regwen_start_prop);', 'intg_err_prop': 'property intg_err_prop;\n  @(posedge clk_i) \n  (intg_err || reg_we_err) |=> intg_err_o;\nendproperty\nintg_err_prop_assert: assert property (intg_err_prop);', 'shadow_busy_prop': 'property shadow_busy_prop;\n  @(posedge clk_i) \n  shadow_busy |-> reg_busy;\nendproperty\nshadow_busy_prop_assert: assert property (shadow_busy_prop);'}
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: assertion_checker_tool

Failed to execute. Error: KeyError('shadow_storage_err_prop_assert')
KeyError: 'shadow_storage_err_prop_assert'
Traceback (most recent call last):
  File "/home/XXXX-2/security_agents/security_agents.py", line 763, in assertion_checker_tool
    falsified_properties[name] = assertions[name]
                               ~~~~~~~~~~^^^^^^
KeyError: 'shadow_storage_err_prop_assert'
================================== Ai Message ==================================

[{'text': 'I apologize for the continued errors. Let me simplify the assertions and try again:', 'type': 'text'}, {'id': 'toolu_012PDn8TjJQwv5sBMi1ZA9zM', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv', 'top_module': 'keymgr_reg_top', 'assertions': {'shadow_storage_err': 'property shadow_storage_err;\n  @(posedge clk_i) \n  (control_shadowed_operation_storage_err || control_shadowed_cdi_sel_storage_err || \n   control_shadowed_dest_sel_storage_err || reseed_interval_shadowed_storage_err || \n   max_creator_key_ver_shadowed_storage_err || max_owner_int_key_ver_shadowed_storage_err || \n   max_owner_key_ver_shadowed_storage_err) |-> ##1 shadowed_storage_err_o;\nendproperty\nshadow_storage_err: assert property (shadow_storage_err);', 'shadow_update_err': 'property shadow_update_err;\n  @(posedge clk_i) \n  (control_shadowed_operation_update_err || control_shadowed_cdi_sel_update_err || \n   control_shadowed_dest_sel_update_err || reseed_interval_shadowed_update_err || \n   max_creator_key_ver_shadowed_update_err || max_owner_int_key_ver_shadowed_update_err || \n   max_owner_key_ver_shadowed_update_err) |-> ##1 shadowed_update_err_o;\nendproperty\nshadow_update_err: assert property (shadow_update_err);', 'regwen_control': 'property regwen_control;\n  @(posedge clk_i) \n  (control_shadowed_we && !cfg_regwen_qs) |-> !control_shadowed_gated_we;\nendproperty\nregwen_control: assert property (regwen_control);', 'regwen_start': 'property regwen_start;\n  @(posedge clk_i) \n  (start_we && !cfg_regwen_qs) |-> !start_gated_we;\nendproperty\nregwen_start: assert property (regwen_start);', 'intg_err': 'property intg_err_prop;\n  @(posedge clk_i) \n  (intg_err || reg_we_err) |=> intg_err_o;\nendproperty\nintg_err: assert property (intg_err_prop);', 'shadow_busy': 'property shadow_busy_prop;\n  @(posedge clk_i) \n  shadow_busy |-> reg_busy;\nendproperty\nshadow_busy: assert property (shadow_busy_prop);'}, 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_012PDn8TjJQwv5sBMi1ZA9zM)
 Call ID: toolu_012PDn8TjJQwv5sBMi1ZA9zM
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv
    top_module: keymgr_reg_top
    assertions: {'shadow_storage_err': 'property shadow_storage_err;\n  @(posedge clk_i) \n  (control_shadowed_operation_storage_err || control_shadowed_cdi_sel_storage_err || \n   control_shadowed_dest_sel_storage_err || reseed_interval_shadowed_storage_err || \n   max_creator_key_ver_shadowed_storage_err || max_owner_int_key_ver_shadowed_storage_err || \n   max_owner_key_ver_shadowed_storage_err) |-> ##1 shadowed_storage_err_o;\nendproperty\nshadow_storage_err: assert property (shadow_storage_err);', 'shadow_update_err': 'property shadow_update_err;\n  @(posedge clk_i) \n  (control_shadowed_operation_update_err || control_shadowed_cdi_sel_update_err || \n   control_shadowed_dest_sel_update_err || reseed_interval_shadowed_update_err || \n   max_creator_key_ver_shadowed_update_err || max_owner_int_key_ver_shadowed_update_err || \n   max_owner_key_ver_shadowed_update_err) |-> ##1 shadowed_update_err_o;\nendproperty\nshadow_update_err: assert property (shadow_update_err);', 'regwen_control': 'property regwen_control;\n  @(posedge clk_i) \n  (control_shadowed_we && !cfg_regwen_qs) |-> !control_shadowed_gated_we;\nendproperty\nregwen_control: assert property (regwen_control);', 'regwen_start': 'property regwen_start;\n  @(posedge clk_i) \n  (start_we && !cfg_regwen_qs) |-> !start_gated_we;\nendproperty\nregwen_start: assert property (regwen_start);', 'intg_err': 'property intg_err_prop;\n  @(posedge clk_i) \n  (intg_err || reg_we_err) |=> intg_err_o;\nendproperty\nintg_err: assert property (intg_err_prop);', 'shadow_busy': 'property shadow_busy_prop;\n  @(posedge clk_i) \n  shadow_busy |-> reg_busy;\nendproperty\nshadow_busy: assert property (shadow_busy_prop);'}
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: assertion_checker_tool

Failed to execute. Error: KeyError('shadow_storage_err_prop_assert')
KeyError: 'shadow_storage_err_prop_assert'
Traceback (most recent call last):
  File "/home/XXXX-2/security_agents/security_agents.py", line 763, in assertion_checker_tool
    falsified_properties[name] = assertions[name]
                               ~~~~~~~~~~^^^^^^
KeyError: 'shadow_storage_err_prop_assert'
================================== Ai Message ==================================

[{'text': 'I apologize for the continued issues. Let me try with a single, simple assertion to diagnose the problem:', 'type': 'text'}, {'id': 'toolu_01Mbfqhru4r7nC8kqiF5N4S6', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv', 'top_module': 'keymgr_reg_top', 'assertions': {'regwen_check': 'property regwen_check;\n  @(posedge clk_i) \n  (start_we && !cfg_regwen_qs) |-> !start_gated_we;\nendproperty\nregwen_check: assert property(regwen_check);'}, 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01Mbfqhru4r7nC8kqiF5N4S6)
 Call ID: toolu_01Mbfqhru4r7nC8kqiF5N4S6
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv
    top_module: keymgr_reg_top
    assertions: {'regwen_check': 'property regwen_check;\n  @(posedge clk_i) \n  (start_we && !cfg_regwen_qs) |-> !start_gated_we;\nendproperty\nregwen_check: assert property(regwen_check);'}
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: run_assertions_checker_agent

[{"text": "I apologize for the continued issues. Let me try with a single, simple assertion to diagnose the problem:", "type": "text"}, {"id": "toolu_01Mbfqhru4r7nC8kqiF5N4S6", "input": {"design_filepath": "/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv", "top_module": "keymgr_reg_top", "assertions": {"regwen_check": "property regwen_check;\n  @(posedge clk_i) \n  (start_we && !cfg_regwen_qs) |-> !start_gated_we;\nendproperty\nregwen_check: assert property(regwen_check);"}, "clock_signal": "clk_i", "reset_signal": "rst_ni", "reset_active": "low"}, "name": "assertion_checker_tool", "type": "tool_use"}]
================================== Ai Message ==================================
Tool Calls:
  run_assertions_checker_agent (call_H179w5juViUiJS7ilAE5m5zn)
 Call ID: call_H179w5juViUiJS7ilAE5m5zn
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_ctrl.sv
    top_module: keymgr_ctrl
    security_objective: illegal state transitions, privilege escalation, FSM stuck/faulty
================================ Human Message =================================

Are there security concerns related to illegal state transitions, privilege escalation, FSM stuck/faulty in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_ctrl.sv

    And the top module is:

    keymgr_ctrl

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Key manager top level
//

`include "prim_assert.sv"

module keymgr_ctrl
  import keymgr_pkg::*;
  import keymgr_reg_pkg::*;
#(
  parameter bit KmacEnMasking = 1'b1
) (
  input clk_i,
  input rst_ni,

  // lifecycle enforcement
  // SEC_CM: CTRL.FSM.GLOBAL_ESC
  input en_i,

  // faults that can occur outside of operations
  input regfile_intg_err_i,
  input shadowed_update_err_i,
  input shadowed_storage_err_i,
  input reseed_cnt_err_i,
  input sideload_sel_err_i,
  input sideload_fsm_err_i,

  // Software interface
  input op_start_i,
  input keymgr_ops_e op_i,
  input [CdiWidth-1:0] op_cdi_sel_i,
  output logic op_done_o,
  output keymgr_op_status_e status_o,
  output logic [ErrLastPos-1:0] error_o,
  output logic [FaultLastPos-1:0] fault_o,
  output logic data_hw_en_o,
  output logic data_sw_en_o,
  output logic data_valid_o,
  output logic wipe_key_o,
  output keymgr_working_state_e working_state_o,
  output logic sw_binding_unlock_o,
  output logic init_o,

  // Data input
  input  otp_ctrl_pkg::otp_keymgr_key_t root_key_i,
  output prim_mubi_pkg::mubi4_t hw_sel_o,
  output keymgr_stage_e stage_sel_o,
  output logic invalid_stage_sel_o,
  output logic [CdiWidth-1:0] cdi_sel_o,

  // KMAC ctrl interface
  output logic adv_en_o,
  output logic id_en_o,
  output logic gen_en_o,
  output hw_key_req_t key_o,
  input kmac_done_i,
  input kmac_input_invalid_i, // asserted when selected data fails criteria check
  input kmac_fsm_err_i, // asserted when kmac fsm reaches unexpected state
  input kmac_op_err_i,  // asserted when kmac itself reports an error
  input kmac_done_err_i,// asserted when kmac unexpectedly toggles done
  input kmac_cmd_err_i, // asserted when more than one command given to kmac
  input [Shares-1:0][KeyWidth-1:0] kmac_data_i,

  // prng control interface
  input [Shares-1:0][RandWidth-1:0] entropy_i,
  input prng_reseed_done_i,
  input prng_reseed_ack_i,
  output logic prng_reseed_req_o,
  output logic prng_en_o
);

  localparam int EntropyWidth = LfsrWidth / 2;
  localparam int EntropyRounds = KeyWidth / EntropyWidth;
  localparam int EntropyRndWidth = prim_util_pkg::vbits(EntropyRounds);
  localparam int CntWidth = EntropyRounds > CDIs ? EntropyRndWidth : CdiWidth;
  localparam int EccDataWidth = 64;
  localparam int EccWidth = 8;
  localparam int EccWords = KeyWidth / EccDataWidth;
  localparam int TotalEccWords = EccWords * Shares * CDIs;


  // Enumeration for working state
  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 5 -m 11 -n 10 \
  //      -s 4101887575 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: --
  //  4: --
  //  5: |||||||||||||||||||| (54.55%)
  //  6: |||||||||||||||| (45.45%)
  //  7: --
  //  8: --
  //  9: --
  // 10: --
  //
  // Minimum Hamming distance: 5
  // Maximum Hamming distance: 6
  // Minimum Hamming weight: 2
  // Maximum Hamming weight: 8
  //
  localparam int StateWidth = 10;
  typedef enum logic [StateWidth-1:0] {
    StCtrlReset          = 10'b1101100001,
    StCtrlEntropyReseed  = 10'b1110010010,
    StCtrlRandom         = 10'b0011110100,
    StCtrlRootKey        = 10'b0110101111,
    StCtrlInit           = 10'b0100000100,
    StCtrlCreatorRootKey = 10'b1000011101,
    StCtrlOwnerIntKey    = 10'b0001001010,
    StCtrlOwnerKey       = 10'b1101111110,
    StCtrlDisabled       = 10'b1010101000,
    StCtrlWipe           = 10'b0000110011,
    StCtrlInvalid        = 10'b1011000111
  } state_e;
  state_e state_q, state_d;

  // A variable that represents differentiates states before root key and after root key.
  logic initialized;

  // There are two versions of the key state, one for sealing one for attestation
  // Among each version, there are multiple shares
  // Each share is a fixed multiple of the entropy width
  logic [CDIs-1:0][Shares-1:0][EntropyRounds-1:0][EntropyWidth-1:0] key_state_d;
  logic [CDIs-1:0][Shares-1:0][EccWords-1:0][EccDataWidth-1:0] key_state_ecc_words_d;
  logic [CDIs-1:0][Shares-1:0][EccWords-1:0][EccDataWidth-1:0] key_state_q;
  logic [CDIs-1:0][Shares-1:0][EccWords-1:0][EccWidth-1:0] key_state_ecc_q;
  logic [CntWidth-1:0] cnt;
  logic [CdiWidth-1:0] cdi_cnt;

  // error conditions
  logic invalid_kmac_out;
  logic invalid_op;
  logic cnt_err;
  // states fall out of sparsely encoded range
  logic state_intg_err_q, state_intg_err_d;

  ///////////////////////////
  //  General operation decode
  ///////////////////////////

  logic adv_op, dis_op, gen_id_op, gen_sw_op, gen_hw_op, gen_op;
  assign adv_op    = (op_i == OpAdvance);
  assign gen_id_op = (op_i == OpGenId);
  assign gen_sw_op = (op_i == OpGenSwOut);
  assign gen_hw_op = (op_i == OpGenHwOut);
  assign dis_op    = ~(op_i inside {OpAdvance, OpGenId, OpGenSwOut, OpGenHwOut});
  assign gen_op    = (gen_id_op | gen_sw_op | gen_hw_op);

  ///////////////////////////
  //  interaction between software and main fsm
  ///////////////////////////
  // disable is treated like an advanced call
  logic advance_sel;
  logic disable_sel;
  logic gen_out_hw_sel;

  assign advance_sel    = op_start_i & adv_op    & en_i;
  assign gen_out_hw_sel = op_start_i & gen_hw_op & en_i;

  // disable is selected whenever a normal operation is not set
  assign disable_sel    = (op_start_i & dis_op) | !en_i;


  ///////////////////////////
  //  interaction between main control fsm and operation fsm
  ///////////////////////////

  // req/ack interface with op handling fsm
  logic op_req;
  logic op_ack;
  logic op_update;
  logic op_busy;
  logic disabled;
  logic invalid;

  logic adv_req, dis_req, id_req, gen_req;
  assign adv_req = op_req & adv_op;
  assign dis_req = op_req & dis_op;
  assign id_req  = op_req & gen_id_op;
  assign gen_req = op_req & (gen_sw_op | gen_hw_op);

  ///////////////////////////
  //  interaction between operation fsm and software
  ///////////////////////////
  // categories of keymgr errors
  logic [SyncErrLastIdx-1:0] sync_err;
  logic [SyncFaultLastIdx-1:0] sync_fault;
  logic [AsyncFaultLastIdx-1:0] async_fault;

  logic op_err;
  logic op_fault_err;

  // unlock sw binding configuration whenever an advance call is made without errors
  assign sw_binding_unlock_o = adv_req & op_ack & ~(op_err | op_fault_err);

  // error definition
  // check incoming kmac data validity
  // Only check during the periods when there is actual kmac output
  assign invalid_kmac_out = (op_update | op_ack) &
                            (~valid_data_chk(kmac_data_i[0]) |
                            (~valid_data_chk(kmac_data_i[1]) & KmacEnMasking));

  // async errors have nothing to do with the operation and thus should not
  // impact operation results.
  assign op_err = |sync_err;

  assign op_fault_err = |{sync_fault, async_fault};

  ///////////////////////////
  //  key update controls
  ///////////////////////////

  // update select can come from both main and operation fsm's
  keymgr_key_update_e update_sel, op_update_sel;

  // req from main control fsm to key update controls
  logic wipe_req;
  logic random_req;
  logic random_ack;

  // wipe and initialize take precedence
  assign update_sel = wipe_req             ? KeyUpdateWipe   :
                      random_req           ? KeyUpdateRandom :
                      init_o               ? KeyUpdateRoot   : op_update_sel;

  ///////////////////////////
  //  interaction between main fsm and prng
  ///////////////////////////

  // Upon entering StCtrlDisabled or StCtrlInvalid, the PRNG is kept advancing until it has been
  // reseeded twice (through the reseeding mechansism inside keymgr_reseed_ctrl.sv).
  logic [1:0] prng_en_dis_inv_d, prng_en_dis_inv_q;
  logic prng_en_dis_inv_set;

  assign prng_en_dis_inv_d =
      prng_en_dis_inv_set ? 2'b11 :
      prng_reseed_done_i  ? {1'b0, prng_en_dis_inv_q[1]} : prng_en_dis_inv_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      prng_en_dis_inv_q <= '0;
    end else begin
      prng_en_dis_inv_q <= prng_en_dis_inv_d;
    end
  end

  assign prng_en_o = random_req | wipe_req | prng_en_dis_inv_q[0];

  //////////////////////////
  // Main Control FSM
  //////////////////////////
  // SEC_CM: CTRL.FSM.SPARSE
  `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, state_e, StCtrlReset)

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      state_intg_err_q <= '0;
    end else begin
      state_intg_err_q <= state_intg_err_d;
    end
  end

  // prevents unknowns from reaching the outside world.
  // - whatever operation causes the input data select to be disabled should not expose the key
  //   state.
  // - when there are no operations, the key state also should be exposed.
  assign key_o.valid = op_req;

  assign cdi_sel_o = advance_sel ? cdi_cnt : op_cdi_sel_i;

  assign invalid_stage_sel_o = ~(stage_sel_o inside {Creator, OwnerInt, Owner});
  for (genvar i = 0; i < Shares; i++) begin : gen_key_out_assign
    assign key_o.key[i] = invalid_stage_sel_o ?
                          {EntropyRounds{entropy_i[i]}} :
                          key_state_q[cdi_sel_o][i];
  end


  //SEC_CM: CTRL.KEY.INTEGRITY
  assign key_state_ecc_words_d = key_state_d;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      key_state_q <= '0;
      key_state_ecc_q <= {TotalEccWords{prim_secded_pkg::SecdedInv7264ZeroEcc}};
    end else begin
      for (int i = 0; i < CDIs; i++) begin
        for (int j = 0; j < Shares; j++) begin
          for (int k = 0; k < EccWords; k++) begin
            {key_state_ecc_q[i][j][k]} <=
                prim_secded_pkg::prim_secded_inv_72_64_enc(key_state_ecc_words_d[i][j][k]);
          end
        end
      end
    end
  end

  logic [CDIs-1:0][Shares-1:0][EccWords-1:0] ecc_errs;
  for (genvar i = 0; i < CDIs; i++) begin : gen_ecc_loop_cdi
    for (genvar j = 0; j < Shares; j++) begin : gen_ecc_loop_shares
      for (genvar k = 0; k < EccWords; k++) begin : gen_ecc_loop_words
        logic [1:0] errs;
        prim_secded_inv_72_64_dec u_dec (
          .data_i({key_state_ecc_q[i][j][k], key_state_q[i][j][k]}),
          .data_o(),
          .syndrome_o(),
          .err_o(errs)
        );
        assign ecc_errs[i][j][k] = |errs;
      end
    end
  end

  // These are consumed one level above in keymgr.sv
  logic unused_otp_sigs;
  assign unused_otp_sigs = ^{root_key_i.creator_seed,
                             root_key_i.creator_seed_valid,
                             root_key_i.owner_seed,
                             root_key_i.owner_seed_valid};

  // root key valid sync
  logic root_key_valid_q;

  prim_flop_2sync # (
    .Width(1)
  ) u_key_valid_sync (
    .clk_i,
    .rst_ni,
    // Both valid signals are flopped in OTP_CTRL, and they only ever transition from 0 -> 1.
    // It is hence ok to AND them here before the synchronizer, since we don't expect this
    // to create glitches.
    .d_i(root_key_i.creator_root_key_share0_valid &&
         root_key_i.creator_root_key_share1_valid),
    .q_o(root_key_valid_q)
  );

  // Do not let the count toggle unless an advance operation is
  // selected
  assign cdi_cnt = op_req ? cnt[CdiWidth-1:0] : '0;

  always_comb begin
    key_state_d = key_state_q;
    data_valid_o = 1'b0;
    wipe_key_o = 1'b0;

    // if a wipe request arrives, immediately destroy the
    // keys regardless of current state
    unique case (update_sel)
      KeyUpdateRandom: begin
        for (int i = 0; i < CDIs; i++) begin
          for (int j = 0; j < Shares; j++) begin
            // Load each share with the same randomness so we can
            // later simply XOR root key on them
            key_state_d[i][j][cnt[EntropyRndWidth-1:0]] = entropy_i[i];
          end
        end
      end

      KeyUpdateRoot: begin
        if (root_key_valid_q) begin
          for (int i = 0; i < CDIs; i++) begin
            if (KmacEnMasking) begin : gen_two_share_key
              key_state_d[i][0] ^= root_key_i.creator_root_key_share0;
              key_state_d[i][1] ^= root_key_i.creator_root_key_share1;
            end else begin : gen_one_share_key
              key_state_d[i][0] = root_key_i.creator_root_key_share0 ^
                                  root_key_i.creator_root_key_share1;
              key_state_d[i][1] = '0;
            end
          end
        end else begin
          // if root key is not valid, load and invalid value
          for (int i = 0; i < CDIs; i++) begin
              key_state_d[i][0] = '0;
              key_state_d[i][1] = '{default: '1};
          end
        end
      end

      KeyUpdateKmac: begin
        data_valid_o = gen_op;
        key_state_d[cdi_sel_o] = (adv_op || dis_op) ? kmac_data_i : key_state_q[cdi_sel_o];
      end

      KeyUpdateWipe: begin
        wipe_key_o = 1'b1;
        for (int i = 0; i < CDIs; i++) begin
          for (int j = 0; j < Shares; j++) begin
            key_state_d[i][j] = {EntropyRounds{entropy_i[j]}};
          end
        end
      end

      default:;
    endcase // unique case (update_sel)
  end

  // SEC_CM: CTRL.CTR.REDUN
  prim_count #(
    .Width(CntWidth)
  ) u_cnt (
    .clk_i,
    .rst_ni,
    .clr_i(op_ack | random_ack),
    .set_i('0),
    .set_cnt_i('0),
    .incr_en_i(op_update | random_req),
    .decr_en_i(1'b0),
    .step_i(CntWidth'(1'b1)),
    .commit_i(1'b1),
    .cnt_o(cnt),
    .cnt_after_commit_o(),
    .err_o(cnt_err)
  );


  prim_mubi4_sender u_hw_sel (
    .clk_i,
    .rst_ni,
    .mubi_i (prim_mubi_pkg::mubi4_bool_to_mubi(gen_out_hw_sel)),
    .mubi_o (hw_sel_o)
  );

  // when in a state that accepts commands, look at op_ack for completion
  // when in a state that does not accept commands, wait for other triggers.
  assign op_done_o = op_req ? op_ack :
                     (init_o | invalid_op);


  // There are 3 possibilities
  // advance to next state (software command)
  // advance to disabled state (software command)
  // advance to invalid state (detected fault)
  logic adv_state;
  logic dis_state;
  logic inv_state;
  assign adv_state = op_ack & adv_req & ~op_err;
  assign dis_state = op_ack & dis_req;

  // SEC_CM: CTRL.FSM.LOCAL_ESC
  // begin invalidation when faults are observed.
  // sync faults only invalidate on transaction boudaries
  // async faults begin invalidating immediately
  assign inv_state = |fault_o;

  always_comb begin
    // persistent data
    state_d = state_q;

    // request to op handling
    op_req = 1'b0;
    random_req = 1'b0;
    random_ack = 1'b0;

    // request to key updates
    wipe_req = 1'b0;

    // invalid operation issued
    invalid_op = '0;

    // data update and select signals
    stage_sel_o = Disable;

    // indication that state is disabled
    disabled = 1'b0;

    // indication that state is invalid
    invalid = 1'b0;

    // Don't request final PRNG updating and reseeding.
    prng_en_dis_inv_set = 1'b0;

    // Request PRNG reseeding.
    prng_reseed_req_o = 1'b0;

    // initialization complete
    init_o = 1'b0;

    // Most states are initialized, mark the exceptions
    initialized = 1'b1;

    // if state is ever faulted, hold on to this indication
    // until reset.
    state_intg_err_d = state_intg_err_q;

    unique case (state_q)
      // Only advance can be called from reset state
      StCtrlReset: begin
        initialized = 1'b0;

        // always use random data for advance, since out of reset state
        // the key state will be randomized.
        stage_sel_o = Disable;

        // key state is updated when it is an advance call
        // all other operations are invalid, including disable
        invalid_op = op_start_i & ~advance_sel;

        // if there was a structural fault before anything began, wipe immediately
        if (inv_state) begin
          state_d = StCtrlWipe;
        end else if (advance_sel) begin
          state_d = StCtrlEntropyReseed;
        end
      end

      // reseed entropy
      StCtrlEntropyReseed: begin
        initialized = 1'b0;
        prng_reseed_req_o = 1'b1;

        if (prng_reseed_ack_i) begin
          state_d = StCtrlRandom;
        end
      end

      // This state does not accept any command.
      StCtrlRandom: begin
        initialized = 1'b0;
        random_req = 1'b1;

        // when mask population is complete, xor the root_key into the zero share
        // if in the future the root key is updated to 2 shares, it will direclty overwrite
        // the values here
        if (int'(cnt) == EntropyRounds-1) begin
          random_ack = 1'b1;
          state_d = StCtrlRootKey;
        end
      end

      // load the root key.
      StCtrlRootKey: begin
        init_o = 1'b1;
        initialized = 1'b1;
        state_d = (en_i && root_key_valid_q) ? StCtrlInit : StCtrlWipe;
      end

      // Beginning from the Init state, operations are accepted.
      // Only valid operation is advance state. If invalid command received,
      // random data is selected for operation and no persistent state is changed.
      StCtrlInit: begin
        op_req = op_start_i;

        // when advancing select creator data, otherwise use random input
        stage_sel_o = advance_sel ? Creator : Disable;
        invalid_op = op_start_i & ~(advance_sel | disable_sel);

        if (!en_i || inv_state) begin
          state_d = StCtrlWipe;
        end else if (dis_state) begin
          state_d = StCtrlDisabled;
          prng_en_dis_inv_set = 1'b1;
        end else if (adv_state) begin
          state_d = StCtrlCreatorRootKey;
        end
      end

      // all commands  are valid during this stage
      StCtrlCreatorRootKey: begin
        op_req = op_start_i;

        // when generating, select creator data input
        // when advancing, select owner intermediate key as target
        // when disabling, select random data input
        stage_sel_o = disable_sel ? Disable  :
                      advance_sel ? OwnerInt : Creator;

        if (!en_i || inv_state) begin
          state_d = StCtrlWipe;
        end else if (dis_state) begin
          state_d = StCtrlDisabled;
          prng_en_dis_inv_set = 1'b1;
        end else if (adv_state) begin
          state_d = StCtrlOwnerIntKey;
        end
      end

      // all commands are valid during this stage
      StCtrlOwnerIntKey: begin
        op_req = op_start_i;

        // when generating, select owner intermediate data input
        // when advancing, select owner as target
        // when disabling, select random data input
        stage_sel_o = disable_sel ? Disable  :
                      advance_sel ? Owner : OwnerInt;

        if (!en_i || inv_state) begin
          state_d = StCtrlWipe;
        end else if (dis_state) begin
          state_d = StCtrlDisabled;
          prng_en_dis_inv_set = 1'b1;
        end else if (adv_state) begin
          state_d = StCtrlOwnerKey;
        end
      end

      // all commands are valid during this stage
      // however advance goes directly to disabled state
      StCtrlOwnerKey: begin
        op_req = op_start_i;

        // when generating, select owner data input
        // when advancing, select disable as target
        // when disabling, select random data input
        stage_sel_o = disable_sel | advance_sel ? Disable : Owner;

        if (!en_i || inv_state) begin
          state_d = StCtrlWipe;
        end else if (adv_state || dis_state) begin
          state_d = StCtrlDisabled;
          prng_en_dis_inv_set = 1'b1;
        end
      end

      // The wipe state immediately clears out the key state, but waits for any ongoing
      // transaction to finish before going to disabled state.
      // Unlike the random state, this is an immedaite shutdown request, so all parts of the
      // key are wiped.
      StCtrlWipe: begin
        wipe_req = 1'b1;
        // if there was already an operation ongoing, maintain the request until completion
        op_req = op_busy;
        invalid_op = op_start_i;

        // If the enable is dropped during the middle of a transaction, we clear and wait for that
        // transaction to gracefully complete (if it can).
        // There are two scenarios:
        // 1. the operation completed right when we started wiping, in which case the done would
        //    clear the start.
        // 2. the operation completed before we started wiping, or there was never an operation to
        //    begin with (op_start_i == 0), in this case, don't wait and immediately transition
        if (!op_start_i) begin
          state_d = StCtrlInvalid;
          prng_en_dis_inv_set = 1'b1;
        end
      end

      // StCtrlDisabled and StCtrlInvalid are almost functionally equivalent
      // The only difference is that Disabled is entered through software invocation,
      // while Invalid is entered through life cycle disable or operational fault.
      //
      // Both states continue to kick off random transactions
      // All transactions are treated as invalid despite completing
      StCtrlDisabled: begin
        op_req = op_start_i;
        disabled = 1'b1;

        if (!en_i || inv_state) begin
          state_d = StCtrlWipe;
        end
      end

      StCtrlInvalid: begin
        invalid_op = op_start_i;
        invalid = 1'b1;
      end

      // latch the fault indication and start to wipe the key manager
      default: begin
        state_intg_err_d = 1'b1;
        state_d = StCtrlWipe;
      end

    endcase // unique case (state_q)
  end // always_comb

  // Current working state provided for software read
  // Certain states are collapsed for simplicity
  keymgr_working_state_e last_working_st;
  logic update_en;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      last_working_st <= StReset;
    end else if (update_en) begin
      last_working_st <= working_state_o;
    end
  end

  always_comb begin
    update_en = 1'b1;
    working_state_o = StInvalid;

    unique case (state_q)
      StCtrlReset, StCtrlEntropyReseed, StCtrlRandom:
        working_state_o = StReset;

      StCtrlRootKey, StCtrlInit:
        working_state_o = StInit;

      StCtrlCreatorRootKey:
        working_state_o = StCreatorRootKey;

      StCtrlOwnerIntKey:
        working_state_o = StOwnerIntKey;

      StCtrlOwnerKey:
        working_state_o = StOwnerKey;

      StCtrlDisabled:
        working_state_o = StDisabled;

      StCtrlWipe: begin
        update_en = 1'b0;
        working_state_o = last_working_st;
      end

      StCtrlInvalid:
        working_state_o = StInvalid;

      default:
        working_state_o = StInvalid;
    endcase // unique case (state_q)
  end

  always_comb begin
    status_o = OpIdle;
    if (op_done_o) begin
      // It is possible for an operation to finish the same cycle en_i goes low.
      // The main fsm handling is one cycle behind, but still report operation
      // fail.
      status_o = |{error_o, fault_o} ? OpDoneFail : OpDoneSuccess;
    end else if (op_start_i) begin
      status_o = OpWip;
    end
  end


  /////////////////////////
  // Operateion state, handle advance and generate
  /////////////////////////

  logic op_fsm_err;
  keymgr_op_state_ctrl u_op_state (
    .clk_i,
    .rst_ni,
    .adv_req_i(adv_req),
    .dis_req_i(dis_req),
    .id_req_i(id_req),
    .gen_req_i(gen_req),
    .cnt_i(cdi_cnt),
    .op_ack_o(op_ack),
    .op_busy_o(op_busy),
    .op_update_o(op_update),
    .kmac_done_i,
    .adv_en_o,
    .id_en_o,
    .gen_en_o,
    .op_fsm_err_o(op_fsm_err)
  );

  // operational state cross check.  The state value must be consistent with
  // the input operations.
  logic op_state_cmd_err;
  assign op_state_cmd_err = (adv_en_o & ~(advance_sel | disable_sel)) |
                            (gen_en_o & ~gen_op);

  // operations fsm update precedence
  // when in invalid state, always update.
  // when in disabled state, always update unless a fault is encountered.
  assign op_update_sel = (op_ack | op_update) & invalid      ? KeyUpdateKmac :
                         (op_ack | op_update) & op_fault_err ? KeyUpdateWipe :
                         (op_ack | op_update) & disabled     ? KeyUpdateKmac :
                         (op_ack | op_update) & op_err       ? KeyUpdateIdle :
                         (op_ack | op_update)                ? KeyUpdateKmac : KeyUpdateIdle;


  ///////////////////////////////
  // Suppress kmac return data
  ///////////////////////////////

  logic data_fsm_err;
  keymgr_data_en_state u_data_en (
    .clk_i,
    .rst_ni,
    .hw_sel_i(hw_sel_o),
    .adv_en_i(adv_en_o),
    .id_en_i(id_en_o),
    .gen_en_i(gen_en_o),
    .op_done_i(op_done_o),
    .op_start_i,
    .data_hw_en_o,
    .data_sw_en_o,
    .fsm_err_o(data_fsm_err)
  );

  /////////////////////////
  // Cross-checks, errors and faults
  /////////////////////////

  logic vld_state_change_d, vld_state_change_q;
  assign vld_state_change_d = (state_d != state_q) &
                              (state_d inside {StCtrlRootKey,
                                               StCtrlCreatorRootKey,
                                               StCtrlOwnerIntKey,
                                               StCtrlOwnerKey});

  // capture for cross check in following cycle
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      vld_state_change_q <= '0;
    end else begin
      vld_state_change_q <= vld_state_change_d;
    end
  end

  // state cross check
  // if the state advanced, ensure that it was due to an advanced operation
  logic state_change_err;
  assign state_change_err = vld_state_change_q & !adv_op;

  keymgr_err u_err (
    .clk_i,
    .rst_ni,
    .invalid_op_i(invalid_op),
    .disabled_i(disabled | (initialized & ~en_i)),
    .invalid_i(invalid),
    .kmac_input_invalid_i,
    .shadowed_update_err_i,
    .kmac_op_err_i,
    .invalid_kmac_out_i(invalid_kmac_out),
    .sideload_sel_err_i,
    .kmac_cmd_err_i,
    .kmac_fsm_err_i,
    .kmac_done_err_i,
    .regfile_intg_err_i,
    .shadowed_storage_err_i,
    .ctrl_fsm_err_i(state_intg_err_q | state_intg_err_d),
    .data_fsm_err_i(data_fsm_err),
    .op_fsm_err_i(op_fsm_err),
    .ecc_err_i(|ecc_errs),
    .state_change_err_i(state_change_err),
    .op_state_cmd_err_i(op_state_cmd_err),
    .cnt_err_i(cnt_err),
    .reseed_cnt_err_i,
    .sideload_fsm_err_i,

    .op_update_i(op_update),
    .op_done_i(op_done_o),

    .sync_err_o(sync_err),
    .async_err_o(),
    .sync_fault_o(sync_fault),
    .async_fault_o(async_fault),
    .error_o,
    .fault_o
  );

  ///////////////////////////////
  // Functions
  ///////////////////////////////

  // unclear what this is supposed to be yet
  // right now just check to see if it not all 0's and not all 1's
 function automatic logic valid_data_chk (logic [KeyWidth-1:0] value);

    return |value & ~&value;

  endfunction // byte_mask

  /////////////////////////////////
  // Assertions
  /////////////////////////////////

  // This assertion will not work if fault_status ever takes on metafields such as
  // qe / re etc.
  `ASSERT_INIT(SameErrCnt_A, $bits(keymgr_reg2hw_fault_status_reg_t) ==
                             (SyncFaultLastIdx + AsyncFaultLastIdx))

  // stage select should always be Disable whenever it is not enabled
  `ASSERT(StageDisableSel_A, !en_i |-> stage_sel_o == Disable)

  // Unless it is a legal command, only select disable
  `ASSERT(InitLegalCommands_A, op_start_i & en_i & state_q inside {StCtrlInit} &
                               !(op_i inside {OpAdvance}) |-> stage_sel_o == Disable)

  // All commands are legal, so select disable only if operation is disable
  `ASSERT(GeneralLegalCommands_A, op_start_i & en_i &
                                  state_q inside {StCtrlCreatorRootKey, StCtrlOwnerIntKey} &
                                  (op_i inside {OpDisable}) |-> stage_sel_o == Disable)

  `ASSERT(OwnerLegalCommands_A, op_start_i & en_i & state_q inside {StCtrlOwnerKey} &
                                (op_i inside {OpAdvance, OpDisable}) |-> stage_sel_o == Disable)

  // load_key should not be high if there is no ongoing operation
  `ASSERT(LoadKey_A, key_o.valid |-> op_start_i)

  // The count value should always be 0 when a transaction start
  `ASSERT(CntZero_A, $rose(op_start_i) |-> cnt == '0)

  // Whenever a transaction completes, data_en must return to 0 on the next cycle
  `ASSERT(DataEnDis_A, op_start_i & op_done_o |=> ~data_hw_en_o && ~data_sw_en_o)

  // Whenever data enable asserts, it must be the case that there was a generate or
  // id operation
  `ASSERT(DataEn_A, data_hw_en_o | data_sw_en_o |-> (id_en_o | gen_en_o) & ~adv_en_o)

  // Check that the FSM is linear and does not contain any loops
  `ASSERT_FPV_LINEAR_FSM(SecCmCFILinear_A, state_q, state_e)

endmodule

    '''

    Form relevant system verilog assertions for the RTL to be checked for.
    These system verilog assertions should be in a dict with the key as the name and the value as the assertion string.
    An example assertions object to be sent to assertion checker tool is as follows:

    assertions = {"assertion_p1":"property p1;\n    @(posedge clk) signal_A |-> signal_B;\nendproperty
assertion_p1: assert property (p1);", "assertion_p2":"property p2;\n    @(posedge clk) conditions |-> signal_C;\nendproperty\nassertion_p2: assert property (p2);"}

    Then run the assertions using the assertion checker tool. This tool call must include the assertions dictionary as an argument.
    From the output of the assertion checker tool, determine if there are security issues in the RTL.
    If there are no falsified assertions in the output from the assertion checker tool, that means there are no verified security issues in the RTL.

    
================================== Ai Message ==================================

[{'text': "I'll analyze the provided RTL code for security concerns related to illegal state transitions, privilege escalation, and FSM issues. Let me create relevant assertions to check for these security issues.\n\nBased on the code, I can see this is a key manager control module (`keymgr_ctrl`) that implements a state machine for managing cryptographic keys. The security concerns we need to check include:\n\n1. Illegal state transitions\n2. Privilege escalation\n3. FSM stuck/faulty states\n\nLet me create assertions to verify these security properties:", 'type': 'text'}, {'id': 'toolu_01Cmjq1HQo5hcisWjHe8jbmx', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_ctrl.sv', 'top_module': 'keymgr_ctrl', 'assertions': {'illegal_state_transition_p': 'property illegal_state_transition_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (state_q != StCtrlWipe && state_q != StCtrlInvalid) && inv_state |-> ##1 (state_q == StCtrlWipe);\nendproperty\nassert property (illegal_state_transition_p);', 'privilege_escalation_p': 'property privilege_escalation_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (state_q == StCtrlReset) && op_start_i && !advance_sel |-> ##1 (state_q != StCtrlCreatorRootKey && state_q != StCtrlOwnerIntKey && state_q != StCtrlOwnerKey);\nendproperty\nassert property (privilege_escalation_p);', 'fsm_integrity_p': 'property fsm_integrity_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  state_intg_err_q |-> ##1 (state_q == StCtrlWipe);\nendproperty\nassert property (fsm_integrity_p);', 'no_invalid_state_p': 'property no_invalid_state_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  !$isunknown(state_q);\nendproperty\nassert property (no_invalid_state_p);', 'lifecycle_disable_p': 'property lifecycle_disable_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  !en_i |-> ##[1:2] (state_q == StCtrlWipe || state_q == StCtrlInvalid);\nendproperty\nassert property (lifecycle_disable_p);', 'fault_response_p': 'property fault_response_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  |fault_o |-> ##[1:3] (state_q == StCtrlWipe || state_q == StCtrlInvalid);\nendproperty\nassert property (fault_response_p);'}, 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01Cmjq1HQo5hcisWjHe8jbmx)
 Call ID: toolu_01Cmjq1HQo5hcisWjHe8jbmx
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_ctrl.sv
    top_module: keymgr_ctrl
    assertions: {'illegal_state_transition_p': 'property illegal_state_transition_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (state_q != StCtrlWipe && state_q != StCtrlInvalid) && inv_state |-> ##1 (state_q == StCtrlWipe);\nendproperty\nassert property (illegal_state_transition_p);', 'privilege_escalation_p': 'property privilege_escalation_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (state_q == StCtrlReset) && op_start_i && !advance_sel |-> ##1 (state_q != StCtrlCreatorRootKey && state_q != StCtrlOwnerIntKey && state_q != StCtrlOwnerKey);\nendproperty\nassert property (privilege_escalation_p);', 'fsm_integrity_p': 'property fsm_integrity_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  state_intg_err_q |-> ##1 (state_q == StCtrlWipe);\nendproperty\nassert property (fsm_integrity_p);', 'no_invalid_state_p': 'property no_invalid_state_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  !$isunknown(state_q);\nendproperty\nassert property (no_invalid_state_p);', 'lifecycle_disable_p': 'property lifecycle_disable_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  !en_i |-> ##[1:2] (state_q == StCtrlWipe || state_q == StCtrlInvalid);\nendproperty\nassert property (lifecycle_disable_p);', 'fault_response_p': 'property fault_response_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  |fault_o |-> ##[1:3] (state_q == StCtrlWipe || state_q == StCtrlInvalid);\nendproperty\nassert property (fault_response_p);'}
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: assertion_checker_tool

Failed to execute. Error: KeyError('unnamed$$_75')
KeyError: 'unnamed$$_75'
Traceback (most recent call last):
  File "/home/XXXX-2/security_agents/security_agents.py", line 763, in assertion_checker_tool
    falsified_properties[name] = assertions[name]
                               ~~~~~~~~~~^^^^^^
KeyError: 'unnamed$$_75'
================================== Ai Message ==================================

[{'text': 'I apologize for the error. Let me try again with more carefully formatted assertions:', 'type': 'text'}, {'id': 'toolu_012U64codPy9ZodUJ4Md7gK6', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_ctrl.sv', 'top_module': 'keymgr_ctrl', 'assertions': {'illegal_state_transition_p': 'property illegal_state_transition_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (state_q != StCtrlWipe && state_q != StCtrlInvalid) && inv_state |-> ##1 (state_q == StCtrlWipe);\nendproperty\nassert property (illegal_state_transition_p);', 'privilege_escalation_p': 'property privilege_escalation_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (state_q == StCtrlReset) && op_start_i && !advance_sel |-> ##1 (state_q != StCtrlCreatorRootKey && state_q != StCtrlOwnerIntKey && state_q != StCtrlOwnerKey);\nendproperty\nassert property (privilege_escalation_p);', 'fsm_integrity_p': 'property fsm_integrity_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  state_intg_err_q |-> ##1 (state_q == StCtrlWipe);\nendproperty\nassert property (fsm_integrity_p);', 'lifecycle_disable_p': 'property lifecycle_disable_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  !en_i |-> ##[1:2] (state_q == StCtrlWipe || state_q == StCtrlInvalid);\nendproperty\nassert property (lifecycle_disable_p);'}, 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_012U64codPy9ZodUJ4Md7gK6)
 Call ID: toolu_012U64codPy9ZodUJ4Md7gK6
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_ctrl.sv
    top_module: keymgr_ctrl
    assertions: {'illegal_state_transition_p': 'property illegal_state_transition_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (state_q != StCtrlWipe && state_q != StCtrlInvalid) && inv_state |-> ##1 (state_q == StCtrlWipe);\nendproperty\nassert property (illegal_state_transition_p);', 'privilege_escalation_p': 'property privilege_escalation_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (state_q == StCtrlReset) && op_start_i && !advance_sel |-> ##1 (state_q != StCtrlCreatorRootKey && state_q != StCtrlOwnerIntKey && state_q != StCtrlOwnerKey);\nendproperty\nassert property (privilege_escalation_p);', 'fsm_integrity_p': 'property fsm_integrity_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  state_intg_err_q |-> ##1 (state_q == StCtrlWipe);\nendproperty\nassert property (fsm_integrity_p);', 'lifecycle_disable_p': 'property lifecycle_disable_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  !en_i |-> ##[1:2] (state_q == StCtrlWipe || state_q == StCtrlInvalid);\nendproperty\nassert property (lifecycle_disable_p);'}
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: assertion_checker_tool

Failed to execute. Error: KeyError('unnamed$$_75')
KeyError: 'unnamed$$_75'
Traceback (most recent call last):
  File "/home/XXXX-2/security_agents/security_agents.py", line 763, in assertion_checker_tool
    falsified_properties[name] = assertions[name]
                               ~~~~~~~~~~^^^^^^
KeyError: 'unnamed$$_75'
================================== Ai Message ==================================

[{'text': 'I apologize for the continued errors. Let me try with simpler assertions to identify the issue:', 'type': 'text'}, {'id': 'toolu_01J75y7KE1o8k2t6NT8TENQN', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_ctrl.sv', 'top_module': 'keymgr_ctrl', 'assertions': {'state_transition_p': 'property state_transition_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  inv_state |-> ##1 (state_q == StCtrlWipe);\nendproperty\nassert property (state_transition_p);'}, 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01J75y7KE1o8k2t6NT8TENQN)
 Call ID: toolu_01J75y7KE1o8k2t6NT8TENQN
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_ctrl.sv
    top_module: keymgr_ctrl
    assertions: {'state_transition_p': 'property state_transition_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  inv_state |-> ##1 (state_q == StCtrlWipe);\nendproperty\nassert property (state_transition_p);'}
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: assertion_checker_tool

Failed to execute. Error: KeyError('unnamed$$_75')
KeyError: 'unnamed$$_75'
Traceback (most recent call last):
  File "/home/XXXX-2/security_agents/security_agents.py", line 763, in assertion_checker_tool
    falsified_properties[name] = assertions[name]
                               ~~~~~~~~~~^^^^^^
KeyError: 'unnamed$$_75'
================================== Ai Message ==================================

[{'text': 'I apologize for the persistent error. Let me try a different approach with a very basic assertion:', 'type': 'text'}, {'id': 'toolu_01NbsS4D7zQbuUyPYiK2mKGr', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_ctrl.sv', 'top_module': 'keymgr_ctrl', 'assertions': {'basic_assertion': 'property basic_assertion;\n  @(posedge clk_i)\n  1;\nendproperty\nassert property (basic_assertion);'}, 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01NbsS4D7zQbuUyPYiK2mKGr)
 Call ID: toolu_01NbsS4D7zQbuUyPYiK2mKGr
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_ctrl.sv
    top_module: keymgr_ctrl
    assertions: {'basic_assertion': 'property basic_assertion;\n  @(posedge clk_i)\n  1;\nendproperty\nassert property (basic_assertion);'}
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: run_assertions_checker_agent

[{"text": "I apologize for the persistent error. Let me try a different approach with a very basic assertion:", "type": "text"}, {"id": "toolu_01NbsS4D7zQbuUyPYiK2mKGr", "input": {"design_filepath": "/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_ctrl.sv", "top_module": "keymgr_ctrl", "assertions": {"basic_assertion": "property basic_assertion;\n  @(posedge clk_i)\n  1;\nendproperty\nassert property (basic_assertion);"}, "clock_signal": "clk_i", "reset_signal": "rst_ni", "reset_active": "low"}, "name": "assertion_checker_tool", "type": "tool_use"}]
================================== Ai Message ==================================
Tool Calls:
  run_assertions_checker_agent (call_FhFEbZRxuE8OUt0BP0sBcADN)
 Call ID: call_FhFEbZRxuE8OUt0BP0sBcADN
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv
    top_module: keymgr_kmac_if
    security_objective: masking enforcement, data leakage, privilege escalation
================================ Human Message =================================

Are there security concerns related to masking enforcement, data leakage, privilege escalation in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv

    And the top module is:

    keymgr_kmac_if

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Key manager interface to kmac
//

`include "prim_assert.sv"

module keymgr_kmac_if
  import keymgr_pkg::*;
#(
  parameter rand_perm_t RndCnstRandPerm = RndCnstRandPermDefault
) (
  input clk_i,
  input rst_ni,

  // data input interfaces
  input [AdvDataWidth-1:0] adv_data_i,
  input [IdDataWidth-1:0] id_data_i,
  input [GenDataWidth-1:0] gen_data_i,
  input [3:0] inputs_invalid_i,
  output logic inputs_invalid_o,

  // keymgr control to select appropriate inputs
  input adv_en_i,
  input id_en_i,
  input gen_en_i,
  output logic done_o,
  output logic [Shares-1:0][kmac_pkg::AppDigestW-1:0] data_o,

  // actual connection to kmac
  output kmac_pkg::app_req_t kmac_data_o,
  input  kmac_pkg::app_rsp_t kmac_data_i,

  // entropy input
  output logic prng_en_o,
  input [Shares-1:0][RandWidth-1:0] entropy_i,

  // error outputs
  output logic fsm_error_o,
  output logic kmac_error_o,
  output logic kmac_done_error_o,
  output logic cmd_error_o
);


  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 5 -m 6 -n 10 \
  //      -s 2292624416 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: --
  //  4: --
  //  5: |||||||||||||||||||| (46.67%)
  //  6: ||||||||||||||||| (40.00%)
  //  7: ||||| (13.33%)
  //  8: --
  //  9: --
  // 10: --
  //
  // Minimum Hamming distance: 5
  // Maximum Hamming distance: 7
  // Minimum Hamming weight: 2
  // Maximum Hamming weight: 9
  //
  localparam int StateWidth = 10;
  typedef enum logic [StateWidth-1:0] {
    StIdle    = 10'b1110100010,
    StTx      = 10'b0010011011,
    StTxLast  = 10'b0101000000,
    StOpWait  = 10'b1000101001,
    StClean   = 10'b1111111101,
    StError   = 10'b0011101110
  } data_state_e;

  localparam int AdvRem = AdvDataWidth % KmacDataIfWidth;
  localparam int IdRem  = IdDataWidth  % KmacDataIfWidth;
  localparam int GenRem = GenDataWidth % KmacDataIfWidth;

  // the remainder must be in number of bytes
  `ASSERT_INIT(AdvRemBytes_A, AdvRem % 8 == 0)
  `ASSERT_INIT(IdRemBytes_A,  IdRem  % 8 == 0)
  `ASSERT_INIT(GenRemBytes_A, GenRem % 8 == 0)

  // Number of kmac transactions required
  localparam int AdvRounds = (AdvDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
  localparam int IdRounds  = (IdDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
  localparam int GenRounds = (GenDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
  localparam int MaxRounds = KDFMaxWidth  / KmacDataIfWidth;

  // calculated parameters for number of roudns and interface width
  localparam int CntWidth = $clog2(MaxRounds);
  localparam int IfBytes = KmacDataIfWidth / 8;
  localparam int DecoyCopies = KmacDataIfWidth / RandWidth;
  localparam int DecoyOutputCopies = (kmac_pkg::AppDigestW / RandWidth);

  localparam int unsigned LastAdvRoundInt = AdvRounds - 1;
  localparam int unsigned LastIdRoundInt = IdRounds - 1;
  localparam int unsigned LastGenRoundInt = GenRounds - 1;
  localparam bit [CntWidth-1:0] LastAdvRound = LastAdvRoundInt[CntWidth-1:0];
  localparam bit [CntWidth-1:0] LastIdRound = LastIdRoundInt[CntWidth-1:0];
  localparam bit [CntWidth-1:0] LastGenRound = LastGenRoundInt[CntWidth-1:0];

  // byte mask for the last transfer
  localparam logic [IfBytes-1:0] AdvByteMask = (AdvRem > 0) ? (2**(AdvRem/8)-1) : {IfBytes{1'b1}};
  localparam logic [IfBytes-1:0] IdByteMask  = (IdRem > 0)  ? (2**(IdRem/8)-1)  : {IfBytes{1'b1}};
  localparam logic [IfBytes-1:0] GenByteMask = (GenRem > 0) ? (2**(GenRem/8)-1) : {IfBytes{1'b1}};

  logic [MaxRounds-1:0][KmacDataIfWidth-1:0] adv_data;
  logic [MaxRounds-1:0][KmacDataIfWidth-1:0] id_data;
  logic [MaxRounds-1:0][KmacDataIfWidth-1:0] gen_data;
  logic [CntWidth-1:0] cnt;
  logic [CntWidth-1:0] rounds;
  logic [KmacDataIfWidth-1:0] decoy_data;
  logic valid;
  logic last;
  logic [IfBytes-1:0] strb;
  logic cnt_clr, cnt_set, cnt_en;
  logic start;
  logic [3:0] inputs_invalid_d, inputs_invalid_q;
  logic clr_err;
  logic kmac_done_vld;
  logic cmd_chk;

  data_state_e state_q, state_d;

  // 0 pad to the appropriate width
  // this is basically for scenarios where *DataWidth % KmacDataIfWidth != 0
  assign adv_data = KDFMaxWidth'(adv_data_i);
  assign id_data  = KDFMaxWidth'(id_data_i);
  assign gen_data = KDFMaxWidth'(gen_data_i);

  assign start = adv_en_i | id_en_i | gen_en_i;

  logic cnt_err;
  // SEC_CM: KMAC_IF.CTR.REDUN
  prim_count #(
    .Width(CntWidth),
    .ResetValue({CntWidth{1'b1}})
  ) u_cnt (
    .clk_i,
    .rst_ni,
    .clr_i(cnt_clr),
    .set_i(cnt_set),
    .set_cnt_i(rounds),
    .incr_en_i(1'b0),
    .decr_en_i(cnt_en),
    .step_i(CntWidth'(1'b1)),
    .commit_i(1'b1),
    .cnt_o(cnt),
    .cnt_after_commit_o(),
    .err_o(cnt_err)
  );

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      inputs_invalid_q <= '0;
    end else begin
      inputs_invalid_q <= inputs_invalid_d;
    end
   end

  // SEC_CM: KMAC_IF.FSM.SPARSE
  `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, data_state_e, StIdle)

  always_comb begin
    cnt_clr = 1'b0;
    cnt_set = 1'b0;
    cnt_en  = 1'b0;
    valid   = 1'b0;
    last    = 1'b0;
    strb    = '0;
    done_o  = 1'b0;
    state_d = state_q;
    rounds  = '0;

    clr_err = '0;
    fsm_error_o = '0;
    kmac_error_o = '0;

    kmac_done_vld = '0;

    cmd_chk = 1'b1;

    unique case (state_q)

      StIdle: begin
        // if for some reason multiple bits are set, adv_en has priority
        // as the current key state will be destroyed

        // cross check for commands once transaction begins
        cmd_chk = '0;
        if (start) begin
          cnt_set = 1'b1;
          if (adv_en_i) begin
            rounds = LastAdvRound;
          end else if (id_en_i) begin
            rounds = LastIdRound;
          end else if (gen_en_i) begin
            rounds = LastGenRound;
          end
          // in case we are sending only 1 entry
          state_d = (rounds == 0) ? StTxLast : StTx;
        end
      end

      StTx: begin
        valid = 1'b1;
        strb = {IfBytes{1'b1}};

        // transaction accepted
        if (kmac_data_i.ready) begin
          cnt_en = 1'b1;

          // second to last beat
          if (cnt == CntWidth'(1'b1)) begin
            state_d = StTxLast;
          end
        end

      end

      StTxLast: begin
        valid = 1'b1;
        last = 1'b1;

        if (adv_en_i) begin
          strb = AdvByteMask;
        end else if (id_en_i) begin
          strb = IdByteMask;
        end else if (gen_en_i) begin
          strb = GenByteMask;
        end

        // transaction accepted
        cnt_clr = kmac_data_i.ready;
        state_d = kmac_data_i.ready ? StOpWait : StTxLast;

      end

      StOpWait: begin
        kmac_done_vld = 1'b1;
        if (kmac_data_i.done) begin
          kmac_error_o = kmac_data_i.error;
          done_o = 1'b1;
          state_d = StClean;
        end
      end

      StClean: begin
        cmd_chk = '0;
        done_o = 1'b1;

        // wait for control side to ack done by waiting start de-assertion
        if (!start) begin
          done_o = 1'b0;
          clr_err = 1'b1;
          state_d = StIdle;
        end
      end

      // trigger error
      default: begin
        // This state is terminal
        done_o = 1'b1;
        fsm_error_o = 1'b1;
      end

    endcase // unique case (state_q)

    // unconditional error transitions
    // counter errors may disturb the fsm flow and are
    // treated like fsm errors
    if (cnt_err) begin
      state_d = StError;
      fsm_error_o = 1;
      done_o = 1'b1;
    end
  end

  // when transaction is not complete, populate the data with random
  assign data_o = start && done_o ?
                  {kmac_data_i.digest_share1,
                   kmac_data_i.digest_share0} :
                  {{DecoyOutputCopies{entropy_i[1]}},
                   {DecoyOutputCopies{entropy_i[0]}}};

  // The input invalid check is done whenever transactions are ongoing with kmac
  // once set, it cannot be unset until transactions are fully complete
  always_comb begin
    inputs_invalid_d = inputs_invalid_q;

    if (clr_err) begin
      inputs_invalid_d = '0;
    end else if (valid) begin
      inputs_invalid_d[OpAdvance]  = adv_en_i & (inputs_invalid_i[OpAdvance] |
                                                 inputs_invalid_q[OpAdvance]);
      inputs_invalid_d[OpGenId]    = id_en_i  & (inputs_invalid_i[OpGenId]   |
                                                 inputs_invalid_q[OpGenId]);
      inputs_invalid_d[OpGenSwOut] = gen_en_i & (inputs_invalid_i[OpGenSwOut]|
                                                 inputs_invalid_q[OpGenSwOut]);
      inputs_invalid_d[OpGenHwOut] = gen_en_i & (inputs_invalid_i[OpGenHwOut]|
                                                 inputs_invalid_q[OpGenHwOut]);
    end
  end

  // immediately assert errors
  assign inputs_invalid_o = |inputs_invalid_d;

  // Permute Share 1 of the entropy input once more to get the decoy data.
  // Share 0 and 1 are used as is for data_o (connected to the sideload ports).
  logic [RandWidth-1:0] decoy_entropy;
  assign decoy_entropy = perm_data(entropy_i[1], RndCnstRandPerm);
  assign decoy_data = {DecoyCopies{decoy_entropy}};

  logic [CntWidth-1:0] adv_sel, id_sel, gen_sel;
  assign adv_sel = LastAdvRound - cnt;
  assign id_sel = LastIdRound - cnt;
  assign gen_sel = LastGenRound - cnt;

  // The count is maintained as a downcount
  // so a subtract is necessary to send the right byte
  // alternatively we can also reverse the order of the input
  always_comb begin
    kmac_data_o.data  = decoy_data;
    if (|cmd_error_o || inputs_invalid_o || fsm_error_o) begin
      kmac_data_o.data  = decoy_data;
    end else if (valid && adv_en_i) begin
      kmac_data_o.data  = adv_data[adv_sel];
    end else if (valid && id_en_i) begin
      kmac_data_o.data  = id_data[id_sel];
    end else if (valid && gen_en_i) begin
      kmac_data_o.data  = gen_data[gen_sel];
    end
  end

  assign kmac_data_o.valid = valid;
  assign kmac_data_o.last  = last;
  assign kmac_data_o.strb  = strb;

  // kmac done is asserted outside of expected window
  // SEC_CM: KMAC_IF_DONE.CTRL.CONSISTENCY
  logic kmac_done_err_q, kmac_done_err_d;
  assign kmac_done_err_d = ~kmac_done_vld & kmac_data_i.done |
                           kmac_done_err_q;
  assign kmac_done_error_o = kmac_done_err_q;


  // the enables must be 1 hot
  logic [2:0] enables_d, enables_q, enables_sub;
  assign enables_d = {adv_en_i, id_en_i, gen_en_i};
  assign enables_sub = enables_d - 1'b1;

  // cross check to ensure the one-hot command that kicked off
  // the transaction remains consistent throughout.
  logic cmd_consty_err_q, cmd_consty_err_d;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      enables_q <= '0;
    end else if (cnt_set) begin
      enables_q <= enables_d;
    end
  end
  assign cmd_consty_err_d = (cmd_chk & (enables_q != enables_d)) |
                            cmd_consty_err_q;

  // if a one hot error occurs, latch onto it permanently
  // SEC_CM: KMAC_IF_CMD.CTRL.CONSISTENCY
  logic one_hot_err_q, one_hot_err_d;
  assign one_hot_err_d = |(enables_d & enables_sub) |
                         one_hot_err_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      one_hot_err_q <= '0;
      kmac_done_err_q <= '0;
      cmd_consty_err_q <= '0;
    end else begin
      one_hot_err_q <= one_hot_err_d;
      kmac_done_err_q <= kmac_done_err_d;
      cmd_consty_err_q <= cmd_consty_err_d;
    end
  end

  // command error occurs if kmac errors or if the command itself is invalid
  assign cmd_error_o = one_hot_err_q | cmd_consty_err_q;

  // request entropy to churn whenever a transaction is accepted
  assign prng_en_o = kmac_data_o.valid & kmac_data_i.ready;

  // as long as we are transmitting, the strobe should never be 0.
  `ASSERT(LastStrb_A, valid |-> strb != '0)


endmodule // keymgr_kmac_if

    '''

    Form relevant system verilog assertions for the RTL to be checked for.
    These system verilog assertions should be in a dict with the key as the name and the value as the assertion string.
    An example assertions object to be sent to assertion checker tool is as follows:

    assertions = {"assertion_p1":"property p1;\n    @(posedge clk) signal_A |-> signal_B;\nendproperty
assertion_p1: assert property (p1);", "assertion_p2":"property p2;\n    @(posedge clk) conditions |-> signal_C;\nendproperty\nassertion_p2: assert property (p2);"}

    Then run the assertions using the assertion checker tool. This tool call must include the assertions dictionary as an argument.
    From the output of the assertion checker tool, determine if there are security issues in the RTL.
    If there are no falsified assertions in the output from the assertion checker tool, that means there are no verified security issues in the RTL.

    
================================== Ai Message ==================================

[{'text': "I'll help you analyze the `keymgr_kmac_if` module for security concerns related to masking enforcement, data leakage, and privilege escalation. Let me create relevant assertions to check for these security issues.\n\nBased on the RTL code, I'll focus on:\n1. Masking enforcement - checking if sensitive data is properly masked\n2. Data leakage - verifying that decoy data is used when appropriate\n3. Command validation - ensuring commands are properly validated\n4. Error handling - checking if errors are properly detected and handled\n\nLet me create assertions and run the assertion checker tool:", 'type': 'text'}, {'id': 'toolu_01C16n8azSXXLmu317qLtpgh', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv', 'top_module': 'keymgr_kmac_if', 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01C16n8azSXXLmu317qLtpgh)
 Call ID: toolu_01C16n8azSXXLmu317qLtpgh
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv
    top_module: keymgr_kmac_if
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: assertion_checker_tool

Error: 1 validation error for assertion_checker_tool
assertions
  Field required [type=missing, input_value={'design_filepath': '/hom..., 'reset_active': 'low'}, input_type=dict]
    For further information visit XXXX
 Please fix your mistakes.
================================== Ai Message ==================================

[{'text': 'I need to include assertions in my tool call. Let me create relevant assertions for security concerns and run the tool again:', 'type': 'text'}, {'id': 'toolu_01QG4pcYcZiLPAmS14YoSAFP', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv', 'top_module': 'keymgr_kmac_if', 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low', 'assertions': {'masking_enforcement_p1': 'property masking_enforcement_p1;\n    @(posedge clk_i) (start && done_o) |-> (data_o[0] != data_o[1]);\nendproperty\nassertion_masking_enforcement_p1: assert property (masking_enforcement_p1);', 'data_leakage_p1': 'property data_leakage_p1;\n    @(posedge clk_i) (!start || inputs_invalid_o || fsm_error_o || cmd_error_o) |-> (kmac_data_o.data == decoy_data);\nendproperty\nassertion_data_leakage_p1: assert property (data_leakage_p1);', 'cmd_validation_p1': 'property cmd_validation_p1;\n    @(posedge clk_i) (adv_en_i && id_en_i) || (adv_en_i && gen_en_i) || (id_en_i && gen_en_i) |-> ##[0:2] cmd_error_o;\nendproperty\nassertion_cmd_validation_p1: assert property (cmd_validation_p1);', 'error_handling_p1': 'property error_handling_p1;\n    @(posedge clk_i) cnt_err |-> ##[0:2] fsm_error_o;\nendproperty\nassertion_error_handling_p1: assert property (error_handling_p1);', 'decoy_data_p1': 'property decoy_data_p1;\n    @(posedge clk_i) !start |-> (data_o == {{DecoyOutputCopies{entropy_i[1]}}, {DecoyOutputCopies{entropy_i[0]}}});\nendproperty\nassertion_decoy_data_p1: assert property (decoy_data_p1);'}}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01QG4pcYcZiLPAmS14YoSAFP)
 Call ID: toolu_01QG4pcYcZiLPAmS14YoSAFP
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv
    top_module: keymgr_kmac_if
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
    assertions: {'masking_enforcement_p1': 'property masking_enforcement_p1;\n    @(posedge clk_i) (start && done_o) |-> (data_o[0] != data_o[1]);\nendproperty\nassertion_masking_enforcement_p1: assert property (masking_enforcement_p1);', 'data_leakage_p1': 'property data_leakage_p1;\n    @(posedge clk_i) (!start || inputs_invalid_o || fsm_error_o || cmd_error_o) |-> (kmac_data_o.data == decoy_data);\nendproperty\nassertion_data_leakage_p1: assert property (data_leakage_p1);', 'cmd_validation_p1': 'property cmd_validation_p1;\n    @(posedge clk_i) (adv_en_i && id_en_i) || (adv_en_i && gen_en_i) || (id_en_i && gen_en_i) |-> ##[0:2] cmd_error_o;\nendproperty\nassertion_cmd_validation_p1: assert property (cmd_validation_p1);', 'error_handling_p1': 'property error_handling_p1;\n    @(posedge clk_i) cnt_err |-> ##[0:2] fsm_error_o;\nendproperty\nassertion_error_handling_p1: assert property (error_handling_p1);', 'decoy_data_p1': 'property decoy_data_p1;\n    @(posedge clk_i) !start |-> (data_o == {{DecoyOutputCopies{entropy_i[1]}}, {DecoyOutputCopies{entropy_i[0]}}});\nendproperty\nassertion_decoy_data_p1: assert property (decoy_data_p1);'}
================================= Tool Message =================================
Name: assertion_checker_tool

Failed to execute. Error: KeyError('assertion_masking_enforcement_p1')
KeyError: 'assertion_masking_enforcement_p1'
Traceback (most recent call last):
  File "/home/XXXX-2/security_agents/security_agents.py", line 763, in assertion_checker_tool
    falsified_properties[name] = assertions[name]
                               ~~~~~~~~~~^^^^^^
KeyError: 'assertion_masking_enforcement_p1'
================================== Ai Message ==================================

[{'text': 'I need to fix the assertion names to match the property names. Let me correct this and run the tool again:', 'type': 'text'}, {'id': 'toolu_01Dw7LTNbH2ETQDMLZv9FF3e', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv', 'top_module': 'keymgr_kmac_if', 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low', 'assertions': {'masking_enforcement_p1': 'property masking_enforcement_p1;\n    @(posedge clk_i) (start && done_o) |-> (data_o[0] != data_o[1]);\nendproperty\nmasking_enforcement_p1: assert property (masking_enforcement_p1);', 'data_leakage_p1': 'property data_leakage_p1;\n    @(posedge clk_i) (!start || inputs_invalid_o || fsm_error_o || cmd_error_o) |-> (kmac_data_o.data == decoy_data);\nendproperty\ndata_leakage_p1: assert property (data_leakage_p1);', 'cmd_validation_p1': 'property cmd_validation_p1;\n    @(posedge clk_i) (adv_en_i && id_en_i) || (adv_en_i && gen_en_i) || (id_en_i && gen_en_i) |-> ##[0:2] cmd_error_o;\nendproperty\ncmd_validation_p1: assert property (cmd_validation_p1);', 'error_handling_p1': 'property error_handling_p1;\n    @(posedge clk_i) cnt_err |-> ##[0:2] fsm_error_o;\nendproperty\nerror_handling_p1: assert property (error_handling_p1);', 'decoy_data_p1': 'property decoy_data_p1;\n    @(posedge clk_i) !start |-> (data_o == {{DecoyOutputCopies{entropy_i[1]}}, {DecoyOutputCopies{entropy_i[0]}}});\nendproperty\ndecoy_data_p1: assert property (decoy_data_p1);'}}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01Dw7LTNbH2ETQDMLZv9FF3e)
 Call ID: toolu_01Dw7LTNbH2ETQDMLZv9FF3e
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv
    top_module: keymgr_kmac_if
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
    assertions: {'masking_enforcement_p1': 'property masking_enforcement_p1;\n    @(posedge clk_i) (start && done_o) |-> (data_o[0] != data_o[1]);\nendproperty\nmasking_enforcement_p1: assert property (masking_enforcement_p1);', 'data_leakage_p1': 'property data_leakage_p1;\n    @(posedge clk_i) (!start || inputs_invalid_o || fsm_error_o || cmd_error_o) |-> (kmac_data_o.data == decoy_data);\nendproperty\ndata_leakage_p1: assert property (data_leakage_p1);', 'cmd_validation_p1': 'property cmd_validation_p1;\n    @(posedge clk_i) (adv_en_i && id_en_i) || (adv_en_i && gen_en_i) || (id_en_i && gen_en_i) |-> ##[0:2] cmd_error_o;\nendproperty\ncmd_validation_p1: assert property (cmd_validation_p1);', 'error_handling_p1': 'property error_handling_p1;\n    @(posedge clk_i) cnt_err |-> ##[0:2] fsm_error_o;\nendproperty\nerror_handling_p1: assert property (error_handling_p1);', 'decoy_data_p1': 'property decoy_data_p1;\n    @(posedge clk_i) !start |-> (data_o == {{DecoyOutputCopies{entropy_i[1]}}, {DecoyOutputCopies{entropy_i[0]}}});\nendproperty\ndecoy_data_p1: assert property (decoy_data_p1);'}
================================= Tool Message =================================
Name: assertion_checker_tool

Failed to execute. Error: KeyError('assertion_masking_enforcement_p1')
KeyError: 'assertion_masking_enforcement_p1'
Traceback (most recent call last):
  File "/home/XXXX-2/security_agents/security_agents.py", line 763, in assertion_checker_tool
    falsified_properties[name] = assertions[name]
                               ~~~~~~~~~~^^^^^^
KeyError: 'assertion_masking_enforcement_p1'
================================== Ai Message ==================================

[{'text': 'Let me simplify the assertions and try again:', 'type': 'text'}, {'id': 'toolu_01CPFALyMmsKUH7odj1K8MhV', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv', 'top_module': 'keymgr_kmac_if', 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low', 'assertions': {'masking_check': 'property masking_check;\n    @(posedge clk_i) (start && done_o) |-> (data_o[0] != data_o[1]);\nendproperty\nmasking_check: assert property (masking_check);', 'decoy_data_check': 'property decoy_data_check;\n    @(posedge clk_i) (inputs_invalid_o || fsm_error_o || cmd_error_o) |-> (kmac_data_o.data == decoy_data);\nendproperty\ndecoy_data_check: assert property (decoy_data_check);', 'cmd_onehot_check': 'property cmd_onehot_check;\n    @(posedge clk_i) (adv_en_i + id_en_i + gen_en_i) > 1 |-> ##[0:2] cmd_error_o;\nendproperty\ncmd_onehot_check: assert property (cmd_onehot_check);', 'error_propagation': 'property error_propagation;\n    @(posedge clk_i) cnt_err |-> ##[0:2] fsm_error_o;\nendproperty\nerror_propagation: assert property (error_propagation);'}}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01CPFALyMmsKUH7odj1K8MhV)
 Call ID: toolu_01CPFALyMmsKUH7odj1K8MhV
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv
    top_module: keymgr_kmac_if
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
    assertions: {'masking_check': 'property masking_check;\n    @(posedge clk_i) (start && done_o) |-> (data_o[0] != data_o[1]);\nendproperty\nmasking_check: assert property (masking_check);', 'decoy_data_check': 'property decoy_data_check;\n    @(posedge clk_i) (inputs_invalid_o || fsm_error_o || cmd_error_o) |-> (kmac_data_o.data == decoy_data);\nendproperty\ndecoy_data_check: assert property (decoy_data_check);', 'cmd_onehot_check': 'property cmd_onehot_check;\n    @(posedge clk_i) (adv_en_i + id_en_i + gen_en_i) > 1 |-> ##[0:2] cmd_error_o;\nendproperty\ncmd_onehot_check: assert property (cmd_onehot_check);', 'error_propagation': 'property error_propagation;\n    @(posedge clk_i) cnt_err |-> ##[0:2] fsm_error_o;\nendproperty\nerror_propagation: assert property (error_propagation);'}
================================= Tool Message =================================
Name: run_assertions_checker_agent

[{"text": "Let me simplify the assertions and try again:", "type": "text"}, {"id": "toolu_01CPFALyMmsKUH7odj1K8MhV", "input": {"design_filepath": "/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv", "top_module": "keymgr_kmac_if", "clock_signal": "clk_i", "reset_signal": "rst_ni", "reset_active": "low", "assertions": {"masking_check": "property masking_check;\n    @(posedge clk_i) (start && done_o) |-> (data_o[0] != data_o[1]);\nendproperty\nmasking_check: assert property (masking_check);", "decoy_data_check": "property decoy_data_check;\n    @(posedge clk_i) (inputs_invalid_o || fsm_error_o || cmd_error_o) |-> (kmac_data_o.data == decoy_data);\nendproperty\ndecoy_data_check: assert property (decoy_data_check);", "cmd_onehot_check": "property cmd_onehot_check;\n    @(posedge clk_i) (adv_en_i + id_en_i + gen_en_i) > 1 |-> ##[0:2] cmd_error_o;\nendproperty\ncmd_onehot_check: assert property (cmd_onehot_check);", "error_propagation": "property error_propagation;\n    @(posedge clk_i) cnt_err |-> ##[0:2] fsm_error_o;\nendproperty\nerror_propagation: assert property (error_propagation);"}}, "name": "assertion_checker_tool", "type": "tool_use"}]
================================== Ai Message ==================================
Tool Calls:
  run_anomaly_detector_agent (call_KmsegCZqy4RM09EqVLU3MXdL)
 Call ID: call_KmsegCZqy4RM09EqVLU3MXdL
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv
    top_module: keymgr_reg_top
    security_objective: register interface, privilege escalation, shadow register anomalies
================================ Human Message =================================

Are there security concerns related to register interface, privilege escalation, shadow register anomalies in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Register Top module auto-generated by `reggen`

`include "prim_assert.sv"

module keymgr_reg_top (
  input clk_i,
  input rst_ni,
  input rst_shadowed_ni,
  input  tlul_pkg::tl_h2d_t tl_i,
  output tlul_pkg::tl_d2h_t tl_o,
  // To HW
  output keymgr_reg_pkg::keymgr_reg2hw_t reg2hw, // Write
  input  keymgr_reg_pkg::keymgr_hw2reg_t hw2reg, // Read

  output logic shadowed_storage_err_o,
  output logic shadowed_update_err_o,

  // Integrity check errors
  output logic intg_err_o
);

  import keymgr_reg_pkg::* ;

  localparam int AW = 8;
  localparam int DW = 32;
  localparam int DBW = DW/8;                    // Byte Width

  // register signals
  logic           reg_we;
  logic           reg_re;
  logic [AW-1:0]  reg_addr;
  logic [DW-1:0]  reg_wdata;
  logic [DBW-1:0] reg_be;
  logic [DW-1:0]  reg_rdata;
  logic           reg_error;

  logic          addrmiss, wr_err;

  logic [DW-1:0] reg_rdata_next;
  logic reg_busy;

  tlul_pkg::tl_h2d_t tl_reg_h2d;
  tlul_pkg::tl_d2h_t tl_reg_d2h;


  // incoming payload check
  logic intg_err;
  tlul_cmd_intg_chk u_chk (
    .tl_i(tl_i),
    .err_o(intg_err)
  );

  // also check for spurious write enables
  logic reg_we_err;
  logic [62:0] reg_we_check;
  prim_reg_we_check #(
    .OneHotWidth(63)
  ) u_prim_reg_we_check (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .oh_i  (reg_we_check),
    .en_i  (reg_we && !addrmiss),
    .err_o (reg_we_err)
  );

  logic err_q;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      err_q <= '0;
    end else if (intg_err || reg_we_err) begin
      err_q <= 1'b1;
    end
  end

  // integrity error output is permanent and should be used for alert generation
  // register errors are transactional
  assign intg_err_o = err_q | intg_err | reg_we_err;

  // outgoing integrity generation
  tlul_pkg::tl_d2h_t tl_o_pre;
  tlul_rsp_intg_gen #(
    .EnableRspIntgGen(1),
    .EnableDataIntgGen(1)
  ) u_rsp_intg_gen (
    .tl_i(tl_o_pre),
    .tl_o(tl_o)
  );

  assign tl_reg_h2d = tl_i;
  assign tl_o_pre   = tl_reg_d2h;

  tlul_adapter_reg #(
    .RegAw(AW),
    .RegDw(DW),
    .EnableDataIntgGen(0)
  ) u_reg_if (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),

    .tl_i (tl_reg_h2d),
    .tl_o (tl_reg_d2h),

    .en_ifetch_i(prim_mubi_pkg::MuBi4False),
    .intg_error_o(),

    .we_o    (reg_we),
    .re_o    (reg_re),
    .addr_o  (reg_addr),
    .wdata_o (reg_wdata),
    .be_o    (reg_be),
    .busy_i  (reg_busy),
    .rdata_i (reg_rdata),
    .error_i (reg_error)
  );

  // cdc oversampling signals

  assign reg_rdata = reg_rdata_next ;
  assign reg_error = addrmiss | wr_err | intg_err;

  // Define SW related signals
  // Format: <reg>_<field>_{wd|we|qs}
  //        or <reg>_{wd|we|qs} if field == 1 or 0
  logic intr_state_we;
  logic intr_state_qs;
  logic intr_state_wd;
  logic intr_enable_we;
  logic intr_enable_qs;
  logic intr_enable_wd;
  logic intr_test_we;
  logic intr_test_wd;
  logic alert_test_we;
  logic alert_test_recov_operation_err_wd;
  logic alert_test_fatal_fault_err_wd;
  logic cfg_regwen_re;
  logic cfg_regwen_qs;
  logic start_we;
  logic start_qs;
  logic start_wd;
  logic control_shadowed_re;
  logic control_shadowed_we;
  logic [2:0] control_shadowed_operation_qs;
  logic [2:0] control_shadowed_operation_wd;
  logic control_shadowed_operation_storage_err;
  logic control_shadowed_operation_update_err;
  logic control_shadowed_cdi_sel_qs;
  logic control_shadowed_cdi_sel_wd;
  logic control_shadowed_cdi_sel_storage_err;
  logic control_shadowed_cdi_sel_update_err;
  logic [1:0] control_shadowed_dest_sel_qs;
  logic [1:0] control_shadowed_dest_sel_wd;
  logic control_shadowed_dest_sel_storage_err;
  logic control_shadowed_dest_sel_update_err;
  logic sideload_clear_we;
  logic [2:0] sideload_clear_qs;
  logic [2:0] sideload_clear_wd;
  logic reseed_interval_regwen_we;
  logic reseed_interval_regwen_qs;
  logic reseed_interval_regwen_wd;
  logic reseed_interval_shadowed_re;
  logic reseed_interval_shadowed_we;
  logic [15:0] reseed_interval_shadowed_qs;
  logic [15:0] reseed_interval_shadowed_wd;
  logic reseed_interval_shadowed_storage_err;
  logic reseed_interval_shadowed_update_err;
  logic sw_binding_regwen_re;
  logic sw_binding_regwen_we;
  logic sw_binding_regwen_qs;
  logic sw_binding_regwen_wd;
  logic sealing_sw_binding_0_we;
  logic [31:0] sealing_sw_binding_0_qs;
  logic [31:0] sealing_sw_binding_0_wd;
  logic sealing_sw_binding_1_we;
  logic [31:0] sealing_sw_binding_1_qs;
  logic [31:0] sealing_sw_binding_1_wd;
  logic sealing_sw_binding_2_we;
  logic [31:0] sealing_sw_binding_2_qs;
  logic [31:0] sealing_sw_binding_2_wd;
  logic sealing_sw_binding_3_we;
  logic [31:0] sealing_sw_binding_3_qs;
  logic [31:0] sealing_sw_binding_3_wd;
  logic sealing_sw_binding_4_we;
  logic [31:0] sealing_sw_binding_4_qs;
  logic [31:0] sealing_sw_binding_4_wd;
  logic sealing_sw_binding_5_we;
  logic [31:0] sealing_sw_binding_5_qs;
  logic [31:0] sealing_sw_binding_5_wd;
  logic sealing_sw_binding_6_we;
  logic [31:0] sealing_sw_binding_6_qs;
  logic [31:0] sealing_sw_binding_6_wd;
  logic sealing_sw_binding_7_we;
  logic [31:0] sealing_sw_binding_7_qs;
  logic [31:0] sealing_sw_binding_7_wd;
  logic attest_sw_binding_0_we;
  logic [31:0] attest_sw_binding_0_qs;
  logic [31:0] attest_sw_binding_0_wd;
  logic attest_sw_binding_1_we;
  logic [31:0] attest_sw_binding_1_qs;
  logic [31:0] attest_sw_binding_1_wd;
  logic attest_sw_binding_2_we;
  logic [31:0] attest_sw_binding_2_qs;
  logic [31:0] attest_sw_binding_2_wd;
  logic attest_sw_binding_3_we;
  logic [31:0] attest_sw_binding_3_qs;
  logic [31:0] attest_sw_binding_3_wd;
  logic attest_sw_binding_4_we;
  logic [31:0] attest_sw_binding_4_qs;
  logic [31:0] attest_sw_binding_4_wd;
  logic attest_sw_binding_5_we;
  logic [31:0] attest_sw_binding_5_qs;
  logic [31:0] attest_sw_binding_5_wd;
  logic attest_sw_binding_6_we;
  logic [31:0] attest_sw_binding_6_qs;
  logic [31:0] attest_sw_binding_6_wd;
  logic attest_sw_binding_7_we;
  logic [31:0] attest_sw_binding_7_qs;
  logic [31:0] attest_sw_binding_7_wd;
  logic salt_0_we;
  logic [31:0] salt_0_qs;
  logic [31:0] salt_0_wd;
  logic salt_1_we;
  logic [31:0] salt_1_qs;
  logic [31:0] salt_1_wd;
  logic salt_2_we;
  logic [31:0] salt_2_qs;
  logic [31:0] salt_2_wd;
  logic salt_3_we;
  logic [31:0] salt_3_qs;
  logic [31:0] salt_3_wd;
  logic salt_4_we;
  logic [31:0] salt_4_qs;
  logic [31:0] salt_4_wd;
  logic salt_5_we;
  logic [31:0] salt_5_qs;
  logic [31:0] salt_5_wd;
  logic salt_6_we;
  logic [31:0] salt_6_qs;
  logic [31:0] salt_6_wd;
  logic salt_7_we;
  logic [31:0] salt_7_qs;
  logic [31:0] salt_7_wd;
  logic key_version_we;
  logic [31:0] key_version_qs;
  logic [31:0] key_version_wd;
  logic max_creator_key_ver_regwen_we;
  logic max_creator_key_ver_regwen_qs;
  logic max_creator_key_ver_regwen_wd;
  logic max_creator_key_ver_shadowed_re;
  logic max_creator_key_ver_shadowed_we;
  logic [31:0] max_creator_key_ver_shadowed_qs;
  logic [31:0] max_creator_key_ver_shadowed_wd;
  logic max_creator_key_ver_shadowed_storage_err;
  logic max_creator_key_ver_shadowed_update_err;
  logic max_owner_int_key_ver_regwen_we;
  logic max_owner_int_key_ver_regwen_qs;
  logic max_owner_int_key_ver_regwen_wd;
  logic max_owner_int_key_ver_shadowed_re;
  logic max_owner_int_key_ver_shadowed_we;
  logic [31:0] max_owner_int_key_ver_shadowed_qs;
  logic [31:0] max_owner_int_key_ver_shadowed_wd;
  logic max_owner_int_key_ver_shadowed_storage_err;
  logic max_owner_int_key_ver_shadowed_update_err;
  logic max_owner_key_ver_regwen_we;
  logic max_owner_key_ver_regwen_qs;
  logic max_owner_key_ver_regwen_wd;
  logic max_owner_key_ver_shadowed_re;
  logic max_owner_key_ver_shadowed_we;
  logic [31:0] max_owner_key_ver_shadowed_qs;
  logic [31:0] max_owner_key_ver_shadowed_wd;
  logic max_owner_key_ver_shadowed_storage_err;
  logic max_owner_key_ver_shadowed_update_err;
  logic sw_share0_output_0_re;
  logic [31:0] sw_share0_output_0_qs;
  logic [31:0] sw_share0_output_0_wd;
  logic sw_share0_output_1_re;
  logic [31:0] sw_share0_output_1_qs;
  logic [31:0] sw_share0_output_1_wd;
  logic sw_share0_output_2_re;
  logic [31:0] sw_share0_output_2_qs;
  logic [31:0] sw_share0_output_2_wd;
  logic sw_share0_output_3_re;
  logic [31:0] sw_share0_output_3_qs;
  logic [31:0] sw_share0_output_3_wd;
  logic sw_share0_output_4_re;
  logic [31:0] sw_share0_output_4_qs;
  logic [31:0] sw_share0_output_4_wd;
  logic sw_share0_output_5_re;
  logic [31:0] sw_share0_output_5_qs;
  logic [31:0] sw_share0_output_5_wd;
  logic sw_share0_output_6_re;
  logic [31:0] sw_share0_output_6_qs;
  logic [31:0] sw_share0_output_6_wd;
  logic sw_share0_output_7_re;
  logic [31:0] sw_share0_output_7_qs;
  logic [31:0] sw_share0_output_7_wd;
  logic sw_share1_output_0_re;
  logic [31:0] sw_share1_output_0_qs;
  logic [31:0] sw_share1_output_0_wd;
  logic sw_share1_output_1_re;
  logic [31:0] sw_share1_output_1_qs;
  logic [31:0] sw_share1_output_1_wd;
  logic sw_share1_output_2_re;
  logic [31:0] sw_share1_output_2_qs;
  logic [31:0] sw_share1_output_2_wd;
  logic sw_share1_output_3_re;
  logic [31:0] sw_share1_output_3_qs;
  logic [31:0] sw_share1_output_3_wd;
  logic sw_share1_output_4_re;
  logic [31:0] sw_share1_output_4_qs;
  logic [31:0] sw_share1_output_4_wd;
  logic sw_share1_output_5_re;
  logic [31:0] sw_share1_output_5_qs;
  logic [31:0] sw_share1_output_5_wd;
  logic sw_share1_output_6_re;
  logic [31:0] sw_share1_output_6_qs;
  logic [31:0] sw_share1_output_6_wd;
  logic sw_share1_output_7_re;
  logic [31:0] sw_share1_output_7_qs;
  logic [31:0] sw_share1_output_7_wd;
  logic [2:0] working_state_qs;
  logic op_status_we;
  logic [1:0] op_status_qs;
  logic [1:0] op_status_wd;
  logic err_code_we;
  logic err_code_invalid_op_qs;
  logic err_code_invalid_op_wd;
  logic err_code_invalid_kmac_input_qs;
  logic err_code_invalid_kmac_input_wd;
  logic err_code_invalid_shadow_update_qs;
  logic err_code_invalid_shadow_update_wd;
  logic fault_status_cmd_qs;
  logic fault_status_kmac_fsm_qs;
  logic fault_status_kmac_done_qs;
  logic fault_status_kmac_op_qs;
  logic fault_status_kmac_out_qs;
  logic fault_status_regfile_intg_qs;
  logic fault_status_shadow_qs;
  logic fault_status_ctrl_fsm_intg_qs;
  logic fault_status_ctrl_fsm_chk_qs;
  logic fault_status_ctrl_fsm_cnt_qs;
  logic fault_status_reseed_cnt_qs;
  logic fault_status_side_ctrl_fsm_qs;
  logic fault_status_side_ctrl_sel_qs;
  logic fault_status_key_ecc_qs;
  logic debug_we;
  logic debug_invalid_creator_seed_qs;
  logic debug_invalid_creator_seed_wd;
  logic debug_invalid_owner_seed_qs;
  logic debug_invalid_owner_seed_wd;
  logic debug_invalid_dev_id_qs;
  logic debug_invalid_dev_id_wd;
  logic debug_invalid_health_state_qs;
  logic debug_invalid_health_state_wd;
  logic debug_invalid_key_version_qs;
  logic debug_invalid_key_version_wd;
  logic debug_invalid_key_qs;
  logic debug_invalid_key_wd;
  logic debug_invalid_digest_qs;
  logic debug_invalid_digest_wd;

  // Register instances
  // R[intr_state]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.de),
    .d      (hw2reg.intr_state.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_qs)
  );


  // R[intr_enable]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_qs)
  );


  // R[intr_test]: V(True)
  logic intr_test_qe;
  logic [0:0] intr_test_flds_we;
  assign intr_test_qe = &intr_test_flds_we;
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[0]),
    .q      (reg2hw.intr_test.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.qe = intr_test_qe;


  // R[alert_test]: V(True)
  logic alert_test_qe;
  logic [1:0] alert_test_flds_we;
  assign alert_test_qe = &alert_test_flds_we;
  //   F[recov_operation_err]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_recov_operation_err (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_recov_operation_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[0]),
    .q      (reg2hw.alert_test.recov_operation_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.recov_operation_err.qe = alert_test_qe;

  //   F[fatal_fault_err]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_fatal_fault_err (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_fatal_fault_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[1]),
    .q      (reg2hw.alert_test.fatal_fault_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.fatal_fault_err.qe = alert_test_qe;


  // R[cfg_regwen]: V(True)
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_regwen (
    .re     (cfg_regwen_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.cfg_regwen.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (cfg_regwen_qs)
  );


  // R[start]: V(False)
  // Create REGWEN-gated WE signal
  logic start_gated_we;
  assign start_gated_we = start_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_start (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (start_gated_we),
    .wd     (start_wd),

    // from internal hardware
    .de     (hw2reg.start.de),
    .d      (hw2reg.start.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.start.q),
    .ds     (),

    // to register interface (read)
    .qs     (start_qs)
  );


  // R[control_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic control_shadowed_gated_we;
  assign control_shadowed_gated_we = control_shadowed_we & cfg_regwen_qs;
  //   F[operation]: 6:4
  prim_subreg_shadow #(
    .DW      (3),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (3'h1),
    .Mubi    (1'b0)
  ) u_control_shadowed_operation (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (control_shadowed_re),
    .we     (control_shadowed_gated_we),
    .wd     (control_shadowed_operation_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.control_shadowed.operation.q),
    .ds     (),

    // to register interface (read)
    .qs     (control_shadowed_operation_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (control_shadowed_operation_update_err),
    .err_storage (control_shadowed_operation_storage_err)
  );

  //   F[cdi_sel]: 7:7
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_control_shadowed_cdi_sel (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (control_shadowed_re),
    .we     (control_shadowed_gated_we),
    .wd     (control_shadowed_cdi_sel_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.control_shadowed.cdi_sel.q),
    .ds     (),

    // to register interface (read)
    .qs     (control_shadowed_cdi_sel_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (control_shadowed_cdi_sel_update_err),
    .err_storage (control_shadowed_cdi_sel_storage_err)
  );

  //   F[dest_sel]: 13:12
  prim_subreg_shadow #(
    .DW      (2),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (2'h0),
    .Mubi    (1'b0)
  ) u_control_shadowed_dest_sel (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (control_shadowed_re),
    .we     (control_shadowed_gated_we),
    .wd     (control_shadowed_dest_sel_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.control_shadowed.dest_sel.q),
    .ds     (),

    // to register interface (read)
    .qs     (control_shadowed_dest_sel_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (control_shadowed_dest_sel_update_err),
    .err_storage (control_shadowed_dest_sel_storage_err)
  );


  // R[sideload_clear]: V(False)
  // Create REGWEN-gated WE signal
  logic sideload_clear_gated_we;
  assign sideload_clear_gated_we = sideload_clear_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (3),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (3'h0),
    .Mubi    (1'b0)
  ) u_sideload_clear (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sideload_clear_gated_we),
    .wd     (sideload_clear_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sideload_clear.q),
    .ds     (),

    // to register interface (read)
    .qs     (sideload_clear_qs)
  );


  // R[reseed_interval_regwen]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_reseed_interval_regwen (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (reseed_interval_regwen_we),
    .wd     (reseed_interval_regwen_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (reseed_interval_regwen_qs)
  );


  // R[reseed_interval_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic reseed_interval_shadowed_gated_we;
  assign reseed_interval_shadowed_gated_we =
    reseed_interval_shadowed_we & reseed_interval_regwen_qs;
  prim_subreg_shadow #(
    .DW      (16),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (16'h100),
    .Mubi    (1'b0)
  ) u_reseed_interval_shadowed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (reseed_interval_shadowed_re),
    .we     (reseed_interval_shadowed_gated_we),
    .wd     (reseed_interval_shadowed_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.reseed_interval_shadowed.q),
    .ds     (),

    // to register interface (read)
    .qs     (reseed_interval_shadowed_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (reseed_interval_shadowed_update_err),
    .err_storage (reseed_interval_shadowed_storage_err)
  );


  // R[sw_binding_regwen]: V(True)
  logic sw_binding_regwen_qe;
  logic [0:0] sw_binding_regwen_flds_we;
  assign sw_binding_regwen_qe = &sw_binding_regwen_flds_we;
  prim_subreg_ext #(
    .DW    (1)
  ) u_sw_binding_regwen (
    .re     (sw_binding_regwen_re),
    .we     (sw_binding_regwen_we),
    .wd     (sw_binding_regwen_wd),
    .d      (hw2reg.sw_binding_regwen.d),
    .qre    (),
    .qe     (sw_binding_regwen_flds_we[0]),
    .q      (reg2hw.sw_binding_regwen.q),
    .ds     (),
    .qs     (sw_binding_regwen_qs)
  );
  assign reg2hw.sw_binding_regwen.qe = sw_binding_regwen_qe;


  // Subregister 0 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_0]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_0_gated_we;
  assign sealing_sw_binding_0_gated_we = sealing_sw_binding_0_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_0_gated_we),
    .wd     (sealing_sw_binding_0_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[0].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_0_qs)
  );


  // Subregister 1 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_1]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_1_gated_we;
  assign sealing_sw_binding_1_gated_we = sealing_sw_binding_1_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_1_gated_we),
    .wd     (sealing_sw_binding_1_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[1].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_1_qs)
  );


  // Subregister 2 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_2]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_2_gated_we;
  assign sealing_sw_binding_2_gated_we = sealing_sw_binding_2_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_2_gated_we),
    .wd     (sealing_sw_binding_2_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[2].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_2_qs)
  );


  // Subregister 3 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_3]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_3_gated_we;
  assign sealing_sw_binding_3_gated_we = sealing_sw_binding_3_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_3_gated_we),
    .wd     (sealing_sw_binding_3_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[3].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_3_qs)
  );


  // Subregister 4 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_4]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_4_gated_we;
  assign sealing_sw_binding_4_gated_we = sealing_sw_binding_4_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_4_gated_we),
    .wd     (sealing_sw_binding_4_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[4].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_4_qs)
  );


  // Subregister 5 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_5]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_5_gated_we;
  assign sealing_sw_binding_5_gated_we = sealing_sw_binding_5_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_5_gated_we),
    .wd     (sealing_sw_binding_5_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[5].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_5_qs)
  );


  // Subregister 6 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_6]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_6_gated_we;
  assign sealing_sw_binding_6_gated_we = sealing_sw_binding_6_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_6_gated_we),
    .wd     (sealing_sw_binding_6_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[6].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_6_qs)
  );


  // Subregister 7 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_7]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_7_gated_we;
  assign sealing_sw_binding_7_gated_we = sealing_sw_binding_7_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_7_gated_we),
    .wd     (sealing_sw_binding_7_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[7].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_7_qs)
  );


  // Subregister 0 of Multireg attest_sw_binding
  // R[attest_sw_binding_0]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_0_gated_we;
  assign attest_sw_binding_0_gated_we = attest_sw_binding_0_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_0_gated_we),
    .wd     (attest_sw_binding_0_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[0].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_0_qs)
  );


  // Subregister 1 of Multireg attest_sw_binding
  // R[attest_sw_binding_1]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_1_gated_we;
  assign attest_sw_binding_1_gated_we = attest_sw_binding_1_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_1_gated_we),
    .wd     (attest_sw_binding_1_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[1].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_1_qs)
  );


  // Subregister 2 of Multireg attest_sw_binding
  // R[attest_sw_binding_2]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_2_gated_we;
  assign attest_sw_binding_2_gated_we = attest_sw_binding_2_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_2_gated_we),
    .wd     (attest_sw_binding_2_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[2].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_2_qs)
  );


  // Subregister 3 of Multireg attest_sw_binding
  // R[attest_sw_binding_3]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_3_gated_we;
  assign attest_sw_binding_3_gated_we = attest_sw_binding_3_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_3_gated_we),
    .wd     (attest_sw_binding_3_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[3].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_3_qs)
  );


  // Subregister 4 of Multireg attest_sw_binding
  // R[attest_sw_binding_4]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_4_gated_we;
  assign attest_sw_binding_4_gated_we = attest_sw_binding_4_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_4_gated_we),
    .wd     (attest_sw_binding_4_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[4].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_4_qs)
  );


  // Subregister 5 of Multireg attest_sw_binding
  // R[attest_sw_binding_5]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_5_gated_we;
  assign attest_sw_binding_5_gated_we = attest_sw_binding_5_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_5_gated_we),
    .wd     (attest_sw_binding_5_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[5].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_5_qs)
  );


  // Subregister 6 of Multireg attest_sw_binding
  // R[attest_sw_binding_6]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_6_gated_we;
  assign attest_sw_binding_6_gated_we = attest_sw_binding_6_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_6_gated_we),
    .wd     (attest_sw_binding_6_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[6].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_6_qs)
  );


  // Subregister 7 of Multireg attest_sw_binding
  // R[attest_sw_binding_7]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_7_gated_we;
  assign attest_sw_binding_7_gated_we = attest_sw_binding_7_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_7_gated_we),
    .wd     (attest_sw_binding_7_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[7].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_7_qs)
  );


  // Subregister 0 of Multireg salt
  // R[salt_0]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_0_gated_we;
  assign salt_0_gated_we = salt_0_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_0_gated_we),
    .wd     (salt_0_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[0].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_0_qs)
  );


  // Subregister 1 of Multireg salt
  // R[salt_1]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_1_gated_we;
  assign salt_1_gated_we = salt_1_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_1_gated_we),
    .wd     (salt_1_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[1].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_1_qs)
  );


  // Subregister 2 of Multireg salt
  // R[salt_2]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_2_gated_we;
  assign salt_2_gated_we = salt_2_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_2_gated_we),
    .wd     (salt_2_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[2].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_2_qs)
  );


  // Subregister 3 of Multireg salt
  // R[salt_3]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_3_gated_we;
  assign salt_3_gated_we = salt_3_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_3_gated_we),
    .wd     (salt_3_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[3].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_3_qs)
  );


  // Subregister 4 of Multireg salt
  // R[salt_4]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_4_gated_we;
  assign salt_4_gated_we = salt_4_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_4_gated_we),
    .wd     (salt_4_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[4].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_4_qs)
  );


  // Subregister 5 of Multireg salt
  // R[salt_5]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_5_gated_we;
  assign salt_5_gated_we = salt_5_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_5_gated_we),
    .wd     (salt_5_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[5].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_5_qs)
  );


  // Subregister 6 of Multireg salt
  // R[salt_6]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_6_gated_we;
  assign salt_6_gated_we = salt_6_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_6_gated_we),
    .wd     (salt_6_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[6].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_6_qs)
  );


  // Subregister 7 of Multireg salt
  // R[salt_7]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_7_gated_we;
  assign salt_7_gated_we = salt_7_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_7_gated_we),
    .wd     (salt_7_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[7].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_7_qs)
  );


  // Subregister 0 of Multireg key_version
  // R[key_version]: V(False)
  // Create REGWEN-gated WE signal
  logic key_version_gated_we;
  assign key_version_gated_we = key_version_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_key_version (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (key_version_gated_we),
    .wd     (key_version_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.key_version[0].q),
    .ds     (),

    // to register interface (read)
    .qs     (key_version_qs)
  );


  // R[max_creator_key_ver_regwen]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_max_creator_key_ver_regwen (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (max_creator_key_ver_regwen_we),
    .wd     (max_creator_key_ver_regwen_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (max_creator_key_ver_regwen_qs)
  );


  // R[max_creator_key_ver_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic max_creator_key_ver_shadowed_gated_we;
  assign max_creator_key_ver_shadowed_gated_we =
    max_creator_key_ver_shadowed_we & max_creator_key_ver_regwen_qs;
  prim_subreg_shadow #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_max_creator_key_ver_shadowed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (max_creator_key_ver_shadowed_re),
    .we     (max_creator_key_ver_shadowed_gated_we),
    .wd     (max_creator_key_ver_shadowed_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.max_creator_key_ver_shadowed.q),
    .ds     (),

    // to register interface (read)
    .qs     (max_creator_key_ver_shadowed_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (max_creator_key_ver_shadowed_update_err),
    .err_storage (max_creator_key_ver_shadowed_storage_err)
  );


  // R[max_owner_int_key_ver_regwen]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_max_owner_int_key_ver_regwen (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (max_owner_int_key_ver_regwen_we),
    .wd     (max_owner_int_key_ver_regwen_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (max_owner_int_key_ver_regwen_qs)
  );


  // R[max_owner_int_key_ver_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic max_owner_int_key_ver_shadowed_gated_we;
  assign max_owner_int_key_ver_shadowed_gated_we =
    max_owner_int_key_ver_shadowed_we & max_owner_int_key_ver_regwen_qs;
  prim_subreg_shadow #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h1),
    .Mubi    (1'b0)
  ) u_max_owner_int_key_ver_shadowed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (max_owner_int_key_ver_shadowed_re),
    .we     (max_owner_int_key_ver_shadowed_gated_we),
    .wd     (max_owner_int_key_ver_shadowed_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.max_owner_int_key_ver_shadowed.q),
    .ds     (),

    // to register interface (read)
    .qs     (max_owner_int_key_ver_shadowed_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (max_owner_int_key_ver_shadowed_update_err),
    .err_storage (max_owner_int_key_ver_shadowed_storage_err)
  );


  // R[max_owner_key_ver_regwen]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_max_owner_key_ver_regwen (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (max_owner_key_ver_regwen_we),
    .wd     (max_owner_key_ver_regwen_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (max_owner_key_ver_regwen_qs)
  );


  // R[max_owner_key_ver_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic max_owner_key_ver_shadowed_gated_we;
  assign max_owner_key_ver_shadowed_gated_we =
    max_owner_key_ver_shadowed_we & max_owner_key_ver_regwen_qs;
  prim_subreg_shadow #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_max_owner_key_ver_shadowed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (max_owner_key_ver_shadowed_re),
    .we     (max_owner_key_ver_shadowed_gated_we),
    .wd     (max_owner_key_ver_shadowed_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.max_owner_key_ver_shadowed.q),
    .ds     (),

    // to register interface (read)
    .qs     (max_owner_key_ver_shadowed_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (max_owner_key_ver_shadowed_update_err),
    .err_storage (max_owner_key_ver_shadowed_storage_err)
  );


  // Subregister 0 of Multireg sw_share0_output
  // R[sw_share0_output_0]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_0_re),
    .wd     (sw_share0_output_0_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[0].de),
    .d      (hw2reg.sw_share0_output[0].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_0_qs)
  );


  // Subregister 1 of Multireg sw_share0_output
  // R[sw_share0_output_1]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_1_re),
    .wd     (sw_share0_output_1_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[1].de),
    .d      (hw2reg.sw_share0_output[1].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_1_qs)
  );


  // Subregister 2 of Multireg sw_share0_output
  // R[sw_share0_output_2]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_2_re),
    .wd     (sw_share0_output_2_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[2].de),
    .d      (hw2reg.sw_share0_output[2].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_2_qs)
  );


  // Subregister 3 of Multireg sw_share0_output
  // R[sw_share0_output_3]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_3_re),
    .wd     (sw_share0_output_3_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[3].de),
    .d      (hw2reg.sw_share0_output[3].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_3_qs)
  );


  // Subregister 4 of Multireg sw_share0_output
  // R[sw_share0_output_4]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_4_re),
    .wd     (sw_share0_output_4_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[4].de),
    .d      (hw2reg.sw_share0_output[4].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_4_qs)
  );


  // Subregister 5 of Multireg sw_share0_output
  // R[sw_share0_output_5]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_5_re),
    .wd     (sw_share0_output_5_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[5].de),
    .d      (hw2reg.sw_share0_output[5].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_5_qs)
  );


  // Subregister 6 of Multireg sw_share0_output
  // R[sw_share0_output_6]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_6_re),
    .wd     (sw_share0_output_6_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[6].de),
    .d      (hw2reg.sw_share0_output[6].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_6_qs)
  );


  // Subregister 7 of Multireg sw_share0_output
  // R[sw_share0_output_7]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_7_re),
    .wd     (sw_share0_output_7_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[7].de),
    .d      (hw2reg.sw_share0_output[7].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_7_qs)
  );


  // Subregister 0 of Multireg sw_share1_output
  // R[sw_share1_output_0]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_0_re),
    .wd     (sw_share1_output_0_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[0].de),
    .d      (hw2reg.sw_share1_output[0].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_0_qs)
  );


  // Subregister 1 of Multireg sw_share1_output
  // R[sw_share1_output_1]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_1_re),
    .wd     (sw_share1_output_1_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[1].de),
    .d      (hw2reg.sw_share1_output[1].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_1_qs)
  );


  // Subregister 2 of Multireg sw_share1_output
  // R[sw_share1_output_2]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_2_re),
    .wd     (sw_share1_output_2_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[2].de),
    .d      (hw2reg.sw_share1_output[2].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_2_qs)
  );


  // Subregister 3 of Multireg sw_share1_output
  // R[sw_share1_output_3]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_3_re),
    .wd     (sw_share1_output_3_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[3].de),
    .d      (hw2reg.sw_share1_output[3].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_3_qs)
  );


  // Subregister 4 of Multireg sw_share1_output
  // R[sw_share1_output_4]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_4_re),
    .wd     (sw_share1_output_4_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[4].de),
    .d      (hw2reg.sw_share1_output[4].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_4_qs)
  );


  // Subregister 5 of Multireg sw_share1_output
  // R[sw_share1_output_5]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_5_re),
    .wd     (sw_share1_output_5_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[5].de),
    .d      (hw2reg.sw_share1_output[5].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_5_qs)
  );


  // Subregister 6 of Multireg sw_share1_output
  // R[sw_share1_output_6]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_6_re),
    .wd     (sw_share1_output_6_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[6].de),
    .d      (hw2reg.sw_share1_output[6].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_6_qs)
  );


  // Subregister 7 of Multireg sw_share1_output
  // R[sw_share1_output_7]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_7_re),
    .wd     (sw_share1_output_7_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[7].de),
    .d      (hw2reg.sw_share1_output[7].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_7_qs)
  );


  // R[working_state]: V(False)
  prim_subreg #(
    .DW      (3),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (3'h0),
    .Mubi    (1'b0)
  ) u_working_state (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.working_state.de),
    .d      (hw2reg.working_state.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (working_state_qs)
  );


  // R[op_status]: V(False)
  prim_subreg #(
    .DW      (2),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (2'h0),
    .Mubi    (1'b0)
  ) u_op_status (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (op_status_we),
    .wd     (op_status_wd),

    // from internal hardware
    .de     (hw2reg.op_status.de),
    .d      (hw2reg.op_status.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (op_status_qs)
  );


  // R[err_code]: V(False)
  //   F[invalid_op]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_err_code_invalid_op (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (err_code_we),
    .wd     (err_code_invalid_op_wd),

    // from internal hardware
    .de     (hw2reg.err_code.invalid_op.de),
    .d      (hw2reg.err_code.invalid_op.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (err_code_invalid_op_qs)
  );

  //   F[invalid_kmac_input]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_err_code_invalid_kmac_input (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (err_code_we),
    .wd     (err_code_invalid_kmac_input_wd),

    // from internal hardware
    .de     (hw2reg.err_code.invalid_kmac_input.de),
    .d      (hw2reg.err_code.invalid_kmac_input.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (err_code_invalid_kmac_input_qs)
  );

  //   F[invalid_shadow_update]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_err_code_invalid_shadow_update (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (err_code_we),
    .wd     (err_code_invalid_shadow_update_wd),

    // from internal hardware
    .de     (hw2reg.err_code.invalid_shadow_update.de),
    .d      (hw2reg.err_code.invalid_shadow_update.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (err_code_invalid_shadow_update_qs)
  );


  // R[fault_status]: V(False)
  //   F[cmd]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_cmd (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.cmd.de),
    .d      (hw2reg.fault_status.cmd.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.cmd.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_cmd_qs)
  );

  //   F[kmac_fsm]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_kmac_fsm (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.kmac_fsm.de),
    .d      (hw2reg.fault_status.kmac_fsm.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.kmac_fsm.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_kmac_fsm_qs)
  );

  //   F[kmac_done]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_kmac_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.kmac_done.de),
    .d      (hw2reg.fault_status.kmac_done.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.kmac_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_kmac_done_qs)
  );

  //   F[kmac_op]: 3:3
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_kmac_op (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.kmac_op.de),
    .d      (hw2reg.fault_status.kmac_op.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.kmac_op.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_kmac_op_qs)
  );

  //   F[kmac_out]: 4:4
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_kmac_out (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.kmac_out.de),
    .d      (hw2reg.fault_status.kmac_out.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.kmac_out.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_kmac_out_qs)
  );

  //   F[regfile_intg]: 5:5
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_regfile_intg (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.regfile_intg.de),
    .d      (hw2reg.fault_status.regfile_intg.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.regfile_intg.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_regfile_intg_qs)
  );

  //   F[shadow]: 6:6
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_shadow (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.shadow.de),
    .d      (hw2reg.fault_status.shadow.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.shadow.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_shadow_qs)
  );

  //   F[ctrl_fsm_intg]: 7:7
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_ctrl_fsm_intg (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.ctrl_fsm_intg.de),
    .d      (hw2reg.fault_status.ctrl_fsm_intg.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.ctrl_fsm_intg.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_ctrl_fsm_intg_qs)
  );

  //   F[ctrl_fsm_chk]: 8:8
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_ctrl_fsm_chk (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.ctrl_fsm_chk.de),
    .d      (hw2reg.fault_status.ctrl_fsm_chk.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.ctrl_fsm_chk.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_ctrl_fsm_chk_qs)
  );

  //   F[ctrl_fsm_cnt]: 9:9
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_ctrl_fsm_cnt (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.ctrl_fsm_cnt.de),
    .d      (hw2reg.fault_status.ctrl_fsm_cnt.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.ctrl_fsm_cnt.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_ctrl_fsm_cnt_qs)
  );

  //   F[reseed_cnt]: 10:10
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_reseed_cnt (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.reseed_cnt.de),
    .d      (hw2reg.fault_status.reseed_cnt.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.reseed_cnt.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_reseed_cnt_qs)
  );

  //   F[side_ctrl_fsm]: 11:11
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_side_ctrl_fsm (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.side_ctrl_fsm.de),
    .d      (hw2reg.fault_status.side_ctrl_fsm.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.side_ctrl_fsm.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_side_ctrl_fsm_qs)
  );

  //   F[side_ctrl_sel]: 12:12
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_side_ctrl_sel (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.side_ctrl_sel.de),
    .d      (hw2reg.fault_status.side_ctrl_sel.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.side_ctrl_sel.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_side_ctrl_sel_qs)
  );

  //   F[key_ecc]: 13:13
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_key_ecc (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.key_ecc.de),
    .d      (hw2reg.fault_status.key_ecc.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.key_ecc.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_key_ecc_qs)
  );


  // R[debug]: V(False)
  //   F[invalid_creator_seed]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_creator_seed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_creator_seed_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_creator_seed.de),
    .d      (hw2reg.debug.invalid_creator_seed.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_creator_seed_qs)
  );

  //   F[invalid_owner_seed]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_owner_seed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_owner_seed_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_owner_seed.de),
    .d      (hw2reg.debug.invalid_owner_seed.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_owner_seed_qs)
  );

  //   F[invalid_dev_id]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_dev_id (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_dev_id_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_dev_id.de),
    .d      (hw2reg.debug.invalid_dev_id.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_dev_id_qs)
  );

  //   F[invalid_health_state]: 3:3
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_health_state (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_health_state_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_health_state.de),
    .d      (hw2reg.debug.invalid_health_state.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_health_state_qs)
  );

  //   F[invalid_key_version]: 4:4
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_key_version (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_key_version_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_key_version.de),
    .d      (hw2reg.debug.invalid_key_version.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_key_version_qs)
  );

  //   F[invalid_key]: 5:5
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_key (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_key_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_key.de),
    .d      (hw2reg.debug.invalid_key.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_key_qs)
  );

  //   F[invalid_digest]: 6:6
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_digest (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_digest_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_digest.de),
    .d      (hw2reg.debug.invalid_digest.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_digest_qs)
  );



  logic [62:0] addr_hit;
  always_comb begin
    addr_hit = '0;
    addr_hit[ 0] = (reg_addr == KEYMGR_INTR_STATE_OFFSET);
    addr_hit[ 1] = (reg_addr == KEYMGR_INTR_ENABLE_OFFSET);
    addr_hit[ 2] = (reg_addr == KEYMGR_INTR_TEST_OFFSET);
    addr_hit[ 3] = (reg_addr == KEYMGR_ALERT_TEST_OFFSET);
    addr_hit[ 4] = (reg_addr == KEYMGR_CFG_REGWEN_OFFSET);
    addr_hit[ 5] = (reg_addr == KEYMGR_START_OFFSET);
    addr_hit[ 6] = (reg_addr == KEYMGR_CONTROL_SHADOWED_OFFSET);
    addr_hit[ 7] = (reg_addr == KEYMGR_SIDELOAD_CLEAR_OFFSET);
    addr_hit[ 8] = (reg_addr == KEYMGR_RESEED_INTERVAL_REGWEN_OFFSET);
    addr_hit[ 9] = (reg_addr == KEYMGR_RESEED_INTERVAL_SHADOWED_OFFSET);
    addr_hit[10] = (reg_addr == KEYMGR_SW_BINDING_REGWEN_OFFSET);
    addr_hit[11] = (reg_addr == KEYMGR_SEALING_SW_BINDING_0_OFFSET);
    addr_hit[12] = (reg_addr == KEYMGR_SEALING_SW_BINDING_1_OFFSET);
    addr_hit[13] = (reg_addr == KEYMGR_SEALING_SW_BINDING_2_OFFSET);
    addr_hit[14] = (reg_addr == KEYMGR_SEALING_SW_BINDING_3_OFFSET);
    addr_hit[15] = (reg_addr == KEYMGR_SEALING_SW_BINDING_4_OFFSET);
    addr_hit[16] = (reg_addr == KEYMGR_SEALING_SW_BINDING_5_OFFSET);
    addr_hit[17] = (reg_addr == KEYMGR_SEALING_SW_BINDING_6_OFFSET);
    addr_hit[18] = (reg_addr == KEYMGR_SEALING_SW_BINDING_7_OFFSET);
    addr_hit[19] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_0_OFFSET);
    addr_hit[20] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_1_OFFSET);
    addr_hit[21] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_2_OFFSET);
    addr_hit[22] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_3_OFFSET);
    addr_hit[23] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_4_OFFSET);
    addr_hit[24] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_5_OFFSET);
    addr_hit[25] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_6_OFFSET);
    addr_hit[26] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_7_OFFSET);
    addr_hit[27] = (reg_addr == KEYMGR_SALT_0_OFFSET);
    addr_hit[28] = (reg_addr == KEYMGR_SALT_1_OFFSET);
    addr_hit[29] = (reg_addr == KEYMGR_SALT_2_OFFSET);
    addr_hit[30] = (reg_addr == KEYMGR_SALT_3_OFFSET);
    addr_hit[31] = (reg_addr == KEYMGR_SALT_4_OFFSET);
    addr_hit[32] = (reg_addr == KEYMGR_SALT_5_OFFSET);
    addr_hit[33] = (reg_addr == KEYMGR_SALT_6_OFFSET);
    addr_hit[34] = (reg_addr == KEYMGR_SALT_7_OFFSET);
    addr_hit[35] = (reg_addr == KEYMGR_KEY_VERSION_OFFSET);
    addr_hit[36] = (reg_addr == KEYMGR_MAX_CREATOR_KEY_VER_REGWEN_OFFSET);
    addr_hit[37] = (reg_addr == KEYMGR_MAX_CREATOR_KEY_VER_SHADOWED_OFFSET);
    addr_hit[38] = (reg_addr == KEYMGR_MAX_OWNER_INT_KEY_VER_REGWEN_OFFSET);
    addr_hit[39] = (reg_addr == KEYMGR_MAX_OWNER_INT_KEY_VER_SHADOWED_OFFSET);
    addr_hit[40] = (reg_addr == KEYMGR_MAX_OWNER_KEY_VER_REGWEN_OFFSET);
    addr_hit[41] = (reg_addr == KEYMGR_MAX_OWNER_KEY_VER_SHADOWED_OFFSET);
    addr_hit[42] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_0_OFFSET);
    addr_hit[43] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_1_OFFSET);
    addr_hit[44] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_2_OFFSET);
    addr_hit[45] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_3_OFFSET);
    addr_hit[46] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_4_OFFSET);
    addr_hit[47] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_5_OFFSET);
    addr_hit[48] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_6_OFFSET);
    addr_hit[49] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_7_OFFSET);
    addr_hit[50] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_0_OFFSET);
    addr_hit[51] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_1_OFFSET);
    addr_hit[52] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_2_OFFSET);
    addr_hit[53] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_3_OFFSET);
    addr_hit[54] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_4_OFFSET);
    addr_hit[55] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_5_OFFSET);
    addr_hit[56] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_6_OFFSET);
    addr_hit[57] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_7_OFFSET);
    addr_hit[58] = (reg_addr == KEYMGR_WORKING_STATE_OFFSET);
    addr_hit[59] = (reg_addr == KEYMGR_OP_STATUS_OFFSET);
    addr_hit[60] = (reg_addr == KEYMGR_ERR_CODE_OFFSET);
    addr_hit[61] = (reg_addr == KEYMGR_FAULT_STATUS_OFFSET);
    addr_hit[62] = (reg_addr == KEYMGR_DEBUG_OFFSET);
  end

  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;

  // Check sub-word write is permitted
  always_comb begin
    wr_err = (reg_we &
              ((addr_hit[ 0] & (|(KEYMGR_PERMIT[ 0] & ~reg_be))) |
               (addr_hit[ 1] & (|(KEYMGR_PERMIT[ 1] & ~reg_be))) |
               (addr_hit[ 2] & (|(KEYMGR_PERMIT[ 2] & ~reg_be))) |
               (addr_hit[ 3] & (|(KEYMGR_PERMIT[ 3] & ~reg_be))) |
               (addr_hit[ 4] & (|(KEYMGR_PERMIT[ 4] & ~reg_be))) |
               (addr_hit[ 5] & (|(KEYMGR_PERMIT[ 5] & ~reg_be))) |
               (addr_hit[ 6] & (|(KEYMGR_PERMIT[ 6] & ~reg_be))) |
               (addr_hit[ 7] & (|(KEYMGR_PERMIT[ 7] & ~reg_be))) |
               (addr_hit[ 8] & (|(KEYMGR_PERMIT[ 8] & ~reg_be))) |
               (addr_hit[ 9] & (|(KEYMGR_PERMIT[ 9] & ~reg_be))) |
               (addr_hit[10] & (|(KEYMGR_PERMIT[10] & ~reg_be))) |
               (addr_hit[11] & (|(KEYMGR_PERMIT[11] & ~reg_be))) |
               (addr_hit[12] & (|(KEYMGR_PERMIT[12] & ~reg_be))) |
               (addr_hit[13] & (|(KEYMGR_PERMIT[13] & ~reg_be))) |
               (addr_hit[14] & (|(KEYMGR_PERMIT[14] & ~reg_be))) |
               (addr_hit[15] & (|(KEYMGR_PERMIT[15] & ~reg_be))) |
               (addr_hit[16] & (|(KEYMGR_PERMIT[16] & ~reg_be))) |
               (addr_hit[17] & (|(KEYMGR_PERMIT[17] & ~reg_be))) |
               (addr_hit[18] & (|(KEYMGR_PERMIT[18] & ~reg_be))) |
               (addr_hit[19] & (|(KEYMGR_PERMIT[19] & ~reg_be))) |
               (addr_hit[20] & (|(KEYMGR_PERMIT[20] & ~reg_be))) |
               (addr_hit[21] & (|(KEYMGR_PERMIT[21] & ~reg_be))) |
               (addr_hit[22] & (|(KEYMGR_PERMIT[22] & ~reg_be))) |
               (addr_hit[23] & (|(KEYMGR_PERMIT[23] & ~reg_be))) |
               (addr_hit[24] & (|(KEYMGR_PERMIT[24] & ~reg_be))) |
               (addr_hit[25] & (|(KEYMGR_PERMIT[25] & ~reg_be))) |
               (addr_hit[26] & (|(KEYMGR_PERMIT[26] & ~reg_be))) |
               (addr_hit[27] & (|(KEYMGR_PERMIT[27] & ~reg_be))) |
               (addr_hit[28] & (|(KEYMGR_PERMIT[28] & ~reg_be))) |
               (addr_hit[29] & (|(KEYMGR_PERMIT[29] & ~reg_be))) |
               (addr_hit[30] & (|(KEYMGR_PERMIT[30] & ~reg_be))) |
               (addr_hit[31] & (|(KEYMGR_PERMIT[31] & ~reg_be))) |
               (addr_hit[32] & (|(KEYMGR_PERMIT[32] & ~reg_be))) |
               (addr_hit[33] & (|(KEYMGR_PERMIT[33] & ~reg_be))) |
               (addr_hit[34] & (|(KEYMGR_PERMIT[34] & ~reg_be))) |
               (addr_hit[35] & (|(KEYMGR_PERMIT[35] & ~reg_be))) |
               (addr_hit[36] & (|(KEYMGR_PERMIT[36] & ~reg_be))) |
               (addr_hit[37] & (|(KEYMGR_PERMIT[37] & ~reg_be))) |
               (addr_hit[38] & (|(KEYMGR_PERMIT[38] & ~reg_be))) |
               (addr_hit[39] & (|(KEYMGR_PERMIT[39] & ~reg_be))) |
               (addr_hit[40] & (|(KEYMGR_PERMIT[40] & ~reg_be))) |
               (addr_hit[41] & (|(KEYMGR_PERMIT[41] & ~reg_be))) |
               (addr_hit[42] & (|(KEYMGR_PERMIT[42] & ~reg_be))) |
               (addr_hit[43] & (|(KEYMGR_PERMIT[43] & ~reg_be))) |
               (addr_hit[44] & (|(KEYMGR_PERMIT[44] & ~reg_be))) |
               (addr_hit[45] & (|(KEYMGR_PERMIT[45] & ~reg_be))) |
               (addr_hit[46] & (|(KEYMGR_PERMIT[46] & ~reg_be))) |
               (addr_hit[47] & (|(KEYMGR_PERMIT[47] & ~reg_be))) |
               (addr_hit[48] & (|(KEYMGR_PERMIT[48] & ~reg_be))) |
               (addr_hit[49] & (|(KEYMGR_PERMIT[49] & ~reg_be))) |
               (addr_hit[50] & (|(KEYMGR_PERMIT[50] & ~reg_be))) |
               (addr_hit[51] & (|(KEYMGR_PERMIT[51] & ~reg_be))) |
               (addr_hit[52] & (|(KEYMGR_PERMIT[52] & ~reg_be))) |
               (addr_hit[53] & (|(KEYMGR_PERMIT[53] & ~reg_be))) |
               (addr_hit[54] & (|(KEYMGR_PERMIT[54] & ~reg_be))) |
               (addr_hit[55] & (|(KEYMGR_PERMIT[55] & ~reg_be))) |
               (addr_hit[56] & (|(KEYMGR_PERMIT[56] & ~reg_be))) |
               (addr_hit[57] & (|(KEYMGR_PERMIT[57] & ~reg_be))) |
               (addr_hit[58] & (|(KEYMGR_PERMIT[58] & ~reg_be))) |
               (addr_hit[59] & (|(KEYMGR_PERMIT[59] & ~reg_be))) |
               (addr_hit[60] & (|(KEYMGR_PERMIT[60] & ~reg_be))) |
               (addr_hit[61] & (|(KEYMGR_PERMIT[61] & ~reg_be))) |
               (addr_hit[62] & (|(KEYMGR_PERMIT[62] & ~reg_be)))));
  end

  // Generate write-enables
  assign intr_state_we = addr_hit[0] & reg_we & !reg_error;

  assign intr_state_wd = reg_wdata[0];
  assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;

  assign intr_enable_wd = reg_wdata[0];
  assign intr_test_we = addr_hit[2] & reg_we & !reg_error;

  assign intr_test_wd = reg_wdata[0];
  assign alert_test_we = addr_hit[3] & reg_we & !reg_error;

  assign alert_test_recov_operation_err_wd = reg_wdata[0];

  assign alert_test_fatal_fault_err_wd = reg_wdata[1];
  assign cfg_regwen_re = addr_hit[4] & reg_re & !reg_error;
  assign start_we = addr_hit[5] & reg_we & !reg_error;

  assign start_wd = reg_wdata[0];
  assign control_shadowed_re = addr_hit[6] & reg_re & !reg_error;
  assign control_shadowed_we = addr_hit[6] & reg_we & !reg_error;

  assign control_shadowed_operation_wd = reg_wdata[6:4];

  assign control_shadowed_cdi_sel_wd = reg_wdata[7];

  assign control_shadowed_dest_sel_wd = reg_wdata[13:12];
  assign sideload_clear_we = addr_hit[7] & reg_we & !reg_error;

  assign sideload_clear_wd = reg_wdata[2:0];
  assign reseed_interval_regwen_we = addr_hit[8] & reg_we & !reg_error;

  assign reseed_interval_regwen_wd = reg_wdata[0];
  assign reseed_interval_shadowed_re = addr_hit[9] & reg_re & !reg_error;
  assign reseed_interval_shadowed_we = addr_hit[9] & reg_we & !reg_error;

  assign reseed_interval_shadowed_wd = reg_wdata[15:0];
  assign sw_binding_regwen_re = addr_hit[10] & reg_re & !reg_error;
  assign sw_binding_regwen_we = addr_hit[10] & reg_we & !reg_error;

  assign sw_binding_regwen_wd = reg_wdata[0];
  assign sealing_sw_binding_0_we = addr_hit[11] & reg_we & !reg_error;

  assign sealing_sw_binding_0_wd = reg_wdata[31:0];
  assign sealing_sw_binding_1_we = addr_hit[12] & reg_we & !reg_error;

  assign sealing_sw_binding_1_wd = reg_wdata[31:0];
  assign sealing_sw_binding_2_we = addr_hit[13] & reg_we & !reg_error;

  assign sealing_sw_binding_2_wd = reg_wdata[31:0];
  assign sealing_sw_binding_3_we = addr_hit[14] & reg_we & !reg_error;

  assign sealing_sw_binding_3_wd = reg_wdata[31:0];
  assign sealing_sw_binding_4_we = addr_hit[15] & reg_we & !reg_error;

  assign sealing_sw_binding_4_wd = reg_wdata[31:0];
  assign sealing_sw_binding_5_we = addr_hit[16] & reg_we & !reg_error;

  assign sealing_sw_binding_5_wd = reg_wdata[31:0];
  assign sealing_sw_binding_6_we = addr_hit[17] & reg_we & !reg_error;

  assign sealing_sw_binding_6_wd = reg_wdata[31:0];
  assign sealing_sw_binding_7_we = addr_hit[18] & reg_we & !reg_error;

  assign sealing_sw_binding_7_wd = reg_wdata[31:0];
  assign attest_sw_binding_0_we = addr_hit[19] & reg_we & !reg_error;

  assign attest_sw_binding_0_wd = reg_wdata[31:0];
  assign attest_sw_binding_1_we = addr_hit[20] & reg_we & !reg_error;

  assign attest_sw_binding_1_wd = reg_wdata[31:0];
  assign attest_sw_binding_2_we = addr_hit[21] & reg_we & !reg_error;

  assign attest_sw_binding_2_wd = reg_wdata[31:0];
  assign attest_sw_binding_3_we = addr_hit[22] & reg_we & !reg_error;

  assign attest_sw_binding_3_wd = reg_wdata[31:0];
  assign attest_sw_binding_4_we = addr_hit[23] & reg_we & !reg_error;

  assign attest_sw_binding_4_wd = reg_wdata[31:0];
  assign attest_sw_binding_5_we = addr_hit[24] & reg_we & !reg_error;

  assign attest_sw_binding_5_wd = reg_wdata[31:0];
  assign attest_sw_binding_6_we = addr_hit[25] & reg_we & !reg_error;

  assign attest_sw_binding_6_wd = reg_wdata[31:0];
  assign attest_sw_binding_7_we = addr_hit[26] & reg_we & !reg_error;

  assign attest_sw_binding_7_wd = reg_wdata[31:0];
  assign salt_0_we = addr_hit[27] & reg_we & !reg_error;

  assign salt_0_wd = reg_wdata[31:0];
  assign salt_1_we = addr_hit[28] & reg_we & !reg_error;

  assign salt_1_wd = reg_wdata[31:0];
  assign salt_2_we = addr_hit[29] & reg_we & !reg_error;

  assign salt_2_wd = reg_wdata[31:0];
  assign salt_3_we = addr_hit[30] & reg_we & !reg_error;

  assign salt_3_wd = reg_wdata[31:0];
  assign salt_4_we = addr_hit[31] & reg_we & !reg_error;

  assign salt_4_wd = reg_wdata[31:0];
  assign salt_5_we = addr_hit[32] & reg_we & !reg_error;

  assign salt_5_wd = reg_wdata[31:0];
  assign salt_6_we = addr_hit[33] & reg_we & !reg_error;

  assign salt_6_wd = reg_wdata[31:0];
  assign salt_7_we = addr_hit[34] & reg_we & !reg_error;

  assign salt_7_wd = reg_wdata[31:0];
  assign key_version_we = addr_hit[35] & reg_we & !reg_error;

  assign key_version_wd = reg_wdata[31:0];
  assign max_creator_key_ver_regwen_we = addr_hit[36] & reg_we & !reg_error;

  assign max_creator_key_ver_regwen_wd = reg_wdata[0];
  assign max_creator_key_ver_shadowed_re = addr_hit[37] & reg_re & !reg_error;
  assign max_creator_key_ver_shadowed_we = addr_hit[37] & reg_we & !reg_error;

  assign max_creator_key_ver_shadowed_wd = reg_wdata[31:0];
  assign max_owner_int_key_ver_regwen_we = addr_hit[38] & reg_we & !reg_error;

  assign max_owner_int_key_ver_regwen_wd = reg_wdata[0];
  assign max_owner_int_key_ver_shadowed_re = addr_hit[39] & reg_re & !reg_error;
  assign max_owner_int_key_ver_shadowed_we = addr_hit[39] & reg_we & !reg_error;

  assign max_owner_int_key_ver_shadowed_wd = reg_wdata[31:0];
  assign max_owner_key_ver_regwen_we = addr_hit[40] & reg_we & !reg_error;

  assign max_owner_key_ver_regwen_wd = reg_wdata[0];
  assign max_owner_key_ver_shadowed_re = addr_hit[41] & reg_re & !reg_error;
  assign max_owner_key_ver_shadowed_we = addr_hit[41] & reg_we & !reg_error;

  assign max_owner_key_ver_shadowed_wd = reg_wdata[31:0];
  assign sw_share0_output_0_re = addr_hit[42] & reg_re & !reg_error;

  assign sw_share0_output_0_wd = '1;
  assign sw_share0_output_1_re = addr_hit[43] & reg_re & !reg_error;

  assign sw_share0_output_1_wd = '1;
  assign sw_share0_output_2_re = addr_hit[44] & reg_re & !reg_error;

  assign sw_share0_output_2_wd = '1;
  assign sw_share0_output_3_re = addr_hit[45] & reg_re & !reg_error;

  assign sw_share0_output_3_wd = '1;
  assign sw_share0_output_4_re = addr_hit[46] & reg_re & !reg_error;

  assign sw_share0_output_4_wd = '1;
  assign sw_share0_output_5_re = addr_hit[47] & reg_re & !reg_error;

  assign sw_share0_output_5_wd = '1;
  assign sw_share0_output_6_re = addr_hit[48] & reg_re & !reg_error;

  assign sw_share0_output_6_wd = '1;
  assign sw_share0_output_7_re = addr_hit[49] & reg_re & !reg_error;

  assign sw_share0_output_7_wd = '1;
  assign sw_share1_output_0_re = addr_hit[50] & reg_re & !reg_error;

  assign sw_share1_output_0_wd = '1;
  assign sw_share1_output_1_re = addr_hit[51] & reg_re & !reg_error;

  assign sw_share1_output_1_wd = '1;
  assign sw_share1_output_2_re = addr_hit[52] & reg_re & !reg_error;

  assign sw_share1_output_2_wd = '1;
  assign sw_share1_output_3_re = addr_hit[53] & reg_re & !reg_error;

  assign sw_share1_output_3_wd = '1;
  assign sw_share1_output_4_re = addr_hit[54] & reg_re & !reg_error;

  assign sw_share1_output_4_wd = '1;
  assign sw_share1_output_5_re = addr_hit[55] & reg_re & !reg_error;

  assign sw_share1_output_5_wd = '1;
  assign sw_share1_output_6_re = addr_hit[56] & reg_re & !reg_error;

  assign sw_share1_output_6_wd = '1;
  assign sw_share1_output_7_re = addr_hit[57] & reg_re & !reg_error;

  assign sw_share1_output_7_wd = '1;
  assign op_status_we = addr_hit[59] & reg_we & !reg_error;

  assign op_status_wd = reg_wdata[1:0];
  assign err_code_we = addr_hit[60] & reg_we & !reg_error;

  assign err_code_invalid_op_wd = reg_wdata[0];

  assign err_code_invalid_kmac_input_wd = reg_wdata[1];

  assign err_code_invalid_shadow_update_wd = reg_wdata[2];
  assign debug_we = addr_hit[62] & reg_we & !reg_error;

  assign debug_invalid_creator_seed_wd = reg_wdata[0];

  assign debug_invalid_owner_seed_wd = reg_wdata[1];

  assign debug_invalid_dev_id_wd = reg_wdata[2];

  assign debug_invalid_health_state_wd = reg_wdata[3];

  assign debug_invalid_key_version_wd = reg_wdata[4];

  assign debug_invalid_key_wd = reg_wdata[5];

  assign debug_invalid_digest_wd = reg_wdata[6];

  // Assign write-enables to checker logic vector.
  always_comb begin
    reg_we_check = '0;
    reg_we_check[0] = intr_state_we;
    reg_we_check[1] = intr_enable_we;
    reg_we_check[2] = intr_test_we;
    reg_we_check[3] = alert_test_we;
    reg_we_check[4] = 1'b0;
    reg_we_check[5] = start_gated_we;
    reg_we_check[6] = control_shadowed_gated_we;
    reg_we_check[7] = sideload_clear_gated_we;
    reg_we_check[8] = reseed_interval_regwen_we;
    reg_we_check[9] = reseed_interval_shadowed_gated_we;
    reg_we_check[10] = sw_binding_regwen_we;
    reg_we_check[11] = sealing_sw_binding_0_gated_we;
    reg_we_check[12] = sealing_sw_binding_1_gated_we;
    reg_we_check[13] = sealing_sw_binding_2_gated_we;
    reg_we_check[14] = sealing_sw_binding_3_gated_we;
    reg_we_check[15] = sealing_sw_binding_4_gated_we;
    reg_we_check[16] = sealing_sw_binding_5_gated_we;
    reg_we_check[17] = sealing_sw_binding_6_gated_we;
    reg_we_check[18] = sealing_sw_binding_7_gated_we;
    reg_we_check[19] = attest_sw_binding_0_gated_we;
    reg_we_check[20] = attest_sw_binding_1_gated_we;
    reg_we_check[21] = attest_sw_binding_2_gated_we;
    reg_we_check[22] = attest_sw_binding_3_gated_we;
    reg_we_check[23] = attest_sw_binding_4_gated_we;
    reg_we_check[24] = attest_sw_binding_5_gated_we;
    reg_we_check[25] = attest_sw_binding_6_gated_we;
    reg_we_check[26] = attest_sw_binding_7_gated_we;
    reg_we_check[27] = salt_0_gated_we;
    reg_we_check[28] = salt_1_gated_we;
    reg_we_check[29] = salt_2_gated_we;
    reg_we_check[30] = salt_3_gated_we;
    reg_we_check[31] = salt_4_gated_we;
    reg_we_check[32] = salt_5_gated_we;
    reg_we_check[33] = salt_6_gated_we;
    reg_we_check[34] = salt_7_gated_we;
    reg_we_check[35] = key_version_gated_we;
    reg_we_check[36] = max_creator_key_ver_regwen_we;
    reg_we_check[37] = max_creator_key_ver_shadowed_gated_we;
    reg_we_check[38] = max_owner_int_key_ver_regwen_we;
    reg_we_check[39] = max_owner_int_key_ver_shadowed_gated_we;
    reg_we_check[40] = max_owner_key_ver_regwen_we;
    reg_we_check[41] = max_owner_key_ver_shadowed_gated_we;
    reg_we_check[42] = 1'b0;
    reg_we_check[43] = 1'b0;
    reg_we_check[44] = 1'b0;
    reg_we_check[45] = 1'b0;
    reg_we_check[46] = 1'b0;
    reg_we_check[47] = 1'b0;
    reg_we_check[48] = 1'b0;
    reg_we_check[49] = 1'b0;
    reg_we_check[50] = 1'b0;
    reg_we_check[51] = 1'b0;
    reg_we_check[52] = 1'b0;
    reg_we_check[53] = 1'b0;
    reg_we_check[54] = 1'b0;
    reg_we_check[55] = 1'b0;
    reg_we_check[56] = 1'b0;
    reg_we_check[57] = 1'b0;
    reg_we_check[58] = 1'b0;
    reg_we_check[59] = op_status_we;
    reg_we_check[60] = err_code_we;
    reg_we_check[61] = 1'b0;
    reg_we_check[62] = debug_we;
  end

  // Read data return
  always_comb begin
    reg_rdata_next = '0;
    unique case (1'b1)
      addr_hit[0]: begin
        reg_rdata_next[0] = intr_state_qs;
      end

      addr_hit[1]: begin
        reg_rdata_next[0] = intr_enable_qs;
      end

      addr_hit[2]: begin
        reg_rdata_next[0] = '0;
      end

      addr_hit[3]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
      end

      addr_hit[4]: begin
        reg_rdata_next[0] = cfg_regwen_qs;
      end

      addr_hit[5]: begin
        reg_rdata_next[0] = start_qs;
      end

      addr_hit[6]: begin
        reg_rdata_next[6:4] = control_shadowed_operation_qs;
        reg_rdata_next[7] = control_shadowed_cdi_sel_qs;
        reg_rdata_next[13:12] = control_shadowed_dest_sel_qs;
      end

      addr_hit[7]: begin
        reg_rdata_next[2:0] = sideload_clear_qs;
      end

      addr_hit[8]: begin
        reg_rdata_next[0] = reseed_interval_regwen_qs;
      end

      addr_hit[9]: begin
        reg_rdata_next[15:0] = reseed_interval_shadowed_qs;
      end

      addr_hit[10]: begin
        reg_rdata_next[0] = sw_binding_regwen_qs;
      end

      addr_hit[11]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_0_qs;
      end

      addr_hit[12]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_1_qs;
      end

      addr_hit[13]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_2_qs;
      end

      addr_hit[14]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_3_qs;
      end

      addr_hit[15]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_4_qs;
      end

      addr_hit[16]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_5_qs;
      end

      addr_hit[17]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_6_qs;
      end

      addr_hit[18]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_7_qs;
      end

      addr_hit[19]: begin
        reg_rdata_next[31:0] = attest_sw_binding_0_qs;
      end

      addr_hit[20]: begin
        reg_rdata_next[31:0] = attest_sw_binding_1_qs;
      end

      addr_hit[21]: begin
        reg_rdata_next[31:0] = attest_sw_binding_2_qs;
      end

      addr_hit[22]: begin
        reg_rdata_next[31:0] = attest_sw_binding_3_qs;
      end

      addr_hit[23]: begin
        reg_rdata_next[31:0] = attest_sw_binding_4_qs;
      end

      addr_hit[24]: begin
        reg_rdata_next[31:0] = attest_sw_binding_5_qs;
      end

      addr_hit[25]: begin
        reg_rdata_next[31:0] = attest_sw_binding_6_qs;
      end

      addr_hit[26]: begin
        reg_rdata_next[31:0] = attest_sw_binding_7_qs;
      end

      addr_hit[27]: begin
        reg_rdata_next[31:0] = salt_0_qs;
      end

      addr_hit[28]: begin
        reg_rdata_next[31:0] = salt_1_qs;
      end

      addr_hit[29]: begin
        reg_rdata_next[31:0] = salt_2_qs;
      end

      addr_hit[30]: begin
        reg_rdata_next[31:0] = salt_3_qs;
      end

      addr_hit[31]: begin
        reg_rdata_next[31:0] = salt_4_qs;
      end

      addr_hit[32]: begin
        reg_rdata_next[31:0] = salt_5_qs;
      end

      addr_hit[33]: begin
        reg_rdata_next[31:0] = salt_6_qs;
      end

      addr_hit[34]: begin
        reg_rdata_next[31:0] = salt_7_qs;
      end

      addr_hit[35]: begin
        reg_rdata_next[31:0] = key_version_qs;
      end

      addr_hit[36]: begin
        reg_rdata_next[0] = max_creator_key_ver_regwen_qs;
      end

      addr_hit[37]: begin
        reg_rdata_next[31:0] = max_creator_key_ver_shadowed_qs;
      end

      addr_hit[38]: begin
        reg_rdata_next[0] = max_owner_int_key_ver_regwen_qs;
      end

      addr_hit[39]: begin
        reg_rdata_next[31:0] = max_owner_int_key_ver_shadowed_qs;
      end

      addr_hit[40]: begin
        reg_rdata_next[0] = max_owner_key_ver_regwen_qs;
      end

      addr_hit[41]: begin
        reg_rdata_next[31:0] = max_owner_key_ver_shadowed_qs;
      end

      addr_hit[42]: begin
        reg_rdata_next[31:0] = sw_share0_output_0_qs;
      end

      addr_hit[43]: begin
        reg_rdata_next[31:0] = sw_share0_output_1_qs;
      end

      addr_hit[44]: begin
        reg_rdata_next[31:0] = sw_share0_output_2_qs;
      end

      addr_hit[45]: begin
        reg_rdata_next[31:0] = sw_share0_output_3_qs;
      end

      addr_hit[46]: begin
        reg_rdata_next[31:0] = sw_share0_output_4_qs;
      end

      addr_hit[47]: begin
        reg_rdata_next[31:0] = sw_share0_output_5_qs;
      end

      addr_hit[48]: begin
        reg_rdata_next[31:0] = sw_share0_output_6_qs;
      end

      addr_hit[49]: begin
        reg_rdata_next[31:0] = sw_share0_output_7_qs;
      end

      addr_hit[50]: begin
        reg_rdata_next[31:0] = sw_share1_output_0_qs;
      end

      addr_hit[51]: begin
        reg_rdata_next[31:0] = sw_share1_output_1_qs;
      end

      addr_hit[52]: begin
        reg_rdata_next[31:0] = sw_share1_output_2_qs;
      end

      addr_hit[53]: begin
        reg_rdata_next[31:0] = sw_share1_output_3_qs;
      end

      addr_hit[54]: begin
        reg_rdata_next[31:0] = sw_share1_output_4_qs;
      end

      addr_hit[55]: begin
        reg_rdata_next[31:0] = sw_share1_output_5_qs;
      end

      addr_hit[56]: begin
        reg_rdata_next[31:0] = sw_share1_output_6_qs;
      end

      addr_hit[57]: begin
        reg_rdata_next[31:0] = sw_share1_output_7_qs;
      end

      addr_hit[58]: begin
        reg_rdata_next[2:0] = working_state_qs;
      end

      addr_hit[59]: begin
        reg_rdata_next[1:0] = op_status_qs;
      end

      addr_hit[60]: begin
        reg_rdata_next[0] = err_code_invalid_op_qs;
        reg_rdata_next[1] = err_code_invalid_kmac_input_qs;
        reg_rdata_next[2] = err_code_invalid_shadow_update_qs;
      end

      addr_hit[61]: begin
        reg_rdata_next[0] = fault_status_cmd_qs;
        reg_rdata_next[1] = fault_status_kmac_fsm_qs;
        reg_rdata_next[2] = fault_status_kmac_done_qs;
        reg_rdata_next[3] = fault_status_kmac_op_qs;
        reg_rdata_next[4] = fault_status_kmac_out_qs;
        reg_rdata_next[5] = fault_status_regfile_intg_qs;
        reg_rdata_next[6] = fault_status_shadow_qs;
        reg_rdata_next[7] = fault_status_ctrl_fsm_intg_qs;
        reg_rdata_next[8] = fault_status_ctrl_fsm_chk_qs;
        reg_rdata_next[9] = fault_status_ctrl_fsm_cnt_qs;
        reg_rdata_next[10] = fault_status_reseed_cnt_qs;
        reg_rdata_next[11] = fault_status_side_ctrl_fsm_qs;
        reg_rdata_next[12] = fault_status_side_ctrl_sel_qs;
        reg_rdata_next[13] = fault_status_key_ecc_qs;
      end

      addr_hit[62]: begin
        reg_rdata_next[0] = debug_invalid_creator_seed_qs;
        reg_rdata_next[1] = debug_invalid_owner_seed_qs;
        reg_rdata_next[2] = debug_invalid_dev_id_qs;
        reg_rdata_next[3] = debug_invalid_health_state_qs;
        reg_rdata_next[4] = debug_invalid_key_version_qs;
        reg_rdata_next[5] = debug_invalid_key_qs;
        reg_rdata_next[6] = debug_invalid_digest_qs;
      end

      default: begin
        reg_rdata_next = '1;
      end
    endcase
  end

  // shadow busy
  logic shadow_busy;
  logic rst_done;
  logic shadow_rst_done;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      rst_done <= '0;
    end else begin
      rst_done <= 1'b1;
    end
  end

  always_ff @(posedge clk_i or negedge rst_shadowed_ni) begin
    if (!rst_shadowed_ni) begin
      shadow_rst_done <= '0;
    end else begin
      shadow_rst_done <= 1'b1;
    end
  end

  // both shadow and normal resets have been released
  assign shadow_busy = ~(rst_done & shadow_rst_done);

  // Collect up storage and update errors
  assign shadowed_storage_err_o = |{
    control_shadowed_operation_storage_err,
    control_shadowed_cdi_sel_storage_err,
    control_shadowed_dest_sel_storage_err,
    reseed_interval_shadowed_storage_err,
    max_creator_key_ver_shadowed_storage_err,
    max_owner_int_key_ver_shadowed_storage_err,
    max_owner_key_ver_shadowed_storage_err
  };
  assign shadowed_update_err_o = |{
    control_shadowed_operation_update_err,
    control_shadowed_cdi_sel_update_err,
    control_shadowed_dest_sel_update_err,
    reseed_interval_shadowed_update_err,
    max_creator_key_ver_shadowed_update_err,
    max_owner_int_key_ver_shadowed_update_err,
    max_owner_key_ver_shadowed_update_err
  };

  // register busy
  assign reg_busy = shadow_busy;

  // Unused signal tieoff

  // wdata / byte enable are not always fully used
  // add a blanket unused statement to handle lint waivers
  logic unused_wdata;
  logic unused_be;
  assign unused_wdata = ^reg_wdata;
  assign unused_be = ^reg_be;

  // Assertions for Register Interface
  `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
  `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)

  `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)

  `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)

  // this is formulated as an assumption such that the FPV testbenches do disprove this
  // property by mistake
  //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)

endmodule

    '''

    Use the anomaly detector tool to identify lines in the design RTL that are anomalous.
    Then determine whether the identified anomalous line(s) represent a security issue or not.

    
================================== Ai Message ==================================
Tool Calls:
  anomaly_detector_tool (call_lONbvm1ypnRlYMVuXKizg6Iu)
 Call ID: call_lONbvm1ypnRlYMVuXKizg6Iu
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv
================================= Tool Message =================================
Name: anomaly_detector_tool

Successfully executed:
```LLM Anomaly Detector tool
```
Output:
Here are clusters of similar verilog constructs in the RTL file:



Cluster 0:
assign intg_err_o = err_q | intg_err | reg_we_err;
assign reg_error = addrmiss | wr_err | intg_err;
assign intr_test_qe = &intr_test_flds_we;
assign reg2hw.intr_test.qe = intr_test_qe;
assign alert_test_qe = &alert_test_flds_we;
assign reg2hw.alert_test.recov_operation_err.qe = alert_test_qe;
assign reg2hw.alert_test.fatal_fault_err.qe = alert_test_qe;
assign start_gated_we = start_we & cfg_regwen_qs;
assign control_shadowed_gated_we = control_shadowed_we & cfg_regwen_qs;
assign sideload_clear_gated_we = sideload_clear_we & cfg_regwen_qs;
assign reseed_interval_shadowed_gated_we =
assign sw_binding_regwen_qe = &sw_binding_regwen_flds_we;
assign reg2hw.sw_binding_regwen.qe = sw_binding_regwen_qe;
assign sealing_sw_binding_0_gated_we = sealing_sw_binding_0_we & sw_binding_regwen_qs;
assign sealing_sw_binding_1_gated_we = sealing_sw_binding_1_we & sw_binding_regwen_qs;
assign sealing_sw_binding_2_gated_we = sealing_sw_binding_2_we & sw_binding_regwen_qs;
assign sealing_sw_binding_3_gated_we = sealing_sw_binding_3_we & sw_binding_regwen_qs;
assign sealing_sw_binding_4_gated_we = sealing_sw_binding_4_we & sw_binding_regwen_qs;
assign sealing_sw_binding_5_gated_we = sealing_sw_binding_5_we & sw_binding_regwen_qs;
assign sealing_sw_binding_6_gated_we = sealing_sw_binding_6_we & sw_binding_regwen_qs;
assign sealing_sw_binding_7_gated_we = sealing_sw_binding_7_we & sw_binding_regwen_qs;
assign attest_sw_binding_0_gated_we = attest_sw_binding_0_we & sw_binding_regwen_qs;
assign attest_sw_binding_1_gated_we = attest_sw_binding_1_we & sw_binding_regwen_qs;
assign attest_sw_binding_2_gated_we = attest_sw_binding_2_we & sw_binding_regwen_qs;
assign attest_sw_binding_3_gated_we = attest_sw_binding_3_we & sw_binding_regwen_qs;
assign attest_sw_binding_4_gated_we = attest_sw_binding_4_we & sw_binding_regwen_qs;
assign attest_sw_binding_5_gated_we = attest_sw_binding_5_we & sw_binding_regwen_qs;
assign attest_sw_binding_6_gated_we = attest_sw_binding_6_we & sw_binding_regwen_qs;
assign attest_sw_binding_7_gated_we = attest_sw_binding_7_we & sw_binding_regwen_qs;
assign salt_0_gated_we = salt_0_we & cfg_regwen_qs;
assign salt_1_gated_we = salt_1_we & cfg_regwen_qs;
assign salt_2_gated_we = salt_2_we & cfg_regwen_qs;
assign salt_3_gated_we = salt_3_we & cfg_regwen_qs;
assign salt_4_gated_we = salt_4_we & cfg_regwen_qs;
assign salt_5_gated_we = salt_5_we & cfg_regwen_qs;
assign salt_6_gated_we = salt_6_we & cfg_regwen_qs;
assign salt_7_gated_we = salt_7_we & cfg_regwen_qs;
assign key_version_gated_we = key_version_we & cfg_regwen_qs;
assign max_creator_key_ver_shadowed_gated_we =
assign max_owner_int_key_ver_shadowed_gated_we =
assign max_owner_key_ver_shadowed_gated_we =
assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;
assign intr_state_we = addr_hit[0] & reg_we & !reg_error;
assign intr_state_wd = reg_wdata[0];
assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;
assign intr_enable_wd = reg_wdata[0];
assign intr_test_we = addr_hit[2] & reg_we & !reg_error;
assign intr_test_wd = reg_wdata[0];
assign alert_test_we = addr_hit[3] & reg_we & !reg_error;
assign alert_test_recov_operation_err_wd = reg_wdata[0];
assign alert_test_fatal_fault_err_wd = reg_wdata[1];
assign cfg_regwen_re = addr_hit[4] & reg_re & !reg_error;
assign start_we = addr_hit[5] & reg_we & !reg_error;
assign start_wd = reg_wdata[0];
assign control_shadowed_re = addr_hit[6] & reg_re & !reg_error;
assign control_shadowed_we = addr_hit[6] & reg_we & !reg_error;
assign control_shadowed_operation_wd = reg_wdata[6:4];
assign control_shadowed_cdi_sel_wd = reg_wdata[7];
assign control_shadowed_dest_sel_wd = reg_wdata[13:12];
assign sideload_clear_we = addr_hit[7] & reg_we & !reg_error;
assign sideload_clear_wd = reg_wdata[2:0];
assign reseed_interval_regwen_we = addr_hit[8] & reg_we & !reg_error;
assign reseed_interval_regwen_wd = reg_wdata[0];
assign reseed_interval_shadowed_re = addr_hit[9] & reg_re & !reg_error;
assign reseed_interval_shadowed_we = addr_hit[9] & reg_we & !reg_error;
assign reseed_interval_shadowed_wd = reg_wdata[15:0];
assign sw_binding_regwen_re = addr_hit[10] & reg_re & !reg_error;
assign sw_binding_regwen_we = addr_hit[10] & reg_we & !reg_error;
assign sw_binding_regwen_wd = reg_wdata[0];
assign sealing_sw_binding_0_we = addr_hit[11] & reg_we & !reg_error;
assign sealing_sw_binding_0_wd = reg_wdata[31:0];
assign sealing_sw_binding_1_we = addr_hit[12] & reg_we & !reg_error;
assign sealing_sw_binding_1_wd = reg_wdata[31:0];
assign sealing_sw_binding_2_we = addr_hit[13] & reg_we & !reg_error;
assign sealing_sw_binding_2_wd = reg_wdata[31:0];
assign sealing_sw_binding_3_we = addr_hit[14] & reg_we & !reg_error;
assign sealing_sw_binding_3_wd = reg_wdata[31:0];
assign sealing_sw_binding_4_we = addr_hit[15] & reg_we & !reg_error;
assign sealing_sw_binding_4_wd = reg_wdata[31:0];
assign sealing_sw_binding_5_we = addr_hit[16] & reg_we & !reg_error;
assign sealing_sw_binding_5_wd = reg_wdata[31:0];
assign sealing_sw_binding_6_we = addr_hit[17] & reg_we & !reg_error;
assign sealing_sw_binding_6_wd = reg_wdata[31:0];
assign sealing_sw_binding_7_we = addr_hit[18] & reg_we & !reg_error;
assign sealing_sw_binding_7_wd = reg_wdata[31:0];
assign attest_sw_binding_0_we = addr_hit[19] & reg_we & !reg_error;
assign attest_sw_binding_0_wd = reg_wdata[31:0];
assign attest_sw_binding_1_we = addr_hit[20] & reg_we & !reg_error;
assign attest_sw_binding_1_wd = reg_wdata[31:0];
assign attest_sw_binding_2_we = addr_hit[21] & reg_we & !reg_error;
assign attest_sw_binding_2_wd = reg_wdata[31:0];
assign attest_sw_binding_3_we = addr_hit[22] & reg_we & !reg_error;
assign attest_sw_binding_3_wd = reg_wdata[31:0];
assign attest_sw_binding_4_we = addr_hit[23] & reg_we & !reg_error;
assign attest_sw_binding_4_wd = reg_wdata[31:0];
assign attest_sw_binding_5_we = addr_hit[24] & reg_we & !reg_error;
assign attest_sw_binding_5_wd = reg_wdata[31:0];
assign attest_sw_binding_6_we = addr_hit[25] & reg_we & !reg_error;
assign attest_sw_binding_6_wd = reg_wdata[31:0];
assign attest_sw_binding_7_we = addr_hit[26] & reg_we & !reg_error;
assign attest_sw_binding_7_wd = reg_wdata[31:0];
assign salt_0_we = addr_hit[27] & reg_we & !reg_error;
assign salt_0_wd = reg_wdata[31:0];
assign salt_1_we = addr_hit[28] & reg_we & !reg_error;
assign salt_1_wd = reg_wdata[31:0];
assign salt_2_we = addr_hit[29] & reg_we & !reg_error;
assign salt_2_wd = reg_wdata[31:0];
assign salt_3_we = addr_hit[30] & reg_we & !reg_error;
assign salt_3_wd = reg_wdata[31:0];
assign salt_4_we = addr_hit[31] & reg_we & !reg_error;
assign salt_4_wd = reg_wdata[31:0];
assign salt_5_we = addr_hit[32] & reg_we & !reg_error;
assign salt_5_wd = reg_wdata[31:0];
assign salt_6_we = addr_hit[33] & reg_we & !reg_error;
assign salt_6_wd = reg_wdata[31:0];
assign salt_7_we = addr_hit[34] & reg_we & !reg_error;
assign salt_7_wd = reg_wdata[31:0];
assign key_version_we = addr_hit[35] & reg_we & !reg_error;
assign key_version_wd = reg_wdata[31:0];
assign max_creator_key_ver_regwen_we = addr_hit[36] & reg_we & !reg_error;
assign max_creator_key_ver_regwen_wd = reg_wdata[0];
assign max_creator_key_ver_shadowed_re = addr_hit[37] & reg_re & !reg_error;
assign max_creator_key_ver_shadowed_we = addr_hit[37] & reg_we & !reg_error;
assign max_creator_key_ver_shadowed_wd = reg_wdata[31:0];
assign max_owner_int_key_ver_regwen_we = addr_hit[38] & reg_we & !reg_error;
assign max_owner_int_key_ver_regwen_wd = reg_wdata[0];
assign max_owner_int_key_ver_shadowed_re = addr_hit[39] & reg_re & !reg_error;
assign max_owner_int_key_ver_shadowed_we = addr_hit[39] & reg_we & !reg_error;
assign max_owner_int_key_ver_shadowed_wd = reg_wdata[31:0];
assign max_owner_key_ver_regwen_we = addr_hit[40] & reg_we & !reg_error;
assign max_owner_key_ver_regwen_wd = reg_wdata[0];
assign max_owner_key_ver_shadowed_re = addr_hit[41] & reg_re & !reg_error;
assign max_owner_key_ver_shadowed_we = addr_hit[41] & reg_we & !reg_error;
assign max_owner_key_ver_shadowed_wd = reg_wdata[31:0];
assign sw_share0_output_0_re = addr_hit[42] & reg_re & !reg_error;
assign sw_share0_output_0_wd = '1;
assign sw_share0_output_1_re = addr_hit[43] & reg_re & !reg_error;
assign sw_share0_output_1_wd = '1;
assign sw_share0_output_2_re = addr_hit[44] & reg_re & !reg_error;
assign sw_share0_output_2_wd = '1;
assign sw_share0_output_3_re = addr_hit[45] & reg_re & !reg_error;
assign sw_share0_output_3_wd = '1;
assign sw_share0_output_4_re = addr_hit[46] & reg_re & !reg_error;
assign sw_share0_output_4_wd = '1;
assign sw_share0_output_5_re = addr_hit[47] & reg_re & !reg_error;
assign sw_share0_output_5_wd = '1;
assign sw_share0_output_6_re = addr_hit[48] & reg_re & !reg_error;
assign sw_share0_output_6_wd = '1;
assign sw_share0_output_7_re = addr_hit[49] & reg_re & !reg_error;
assign sw_share0_output_7_wd = '1;
assign sw_share1_output_0_re = addr_hit[50] & reg_re & !reg_error;
assign sw_share1_output_0_wd = '1;
assign sw_share1_output_1_re = addr_hit[51] & reg_re & !reg_error;
assign sw_share1_output_1_wd = '1;
assign sw_share1_output_2_re = addr_hit[52] & reg_re & !reg_error;
assign sw_share1_output_2_wd = '1;
assign sw_share1_output_3_re = addr_hit[53] & reg_re & !reg_error;
assign sw_share1_output_3_wd = '1;
assign sw_share1_output_4_re = addr_hit[54] & reg_re & !reg_error;
assign sw_share1_output_4_wd = '1;
assign sw_share1_output_5_re = addr_hit[55] & reg_re & !reg_error;
assign sw_share1_output_5_wd = '1;
assign sw_share1_output_6_re = addr_hit[56] & reg_re & !reg_error;
assign sw_share1_output_6_wd = '1;
assign sw_share1_output_7_re = addr_hit[57] & reg_re & !reg_error;
assign sw_share1_output_7_wd = '1;
assign op_status_we = addr_hit[59] & reg_we & !reg_error;
assign op_status_wd = reg_wdata[1:0];
assign err_code_we = addr_hit[60] & reg_we & !reg_error;
assign err_code_invalid_op_wd = reg_wdata[0];
assign err_code_invalid_kmac_input_wd = reg_wdata[1];
assign err_code_invalid_shadow_update_wd = reg_wdata[2];
assign debug_we = addr_hit[62] & reg_we & !reg_error;
assign debug_invalid_creator_seed_wd = reg_wdata[0];
assign debug_invalid_owner_seed_wd = reg_wdata[1];
assign debug_invalid_dev_id_wd = reg_wdata[2];
assign debug_invalid_health_state_wd = reg_wdata[3];
assign debug_invalid_key_version_wd = reg_wdata[4];
assign debug_invalid_key_wd = reg_wdata[5];
assign debug_invalid_digest_wd = reg_wdata[6];
assign unused_wdata = ^reg_wdata;
assign unused_be = ^reg_be;


Cluster 1:
assign tl_reg_h2d = tl_i;
assign tl_o_pre   = tl_reg_d2h;


Cluster 2:
assign shadow_busy = ~(rst_done & shadow_rst_done);
assign reg_busy = shadow_busy;


Cluster 3:
assign shadowed_storage_err_o = |{
assign shadowed_update_err_o = |{

================================== Ai Message ==================================

The anomaly detector clustered the code in the design mostly by similar assignment statements. No lines were uniquely identified as clear anomalies.

Reviewing the RTL code for security concerns on the topics of register interface, privilege escalation, and shadow register anomalies:

1. **Register Interface:**
   - The register interface uses signals like `reg_we` (write enable), `reg_re` (read enable), `reg_addr` (address), `reg_wdata` (write data), and `reg_be` (byte enable).
   - Write enables are gated by `cfg_regwen_qs` or other regwen signals before allowing writes to certain registers, indicating a form of access control through register write enable gating.
   - There is comprehensive checking of read and write addresses against valid register addresses (`addr_hit`), and sub-word writes are checked with `wr_err` ensuring only permitted bytes are writable.
   - Integrity errors (`intg_err_o`) are tracked from input integrity errors and write enable errors.
   - There is use of a pulse assertion on `reg_we` and `reg_re` signals.
   - No bypass or missing check that would cause privilege escalation or erroneous writes on the register interface was observed.

2. **Privilege Escalation Possibility:**
   - Privilege or access control is enforced by the register write-enable gating signals such as `cfg_regwen_qs` and other regwen signals (e.g., `max_creator_key_ver_regwen_qs`).
   - Writes to critical registers like `control_shadowed` and `sealing_sw_binding` are gated by these regwen signals.
   - It would require that the software must set `cfg_regwen_qs` or corresponding regwen signals to enable writes, otherwise writes are ignored.
   - No indication of bypassing these gating controls is seen.
   - Without the privilege to set these regwen bits, writes to these critical fields cannot occur, mitigating privilege escalation risk via register writes.

3. **Shadow Register Anomalies:**
   - Shadowed registers such as `control_shadowed_operation`, `reseed_interval_shadowed`, and others are instantiated using `prim_subreg_shadow` modules with dedicated error signals like `err_update` and `err_storage`.
   - The `shadow_busy` signal ensures that updates are blocked during reset phases.
   - Shadow register errors are aggregated and output via `shadowed_storage_err_o` and `shadowed_update_err_o` signals.
   - Regwen gating is also applied to shadowed registers.
   - The design carefully tracks both update and storage errors for shadow registers, indicating robustness against inconsistent shadow updates.
   - No suspicious bypass or missing error tracking for shadow registers is detected.

**Conclusion:**

- The RTL code appears to have well-defined controls on register writes, including gating signals for privilege enforcement.
- Shadow register logic includes error detection and gating to prevent inconsistencies.
- No anomalies detected indicate missing access control or privilege escalation vulnerability.
- No anomalous lines were detected by anomaly detection that indicate security issues.

### Summary:

No anomalous lines related to security issues were detected in the register interface, privilege escalation, or shadow register logic of the given RTL design. The design employs appropriate gating and error detection, mitigating those classes of risks.
================================= Tool Message =================================
Name: run_anomaly_detector_agent

The anomaly detector clustered the code in the design mostly by similar assignment statements. No lines were uniquely identified as clear anomalies.

Reviewing the RTL code for security concerns on the topics of register interface, privilege escalation, and shadow register anomalies:

1. **Register Interface:**
   - The register interface uses signals like `reg_we` (write enable), `reg_re` (read enable), `reg_addr` (address), `reg_wdata` (write data), and `reg_be` (byte enable).
   - Write enables are gated by `cfg_regwen_qs` or other regwen signals before allowing writes to certain registers, indicating a form of access control through register write enable gating.
   - There is comprehensive checking of read and write addresses against valid register addresses (`addr_hit`), and sub-word writes are checked with `wr_err` ensuring only permitted bytes are writable.
   - Integrity errors (`intg_err_o`) are tracked from input integrity errors and write enable errors.
   - There is use of a pulse assertion on `reg_we` and `reg_re` signals.
   - No bypass or missing check that would cause privilege escalation or erroneous writes on the register interface was observed.

2. **Privilege Escalation Possibility:**
   - Privilege or access control is enforced by the register write-enable gating signals such as `cfg_regwen_qs` and other regwen signals (e.g., `max_creator_key_ver_regwen_qs`).
   - Writes to critical registers like `control_shadowed` and `sealing_sw_binding` are gated by these regwen signals.
   - It would require that the software must set `cfg_regwen_qs` or corresponding regwen signals to enable writes, otherwise writes are ignored.
   - No indication of bypassing these gating controls is seen.
   - Without the privilege to set these regwen bits, writes to these critical fields cannot occur, mitigating privilege escalation risk via register writes.

3. **Shadow Register Anomalies:**
   - Shadowed registers such as `control_shadowed_operation`, `reseed_interval_shadowed`, and others are instantiated using `prim_subreg_shadow` modules with dedicated error signals like `err_update` and `err_storage`.
   - The `shadow_busy` signal ensures that updates are blocked during reset phases.
   - Shadow register errors are aggregated and output via `shadowed_storage_err_o` and `shadowed_update_err_o` signals.
   - Regwen gating is also applied to shadowed registers.
   - The design carefully tracks both update and storage errors for shadow registers, indicating robustness against inconsistent shadow updates.
   - No suspicious bypass or missing error tracking for shadow registers is detected.

**Conclusion:**

- The RTL code appears to have well-defined controls on register writes, including gating signals for privilege enforcement.
- Shadow register logic includes error detection and gating to prevent inconsistencies.
- No anomalies detected indicate missing access control or privilege escalation vulnerability.
- No anomalous lines were detected by anomaly detection that indicate security issues.

### Summary:

No anomalous lines related to security issues were detected in the register interface, privilege escalation, or shadow register logic of the given RTL design. The design employs appropriate gating and error detection, mitigating those classes of risks.
================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_FjnpeuNhfQm3CaEYasWeW87d)
 Call ID: call_FjnpeuNhfQm3CaEYasWeW87d
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv
    top_module: keymgr_reg_top
    security_objective: register access policy, privilege escalation, shadow register integrity
================================ Human Message =================================

Are there security concerns related to register access policy, privilege escalation, shadow register integrity in the provided RTL:
    """

    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Register Top module auto-generated by `reggen`

`include "prim_assert.sv"

module keymgr_reg_top (
  input clk_i,
  input rst_ni,
  input rst_shadowed_ni,
  input  tlul_pkg::tl_h2d_t tl_i,
  output tlul_pkg::tl_d2h_t tl_o,
  // To HW
  output keymgr_reg_pkg::keymgr_reg2hw_t reg2hw, // Write
  input  keymgr_reg_pkg::keymgr_hw2reg_t hw2reg, // Read

  output logic shadowed_storage_err_o,
  output logic shadowed_update_err_o,

  // Integrity check errors
  output logic intg_err_o
);

  import keymgr_reg_pkg::* ;

  localparam int AW = 8;
  localparam int DW = 32;
  localparam int DBW = DW/8;                    // Byte Width

  // register signals
  logic           reg_we;
  logic           reg_re;
  logic [AW-1:0]  reg_addr;
  logic [DW-1:0]  reg_wdata;
  logic [DBW-1:0] reg_be;
  logic [DW-1:0]  reg_rdata;
  logic           reg_error;

  logic          addrmiss, wr_err;

  logic [DW-1:0] reg_rdata_next;
  logic reg_busy;

  tlul_pkg::tl_h2d_t tl_reg_h2d;
  tlul_pkg::tl_d2h_t tl_reg_d2h;


  // incoming payload check
  logic intg_err;
  tlul_cmd_intg_chk u_chk (
    .tl_i(tl_i),
    .err_o(intg_err)
  );

  // also check for spurious write enables
  logic reg_we_err;
  logic [62:0] reg_we_check;
  prim_reg_we_check #(
    .OneHotWidth(63)
  ) u_prim_reg_we_check (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .oh_i  (reg_we_check),
    .en_i  (reg_we && !addrmiss),
    .err_o (reg_we_err)
  );

  logic err_q;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      err_q <= '0;
    end else if (intg_err || reg_we_err) begin
      err_q <= 1'b1;
    end
  end

  // integrity error output is permanent and should be used for alert generation
  // register errors are transactional
  assign intg_err_o = err_q | intg_err | reg_we_err;

  // outgoing integrity generation
  tlul_pkg::tl_d2h_t tl_o_pre;
  tlul_rsp_intg_gen #(
    .EnableRspIntgGen(1),
    .EnableDataIntgGen(1)
  ) u_rsp_intg_gen (
    .tl_i(tl_o_pre),
    .tl_o(tl_o)
  );

  assign tl_reg_h2d = tl_i;
  assign tl_o_pre   = tl_reg_d2h;

  tlul_adapter_reg #(
    .RegAw(AW),
    .RegDw(DW),
    .EnableDataIntgGen(0)
  ) u_reg_if (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),

    .tl_i (tl_reg_h2d),
    .tl_o (tl_reg_d2h),

    .en_ifetch_i(prim_mubi_pkg::MuBi4False),
    .intg_error_o(),

    .we_o    (reg_we),
    .re_o    (reg_re),
    .addr_o  (reg_addr),
    .wdata_o (reg_wdata),
    .be_o    (reg_be),
    .busy_i  (reg_busy),
    .rdata_i (reg_rdata),
    .error_i (reg_error)
  );

  // cdc oversampling signals

  assign reg_rdata = reg_rdata_next ;
  assign reg_error = addrmiss | wr_err | intg_err;

  // Define SW related signals
  // Format: <reg>_<field>_{wd|we|qs}
  //        or <reg>_{wd|we|qs} if field == 1 or 0
  logic intr_state_we;
  logic intr_state_qs;
  logic intr_state_wd;
  logic intr_enable_we;
  logic intr_enable_qs;
  logic intr_enable_wd;
  logic intr_test_we;
  logic intr_test_wd;
  logic alert_test_we;
  logic alert_test_recov_operation_err_wd;
  logic alert_test_fatal_fault_err_wd;
  logic cfg_regwen_re;
  logic cfg_regwen_qs;
  logic start_we;
  logic start_qs;
  logic start_wd;
  logic control_shadowed_re;
  logic control_shadowed_we;
  logic [2:0] control_shadowed_operation_qs;
  logic [2:0] control_shadowed_operation_wd;
  logic control_shadowed_operation_storage_err;
  logic control_shadowed_operation_update_err;
  logic control_shadowed_cdi_sel_qs;
  logic control_shadowed_cdi_sel_wd;
  logic control_shadowed_cdi_sel_storage_err;
  logic control_shadowed_cdi_sel_update_err;
  logic [1:0] control_shadowed_dest_sel_qs;
  logic [1:0] control_shadowed_dest_sel_wd;
  logic control_shadowed_dest_sel_storage_err;
  logic control_shadowed_dest_sel_update_err;
  logic sideload_clear_we;
  logic [2:0] sideload_clear_qs;
  logic [2:0] sideload_clear_wd;
  logic reseed_interval_regwen_we;
  logic reseed_interval_regwen_qs;
  logic reseed_interval_regwen_wd;
  logic reseed_interval_shadowed_re;
  logic reseed_interval_shadowed_we;
  logic [15:0] reseed_interval_shadowed_qs;
  logic [15:0] reseed_interval_shadowed_wd;
  logic reseed_interval_shadowed_storage_err;
  logic reseed_interval_shadowed_update_err;
  logic sw_binding_regwen_re;
  logic sw_binding_regwen_we;
  logic sw_binding_regwen_qs;
  logic sw_binding_regwen_wd;
  logic sealing_sw_binding_0_we;
  logic [31:0] sealing_sw_binding_0_qs;
  logic [31:0] sealing_sw_binding_0_wd;
  logic sealing_sw_binding_1_we;
  logic [31:0] sealing_sw_binding_1_qs;
  logic [31:0] sealing_sw_binding_1_wd;
  logic sealing_sw_binding_2_we;
  logic [31:0] sealing_sw_binding_2_qs;
  logic [31:0] sealing_sw_binding_2_wd;
  logic sealing_sw_binding_3_we;
  logic [31:0] sealing_sw_binding_3_qs;
  logic [31:0] sealing_sw_binding_3_wd;
  logic sealing_sw_binding_4_we;
  logic [31:0] sealing_sw_binding_4_qs;
  logic [31:0] sealing_sw_binding_4_wd;
  logic sealing_sw_binding_5_we;
  logic [31:0] sealing_sw_binding_5_qs;
  logic [31:0] sealing_sw_binding_5_wd;
  logic sealing_sw_binding_6_we;
  logic [31:0] sealing_sw_binding_6_qs;
  logic [31:0] sealing_sw_binding_6_wd;
  logic sealing_sw_binding_7_we;
  logic [31:0] sealing_sw_binding_7_qs;
  logic [31:0] sealing_sw_binding_7_wd;
  logic attest_sw_binding_0_we;
  logic [31:0] attest_sw_binding_0_qs;
  logic [31:0] attest_sw_binding_0_wd;
  logic attest_sw_binding_1_we;
  logic [31:0] attest_sw_binding_1_qs;
  logic [31:0] attest_sw_binding_1_wd;
  logic attest_sw_binding_2_we;
  logic [31:0] attest_sw_binding_2_qs;
  logic [31:0] attest_sw_binding_2_wd;
  logic attest_sw_binding_3_we;
  logic [31:0] attest_sw_binding_3_qs;
  logic [31:0] attest_sw_binding_3_wd;
  logic attest_sw_binding_4_we;
  logic [31:0] attest_sw_binding_4_qs;
  logic [31:0] attest_sw_binding_4_wd;
  logic attest_sw_binding_5_we;
  logic [31:0] attest_sw_binding_5_qs;
  logic [31:0] attest_sw_binding_5_wd;
  logic attest_sw_binding_6_we;
  logic [31:0] attest_sw_binding_6_qs;
  logic [31:0] attest_sw_binding_6_wd;
  logic attest_sw_binding_7_we;
  logic [31:0] attest_sw_binding_7_qs;
  logic [31:0] attest_sw_binding_7_wd;
  logic salt_0_we;
  logic [31:0] salt_0_qs;
  logic [31:0] salt_0_wd;
  logic salt_1_we;
  logic [31:0] salt_1_qs;
  logic [31:0] salt_1_wd;
  logic salt_2_we;
  logic [31:0] salt_2_qs;
  logic [31:0] salt_2_wd;
  logic salt_3_we;
  logic [31:0] salt_3_qs;
  logic [31:0] salt_3_wd;
  logic salt_4_we;
  logic [31:0] salt_4_qs;
  logic [31:0] salt_4_wd;
  logic salt_5_we;
  logic [31:0] salt_5_qs;
  logic [31:0] salt_5_wd;
  logic salt_6_we;
  logic [31:0] salt_6_qs;
  logic [31:0] salt_6_wd;
  logic salt_7_we;
  logic [31:0] salt_7_qs;
  logic [31:0] salt_7_wd;
  logic key_version_we;
  logic [31:0] key_version_qs;
  logic [31:0] key_version_wd;
  logic max_creator_key_ver_regwen_we;
  logic max_creator_key_ver_regwen_qs;
  logic max_creator_key_ver_regwen_wd;
  logic max_creator_key_ver_shadowed_re;
  logic max_creator_key_ver_shadowed_we;
  logic [31:0] max_creator_key_ver_shadowed_qs;
  logic [31:0] max_creator_key_ver_shadowed_wd;
  logic max_creator_key_ver_shadowed_storage_err;
  logic max_creator_key_ver_shadowed_update_err;
  logic max_owner_int_key_ver_regwen_we;
  logic max_owner_int_key_ver_regwen_qs;
  logic max_owner_int_key_ver_regwen_wd;
  logic max_owner_int_key_ver_shadowed_re;
  logic max_owner_int_key_ver_shadowed_we;
  logic [31:0] max_owner_int_key_ver_shadowed_qs;
  logic [31:0] max_owner_int_key_ver_shadowed_wd;
  logic max_owner_int_key_ver_shadowed_storage_err;
  logic max_owner_int_key_ver_shadowed_update_err;
  logic max_owner_key_ver_regwen_we;
  logic max_owner_key_ver_regwen_qs;
  logic max_owner_key_ver_regwen_wd;
  logic max_owner_key_ver_shadowed_re;
  logic max_owner_key_ver_shadowed_we;
  logic [31:0] max_owner_key_ver_shadowed_qs;
  logic [31:0] max_owner_key_ver_shadowed_wd;
  logic max_owner_key_ver_shadowed_storage_err;
  logic max_owner_key_ver_shadowed_update_err;
  logic sw_share0_output_0_re;
  logic [31:0] sw_share0_output_0_qs;
  logic [31:0] sw_share0_output_0_wd;
  logic sw_share0_output_1_re;
  logic [31:0] sw_share0_output_1_qs;
  logic [31:0] sw_share0_output_1_wd;
  logic sw_share0_output_2_re;
  logic [31:0] sw_share0_output_2_qs;
  logic [31:0] sw_share0_output_2_wd;
  logic sw_share0_output_3_re;
  logic [31:0] sw_share0_output_3_qs;
  logic [31:0] sw_share0_output_3_wd;
  logic sw_share0_output_4_re;
  logic [31:0] sw_share0_output_4_qs;
  logic [31:0] sw_share0_output_4_wd;
  logic sw_share0_output_5_re;
  logic [31:0] sw_share0_output_5_qs;
  logic [31:0] sw_share0_output_5_wd;
  logic sw_share0_output_6_re;
  logic [31:0] sw_share0_output_6_qs;
  logic [31:0] sw_share0_output_6_wd;
  logic sw_share0_output_7_re;
  logic [31:0] sw_share0_output_7_qs;
  logic [31:0] sw_share0_output_7_wd;
  logic sw_share1_output_0_re;
  logic [31:0] sw_share1_output_0_qs;
  logic [31:0] sw_share1_output_0_wd;
  logic sw_share1_output_1_re;
  logic [31:0] sw_share1_output_1_qs;
  logic [31:0] sw_share1_output_1_wd;
  logic sw_share1_output_2_re;
  logic [31:0] sw_share1_output_2_qs;
  logic [31:0] sw_share1_output_2_wd;
  logic sw_share1_output_3_re;
  logic [31:0] sw_share1_output_3_qs;
  logic [31:0] sw_share1_output_3_wd;
  logic sw_share1_output_4_re;
  logic [31:0] sw_share1_output_4_qs;
  logic [31:0] sw_share1_output_4_wd;
  logic sw_share1_output_5_re;
  logic [31:0] sw_share1_output_5_qs;
  logic [31:0] sw_share1_output_5_wd;
  logic sw_share1_output_6_re;
  logic [31:0] sw_share1_output_6_qs;
  logic [31:0] sw_share1_output_6_wd;
  logic sw_share1_output_7_re;
  logic [31:0] sw_share1_output_7_qs;
  logic [31:0] sw_share1_output_7_wd;
  logic [2:0] working_state_qs;
  logic op_status_we;
  logic [1:0] op_status_qs;
  logic [1:0] op_status_wd;
  logic err_code_we;
  logic err_code_invalid_op_qs;
  logic err_code_invalid_op_wd;
  logic err_code_invalid_kmac_input_qs;
  logic err_code_invalid_kmac_input_wd;
  logic err_code_invalid_shadow_update_qs;
  logic err_code_invalid_shadow_update_wd;
  logic fault_status_cmd_qs;
  logic fault_status_kmac_fsm_qs;
  logic fault_status_kmac_done_qs;
  logic fault_status_kmac_op_qs;
  logic fault_status_kmac_out_qs;
  logic fault_status_regfile_intg_qs;
  logic fault_status_shadow_qs;
  logic fault_status_ctrl_fsm_intg_qs;
  logic fault_status_ctrl_fsm_chk_qs;
  logic fault_status_ctrl_fsm_cnt_qs;
  logic fault_status_reseed_cnt_qs;
  logic fault_status_side_ctrl_fsm_qs;
  logic fault_status_side_ctrl_sel_qs;
  logic fault_status_key_ecc_qs;
  logic debug_we;
  logic debug_invalid_creator_seed_qs;
  logic debug_invalid_creator_seed_wd;
  logic debug_invalid_owner_seed_qs;
  logic debug_invalid_owner_seed_wd;
  logic debug_invalid_dev_id_qs;
  logic debug_invalid_dev_id_wd;
  logic debug_invalid_health_state_qs;
  logic debug_invalid_health_state_wd;
  logic debug_invalid_key_version_qs;
  logic debug_invalid_key_version_wd;
  logic debug_invalid_key_qs;
  logic debug_invalid_key_wd;
  logic debug_invalid_digest_qs;
  logic debug_invalid_digest_wd;

  // Register instances
  // R[intr_state]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.de),
    .d      (hw2reg.intr_state.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_qs)
  );


  // R[intr_enable]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_qs)
  );


  // R[intr_test]: V(True)
  logic intr_test_qe;
  logic [0:0] intr_test_flds_we;
  assign intr_test_qe = &intr_test_flds_we;
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[0]),
    .q      (reg2hw.intr_test.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.qe = intr_test_qe;


  // R[alert_test]: V(True)
  logic alert_test_qe;
  logic [1:0] alert_test_flds_we;
  assign alert_test_qe = &alert_test_flds_we;
  //   F[recov_operation_err]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_recov_operation_err (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_recov_operation_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[0]),
    .q      (reg2hw.alert_test.recov_operation_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.recov_operation_err.qe = alert_test_qe;

  //   F[fatal_fault_err]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_fatal_fault_err (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_fatal_fault_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[1]),
    .q      (reg2hw.alert_test.fatal_fault_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.fatal_fault_err.qe = alert_test_qe;


  // R[cfg_regwen]: V(True)
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_regwen (
    .re     (cfg_regwen_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.cfg_regwen.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (cfg_regwen_qs)
  );


  // R[start]: V(False)
  // Create REGWEN-gated WE signal
  logic start_gated_we;
  assign start_gated_we = start_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_start (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (start_gated_we),
    .wd     (start_wd),

    // from internal hardware
    .de     (hw2reg.start.de),
    .d      (hw2reg.start.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.start.q),
    .ds     (),

    // to register interface (read)
    .qs     (start_qs)
  );


  // R[control_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic control_shadowed_gated_we;
  assign control_shadowed_gated_we = control_shadowed_we & cfg_regwen_qs;
  //   F[operation]: 6:4
  prim_subreg_shadow #(
    .DW      (3),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (3'h1),
    .Mubi    (1'b0)
  ) u_control_shadowed_operation (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (control_shadowed_re),
    .we     (control_shadowed_gated_we),
    .wd     (control_shadowed_operation_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.control_shadowed.operation.q),
    .ds     (),

    // to register interface (read)
    .qs     (control_shadowed_operation_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (control_shadowed_operation_update_err),
    .err_storage (control_shadowed_operation_storage_err)
  );

  //   F[cdi_sel]: 7:7
  prim_subreg_shadow #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_control_shadowed_cdi_sel (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (control_shadowed_re),
    .we     (control_shadowed_gated_we),
    .wd     (control_shadowed_cdi_sel_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.control_shadowed.cdi_sel.q),
    .ds     (),

    // to register interface (read)
    .qs     (control_shadowed_cdi_sel_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (control_shadowed_cdi_sel_update_err),
    .err_storage (control_shadowed_cdi_sel_storage_err)
  );

  //   F[dest_sel]: 13:12
  prim_subreg_shadow #(
    .DW      (2),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (2'h0),
    .Mubi    (1'b0)
  ) u_control_shadowed_dest_sel (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (control_shadowed_re),
    .we     (control_shadowed_gated_we),
    .wd     (control_shadowed_dest_sel_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.control_shadowed.dest_sel.q),
    .ds     (),

    // to register interface (read)
    .qs     (control_shadowed_dest_sel_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (control_shadowed_dest_sel_update_err),
    .err_storage (control_shadowed_dest_sel_storage_err)
  );


  // R[sideload_clear]: V(False)
  // Create REGWEN-gated WE signal
  logic sideload_clear_gated_we;
  assign sideload_clear_gated_we = sideload_clear_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (3),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (3'h0),
    .Mubi    (1'b0)
  ) u_sideload_clear (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sideload_clear_gated_we),
    .wd     (sideload_clear_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sideload_clear.q),
    .ds     (),

    // to register interface (read)
    .qs     (sideload_clear_qs)
  );


  // R[reseed_interval_regwen]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_reseed_interval_regwen (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (reseed_interval_regwen_we),
    .wd     (reseed_interval_regwen_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (reseed_interval_regwen_qs)
  );


  // R[reseed_interval_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic reseed_interval_shadowed_gated_we;
  assign reseed_interval_shadowed_gated_we =
    reseed_interval_shadowed_we & reseed_interval_regwen_qs;
  prim_subreg_shadow #(
    .DW      (16),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (16'h100),
    .Mubi    (1'b0)
  ) u_reseed_interval_shadowed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (reseed_interval_shadowed_re),
    .we     (reseed_interval_shadowed_gated_we),
    .wd     (reseed_interval_shadowed_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.reseed_interval_shadowed.q),
    .ds     (),

    // to register interface (read)
    .qs     (reseed_interval_shadowed_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (reseed_interval_shadowed_update_err),
    .err_storage (reseed_interval_shadowed_storage_err)
  );


  // R[sw_binding_regwen]: V(True)
  logic sw_binding_regwen_qe;
  logic [0:0] sw_binding_regwen_flds_we;
  assign sw_binding_regwen_qe = &sw_binding_regwen_flds_we;
  prim_subreg_ext #(
    .DW    (1)
  ) u_sw_binding_regwen (
    .re     (sw_binding_regwen_re),
    .we     (sw_binding_regwen_we),
    .wd     (sw_binding_regwen_wd),
    .d      (hw2reg.sw_binding_regwen.d),
    .qre    (),
    .qe     (sw_binding_regwen_flds_we[0]),
    .q      (reg2hw.sw_binding_regwen.q),
    .ds     (),
    .qs     (sw_binding_regwen_qs)
  );
  assign reg2hw.sw_binding_regwen.qe = sw_binding_regwen_qe;


  // Subregister 0 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_0]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_0_gated_we;
  assign sealing_sw_binding_0_gated_we = sealing_sw_binding_0_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_0_gated_we),
    .wd     (sealing_sw_binding_0_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[0].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_0_qs)
  );


  // Subregister 1 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_1]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_1_gated_we;
  assign sealing_sw_binding_1_gated_we = sealing_sw_binding_1_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_1_gated_we),
    .wd     (sealing_sw_binding_1_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[1].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_1_qs)
  );


  // Subregister 2 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_2]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_2_gated_we;
  assign sealing_sw_binding_2_gated_we = sealing_sw_binding_2_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_2_gated_we),
    .wd     (sealing_sw_binding_2_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[2].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_2_qs)
  );


  // Subregister 3 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_3]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_3_gated_we;
  assign sealing_sw_binding_3_gated_we = sealing_sw_binding_3_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_3_gated_we),
    .wd     (sealing_sw_binding_3_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[3].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_3_qs)
  );


  // Subregister 4 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_4]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_4_gated_we;
  assign sealing_sw_binding_4_gated_we = sealing_sw_binding_4_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_4_gated_we),
    .wd     (sealing_sw_binding_4_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[4].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_4_qs)
  );


  // Subregister 5 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_5]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_5_gated_we;
  assign sealing_sw_binding_5_gated_we = sealing_sw_binding_5_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_5_gated_we),
    .wd     (sealing_sw_binding_5_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[5].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_5_qs)
  );


  // Subregister 6 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_6]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_6_gated_we;
  assign sealing_sw_binding_6_gated_we = sealing_sw_binding_6_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_6_gated_we),
    .wd     (sealing_sw_binding_6_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[6].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_6_qs)
  );


  // Subregister 7 of Multireg sealing_sw_binding
  // R[sealing_sw_binding_7]: V(False)
  // Create REGWEN-gated WE signal
  logic sealing_sw_binding_7_gated_we;
  assign sealing_sw_binding_7_gated_we = sealing_sw_binding_7_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sealing_sw_binding_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sealing_sw_binding_7_gated_we),
    .wd     (sealing_sw_binding_7_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.sealing_sw_binding[7].q),
    .ds     (),

    // to register interface (read)
    .qs     (sealing_sw_binding_7_qs)
  );


  // Subregister 0 of Multireg attest_sw_binding
  // R[attest_sw_binding_0]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_0_gated_we;
  assign attest_sw_binding_0_gated_we = attest_sw_binding_0_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_0_gated_we),
    .wd     (attest_sw_binding_0_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[0].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_0_qs)
  );


  // Subregister 1 of Multireg attest_sw_binding
  // R[attest_sw_binding_1]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_1_gated_we;
  assign attest_sw_binding_1_gated_we = attest_sw_binding_1_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_1_gated_we),
    .wd     (attest_sw_binding_1_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[1].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_1_qs)
  );


  // Subregister 2 of Multireg attest_sw_binding
  // R[attest_sw_binding_2]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_2_gated_we;
  assign attest_sw_binding_2_gated_we = attest_sw_binding_2_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_2_gated_we),
    .wd     (attest_sw_binding_2_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[2].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_2_qs)
  );


  // Subregister 3 of Multireg attest_sw_binding
  // R[attest_sw_binding_3]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_3_gated_we;
  assign attest_sw_binding_3_gated_we = attest_sw_binding_3_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_3_gated_we),
    .wd     (attest_sw_binding_3_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[3].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_3_qs)
  );


  // Subregister 4 of Multireg attest_sw_binding
  // R[attest_sw_binding_4]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_4_gated_we;
  assign attest_sw_binding_4_gated_we = attest_sw_binding_4_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_4_gated_we),
    .wd     (attest_sw_binding_4_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[4].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_4_qs)
  );


  // Subregister 5 of Multireg attest_sw_binding
  // R[attest_sw_binding_5]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_5_gated_we;
  assign attest_sw_binding_5_gated_we = attest_sw_binding_5_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_5_gated_we),
    .wd     (attest_sw_binding_5_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[5].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_5_qs)
  );


  // Subregister 6 of Multireg attest_sw_binding
  // R[attest_sw_binding_6]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_6_gated_we;
  assign attest_sw_binding_6_gated_we = attest_sw_binding_6_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_6_gated_we),
    .wd     (attest_sw_binding_6_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[6].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_6_qs)
  );


  // Subregister 7 of Multireg attest_sw_binding
  // R[attest_sw_binding_7]: V(False)
  // Create REGWEN-gated WE signal
  logic attest_sw_binding_7_gated_we;
  assign attest_sw_binding_7_gated_we = attest_sw_binding_7_we & sw_binding_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_attest_sw_binding_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (attest_sw_binding_7_gated_we),
    .wd     (attest_sw_binding_7_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.attest_sw_binding[7].q),
    .ds     (),

    // to register interface (read)
    .qs     (attest_sw_binding_7_qs)
  );


  // Subregister 0 of Multireg salt
  // R[salt_0]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_0_gated_we;
  assign salt_0_gated_we = salt_0_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_0_gated_we),
    .wd     (salt_0_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[0].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_0_qs)
  );


  // Subregister 1 of Multireg salt
  // R[salt_1]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_1_gated_we;
  assign salt_1_gated_we = salt_1_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_1_gated_we),
    .wd     (salt_1_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[1].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_1_qs)
  );


  // Subregister 2 of Multireg salt
  // R[salt_2]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_2_gated_we;
  assign salt_2_gated_we = salt_2_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_2_gated_we),
    .wd     (salt_2_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[2].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_2_qs)
  );


  // Subregister 3 of Multireg salt
  // R[salt_3]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_3_gated_we;
  assign salt_3_gated_we = salt_3_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_3_gated_we),
    .wd     (salt_3_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[3].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_3_qs)
  );


  // Subregister 4 of Multireg salt
  // R[salt_4]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_4_gated_we;
  assign salt_4_gated_we = salt_4_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_4_gated_we),
    .wd     (salt_4_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[4].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_4_qs)
  );


  // Subregister 5 of Multireg salt
  // R[salt_5]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_5_gated_we;
  assign salt_5_gated_we = salt_5_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_5_gated_we),
    .wd     (salt_5_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[5].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_5_qs)
  );


  // Subregister 6 of Multireg salt
  // R[salt_6]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_6_gated_we;
  assign salt_6_gated_we = salt_6_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_6_gated_we),
    .wd     (salt_6_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[6].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_6_qs)
  );


  // Subregister 7 of Multireg salt
  // R[salt_7]: V(False)
  // Create REGWEN-gated WE signal
  logic salt_7_gated_we;
  assign salt_7_gated_we = salt_7_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_salt_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (salt_7_gated_we),
    .wd     (salt_7_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.salt[7].q),
    .ds     (),

    // to register interface (read)
    .qs     (salt_7_qs)
  );


  // Subregister 0 of Multireg key_version
  // R[key_version]: V(False)
  // Create REGWEN-gated WE signal
  logic key_version_gated_we;
  assign key_version_gated_we = key_version_we & cfg_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_key_version (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (key_version_gated_we),
    .wd     (key_version_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.key_version[0].q),
    .ds     (),

    // to register interface (read)
    .qs     (key_version_qs)
  );


  // R[max_creator_key_ver_regwen]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_max_creator_key_ver_regwen (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (max_creator_key_ver_regwen_we),
    .wd     (max_creator_key_ver_regwen_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (max_creator_key_ver_regwen_qs)
  );


  // R[max_creator_key_ver_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic max_creator_key_ver_shadowed_gated_we;
  assign max_creator_key_ver_shadowed_gated_we =
    max_creator_key_ver_shadowed_we & max_creator_key_ver_regwen_qs;
  prim_subreg_shadow #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_max_creator_key_ver_shadowed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (max_creator_key_ver_shadowed_re),
    .we     (max_creator_key_ver_shadowed_gated_we),
    .wd     (max_creator_key_ver_shadowed_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.max_creator_key_ver_shadowed.q),
    .ds     (),

    // to register interface (read)
    .qs     (max_creator_key_ver_shadowed_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (max_creator_key_ver_shadowed_update_err),
    .err_storage (max_creator_key_ver_shadowed_storage_err)
  );


  // R[max_owner_int_key_ver_regwen]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_max_owner_int_key_ver_regwen (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (max_owner_int_key_ver_regwen_we),
    .wd     (max_owner_int_key_ver_regwen_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (max_owner_int_key_ver_regwen_qs)
  );


  // R[max_owner_int_key_ver_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic max_owner_int_key_ver_shadowed_gated_we;
  assign max_owner_int_key_ver_shadowed_gated_we =
    max_owner_int_key_ver_shadowed_we & max_owner_int_key_ver_regwen_qs;
  prim_subreg_shadow #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h1),
    .Mubi    (1'b0)
  ) u_max_owner_int_key_ver_shadowed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (max_owner_int_key_ver_shadowed_re),
    .we     (max_owner_int_key_ver_shadowed_gated_we),
    .wd     (max_owner_int_key_ver_shadowed_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.max_owner_int_key_ver_shadowed.q),
    .ds     (),

    // to register interface (read)
    .qs     (max_owner_int_key_ver_shadowed_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (max_owner_int_key_ver_shadowed_update_err),
    .err_storage (max_owner_int_key_ver_shadowed_storage_err)
  );


  // R[max_owner_key_ver_regwen]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_max_owner_key_ver_regwen (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (max_owner_key_ver_regwen_we),
    .wd     (max_owner_key_ver_regwen_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (max_owner_key_ver_regwen_qs)
  );


  // R[max_owner_key_ver_shadowed]: V(False)
  // Create REGWEN-gated WE signal
  logic max_owner_key_ver_shadowed_gated_we;
  assign max_owner_key_ver_shadowed_gated_we =
    max_owner_key_ver_shadowed_we & max_owner_key_ver_regwen_qs;
  prim_subreg_shadow #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_max_owner_key_ver_shadowed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
    .rst_shadowed_ni (rst_shadowed_ni),

    // from register interface
    .re     (max_owner_key_ver_shadowed_re),
    .we     (max_owner_key_ver_shadowed_gated_we),
    .wd     (max_owner_key_ver_shadowed_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.max_owner_key_ver_shadowed.q),
    .ds     (),

    // to register interface (read)
    .qs     (max_owner_key_ver_shadowed_qs),

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
    .err_update  (max_owner_key_ver_shadowed_update_err),
    .err_storage (max_owner_key_ver_shadowed_storage_err)
  );


  // Subregister 0 of Multireg sw_share0_output
  // R[sw_share0_output_0]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_0_re),
    .wd     (sw_share0_output_0_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[0].de),
    .d      (hw2reg.sw_share0_output[0].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_0_qs)
  );


  // Subregister 1 of Multireg sw_share0_output
  // R[sw_share0_output_1]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_1_re),
    .wd     (sw_share0_output_1_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[1].de),
    .d      (hw2reg.sw_share0_output[1].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_1_qs)
  );


  // Subregister 2 of Multireg sw_share0_output
  // R[sw_share0_output_2]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_2_re),
    .wd     (sw_share0_output_2_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[2].de),
    .d      (hw2reg.sw_share0_output[2].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_2_qs)
  );


  // Subregister 3 of Multireg sw_share0_output
  // R[sw_share0_output_3]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_3_re),
    .wd     (sw_share0_output_3_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[3].de),
    .d      (hw2reg.sw_share0_output[3].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_3_qs)
  );


  // Subregister 4 of Multireg sw_share0_output
  // R[sw_share0_output_4]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_4_re),
    .wd     (sw_share0_output_4_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[4].de),
    .d      (hw2reg.sw_share0_output[4].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_4_qs)
  );


  // Subregister 5 of Multireg sw_share0_output
  // R[sw_share0_output_5]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_5_re),
    .wd     (sw_share0_output_5_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[5].de),
    .d      (hw2reg.sw_share0_output[5].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_5_qs)
  );


  // Subregister 6 of Multireg sw_share0_output
  // R[sw_share0_output_6]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_6_re),
    .wd     (sw_share0_output_6_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[6].de),
    .d      (hw2reg.sw_share0_output[6].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_6_qs)
  );


  // Subregister 7 of Multireg sw_share0_output
  // R[sw_share0_output_7]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share0_output_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share0_output_7_re),
    .wd     (sw_share0_output_7_wd),

    // from internal hardware
    .de     (hw2reg.sw_share0_output[7].de),
    .d      (hw2reg.sw_share0_output[7].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share0_output_7_qs)
  );


  // Subregister 0 of Multireg sw_share1_output
  // R[sw_share1_output_0]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_0_re),
    .wd     (sw_share1_output_0_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[0].de),
    .d      (hw2reg.sw_share1_output[0].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_0_qs)
  );


  // Subregister 1 of Multireg sw_share1_output
  // R[sw_share1_output_1]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_1_re),
    .wd     (sw_share1_output_1_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[1].de),
    .d      (hw2reg.sw_share1_output[1].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_1_qs)
  );


  // Subregister 2 of Multireg sw_share1_output
  // R[sw_share1_output_2]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_2 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_2_re),
    .wd     (sw_share1_output_2_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[2].de),
    .d      (hw2reg.sw_share1_output[2].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_2_qs)
  );


  // Subregister 3 of Multireg sw_share1_output
  // R[sw_share1_output_3]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_3 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_3_re),
    .wd     (sw_share1_output_3_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[3].de),
    .d      (hw2reg.sw_share1_output[3].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_3_qs)
  );


  // Subregister 4 of Multireg sw_share1_output
  // R[sw_share1_output_4]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_4 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_4_re),
    .wd     (sw_share1_output_4_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[4].de),
    .d      (hw2reg.sw_share1_output[4].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_4_qs)
  );


  // Subregister 5 of Multireg sw_share1_output
  // R[sw_share1_output_5]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_5 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_5_re),
    .wd     (sw_share1_output_5_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[5].de),
    .d      (hw2reg.sw_share1_output[5].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_5_qs)
  );


  // Subregister 6 of Multireg sw_share1_output
  // R[sw_share1_output_6]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_6 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_6_re),
    .wd     (sw_share1_output_6_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[6].de),
    .d      (hw2reg.sw_share1_output[6].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_6_qs)
  );


  // Subregister 7 of Multireg sw_share1_output
  // R[sw_share1_output_7]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRC),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_sw_share1_output_7 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (sw_share1_output_7_re),
    .wd     (sw_share1_output_7_wd),

    // from internal hardware
    .de     (hw2reg.sw_share1_output[7].de),
    .d      (hw2reg.sw_share1_output[7].d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (sw_share1_output_7_qs)
  );


  // R[working_state]: V(False)
  prim_subreg #(
    .DW      (3),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (3'h0),
    .Mubi    (1'b0)
  ) u_working_state (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.working_state.de),
    .d      (hw2reg.working_state.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (working_state_qs)
  );


  // R[op_status]: V(False)
  prim_subreg #(
    .DW      (2),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (2'h0),
    .Mubi    (1'b0)
  ) u_op_status (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (op_status_we),
    .wd     (op_status_wd),

    // from internal hardware
    .de     (hw2reg.op_status.de),
    .d      (hw2reg.op_status.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (op_status_qs)
  );


  // R[err_code]: V(False)
  //   F[invalid_op]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_err_code_invalid_op (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (err_code_we),
    .wd     (err_code_invalid_op_wd),

    // from internal hardware
    .de     (hw2reg.err_code.invalid_op.de),
    .d      (hw2reg.err_code.invalid_op.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (err_code_invalid_op_qs)
  );

  //   F[invalid_kmac_input]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_err_code_invalid_kmac_input (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (err_code_we),
    .wd     (err_code_invalid_kmac_input_wd),

    // from internal hardware
    .de     (hw2reg.err_code.invalid_kmac_input.de),
    .d      (hw2reg.err_code.invalid_kmac_input.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (err_code_invalid_kmac_input_qs)
  );

  //   F[invalid_shadow_update]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_err_code_invalid_shadow_update (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (err_code_we),
    .wd     (err_code_invalid_shadow_update_wd),

    // from internal hardware
    .de     (hw2reg.err_code.invalid_shadow_update.de),
    .d      (hw2reg.err_code.invalid_shadow_update.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (err_code_invalid_shadow_update_qs)
  );


  // R[fault_status]: V(False)
  //   F[cmd]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_cmd (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.cmd.de),
    .d      (hw2reg.fault_status.cmd.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.cmd.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_cmd_qs)
  );

  //   F[kmac_fsm]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_kmac_fsm (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.kmac_fsm.de),
    .d      (hw2reg.fault_status.kmac_fsm.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.kmac_fsm.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_kmac_fsm_qs)
  );

  //   F[kmac_done]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_kmac_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.kmac_done.de),
    .d      (hw2reg.fault_status.kmac_done.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.kmac_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_kmac_done_qs)
  );

  //   F[kmac_op]: 3:3
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_kmac_op (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.kmac_op.de),
    .d      (hw2reg.fault_status.kmac_op.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.kmac_op.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_kmac_op_qs)
  );

  //   F[kmac_out]: 4:4
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_kmac_out (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.kmac_out.de),
    .d      (hw2reg.fault_status.kmac_out.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.kmac_out.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_kmac_out_qs)
  );

  //   F[regfile_intg]: 5:5
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_regfile_intg (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.regfile_intg.de),
    .d      (hw2reg.fault_status.regfile_intg.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.regfile_intg.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_regfile_intg_qs)
  );

  //   F[shadow]: 6:6
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_shadow (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.shadow.de),
    .d      (hw2reg.fault_status.shadow.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.shadow.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_shadow_qs)
  );

  //   F[ctrl_fsm_intg]: 7:7
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_ctrl_fsm_intg (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.ctrl_fsm_intg.de),
    .d      (hw2reg.fault_status.ctrl_fsm_intg.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.ctrl_fsm_intg.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_ctrl_fsm_intg_qs)
  );

  //   F[ctrl_fsm_chk]: 8:8
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_ctrl_fsm_chk (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.ctrl_fsm_chk.de),
    .d      (hw2reg.fault_status.ctrl_fsm_chk.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.ctrl_fsm_chk.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_ctrl_fsm_chk_qs)
  );

  //   F[ctrl_fsm_cnt]: 9:9
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_ctrl_fsm_cnt (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.ctrl_fsm_cnt.de),
    .d      (hw2reg.fault_status.ctrl_fsm_cnt.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.ctrl_fsm_cnt.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_ctrl_fsm_cnt_qs)
  );

  //   F[reseed_cnt]: 10:10
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_reseed_cnt (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.reseed_cnt.de),
    .d      (hw2reg.fault_status.reseed_cnt.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.reseed_cnt.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_reseed_cnt_qs)
  );

  //   F[side_ctrl_fsm]: 11:11
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_side_ctrl_fsm (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.side_ctrl_fsm.de),
    .d      (hw2reg.fault_status.side_ctrl_fsm.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.side_ctrl_fsm.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_side_ctrl_fsm_qs)
  );

  //   F[side_ctrl_sel]: 12:12
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_side_ctrl_sel (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.side_ctrl_sel.de),
    .d      (hw2reg.fault_status.side_ctrl_sel.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.side_ctrl_sel.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_side_ctrl_sel_qs)
  );

  //   F[key_ecc]: 13:13
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_fault_status_key_ecc (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.fault_status.key_ecc.de),
    .d      (hw2reg.fault_status.key_ecc.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.fault_status.key_ecc.q),
    .ds     (),

    // to register interface (read)
    .qs     (fault_status_key_ecc_qs)
  );


  // R[debug]: V(False)
  //   F[invalid_creator_seed]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_creator_seed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_creator_seed_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_creator_seed.de),
    .d      (hw2reg.debug.invalid_creator_seed.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_creator_seed_qs)
  );

  //   F[invalid_owner_seed]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_owner_seed (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_owner_seed_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_owner_seed.de),
    .d      (hw2reg.debug.invalid_owner_seed.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_owner_seed_qs)
  );

  //   F[invalid_dev_id]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_dev_id (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_dev_id_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_dev_id.de),
    .d      (hw2reg.debug.invalid_dev_id.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_dev_id_qs)
  );

  //   F[invalid_health_state]: 3:3
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_health_state (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_health_state_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_health_state.de),
    .d      (hw2reg.debug.invalid_health_state.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_health_state_qs)
  );

  //   F[invalid_key_version]: 4:4
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_key_version (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_key_version_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_key_version.de),
    .d      (hw2reg.debug.invalid_key_version.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_key_version_qs)
  );

  //   F[invalid_key]: 5:5
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_key (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_key_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_key.de),
    .d      (hw2reg.debug.invalid_key.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_key_qs)
  );

  //   F[invalid_digest]: 6:6
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_debug_invalid_digest (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (debug_we),
    .wd     (debug_invalid_digest_wd),

    // from internal hardware
    .de     (hw2reg.debug.invalid_digest.de),
    .d      (hw2reg.debug.invalid_digest.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (debug_invalid_digest_qs)
  );



  logic [62:0] addr_hit;
  always_comb begin
    addr_hit = '0;
    addr_hit[ 0] = (reg_addr == KEYMGR_INTR_STATE_OFFSET);
    addr_hit[ 1] = (reg_addr == KEYMGR_INTR_ENABLE_OFFSET);
    addr_hit[ 2] = (reg_addr == KEYMGR_INTR_TEST_OFFSET);
    addr_hit[ 3] = (reg_addr == KEYMGR_ALERT_TEST_OFFSET);
    addr_hit[ 4] = (reg_addr == KEYMGR_CFG_REGWEN_OFFSET);
    addr_hit[ 5] = (reg_addr == KEYMGR_START_OFFSET);
    addr_hit[ 6] = (reg_addr == KEYMGR_CONTROL_SHADOWED_OFFSET);
    addr_hit[ 7] = (reg_addr == KEYMGR_SIDELOAD_CLEAR_OFFSET);
    addr_hit[ 8] = (reg_addr == KEYMGR_RESEED_INTERVAL_REGWEN_OFFSET);
    addr_hit[ 9] = (reg_addr == KEYMGR_RESEED_INTERVAL_SHADOWED_OFFSET);
    addr_hit[10] = (reg_addr == KEYMGR_SW_BINDING_REGWEN_OFFSET);
    addr_hit[11] = (reg_addr == KEYMGR_SEALING_SW_BINDING_0_OFFSET);
    addr_hit[12] = (reg_addr == KEYMGR_SEALING_SW_BINDING_1_OFFSET);
    addr_hit[13] = (reg_addr == KEYMGR_SEALING_SW_BINDING_2_OFFSET);
    addr_hit[14] = (reg_addr == KEYMGR_SEALING_SW_BINDING_3_OFFSET);
    addr_hit[15] = (reg_addr == KEYMGR_SEALING_SW_BINDING_4_OFFSET);
    addr_hit[16] = (reg_addr == KEYMGR_SEALING_SW_BINDING_5_OFFSET);
    addr_hit[17] = (reg_addr == KEYMGR_SEALING_SW_BINDING_6_OFFSET);
    addr_hit[18] = (reg_addr == KEYMGR_SEALING_SW_BINDING_7_OFFSET);
    addr_hit[19] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_0_OFFSET);
    addr_hit[20] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_1_OFFSET);
    addr_hit[21] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_2_OFFSET);
    addr_hit[22] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_3_OFFSET);
    addr_hit[23] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_4_OFFSET);
    addr_hit[24] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_5_OFFSET);
    addr_hit[25] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_6_OFFSET);
    addr_hit[26] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_7_OFFSET);
    addr_hit[27] = (reg_addr == KEYMGR_SALT_0_OFFSET);
    addr_hit[28] = (reg_addr == KEYMGR_SALT_1_OFFSET);
    addr_hit[29] = (reg_addr == KEYMGR_SALT_2_OFFSET);
    addr_hit[30] = (reg_addr == KEYMGR_SALT_3_OFFSET);
    addr_hit[31] = (reg_addr == KEYMGR_SALT_4_OFFSET);
    addr_hit[32] = (reg_addr == KEYMGR_SALT_5_OFFSET);
    addr_hit[33] = (reg_addr == KEYMGR_SALT_6_OFFSET);
    addr_hit[34] = (reg_addr == KEYMGR_SALT_7_OFFSET);
    addr_hit[35] = (reg_addr == KEYMGR_KEY_VERSION_OFFSET);
    addr_hit[36] = (reg_addr == KEYMGR_MAX_CREATOR_KEY_VER_REGWEN_OFFSET);
    addr_hit[37] = (reg_addr == KEYMGR_MAX_CREATOR_KEY_VER_SHADOWED_OFFSET);
    addr_hit[38] = (reg_addr == KEYMGR_MAX_OWNER_INT_KEY_VER_REGWEN_OFFSET);
    addr_hit[39] = (reg_addr == KEYMGR_MAX_OWNER_INT_KEY_VER_SHADOWED_OFFSET);
    addr_hit[40] = (reg_addr == KEYMGR_MAX_OWNER_KEY_VER_REGWEN_OFFSET);
    addr_hit[41] = (reg_addr == KEYMGR_MAX_OWNER_KEY_VER_SHADOWED_OFFSET);
    addr_hit[42] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_0_OFFSET);
    addr_hit[43] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_1_OFFSET);
    addr_hit[44] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_2_OFFSET);
    addr_hit[45] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_3_OFFSET);
    addr_hit[46] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_4_OFFSET);
    addr_hit[47] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_5_OFFSET);
    addr_hit[48] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_6_OFFSET);
    addr_hit[49] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_7_OFFSET);
    addr_hit[50] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_0_OFFSET);
    addr_hit[51] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_1_OFFSET);
    addr_hit[52] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_2_OFFSET);
    addr_hit[53] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_3_OFFSET);
    addr_hit[54] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_4_OFFSET);
    addr_hit[55] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_5_OFFSET);
    addr_hit[56] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_6_OFFSET);
    addr_hit[57] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_7_OFFSET);
    addr_hit[58] = (reg_addr == KEYMGR_WORKING_STATE_OFFSET);
    addr_hit[59] = (reg_addr == KEYMGR_OP_STATUS_OFFSET);
    addr_hit[60] = (reg_addr == KEYMGR_ERR_CODE_OFFSET);
    addr_hit[61] = (reg_addr == KEYMGR_FAULT_STATUS_OFFSET);
    addr_hit[62] = (reg_addr == KEYMGR_DEBUG_OFFSET);
  end

  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;

  // Check sub-word write is permitted
  always_comb begin
    wr_err = (reg_we &
              ((addr_hit[ 0] & (|(KEYMGR_PERMIT[ 0] & ~reg_be))) |
               (addr_hit[ 1] & (|(KEYMGR_PERMIT[ 1] & ~reg_be))) |
               (addr_hit[ 2] & (|(KEYMGR_PERMIT[ 2] & ~reg_be))) |
               (addr_hit[ 3] & (|(KEYMGR_PERMIT[ 3] & ~reg_be))) |
               (addr_hit[ 4] & (|(KEYMGR_PERMIT[ 4] & ~reg_be))) |
               (addr_hit[ 5] & (|(KEYMGR_PERMIT[ 5] & ~reg_be))) |
               (addr_hit[ 6] & (|(KEYMGR_PERMIT[ 6] & ~reg_be))) |
               (addr_hit[ 7] & (|(KEYMGR_PERMIT[ 7] & ~reg_be))) |
               (addr_hit[ 8] & (|(KEYMGR_PERMIT[ 8] & ~reg_be))) |
               (addr_hit[ 9] & (|(KEYMGR_PERMIT[ 9] & ~reg_be))) |
               (addr_hit[10] & (|(KEYMGR_PERMIT[10] & ~reg_be))) |
               (addr_hit[11] & (|(KEYMGR_PERMIT[11] & ~reg_be))) |
               (addr_hit[12] & (|(KEYMGR_PERMIT[12] & ~reg_be))) |
               (addr_hit[13] & (|(KEYMGR_PERMIT[13] & ~reg_be))) |
               (addr_hit[14] & (|(KEYMGR_PERMIT[14] & ~reg_be))) |
               (addr_hit[15] & (|(KEYMGR_PERMIT[15] & ~reg_be))) |
               (addr_hit[16] & (|(KEYMGR_PERMIT[16] & ~reg_be))) |
               (addr_hit[17] & (|(KEYMGR_PERMIT[17] & ~reg_be))) |
               (addr_hit[18] & (|(KEYMGR_PERMIT[18] & ~reg_be))) |
               (addr_hit[19] & (|(KEYMGR_PERMIT[19] & ~reg_be))) |
               (addr_hit[20] & (|(KEYMGR_PERMIT[20] & ~reg_be))) |
               (addr_hit[21] & (|(KEYMGR_PERMIT[21] & ~reg_be))) |
               (addr_hit[22] & (|(KEYMGR_PERMIT[22] & ~reg_be))) |
               (addr_hit[23] & (|(KEYMGR_PERMIT[23] & ~reg_be))) |
               (addr_hit[24] & (|(KEYMGR_PERMIT[24] & ~reg_be))) |
               (addr_hit[25] & (|(KEYMGR_PERMIT[25] & ~reg_be))) |
               (addr_hit[26] & (|(KEYMGR_PERMIT[26] & ~reg_be))) |
               (addr_hit[27] & (|(KEYMGR_PERMIT[27] & ~reg_be))) |
               (addr_hit[28] & (|(KEYMGR_PERMIT[28] & ~reg_be))) |
               (addr_hit[29] & (|(KEYMGR_PERMIT[29] & ~reg_be))) |
               (addr_hit[30] & (|(KEYMGR_PERMIT[30] & ~reg_be))) |
               (addr_hit[31] & (|(KEYMGR_PERMIT[31] & ~reg_be))) |
               (addr_hit[32] & (|(KEYMGR_PERMIT[32] & ~reg_be))) |
               (addr_hit[33] & (|(KEYMGR_PERMIT[33] & ~reg_be))) |
               (addr_hit[34] & (|(KEYMGR_PERMIT[34] & ~reg_be))) |
               (addr_hit[35] & (|(KEYMGR_PERMIT[35] & ~reg_be))) |
               (addr_hit[36] & (|(KEYMGR_PERMIT[36] & ~reg_be))) |
               (addr_hit[37] & (|(KEYMGR_PERMIT[37] & ~reg_be))) |
               (addr_hit[38] & (|(KEYMGR_PERMIT[38] & ~reg_be))) |
               (addr_hit[39] & (|(KEYMGR_PERMIT[39] & ~reg_be))) |
               (addr_hit[40] & (|(KEYMGR_PERMIT[40] & ~reg_be))) |
               (addr_hit[41] & (|(KEYMGR_PERMIT[41] & ~reg_be))) |
               (addr_hit[42] & (|(KEYMGR_PERMIT[42] & ~reg_be))) |
               (addr_hit[43] & (|(KEYMGR_PERMIT[43] & ~reg_be))) |
               (addr_hit[44] & (|(KEYMGR_PERMIT[44] & ~reg_be))) |
               (addr_hit[45] & (|(KEYMGR_PERMIT[45] & ~reg_be))) |
               (addr_hit[46] & (|(KEYMGR_PERMIT[46] & ~reg_be))) |
               (addr_hit[47] & (|(KEYMGR_PERMIT[47] & ~reg_be))) |
               (addr_hit[48] & (|(KEYMGR_PERMIT[48] & ~reg_be))) |
               (addr_hit[49] & (|(KEYMGR_PERMIT[49] & ~reg_be))) |
               (addr_hit[50] & (|(KEYMGR_PERMIT[50] & ~reg_be))) |
               (addr_hit[51] & (|(KEYMGR_PERMIT[51] & ~reg_be))) |
               (addr_hit[52] & (|(KEYMGR_PERMIT[52] & ~reg_be))) |
               (addr_hit[53] & (|(KEYMGR_PERMIT[53] & ~reg_be))) |
               (addr_hit[54] & (|(KEYMGR_PERMIT[54] & ~reg_be))) |
               (addr_hit[55] & (|(KEYMGR_PERMIT[55] & ~reg_be))) |
               (addr_hit[56] & (|(KEYMGR_PERMIT[56] & ~reg_be))) |
               (addr_hit[57] & (|(KEYMGR_PERMIT[57] & ~reg_be))) |
               (addr_hit[58] & (|(KEYMGR_PERMIT[58] & ~reg_be))) |
               (addr_hit[59] & (|(KEYMGR_PERMIT[59] & ~reg_be))) |
               (addr_hit[60] & (|(KEYMGR_PERMIT[60] & ~reg_be))) |
               (addr_hit[61] & (|(KEYMGR_PERMIT[61] & ~reg_be))) |
               (addr_hit[62] & (|(KEYMGR_PERMIT[62] & ~reg_be)))));
  end

  // Generate write-enables
  assign intr_state_we = addr_hit[0] & reg_we & !reg_error;

  assign intr_state_wd = reg_wdata[0];
  assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;

  assign intr_enable_wd = reg_wdata[0];
  assign intr_test_we = addr_hit[2] & reg_we & !reg_error;

  assign intr_test_wd = reg_wdata[0];
  assign alert_test_we = addr_hit[3] & reg_we & !reg_error;

  assign alert_test_recov_operation_err_wd = reg_wdata[0];

  assign alert_test_fatal_fault_err_wd = reg_wdata[1];
  assign cfg_regwen_re = addr_hit[4] & reg_re & !reg_error;
  assign start_we = addr_hit[5] & reg_we & !reg_error;

  assign start_wd = reg_wdata[0];
  assign control_shadowed_re = addr_hit[6] & reg_re & !reg_error;
  assign control_shadowed_we = addr_hit[6] & reg_we & !reg_error;

  assign control_shadowed_operation_wd = reg_wdata[6:4];

  assign control_shadowed_cdi_sel_wd = reg_wdata[7];

  assign control_shadowed_dest_sel_wd = reg_wdata[13:12];
  assign sideload_clear_we = addr_hit[7] & reg_we & !reg_error;

  assign sideload_clear_wd = reg_wdata[2:0];
  assign reseed_interval_regwen_we = addr_hit[8] & reg_we & !reg_error;

  assign reseed_interval_regwen_wd = reg_wdata[0];
  assign reseed_interval_shadowed_re = addr_hit[9] & reg_re & !reg_error;
  assign reseed_interval_shadowed_we = addr_hit[9] & reg_we & !reg_error;

  assign reseed_interval_shadowed_wd = reg_wdata[15:0];
  assign sw_binding_regwen_re = addr_hit[10] & reg_re & !reg_error;
  assign sw_binding_regwen_we = addr_hit[10] & reg_we & !reg_error;

  assign sw_binding_regwen_wd = reg_wdata[0];
  assign sealing_sw_binding_0_we = addr_hit[11] & reg_we & !reg_error;

  assign sealing_sw_binding_0_wd = reg_wdata[31:0];
  assign sealing_sw_binding_1_we = addr_hit[12] & reg_we & !reg_error;

  assign sealing_sw_binding_1_wd = reg_wdata[31:0];
  assign sealing_sw_binding_2_we = addr_hit[13] & reg_we & !reg_error;

  assign sealing_sw_binding_2_wd = reg_wdata[31:0];
  assign sealing_sw_binding_3_we = addr_hit[14] & reg_we & !reg_error;

  assign sealing_sw_binding_3_wd = reg_wdata[31:0];
  assign sealing_sw_binding_4_we = addr_hit[15] & reg_we & !reg_error;

  assign sealing_sw_binding_4_wd = reg_wdata[31:0];
  assign sealing_sw_binding_5_we = addr_hit[16] & reg_we & !reg_error;

  assign sealing_sw_binding_5_wd = reg_wdata[31:0];
  assign sealing_sw_binding_6_we = addr_hit[17] & reg_we & !reg_error;

  assign sealing_sw_binding_6_wd = reg_wdata[31:0];
  assign sealing_sw_binding_7_we = addr_hit[18] & reg_we & !reg_error;

  assign sealing_sw_binding_7_wd = reg_wdata[31:0];
  assign attest_sw_binding_0_we = addr_hit[19] & reg_we & !reg_error;

  assign attest_sw_binding_0_wd = reg_wdata[31:0];
  assign attest_sw_binding_1_we = addr_hit[20] & reg_we & !reg_error;

  assign attest_sw_binding_1_wd = reg_wdata[31:0];
  assign attest_sw_binding_2_we = addr_hit[21] & reg_we & !reg_error;

  assign attest_sw_binding_2_wd = reg_wdata[31:0];
  assign attest_sw_binding_3_we = addr_hit[22] & reg_we & !reg_error;

  assign attest_sw_binding_3_wd = reg_wdata[31:0];
  assign attest_sw_binding_4_we = addr_hit[23] & reg_we & !reg_error;

  assign attest_sw_binding_4_wd = reg_wdata[31:0];
  assign attest_sw_binding_5_we = addr_hit[24] & reg_we & !reg_error;

  assign attest_sw_binding_5_wd = reg_wdata[31:0];
  assign attest_sw_binding_6_we = addr_hit[25] & reg_we & !reg_error;

  assign attest_sw_binding_6_wd = reg_wdata[31:0];
  assign attest_sw_binding_7_we = addr_hit[26] & reg_we & !reg_error;

  assign attest_sw_binding_7_wd = reg_wdata[31:0];
  assign salt_0_we = addr_hit[27] & reg_we & !reg_error;

  assign salt_0_wd = reg_wdata[31:0];
  assign salt_1_we = addr_hit[28] & reg_we & !reg_error;

  assign salt_1_wd = reg_wdata[31:0];
  assign salt_2_we = addr_hit[29] & reg_we & !reg_error;

  assign salt_2_wd = reg_wdata[31:0];
  assign salt_3_we = addr_hit[30] & reg_we & !reg_error;

  assign salt_3_wd = reg_wdata[31:0];
  assign salt_4_we = addr_hit[31] & reg_we & !reg_error;

  assign salt_4_wd = reg_wdata[31:0];
  assign salt_5_we = addr_hit[32] & reg_we & !reg_error;

  assign salt_5_wd = reg_wdata[31:0];
  assign salt_6_we = addr_hit[33] & reg_we & !reg_error;

  assign salt_6_wd = reg_wdata[31:0];
  assign salt_7_we = addr_hit[34] & reg_we & !reg_error;

  assign salt_7_wd = reg_wdata[31:0];
  assign key_version_we = addr_hit[35] & reg_we & !reg_error;

  assign key_version_wd = reg_wdata[31:0];
  assign max_creator_key_ver_regwen_we = addr_hit[36] & reg_we & !reg_error;

  assign max_creator_key_ver_regwen_wd = reg_wdata[0];
  assign max_creator_key_ver_shadowed_re = addr_hit[37] & reg_re & !reg_error;
  assign max_creator_key_ver_shadowed_we = addr_hit[37] & reg_we & !reg_error;

  assign max_creator_key_ver_shadowed_wd = reg_wdata[31:0];
  assign max_owner_int_key_ver_regwen_we = addr_hit[38] & reg_we & !reg_error;

  assign max_owner_int_key_ver_regwen_wd = reg_wdata[0];
  assign max_owner_int_key_ver_shadowed_re = addr_hit[39] & reg_re & !reg_error;
  assign max_owner_int_key_ver_shadowed_we = addr_hit[39] & reg_we & !reg_error;

  assign max_owner_int_key_ver_shadowed_wd = reg_wdata[31:0];
  assign max_owner_key_ver_regwen_we = addr_hit[40] & reg_we & !reg_error;

  assign max_owner_key_ver_regwen_wd = reg_wdata[0];
  assign max_owner_key_ver_shadowed_re = addr_hit[41] & reg_re & !reg_error;
  assign max_owner_key_ver_shadowed_we = addr_hit[41] & reg_we & !reg_error;

  assign max_owner_key_ver_shadowed_wd = reg_wdata[31:0];
  assign sw_share0_output_0_re = addr_hit[42] & reg_re & !reg_error;

  assign sw_share0_output_0_wd = '1;
  assign sw_share0_output_1_re = addr_hit[43] & reg_re & !reg_error;

  assign sw_share0_output_1_wd = '1;
  assign sw_share0_output_2_re = addr_hit[44] & reg_re & !reg_error;

  assign sw_share0_output_2_wd = '1;
  assign sw_share0_output_3_re = addr_hit[45] & reg_re & !reg_error;

  assign sw_share0_output_3_wd = '1;
  assign sw_share0_output_4_re = addr_hit[46] & reg_re & !reg_error;

  assign sw_share0_output_4_wd = '1;
  assign sw_share0_output_5_re = addr_hit[47] & reg_re & !reg_error;

  assign sw_share0_output_5_wd = '1;
  assign sw_share0_output_6_re = addr_hit[48] & reg_re & !reg_error;

  assign sw_share0_output_6_wd = '1;
  assign sw_share0_output_7_re = addr_hit[49] & reg_re & !reg_error;

  assign sw_share0_output_7_wd = '1;
  assign sw_share1_output_0_re = addr_hit[50] & reg_re & !reg_error;

  assign sw_share1_output_0_wd = '1;
  assign sw_share1_output_1_re = addr_hit[51] & reg_re & !reg_error;

  assign sw_share1_output_1_wd = '1;
  assign sw_share1_output_2_re = addr_hit[52] & reg_re & !reg_error;

  assign sw_share1_output_2_wd = '1;
  assign sw_share1_output_3_re = addr_hit[53] & reg_re & !reg_error;

  assign sw_share1_output_3_wd = '1;
  assign sw_share1_output_4_re = addr_hit[54] & reg_re & !reg_error;

  assign sw_share1_output_4_wd = '1;
  assign sw_share1_output_5_re = addr_hit[55] & reg_re & !reg_error;

  assign sw_share1_output_5_wd = '1;
  assign sw_share1_output_6_re = addr_hit[56] & reg_re & !reg_error;

  assign sw_share1_output_6_wd = '1;
  assign sw_share1_output_7_re = addr_hit[57] & reg_re & !reg_error;

  assign sw_share1_output_7_wd = '1;
  assign op_status_we = addr_hit[59] & reg_we & !reg_error;

  assign op_status_wd = reg_wdata[1:0];
  assign err_code_we = addr_hit[60] & reg_we & !reg_error;

  assign err_code_invalid_op_wd = reg_wdata[0];

  assign err_code_invalid_kmac_input_wd = reg_wdata[1];

  assign err_code_invalid_shadow_update_wd = reg_wdata[2];
  assign debug_we = addr_hit[62] & reg_we & !reg_error;

  assign debug_invalid_creator_seed_wd = reg_wdata[0];

  assign debug_invalid_owner_seed_wd = reg_wdata[1];

  assign debug_invalid_dev_id_wd = reg_wdata[2];

  assign debug_invalid_health_state_wd = reg_wdata[3];

  assign debug_invalid_key_version_wd = reg_wdata[4];

  assign debug_invalid_key_wd = reg_wdata[5];

  assign debug_invalid_digest_wd = reg_wdata[6];

  // Assign write-enables to checker logic vector.
  always_comb begin
    reg_we_check = '0;
    reg_we_check[0] = intr_state_we;
    reg_we_check[1] = intr_enable_we;
    reg_we_check[2] = intr_test_we;
    reg_we_check[3] = alert_test_we;
    reg_we_check[4] = 1'b0;
    reg_we_check[5] = start_gated_we;
    reg_we_check[6] = control_shadowed_gated_we;
    reg_we_check[7] = sideload_clear_gated_we;
    reg_we_check[8] = reseed_interval_regwen_we;
    reg_we_check[9] = reseed_interval_shadowed_gated_we;
    reg_we_check[10] = sw_binding_regwen_we;
    reg_we_check[11] = sealing_sw_binding_0_gated_we;
    reg_we_check[12] = sealing_sw_binding_1_gated_we;
    reg_we_check[13] = sealing_sw_binding_2_gated_we;
    reg_we_check[14] = sealing_sw_binding_3_gated_we;
    reg_we_check[15] = sealing_sw_binding_4_gated_we;
    reg_we_check[16] = sealing_sw_binding_5_gated_we;
    reg_we_check[17] = sealing_sw_binding_6_gated_we;
    reg_we_check[18] = sealing_sw_binding_7_gated_we;
    reg_we_check[19] = attest_sw_binding_0_gated_we;
    reg_we_check[20] = attest_sw_binding_1_gated_we;
    reg_we_check[21] = attest_sw_binding_2_gated_we;
    reg_we_check[22] = attest_sw_binding_3_gated_we;
    reg_we_check[23] = attest_sw_binding_4_gated_we;
    reg_we_check[24] = attest_sw_binding_5_gated_we;
    reg_we_check[25] = attest_sw_binding_6_gated_we;
    reg_we_check[26] = attest_sw_binding_7_gated_we;
    reg_we_check[27] = salt_0_gated_we;
    reg_we_check[28] = salt_1_gated_we;
    reg_we_check[29] = salt_2_gated_we;
    reg_we_check[30] = salt_3_gated_we;
    reg_we_check[31] = salt_4_gated_we;
    reg_we_check[32] = salt_5_gated_we;
    reg_we_check[33] = salt_6_gated_we;
    reg_we_check[34] = salt_7_gated_we;
    reg_we_check[35] = key_version_gated_we;
    reg_we_check[36] = max_creator_key_ver_regwen_we;
    reg_we_check[37] = max_creator_key_ver_shadowed_gated_we;
    reg_we_check[38] = max_owner_int_key_ver_regwen_we;
    reg_we_check[39] = max_owner_int_key_ver_shadowed_gated_we;
    reg_we_check[40] = max_owner_key_ver_regwen_we;
    reg_we_check[41] = max_owner_key_ver_shadowed_gated_we;
    reg_we_check[42] = 1'b0;
    reg_we_check[43] = 1'b0;
    reg_we_check[44] = 1'b0;
    reg_we_check[45] = 1'b0;
    reg_we_check[46] = 1'b0;
    reg_we_check[47] = 1'b0;
    reg_we_check[48] = 1'b0;
    reg_we_check[49] = 1'b0;
    reg_we_check[50] = 1'b0;
    reg_we_check[51] = 1'b0;
    reg_we_check[52] = 1'b0;
    reg_we_check[53] = 1'b0;
    reg_we_check[54] = 1'b0;
    reg_we_check[55] = 1'b0;
    reg_we_check[56] = 1'b0;
    reg_we_check[57] = 1'b0;
    reg_we_check[58] = 1'b0;
    reg_we_check[59] = op_status_we;
    reg_we_check[60] = err_code_we;
    reg_we_check[61] = 1'b0;
    reg_we_check[62] = debug_we;
  end

  // Read data return
  always_comb begin
    reg_rdata_next = '0;
    unique case (1'b1)
      addr_hit[0]: begin
        reg_rdata_next[0] = intr_state_qs;
      end

      addr_hit[1]: begin
        reg_rdata_next[0] = intr_enable_qs;
      end

      addr_hit[2]: begin
        reg_rdata_next[0] = '0;
      end

      addr_hit[3]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
      end

      addr_hit[4]: begin
        reg_rdata_next[0] = cfg_regwen_qs;
      end

      addr_hit[5]: begin
        reg_rdata_next[0] = start_qs;
      end

      addr_hit[6]: begin
        reg_rdata_next[6:4] = control_shadowed_operation_qs;
        reg_rdata_next[7] = control_shadowed_cdi_sel_qs;
        reg_rdata_next[13:12] = control_shadowed_dest_sel_qs;
      end

      addr_hit[7]: begin
        reg_rdata_next[2:0] = sideload_clear_qs;
      end

      addr_hit[8]: begin
        reg_rdata_next[0] = reseed_interval_regwen_qs;
      end

      addr_hit[9]: begin
        reg_rdata_next[15:0] = reseed_interval_shadowed_qs;
      end

      addr_hit[10]: begin
        reg_rdata_next[0] = sw_binding_regwen_qs;
      end

      addr_hit[11]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_0_qs;
      end

      addr_hit[12]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_1_qs;
      end

      addr_hit[13]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_2_qs;
      end

      addr_hit[14]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_3_qs;
      end

      addr_hit[15]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_4_qs;
      end

      addr_hit[16]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_5_qs;
      end

      addr_hit[17]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_6_qs;
      end

      addr_hit[18]: begin
        reg_rdata_next[31:0] = sealing_sw_binding_7_qs;
      end

      addr_hit[19]: begin
        reg_rdata_next[31:0] = attest_sw_binding_0_qs;
      end

      addr_hit[20]: begin
        reg_rdata_next[31:0] = attest_sw_binding_1_qs;
      end

      addr_hit[21]: begin
        reg_rdata_next[31:0] = attest_sw_binding_2_qs;
      end

      addr_hit[22]: begin
        reg_rdata_next[31:0] = attest_sw_binding_3_qs;
      end

      addr_hit[23]: begin
        reg_rdata_next[31:0] = attest_sw_binding_4_qs;
      end

      addr_hit[24]: begin
        reg_rdata_next[31:0] = attest_sw_binding_5_qs;
      end

      addr_hit[25]: begin
        reg_rdata_next[31:0] = attest_sw_binding_6_qs;
      end

      addr_hit[26]: begin
        reg_rdata_next[31:0] = attest_sw_binding_7_qs;
      end

      addr_hit[27]: begin
        reg_rdata_next[31:0] = salt_0_qs;
      end

      addr_hit[28]: begin
        reg_rdata_next[31:0] = salt_1_qs;
      end

      addr_hit[29]: begin
        reg_rdata_next[31:0] = salt_2_qs;
      end

      addr_hit[30]: begin
        reg_rdata_next[31:0] = salt_3_qs;
      end

      addr_hit[31]: begin
        reg_rdata_next[31:0] = salt_4_qs;
      end

      addr_hit[32]: begin
        reg_rdata_next[31:0] = salt_5_qs;
      end

      addr_hit[33]: begin
        reg_rdata_next[31:0] = salt_6_qs;
      end

      addr_hit[34]: begin
        reg_rdata_next[31:0] = salt_7_qs;
      end

      addr_hit[35]: begin
        reg_rdata_next[31:0] = key_version_qs;
      end

      addr_hit[36]: begin
        reg_rdata_next[0] = max_creator_key_ver_regwen_qs;
      end

      addr_hit[37]: begin
        reg_rdata_next[31:0] = max_creator_key_ver_shadowed_qs;
      end

      addr_hit[38]: begin
        reg_rdata_next[0] = max_owner_int_key_ver_regwen_qs;
      end

      addr_hit[39]: begin
        reg_rdata_next[31:0] = max_owner_int_key_ver_shadowed_qs;
      end

      addr_hit[40]: begin
        reg_rdata_next[0] = max_owner_key_ver_regwen_qs;
      end

      addr_hit[41]: begin
        reg_rdata_next[31:0] = max_owner_key_ver_shadowed_qs;
      end

      addr_hit[42]: begin
        reg_rdata_next[31:0] = sw_share0_output_0_qs;
      end

      addr_hit[43]: begin
        reg_rdata_next[31:0] = sw_share0_output_1_qs;
      end

      addr_hit[44]: begin
        reg_rdata_next[31:0] = sw_share0_output_2_qs;
      end

      addr_hit[45]: begin
        reg_rdata_next[31:0] = sw_share0_output_3_qs;
      end

      addr_hit[46]: begin
        reg_rdata_next[31:0] = sw_share0_output_4_qs;
      end

      addr_hit[47]: begin
        reg_rdata_next[31:0] = sw_share0_output_5_qs;
      end

      addr_hit[48]: begin
        reg_rdata_next[31:0] = sw_share0_output_6_qs;
      end

      addr_hit[49]: begin
        reg_rdata_next[31:0] = sw_share0_output_7_qs;
      end

      addr_hit[50]: begin
        reg_rdata_next[31:0] = sw_share1_output_0_qs;
      end

      addr_hit[51]: begin
        reg_rdata_next[31:0] = sw_share1_output_1_qs;
      end

      addr_hit[52]: begin
        reg_rdata_next[31:0] = sw_share1_output_2_qs;
      end

      addr_hit[53]: begin
        reg_rdata_next[31:0] = sw_share1_output_3_qs;
      end

      addr_hit[54]: begin
        reg_rdata_next[31:0] = sw_share1_output_4_qs;
      end

      addr_hit[55]: begin
        reg_rdata_next[31:0] = sw_share1_output_5_qs;
      end

      addr_hit[56]: begin
        reg_rdata_next[31:0] = sw_share1_output_6_qs;
      end

      addr_hit[57]: begin
        reg_rdata_next[31:0] = sw_share1_output_7_qs;
      end

      addr_hit[58]: begin
        reg_rdata_next[2:0] = working_state_qs;
      end

      addr_hit[59]: begin
        reg_rdata_next[1:0] = op_status_qs;
      end

      addr_hit[60]: begin
        reg_rdata_next[0] = err_code_invalid_op_qs;
        reg_rdata_next[1] = err_code_invalid_kmac_input_qs;
        reg_rdata_next[2] = err_code_invalid_shadow_update_qs;
      end

      addr_hit[61]: begin
        reg_rdata_next[0] = fault_status_cmd_qs;
        reg_rdata_next[1] = fault_status_kmac_fsm_qs;
        reg_rdata_next[2] = fault_status_kmac_done_qs;
        reg_rdata_next[3] = fault_status_kmac_op_qs;
        reg_rdata_next[4] = fault_status_kmac_out_qs;
        reg_rdata_next[5] = fault_status_regfile_intg_qs;
        reg_rdata_next[6] = fault_status_shadow_qs;
        reg_rdata_next[7] = fault_status_ctrl_fsm_intg_qs;
        reg_rdata_next[8] = fault_status_ctrl_fsm_chk_qs;
        reg_rdata_next[9] = fault_status_ctrl_fsm_cnt_qs;
        reg_rdata_next[10] = fault_status_reseed_cnt_qs;
        reg_rdata_next[11] = fault_status_side_ctrl_fsm_qs;
        reg_rdata_next[12] = fault_status_side_ctrl_sel_qs;
        reg_rdata_next[13] = fault_status_key_ecc_qs;
      end

      addr_hit[62]: begin
        reg_rdata_next[0] = debug_invalid_creator_seed_qs;
        reg_rdata_next[1] = debug_invalid_owner_seed_qs;
        reg_rdata_next[2] = debug_invalid_dev_id_qs;
        reg_rdata_next[3] = debug_invalid_health_state_qs;
        reg_rdata_next[4] = debug_invalid_key_version_qs;
        reg_rdata_next[5] = debug_invalid_key_qs;
        reg_rdata_next[6] = debug_invalid_digest_qs;
      end

      default: begin
        reg_rdata_next = '1;
      end
    endcase
  end

  // shadow busy
  logic shadow_busy;
  logic rst_done;
  logic shadow_rst_done;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      rst_done <= '0;
    end else begin
      rst_done <= 1'b1;
    end
  end

  always_ff @(posedge clk_i or negedge rst_shadowed_ni) begin
    if (!rst_shadowed_ni) begin
      shadow_rst_done <= '0;
    end else begin
      shadow_rst_done <= 1'b1;
    end
  end

  // both shadow and normal resets have been released
  assign shadow_busy = ~(rst_done & shadow_rst_done);

  // Collect up storage and update errors
  assign shadowed_storage_err_o = |{
    control_shadowed_operation_storage_err,
    control_shadowed_cdi_sel_storage_err,
    control_shadowed_dest_sel_storage_err,
    reseed_interval_shadowed_storage_err,
    max_creator_key_ver_shadowed_storage_err,
    max_owner_int_key_ver_shadowed_storage_err,
    max_owner_key_ver_shadowed_storage_err
  };
  assign shadowed_update_err_o = |{
    control_shadowed_operation_update_err,
    control_shadowed_cdi_sel_update_err,
    control_shadowed_dest_sel_update_err,
    reseed_interval_shadowed_update_err,
    max_creator_key_ver_shadowed_update_err,
    max_owner_int_key_ver_shadowed_update_err,
    max_owner_key_ver_shadowed_update_err
  };

  // register busy
  assign reg_busy = shadow_busy;

  // Unused signal tieoff

  // wdata / byte enable are not always fully used
  // add a blanket unused statement to handle lint waivers
  logic unused_wdata;
  logic unused_be;
  assign unused_wdata = ^reg_wdata;
  assign unused_be = ^reg_be;

  // Assertions for Register Interface
  `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
  `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)

  `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)

  `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)

  // this is formulated as an assumption such that the FPV testbenches do disprove this
  // property by mistake
  //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)

endmodule


    """


    Identify the CWE relevant to the security issue for the given RTL.
    Obtain details of the CWE.

    Then determine if there are security issues relevant to the identified CWE in the RTL.
    Refer to the code that corresponds to the issues identified.
    
================================== Ai Message ==================================

[{'text': "I'll analyze the provided RTL code for security concerns related to register access policy, privilege escalation, and shadow register integrity. Let me first identify relevant CWEs for these security issues.", 'type': 'text'}, {'id': 'toolu_01JH4c2m2Ew3423B4y4NUnM1', 'input': {'security_issue': 'register access control bypass'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01JH4c2m2Ew3423B4y4NUnM1)
 Call ID: toolu_01JH4c2m2Ew3423B4y4NUnM1
  Args:
    security_issue: register access control bypass
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1220: Insufficient Granularity of Access Control
The product implements access controls via a policy or other feature with the intention to disable or restrict accesses (reads and/or writes) to assets in a system from untrusted agents. However, implemented access controls lack required granularity, which renders the control policy too broad because it allows accesses from unauthorized agents to the security-sensitive assets.
Integrated circuits and hardware engines can expose accesses to assets (device configuration, keys, etc.) to trusted firmware or a software module (commonly set by BIOS/bootloader). This access is typically access-controlled. Upon a power reset, the hardware or system usually starts with default values in registers, and the trusted firmware (Boot firmware) configures the necessary access-control protection.
Example 1
Consider a system with a register for storing AES key for encryption or decryption. The key is 128 bits, implemented as a set of four 32-bit registers. The key registers are assets and registers, AES_KEY_READ_POLICY and AES_KEY_WRITE_POLICY, and are defined to provide necessary access controls. The read-policy register defines which agents can read the AES-key registers, and write-policy register defines which agents can program or write to those registers. Each register is a 32-bit register, and it can support access control for a maximum of 32 agents. The number of the bit when set (i.e., "1") allows respective action from an agent whose identity matches the number of the bit and, if "0" (i.e., Clear), disallows the respective action to that corresponding agent.
(bad code)
Example Language: Other
Register Field description AES_ENC_DEC_KEY_0 AES key [0:31] for encryption or decryption Default 0x00000000 AES_ENC_DEC_KEY_1 AES key [32:63] for encryption or decryption Default 0x00000000 AES_ENC_DEC_KEY_2 AES key [64:95] for encryption or decryption Default 0x00000000 AES_ENC_DEC_KEY_4 AES key [96:127] for encryption or decryption Default 0x00000000 AES_KEY_READ_WRITE_POLICY [31:0] Default 0x00000006 - meaning agent with identities "1" and "2" can both read from and write to key registers In the above example, there is only one policy register that controls access to both read and write accesses to the AES-key registers, and thus the design is not granular enough to separate read and writes access for different agents. Here, agent with identities "1" and "2" can both read and write. A good design should be granular enough to provide separate access controls to separate actions. Access control for reads should be separate from writes. Below is an example of such implementation where two policy registers are defined for each of these actions. The policy is defined such that: the AES-key registers can only be read or used by a crypto agent with identity "1" when bit #1 is set. The AES-key registers can only be programmed by a trusted firmware with identity "2" when bit #2 is set.
(good code)
Example Language: Other
AES_KEY_READ_POLICY [31:0] Default 0x00000002 - meaning only Crypto engine with identity "1" can read registers: AES_ENC_DEC_KEY_0, AES_ENC_DEC_KEY_1, AES_ENC_DEC_KEY_2, AES_ENC_DEC_KEY_3 AES_KEY_WRITE_POLICY [31:0] Default 0x00000004 - meaning only trusted firmware with identity "2" can program registers: AES_ENC_DEC_KEY_0, AES_ENC_DEC_KEY_1, AES_ENC_DEC_KEY_2, AES_ENC_DEC_KEY_3

Example 2
Within the AXI node interface wrapper module in the RISC-V AXI module of the HACK@DAC'19 CVA6 SoC, an access control mechanism is employed to regulate the access of different privileged users to peripherals. The AXI ensures that only users with appropriate privileges can access specific peripherals. For instance, a ROM module is accessible exclusively with Machine privilege, and AXI enforces that users attempting to read data from the ROM must possess machine privilege; otherwise, access to the ROM is denied. The access control information and configurations are stored in a ROM.
(bad code)
Example Language: Verilog
...
for (i=0; i<NB_SUBORDINATE; i++)
begin
for (j=0; j<NB_MANAGER; j++)
begin
assign connectivity_map_o[i][j] = access_ctrl_i[i][j][priv_lvl_i] || ((j==6) && access_ctrl_i[i][7][priv_lvl_i]);
end
end
...
However, in the example code above, while assigning distinct privileges to AXI manager and subordinates, both the Platform-Level Interrupt Controller Specification (PLIC) and the Core-local Interrupt Controller (CLINT) (which are peripheral numbers 6 and 7 respectively) utilize the same access control configuration. This common configuration diminishes the granularity of the AXI access control mechanism. In certain situations, it might be necessary to grant higher privileges for accessing the PLIC than those required for accessing the CLINT. Unfortunately, this differentiation is overlooked, allowing an attacker to access the PLIC with lower privileges than intended. As a consequence, unprivileged code can read and write to the PLIC even when it was not intended to do so. In the worst-case scenario, the attacker could manipulate interrupt priorities, potentially modifying the system's behavior or availability. To address the aforementioned vulnerability, developers must enhance the AXI access control granularity by implementing distinct access control entries for the Platform-Level Interrupt Controller (PLIC) and the Core-local Interrupt Controller (CLINT). By doing so, different privilege levels can be defined for accessing PLIC and CLINT, effectively thwarting the potential attacks previously highlighted. This approach ensures a more robust and secure system, safeguarding against unauthorized access and manipulation of interrupt priorities.
(good code)
Example Language: Verilog
...
for (i=0; i<NB_SUBORDINATE; i++)
begin
for (j=0; j<NB_MANAGER; j++)
begin
assign connectivity_map_o[i][j] = access_ctrl_i[i][j][priv_lvl_i];
end
end
...

Example 3
Consider the following SoC design. The sram in HRoT has an address range that is readable and writable by unprivileged software and it has an area that is only readable by unprivileged software. The tbus interconnect enforces access control for subordinates on the bus but uses only one bit to control both read and write access. Address 0xA0000000 - 0xA000FFFF is readable and writable by the untrusted cores core{0-N} and address 0xA0010000 - 0xA001FFFF is only readable by the untrusted cores core{0-N}. The security policy access control is not granular enough, as it uses one bit to enable both read and write access. This gives write access to an area that should only be readable by unprivileged agents. Access control logic should differentiate between read and write access and to have sufficient address granularity.


================================== Ai Message ==================================

[{'id': 'toolu_014PhCyNSHrA1Av1k4kYsbmb', 'input': {'security_issue': 'shadow register integrity'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_014PhCyNSHrA1Av1k4kYsbmb)
 Call ID: toolu_014PhCyNSHrA1Av1k4kYsbmb
  Args:
    security_issue: shadow register integrity
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1326: Missing Immutable Root of Trust in Hardware
A missing immutable root of trust in the hardware results in the ability to bypass secure boot or execute untrusted or adversarial boot code.
A System-on-Chip (SoC) implements secure boot by verifying or authenticating signed boot code. The signing of the code is achieved by an entity that the SoC trusts. Before executing the boot code, the SoC verifies that the code or the public key with which the code has been signed has not been tampered with. The other data upon which the SoC depends are system-hardware settings in fuses such as whether "Secure Boot is enabled". These data play a crucial role in establishing a Root of Trust (RoT) to execute secure-boot flows.
Example 1
The RoT is stored in memory. This memory can be modified by an adversary. For example, if an SoC implements "Secure Boot" by storing the boot code in an off-chip/on-chip flash, the contents of the flash can be modified by using a flash programmer. Similarly, if the boot code is stored in ROM (Read-Only Memory) but the public key or the hash of the public key (used to enable "Secure Boot") is stored in Flash or a memory that is susceptible to modifications or writes, the implementation is vulnerable. In general, if the boot code, key materials and data that enable "Secure Boot" are all mutable, the implementation is vulnerable. Good architecture defines RoT as immutable in hardware. One of the best ways to achieve immutability is to store boot code, public key or hash of the public key and other relevant data in Read-Only Memory (ROM) or One-Time Programmable (OTP) memory that prevents further programming or writes.

Example 2
The example code below is a snippet from the bootrom of the HACK@DAC'19 buggy OpenPiton SoC. The contents of the bootrom are critical in implementing the hardware root of trust. It performs security-critical functions such as defining the system's device tree, validating the hardware cryptographic accelerators in the system, etc. Hence, write access to bootrom should be strictly limited to authorized users or removed completely so that bootrom is immutable. In this example (see the vulnerable code source), the boot instructions are stored in bootrom memory, mem. This memory can be read using the read address, addr_i, but write access should be restricted or removed.
(bad code)
Example Language: Verilog
...
always_ff @(posedge clk_i) begin
if (req_i) begin
if (!we_i) begin
raddr_q <= addr_i[$clog2(RomSize)-1+3:3];
end else begin
mem[addr_i[$clog2(RomSize)-1+3:3]] <= wdata_i;
end
end
end
...
// this prevents spurious Xes from propagating into the speculative fetch stage of the core
assign rdata_o = (raddr_q < RomSize) ? mem[raddr_q] : '0;
...
The vulnerable code shows an insecure implementation of the bootrom where bootrom can be written directly by enabling write enable, we_i, and using write address, addr_i, and write data, wdata_i. To mitigate this issue, remove the write access to bootrom memory.
(good code)
Example Language: Verilog
...
always_ff @(posedge clk_i) begin
if (req_i) begin
raddr_q <= addr_i[$clog2(RomSize)-1+3:3];
end
end
...
// this prevents spurious Xes from propagating into the speculative fetch stage of the core
assign rdata_o = (raddr_q < RomSize) ? mem[raddr_q] : '0;
...


================================== Ai Message ==================================

[{'id': 'toolu_01EM1dvwHbG5qsk4mmXf4RC2', 'input': {'security_issue': 'privilege escalation hardware'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01EM1dvwHbG5qsk4mmXf4RC2)
 Call ID: toolu_01EM1dvwHbG5qsk4mmXf4RC2
  Args:
    security_issue: privilege escalation hardware
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1268: Policy Privileges are not Assigned Consistently Between Control and Data Agents
The product's hardware-enforced access control for a particular resource improperly accounts for privilege discrepancies between control and write policies.
Integrated circuits and hardware engines may provide access to resources (device-configuration, encryption keys, etc.) belonging to trusted firmware or software modules (commonly set by a BIOS or a bootloader). These accesses are typically controlled and limited by the hardware. Hardware design access control is sometimes implemented using a policy. A policy defines which entity or agent may or may not be allowed to perform an action. When a system implements multiple levels of policies, a control policy may allow direct access to a resource as well as changes to the policies themselves.
Example 1
Consider a system of seven registers for storing and configuring an AES key for encryption or decryption. Four 32-bit registers are used to store a 128-bit AES key. The names of those registers are AES_ENC_DEC_KEY_0, AES_ENC_DEC_KEY_1, AES_ENC_DEC_KEY_2, and AES_ENC_DEC_KEY_3. Collectively these are referred to as the AES Key registers. RegisterField description AES_ENC_DEC_KEY_0AES key [0:31] for encryption or decryption Default 0x00000000 AES_ENC_DEC_KEY_1AES key [32:63] for encryption or decryption Default 0x00000000 AES_ENC_DEC_KEY_2AES key [64:95] for encryption or decryption Default 0x00000000 AES_ENC_DEC_KEY_3AES key [96:127] for encryption or decryption Default 0x00000000 Three 32-bit registers are used to define access control for the AES-key registers. The names of those registers are AES_KEY_CONTROL_POLICY, AES_KEY_READ_POLICY, and AES_KEY_WRITE_POLICY. Collectively these registers are referred to as the Policy registers, and their functions are explained next. The AES_KEY_CONTROL_POLICY register defines which agents can write to the AES_KEY_READ_POLICY or AES_KEY_WRITE_POLICY registers. The AES_KEY_READ_POLICY register defines which agents can read the AES-key registers. The AES_KEY_WRITE_POLICY register defines which agents can write the AES key registers. The preceding three policy registers encode access control at the bit level. Therefore a maximum of 32 agents can be defined (1 bit per agent). The value of the bit when set (i.e., "1") allows the respective action from an agent whose identity corresponds to the number of the bit. If clear (i.e., "0"), it disallows the respective action to that corresponding agent. For example, if bit 0 is set to "1" in the AES_KEY_READ_POLICY register, then agent 0 has permission to read the AES-key registers. Consider that there are 4 agents named Agent 1, Agent 2, Agent 3, and Agent 4. For access control purposes Agent 1 is assigned to bit 1, Agent 2 to bit 2, Agent 3 to bit 3, and Agent 4 to bit 4. All agents are trusted except for Agent 3 who is untrusted. Also consider the register values in the below table.
(bad code)
RegisterField description AES_KEY_CONTROL_POLICYControls which agents can write to READ_POLICY and WRITE_POLICY registers [31:0] Default 0x00000018 AES_KEY_READ_POLICYControls which agents can read the AES-key registers [31:0] Default 0x00000002 AES_KEY_WRITE_POLICYControls which agents can write to the AES-key registers [31:0] Default 0x00000004
IThe AES_KEY_CONTROL_POLICY register value is 0x00000018. In binary, the lower 8 bits will be 0001 1000, meaning that: Bits 3 and 4 are set, thus Agents 3 and 4 will have write access to AES_KEY_READ_POLICY or AES_KEY_WRITE_POLICY. All other bits are clear, hence agents other than 3 and 4 will not have access to write to AES_KEY_READ_POLICY or AES_KEY_WRITE_POLICY. The AES_KEY_READ_POLICY register value is 0x00000002. In binary, the lower 8 bits will be 0000 0010, meaning that: Bit 1 is set, thus Agent 1 will be able to read the AES key registers. The AES_KEY_WRITE_POLICY register value is 0x00000004. In binary, the lower 8 bits will be 0000 0100, meaning that: Bit 2 is set, thus Agent 2 will be able to write the AES Key registers. The configured access control policy for Agents 1,2,3,4 is summarized in table below. AgentReadWriteControl Agent 1AllowedNot AllowedNot Allowed Agent 2Not AllowedAllowedNot Allowed Agent 3Not AllowedNot AllowedAllowed Agent 4Not AllowedNot AllowedAllowed At this point Agents 3 and 4 can only configure which agents can read AES keys and which agents can write AES keys. Agents 3 and 4 cannot read or write AES keys - just configure access control. Now, recall Agent 3 is untrusted. As explained above, the value of the AES_KEY_CONTROL_POLICY register gives agent 3 access to write to the AES_KEY_WRITE_POLICY register. Agent 3 can use this write access to add themselves to the AES_KEY_WRITE_POLICY register. This is accomplished by Agent 3 writing the value 0x00000006. In binary, the lower 8 bits are 0000 0110, meaning that bit 3 will be set. Thus, giving Agent 3 having the ability to write to the AES Key registers. If the AES_KEY_CONTROL_POLICY register value is 0x00000010, the lower 8 bits will be 0001 0000. This will give Agent 4, a trusted agent, write access to AES_KEY_WRITE_POLICY, but Agent 3, who is untrusted, will not have write access. The Policy register values should therefore be as follows:
(good code)
RegisterField description AES_KEY_CONTROL_POLICY[31:0] Default 0x00000010 AES_KEY_READ_POLICY[31:0] Default 0x00000002 AES_KEY_WRITE_POLICY[31:0] Default 0x00000004


================================== Ai Message ==================================

Based on my analysis of the provided RTL code and the relevant CWEs, I can identify several security concerns related to register access policy, privilege escalation, and shadow register integrity:

## Security Concerns in the RTL Code

### 1. Register Access Control Issues (CWE-1220)

The code implements a register interface for the Key Manager (keymgr) module with various access control mechanisms, but there are potential issues:

1. **REGWEN-gated Write Enable Signals**: The code uses REGWEN (register write enable) signals to control access to certain registers. For example:
   ```verilog
   // Create REGWEN-gated WE signal
   logic start_gated_we;
   assign start_gated_we = start_we & cfg_regwen_qs;
   ```
   
   While this approach provides some access control, it may not be granular enough for all security requirements. The same REGWEN signal (`cfg_regwen_qs`) is used to gate multiple registers, which could lead to insufficient granularity of access control.

2. **Shadow Register Protection**: The code implements shadow registers for critical configuration values, which is good practice, but the access control for these shadow registers relies on the same REGWEN signals as other registers, potentially allowing unauthorized modifications if the REGWEN signal is compromised.

### 2. Shadow Register Integrity Issues

The code implements shadow registers for critical security parameters, which is a good practice, but there are potential concerns:

1. **Shadow Register Error Handling**: The code collects shadow register errors:
   ```verilog
   assign shadowed_storage_err_o = |{
     control_shadowed_operation_storage_err,
     control_shadowed_cdi_sel_storage_err,
     control_shadowed_dest_sel_storage_err,
     // ...more errors...
   };
   ```
   
   However, it's not clear from this code snippet how these errors are handled or if they trigger appropriate security responses.

2. **Shadow Register Reset**: The code implements separate reset signals for normal and shadow registers:
   ```verilog
   input rst_ni,
   input rst_shadowed_ni,
   ```
   
   This is good practice, but if an attacker can control one of these reset signals, they might be able to manipulate the shadow register state.

### 3. Privilege Escalation Concerns (CWE-1268)

1. **Register Write Enable Checks**: The code implements a register write enable check mechanism:
   ```verilog
   prim_reg_we_check #(
     .OneHotWidth(63)
   ) u_prim_reg_we_check (
     .clk_i(clk_i),
     .rst_ni(rst_ni),
     .oh_i  (reg_we_check),
     .en_i  (reg_we && !addrmiss),
     .err_o (reg_we_err)
   );
   ```
   
   This checks for spurious write enables, which is good, but if an attacker can manipulate the `reg_we_check` signals, they might be able to bypass this protection.

2. **Integrity Checking**: The code implements integrity checking for incoming transactions:
   ```verilog
   // incoming payload check
   logic intg_err;
   tlul_cmd_intg_chk u_chk (
     .tl_i(tl_i),
     .err_o(intg_err)
   );
   ```
   
   This is good practice, but the error handling appears to only set a flag rather than immediately blocking the transaction, which could potentially allow an attacker to exploit timing windows.

## Specific Vulnerabilities

1. **Key Version Control**: The code implements key version control registers with separate REGWEN signals:
   ```verilog
   assign max_creator_key_ver_shadowed_gated_we =
     max_creator_key_ver_shadowed_we & max_creator_key_ver_regwen_qs;
   ```
   
   However, if an attacker can manipulate the REGWEN value, they could potentially modify key version limits, which could lead to downgrade attacks.

2. **Shadow Register Update Errors**: The code collects shadow register update errors, but it's not clear if these errors immediately block operations or just set flags:
   ```verilog
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

Based on my analysis of the provided RTL code and the relevant CWEs, I can identify several security concerns related to register access policy, privilege escalation, and shadow register integrity:

## Security Concerns in the RTL Code

### 1. Register Access Control Issues (CWE-1220)

The code implements a register interface for the Key Manager (keymgr) module with various access control mechanisms, but there are potential issues:

1. **REGWEN-gated Write Enable Signals**: The code uses REGWEN (register write enable) signals to control access to certain registers. For example:
   ```verilog
   // Create REGWEN-gated WE signal
   logic start_gated_we;
   assign start_gated_we = start_we & cfg_regwen_qs;
   ```
   
   While this approach provides some access control, it may not be granular enough for all security requirements. The same REGWEN signal (`cfg_regwen_qs`) is used to gate multiple registers, which could lead to insufficient granularity of access control.

2. **Shadow Register Protection**: The code implements shadow registers for critical configuration values, which is good practice, but the access control for these shadow registers relies on the same REGWEN signals as other registers, potentially allowing unauthorized modifications if the REGWEN signal is compromised.

### 2. Shadow Register Integrity Issues

The code implements shadow registers for critical security parameters, which is a good practice, but there are potential concerns:

1. **Shadow Register Error Handling**: The code collects shadow register errors:
   ```verilog
   assign shadowed_storage_err_o = |{
     control_shadowed_operation_storage_err,
     control_shadowed_cdi_sel_storage_err,
     control_shadowed_dest_sel_storage_err,
     // ...more errors...
   };
   ```
   
   However, it's not clear from this code snippet how these errors are handled or if they trigger appropriate security responses.

2. **Shadow Register Reset**: The code implements separate reset signals for normal and shadow registers:
   ```verilog
   input rst_ni,
   input rst_shadowed_ni,
   ```
   
   This is good practice, but if an attacker can control one of these reset signals, they might be able to manipulate the shadow register state.

### 3. Privilege Escalation Concerns (CWE-1268)

1. **Register Write Enable Checks**: The code implements a register write enable check mechanism:
   ```verilog
   prim_reg_we_check #(
     .OneHotWidth(63)
   ) u_prim_reg_we_check (
     .clk_i(clk_i),
     .rst_ni(rst_ni),
     .oh_i  (reg_we_check),
     .en_i  (reg_we && !addrmiss),
     .err_o (reg_we_err)
   );
   ```
   
   This checks for spurious write enables, which is good, but if an attacker can manipulate the `reg_we_check` signals, they might be able to bypass this protection.

2. **Integrity Checking**: The code implements integrity checking for incoming transactions:
   ```verilog
   // incoming payload check
   logic intg_err;
   tlul_cmd_intg_chk u_chk (
     .tl_i(tl_i),
     .err_o(intg_err)
   );
   ```
   
   This is good practice, but the error handling appears to only set a flag rather than immediately blocking the transaction, which could potentially allow an attacker to exploit timing windows.

## Specific Vulnerabilities

1. **Key Version Control**: The code implements key version control registers with separate REGWEN signals:
   ```verilog
   assign max_creator_key_ver_shadowed_gated_we =
     max_creator_key_ver_shadowed_we & max_creator_key_ver_regwen_qs;
   ```
   
   However, if an attacker can manipulate the REGWEN value, they could potentially modify key version limits, which could lead to downgrade attacks.

2. **Shadow Register Update Errors**: The code collects shadow register update errors, but it's not clear if these errors immediately block operations or just set flags:
   ```verilog
   
================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_xtewR8MbJVgqcMyYne4x8J6c)
 Call ID: call_xtewR8MbJVgqcMyYne4x8J6c
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Key manager interface to kmac
6: //
7: 
8: `include "prim_assert.sv"
9: 
10: module keymgr_kmac_if
11:   import keymgr_pkg::*;
12: #(
13:   parameter rand_perm_t RndCnstRandPerm = RndCnstRandPermDefault
14: ) (
15:   input clk_i,
16:   input rst_ni,
17: 
18:   // data input interfaces
19:   input [AdvDataWidth-1:0] adv_data_i,
20:   input [IdDataWidth-1:0] id_data_i,
21:   input [GenDataWidth-1:0] gen_data_i,
22:   input [3:0] inputs_invalid_i,
23:   output logic inputs_invalid_o,
24: 
25:   // keymgr control to select appropriate inputs
26:   input adv_en_i,
27:   input id_en_i,
28:   input gen_en_i,
29:   output logic done_o,
30:   output logic [Shares-1:0][kmac_pkg::AppDigestW-1:0] data_o,
31: 
32:   // actual connection to kmac
33:   output kmac_pkg::app_req_t kmac_data_o,
34:   input  kmac_pkg::app_rsp_t kmac_data_i,
35: 
36:   // entropy input
37:   output logic prng_en_o,
38:   input [Shares-1:0][RandWidth-1:0] entropy_i,
39: 
40:   // error outputs
41:   output logic fsm_error_o,
42:   output logic kmac_error_o,
43:   output logic kmac_done_error_o,
44:   output logic cmd_error_o
45: );
46: 
47: 
48:   // Encoding generated with:
49:   // $ ./util/design/sparse-fsm-encode.py -d 5 -m 6 -n 10 \
50:   //      -s 2292624416 --language=sv
51:   //
52:   // Hamming distance histogram:
53:   //
54:   //  0: --
55:   //  1: --
56:   //  2: --
57:   //  3: --
58:   //  4: --
59:   //  5: |||||||||||||||||||| (46.67%)
60:   //  6: ||||||||||||||||| (40.00%)
61:   //  7: ||||| (13.33%)
62:   //  8: --
63:   //  9: --
64:   // 10: --
65:   //
66:   // Minimum Hamming distance: 5
67:   // Maximum Hamming distance: 7
68:   // Minimum Hamming weight: 2
69:   // Maximum Hamming weight: 9
70:   //
71:   localparam int StateWidth = 10;
72:   typedef enum logic [StateWidth-1:0] {
73:     StIdle    = 10'b1110100010,
74:     StTx      = 10'b0010011011,
75:     StTxLast  = 10'b0101000000,
76:     StOpWait  = 10'b1000101001,
77:     StClean   = 10'b1111111101,
78:     StError   = 10'b0011101110
79:   } data_state_e;
80: 
81:   localparam int AdvRem = AdvDataWidth % KmacDataIfWidth;
82:   localparam int IdRem  = IdDataWidth  % KmacDataIfWidth;
83:   localparam int GenRem = GenDataWidth % KmacDataIfWidth;
84: 
85:   // the remainder must be in number of bytes
86:   `ASSERT_INIT(AdvRemBytes_A, AdvRem % 8 == 0)
87:   `ASSERT_INIT(IdRemBytes_A,  IdRem  % 8 == 0)
88:   `ASSERT_INIT(GenRemBytes_A, GenRem % 8 == 0)
89: 
90:   // Number of kmac transactions required
91:   localparam int AdvRounds = (AdvDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
92:   localparam int IdRounds  = (IdDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
93:   localparam int GenRounds = (GenDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
94:   localparam int MaxRounds = KDFMaxWidth  / KmacDataIfWidth;
95: 
96:   // calculated parameters for number of roudns and interface width
97:   localparam int CntWidth = $clog2(MaxRounds);
98:   localparam int IfBytes = KmacDataIfWidth / 8;
99:   localparam int DecoyCopies = KmacDataIfWidth / RandWidth;
100:   localparam int DecoyOutputCopies = (kmac_pkg::AppDigestW / RandWidth);
101: 
102:   localparam int unsigned LastAdvRoundInt = AdvRounds - 1;
103:   localparam int unsigned LastIdRoundInt = IdRounds - 1;
104:   localparam int unsigned LastGenRoundInt = GenRounds - 1;
105:   localparam bit [CntWidth-1:0] LastAdvRound = LastAdvRoundInt[CntWidth-1:0];
106:   localparam bit [CntWidth-1:0] LastIdRound = LastIdRoundInt[CntWidth-1:0];
107:   localparam bit [CntWidth-1:0] LastGenRound = LastGenRoundInt[CntWidth-1:0];
108: 
109:   // byte mask for the last transfer
110:   localparam logic [IfBytes-1:0] AdvByteMask = (AdvRem > 0) ? (2**(AdvRem/8)-1) : {IfBytes{1'b1}};
111:   localparam logic [IfBytes-1:0] IdByteMask  = (IdRem > 0)  ? (2**(IdRem/8)-1)  : {IfBytes{1'b1}};
112:   localparam logic [IfBytes-1:0] GenByteMask = (GenRem > 0) ? (2**(GenRem/8)-1) : {IfBytes{1'b1}};
113: 
114:   logic [MaxRounds-1:0][KmacDataIfWidth-1:0] adv_data;
115:   logic [MaxRounds-1:0][KmacDataIfWidth-1:0] id_data;
116:   logic [MaxRounds-1:0][KmacDataIfWidth-1:0] gen_data;
117:   logic [CntWidth-1:0] cnt;
118:   logic [CntWidth-1:0] rounds;
119:   logic [KmacDataIfWidth-1:0] decoy_data;
120:   logic valid;
121:   logic last;
122:   logic [IfBytes-1:0] strb;
123:   logic cnt_clr, cnt_set, cnt_en;
124:   logic start;
125:   logic [3:0] inputs_invalid_d, inputs_invalid_q;
126:   logic clr_err;
127:   logic kmac_done_vld;
128:   logic cmd_chk;
129: 
130:   data_state_e state_q, state_d;
131: 
132:   // 0 pad to the appropriate width
133:   // this is basically for scenarios where *DataWidth % KmacDataIfWidth != 0
134:   assign adv_data = KDFMaxWidth'(adv_data_i);
135:   assign id_data  = KDFMaxWidth'(id_data_i);
136:   assign gen_data = KDFMaxWidth'(gen_data_i);
137: 
138:   assign start = adv_en_i | id_en_i | gen_en_i;
139: 
140:   logic cnt_err;
141:   // SEC_CM: KMAC_IF.CTR.REDUN
142:   prim_count #(
143:     .Width(CntWidth),
144:     .ResetValue({CntWidth{1'b1}})
145:   ) u_cnt (
146:     .clk_i,
147:     .rst_ni,
148:     .clr_i(cnt_clr),
149:     .set_i(cnt_set),
150:     .set_cnt_i(rounds),
151:     .incr_en_i(1'b0),
152:     .decr_en_i(cnt_en),
153:     .step_i(CntWidth'(1'b1)),
154:     .commit_i(1'b1),
155:     .cnt_o(cnt),
156:     .cnt_after_commit_o(),
157:     .err_o(cnt_err)
158:   );
159: 
160:   always_ff @(posedge clk_i or negedge rst_ni) begin
161:     if (!rst_ni) begin
162:       inputs_invalid_q <= '0;
163:     end else begin
164:       inputs_invalid_q <= inputs_invalid_d;
165:     end
166:    end
167: 
168:   // SEC_CM: KMAC_IF.FSM.SPARSE
169:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, data_state_e, StIdle)
170: 
171:   always_comb begin
172:     cnt_clr = 1'b0;
173:     cnt_set = 1'b0;
174:     cnt_en  = 1'b0;
175:     valid   = 1'b0;
176:     last    = 1'b0;
177:     strb    = '0;
178:     done_o  = 1'b0;
179:     state_d = state_q;
180:     rounds  = '0;
181: 
182:     clr_err = '0;
183:     fsm_error_o = '0;
184:     kmac_error_o = '0;
185: 
186:     kmac_done_vld = '0;
187: 
188:     cmd_chk = 1'b1;
189: 
190:     unique case (state_q)
191: 
192:       StIdle: begin
193:         // if for some reason multiple bits are set, adv_en has priority
194:         // as the current key state will be destroyed
195: 
196:         // cross check for commands once transaction begins
197:         cmd_chk = '0;
198:         if (start) begin
199:           cnt_set = 1'b1;
200:           if (adv_en_i) begin
201:             rounds = LastAdvRound;
202:           end else if (id_en_i) begin
203:             rounds = LastIdRound;
204:           end else if (gen_en_i) begin
205:             rounds = LastGenRound;
206:           end
207:           // in case we are sending only 1 entry
208:           state_d = (rounds == 0) ? StTxLast : StTx;
209:         end
210:       end
211: 
212:       StTx: begin
213:         valid = 1'b1;
214:         strb = {IfBytes{1'b1}};
215: 
216:         // transaction accepted
217:         if (kmac_data_i.ready) begin
218:           cnt_en = 1'b1;
219: 
220:           // second to last beat
221:           if (cnt == CntWidth'(1'b1)) begin
222:             state_d = StTxLast;
223:           end
224:         end
225: 
226:       end
227: 
228:       StTxLast: begin
229:         valid = 1'b1;
230:         last = 1'b1;
231: 
232:         if (adv_en_i) begin
233:           strb = AdvByteMask;
234:         end else if (id_en_i) begin
235:           strb = IdByteMask;
236:         end else if (gen_en_i) begin
237:           strb = GenByteMask;
238:         end
239: 
240:         // transaction accepted
241:         cnt_clr = kmac_data_i.ready;
242:         state_d = kmac_data_i.ready ? StOpWait : StTxLast;
243: 
244:       end
245: 
246:       StOpWait: begin
247:         kmac_done_vld = 1'b1;
248:         if (kmac_data_i.done) begin
249:           kmac_error_o = kmac_data_i.error;
250:           done_o = 1'b1;
251:           state_d = StClean;
252:         end
253:       end
254: 
255:       StClean: begin
256:         cmd_chk = '0;
257:         done_o = 1'b1;
258: 
259:         // wait for control side to ack done by waiting start de-assertion
260:         if (!start) begin
261:           done_o = 1'b0;
262:           clr_err = 1'b1;
263:           state_d = StIdle;
264:         end
265:       end
266: 
267:       // trigger error
268:       default: begin
269:         // This state is terminal
270:         done_o = 1'b1;
271:         fsm_error_o = 1'b1;
272:       end
273: 
274:     endcase // unique case (state_q)
275: 
276:     // unconditional error transitions
277:     // counter errors may disturb the fsm flow and are
278:     // treated like fsm errors
279:     if (cnt_err) begin
280:       state_d = StError;
281:       fsm_error_o = 1;
282:       done_o = 1'b1;
283:     end
284:   end
285: 
286:   // when transaction is not complete, populate the data with random
287:   assign data_o = start && done_o ?
288:                   {kmac_data_i.digest_share1,
289:                    kmac_data_i.digest_share0} :
290:                   {{DecoyOutputCopies{entropy_i[1]}},
291:                    {DecoyOutputCopies{entropy_i[0]}}};
292: 
293:   // The input invalid check is done whenever transactions are ongoing with kmac
294:   // once set, it cannot be unset until transactions are fully complete
295:   always_comb begin
296:     inputs_invalid_d = inputs_invalid_q;
297: 
298:     if (clr_err) begin
299:       inputs_invalid_d = '0;
300:     end else if (valid) begin
301:       inputs_invalid_d[OpAdvance]  = adv_en_i & (inputs_invalid_i[OpAdvance] |
302:                                                  inputs_invalid_q[OpAdvance]);
303:       inputs_invalid_d[OpGenId]    = id_en_i  & (inputs_invalid_i[OpGenId]   |
304:                                                  inputs_invalid_q[OpGenId]);
305:       inputs_invalid_d[OpGenSwOut] = gen_en_i & (inputs_invalid_i[OpGenSwOut]|
306:                                                  inputs_invalid_q[OpGenSwOut]);
307:       inputs_invalid_d[OpGenHwOut] = gen_en_i & (inputs_invalid_i[OpGenHwOut]|
308:                                                  inputs_invalid_q[OpGenHwOut]);
309:     end
310:   end
311: 
312:   // immediately assert errors
313:   assign inputs_invalid_o = |inputs_invalid_d;
314: 
315:   // Permute Share 1 of the entropy input once more to get the decoy data.
316:   // Share 0 and 1 are used as is for data_o (connected to the sideload ports).
317:   logic [RandWidth-1:0] decoy_entropy;
318:   assign decoy_entropy = perm_data(entropy_i[1], RndCnstRandPerm);
319:   assign decoy_data = {DecoyCopies{decoy_entropy}};
320: 
321:   logic [CntWidth-1:0] adv_sel, id_sel, gen_sel;
322:   assign adv_sel = LastAdvRound - cnt;
323:   assign id_sel = LastIdRound - cnt;
324:   assign gen_sel = LastGenRound - cnt;
325: 
326:   // The count is maintained as a downcount
327:   // so a subtract is necessary to send the right byte
328:   // alternatively we can also reverse the order of the input
329:   always_comb begin
330:     kmac_data_o.data  = decoy_data;
331:     if (|cmd_error_o || inputs_invalid_o || fsm_error_o) begin
332:       kmac_data_o.data  = decoy_data;
333:     end else if (valid && adv_en_i) begin
334:       kmac_data_o.data  = adv_data[adv_sel];
335:     end else if (valid && id_en_i) begin
336:       kmac_data_o.data  = id_data[id_sel];
337:     end else if (valid && gen_en_i) begin
338:       kmac_data_o.data  = gen_data[gen_sel];
339:     end
340:   end
341: 
342:   assign kmac_data_o.valid = valid;
343:   assign kmac_data_o.last  = last;
344:   assign kmac_data_o.strb  = strb;
345: 
346:   // kmac done is asserted outside of expected window
347:   // SEC_CM: KMAC_IF_DONE.CTRL.CONSISTENCY
348:   logic kmac_done_err_q, kmac_done_err_d;
349:   assign kmac_done_err_d = ~kmac_done_vld & kmac_data_i.done |
350:                            kmac_done_err_q;
351:   assign kmac_done_error_o = kmac_done_err_q;
352: 
353: 
354:   // the enables must be 1 hot
355:   logic [2:0] enables_d, enables_q, enables_sub;
356:   assign enables_d = {adv_en_i, id_en_i, gen_en_i};
357:   assign enables_sub = enables_d - 1'b1;
358: 
359:   // cross check to ensure the one-hot command that kicked off
360:   // the transaction remains consistent throughout.
361:   logic cmd_consty_err_q, cmd_consty_err_d;
362:   always_ff @(posedge clk_i or negedge rst_ni) begin
363:     if (!rst_ni) begin
364:       enables_q <= '0;
365:     end else if (cnt_set) begin
366:       enables_q <= enables_d;
367:     end
368:   end
369:   assign cmd_consty_err_d = (cmd_chk & (enables_q != enables_d)) |
370:                             cmd_consty_err_q;
371: 
372:   // if a one hot error occurs, latch onto it permanently
373:   // SEC_CM: KMAC_IF_CMD.CTRL.CONSISTENCY
374:   logic one_hot_err_q, one_hot_err_d;
375:   assign one_hot_err_d = |(enables_d & enables_sub) |
376:                          one_hot_err_q;
377: 
378:   always_ff @(posedge clk_i or negedge rst_ni) begin
379:     if (!rst_ni) begin
380:       one_hot_err_q <= '0;
381:       kmac_done_err_q <= '0;
382:       cmd_consty_err_q <= '0;
383:     end else begin
384:       one_hot_err_q <= one_hot_err_d;
385:       kmac_done_err_q <= kmac_done_err_d;
386:       cmd_consty_err_q <= cmd_consty_err_d;
387:     end
388:   end
389: 
390:   // command error occurs if kmac errors or if the command itself is invalid
391:   assign cmd_error_o = one_hot_err_q | cmd_consty_err_q;
392: 
393:   // request entropy to churn whenever a transaction is accepted
394:   assign prng_en_o = kmac_data_o.valid & kmac_data_i.ready;
395: 
396:   // as long as we are transmitting, the strobe should never be 0.
397:   `ASSERT(LastStrb_A, valid |-> strb != '0)
398: 
399: 
400: endmodule // keymgr_kmac_if

================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_3QlEuiblqyrZVXybBhIohFa5)
 Call ID: call_3QlEuiblqyrZVXybBhIohFa5
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv
    top_module: keymgr_kmac_if
    security_objective: masking enforcement, data leakage, privilege escalation
================================ Human Message =================================

Are there security concerns related to masking enforcement, data leakage, privilege escalation in the provided RTL:
    """

    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Key manager interface to kmac
//

`include "prim_assert.sv"

module keymgr_kmac_if
  import keymgr_pkg::*;
#(
  parameter rand_perm_t RndCnstRandPerm = RndCnstRandPermDefault
) (
  input clk_i,
  input rst_ni,

  // data input interfaces
  input [AdvDataWidth-1:0] adv_data_i,
  input [IdDataWidth-1:0] id_data_i,
  input [GenDataWidth-1:0] gen_data_i,
  input [3:0] inputs_invalid_i,
  output logic inputs_invalid_o,

  // keymgr control to select appropriate inputs
  input adv_en_i,
  input id_en_i,
  input gen_en_i,
  output logic done_o,
  output logic [Shares-1:0][kmac_pkg::AppDigestW-1:0] data_o,

  // actual connection to kmac
  output kmac_pkg::app_req_t kmac_data_o,
  input  kmac_pkg::app_rsp_t kmac_data_i,

  // entropy input
  output logic prng_en_o,
  input [Shares-1:0][RandWidth-1:0] entropy_i,

  // error outputs
  output logic fsm_error_o,
  output logic kmac_error_o,
  output logic kmac_done_error_o,
  output logic cmd_error_o
);


  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 5 -m 6 -n 10 \
  //      -s 2292624416 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: --
  //  4: --
  //  5: |||||||||||||||||||| (46.67%)
  //  6: ||||||||||||||||| (40.00%)
  //  7: ||||| (13.33%)
  //  8: --
  //  9: --
  // 10: --
  //
  // Minimum Hamming distance: 5
  // Maximum Hamming distance: 7
  // Minimum Hamming weight: 2
  // Maximum Hamming weight: 9
  //
  localparam int StateWidth = 10;
  typedef enum logic [StateWidth-1:0] {
    StIdle    = 10'b1110100010,
    StTx      = 10'b0010011011,
    StTxLast  = 10'b0101000000,
    StOpWait  = 10'b1000101001,
    StClean   = 10'b1111111101,
    StError   = 10'b0011101110
  } data_state_e;

  localparam int AdvRem = AdvDataWidth % KmacDataIfWidth;
  localparam int IdRem  = IdDataWidth  % KmacDataIfWidth;
  localparam int GenRem = GenDataWidth % KmacDataIfWidth;

  // the remainder must be in number of bytes
  `ASSERT_INIT(AdvRemBytes_A, AdvRem % 8 == 0)
  `ASSERT_INIT(IdRemBytes_A,  IdRem  % 8 == 0)
  `ASSERT_INIT(GenRemBytes_A, GenRem % 8 == 0)

  // Number of kmac transactions required
  localparam int AdvRounds = (AdvDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
  localparam int IdRounds  = (IdDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
  localparam int GenRounds = (GenDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
  localparam int MaxRounds = KDFMaxWidth  / KmacDataIfWidth;

  // calculated parameters for number of roudns and interface width
  localparam int CntWidth = $clog2(MaxRounds);
  localparam int IfBytes = KmacDataIfWidth / 8;
  localparam int DecoyCopies = KmacDataIfWidth / RandWidth;
  localparam int DecoyOutputCopies = (kmac_pkg::AppDigestW / RandWidth);

  localparam int unsigned LastAdvRoundInt = AdvRounds - 1;
  localparam int unsigned LastIdRoundInt = IdRounds - 1;
  localparam int unsigned LastGenRoundInt = GenRounds - 1;
  localparam bit [CntWidth-1:0] LastAdvRound = LastAdvRoundInt[CntWidth-1:0];
  localparam bit [CntWidth-1:0] LastIdRound = LastIdRoundInt[CntWidth-1:0];
  localparam bit [CntWidth-1:0] LastGenRound = LastGenRoundInt[CntWidth-1:0];

  // byte mask for the last transfer
  localparam logic [IfBytes-1:0] AdvByteMask = (AdvRem > 0) ? (2**(AdvRem/8)-1) : {IfBytes{1'b1}};
  localparam logic [IfBytes-1:0] IdByteMask  = (IdRem > 0)  ? (2**(IdRem/8)-1)  : {IfBytes{1'b1}};
  localparam logic [IfBytes-1:0] GenByteMask = (GenRem > 0) ? (2**(GenRem/8)-1) : {IfBytes{1'b1}};

  logic [MaxRounds-1:0][KmacDataIfWidth-1:0] adv_data;
  logic [MaxRounds-1:0][KmacDataIfWidth-1:0] id_data;
  logic [MaxRounds-1:0][KmacDataIfWidth-1:0] gen_data;
  logic [CntWidth-1:0] cnt;
  logic [CntWidth-1:0] rounds;
  logic [KmacDataIfWidth-1:0] decoy_data;
  logic valid;
  logic last;
  logic [IfBytes-1:0] strb;
  logic cnt_clr, cnt_set, cnt_en;
  logic start;
  logic [3:0] inputs_invalid_d, inputs_invalid_q;
  logic clr_err;
  logic kmac_done_vld;
  logic cmd_chk;

  data_state_e state_q, state_d;

  // 0 pad to the appropriate width
  // this is basically for scenarios where *DataWidth % KmacDataIfWidth != 0
  assign adv_data = KDFMaxWidth'(adv_data_i);
  assign id_data  = KDFMaxWidth'(id_data_i);
  assign gen_data = KDFMaxWidth'(gen_data_i);

  assign start = adv_en_i | id_en_i | gen_en_i;

  logic cnt_err;
  // SEC_CM: KMAC_IF.CTR.REDUN
  prim_count #(
    .Width(CntWidth),
    .ResetValue({CntWidth{1'b1}})
  ) u_cnt (
    .clk_i,
    .rst_ni,
    .clr_i(cnt_clr),
    .set_i(cnt_set),
    .set_cnt_i(rounds),
    .incr_en_i(1'b0),
    .decr_en_i(cnt_en),
    .step_i(CntWidth'(1'b1)),
    .commit_i(1'b1),
    .cnt_o(cnt),
    .cnt_after_commit_o(),
    .err_o(cnt_err)
  );

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      inputs_invalid_q <= '0;
    end else begin
      inputs_invalid_q <= inputs_invalid_d;
    end
   end

  // SEC_CM: KMAC_IF.FSM.SPARSE
  `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, data_state_e, StIdle)

  always_comb begin
    cnt_clr = 1'b0;
    cnt_set = 1'b0;
    cnt_en  = 1'b0;
    valid   = 1'b0;
    last    = 1'b0;
    strb    = '0;
    done_o  = 1'b0;
    state_d = state_q;
    rounds  = '0;

    clr_err = '0;
    fsm_error_o = '0;
    kmac_error_o = '0;

    kmac_done_vld = '0;

    cmd_chk = 1'b1;

    unique case (state_q)

      StIdle: begin
        // if for some reason multiple bits are set, adv_en has priority
        // as the current key state will be destroyed

        // cross check for commands once transaction begins
        cmd_chk = '0;
        if (start) begin
          cnt_set = 1'b1;
          if (adv_en_i) begin
            rounds = LastAdvRound;
          end else if (id_en_i) begin
            rounds = LastIdRound;
          end else if (gen_en_i) begin
            rounds = LastGenRound;
          end
          // in case we are sending only 1 entry
          state_d = (rounds == 0) ? StTxLast : StTx;
        end
      end

      StTx: begin
        valid = 1'b1;
        strb = {IfBytes{1'b1}};

        // transaction accepted
        if (kmac_data_i.ready) begin
          cnt_en = 1'b1;

          // second to last beat
          if (cnt == CntWidth'(1'b1)) begin
            state_d = StTxLast;
          end
        end

      end

      StTxLast: begin
        valid = 1'b1;
        last = 1'b1;

        if (adv_en_i) begin
          strb = AdvByteMask;
        end else if (id_en_i) begin
          strb = IdByteMask;
        end else if (gen_en_i) begin
          strb = GenByteMask;
        end

        // transaction accepted
        cnt_clr = kmac_data_i.ready;
        state_d = kmac_data_i.ready ? StOpWait : StTxLast;

      end

      StOpWait: begin
        kmac_done_vld = 1'b1;
        if (kmac_data_i.done) begin
          kmac_error_o = kmac_data_i.error;
          done_o = 1'b1;
          state_d = StClean;
        end
      end

      StClean: begin
        cmd_chk = '0;
        done_o = 1'b1;

        // wait for control side to ack done by waiting start de-assertion
        if (!start) begin
          done_o = 1'b0;
          clr_err = 1'b1;
          state_d = StIdle;
        end
      end

      // trigger error
      default: begin
        // This state is terminal
        done_o = 1'b1;
        fsm_error_o = 1'b1;
      end

    endcase // unique case (state_q)

    // unconditional error transitions
    // counter errors may disturb the fsm flow and are
    // treated like fsm errors
    if (cnt_err) begin
      state_d = StError;
      fsm_error_o = 1;
      done_o = 1'b1;
    end
  end

  // when transaction is not complete, populate the data with random
  assign data_o = start && done_o ?
                  {kmac_data_i.digest_share1,
                   kmac_data_i.digest_share0} :
                  {{DecoyOutputCopies{entropy_i[1]}},
                   {DecoyOutputCopies{entropy_i[0]}}};

  // The input invalid check is done whenever transactions are ongoing with kmac
  // once set, it cannot be unset until transactions are fully complete
  always_comb begin
    inputs_invalid_d = inputs_invalid_q;

    if (clr_err) begin
      inputs_invalid_d = '0;
    end else if (valid) begin
      inputs_invalid_d[OpAdvance]  = adv_en_i & (inputs_invalid_i[OpAdvance] |
                                                 inputs_invalid_q[OpAdvance]);
      inputs_invalid_d[OpGenId]    = id_en_i  & (inputs_invalid_i[OpGenId]   |
                                                 inputs_invalid_q[OpGenId]);
      inputs_invalid_d[OpGenSwOut] = gen_en_i & (inputs_invalid_i[OpGenSwOut]|
                                                 inputs_invalid_q[OpGenSwOut]);
      inputs_invalid_d[OpGenHwOut] = gen_en_i & (inputs_invalid_i[OpGenHwOut]|
                                                 inputs_invalid_q[OpGenHwOut]);
    end
  end

  // immediately assert errors
  assign inputs_invalid_o = |inputs_invalid_d;

  // Permute Share 1 of the entropy input once more to get the decoy data.
  // Share 0 and 1 are used as is for data_o (connected to the sideload ports).
  logic [RandWidth-1:0] decoy_entropy;
  assign decoy_entropy = perm_data(entropy_i[1], RndCnstRandPerm);
  assign decoy_data = {DecoyCopies{decoy_entropy}};

  logic [CntWidth-1:0] adv_sel, id_sel, gen_sel;
  assign adv_sel = LastAdvRound - cnt;
  assign id_sel = LastIdRound - cnt;
  assign gen_sel = LastGenRound - cnt;

  // The count is maintained as a downcount
  // so a subtract is necessary to send the right byte
  // alternatively we can also reverse the order of the input
  always_comb begin
    kmac_data_o.data  = decoy_data;
    if (|cmd_error_o || inputs_invalid_o || fsm_error_o) begin
      kmac_data_o.data  = decoy_data;
    end else if (valid && adv_en_i) begin
      kmac_data_o.data  = adv_data[adv_sel];
    end else if (valid && id_en_i) begin
      kmac_data_o.data  = id_data[id_sel];
    end else if (valid && gen_en_i) begin
      kmac_data_o.data  = gen_data[gen_sel];
    end
  end

  assign kmac_data_o.valid = valid;
  assign kmac_data_o.last  = last;
  assign kmac_data_o.strb  = strb;

  // kmac done is asserted outside of expected window
  // SEC_CM: KMAC_IF_DONE.CTRL.CONSISTENCY
  logic kmac_done_err_q, kmac_done_err_d;
  assign kmac_done_err_d = ~kmac_done_vld & kmac_data_i.done |
                           kmac_done_err_q;
  assign kmac_done_error_o = kmac_done_err_q;


  // the enables must be 1 hot
  logic [2:0] enables_d, enables_q, enables_sub;
  assign enables_d = {adv_en_i, id_en_i, gen_en_i};
  assign enables_sub = enables_d - 1'b1;

  // cross check to ensure the one-hot command that kicked off
  // the transaction remains consistent throughout.
  logic cmd_consty_err_q, cmd_consty_err_d;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      enables_q <= '0;
    end else if (cnt_set) begin
      enables_q <= enables_d;
    end
  end
  assign cmd_consty_err_d = (cmd_chk & (enables_q != enables_d)) |
                            cmd_consty_err_q;

  // if a one hot error occurs, latch onto it permanently
  // SEC_CM: KMAC_IF_CMD.CTRL.CONSISTENCY
  logic one_hot_err_q, one_hot_err_d;
  assign one_hot_err_d = |(enables_d & enables_sub) |
                         one_hot_err_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      one_hot_err_q <= '0;
      kmac_done_err_q <= '0;
      cmd_consty_err_q <= '0;
    end else begin
      one_hot_err_q <= one_hot_err_d;
      kmac_done_err_q <= kmac_done_err_d;
      cmd_consty_err_q <= cmd_consty_err_d;
    end
  end

  // command error occurs if kmac errors or if the command itself is invalid
  assign cmd_error_o = one_hot_err_q | cmd_consty_err_q;

  // request entropy to churn whenever a transaction is accepted
  assign prng_en_o = kmac_data_o.valid & kmac_data_i.ready;

  // as long as we are transmitting, the strobe should never be 0.
  `ASSERT(LastStrb_A, valid |-> strb != '0)


endmodule // keymgr_kmac_if


    """


    Identify the CWE relevant to the security issue for the given RTL.
    Obtain details of the CWE.

    Then determine if there are security issues relevant to the identified CWE in the RTL.
    Refer to the code that corresponds to the issues identified.
    
================================== Ai Message ==================================

[{'text': "I'll analyze the RTL code for security concerns related to masking enforcement, data leakage, and privilege escalation. Let me first identify relevant CWEs that might apply to these security areas in hardware design.", 'type': 'text'}, {'id': 'toolu_01LN2wd7xvEagNQ4wzpU8voe', 'input': {'security_issue': 'hardware masking enforcement'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01LN2wd7xvEagNQ4wzpU8voe)
 Call ID: toolu_01LN2wd7xvEagNQ4wzpU8voe
  Args:
    security_issue: hardware masking enforcement
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1256: Improper Restriction of Software Interfaces to Hardware Features
The product provides software-controllable device functionality for capabilities such as power and clock management, but it does not properly limit functionality that can lead to modification of hardware memory or register bits, or the ability to observe physical side channels.
It is frequently assumed that physical attacks such as fault injection and side-channel analysis require an attacker to have physical access to the target device. This assumption may be false if the device has improperly secured power management features, or similar features. For mobile devices, minimizing power consumption is critical, but these devices run a wide variety of applications with different performance requirements. Software-controllable mechanisms to dynamically scale device voltage and frequency and monitor power consumption are common features in today's chipsets, but they also enable attackers to mount fault injection and side-channel attacks without having physical access to the device.
Example 1
This example considers the Rowhammer problem. The Rowhammer issue was caused by a program in a tight loop writing repeatedly to a location to which the program was allowed to write but causing an adjacent memory location value to change.
(bad code)
Example Language: Other
Continuously writing the same value to the same address causes the value of an adjacent location to change value.
Preventing the loop required to defeat the Rowhammer exploit is not always possible:
(good code)
Example Language: Other
Redesign the RAM devices to reduce inter capacitive coupling making the Rowhammer exploit impossible. While the redesign may be possible for new devices, a redesign is not possible in existing devices. There is also the possibility that reducing capacitance with a relayout would impact the density of the device resulting in a less capable, more costly device.

Example 2
Suppose a hardware design implements a set of software-accessible registers for scaling clock frequency and voltage but does not control access to these registers. Attackers may cause register and memory changes and race conditions by changing the clock or voltage of the device under their control.

Example 3
Consider the following SoC design. Security-critical settings for scaling clock frequency and voltage are available in a range of registers bounded by [PRIV_END_ADDR : PRIV_START_ADDR] in the tmcu.csr module in the HW Root of Trust. These values are writable based on the lock_bit register in the same module. The lock_bit is only writable by privileged software running on the tmcu. We assume that untrusted software running on any of the Core{0-N} processors has access to the input and output ports of the hrot_iface. If untrusted software can clear the lock_bit or write the clock frequency and voltage registers due to inadequate protection, a fault injection attack could be performed.


================================== Ai Message ==================================

[{'id': 'toolu_01TiRKoiADoXfZ71TBLbVzTF', 'input': {'security_issue': 'hardware data leakage'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01TiRKoiADoXfZ71TBLbVzTF)
 Call ID: toolu_01TiRKoiADoXfZ71TBLbVzTF
  Args:
    security_issue: hardware data leakage
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component
The product's data removal process does not completely delete all data and potentially sensitive information within hardware components.
Physical properties of hardware devices, such as remanence of magnetic media, residual charge of ROMs/RAMs, or screen burn-in may still retain sensitive data after a data removal process has taken place and power is removed.

================================== Ai Message ==================================

[{'id': 'toolu_011TtAhT5oBN96SeScV3iQs4', 'input': {'security_issue': 'side channel attacks in hardware'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_011TtAhT5oBN96SeScV3iQs4)
 Call ID: toolu_011TtAhT5oBN96SeScV3iQs4
  Args:
    security_issue: side channel attacks in hardware
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1256: Improper Restriction of Software Interfaces to Hardware Features
The product provides software-controllable device functionality for capabilities such as power and clock management, but it does not properly limit functionality that can lead to modification of hardware memory or register bits, or the ability to observe physical side channels.
It is frequently assumed that physical attacks such as fault injection and side-channel analysis require an attacker to have physical access to the target device. This assumption may be false if the device has improperly secured power management features, or similar features. For mobile devices, minimizing power consumption is critical, but these devices run a wide variety of applications with different performance requirements. Software-controllable mechanisms to dynamically scale device voltage and frequency and monitor power consumption are common features in today's chipsets, but they also enable attackers to mount fault injection and side-channel attacks without having physical access to the device.
Example 1
This example considers the Rowhammer problem. The Rowhammer issue was caused by a program in a tight loop writing repeatedly to a location to which the program was allowed to write but causing an adjacent memory location value to change.
(bad code)
Example Language: Other
Continuously writing the same value to the same address causes the value of an adjacent location to change value.
Preventing the loop required to defeat the Rowhammer exploit is not always possible:
(good code)
Example Language: Other
Redesign the RAM devices to reduce inter capacitive coupling making the Rowhammer exploit impossible. While the redesign may be possible for new devices, a redesign is not possible in existing devices. There is also the possibility that reducing capacitance with a relayout would impact the density of the device resulting in a less capable, more costly device.

Example 2
Suppose a hardware design implements a set of software-accessible registers for scaling clock frequency and voltage but does not control access to these registers. Attackers may cause register and memory changes and race conditions by changing the clock or voltage of the device under their control.

Example 3
Consider the following SoC design. Security-critical settings for scaling clock frequency and voltage are available in a range of registers bounded by [PRIV_END_ADDR : PRIV_START_ADDR] in the tmcu.csr module in the HW Root of Trust. These values are writable based on the lock_bit register in the same module. The lock_bit is only writable by privileged software running on the tmcu. We assume that untrusted software running on any of the Core{0-N} processors has access to the input and output ports of the hrot_iface. If untrusted software can clear the lock_bit or write the clock frequency and voltage registers due to inadequate protection, a fault injection attack could be performed.


================================== Ai Message ==================================

[{'id': 'toolu_01KteJY4WVGvYeFJnJEc65L9', 'input': {'security_issue': 'hardware cryptographic masking'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01KteJY4WVGvYeFJnJEc65L9)
 Call ID: toolu_01KteJY4WVGvYeFJnJEc65L9
  Args:
    security_issue: hardware cryptographic masking
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

[{"id": "toolu_01KteJY4WVGvYeFJnJEc65L9", "input": {"security_issue": "hardware cryptographic masking"}, "name": "llm_cwe_details_retriever_tool", "type": "tool_use"}]
================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_Tc3B0iSHL994QObIuJwNd4LP)
 Call ID: call_Tc3B0iSHL994QObIuJwNd4LP
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_ctrl.sv
    top_module: keymgr_ctrl
    security_objective: illegal state transitions, privilege escalation, FSM stuck/faulty
================================ Human Message =================================

Are there security concerns related to illegal state transitions, privilege escalation, FSM stuck/faulty in the provided RTL:
    """

    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Key manager top level
//

`include "prim_assert.sv"

module keymgr_ctrl
  import keymgr_pkg::*;
  import keymgr_reg_pkg::*;
#(
  parameter bit KmacEnMasking = 1'b1
) (
  input clk_i,
  input rst_ni,

  // lifecycle enforcement
  // SEC_CM: CTRL.FSM.GLOBAL_ESC
  input en_i,

  // faults that can occur outside of operations
  input regfile_intg_err_i,
  input shadowed_update_err_i,
  input shadowed_storage_err_i,
  input reseed_cnt_err_i,
  input sideload_sel_err_i,
  input sideload_fsm_err_i,

  // Software interface
  input op_start_i,
  input keymgr_ops_e op_i,
  input [CdiWidth-1:0] op_cdi_sel_i,
  output logic op_done_o,
  output keymgr_op_status_e status_o,
  output logic [ErrLastPos-1:0] error_o,
  output logic [FaultLastPos-1:0] fault_o,
  output logic data_hw_en_o,
  output logic data_sw_en_o,
  output logic data_valid_o,
  output logic wipe_key_o,
  output keymgr_working_state_e working_state_o,
  output logic sw_binding_unlock_o,
  output logic init_o,

  // Data input
  input  otp_ctrl_pkg::otp_keymgr_key_t root_key_i,
  output prim_mubi_pkg::mubi4_t hw_sel_o,
  output keymgr_stage_e stage_sel_o,
  output logic invalid_stage_sel_o,
  output logic [CdiWidth-1:0] cdi_sel_o,

  // KMAC ctrl interface
  output logic adv_en_o,
  output logic id_en_o,
  output logic gen_en_o,
  output hw_key_req_t key_o,
  input kmac_done_i,
  input kmac_input_invalid_i, // asserted when selected data fails criteria check
  input kmac_fsm_err_i, // asserted when kmac fsm reaches unexpected state
  input kmac_op_err_i,  // asserted when kmac itself reports an error
  input kmac_done_err_i,// asserted when kmac unexpectedly toggles done
  input kmac_cmd_err_i, // asserted when more than one command given to kmac
  input [Shares-1:0][KeyWidth-1:0] kmac_data_i,

  // prng control interface
  input [Shares-1:0][RandWidth-1:0] entropy_i,
  input prng_reseed_done_i,
  input prng_reseed_ack_i,
  output logic prng_reseed_req_o,
  output logic prng_en_o
);

  localparam int EntropyWidth = LfsrWidth / 2;
  localparam int EntropyRounds = KeyWidth / EntropyWidth;
  localparam int EntropyRndWidth = prim_util_pkg::vbits(EntropyRounds);
  localparam int CntWidth = EntropyRounds > CDIs ? EntropyRndWidth : CdiWidth;
  localparam int EccDataWidth = 64;
  localparam int EccWidth = 8;
  localparam int EccWords = KeyWidth / EccDataWidth;
  localparam int TotalEccWords = EccWords * Shares * CDIs;


  // Enumeration for working state
  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 5 -m 11 -n 10 \
  //      -s 4101887575 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: --
  //  4: --
  //  5: |||||||||||||||||||| (54.55%)
  //  6: |||||||||||||||| (45.45%)
  //  7: --
  //  8: --
  //  9: --
  // 10: --
  //
  // Minimum Hamming distance: 5
  // Maximum Hamming distance: 6
  // Minimum Hamming weight: 2
  // Maximum Hamming weight: 8
  //
  localparam int StateWidth = 10;
  typedef enum logic [StateWidth-1:0] {
    StCtrlReset          = 10'b1101100001,
    StCtrlEntropyReseed  = 10'b1110010010,
    StCtrlRandom         = 10'b0011110100,
    StCtrlRootKey        = 10'b0110101111,
    StCtrlInit           = 10'b0100000100,
    StCtrlCreatorRootKey = 10'b1000011101,
    StCtrlOwnerIntKey    = 10'b0001001010,
    StCtrlOwnerKey       = 10'b1101111110,
    StCtrlDisabled       = 10'b1010101000,
    StCtrlWipe           = 10'b0000110011,
    StCtrlInvalid        = 10'b1011000111
  } state_e;
  state_e state_q, state_d;

  // A variable that represents differentiates states before root key and after root key.
  logic initialized;

  // There are two versions of the key state, one for sealing one for attestation
  // Among each version, there are multiple shares
  // Each share is a fixed multiple of the entropy width
  logic [CDIs-1:0][Shares-1:0][EntropyRounds-1:0][EntropyWidth-1:0] key_state_d;
  logic [CDIs-1:0][Shares-1:0][EccWords-1:0][EccDataWidth-1:0] key_state_ecc_words_d;
  logic [CDIs-1:0][Shares-1:0][EccWords-1:0][EccDataWidth-1:0] key_state_q;
  logic [CDIs-1:0][Shares-1:0][EccWords-1:0][EccWidth-1:0] key_state_ecc_q;
  logic [CntWidth-1:0] cnt;
  logic [CdiWidth-1:0] cdi_cnt;

  // error conditions
  logic invalid_kmac_out;
  logic invalid_op;
  logic cnt_err;
  // states fall out of sparsely encoded range
  logic state_intg_err_q, state_intg_err_d;

  ///////////////////////////
  //  General operation decode
  ///////////////////////////

  logic adv_op, dis_op, gen_id_op, gen_sw_op, gen_hw_op, gen_op;
  assign adv_op    = (op_i == OpAdvance);
  assign gen_id_op = (op_i == OpGenId);
  assign gen_sw_op = (op_i == OpGenSwOut);
  assign gen_hw_op = (op_i == OpGenHwOut);
  assign dis_op    = ~(op_i inside {OpAdvance, OpGenId, OpGenSwOut, OpGenHwOut});
  assign gen_op    = (gen_id_op | gen_sw_op | gen_hw_op);

  ///////////////////////////
  //  interaction between software and main fsm
  ///////////////////////////
  // disable is treated like an advanced call
  logic advance_sel;
  logic disable_sel;
  logic gen_out_hw_sel;

  assign advance_sel    = op_start_i & adv_op    & en_i;
  assign gen_out_hw_sel = op_start_i & gen_hw_op & en_i;

  // disable is selected whenever a normal operation is not set
  assign disable_sel    = (op_start_i & dis_op) | !en_i;


  ///////////////////////////
  //  interaction between main control fsm and operation fsm
  ///////////////////////////

  // req/ack interface with op handling fsm
  logic op_req;
  logic op_ack;
  logic op_update;
  logic op_busy;
  logic disabled;
  logic invalid;

  logic adv_req, dis_req, id_req, gen_req;
  assign adv_req = op_req & adv_op;
  assign dis_req = op_req & dis_op;
  assign id_req  = op_req & gen_id_op;
  assign gen_req = op_req & (gen_sw_op | gen_hw_op);

  ///////////////////////////
  //  interaction between operation fsm and software
  ///////////////////////////
  // categories of keymgr errors
  logic [SyncErrLastIdx-1:0] sync_err;
  logic [SyncFaultLastIdx-1:0] sync_fault;
  logic [AsyncFaultLastIdx-1:0] async_fault;

  logic op_err;
  logic op_fault_err;

  // unlock sw binding configuration whenever an advance call is made without errors
  assign sw_binding_unlock_o = adv_req & op_ack & ~(op_err | op_fault_err);

  // error definition
  // check incoming kmac data validity
  // Only check during the periods when there is actual kmac output
  assign invalid_kmac_out = (op_update | op_ack) &
                            (~valid_data_chk(kmac_data_i[0]) |
                            (~valid_data_chk(kmac_data_i[1]) & KmacEnMasking));

  // async errors have nothing to do with the operation and thus should not
  // impact operation results.
  assign op_err = |sync_err;

  assign op_fault_err = |{sync_fault, async_fault};

  ///////////////////////////
  //  key update controls
  ///////////////////////////

  // update select can come from both main and operation fsm's
  keymgr_key_update_e update_sel, op_update_sel;

  // req from main control fsm to key update controls
  logic wipe_req;
  logic random_req;
  logic random_ack;

  // wipe and initialize take precedence
  assign update_sel = wipe_req             ? KeyUpdateWipe   :
                      random_req           ? KeyUpdateRandom :
                      init_o               ? KeyUpdateRoot   : op_update_sel;

  ///////////////////////////
  //  interaction between main fsm and prng
  ///////////////////////////

  // Upon entering StCtrlDisabled or StCtrlInvalid, the PRNG is kept advancing until it has been
  // reseeded twice (through the reseeding mechansism inside keymgr_reseed_ctrl.sv).
  logic [1:0] prng_en_dis_inv_d, prng_en_dis_inv_q;
  logic prng_en_dis_inv_set;

  assign prng_en_dis_inv_d =
      prng_en_dis_inv_set ? 2'b11 :
      prng_reseed_done_i  ? {1'b0, prng_en_dis_inv_q[1]} : prng_en_dis_inv_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      prng_en_dis_inv_q <= '0;
    end else begin
      prng_en_dis_inv_q <= prng_en_dis_inv_d;
    end
  end

  assign prng_en_o = random_req | wipe_req | prng_en_dis_inv_q[0];

  //////////////////////////
  // Main Control FSM
  //////////////////////////
  // SEC_CM: CTRL.FSM.SPARSE
  `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, state_e, StCtrlReset)

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      state_intg_err_q <= '0;
    end else begin
      state_intg_err_q <= state_intg_err_d;
    end
  end

  // prevents unknowns from reaching the outside world.
  // - whatever operation causes the input data select to be disabled should not expose the key
  //   state.
  // - when there are no operations, the key state also should be exposed.
  assign key_o.valid = op_req;

  assign cdi_sel_o = advance_sel ? cdi_cnt : op_cdi_sel_i;

  assign invalid_stage_sel_o = ~(stage_sel_o inside {Creator, OwnerInt, Owner});
  for (genvar i = 0; i < Shares; i++) begin : gen_key_out_assign
    assign key_o.key[i] = invalid_stage_sel_o ?
                          {EntropyRounds{entropy_i[i]}} :
                          key_state_q[cdi_sel_o][i];
  end


  //SEC_CM: CTRL.KEY.INTEGRITY
  assign key_state_ecc_words_d = key_state_d;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      key_state_q <= '0;
      key_state_ecc_q <= {TotalEccWords{prim_secded_pkg::SecdedInv7264ZeroEcc}};
    end else begin
      for (int i = 0; i < CDIs; i++) begin
        for (int j = 0; j < Shares; j++) begin
          for (int k = 0; k < EccWords; k++) begin
            {key_state_ecc_q[i][j][k]} <=
                prim_secded_pkg::prim_secded_inv_72_64_enc(key_state_ecc_words_d[i][j][k]);
          end
        end
      end
    end
  end

  logic [CDIs-1:0][Shares-1:0][EccWords-1:0] ecc_errs;
  for (genvar i = 0; i < CDIs; i++) begin : gen_ecc_loop_cdi
    for (genvar j = 0; j < Shares; j++) begin : gen_ecc_loop_shares
      for (genvar k = 0; k < EccWords; k++) begin : gen_ecc_loop_words
        logic [1:0] errs;
        prim_secded_inv_72_64_dec u_dec (
          .data_i({key_state_ecc_q[i][j][k], key_state_q[i][j][k]}),
          .data_o(),
          .syndrome_o(),
          .err_o(errs)
        );
        assign ecc_errs[i][j][k] = |errs;
      end
    end
  end

  // These are consumed one level above in keymgr.sv
  logic unused_otp_sigs;
  assign unused_otp_sigs = ^{root_key_i.creator_seed,
                             root_key_i.creator_seed_valid,
                             root_key_i.owner_seed,
                             root_key_i.owner_seed_valid};

  // root key valid sync
  logic root_key_valid_q;

  prim_flop_2sync # (
    .Width(1)
  ) u_key_valid_sync (
    .clk_i,
    .rst_ni,
    // Both valid signals are flopped in OTP_CTRL, and they only ever transition from 0 -> 1.
    // It is hence ok to AND them here before the synchronizer, since we don't expect this
    // to create glitches.
    .d_i(root_key_i.creator_root_key_share0_valid &&
         root_key_i.creator_root_key_share1_valid),
    .q_o(root_key_valid_q)
  );

  // Do not let the count toggle unless an advance operation is
  // selected
  assign cdi_cnt = op_req ? cnt[CdiWidth-1:0] : '0;

  always_comb begin
    key_state_d = key_state_q;
    data_valid_o = 1'b0;
    wipe_key_o = 1'b0;

    // if a wipe request arrives, immediately destroy the
    // keys regardless of current state
    unique case (update_sel)
      KeyUpdateRandom: begin
        for (int i = 0; i < CDIs; i++) begin
          for (int j = 0; j < Shares; j++) begin
            // Load each share with the same randomness so we can
            // later simply XOR root key on them
            key_state_d[i][j][cnt[EntropyRndWidth-1:0]] = entropy_i[i];
          end
        end
      end

      KeyUpdateRoot: begin
        if (root_key_valid_q) begin
          for (int i = 0; i < CDIs; i++) begin
            if (KmacEnMasking) begin : gen_two_share_key
              key_state_d[i][0] ^= root_key_i.creator_root_key_share0;
              key_state_d[i][1] ^= root_key_i.creator_root_key_share1;
            end else begin : gen_one_share_key
              key_state_d[i][0] = root_key_i.creator_root_key_share0 ^
                                  root_key_i.creator_root_key_share1;
              key_state_d[i][1] = '0;
            end
          end
        end else begin
          // if root key is not valid, load and invalid value
          for (int i = 0; i < CDIs; i++) begin
              key_state_d[i][0] = '0;
              key_state_d[i][1] = '{default: '1};
          end
        end
      end

      KeyUpdateKmac: begin
        data_valid_o = gen_op;
        key_state_d[cdi_sel_o] = (adv_op || dis_op) ? kmac_data_i : key_state_q[cdi_sel_o];
      end

      KeyUpdateWipe: begin
        wipe_key_o = 1'b1;
        for (int i = 0; i < CDIs; i++) begin
          for (int j = 0; j < Shares; j++) begin
            key_state_d[i][j] = {EntropyRounds{entropy_i[j]}};
          end
        end
      end

      default:;
    endcase // unique case (update_sel)
  end

  // SEC_CM: CTRL.CTR.REDUN
  prim_count #(
    .Width(CntWidth)
  ) u_cnt (
    .clk_i,
    .rst_ni,
    .clr_i(op_ack | random_ack),
    .set_i('0),
    .set_cnt_i('0),
    .incr_en_i(op_update | random_req),
    .decr_en_i(1'b0),
    .step_i(CntWidth'(1'b1)),
    .commit_i(1'b1),
    .cnt_o(cnt),
    .cnt_after_commit_o(),
    .err_o(cnt_err)
  );


  prim_mubi4_sender u_hw_sel (
    .clk_i,
    .rst_ni,
    .mubi_i (prim_mubi_pkg::mubi4_bool_to_mubi(gen_out_hw_sel)),
    .mubi_o (hw_sel_o)
  );

  // when in a state that accepts commands, look at op_ack for completion
  // when in a state that does not accept commands, wait for other triggers.
  assign op_done_o = op_req ? op_ack :
                     (init_o | invalid_op);


  // There are 3 possibilities
  // advance to next state (software command)
  // advance to disabled state (software command)
  // advance to invalid state (detected fault)
  logic adv_state;
  logic dis_state;
  logic inv_state;
  assign adv_state = op_ack & adv_req & ~op_err;
  assign dis_state = op_ack & dis_req;

  // SEC_CM: CTRL.FSM.LOCAL_ESC
  // begin invalidation when faults are observed.
  // sync faults only invalidate on transaction boudaries
  // async faults begin invalidating immediately
  assign inv_state = |fault_o;

  always_comb begin
    // persistent data
    state_d = state_q;

    // request to op handling
    op_req = 1'b0;
    random_req = 1'b0;
    random_ack = 1'b0;

    // request to key updates
    wipe_req = 1'b0;

    // invalid operation issued
    invalid_op = '0;

    // data update and select signals
    stage_sel_o = Disable;

    // indication that state is disabled
    disabled = 1'b0;

    // indication that state is invalid
    invalid = 1'b0;

    // Don't request final PRNG updating and reseeding.
    prng_en_dis_inv_set = 1'b0;

    // Request PRNG reseeding.
    prng_reseed_req_o = 1'b0;

    // initialization complete
    init_o = 1'b0;

    // Most states are initialized, mark the exceptions
    initialized = 1'b1;

    // if state is ever faulted, hold on to this indication
    // until reset.
    state_intg_err_d = state_intg_err_q;

    unique case (state_q)
      // Only advance can be called from reset state
      StCtrlReset: begin
        initialized = 1'b0;

        // always use random data for advance, since out of reset state
        // the key state will be randomized.
        stage_sel_o = Disable;

        // key state is updated when it is an advance call
        // all other operations are invalid, including disable
        invalid_op = op_start_i & ~advance_sel;

        // if there was a structural fault before anything began, wipe immediately
        if (inv_state) begin
          state_d = StCtrlWipe;
        end else if (advance_sel) begin
          state_d = StCtrlEntropyReseed;
        end
      end

      // reseed entropy
      StCtrlEntropyReseed: begin
        initialized = 1'b0;
        prng_reseed_req_o = 1'b1;

        if (prng_reseed_ack_i) begin
          state_d = StCtrlRandom;
        end
      end

      // This state does not accept any command.
      StCtrlRandom: begin
        initialized = 1'b0;
        random_req = 1'b1;

        // when mask population is complete, xor the root_key into the zero share
        // if in the future the root key is updated to 2 shares, it will direclty overwrite
        // the values here
        if (int'(cnt) == EntropyRounds-1) begin
          random_ack = 1'b1;
          state_d = StCtrlRootKey;
        end
      end

      // load the root key.
      StCtrlRootKey: begin
        init_o = 1'b1;
        initialized = 1'b1;
        state_d = (en_i && root_key_valid_q) ? StCtrlInit : StCtrlWipe;
      end

      // Beginning from the Init state, operations are accepted.
      // Only valid operation is advance state. If invalid command received,
      // random data is selected for operation and no persistent state is changed.
      StCtrlInit: begin
        op_req = op_start_i;

        // when advancing select creator data, otherwise use random input
        stage_sel_o = advance_sel ? Creator : Disable;
        invalid_op = op_start_i & ~(advance_sel | disable_sel);

        if (!en_i || inv_state) begin
          state_d = StCtrlWipe;
        end else if (dis_state) begin
          state_d = StCtrlDisabled;
          prng_en_dis_inv_set = 1'b1;
        end else if (adv_state) begin
          state_d = StCtrlCreatorRootKey;
        end
      end

      // all commands  are valid during this stage
      StCtrlCreatorRootKey: begin
        op_req = op_start_i;

        // when generating, select creator data input
        // when advancing, select owner intermediate key as target
        // when disabling, select random data input
        stage_sel_o = disable_sel ? Disable  :
                      advance_sel ? OwnerInt : Creator;

        if (!en_i || inv_state) begin
          state_d = StCtrlWipe;
        end else if (dis_state) begin
          state_d = StCtrlDisabled;
          prng_en_dis_inv_set = 1'b1;
        end else if (adv_state) begin
          state_d = StCtrlOwnerIntKey;
        end
      end

      // all commands are valid during this stage
      StCtrlOwnerIntKey: begin
        op_req = op_start_i;

        // when generating, select owner intermediate data input
        // when advancing, select owner as target
        // when disabling, select random data input
        stage_sel_o = disable_sel ? Disable  :
                      advance_sel ? Owner : OwnerInt;

        if (!en_i || inv_state) begin
          state_d = StCtrlWipe;
        end else if (dis_state) begin
          state_d = StCtrlDisabled;
          prng_en_dis_inv_set = 1'b1;
        end else if (adv_state) begin
          state_d = StCtrlOwnerKey;
        end
      end

      // all commands are valid during this stage
      // however advance goes directly to disabled state
      StCtrlOwnerKey: begin
        op_req = op_start_i;

        // when generating, select owner data input
        // when advancing, select disable as target
        // when disabling, select random data input
        stage_sel_o = disable_sel | advance_sel ? Disable : Owner;

        if (!en_i || inv_state) begin
          state_d = StCtrlWipe;
        end else if (adv_state || dis_state) begin
          state_d = StCtrlDisabled;
          prng_en_dis_inv_set = 1'b1;
        end
      end

      // The wipe state immediately clears out the key state, but waits for any ongoing
      // transaction to finish before going to disabled state.
      // Unlike the random state, this is an immedaite shutdown request, so all parts of the
      // key are wiped.
      StCtrlWipe: begin
        wipe_req = 1'b1;
        // if there was already an operation ongoing, maintain the request until completion
        op_req = op_busy;
        invalid_op = op_start_i;

        // If the enable is dropped during the middle of a transaction, we clear and wait for that
        // transaction to gracefully complete (if it can).
        // There are two scenarios:
        // 1. the operation completed right when we started wiping, in which case the done would
        //    clear the start.
        // 2. the operation completed before we started wiping, or there was never an operation to
        //    begin with (op_start_i == 0), in this case, don't wait and immediately transition
        if (!op_start_i) begin
          state_d = StCtrlInvalid;
          prng_en_dis_inv_set = 1'b1;
        end
      end

      // StCtrlDisabled and StCtrlInvalid are almost functionally equivalent
      // The only difference is that Disabled is entered through software invocation,
      // while Invalid is entered through life cycle disable or operational fault.
      //
      // Both states continue to kick off random transactions
      // All transactions are treated as invalid despite completing
      StCtrlDisabled: begin
        op_req = op_start_i;
        disabled = 1'b1;

        if (!en_i || inv_state) begin
          state_d = StCtrlWipe;
        end
      end

      StCtrlInvalid: begin
        invalid_op = op_start_i;
        invalid = 1'b1;
      end

      // latch the fault indication and start to wipe the key manager
      default: begin
        state_intg_err_d = 1'b1;
        state_d = StCtrlWipe;
      end

    endcase // unique case (state_q)
  end // always_comb

  // Current working state provided for software read
  // Certain states are collapsed for simplicity
  keymgr_working_state_e last_working_st;
  logic update_en;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      last_working_st <= StReset;
    end else if (update_en) begin
      last_working_st <= working_state_o;
    end
  end

  always_comb begin
    update_en = 1'b1;
    working_state_o = StInvalid;

    unique case (state_q)
      StCtrlReset, StCtrlEntropyReseed, StCtrlRandom:
        working_state_o = StReset;

      StCtrlRootKey, StCtrlInit:
        working_state_o = StInit;

      StCtrlCreatorRootKey:
        working_state_o = StCreatorRootKey;

      StCtrlOwnerIntKey:
        working_state_o = StOwnerIntKey;

      StCtrlOwnerKey:
        working_state_o = StOwnerKey;

      StCtrlDisabled:
        working_state_o = StDisabled;

      StCtrlWipe: begin
        update_en = 1'b0;
        working_state_o = last_working_st;
      end

      StCtrlInvalid:
        working_state_o = StInvalid;

      default:
        working_state_o = StInvalid;
    endcase // unique case (state_q)
  end

  always_comb begin
    status_o = OpIdle;
    if (op_done_o) begin
      // It is possible for an operation to finish the same cycle en_i goes low.
      // The main fsm handling is one cycle behind, but still report operation
      // fail.
      status_o = |{error_o, fault_o} ? OpDoneFail : OpDoneSuccess;
    end else if (op_start_i) begin
      status_o = OpWip;
    end
  end


  /////////////////////////
  // Operateion state, handle advance and generate
  /////////////////////////

  logic op_fsm_err;
  keymgr_op_state_ctrl u_op_state (
    .clk_i,
    .rst_ni,
    .adv_req_i(adv_req),
    .dis_req_i(dis_req),
    .id_req_i(id_req),
    .gen_req_i(gen_req),
    .cnt_i(cdi_cnt),
    .op_ack_o(op_ack),
    .op_busy_o(op_busy),
    .op_update_o(op_update),
    .kmac_done_i,
    .adv_en_o,
    .id_en_o,
    .gen_en_o,
    .op_fsm_err_o(op_fsm_err)
  );

  // operational state cross check.  The state value must be consistent with
  // the input operations.
  logic op_state_cmd_err;
  assign op_state_cmd_err = (adv_en_o & ~(advance_sel | disable_sel)) |
                            (gen_en_o & ~gen_op);

  // operations fsm update precedence
  // when in invalid state, always update.
  // when in disabled state, always update unless a fault is encountered.
  assign op_update_sel = (op_ack | op_update) & invalid      ? KeyUpdateKmac :
                         (op_ack | op_update) & op_fault_err ? KeyUpdateWipe :
                         (op_ack | op_update) & disabled     ? KeyUpdateKmac :
                         (op_ack | op_update) & op_err       ? KeyUpdateIdle :
                         (op_ack | op_update)                ? KeyUpdateKmac : KeyUpdateIdle;


  ///////////////////////////////
  // Suppress kmac return data
  ///////////////////////////////

  logic data_fsm_err;
  keymgr_data_en_state u_data_en (
    .clk_i,
    .rst_ni,
    .hw_sel_i(hw_sel_o),
    .adv_en_i(adv_en_o),
    .id_en_i(id_en_o),
    .gen_en_i(gen_en_o),
    .op_done_i(op_done_o),
    .op_start_i,
    .data_hw_en_o,
    .data_sw_en_o,
    .fsm_err_o(data_fsm_err)
  );

  /////////////////////////
  // Cross-checks, errors and faults
  /////////////////////////

  logic vld_state_change_d, vld_state_change_q;
  assign vld_state_change_d = (state_d != state_q) &
                              (state_d inside {StCtrlRootKey,
                                               StCtrlCreatorRootKey,
                                               StCtrlOwnerIntKey,
                                               StCtrlOwnerKey});

  // capture for cross check in following cycle
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      vld_state_change_q <= '0;
    end else begin
      vld_state_change_q <= vld_state_change_d;
    end
  end

  // state cross check
  // if the state advanced, ensure that it was due to an advanced operation
  logic state_change_err;
  assign state_change_err = vld_state_change_q & !adv_op;

  keymgr_err u_err (
    .clk_i,
    .rst_ni,
    .invalid_op_i(invalid_op),
    .disabled_i(disabled | (initialized & ~en_i)),
    .invalid_i(invalid),
    .kmac_input_invalid_i,
    .shadowed_update_err_i,
    .kmac_op_err_i,
    .invalid_kmac_out_i(invalid_kmac_out),
    .sideload_sel_err_i,
    .kmac_cmd_err_i,
    .kmac_fsm_err_i,
    .kmac_done_err_i,
    .regfile_intg_err_i,
    .shadowed_storage_err_i,
    .ctrl_fsm_err_i(state_intg_err_q | state_intg_err_d),
    .data_fsm_err_i(data_fsm_err),
    .op_fsm_err_i(op_fsm_err),
    .ecc_err_i(|ecc_errs),
    .state_change_err_i(state_change_err),
    .op_state_cmd_err_i(op_state_cmd_err),
    .cnt_err_i(cnt_err),
    .reseed_cnt_err_i,
    .sideload_fsm_err_i,

    .op_update_i(op_update),
    .op_done_i(op_done_o),

    .sync_err_o(sync_err),
    .async_err_o(),
    .sync_fault_o(sync_fault),
    .async_fault_o(async_fault),
    .error_o,
    .fault_o
  );

  ///////////////////////////////
  // Functions
  ///////////////////////////////

  // unclear what this is supposed to be yet
  // right now just check to see if it not all 0's and not all 1's
 function automatic logic valid_data_chk (logic [KeyWidth-1:0] value);

    return |value & ~&value;

  endfunction // byte_mask

  /////////////////////////////////
  // Assertions
  /////////////////////////////////

  // This assertion will not work if fault_status ever takes on metafields such as
  // qe / re etc.
  `ASSERT_INIT(SameErrCnt_A, $bits(keymgr_reg2hw_fault_status_reg_t) ==
                             (SyncFaultLastIdx + AsyncFaultLastIdx))

  // stage select should always be Disable whenever it is not enabled
  `ASSERT(StageDisableSel_A, !en_i |-> stage_sel_o == Disable)

  // Unless it is a legal command, only select disable
  `ASSERT(InitLegalCommands_A, op_start_i & en_i & state_q inside {StCtrlInit} &
                               !(op_i inside {OpAdvance}) |-> stage_sel_o == Disable)

  // All commands are legal, so select disable only if operation is disable
  `ASSERT(GeneralLegalCommands_A, op_start_i & en_i &
                                  state_q inside {StCtrlCreatorRootKey, StCtrlOwnerIntKey} &
                                  (op_i inside {OpDisable}) |-> stage_sel_o == Disable)

  `ASSERT(OwnerLegalCommands_A, op_start_i & en_i & state_q inside {StCtrlOwnerKey} &
                                (op_i inside {OpAdvance, OpDisable}) |-> stage_sel_o == Disable)

  // load_key should not be high if there is no ongoing operation
  `ASSERT(LoadKey_A, key_o.valid |-> op_start_i)

  // The count value should always be 0 when a transaction start
  `ASSERT(CntZero_A, $rose(op_start_i) |-> cnt == '0)

  // Whenever a transaction completes, data_en must return to 0 on the next cycle
  `ASSERT(DataEnDis_A, op_start_i & op_done_o |=> ~data_hw_en_o && ~data_sw_en_o)

  // Whenever data enable asserts, it must be the case that there was a generate or
  // id operation
  `ASSERT(DataEn_A, data_hw_en_o | data_sw_en_o |-> (id_en_o | gen_en_o) & ~adv_en_o)

  // Check that the FSM is linear and does not contain any loops
  `ASSERT_FPV_LINEAR_FSM(SecCmCFILinear_A, state_q, state_e)

endmodule


    """


    Identify the CWE relevant to the security issue for the given RTL.
    Obtain details of the CWE.

    Then determine if there are security issues relevant to the identified CWE in the RTL.
    Refer to the code that corresponds to the issues identified.
    
================================== Ai Message ==================================

[{'text': "I'll analyze the RTL code for security concerns related to illegal state transitions, privilege escalation, and FSM stuck/faulty conditions. Let me first identify the relevant CWEs for these types of issues.", 'type': 'text'}, {'id': 'toolu_01Difg3bJfmwKa1gg1vM6Qgn', 'input': {'security_issue': 'FSM illegal state transitions'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01Difg3bJfmwKa1gg1vM6Qgn)
 Call ID: toolu_01Difg3bJfmwKa1gg1vM6Qgn
  Args:
    security_issue: FSM illegal state transitions
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1245: Improper Finite State Machines (FSMs) in Hardware Logic
Faulty finite state machines (FSMs) in the hardware logic allow an attacker to put the system in an undefined state, to cause a denial of service (DoS) or gain privileges on the victim's system.
The functionality and security of the system heavily depend on the implementation of FSMs. FSMs can be used to indicate the current security state of the system. Lots of secure data operations and data transfers rely on the state reported by the FSM. Faulty FSM designs that do not account for all states, either through undefined states (left as don't cares) or through incorrect implementation, might lead an attacker to drive the system into an unstable state from which the system cannot recover without a reset, thus causing a DoS. Depending on what the FSM is used for, an attacker might also gain additional privileges to launch further attacks and compromise the security guarantees.
Example 1
The Finite State Machine (FSM) shown in the "bad" code snippet below assigns the output ("out") based on the value of state, which is determined based on the user provided input ("user_input").
(bad code)
Example Language: Verilog
module fsm_1(out, user_input, clk, rst_n);
input [2:0] user_input;
input clk, rst_n;
output reg [2:0] out;
reg [1:0] state;
always @ (posedge clk or negedge rst_n )
begin
if (!rst_n)
state = 3'h0;
else
case (user_input)
3'h0:
3'h1:
3'h2:
3'h3: state = 2'h3;
3'h4: state = 2'h2;
3'h5: state = 2'h1;
endcase
end
out <= {1'h1, state};
endmodule
The case statement does not include a default to handle the scenario when the user provides inputs of 3'h6 and 3'h7. Those inputs push the system to an undefined state and might cause a crash (denial of service) or any other unanticipated outcome. Adding a default statement to handle undefined inputs mitigates this issue. This is shown in the "Good" code snippet below. The default statement is in bold.
(good code)
Example Language: Verilog
case (user_input)
3'h0:
3'h1:
3'h2:
3'h3: state = 2'h3;
3'h4: state = 2'h2;
3'h5: state = 2'h1;
default: state = 2'h0;
endcase


================================== Ai Message ==================================

[{'id': 'toolu_01MiUEjT6knQs27UV1pKzd8W', 'input': {'security_issue': 'FSM privilege escalation'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01MiUEjT6knQs27UV1pKzd8W)
 Call ID: toolu_01MiUEjT6knQs27UV1pKzd8W
  Args:
    security_issue: FSM privilege escalation
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1245: Improper Finite State Machines (FSMs) in Hardware Logic
Faulty finite state machines (FSMs) in the hardware logic allow an attacker to put the system in an undefined state, to cause a denial of service (DoS) or gain privileges on the victim's system.
The functionality and security of the system heavily depend on the implementation of FSMs. FSMs can be used to indicate the current security state of the system. Lots of secure data operations and data transfers rely on the state reported by the FSM. Faulty FSM designs that do not account for all states, either through undefined states (left as don't cares) or through incorrect implementation, might lead an attacker to drive the system into an unstable state from which the system cannot recover without a reset, thus causing a DoS. Depending on what the FSM is used for, an attacker might also gain additional privileges to launch further attacks and compromise the security guarantees.
Example 1
The Finite State Machine (FSM) shown in the "bad" code snippet below assigns the output ("out") based on the value of state, which is determined based on the user provided input ("user_input").
(bad code)
Example Language: Verilog
module fsm_1(out, user_input, clk, rst_n);
input [2:0] user_input;
input clk, rst_n;
output reg [2:0] out;
reg [1:0] state;
always @ (posedge clk or negedge rst_n )
begin
if (!rst_n)
state = 3'h0;
else
case (user_input)
3'h0:
3'h1:
3'h2:
3'h3: state = 2'h3;
3'h4: state = 2'h2;
3'h5: state = 2'h1;
endcase
end
out <= {1'h1, state};
endmodule
The case statement does not include a default to handle the scenario when the user provides inputs of 3'h6 and 3'h7. Those inputs push the system to an undefined state and might cause a crash (denial of service) or any other unanticipated outcome. Adding a default statement to handle undefined inputs mitigates this issue. This is shown in the "Good" code snippet below. The default statement is in bold.
(good code)
Example Language: Verilog
case (user_input)
3'h0:
3'h1:
3'h2:
3'h3: state = 2'h3;
3'h4: state = 2'h2;
3'h5: state = 2'h1;
default: state = 2'h0;
endcase


================================== Ai Message ==================================

[{'id': 'toolu_01CvPUVcRL4oE6yRCQVtbei4', 'input': {'security_issue': 'FSM stuck states'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01CvPUVcRL4oE6yRCQVtbei4)
 Call ID: toolu_01CvPUVcRL4oE6yRCQVtbei4
  Args:
    security_issue: FSM stuck states
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1245: Improper Finite State Machines (FSMs) in Hardware Logic
Faulty finite state machines (FSMs) in the hardware logic allow an attacker to put the system in an undefined state, to cause a denial of service (DoS) or gain privileges on the victim's system.
The functionality and security of the system heavily depend on the implementation of FSMs. FSMs can be used to indicate the current security state of the system. Lots of secure data operations and data transfers rely on the state reported by the FSM. Faulty FSM designs that do not account for all states, either through undefined states (left as don't cares) or through incorrect implementation, might lead an attacker to drive the system into an unstable state from which the system cannot recover without a reset, thus causing a DoS. Depending on what the FSM is used for, an attacker might also gain additional privileges to launch further attacks and compromise the security guarantees.
Example 1
The Finite State Machine (FSM) shown in the "bad" code snippet below assigns the output ("out") based on the value of state, which is determined based on the user provided input ("user_input").
(bad code)
Example Language: Verilog
module fsm_1(out, user_input, clk, rst_n);
input [2:0] user_input;
input clk, rst_n;
output reg [2:0] out;
reg [1:0] state;
always @ (posedge clk or negedge rst_n )
begin
if (!rst_n)
state = 3'h0;
else
case (user_input)
3'h0:
3'h1:
3'h2:
3'h3: state = 2'h3;
3'h4: state = 2'h2;
3'h5: state = 2'h1;
endcase
end
out <= {1'h1, state};
endmodule
The case statement does not include a default to handle the scenario when the user provides inputs of 3'h6 and 3'h7. Those inputs push the system to an undefined state and might cause a crash (denial of service) or any other unanticipated outcome. Adding a default statement to handle undefined inputs mitigates this issue. This is shown in the "Good" code snippet below. The default statement is in bold.
(good code)
Example Language: Verilog
case (user_input)
3'h0:
3'h1:
3'h2:
3'h3: state = 2'h3;
3'h4: state = 2'h2;
3'h5: state = 2'h1;
default: state = 2'h0;
endcase


================================== Ai Message ==================================

Based on my analysis, the primary security concern in the provided RTL code relates to CWE-1245: Improper Finite State Machines (FSMs) in Hardware Logic. This CWE addresses issues where faulty FSM designs can lead to undefined states, denial of service, or privilege escalation.

## Analysis of the RTL Code

The provided code is a key manager control module (`keymgr_ctrl`) from the OpenTitan project, which manages cryptographic keys through various states. Let me analyze the security concerns:

### Security Measures Already Implemented

1. **Sparse FSM Encoding**: 
   ```verilog
   // Encoding generated with:
   // $ ./util/design/sparse-fsm-encode.py -d 5 -m 11 -n 10 \
   //      -s 4101887575 --language=sv
   ```
   The FSM uses sparse encoding with a minimum Hamming distance of 5, which is a good security practice to prevent single-bit errors from causing illegal state transitions.

2. **State Integrity Checking**:
   ```verilog
   // states fall out of sparsely encoded range
   logic state_intg_err_q, state_intg_err_d;
   ```
   The code tracks state integrity errors and has a mechanism to detect when the FSM falls outside the valid encoding range.

3. **Fault Detection and Response**:
   ```verilog
   // SEC_CM: CTRL.FSM.LOCAL_ESC
   // begin invalidation when faults are observed.
   assign inv_state = |fault_o;
   ```
   The design includes fault detection and transitions to an invalid state when faults are detected.

4. **Default State Handling**:
   ```verilog
   default: begin
     state_intg_err_d = 1'b1;
     state_d = StCtrlWipe;
   end
   ```
   The FSM has a default case that handles unexpected states by setting an error flag and transitioning to a wipe state.

5. **Key Integrity Protection**:
   ```verilog
   //SEC_CM: CTRL.KEY.INTEGRITY
   assign key_state_ecc_words_d = key_state_d;
   ```
   The design uses ECC (Error Correction Code) to protect key state integrity.

### Potential Security Concerns

1. **State Transition Validation**:
   The code includes cross-checks for state transitions:
   ```verilog
   // state cross check
   // if the state advanced, ensure that it was due to an advanced operation
   logic state_change_err;
   assign state_change_err = vld_state_change_q & !adv_op;
   ```
   However, there could be edge cases where invalid transitions might occur if timing issues arise between the state change detection and operation validation.

2. **Potential for FSM to Get Stuck**:
   In the `StCtrlWipe` state, there's a condition that might lead to the FSM getting stuck:
   ```verilog
   if (!op_start_i) begin
     state_d = StCtrlInvalid;
     prng_en_dis_inv_set = 1'b1;
   end
   ```
   If `op_start_i` remains high (indicating an ongoing operation), the FSM might remain in the `StCtrlWipe` state longer than intended, potentially causing a denial of service.

3. **Privilege Escalation Concerns**:
   The module handles key management with different privilege levels (Creator, OwnerInt, Owner). The transitions between these states are controlled by operations:
   ```verilog
   stage_sel_o = disable_sel ? Disable  :
                 advance_sel ? OwnerInt : Creator;
   ```
   If there are timing vulnerabilities or glitches in the `disable_sel` or `advance_sel` signals, it might be possible to manipulate the stage selection, potentially leading to privilege escalation.

4. **Error Handling in Fault Conditions**:
   While the code has extensive error detection, the response to some error conditions might not be immediate:
   ```verilog
   // sync faults only invalidate on transaction boundaries
   // async faults begin invalidating immediately
   assign inv_state = |fault_o;
   ```
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

Based on my analysis, the primary security concern in the provided RTL code relates to CWE-1245: Improper Finite State Machines (FSMs) in Hardware Logic. This CWE addresses issues where faulty FSM designs can lead to undefined states, denial of service, or privilege escalation.

## Analysis of the RTL Code

The provided code is a key manager control module (`keymgr_ctrl`) from the OpenTitan project, which manages cryptographic keys through various states. Let me analyze the security concerns:

### Security Measures Already Implemented

1. **Sparse FSM Encoding**: 
   ```verilog
   // Encoding generated with:
   // $ ./util/design/sparse-fsm-encode.py -d 5 -m 11 -n 10 \
   //      -s 4101887575 --language=sv
   ```
   The FSM uses sparse encoding with a minimum Hamming distance of 5, which is a good security practice to prevent single-bit errors from causing illegal state transitions.

2. **State Integrity Checking**:
   ```verilog
   // states fall out of sparsely encoded range
   logic state_intg_err_q, state_intg_err_d;
   ```
   The code tracks state integrity errors and has a mechanism to detect when the FSM falls outside the valid encoding range.

3. **Fault Detection and Response**:
   ```verilog
   // SEC_CM: CTRL.FSM.LOCAL_ESC
   // begin invalidation when faults are observed.
   assign inv_state = |fault_o;
   ```
   The design includes fault detection and transitions to an invalid state when faults are detected.

4. **Default State Handling**:
   ```verilog
   default: begin
     state_intg_err_d = 1'b1;
     state_d = StCtrlWipe;
   end
   ```
   The FSM has a default case that handles unexpected states by setting an error flag and transitioning to a wipe state.

5. **Key Integrity Protection**:
   ```verilog
   //SEC_CM: CTRL.KEY.INTEGRITY
   assign key_state_ecc_words_d = key_state_d;
   ```
   The design uses ECC (Error Correction Code) to protect key state integrity.

### Potential Security Concerns

1. **State Transition Validation**:
   The code includes cross-checks for state transitions:
   ```verilog
   // state cross check
   // if the state advanced, ensure that it was due to an advanced operation
   logic state_change_err;
   assign state_change_err = vld_state_change_q & !adv_op;
   ```
   However, there could be edge cases where invalid transitions might occur if timing issues arise between the state change detection and operation validation.

2. **Potential for FSM to Get Stuck**:
   In the `StCtrlWipe` state, there's a condition that might lead to the FSM getting stuck:
   ```verilog
   if (!op_start_i) begin
     state_d = StCtrlInvalid;
     prng_en_dis_inv_set = 1'b1;
   end
   ```
   If `op_start_i` remains high (indicating an ongoing operation), the FSM might remain in the `StCtrlWipe` state longer than intended, potentially causing a denial of service.

3. **Privilege Escalation Concerns**:
   The module handles key management with different privilege levels (Creator, OwnerInt, Owner). The transitions between these states are controlled by operations:
   ```verilog
   stage_sel_o = disable_sel ? Disable  :
                 advance_sel ? OwnerInt : Creator;
   ```
   If there are timing vulnerabilities or glitches in the `disable_sel` or `advance_sel` signals, it might be possible to manipulate the stage selection, potentially leading to privilege escalation.

4. **Error Handling in Fault Conditions**:
   While the code has extensive error detection, the response to some error conditions might not be immediate:
   ```verilog
   // sync faults only invalidate on transaction boundaries
   // async faults begin invalidating immediately
   assign inv_state = |fault_o;
   ```
   
================================== Ai Message ==================================
Tool Calls:
  run_anomaly_detector_agent (call_i8QmZ6HPbKipFOUKi4qEYbwT)
 Call ID: call_i8QmZ6HPbKipFOUKi4qEYbwT
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_ctrl.sv
    top_module: keymgr_ctrl
    security_objective: FSM security, privilege escalation, illegal state transitions
================================ Human Message =================================

Are there security concerns related to FSM security, privilege escalation, illegal state transitions in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_ctrl.sv

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Key manager top level
//

`include "prim_assert.sv"

module keymgr_ctrl
  import keymgr_pkg::*;
  import keymgr_reg_pkg::*;
#(
  parameter bit KmacEnMasking = 1'b1
) (
  input clk_i,
  input rst_ni,

  // lifecycle enforcement
  // SEC_CM: CTRL.FSM.GLOBAL_ESC
  input en_i,

  // faults that can occur outside of operations
  input regfile_intg_err_i,
  input shadowed_update_err_i,
  input shadowed_storage_err_i,
  input reseed_cnt_err_i,
  input sideload_sel_err_i,
  input sideload_fsm_err_i,

  // Software interface
  input op_start_i,
  input keymgr_ops_e op_i,
  input [CdiWidth-1:0] op_cdi_sel_i,
  output logic op_done_o,
  output keymgr_op_status_e status_o,
  output logic [ErrLastPos-1:0] error_o,
  output logic [FaultLastPos-1:0] fault_o,
  output logic data_hw_en_o,
  output logic data_sw_en_o,
  output logic data_valid_o,
  output logic wipe_key_o,
  output keymgr_working_state_e working_state_o,
  output logic sw_binding_unlock_o,
  output logic init_o,

  // Data input
  input  otp_ctrl_pkg::otp_keymgr_key_t root_key_i,
  output prim_mubi_pkg::mubi4_t hw_sel_o,
  output keymgr_stage_e stage_sel_o,
  output logic invalid_stage_sel_o,
  output logic [CdiWidth-1:0] cdi_sel_o,

  // KMAC ctrl interface
  output logic adv_en_o,
  output logic id_en_o,
  output logic gen_en_o,
  output hw_key_req_t key_o,
  input kmac_done_i,
  input kmac_input_invalid_i, // asserted when selected data fails criteria check
  input kmac_fsm_err_i, // asserted when kmac fsm reaches unexpected state
  input kmac_op_err_i,  // asserted when kmac itself reports an error
  input kmac_done_err_i,// asserted when kmac unexpectedly toggles done
  input kmac_cmd_err_i, // asserted when more than one command given to kmac
  input [Shares-1:0][KeyWidth-1:0] kmac_data_i,

  // prng control interface
  input [Shares-1:0][RandWidth-1:0] entropy_i,
  input prng_reseed_done_i,
  input prng_reseed_ack_i,
  output logic prng_reseed_req_o,
  output logic prng_en_o
);

  localparam int EntropyWidth = LfsrWidth / 2;
  localparam int EntropyRounds = KeyWidth / EntropyWidth;
  localparam int EntropyRndWidth = prim_util_pkg::vbits(EntropyRounds);
  localparam int CntWidth = EntropyRounds > CDIs ? EntropyRndWidth : CdiWidth;
  localparam int EccDataWidth = 64;
  localparam int EccWidth = 8;
  localparam int EccWords = KeyWidth / EccDataWidth;
  localparam int TotalEccWords = EccWords * Shares * CDIs;


  // Enumeration for working state
  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 5 -m 11 -n 10 \
  //      -s 4101887575 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: --
  //  4: --
  //  5: |||||||||||||||||||| (54.55%)
  //  6: |||||||||||||||| (45.45%)
  //  7: --
  //  8: --
  //  9: --
  // 10: --
  //
  // Minimum Hamming distance: 5
  // Maximum Hamming distance: 6
  // Minimum Hamming weight: 2
  // Maximum Hamming weight: 8
  //
  localparam int StateWidth = 10;
  typedef enum logic [StateWidth-1:0] {
    StCtrlReset          = 10'b1101100001,
    StCtrlEntropyReseed  = 10'b1110010010,
    StCtrlRandom         = 10'b0011110100,
    StCtrlRootKey        = 10'b0110101111,
    StCtrlInit           = 10'b0100000100,
    StCtrlCreatorRootKey = 10'b1000011101,
    StCtrlOwnerIntKey    = 10'b0001001010,
    StCtrlOwnerKey       = 10'b1101111110,
    StCtrlDisabled       = 10'b1010101000,
    StCtrlWipe           = 10'b0000110011,
    StCtrlInvalid        = 10'b1011000111
  } state_e;
  state_e state_q, state_d;

  // A variable that represents differentiates states before root key and after root key.
  logic initialized;

  // There are two versions of the key state, one for sealing one for attestation
  // Among each version, there are multiple shares
  // Each share is a fixed multiple of the entropy width
  logic [CDIs-1:0][Shares-1:0][EntropyRounds-1:0][EntropyWidth-1:0] key_state_d;
  logic [CDIs-1:0][Shares-1:0][EccWords-1:0][EccDataWidth-1:0] key_state_ecc_words_d;
  logic [CDIs-1:0][Shares-1:0][EccWords-1:0][EccDataWidth-1:0] key_state_q;
  logic [CDIs-1:0][Shares-1:0][EccWords-1:0][EccWidth-1:0] key_state_ecc_q;
  logic [CntWidth-1:0] cnt;
  logic [CdiWidth-1:0] cdi_cnt;

  // error conditions
  logic invalid_kmac_out;
  logic invalid_op;
  logic cnt_err;
  // states fall out of sparsely encoded range
  logic state_intg_err_q, state_intg_err_d;

  ///////////////////////////
  //  General operation decode
  ///////////////////////////

  logic adv_op, dis_op, gen_id_op, gen_sw_op, gen_hw_op, gen_op;
  assign adv_op    = (op_i == OpAdvance);
  assign gen_id_op = (op_i == OpGenId);
  assign gen_sw_op = (op_i == OpGenSwOut);
  assign gen_hw_op = (op_i == OpGenHwOut);
  assign dis_op    = ~(op_i inside {OpAdvance, OpGenId, OpGenSwOut, OpGenHwOut});
  assign gen_op    = (gen_id_op | gen_sw_op | gen_hw_op);

  ///////////////////////////
  //  interaction between software and main fsm
  ///////////////////////////
  // disable is treated like an advanced call
  logic advance_sel;
  logic disable_sel;
  logic gen_out_hw_sel;

  assign advance_sel    = op_start_i & adv_op    & en_i;
  assign gen_out_hw_sel = op_start_i & gen_hw_op & en_i;

  // disable is selected whenever a normal operation is not set
  assign disable_sel    = (op_start_i & dis_op) | !en_i;


  ///////////////////////////
  //  interaction between main control fsm and operation fsm
  ///////////////////////////

  // req/ack interface with op handling fsm
  logic op_req;
  logic op_ack;
  logic op_update;
  logic op_busy;
  logic disabled;
  logic invalid;

  logic adv_req, dis_req, id_req, gen_req;
  assign adv_req = op_req & adv_op;
  assign dis_req = op_req & dis_op;
  assign id_req  = op_req & gen_id_op;
  assign gen_req = op_req & (gen_sw_op | gen_hw_op);

  ///////////////////////////
  //  interaction between operation fsm and software
  ///////////////////////////
  // categories of keymgr errors
  logic [SyncErrLastIdx-1:0] sync_err;
  logic [SyncFaultLastIdx-1:0] sync_fault;
  logic [AsyncFaultLastIdx-1:0] async_fault;

  logic op_err;
  logic op_fault_err;

  // unlock sw binding configuration whenever an advance call is made without errors
  assign sw_binding_unlock_o = adv_req & op_ack & ~(op_err | op_fault_err);

  // error definition
  // check incoming kmac data validity
  // Only check during the periods when there is actual kmac output
  assign invalid_kmac_out = (op_update | op_ack) &
                            (~valid_data_chk(kmac_data_i[0]) |
                            (~valid_data_chk(kmac_data_i[1]) & KmacEnMasking));

  // async errors have nothing to do with the operation and thus should not
  // impact operation results.
  assign op_err = |sync_err;

  assign op_fault_err = |{sync_fault, async_fault};

  ///////////////////////////
  //  key update controls
  ///////////////////////////

  // update select can come from both main and operation fsm's
  keymgr_key_update_e update_sel, op_update_sel;

  // req from main control fsm to key update controls
  logic wipe_req;
  logic random_req;
  logic random_ack;

  // wipe and initialize take precedence
  assign update_sel = wipe_req             ? KeyUpdateWipe   :
                      random_req           ? KeyUpdateRandom :
                      init_o               ? KeyUpdateRoot   : op_update_sel;

  ///////////////////////////
  //  interaction between main fsm and prng
  ///////////////////////////

  // Upon entering StCtrlDisabled or StCtrlInvalid, the PRNG is kept advancing until it has been
  // reseeded twice (through the reseeding mechansism inside keymgr_reseed_ctrl.sv).
  logic [1:0] prng_en_dis_inv_d, prng_en_dis_inv_q;
  logic prng_en_dis_inv_set;

  assign prng_en_dis_inv_d =
      prng_en_dis_inv_set ? 2'b11 :
      prng_reseed_done_i  ? {1'b0, prng_en_dis_inv_q[1]} : prng_en_dis_inv_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      prng_en_dis_inv_q <= '0;
    end else begin
      prng_en_dis_inv_q <= prng_en_dis_inv_d;
    end
  end

  assign prng_en_o = random_req | wipe_req | prng_en_dis_inv_q[0];

  //////////////////////////
  // Main Control FSM
  //////////////////////////
  // SEC_CM: CTRL.FSM.SPARSE
  `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, state_e, StCtrlReset)

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      state_intg_err_q <= '0;
    end else begin
      state_intg_err_q <= state_intg_err_d;
    end
  end

  // prevents unknowns from reaching the outside world.
  // - whatever operation causes the input data select to be disabled should not expose the key
  //   state.
  // - when there are no operations, the key state also should be exposed.
  assign key_o.valid = op_req;

  assign cdi_sel_o = advance_sel ? cdi_cnt : op_cdi_sel_i;

  assign invalid_stage_sel_o = ~(stage_sel_o inside {Creator, OwnerInt, Owner});
  for (genvar i = 0; i < Shares; i++) begin : gen_key_out_assign
    assign key_o.key[i] = invalid_stage_sel_o ?
                          {EntropyRounds{entropy_i[i]}} :
                          key_state_q[cdi_sel_o][i];
  end


  //SEC_CM: CTRL.KEY.INTEGRITY
  assign key_state_ecc_words_d = key_state_d;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      key_state_q <= '0;
      key_state_ecc_q <= {TotalEccWords{prim_secded_pkg::SecdedInv7264ZeroEcc}};
    end else begin
      for (int i = 0; i < CDIs; i++) begin
        for (int j = 0; j < Shares; j++) begin
          for (int k = 0; k < EccWords; k++) begin
            {key_state_ecc_q[i][j][k]} <=
                prim_secded_pkg::prim_secded_inv_72_64_enc(key_state_ecc_words_d[i][j][k]);
          end
        end
      end
    end
  end

  logic [CDIs-1:0][Shares-1:0][EccWords-1:0] ecc_errs;
  for (genvar i = 0; i < CDIs; i++) begin : gen_ecc_loop_cdi
    for (genvar j = 0; j < Shares; j++) begin : gen_ecc_loop_shares
      for (genvar k = 0; k < EccWords; k++) begin : gen_ecc_loop_words
        logic [1:0] errs;
        prim_secded_inv_72_64_dec u_dec (
          .data_i({key_state_ecc_q[i][j][k], key_state_q[i][j][k]}),
          .data_o(),
          .syndrome_o(),
          .err_o(errs)
        );
        assign ecc_errs[i][j][k] = |errs;
      end
    end
  end

  // These are consumed one level above in keymgr.sv
  logic unused_otp_sigs;
  assign unused_otp_sigs = ^{root_key_i.creator_seed,
                             root_key_i.creator_seed_valid,
                             root_key_i.owner_seed,
                             root_key_i.owner_seed_valid};

  // root key valid sync
  logic root_key_valid_q;

  prim_flop_2sync # (
    .Width(1)
  ) u_key_valid_sync (
    .clk_i,
    .rst_ni,
    // Both valid signals are flopped in OTP_CTRL, and they only ever transition from 0 -> 1.
    // It is hence ok to AND them here before the synchronizer, since we don't expect this
    // to create glitches.
    .d_i(root_key_i.creator_root_key_share0_valid &&
         root_key_i.creator_root_key_share1_valid),
    .q_o(root_key_valid_q)
  );

  // Do not let the count toggle unless an advance operation is
  // selected
  assign cdi_cnt = op_req ? cnt[CdiWidth-1:0] : '0;

  always_comb begin
    key_state_d = key_state_q;
    data_valid_o = 1'b0;
    wipe_key_o = 1'b0;

    // if a wipe request arrives, immediately destroy the
    // keys regardless of current state
    unique case (update_sel)
      KeyUpdateRandom: begin
        for (int i = 0; i < CDIs; i++) begin
          for (int j = 0; j < Shares; j++) begin
            // Load each share with the same randomness so we can
            // later simply XOR root key on them
            key_state_d[i][j][cnt[EntropyRndWidth-1:0]] = entropy_i[i];
          end
        end
      end

      KeyUpdateRoot: begin
        if (root_key_valid_q) begin
          for (int i = 0; i < CDIs; i++) begin
            if (KmacEnMasking) begin : gen_two_share_key
              key_state_d[i][0] ^= root_key_i.creator_root_key_share0;
              key_state_d[i][1] ^= root_key_i.creator_root_key_share1;
            end else begin : gen_one_share_key
              key_state_d[i][0] = root_key_i.creator_root_key_share0 ^
                                  root_key_i.creator_root_key_share1;
              key_state_d[i][1] = '0;
            end
          end
        end else begin
          // if root key is not valid, load and invalid value
          for (int i = 0; i < CDIs; i++) begin
              key_state_d[i][0] = '0;
              key_state_d[i][1] = '{default: '1};
          end
        end
      end

      KeyUpdateKmac: begin
        data_valid_o = gen_op;
        key_state_d[cdi_sel_o] = (adv_op || dis_op) ? kmac_data_i : key_state_q[cdi_sel_o];
      end

      KeyUpdateWipe: begin
        wipe_key_o = 1'b1;
        for (int i = 0; i < CDIs; i++) begin
          for (int j = 0; j < Shares; j++) begin
            key_state_d[i][j] = {EntropyRounds{entropy_i[j]}};
          end
        end
      end

      default:;
    endcase // unique case (update_sel)
  end

  // SEC_CM: CTRL.CTR.REDUN
  prim_count #(
    .Width(CntWidth)
  ) u_cnt (
    .clk_i,
    .rst_ni,
    .clr_i(op_ack | random_ack),
    .set_i('0),
    .set_cnt_i('0),
    .incr_en_i(op_update | random_req),
    .decr_en_i(1'b0),
    .step_i(CntWidth'(1'b1)),
    .commit_i(1'b1),
    .cnt_o(cnt),
    .cnt_after_commit_o(),
    .err_o(cnt_err)
  );


  prim_mubi4_sender u_hw_sel (
    .clk_i,
    .rst_ni,
    .mubi_i (prim_mubi_pkg::mubi4_bool_to_mubi(gen_out_hw_sel)),
    .mubi_o (hw_sel_o)
  );

  // when in a state that accepts commands, look at op_ack for completion
  // when in a state that does not accept commands, wait for other triggers.
  assign op_done_o = op_req ? op_ack :
                     (init_o | invalid_op);


  // There are 3 possibilities
  // advance to next state (software command)
  // advance to disabled state (software command)
  // advance to invalid state (detected fault)
  logic adv_state;
  logic dis_state;
  logic inv_state;
  assign adv_state = op_ack & adv_req & ~op_err;
  assign dis_state = op_ack & dis_req;

  // SEC_CM: CTRL.FSM.LOCAL_ESC
  // begin invalidation when faults are observed.
  // sync faults only invalidate on transaction boudaries
  // async faults begin invalidating immediately
  assign inv_state = |fault_o;

  always_comb begin
    // persistent data
    state_d = state_q;

    // request to op handling
    op_req = 1'b0;
    random_req = 1'b0;
    random_ack = 1'b0;

    // request to key updates
    wipe_req = 1'b0;

    // invalid operation issued
    invalid_op = '0;

    // data update and select signals
    stage_sel_o = Disable;

    // indication that state is disabled
    disabled = 1'b0;

    // indication that state is invalid
    invalid = 1'b0;

    // Don't request final PRNG updating and reseeding.
    prng_en_dis_inv_set = 1'b0;

    // Request PRNG reseeding.
    prng_reseed_req_o = 1'b0;

    // initialization complete
    init_o = 1'b0;

    // Most states are initialized, mark the exceptions
    initialized = 1'b1;

    // if state is ever faulted, hold on to this indication
    // until reset.
    state_intg_err_d = state_intg_err_q;

    unique case (state_q)
      // Only advance can be called from reset state
      StCtrlReset: begin
        initialized = 1'b0;

        // always use random data for advance, since out of reset state
        // the key state will be randomized.
        stage_sel_o = Disable;

        // key state is updated when it is an advance call
        // all other operations are invalid, including disable
        invalid_op = op_start_i & ~advance_sel;

        // if there was a structural fault before anything began, wipe immediately
        if (inv_state) begin
          state_d = StCtrlWipe;
        end else if (advance_sel) begin
          state_d = StCtrlEntropyReseed;
        end
      end

      // reseed entropy
      StCtrlEntropyReseed: begin
        initialized = 1'b0;
        prng_reseed_req_o = 1'b1;

        if (prng_reseed_ack_i) begin
          state_d = StCtrlRandom;
        end
      end

      // This state does not accept any command.
      StCtrlRandom: begin
        initialized = 1'b0;
        random_req = 1'b1;

        // when mask population is complete, xor the root_key into the zero share
        // if in the future the root key is updated to 2 shares, it will direclty overwrite
        // the values here
        if (int'(cnt) == EntropyRounds-1) begin
          random_ack = 1'b1;
          state_d = StCtrlRootKey;
        end
      end

      // load the root key.
      StCtrlRootKey: begin
        init_o = 1'b1;
        initialized = 1'b1;
        state_d = (en_i && root_key_valid_q) ? StCtrlInit : StCtrlWipe;
      end

      // Beginning from the Init state, operations are accepted.
      // Only valid operation is advance state. If invalid command received,
      // random data is selected for operation and no persistent state is changed.
      StCtrlInit: begin
        op_req = op_start_i;

        // when advancing select creator data, otherwise use random input
        stage_sel_o = advance_sel ? Creator : Disable;
        invalid_op = op_start_i & ~(advance_sel | disable_sel);

        if (!en_i || inv_state) begin
          state_d = StCtrlWipe;
        end else if (dis_state) begin
          state_d = StCtrlDisabled;
          prng_en_dis_inv_set = 1'b1;
        end else if (adv_state) begin
          state_d = StCtrlCreatorRootKey;
        end
      end

      // all commands  are valid during this stage
      StCtrlCreatorRootKey: begin
        op_req = op_start_i;

        // when generating, select creator data input
        // when advancing, select owner intermediate key as target
        // when disabling, select random data input
        stage_sel_o = disable_sel ? Disable  :
                      advance_sel ? OwnerInt : Creator;

        if (!en_i || inv_state) begin
          state_d = StCtrlWipe;
        end else if (dis_state) begin
          state_d = StCtrlDisabled;
          prng_en_dis_inv_set = 1'b1;
        end else if (adv_state) begin
          state_d = StCtrlOwnerIntKey;
        end
      end

      // all commands are valid during this stage
      StCtrlOwnerIntKey: begin
        op_req = op_start_i;

        // when generating, select owner intermediate data input
        // when advancing, select owner as target
        // when disabling, select random data input
        stage_sel_o = disable_sel ? Disable  :
                      advance_sel ? Owner : OwnerInt;

        if (!en_i || inv_state) begin
          state_d = StCtrlWipe;
        end else if (dis_state) begin
          state_d = StCtrlDisabled;
          prng_en_dis_inv_set = 1'b1;
        end else if (adv_state) begin
          state_d = StCtrlOwnerKey;
        end
      end

      // all commands are valid during this stage
      // however advance goes directly to disabled state
      StCtrlOwnerKey: begin
        op_req = op_start_i;

        // when generating, select owner data input
        // when advancing, select disable as target
        // when disabling, select random data input
        stage_sel_o = disable_sel | advance_sel ? Disable : Owner;

        if (!en_i || inv_state) begin
          state_d = StCtrlWipe;
        end else if (adv_state || dis_state) begin
          state_d = StCtrlDisabled;
          prng_en_dis_inv_set = 1'b1;
        end
      end

      // The wipe state immediately clears out the key state, but waits for any ongoing
      // transaction to finish before going to disabled state.
      // Unlike the random state, this is an immedaite shutdown request, so all parts of the
      // key are wiped.
      StCtrlWipe: begin
        wipe_req = 1'b1;
        // if there was already an operation ongoing, maintain the request until completion
        op_req = op_busy;
        invalid_op = op_start_i;

        // If the enable is dropped during the middle of a transaction, we clear and wait for that
        // transaction to gracefully complete (if it can).
        // There are two scenarios:
        // 1. the operation completed right when we started wiping, in which case the done would
        //    clear the start.
        // 2. the operation completed before we started wiping, or there was never an operation to
        //    begin with (op_start_i == 0), in this case, don't wait and immediately transition
        if (!op_start_i) begin
          state_d = StCtrlInvalid;
          prng_en_dis_inv_set = 1'b1;
        end
      end

      // StCtrlDisabled and StCtrlInvalid are almost functionally equivalent
      // The only difference is that Disabled is entered through software invocation,
      // while Invalid is entered through life cycle disable or operational fault.
      //
      // Both states continue to kick off random transactions
      // All transactions are treated as invalid despite completing
      StCtrlDisabled: begin
        op_req = op_start_i;
        disabled = 1'b1;

        if (!en_i || inv_state) begin
          state_d = StCtrlWipe;
        end
      end

      StCtrlInvalid: begin
        invalid_op = op_start_i;
        invalid = 1'b1;
      end

      // latch the fault indication and start to wipe the key manager
      default: begin
        state_intg_err_d = 1'b1;
        state_d = StCtrlWipe;
      end

    endcase // unique case (state_q)
  end // always_comb

  // Current working state provided for software read
  // Certain states are collapsed for simplicity
  keymgr_working_state_e last_working_st;
  logic update_en;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      last_working_st <= StReset;
    end else if (update_en) begin
      last_working_st <= working_state_o;
    end
  end

  always_comb begin
    update_en = 1'b1;
    working_state_o = StInvalid;

    unique case (state_q)
      StCtrlReset, StCtrlEntropyReseed, StCtrlRandom:
        working_state_o = StReset;

      StCtrlRootKey, StCtrlInit:
        working_state_o = StInit;

      StCtrlCreatorRootKey:
        working_state_o = StCreatorRootKey;

      StCtrlOwnerIntKey:
        working_state_o = StOwnerIntKey;

      StCtrlOwnerKey:
        working_state_o = StOwnerKey;

      StCtrlDisabled:
        working_state_o = StDisabled;

      StCtrlWipe: begin
        update_en = 1'b0;
        working_state_o = last_working_st;
      end

      StCtrlInvalid:
        working_state_o = StInvalid;

      default:
        working_state_o = StInvalid;
    endcase // unique case (state_q)
  end

  always_comb begin
    status_o = OpIdle;
    if (op_done_o) begin
      // It is possible for an operation to finish the same cycle en_i goes low.
      // The main fsm handling is one cycle behind, but still report operation
      // fail.
      status_o = |{error_o, fault_o} ? OpDoneFail : OpDoneSuccess;
    end else if (op_start_i) begin
      status_o = OpWip;
    end
  end


  /////////////////////////
  // Operateion state, handle advance and generate
  /////////////////////////

  logic op_fsm_err;
  keymgr_op_state_ctrl u_op_state (
    .clk_i,
    .rst_ni,
    .adv_req_i(adv_req),
    .dis_req_i(dis_req),
    .id_req_i(id_req),
    .gen_req_i(gen_req),
    .cnt_i(cdi_cnt),
    .op_ack_o(op_ack),
    .op_busy_o(op_busy),
    .op_update_o(op_update),
    .kmac_done_i,
    .adv_en_o,
    .id_en_o,
    .gen_en_o,
    .op_fsm_err_o(op_fsm_err)
  );

  // operational state cross check.  The state value must be consistent with
  // the input operations.
  logic op_state_cmd_err;
  assign op_state_cmd_err = (adv_en_o & ~(advance_sel | disable_sel)) |
                            (gen_en_o & ~gen_op);

  // operations fsm update precedence
  // when in invalid state, always update.
  // when in disabled state, always update unless a fault is encountered.
  assign op_update_sel = (op_ack | op_update) & invalid      ? KeyUpdateKmac :
                         (op_ack | op_update) & op_fault_err ? KeyUpdateWipe :
                         (op_ack | op_update) & disabled     ? KeyUpdateKmac :
                         (op_ack | op_update) & op_err       ? KeyUpdateIdle :
                         (op_ack | op_update)                ? KeyUpdateKmac : KeyUpdateIdle;


  ///////////////////////////////
  // Suppress kmac return data
  ///////////////////////////////

  logic data_fsm_err;
  keymgr_data_en_state u_data_en (
    .clk_i,
    .rst_ni,
    .hw_sel_i(hw_sel_o),
    .adv_en_i(adv_en_o),
    .id_en_i(id_en_o),
    .gen_en_i(gen_en_o),
    .op_done_i(op_done_o),
    .op_start_i,
    .data_hw_en_o,
    .data_sw_en_o,
    .fsm_err_o(data_fsm_err)
  );

  /////////////////////////
  // Cross-checks, errors and faults
  /////////////////////////

  logic vld_state_change_d, vld_state_change_q;
  assign vld_state_change_d = (state_d != state_q) &
                              (state_d inside {StCtrlRootKey,
                                               StCtrlCreatorRootKey,
                                               StCtrlOwnerIntKey,
                                               StCtrlOwnerKey});

  // capture for cross check in following cycle
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      vld_state_change_q <= '0;
    end else begin
      vld_state_change_q <= vld_state_change_d;
    end
  end

  // state cross check
  // if the state advanced, ensure that it was due to an advanced operation
  logic state_change_err;
  assign state_change_err = vld_state_change_q & !adv_op;

  keymgr_err u_err (
    .clk_i,
    .rst_ni,
    .invalid_op_i(invalid_op),
    .disabled_i(disabled | (initialized & ~en_i)),
    .invalid_i(invalid),
    .kmac_input_invalid_i,
    .shadowed_update_err_i,
    .kmac_op_err_i,
    .invalid_kmac_out_i(invalid_kmac_out),
    .sideload_sel_err_i,
    .kmac_cmd_err_i,
    .kmac_fsm_err_i,
    .kmac_done_err_i,
    .regfile_intg_err_i,
    .shadowed_storage_err_i,
    .ctrl_fsm_err_i(state_intg_err_q | state_intg_err_d),
    .data_fsm_err_i(data_fsm_err),
    .op_fsm_err_i(op_fsm_err),
    .ecc_err_i(|ecc_errs),
    .state_change_err_i(state_change_err),
    .op_state_cmd_err_i(op_state_cmd_err),
    .cnt_err_i(cnt_err),
    .reseed_cnt_err_i,
    .sideload_fsm_err_i,

    .op_update_i(op_update),
    .op_done_i(op_done_o),

    .sync_err_o(sync_err),
    .async_err_o(),
    .sync_fault_o(sync_fault),
    .async_fault_o(async_fault),
    .error_o,
    .fault_o
  );

  ///////////////////////////////
  // Functions
  ///////////////////////////////

  // unclear what this is supposed to be yet
  // right now just check to see if it not all 0's and not all 1's
 function automatic logic valid_data_chk (logic [KeyWidth-1:0] value);

    return |value & ~&value;

  endfunction // byte_mask

  /////////////////////////////////
  // Assertions
  /////////////////////////////////

  // This assertion will not work if fault_status ever takes on metafields such as
  // qe / re etc.
  `ASSERT_INIT(SameErrCnt_A, $bits(keymgr_reg2hw_fault_status_reg_t) ==
                             (SyncFaultLastIdx + AsyncFaultLastIdx))

  // stage select should always be Disable whenever it is not enabled
  `ASSERT(StageDisableSel_A, !en_i |-> stage_sel_o == Disable)

  // Unless it is a legal command, only select disable
  `ASSERT(InitLegalCommands_A, op_start_i & en_i & state_q inside {StCtrlInit} &
                               !(op_i inside {OpAdvance}) |-> stage_sel_o == Disable)

  // All commands are legal, so select disable only if operation is disable
  `ASSERT(GeneralLegalCommands_A, op_start_i & en_i &
                                  state_q inside {StCtrlCreatorRootKey, StCtrlOwnerIntKey} &
                                  (op_i inside {OpDisable}) |-> stage_sel_o == Disable)

  `ASSERT(OwnerLegalCommands_A, op_start_i & en_i & state_q inside {StCtrlOwnerKey} &
                                (op_i inside {OpAdvance, OpDisable}) |-> stage_sel_o == Disable)

  // load_key should not be high if there is no ongoing operation
  `ASSERT(LoadKey_A, key_o.valid |-> op_start_i)

  // The count value should always be 0 when a transaction start
  `ASSERT(CntZero_A, $rose(op_start_i) |-> cnt == '0)

  // Whenever a transaction completes, data_en must return to 0 on the next cycle
  `ASSERT(DataEnDis_A, op_start_i & op_done_o |=> ~data_hw_en_o && ~data_sw_en_o)

  // Whenever data enable asserts, it must be the case that there was a generate or
  // id operation
  `ASSERT(DataEn_A, data_hw_en_o | data_sw_en_o |-> (id_en_o | gen_en_o) & ~adv_en_o)

  // Check that the FSM is linear and does not contain any loops
  `ASSERT_FPV_LINEAR_FSM(SecCmCFILinear_A, state_q, state_e)

endmodule

    '''

    Use the anomaly detector tool to identify lines in the design RTL that are anomalous.
    Then determine whether the identified anomalous line(s) represent a security issue or not.

    
================================== Ai Message ==================================
Tool Calls:
  anomaly_detector_tool (call_xIkfTPnGvOO1fbJRbxd2R55t)
 Call ID: call_xIkfTPnGvOO1fbJRbxd2R55t
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_ctrl.sv
================================= Tool Message =================================
Name: anomaly_detector_tool

Successfully executed:
```LLM Anomaly Detector tool
```
Output:
Here are clusters of similar verilog constructs in the RTL file:



Cluster 0:
assign adv_op    = (op_i == OpAdvance);
assign gen_id_op = (op_i == OpGenId);
assign gen_sw_op = (op_i == OpGenSwOut);
assign gen_hw_op = (op_i == OpGenHwOut);
assign dis_op    = ~(op_i inside {OpAdvance, OpGenId, OpGenSwOut, OpGenHwOut});
assign gen_op    = (gen_id_op | gen_sw_op | gen_hw_op);
assign advance_sel    = op_start_i & adv_op    & en_i;
assign gen_out_hw_sel = op_start_i & gen_hw_op & en_i;
assign disable_sel    = (op_start_i & dis_op) | !en_i;
assign adv_req = op_req & adv_op;
assign dis_req = op_req & dis_op;
assign id_req  = op_req & gen_id_op;
assign gen_req = op_req & (gen_sw_op | gen_hw_op);
assign sw_binding_unlock_o = adv_req & op_ack & ~(op_err | op_fault_err);
assign cdi_sel_o = advance_sel ? cdi_cnt : op_cdi_sel_i;
assign cdi_cnt = op_req ? cnt[CdiWidth-1:0] : '0;
assign op_done_o = op_req ? op_ack :
assign adv_state = op_ack & adv_req & ~op_err;
assign dis_state = op_ack & dis_req;
assign op_state_cmd_err = (adv_en_o & ~(advance_sel | disable_sel)) |
assign vld_state_change_d = (state_d != state_q) &
assign state_change_err = vld_state_change_q & !adv_op;


Cluster 1:
assign invalid_kmac_out = (op_update | op_ack) &
assign op_update_sel = (op_ack | op_update) & invalid      ? KeyUpdateKmac :


Cluster 2:
assign op_err = |sync_err;
assign op_fault_err = |{sync_fault, async_fault};


Cluster 3:
assign prng_en_dis_inv_d =
assign prng_en_o = random_req | wipe_req | prng_en_dis_inv_q[0];

================================== Ai Message ==================================

Anomalies found in the assignment/conditional clusters:

1. Cluster 1:
- "assign invalid_kmac_out = (op_update | op_ack) &"
- "assign op_update_sel = (op_ack | op_update) & invalid ? KeyUpdateKmac :"

These lines indicate anomalous or less common conditional assignments related to handling key material and update selections. The line about invalid_kmac_out checks the validity of kmac data output only in specific operational phases, which can frame potential fault or illegal data inputs. The op_update_sel uses several conditions combining fault and invalid states to dictate key update behaviors, which is critical for preserving key integrity.

Security evaluation:
- These anomalies relate to handling operations that can detect when the output data or operation state is invalid or faulted.
- The logic routes key updates differently based on error/invalid conditions which is essential to prevent privilege escalation or execution of illegal state transitions.
- The defined states and checks avoid accidental or malicious operations when a fault or invalid condition is detected.
- From a security perspective, these are necessary to enforce correct state transitions and avoid privilege escalation vulnerabilities.
- Proper handling (like wiping keys or switching to safe states) ensures FSM security.

No direct vulnerability is observable here; instead, these anomalies are security features enforcing correct privilege and state transitions.

Summary:
- The anomalous lines represent important security-related logic enforcing FSM security and preventing privilege escalation via illegal state transitions.
- No flaws or security vulnerabilities were detected from these anomalies.
- They should be carefully maintained and verified for correctness.

If you want, I can dive deeper into specific parts or verify assertions related to FSM security and privilege escalation.
================================= Tool Message =================================
Name: run_anomaly_detector_agent

Anomalies found in the assignment/conditional clusters:

1. Cluster 1:
- "assign invalid_kmac_out = (op_update | op_ack) &"
- "assign op_update_sel = (op_ack | op_update) & invalid ? KeyUpdateKmac :"

These lines indicate anomalous or less common conditional assignments related to handling key material and update selections. The line about invalid_kmac_out checks the validity of kmac data output only in specific operational phases, which can frame potential fault or illegal data inputs. The op_update_sel uses several conditions combining fault and invalid states to dictate key update behaviors, which is critical for preserving key integrity.

Security evaluation:
- These anomalies relate to handling operations that can detect when the output data or operation state is invalid or faulted.
- The logic routes key updates differently based on error/invalid conditions which is essential to prevent privilege escalation or execution of illegal state transitions.
- The defined states and checks avoid accidental or malicious operations when a fault or invalid condition is detected.
- From a security perspective, these are necessary to enforce correct state transitions and avoid privilege escalation vulnerabilities.
- Proper handling (like wiping keys or switching to safe states) ensures FSM security.

No direct vulnerability is observable here; instead, these anomalies are security features enforcing correct privilege and state transitions.

Summary:
- The anomalous lines represent important security-related logic enforcing FSM security and preventing privilege escalation via illegal state transitions.
- No flaws or security vulnerabilities were detected from these anomalies.
- They should be carefully maintained and verified for correctness.

If you want, I can dive deeper into specific parts or verify assertions related to FSM security and privilege escalation.
================================== Ai Message ==================================
Tool Calls:
  run_anomaly_detector_agent (call_ZJvO2CzBrBKpBsixBhwW9QpH)
 Call ID: call_ZJvO2CzBrBKpBsixBhwW9QpH
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv
    top_module: keymgr_kmac_if
    security_objective: masking enforcement, data leakage, privilege escalation
================================ Human Message =================================

Are there security concerns related to masking enforcement, data leakage, privilege escalation in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Key manager interface to kmac
//

`include "prim_assert.sv"

module keymgr_kmac_if
  import keymgr_pkg::*;
#(
  parameter rand_perm_t RndCnstRandPerm = RndCnstRandPermDefault
) (
  input clk_i,
  input rst_ni,

  // data input interfaces
  input [AdvDataWidth-1:0] adv_data_i,
  input [IdDataWidth-1:0] id_data_i,
  input [GenDataWidth-1:0] gen_data_i,
  input [3:0] inputs_invalid_i,
  output logic inputs_invalid_o,

  // keymgr control to select appropriate inputs
  input adv_en_i,
  input id_en_i,
  input gen_en_i,
  output logic done_o,
  output logic [Shares-1:0][kmac_pkg::AppDigestW-1:0] data_o,

  // actual connection to kmac
  output kmac_pkg::app_req_t kmac_data_o,
  input  kmac_pkg::app_rsp_t kmac_data_i,

  // entropy input
  output logic prng_en_o,
  input [Shares-1:0][RandWidth-1:0] entropy_i,

  // error outputs
  output logic fsm_error_o,
  output logic kmac_error_o,
  output logic kmac_done_error_o,
  output logic cmd_error_o
);


  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 5 -m 6 -n 10 \
  //      -s 2292624416 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: --
  //  4: --
  //  5: |||||||||||||||||||| (46.67%)
  //  6: ||||||||||||||||| (40.00%)
  //  7: ||||| (13.33%)
  //  8: --
  //  9: --
  // 10: --
  //
  // Minimum Hamming distance: 5
  // Maximum Hamming distance: 7
  // Minimum Hamming weight: 2
  // Maximum Hamming weight: 9
  //
  localparam int StateWidth = 10;
  typedef enum logic [StateWidth-1:0] {
    StIdle    = 10'b1110100010,
    StTx      = 10'b0010011011,
    StTxLast  = 10'b0101000000,
    StOpWait  = 10'b1000101001,
    StClean   = 10'b1111111101,
    StError   = 10'b0011101110
  } data_state_e;

  localparam int AdvRem = AdvDataWidth % KmacDataIfWidth;
  localparam int IdRem  = IdDataWidth  % KmacDataIfWidth;
  localparam int GenRem = GenDataWidth % KmacDataIfWidth;

  // the remainder must be in number of bytes
  `ASSERT_INIT(AdvRemBytes_A, AdvRem % 8 == 0)
  `ASSERT_INIT(IdRemBytes_A,  IdRem  % 8 == 0)
  `ASSERT_INIT(GenRemBytes_A, GenRem % 8 == 0)

  // Number of kmac transactions required
  localparam int AdvRounds = (AdvDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
  localparam int IdRounds  = (IdDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
  localparam int GenRounds = (GenDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
  localparam int MaxRounds = KDFMaxWidth  / KmacDataIfWidth;

  // calculated parameters for number of roudns and interface width
  localparam int CntWidth = $clog2(MaxRounds);
  localparam int IfBytes = KmacDataIfWidth / 8;
  localparam int DecoyCopies = KmacDataIfWidth / RandWidth;
  localparam int DecoyOutputCopies = (kmac_pkg::AppDigestW / RandWidth);

  localparam int unsigned LastAdvRoundInt = AdvRounds - 1;
  localparam int unsigned LastIdRoundInt = IdRounds - 1;
  localparam int unsigned LastGenRoundInt = GenRounds - 1;
  localparam bit [CntWidth-1:0] LastAdvRound = LastAdvRoundInt[CntWidth-1:0];
  localparam bit [CntWidth-1:0] LastIdRound = LastIdRoundInt[CntWidth-1:0];
  localparam bit [CntWidth-1:0] LastGenRound = LastGenRoundInt[CntWidth-1:0];

  // byte mask for the last transfer
  localparam logic [IfBytes-1:0] AdvByteMask = (AdvRem > 0) ? (2**(AdvRem/8)-1) : {IfBytes{1'b1}};
  localparam logic [IfBytes-1:0] IdByteMask  = (IdRem > 0)  ? (2**(IdRem/8)-1)  : {IfBytes{1'b1}};
  localparam logic [IfBytes-1:0] GenByteMask = (GenRem > 0) ? (2**(GenRem/8)-1) : {IfBytes{1'b1}};

  logic [MaxRounds-1:0][KmacDataIfWidth-1:0] adv_data;
  logic [MaxRounds-1:0][KmacDataIfWidth-1:0] id_data;
  logic [MaxRounds-1:0][KmacDataIfWidth-1:0] gen_data;
  logic [CntWidth-1:0] cnt;
  logic [CntWidth-1:0] rounds;
  logic [KmacDataIfWidth-1:0] decoy_data;
  logic valid;
  logic last;
  logic [IfBytes-1:0] strb;
  logic cnt_clr, cnt_set, cnt_en;
  logic start;
  logic [3:0] inputs_invalid_d, inputs_invalid_q;
  logic clr_err;
  logic kmac_done_vld;
  logic cmd_chk;

  data_state_e state_q, state_d;

  // 0 pad to the appropriate width
  // this is basically for scenarios where *DataWidth % KmacDataIfWidth != 0
  assign adv_data = KDFMaxWidth'(adv_data_i);
  assign id_data  = KDFMaxWidth'(id_data_i);
  assign gen_data = KDFMaxWidth'(gen_data_i);

  assign start = adv_en_i | id_en_i | gen_en_i;

  logic cnt_err;
  // SEC_CM: KMAC_IF.CTR.REDUN
  prim_count #(
    .Width(CntWidth),
    .ResetValue({CntWidth{1'b1}})
  ) u_cnt (
    .clk_i,
    .rst_ni,
    .clr_i(cnt_clr),
    .set_i(cnt_set),
    .set_cnt_i(rounds),
    .incr_en_i(1'b0),
    .decr_en_i(cnt_en),
    .step_i(CntWidth'(1'b1)),
    .commit_i(1'b1),
    .cnt_o(cnt),
    .cnt_after_commit_o(),
    .err_o(cnt_err)
  );

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      inputs_invalid_q <= '0;
    end else begin
      inputs_invalid_q <= inputs_invalid_d;
    end
   end

  // SEC_CM: KMAC_IF.FSM.SPARSE
  `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, data_state_e, StIdle)

  always_comb begin
    cnt_clr = 1'b0;
    cnt_set = 1'b0;
    cnt_en  = 1'b0;
    valid   = 1'b0;
    last    = 1'b0;
    strb    = '0;
    done_o  = 1'b0;
    state_d = state_q;
    rounds  = '0;

    clr_err = '0;
    fsm_error_o = '0;
    kmac_error_o = '0;

    kmac_done_vld = '0;

    cmd_chk = 1'b1;

    unique case (state_q)

      StIdle: begin
        // if for some reason multiple bits are set, adv_en has priority
        // as the current key state will be destroyed

        // cross check for commands once transaction begins
        cmd_chk = '0;
        if (start) begin
          cnt_set = 1'b1;
          if (adv_en_i) begin
            rounds = LastAdvRound;
          end else if (id_en_i) begin
            rounds = LastIdRound;
          end else if (gen_en_i) begin
            rounds = LastGenRound;
          end
          // in case we are sending only 1 entry
          state_d = (rounds == 0) ? StTxLast : StTx;
        end
      end

      StTx: begin
        valid = 1'b1;
        strb = {IfBytes{1'b1}};

        // transaction accepted
        if (kmac_data_i.ready) begin
          cnt_en = 1'b1;

          // second to last beat
          if (cnt == CntWidth'(1'b1)) begin
            state_d = StTxLast;
          end
        end

      end

      StTxLast: begin
        valid = 1'b1;
        last = 1'b1;

        if (adv_en_i) begin
          strb = AdvByteMask;
        end else if (id_en_i) begin
          strb = IdByteMask;
        end else if (gen_en_i) begin
          strb = GenByteMask;
        end

        // transaction accepted
        cnt_clr = kmac_data_i.ready;
        state_d = kmac_data_i.ready ? StOpWait : StTxLast;

      end

      StOpWait: begin
        kmac_done_vld = 1'b1;
        if (kmac_data_i.done) begin
          kmac_error_o = kmac_data_i.error;
          done_o = 1'b1;
          state_d = StClean;
        end
      end

      StClean: begin
        cmd_chk = '0;
        done_o = 1'b1;

        // wait for control side to ack done by waiting start de-assertion
        if (!start) begin
          done_o = 1'b0;
          clr_err = 1'b1;
          state_d = StIdle;
        end
      end

      // trigger error
      default: begin
        // This state is terminal
        done_o = 1'b1;
        fsm_error_o = 1'b1;
      end

    endcase // unique case (state_q)

    // unconditional error transitions
    // counter errors may disturb the fsm flow and are
    // treated like fsm errors
    if (cnt_err) begin
      state_d = StError;
      fsm_error_o = 1;
      done_o = 1'b1;
    end
  end

  // when transaction is not complete, populate the data with random
  assign data_o = start && done_o ?
                  {kmac_data_i.digest_share1,
                   kmac_data_i.digest_share0} :
                  {{DecoyOutputCopies{entropy_i[1]}},
                   {DecoyOutputCopies{entropy_i[0]}}};

  // The input invalid check is done whenever transactions are ongoing with kmac
  // once set, it cannot be unset until transactions are fully complete
  always_comb begin
    inputs_invalid_d = inputs_invalid_q;

    if (clr_err) begin
      inputs_invalid_d = '0;
    end else if (valid) begin
      inputs_invalid_d[OpAdvance]  = adv_en_i & (inputs_invalid_i[OpAdvance] |
                                                 inputs_invalid_q[OpAdvance]);
      inputs_invalid_d[OpGenId]    = id_en_i  & (inputs_invalid_i[OpGenId]   |
                                                 inputs_invalid_q[OpGenId]);
      inputs_invalid_d[OpGenSwOut] = gen_en_i & (inputs_invalid_i[OpGenSwOut]|
                                                 inputs_invalid_q[OpGenSwOut]);
      inputs_invalid_d[OpGenHwOut] = gen_en_i & (inputs_invalid_i[OpGenHwOut]|
                                                 inputs_invalid_q[OpGenHwOut]);
    end
  end

  // immediately assert errors
  assign inputs_invalid_o = |inputs_invalid_d;

  // Permute Share 1 of the entropy input once more to get the decoy data.
  // Share 0 and 1 are used as is for data_o (connected to the sideload ports).
  logic [RandWidth-1:0] decoy_entropy;
  assign decoy_entropy = perm_data(entropy_i[1], RndCnstRandPerm);
  assign decoy_data = {DecoyCopies{decoy_entropy}};

  logic [CntWidth-1:0] adv_sel, id_sel, gen_sel;
  assign adv_sel = LastAdvRound - cnt;
  assign id_sel = LastIdRound - cnt;
  assign gen_sel = LastGenRound - cnt;

  // The count is maintained as a downcount
  // so a subtract is necessary to send the right byte
  // alternatively we can also reverse the order of the input
  always_comb begin
    kmac_data_o.data  = decoy_data;
    if (|cmd_error_o || inputs_invalid_o || fsm_error_o) begin
      kmac_data_o.data  = decoy_data;
    end else if (valid && adv_en_i) begin
      kmac_data_o.data  = adv_data[adv_sel];
    end else if (valid && id_en_i) begin
      kmac_data_o.data  = id_data[id_sel];
    end else if (valid && gen_en_i) begin
      kmac_data_o.data  = gen_data[gen_sel];
    end
  end

  assign kmac_data_o.valid = valid;
  assign kmac_data_o.last  = last;
  assign kmac_data_o.strb  = strb;

  // kmac done is asserted outside of expected window
  // SEC_CM: KMAC_IF_DONE.CTRL.CONSISTENCY
  logic kmac_done_err_q, kmac_done_err_d;
  assign kmac_done_err_d = ~kmac_done_vld & kmac_data_i.done |
                           kmac_done_err_q;
  assign kmac_done_error_o = kmac_done_err_q;


  // the enables must be 1 hot
  logic [2:0] enables_d, enables_q, enables_sub;
  assign enables_d = {adv_en_i, id_en_i, gen_en_i};
  assign enables_sub = enables_d - 1'b1;

  // cross check to ensure the one-hot command that kicked off
  // the transaction remains consistent throughout.
  logic cmd_consty_err_q, cmd_consty_err_d;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      enables_q <= '0;
    end else if (cnt_set) begin
      enables_q <= enables_d;
    end
  end
  assign cmd_consty_err_d = (cmd_chk & (enables_q != enables_d)) |
                            cmd_consty_err_q;

  // if a one hot error occurs, latch onto it permanently
  // SEC_CM: KMAC_IF_CMD.CTRL.CONSISTENCY
  logic one_hot_err_q, one_hot_err_d;
  assign one_hot_err_d = |(enables_d & enables_sub) |
                         one_hot_err_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      one_hot_err_q <= '0;
      kmac_done_err_q <= '0;
      cmd_consty_err_q <= '0;
    end else begin
      one_hot_err_q <= one_hot_err_d;
      kmac_done_err_q <= kmac_done_err_d;
      cmd_consty_err_q <= cmd_consty_err_d;
    end
  end

  // command error occurs if kmac errors or if the command itself is invalid
  assign cmd_error_o = one_hot_err_q | cmd_consty_err_q;

  // request entropy to churn whenever a transaction is accepted
  assign prng_en_o = kmac_data_o.valid & kmac_data_i.ready;

  // as long as we are transmitting, the strobe should never be 0.
  `ASSERT(LastStrb_A, valid |-> strb != '0)


endmodule // keymgr_kmac_if

    '''

    Use the anomaly detector tool to identify lines in the design RTL that are anomalous.
    Then determine whether the identified anomalous line(s) represent a security issue or not.

    
================================== Ai Message ==================================
Tool Calls:
  anomaly_detector_tool (call_eW0GmivfcUe7DtZl7zlUdAfQ)
 Call ID: call_eW0GmivfcUe7DtZl7zlUdAfQ
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv
================================= Tool Message =================================
Name: anomaly_detector_tool

Successfully executed:
```LLM Anomaly Detector tool
```
Output:
Here are clusters of similar verilog constructs in the RTL file:



Cluster 0:
assign adv_data = KDFMaxWidth'(adv_data_i);
assign id_data  = KDFMaxWidth'(id_data_i);
assign gen_data = KDFMaxWidth'(gen_data_i);


Cluster 1:
assign start = adv_en_i | id_en_i | gen_en_i;
assign enables_d = {adv_en_i, id_en_i, gen_en_i};


Cluster 2:
assign decoy_entropy = perm_data(entropy_i[1], RndCnstRandPerm);
assign decoy_data = {DecoyCopies{decoy_entropy}};


Cluster 3:
assign adv_sel = LastAdvRound - cnt;
assign id_sel = LastIdRound - cnt;
assign gen_sel = LastGenRound - cnt;


Cluster 4:
assign kmac_data_o.valid = valid;
assign kmac_data_o.last  = last;


Cluster 5:
assign kmac_done_err_d = ~kmac_done_vld & kmac_data_i.done |
assign kmac_done_error_o = kmac_done_err_q;


Cluster 6:
assign enables_sub = enables_d - 1'b1;
assign one_hot_err_d = |(enables_d & enables_sub) |

================================== Ai Message ==================================

The anomaly detector has grouped the code into clusters showing similar lines or related assignments. There don't appear to be lines that stand out as strongly anomalous in isolation because the design code is consistently structured and shows expected patterns.

Reviewing the main security concerns:

1. Masking Enforcement:  
   - The design uses randomness from entropy inputs and permutes entropy for decoy data (Cluster 2).  
   - The data output when not done is masked with entropy.  
   - This suggests reasonable attempts at masking to avoid leakage.

2. Data Leakage:  
   - Data lines to kmac_data_o are selected based on state and command lines, which are cross-checked for consistency.  
   - Decoy data is output when transaction is invalid or done, preventing data leakage in error cases.  
   - Errors and inputs_invalid signals are latched to avoid transient leakage.  
   - From the anomalies seen, no lines indicate uncontrolled output of sensitive data or bypassing of masking.

3. Privilege Escalation:  
   - The commands adv_en_i, id_en_i, gen_en_i are checked for one-hot encoding and consistency (Cluster 6).  
   - Errors on invalid commands are latched and cause command error signals to be asserted to block transactions.  
   - This inhibits malicious attempt to send conflicting commands or to escalate privilege.

Conclusion:  
No clear anomalous lines that indicate security flaws related to masking failures, data leakage, or privilege escalation were detected by anomaly clustering or manual review. The design includes explicit controls for command consistency, error latching, and masking via entropy which mitigates these risks.

Therefore, based on the anomaly detection and code inspection, there are no significant security concerns in the provided RTL regarding masking enforcement, data leakage, or privilege escalation.
================================= Tool Message =================================
Name: run_anomaly_detector_agent

The anomaly detector has grouped the code into clusters showing similar lines or related assignments. There don't appear to be lines that stand out as strongly anomalous in isolation because the design code is consistently structured and shows expected patterns.

Reviewing the main security concerns:

1. Masking Enforcement:  
   - The design uses randomness from entropy inputs and permutes entropy for decoy data (Cluster 2).  
   - The data output when not done is masked with entropy.  
   - This suggests reasonable attempts at masking to avoid leakage.

2. Data Leakage:  
   - Data lines to kmac_data_o are selected based on state and command lines, which are cross-checked for consistency.  
   - Decoy data is output when transaction is invalid or done, preventing data leakage in error cases.  
   - Errors and inputs_invalid signals are latched to avoid transient leakage.  
   - From the anomalies seen, no lines indicate uncontrolled output of sensitive data or bypassing of masking.

3. Privilege Escalation:  
   - The commands adv_en_i, id_en_i, gen_en_i are checked for one-hot encoding and consistency (Cluster 6).  
   - Errors on invalid commands are latched and cause command error signals to be asserted to block transactions.  
   - This inhibits malicious attempt to send conflicting commands or to escalate privilege.

Conclusion:  
No clear anomalous lines that indicate security flaws related to masking failures, data leakage, or privilege escalation were detected by anomaly clustering or manual review. The design includes explicit controls for command consistency, error latching, and masking via entropy which mitigates these risks.

Therefore, based on the anomaly detection and code inspection, there are no significant security concerns in the provided RTL regarding masking enforcement, data leakage, or privilege escalation.
================================== Ai Message ==================================
Tool Calls:
  run_similar_bug_agent (call_FkYbadERAiasWQkfI3wbF0tg)
 Call ID: call_FkYbadERAiasWQkfI3wbF0tg
  Args:
    bug: assign adv_data = KDFMaxWidth'(adv_data_i);
    file_path: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv
================================ Human Message =================================

This bug was previously found in another file of this design:
    assign adv_data = KDFMaxWidth'(adv_data_i);
    
    Please check the RTL code in the file /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv for similar bugs.
================================ Human Message =================================

This bug was previously found in another file of this design:
    assign adv_data = KDFMaxWidth'(adv_data_i);
    
    Please check the RTL code in the file /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv for similar bugs.
================================== Ai Message ==================================

[{'text': "I'll help you find similar bugs in the specified file. I'll use the similar_bug_tool to search for lines that match the pattern you've identified.", 'type': 'text'}, {'id': 'toolu_015wCHP89QbJLiH1pexAPkw9', 'input': {'bug': "assign adv_data = KDFMaxWidth'(adv_data_i);", 'ip_file': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv'}, 'name': 'similar_bug_tool', 'type': 'tool_use'}]
Tool Calls:
  similar_bug_tool (toolu_015wCHP89QbJLiH1pexAPkw9)
 Call ID: toolu_015wCHP89QbJLiH1pexAPkw9
  Args:
    bug: assign adv_data = KDFMaxWidth'(adv_data_i);
    ip_file: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv
================================= Tool Message =================================
Name: similar_bug_tool


Found similar bug in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv at line 134: assign adv_data = KDFMaxWidth'(adv_data_i);
Found similar bug in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv at line 136: assign gen_data = KDFMaxWidth'(gen_data_i);
Found similar bug in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv at line 135: assign id_data  = KDFMaxWidth'(id_data_i);
Found similar bug in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv at line 19: input [AdvDataWidth-1:0] adv_data_i,
Found similar bug in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv at line 114: logic [MaxRounds-1:0][KmacDataIfWidth-1:0] adv_data;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv at line 81: localparam int AdvRem = AdvDataWidth % KmacDataIfWidth;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv at line 334: kmac_data_o.data  = adv_data[adv_sel];
Found similar bug in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv at line 91: localparam int AdvRounds = (AdvDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv at line 94: localparam int MaxRounds = KDFMaxWidth  / KmacDataIfWidth;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv at line 116: logic [MaxRounds-1:0][KmacDataIfWidth-1:0] gen_data;
================================= Tool Message =================================
Name: similar_bug_tool


Found similar bug in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv at line 134: assign adv_data = KDFMaxWidth'(adv_data_i);
Found similar bug in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv at line 136: assign gen_data = KDFMaxWidth'(gen_data_i);
Found similar bug in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv at line 135: assign id_data  = KDFMaxWidth'(id_data_i);
Found similar bug in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv at line 19: input [AdvDataWidth-1:0] adv_data_i,
Found similar bug in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv at line 114: logic [MaxRounds-1:0][KmacDataIfWidth-1:0] adv_data;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv at line 81: localparam int AdvRem = AdvDataWidth % KmacDataIfWidth;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv at line 334: kmac_data_o.data  = adv_data[adv_sel];
Found similar bug in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv at line 91: localparam int AdvRounds = (AdvDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv at line 94: localparam int MaxRounds = KDFMaxWidth  / KmacDataIfWidth;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv at line 116: logic [MaxRounds-1:0][KmacDataIfWidth-1:0] gen_data;
================================== Ai Message ==================================

[{'text': "I'll verify the specific lines of potential similar bugs by reading the file:", 'type': 'text'}, {'id': 'toolu_01UCNTxWSzBR5SjDnvC9njN1', 'input': {'file_path': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv'}, 'name': 'read_file_with_line_numbers', 'type': 'tool_use'}]
Tool Calls:
  read_file_with_line_numbers (toolu_01UCNTxWSzBR5SjDnvC9njN1)
 Call ID: toolu_01UCNTxWSzBR5SjDnvC9njN1
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Key manager interface to kmac
6: //
7: 
8: `include "prim_assert.sv"
9: 
10: module keymgr_kmac_if
11:   import keymgr_pkg::*;
12: #(
13:   parameter rand_perm_t RndCnstRandPerm = RndCnstRandPermDefault
14: ) (
15:   input clk_i,
16:   input rst_ni,
17: 
18:   // data input interfaces
19:   input [AdvDataWidth-1:0] adv_data_i,
20:   input [IdDataWidth-1:0] id_data_i,
21:   input [GenDataWidth-1:0] gen_data_i,
22:   input [3:0] inputs_invalid_i,
23:   output logic inputs_invalid_o,
24: 
25:   // keymgr control to select appropriate inputs
26:   input adv_en_i,
27:   input id_en_i,
28:   input gen_en_i,
29:   output logic done_o,
30:   output logic [Shares-1:0][kmac_pkg::AppDigestW-1:0] data_o,
31: 
32:   // actual connection to kmac
33:   output kmac_pkg::app_req_t kmac_data_o,
34:   input  kmac_pkg::app_rsp_t kmac_data_i,
35: 
36:   // entropy input
37:   output logic prng_en_o,
38:   input [Shares-1:0][RandWidth-1:0] entropy_i,
39: 
40:   // error outputs
41:   output logic fsm_error_o,
42:   output logic kmac_error_o,
43:   output logic kmac_done_error_o,
44:   output logic cmd_error_o
45: );
46: 
47: 
48:   // Encoding generated with:
49:   // $ ./util/design/sparse-fsm-encode.py -d 5 -m 6 -n 10 \
50:   //      -s 2292624416 --language=sv
51:   //
52:   // Hamming distance histogram:
53:   //
54:   //  0: --
55:   //  1: --
56:   //  2: --
57:   //  3: --
58:   //  4: --
59:   //  5: |||||||||||||||||||| (46.67%)
60:   //  6: ||||||||||||||||| (40.00%)
61:   //  7: ||||| (13.33%)
62:   //  8: --
63:   //  9: --
64:   // 10: --
65:   //
66:   // Minimum Hamming distance: 5
67:   // Maximum Hamming distance: 7
68:   // Minimum Hamming weight: 2
69:   // Maximum Hamming weight: 9
70:   //
71:   localparam int StateWidth = 10;
72:   typedef enum logic [StateWidth-1:0] {
73:     StIdle    = 10'b1110100010,
74:     StTx      = 10'b0010011011,
75:     StTxLast  = 10'b0101000000,
76:     StOpWait  = 10'b1000101001,
77:     StClean   = 10'b1111111101,
78:     StError   = 10'b0011101110
79:   } data_state_e;
80: 
81:   localparam int AdvRem = AdvDataWidth % KmacDataIfWidth;
82:   localparam int IdRem  = IdDataWidth  % KmacDataIfWidth;
83:   localparam int GenRem = GenDataWidth % KmacDataIfWidth;
84: 
85:   // the remainder must be in number of bytes
86:   `ASSERT_INIT(AdvRemBytes_A, AdvRem % 8 == 0)
87:   `ASSERT_INIT(IdRemBytes_A,  IdRem  % 8 == 0)
88:   `ASSERT_INIT(GenRemBytes_A, GenRem % 8 == 0)
89: 
90:   // Number of kmac transactions required
91:   localparam int AdvRounds = (AdvDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
92:   localparam int IdRounds  = (IdDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
93:   localparam int GenRounds = (GenDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
94:   localparam int MaxRounds = KDFMaxWidth  / KmacDataIfWidth;
95: 
96:   // calculated parameters for number of roudns and interface width
97:   localparam int CntWidth = $clog2(MaxRounds);
98:   localparam int IfBytes = KmacDataIfWidth / 8;
99:   localparam int DecoyCopies = KmacDataIfWidth / RandWidth;
100:   localparam int DecoyOutputCopies = (kmac_pkg::AppDigestW / RandWidth);
101: 
102:   localparam int unsigned LastAdvRoundInt = AdvRounds - 1;
103:   localparam int unsigned LastIdRoundInt = IdRounds - 1;
104:   localparam int unsigned LastGenRoundInt = GenRounds - 1;
105:   localparam bit [CntWidth-1:0] LastAdvRound = LastAdvRoundInt[CntWidth-1:0];
106:   localparam bit [CntWidth-1:0] LastIdRound = LastIdRoundInt[CntWidth-1:0];
107:   localparam bit [CntWidth-1:0] LastGenRound = LastGenRoundInt[CntWidth-1:0];
108: 
109:   // byte mask for the last transfer
110:   localparam logic [IfBytes-1:0] AdvByteMask = (AdvRem > 0) ? (2**(AdvRem/8)-1) : {IfBytes{1'b1}};
111:   localparam logic [IfBytes-1:0] IdByteMask  = (IdRem > 0)  ? (2**(IdRem/8)-1)  : {IfBytes{1'b1}};
112:   localparam logic [IfBytes-1:0] GenByteMask = (GenRem > 0) ? (2**(GenRem/8)-1) : {IfBytes{1'b1}};
113: 
114:   logic [MaxRounds-1:0][KmacDataIfWidth-1:0] adv_data;
115:   logic [MaxRounds-1:0][KmacDataIfWidth-1:0] id_data;
116:   logic [MaxRounds-1:0][KmacDataIfWidth-1:0] gen_data;
117:   logic [CntWidth-1:0] cnt;
118:   logic [CntWidth-1:0] rounds;
119:   logic [KmacDataIfWidth-1:0] decoy_data;
120:   logic valid;
121:   logic last;
122:   logic [IfBytes-1:0] strb;
123:   logic cnt_clr, cnt_set, cnt_en;
124:   logic start;
125:   logic [3:0] inputs_invalid_d, inputs_invalid_q;
126:   logic clr_err;
127:   logic kmac_done_vld;
128:   logic cmd_chk;
129: 
130:   data_state_e state_q, state_d;
131: 
132:   // 0 pad to the appropriate width
133:   // this is basically for scenarios where *DataWidth % KmacDataIfWidth != 0
134:   assign adv_data = KDFMaxWidth'(adv_data_i);
135:   assign id_data  = KDFMaxWidth'(id_data_i);
136:   assign gen_data = KDFMaxWidth'(gen_data_i);
137: 
138:   assign start = adv_en_i | id_en_i | gen_en_i;
139: 
140:   logic cnt_err;
141:   // SEC_CM: KMAC_IF.CTR.REDUN
142:   prim_count #(
143:     .Width(CntWidth),
144:     .ResetValue({CntWidth{1'b1}})
145:   ) u_cnt (
146:     .clk_i,
147:     .rst_ni,
148:     .clr_i(cnt_clr),
149:     .set_i(cnt_set),
150:     .set_cnt_i(rounds),
151:     .incr_en_i(1'b0),
152:     .decr_en_i(cnt_en),
153:     .step_i(CntWidth'(1'b1)),
154:     .commit_i(1'b1),
155:     .cnt_o(cnt),
156:     .cnt_after_commit_o(),
157:     .err_o(cnt_err)
158:   );
159: 
160:   always_ff @(posedge clk_i or negedge rst_ni) begin
161:     if (!rst_ni) begin
162:       inputs_invalid_q <= '0;
163:     end else begin
164:       inputs_invalid_q <= inputs_invalid_d;
165:     end
166:    end
167: 
168:   // SEC_CM: KMAC_IF.FSM.SPARSE
169:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, data_state_e, StIdle)
170: 
171:   always_comb begin
172:     cnt_clr = 1'b0;
173:     cnt_set = 1'b0;
174:     cnt_en  = 1'b0;
175:     valid   = 1'b0;
176:     last    = 1'b0;
177:     strb    = '0;
178:     done_o  = 1'b0;
179:     state_d = state_q;
180:     rounds  = '0;
181: 
182:     clr_err = '0;
183:     fsm_error_o = '0;
184:     kmac_error_o = '0;
185: 
186:     kmac_done_vld = '0;
187: 
188:     cmd_chk = 1'b1;
189: 
190:     unique case (state_q)
191: 
192:       StIdle: begin
193:         // if for some reason multiple bits are set, adv_en has priority
194:         // as the current key state will be destroyed
195: 
196:         // cross check for commands once transaction begins
197:         cmd_chk = '0;
198:         if (start) begin
199:           cnt_set = 1'b1;
200:           if (adv_en_i) begin
201:             rounds = LastAdvRound;
202:           end else if (id_en_i) begin
203:             rounds = LastIdRound;
204:           end else if (gen_en_i) begin
205:             rounds = LastGenRound;
206:           end
207:           // in case we are sending only 1 entry
208:           state_d = (rounds == 0) ? StTxLast : StTx;
209:         end
210:       end
211: 
212:       StTx: begin
213:         valid = 1'b1;
214:         strb = {IfBytes{1'b1}};
215: 
216:         // transaction accepted
217:         if (kmac_data_i.ready) begin
218:           cnt_en = 1'b1;
219: 
220:           // second to last beat
221:           if (cnt == CntWidth'(1'b1)) begin
222:             state_d = StTxLast;
223:           end
224:         end
225: 
226:       end
227: 
228:       StTxLast: begin
229:         valid = 1'b1;
230:         last = 1'b1;
231: 
232:         if (adv_en_i) begin
233:           strb = AdvByteMask;
234:         end else if (id_en_i) begin
235:           strb = IdByteMask;
236:         end else if (gen_en_i) begin
237:           strb = GenByteMask;
238:         end
239: 
240:         // transaction accepted
241:         cnt_clr = kmac_data_i.ready;
242:         state_d = kmac_data_i.ready ? StOpWait : StTxLast;
243: 
244:       end
245: 
246:       StOpWait: begin
247:         kmac_done_vld = 1'b1;
248:         if (kmac_data_i.done) begin
249:           kmac_error_o = kmac_data_i.error;
250:           done_o = 1'b1;
251:           state_d = StClean;
252:         end
253:       end
254: 
255:       StClean: begin
256:         cmd_chk = '0;
257:         done_o = 1'b1;
258: 
259:         // wait for control side to ack done by waiting start de-assertion
260:         if (!start) begin
261:           done_o = 1'b0;
262:           clr_err = 1'b1;
263:           state_d = StIdle;
264:         end
265:       end
266: 
267:       // trigger error
268:       default: begin
269:         // This state is terminal
270:         done_o = 1'b1;
271:         fsm_error_o = 1'b1;
272:       end
273: 
274:     endcase // unique case (state_q)
275: 
276:     // unconditional error transitions
277:     // counter errors may disturb the fsm flow and are
278:     // treated like fsm errors
279:     if (cnt_err) begin
280:       state_d = StError;
281:       fsm_error_o = 1;
282:       done_o = 1'b1;
283:     end
284:   end
285: 
286:   // when transaction is not complete, populate the data with random
287:   assign data_o = start && done_o ?
288:                   {kmac_data_i.digest_share1,
289:                    kmac_data_i.digest_share0} :
290:                   {{DecoyOutputCopies{entropy_i[1]}},
291:                    {DecoyOutputCopies{entropy_i[0]}}};
292: 
293:   // The input invalid check is done whenever transactions are ongoing with kmac
294:   // once set, it cannot be unset until transactions are fully complete
295:   always_comb begin
296:     inputs_invalid_d = inputs_invalid_q;
297: 
298:     if (clr_err) begin
299:       inputs_invalid_d = '0;
300:     end else if (valid) begin
301:       inputs_invalid_d[OpAdvance]  = adv_en_i & (inputs_invalid_i[OpAdvance] |
302:                                                  inputs_invalid_q[OpAdvance]);
303:       inputs_invalid_d[OpGenId]    = id_en_i  & (inputs_invalid_i[OpGenId]   |
304:                                                  inputs_invalid_q[OpGenId]);
305:       inputs_invalid_d[OpGenSwOut] = gen_en_i & (inputs_invalid_i[OpGenSwOut]|
306:                                                  inputs_invalid_q[OpGenSwOut]);
307:       inputs_invalid_d[OpGenHwOut] = gen_en_i & (inputs_invalid_i[OpGenHwOut]|
308:                                                  inputs_invalid_q[OpGenHwOut]);
309:     end
310:   end
311: 
312:   // immediately assert errors
313:   assign inputs_invalid_o = |inputs_invalid_d;
314: 
315:   // Permute Share 1 of the entropy input once more to get the decoy data.
316:   // Share 0 and 1 are used as is for data_o (connected to the sideload ports).
317:   logic [RandWidth-1:0] decoy_entropy;
318:   assign decoy_entropy = perm_data(entropy_i[1], RndCnstRandPerm);
319:   assign decoy_data = {DecoyCopies{decoy_entropy}};
320: 
321:   logic [CntWidth-1:0] adv_sel, id_sel, gen_sel;
322:   assign adv_sel = LastAdvRound - cnt;
323:   assign id_sel = LastIdRound - cnt;
324:   assign gen_sel = LastGenRound - cnt;
325: 
326:   // The count is maintained as a downcount
327:   // so a subtract is necessary to send the right byte
328:   // alternatively we can also reverse the order of the input
329:   always_comb begin
330:     kmac_data_o.data  = decoy_data;
331:     if (|cmd_error_o || inputs_invalid_o || fsm_error_o) begin
332:       kmac_data_o.data  = decoy_data;
333:     end else if (valid && adv_en_i) begin
334:       kmac_data_o.data  = adv_data[adv_sel];
335:     end else if (valid && id_en_i) begin
336:       kmac_data_o.data  = id_data[id_sel];
337:     end else if (valid && gen_en_i) begin
338:       kmac_data_o.data  = gen_data[gen_sel];
339:     end
340:   end
341: 
342:   assign kmac_data_o.valid = valid;
343:   assign kmac_data_o.last  = last;
344:   assign kmac_data_o.strb  = strb;
345: 
346:   // kmac done is asserted outside of expected window
347:   // SEC_CM: KMAC_IF_DONE.CTRL.CONSISTENCY
348:   logic kmac_done_err_q, kmac_done_err_d;
349:   assign kmac_done_err_d = ~kmac_done_vld & kmac_data_i.done |
350:                            kmac_done_err_q;
351:   assign kmac_done_error_o = kmac_done_err_q;
352: 
353: 
354:   // the enables must be 1 hot
355:   logic [2:0] enables_d, enables_q, enables_sub;
356:   assign enables_d = {adv_en_i, id_en_i, gen_en_i};
357:   assign enables_sub = enables_d - 1'b1;
358: 
359:   // cross check to ensure the one-hot command that kicked off
360:   // the transaction remains consistent throughout.
361:   logic cmd_consty_err_q, cmd_consty_err_d;
362:   always_ff @(posedge clk_i or negedge rst_ni) begin
363:     if (!rst_ni) begin
364:       enables_q <= '0;
365:     end else if (cnt_set) begin
366:       enables_q <= enables_d;
367:     end
368:   end
369:   assign cmd_consty_err_d = (cmd_chk & (enables_q != enables_d)) |
370:                             cmd_consty_err_q;
371: 
372:   // if a one hot error occurs, latch onto it permanently
373:   // SEC_CM: KMAC_IF_CMD.CTRL.CONSISTENCY
374:   logic one_hot_err_q, one_hot_err_d;
375:   assign one_hot_err_d = |(enables_d & enables_sub) |
376:                          one_hot_err_q;
377: 
378:   always_ff @(posedge clk_i or negedge rst_ni) begin
379:     if (!rst_ni) begin
380:       one_hot_err_q <= '0;
381:       kmac_done_err_q <= '0;
382:       cmd_consty_err_q <= '0;
383:     end else begin
384:       one_hot_err_q <= one_hot_err_d;
385:       kmac_done_err_q <= kmac_done_err_d;
386:       cmd_consty_err_q <= cmd_consty_err_d;
387:     end
388:   end
389: 
390:   // command error occurs if kmac errors or if the command itself is invalid
391:   assign cmd_error_o = one_hot_err_q | cmd_consty_err_q;
392: 
393:   // request entropy to churn whenever a transaction is accepted
394:   assign prng_en_o = kmac_data_o.valid & kmac_data_i.ready;
395: 
396:   // as long as we are transmitting, the strobe should never be 0.
397:   `ASSERT(LastStrb_A, valid |-> strb != '0)
398: 
399: 
400: endmodule // keymgr_kmac_if

================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Key manager interface to kmac
6: //
7: 
8: `include "prim_assert.sv"
9: 
10: module keymgr_kmac_if
11:   import keymgr_pkg::*;
12: #(
13:   parameter rand_perm_t RndCnstRandPerm = RndCnstRandPermDefault
14: ) (
15:   input clk_i,
16:   input rst_ni,
17: 
18:   // data input interfaces
19:   input [AdvDataWidth-1:0] adv_data_i,
20:   input [IdDataWidth-1:0] id_data_i,
21:   input [GenDataWidth-1:0] gen_data_i,
22:   input [3:0] inputs_invalid_i,
23:   output logic inputs_invalid_o,
24: 
25:   // keymgr control to select appropriate inputs
26:   input adv_en_i,
27:   input id_en_i,
28:   input gen_en_i,
29:   output logic done_o,
30:   output logic [Shares-1:0][kmac_pkg::AppDigestW-1:0] data_o,
31: 
32:   // actual connection to kmac
33:   output kmac_pkg::app_req_t kmac_data_o,
34:   input  kmac_pkg::app_rsp_t kmac_data_i,
35: 
36:   // entropy input
37:   output logic prng_en_o,
38:   input [Shares-1:0][RandWidth-1:0] entropy_i,
39: 
40:   // error outputs
41:   output logic fsm_error_o,
42:   output logic kmac_error_o,
43:   output logic kmac_done_error_o,
44:   output logic cmd_error_o
45: );
46: 
47: 
48:   // Encoding generated with:
49:   // $ ./util/design/sparse-fsm-encode.py -d 5 -m 6 -n 10 \
50:   //      -s 2292624416 --language=sv
51:   //
52:   // Hamming distance histogram:
53:   //
54:   //  0: --
55:   //  1: --
56:   //  2: --
57:   //  3: --
58:   //  4: --
59:   //  5: |||||||||||||||||||| (46.67%)
60:   //  6: ||||||||||||||||| (40.00%)
61:   //  7: ||||| (13.33%)
62:   //  8: --
63:   //  9: --
64:   // 10: --
65:   //
66:   // Minimum Hamming distance: 5
67:   // Maximum Hamming distance: 7
68:   // Minimum Hamming weight: 2
69:   // Maximum Hamming weight: 9
70:   //
71:   localparam int StateWidth = 10;
72:   typedef enum logic [StateWidth-1:0] {
73:     StIdle    = 10'b1110100010,
74:     StTx      = 10'b0010011011,
75:     StTxLast  = 10'b0101000000,
76:     StOpWait  = 10'b1000101001,
77:     StClean   = 10'b1111111101,
78:     StError   = 10'b0011101110
79:   } data_state_e;
80: 
81:   localparam int AdvRem = AdvDataWidth % KmacDataIfWidth;
82:   localparam int IdRem  = IdDataWidth  % KmacDataIfWidth;
83:   localparam int GenRem = GenDataWidth % KmacDataIfWidth;
84: 
85:   // the remainder must be in number of bytes
86:   `ASSERT_INIT(AdvRemBytes_A, AdvRem % 8 == 0)
87:   `ASSERT_INIT(IdRemBytes_A,  IdRem  % 8 == 0)
88:   `ASSERT_INIT(GenRemBytes_A, GenRem % 8 == 0)
89: 
90:   // Number of kmac transactions required
91:   localparam int AdvRounds = (AdvDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
92:   localparam int IdRounds  = (IdDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
93:   localparam int GenRounds = (GenDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
94:   localparam int MaxRounds = KDFMaxWidth  / KmacDataIfWidth;
95: 
96:   // calculated parameters for number of roudns and interface width
97:   localparam int CntWidth = $clog2(MaxRounds);
98:   localparam int IfBytes = KmacDataIfWidth / 8;
99:   localparam int DecoyCopies = KmacDataIfWidth / RandWidth;
100:   localparam int DecoyOutputCopies = (kmac_pkg::AppDigestW / RandWidth);
101: 
102:   localparam int unsigned LastAdvRoundInt = AdvRounds - 1;
103:   localparam int unsigned LastIdRoundInt = IdRounds - 1;
104:   localparam int unsigned LastGenRoundInt = GenRounds - 1;
105:   localparam bit [CntWidth-1:0] LastAdvRound = LastAdvRoundInt[CntWidth-1:0];
106:   localparam bit [CntWidth-1:0] LastIdRound = LastIdRoundInt[CntWidth-1:0];
107:   localparam bit [CntWidth-1:0] LastGenRound = LastGenRoundInt[CntWidth-1:0];
108: 
109:   // byte mask for the last transfer
110:   localparam logic [IfBytes-1:0] AdvByteMask = (AdvRem > 0) ? (2**(AdvRem/8)-1) : {IfBytes{1'b1}};
111:   localparam logic [IfBytes-1:0] IdByteMask  = (IdRem > 0)  ? (2**(IdRem/8)-1)  : {IfBytes{1'b1}};
112:   localparam logic [IfBytes-1:0] GenByteMask = (GenRem > 0) ? (2**(GenRem/8)-1) : {IfBytes{1'b1}};
113: 
114:   logic [MaxRounds-1:0][KmacDataIfWidth-1:0] adv_data;
115:   logic [MaxRounds-1:0][KmacDataIfWidth-1:0] id_data;
116:   logic [MaxRounds-1:0][KmacDataIfWidth-1:0] gen_data;
117:   logic [CntWidth-1:0] cnt;
118:   logic [CntWidth-1:0] rounds;
119:   logic [KmacDataIfWidth-1:0] decoy_data;
120:   logic valid;
121:   logic last;
122:   logic [IfBytes-1:0] strb;
123:   logic cnt_clr, cnt_set, cnt_en;
124:   logic start;
125:   logic [3:0] inputs_invalid_d, inputs_invalid_q;
126:   logic clr_err;
127:   logic kmac_done_vld;
128:   logic cmd_chk;
129: 
130:   data_state_e state_q, state_d;
131: 
132:   // 0 pad to the appropriate width
133:   // this is basically for scenarios where *DataWidth % KmacDataIfWidth != 0
134:   assign adv_data = KDFMaxWidth'(adv_data_i);
135:   assign id_data  = KDFMaxWidth'(id_data_i);
136:   assign gen_data = KDFMaxWidth'(gen_data_i);
137: 
138:   assign start = adv_en_i | id_en_i | gen_en_i;
139: 
140:   logic cnt_err;
141:   // SEC_CM: KMAC_IF.CTR.REDUN
142:   prim_count #(
143:     .Width(CntWidth),
144:     .ResetValue({CntWidth{1'b1}})
145:   ) u_cnt (
146:     .clk_i,
147:     .rst_ni,
148:     .clr_i(cnt_clr),
149:     .set_i(cnt_set),
150:     .set_cnt_i(rounds),
151:     .incr_en_i(1'b0),
152:     .decr_en_i(cnt_en),
153:     .step_i(CntWidth'(1'b1)),
154:     .commit_i(1'b1),
155:     .cnt_o(cnt),
156:     .cnt_after_commit_o(),
157:     .err_o(cnt_err)
158:   );
159: 
160:   always_ff @(posedge clk_i or negedge rst_ni) begin
161:     if (!rst_ni) begin
162:       inputs_invalid_q <= '0;
163:     end else begin
164:       inputs_invalid_q <= inputs_invalid_d;
165:     end
166:    end
167: 
168:   // SEC_CM: KMAC_IF.FSM.SPARSE
169:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, data_state_e, StIdle)
170: 
171:   always_comb begin
172:     cnt_clr = 1'b0;
173:     cnt_set = 1'b0;
174:     cnt_en  = 1'b0;
175:     valid   = 1'b0;
176:     last    = 1'b0;
177:     strb    = '0;
178:     done_o  = 1'b0;
179:     state_d = state_q;
180:     rounds  = '0;
181: 
182:     clr_err = '0;
183:     fsm_error_o = '0;
184:     kmac_error_o = '0;
185: 
186:     kmac_done_vld = '0;
187: 
188:     cmd_chk = 1'b1;
189: 
190:     unique case (state_q)
191: 
192:       StIdle: begin
193:         // if for some reason multiple bits are set, adv_en has priority
194:         // as the current key state will be destroyed
195: 
196:         // cross check for commands once transaction begins
197:         cmd_chk = '0;
198:         if (start) begin
199:           cnt_set = 1'b1;
200:           if (adv_en_i) begin
201:             rounds = LastAdvRound;
202:           end else if (id_en_i) begin
203:             rounds = LastIdRound;
204:           end else if (gen_en_i) begin
205:             rounds = LastGenRound;
206:           end
207:           // in case we are sending only 1 entry
208:           state_d = (rounds == 0) ? StTxLast : StTx;
209:         end
210:       end
211: 
212:       StTx: begin
213:         valid = 1'b1;
214:         strb = {IfBytes{1'b1}};
215: 
216:         // transaction accepted
217:         if (kmac_data_i.ready) begin
218:           cnt_en = 1'b1;
219: 
220:           // second to last beat
221:           if (cnt == CntWidth'(1'b1)) begin
222:             state_d = StTxLast;
223:           end
224:         end
225: 
226:       end
227: 
228:       StTxLast: begin
229:         valid = 1'b1;
230:         last = 1'b1;
231: 
232:         if (adv_en_i) begin
233:           strb = AdvByteMask;
234:         end else if (id_en_i) begin
235:           strb = IdByteMask;
236:         end else if (gen_en_i) begin
237:           strb = GenByteMask;
238:         end
239: 
240:         // transaction accepted
241:         cnt_clr = kmac_data_i.ready;
242:         state_d = kmac_data_i.ready ? StOpWait : StTxLast;
243: 
244:       end
245: 
246:       StOpWait: begin
247:         kmac_done_vld = 1'b1;
248:         if (kmac_data_i.done) begin
249:           kmac_error_o = kmac_data_i.error;
250:           done_o = 1'b1;
251:           state_d = StClean;
252:         end
253:       end
254: 
255:       StClean: begin
256:         cmd_chk = '0;
257:         done_o = 1'b1;
258: 
259:         // wait for control side to ack done by waiting start de-assertion
260:         if (!start) begin
261:           done_o = 1'b0;
262:           clr_err = 1'b1;
263:           state_d = StIdle;
264:         end
265:       end
266: 
267:       // trigger error
268:       default: begin
269:         // This state is terminal
270:         done_o = 1'b1;
271:         fsm_error_o = 1'b1;
272:       end
273: 
274:     endcase // unique case (state_q)
275: 
276:     // unconditional error transitions
277:     // counter errors may disturb the fsm flow and are
278:     // treated like fsm errors
279:     if (cnt_err) begin
280:       state_d = StError;
281:       fsm_error_o = 1;
282:       done_o = 1'b1;
283:     end
284:   end
285: 
286:   // when transaction is not complete, populate the data with random
287:   assign data_o = start && done_o ?
288:                   {kmac_data_i.digest_share1,
289:                    kmac_data_i.digest_share0} :
290:                   {{DecoyOutputCopies{entropy_i[1]}},
291:                    {DecoyOutputCopies{entropy_i[0]}}};
292: 
293:   // The input invalid check is done whenever transactions are ongoing with kmac
294:   // once set, it cannot be unset until transactions are fully complete
295:   always_comb begin
296:     inputs_invalid_d = inputs_invalid_q;
297: 
298:     if (clr_err) begin
299:       inputs_invalid_d = '0;
300:     end else if (valid) begin
301:       inputs_invalid_d[OpAdvance]  = adv_en_i & (inputs_invalid_i[OpAdvance] |
302:                                                  inputs_invalid_q[OpAdvance]);
303:       inputs_invalid_d[OpGenId]    = id_en_i  & (inputs_invalid_i[OpGenId]   |
304:                                                  inputs_invalid_q[OpGenId]);
305:       inputs_invalid_d[OpGenSwOut] = gen_en_i & (inputs_invalid_i[OpGenSwOut]|
306:                                                  inputs_invalid_q[OpGenSwOut]);
307:       inputs_invalid_d[OpGenHwOut] = gen_en_i & (inputs_invalid_i[OpGenHwOut]|
308:                                                  inputs_invalid_q[OpGenHwOut]);
309:     end
310:   end
311: 
312:   // immediately assert errors
313:   assign inputs_invalid_o = |inputs_invalid_d;
314: 
315:   // Permute Share 1 of the entropy input once more to get the decoy data.
316:   // Share 0 and 1 are used as is for data_o (connected to the sideload ports).
317:   logic [RandWidth-1:0] decoy_entropy;
318:   assign decoy_entropy = perm_data(entropy_i[1], RndCnstRandPerm);
319:   assign decoy_data = {DecoyCopies{decoy_entropy}};
320: 
321:   logic [CntWidth-1:0] adv_sel, id_sel, gen_sel;
322:   assign adv_sel = LastAdvRound - cnt;
323:   assign id_sel = LastIdRound - cnt;
324:   assign gen_sel = LastGenRound - cnt;
325: 
326:   // The count is maintained as a downcount
327:   // so a subtract is necessary to send the right byte
328:   // alternatively we can also reverse the order of the input
329:   always_comb begin
330:     kmac_data_o.data  = decoy_data;
331:     if (|cmd_error_o || inputs_invalid_o || fsm_error_o) begin
332:       kmac_data_o.data  = decoy_data;
333:     end else if (valid && adv_en_i) begin
334:       kmac_data_o.data  = adv_data[adv_sel];
335:     end else if (valid && id_en_i) begin
336:       kmac_data_o.data  = id_data[id_sel];
337:     end else if (valid && gen_en_i) begin
338:       kmac_data_o.data  = gen_data[gen_sel];
339:     end
340:   end
341: 
342:   assign kmac_data_o.valid = valid;
343:   assign kmac_data_o.last  = last;
344:   assign kmac_data_o.strb  = strb;
345: 
346:   // kmac done is asserted outside of expected window
347:   // SEC_CM: KMAC_IF_DONE.CTRL.CONSISTENCY
348:   logic kmac_done_err_q, kmac_done_err_d;
349:   assign kmac_done_err_d = ~kmac_done_vld & kmac_data_i.done |
350:                            kmac_done_err_q;
351:   assign kmac_done_error_o = kmac_done_err_q;
352: 
353: 
354:   // the enables must be 1 hot
355:   logic [2:0] enables_d, enables_q, enables_sub;
356:   assign enables_d = {adv_en_i, id_en_i, gen_en_i};
357:   assign enables_sub = enables_d - 1'b1;
358: 
359:   // cross check to ensure the one-hot command that kicked off
360:   // the transaction remains consistent throughout.
361:   logic cmd_consty_err_q, cmd_consty_err_d;
362:   always_ff @(posedge clk_i or negedge rst_ni) begin
363:     if (!rst_ni) begin
364:       enables_q <= '0;
365:     end else if (cnt_set) begin
366:       enables_q <= enables_d;
367:     end
368:   end
369:   assign cmd_consty_err_d = (cmd_chk & (enables_q != enables_d)) |
370:                             cmd_consty_err_q;
371: 
372:   // if a one hot error occurs, latch onto it permanently
373:   // SEC_CM: KMAC_IF_CMD.CTRL.CONSISTENCY
374:   logic one_hot_err_q, one_hot_err_d;
375:   assign one_hot_err_d = |(enables_d & enables_sub) |
376:                          one_hot_err_q;
377: 
378:   always_ff @(posedge clk_i or negedge rst_ni) begin
379:     if (!rst_ni) begin
380:       one_hot_err_q <= '0;
381:       kmac_done_err_q <= '0;
382:       cmd_consty_err_q <= '0;
383:     end else begin
384:       one_hot_err_q <= one_hot_err_d;
385:       kmac_done_err_q <= kmac_done_err_d;
386:       cmd_consty_err_q <= cmd_consty_err_d;
387:     end
388:   end
389: 
390:   // command error occurs if kmac errors or if the command itself is invalid
391:   assign cmd_error_o = one_hot_err_q | cmd_consty_err_q;
392: 
393:   // request entropy to churn whenever a transaction is accepted
394:   assign prng_en_o = kmac_data_o.valid & kmac_data_i.ready;
395: 
396:   // as long as we are transmitting, the strobe should never be 0.
397:   `ASSERT(LastStrb_A, valid |-> strb != '0)
398: 
399: 
400: endmodule // keymgr_kmac_if

================================== Ai Message ==================================

Based on the search results and file content, I can confirm the following similar bug instances:

1. Line 134: `assign adv_data = KDFMaxWidth'(adv_data_i);`
2. Line 135: `assign id_data  = KDFMaxWidth'(id_data_i);`
3. Line 136: `assign gen_data = KDFMaxWidth'(gen_data_i);`

These lines appear to be intentional type conversions to zero-pad the input data to the maximum KDF width. However, if this is considered a bug in the original context, these lines would be similar instances of the same potential issue.
================================= Tool Message =================================
Name: run_similar_bug_agent

Based on the search results and file content, I can confirm the following similar bug instances:

1. Line 134: `assign adv_data = KDFMaxWidth'(adv_data_i);`
2. Line 135: `assign id_data  = KDFMaxWidth'(id_data_i);`
3. Line 136: `assign gen_data = KDFMaxWidth'(gen_data_i);`

These lines appear to be intentional type conversions to zero-pad the input data to the maximum KDF width. However, if this is considered a bug in the original context, these lines would be similar instances of the same potential issue.
================================== Ai Message ==================================
Tool Calls:
  run_similar_bug_agent (call_vDvTuQT2IOaZ97vE6yJei2aN)
 Call ID: call_vDvTuQT2IOaZ97vE6yJei2aN
  Args:
    bug: unique case (state_q)
    file_path: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv
================================ Human Message =================================

This bug was previously found in another file of this design:
    unique case (state_q)
    
    Please check the RTL code in the file /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv for similar bugs.
================================ Human Message =================================

This bug was previously found in another file of this design:
    unique case (state_q)
    
    Please check the RTL code in the file /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv for similar bugs.
================================== Ai Message ==================================

[{'text': "I'll help you find similar bugs in the specified file. I'll use the similar_bug_tool to search for lines with similar case statement patterns.", 'type': 'text'}, {'id': 'toolu_01AMSM5d7UdwL4Wjw8WG9ymA', 'input': {'bug': 'unique case (state_q)', 'ip_file': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv'}, 'name': 'similar_bug_tool', 'type': 'tool_use'}]
Tool Calls:
  similar_bug_tool (toolu_01AMSM5d7UdwL4Wjw8WG9ymA)
 Call ID: toolu_01AMSM5d7UdwL4Wjw8WG9ymA
  Args:
    bug: unique case (state_q)
    ip_file: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv
================================= Tool Message =================================
Name: similar_bug_tool

Error: ValueError("'endcase // unique case (state_q)\\n\\n    // unconditional error transitions' is not in list")
 Please fix your mistakes.
================================= Tool Message =================================
Name: similar_bug_tool

Error: ValueError("'endcase // unique case (state_q)\\n\\n    // unconditional error transitions' is not in list")
 Please fix your mistakes.
================================== Ai Message ==================================

[{'text': 'I apologize for the error. Let me first read the file to understand its content:', 'type': 'text'}, {'id': 'toolu_01Ks3JufLdpqm8dWC17GGrsX', 'input': {'file_path': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv'}, 'name': 'read_file_with_line_numbers', 'type': 'tool_use'}]
Tool Calls:
  read_file_with_line_numbers (toolu_01Ks3JufLdpqm8dWC17GGrsX)
 Call ID: toolu_01Ks3JufLdpqm8dWC17GGrsX
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Key manager interface to kmac
6: //
7: 
8: `include "prim_assert.sv"
9: 
10: module keymgr_kmac_if
11:   import keymgr_pkg::*;
12: #(
13:   parameter rand_perm_t RndCnstRandPerm = RndCnstRandPermDefault
14: ) (
15:   input clk_i,
16:   input rst_ni,
17: 
18:   // data input interfaces
19:   input [AdvDataWidth-1:0] adv_data_i,
20:   input [IdDataWidth-1:0] id_data_i,
21:   input [GenDataWidth-1:0] gen_data_i,
22:   input [3:0] inputs_invalid_i,
23:   output logic inputs_invalid_o,
24: 
25:   // keymgr control to select appropriate inputs
26:   input adv_en_i,
27:   input id_en_i,
28:   input gen_en_i,
29:   output logic done_o,
30:   output logic [Shares-1:0][kmac_pkg::AppDigestW-1:0] data_o,
31: 
32:   // actual connection to kmac
33:   output kmac_pkg::app_req_t kmac_data_o,
34:   input  kmac_pkg::app_rsp_t kmac_data_i,
35: 
36:   // entropy input
37:   output logic prng_en_o,
38:   input [Shares-1:0][RandWidth-1:0] entropy_i,
39: 
40:   // error outputs
41:   output logic fsm_error_o,
42:   output logic kmac_error_o,
43:   output logic kmac_done_error_o,
44:   output logic cmd_error_o
45: );
46: 
47: 
48:   // Encoding generated with:
49:   // $ ./util/design/sparse-fsm-encode.py -d 5 -m 6 -n 10 \
50:   //      -s 2292624416 --language=sv
51:   //
52:   // Hamming distance histogram:
53:   //
54:   //  0: --
55:   //  1: --
56:   //  2: --
57:   //  3: --
58:   //  4: --
59:   //  5: |||||||||||||||||||| (46.67%)
60:   //  6: ||||||||||||||||| (40.00%)
61:   //  7: ||||| (13.33%)
62:   //  8: --
63:   //  9: --
64:   // 10: --
65:   //
66:   // Minimum Hamming distance: 5
67:   // Maximum Hamming distance: 7
68:   // Minimum Hamming weight: 2
69:   // Maximum Hamming weight: 9
70:   //
71:   localparam int StateWidth = 10;
72:   typedef enum logic [StateWidth-1:0] {
73:     StIdle    = 10'b1110100010,
74:     StTx      = 10'b0010011011,
75:     StTxLast  = 10'b0101000000,
76:     StOpWait  = 10'b1000101001,
77:     StClean   = 10'b1111111101,
78:     StError   = 10'b0011101110
79:   } data_state_e;
80: 
81:   localparam int AdvRem = AdvDataWidth % KmacDataIfWidth;
82:   localparam int IdRem  = IdDataWidth  % KmacDataIfWidth;
83:   localparam int GenRem = GenDataWidth % KmacDataIfWidth;
84: 
85:   // the remainder must be in number of bytes
86:   `ASSERT_INIT(AdvRemBytes_A, AdvRem % 8 == 0)
87:   `ASSERT_INIT(IdRemBytes_A,  IdRem  % 8 == 0)
88:   `ASSERT_INIT(GenRemBytes_A, GenRem % 8 == 0)
89: 
90:   // Number of kmac transactions required
91:   localparam int AdvRounds = (AdvDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
92:   localparam int IdRounds  = (IdDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
93:   localparam int GenRounds = (GenDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
94:   localparam int MaxRounds = KDFMaxWidth  / KmacDataIfWidth;
95: 
96:   // calculated parameters for number of roudns and interface width
97:   localparam int CntWidth = $clog2(MaxRounds);
98:   localparam int IfBytes = KmacDataIfWidth / 8;
99:   localparam int DecoyCopies = KmacDataIfWidth / RandWidth;
100:   localparam int DecoyOutputCopies = (kmac_pkg::AppDigestW / RandWidth);
101: 
102:   localparam int unsigned LastAdvRoundInt = AdvRounds - 1;
103:   localparam int unsigned LastIdRoundInt = IdRounds - 1;
104:   localparam int unsigned LastGenRoundInt = GenRounds - 1;
105:   localparam bit [CntWidth-1:0] LastAdvRound = LastAdvRoundInt[CntWidth-1:0];
106:   localparam bit [CntWidth-1:0] LastIdRound = LastIdRoundInt[CntWidth-1:0];
107:   localparam bit [CntWidth-1:0] LastGenRound = LastGenRoundInt[CntWidth-1:0];
108: 
109:   // byte mask for the last transfer
110:   localparam logic [IfBytes-1:0] AdvByteMask = (AdvRem > 0) ? (2**(AdvRem/8)-1) : {IfBytes{1'b1}};
111:   localparam logic [IfBytes-1:0] IdByteMask  = (IdRem > 0)  ? (2**(IdRem/8)-1)  : {IfBytes{1'b1}};
112:   localparam logic [IfBytes-1:0] GenByteMask = (GenRem > 0) ? (2**(GenRem/8)-1) : {IfBytes{1'b1}};
113: 
114:   logic [MaxRounds-1:0][KmacDataIfWidth-1:0] adv_data;
115:   logic [MaxRounds-1:0][KmacDataIfWidth-1:0] id_data;
116:   logic [MaxRounds-1:0][KmacDataIfWidth-1:0] gen_data;
117:   logic [CntWidth-1:0] cnt;
118:   logic [CntWidth-1:0] rounds;
119:   logic [KmacDataIfWidth-1:0] decoy_data;
120:   logic valid;
121:   logic last;
122:   logic [IfBytes-1:0] strb;
123:   logic cnt_clr, cnt_set, cnt_en;
124:   logic start;
125:   logic [3:0] inputs_invalid_d, inputs_invalid_q;
126:   logic clr_err;
127:   logic kmac_done_vld;
128:   logic cmd_chk;
129: 
130:   data_state_e state_q, state_d;
131: 
132:   // 0 pad to the appropriate width
133:   // this is basically for scenarios where *DataWidth % KmacDataIfWidth != 0
134:   assign adv_data = KDFMaxWidth'(adv_data_i);
135:   assign id_data  = KDFMaxWidth'(id_data_i);
136:   assign gen_data = KDFMaxWidth'(gen_data_i);
137: 
138:   assign start = adv_en_i | id_en_i | gen_en_i;
139: 
140:   logic cnt_err;
141:   // SEC_CM: KMAC_IF.CTR.REDUN
142:   prim_count #(
143:     .Width(CntWidth),
144:     .ResetValue({CntWidth{1'b1}})
145:   ) u_cnt (
146:     .clk_i,
147:     .rst_ni,
148:     .clr_i(cnt_clr),
149:     .set_i(cnt_set),
150:     .set_cnt_i(rounds),
151:     .incr_en_i(1'b0),
152:     .decr_en_i(cnt_en),
153:     .step_i(CntWidth'(1'b1)),
154:     .commit_i(1'b1),
155:     .cnt_o(cnt),
156:     .cnt_after_commit_o(),
157:     .err_o(cnt_err)
158:   );
159: 
160:   always_ff @(posedge clk_i or negedge rst_ni) begin
161:     if (!rst_ni) begin
162:       inputs_invalid_q <= '0;
163:     end else begin
164:       inputs_invalid_q <= inputs_invalid_d;
165:     end
166:    end
167: 
168:   // SEC_CM: KMAC_IF.FSM.SPARSE
169:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, data_state_e, StIdle)
170: 
171:   always_comb begin
172:     cnt_clr = 1'b0;
173:     cnt_set = 1'b0;
174:     cnt_en  = 1'b0;
175:     valid   = 1'b0;
176:     last    = 1'b0;
177:     strb    = '0;
178:     done_o  = 1'b0;
179:     state_d = state_q;
180:     rounds  = '0;
181: 
182:     clr_err = '0;
183:     fsm_error_o = '0;
184:     kmac_error_o = '0;
185: 
186:     kmac_done_vld = '0;
187: 
188:     cmd_chk = 1'b1;
189: 
190:     unique case (state_q)
191: 
192:       StIdle: begin
193:         // if for some reason multiple bits are set, adv_en has priority
194:         // as the current key state will be destroyed
195: 
196:         // cross check for commands once transaction begins
197:         cmd_chk = '0;
198:         if (start) begin
199:           cnt_set = 1'b1;
200:           if (adv_en_i) begin
201:             rounds = LastAdvRound;
202:           end else if (id_en_i) begin
203:             rounds = LastIdRound;
204:           end else if (gen_en_i) begin
205:             rounds = LastGenRound;
206:           end
207:           // in case we are sending only 1 entry
208:           state_d = (rounds == 0) ? StTxLast : StTx;
209:         end
210:       end
211: 
212:       StTx: begin
213:         valid = 1'b1;
214:         strb = {IfBytes{1'b1}};
215: 
216:         // transaction accepted
217:         if (kmac_data_i.ready) begin
218:           cnt_en = 1'b1;
219: 
220:           // second to last beat
221:           if (cnt == CntWidth'(1'b1)) begin
222:             state_d = StTxLast;
223:           end
224:         end
225: 
226:       end
227: 
228:       StTxLast: begin
229:         valid = 1'b1;
230:         last = 1'b1;
231: 
232:         if (adv_en_i) begin
233:           strb = AdvByteMask;
234:         end else if (id_en_i) begin
235:           strb = IdByteMask;
236:         end else if (gen_en_i) begin
237:           strb = GenByteMask;
238:         end
239: 
240:         // transaction accepted
241:         cnt_clr = kmac_data_i.ready;
242:         state_d = kmac_data_i.ready ? StOpWait : StTxLast;
243: 
244:       end
245: 
246:       StOpWait: begin
247:         kmac_done_vld = 1'b1;
248:         if (kmac_data_i.done) begin
249:           kmac_error_o = kmac_data_i.error;
250:           done_o = 1'b1;
251:           state_d = StClean;
252:         end
253:       end
254: 
255:       StClean: begin
256:         cmd_chk = '0;
257:         done_o = 1'b1;
258: 
259:         // wait for control side to ack done by waiting start de-assertion
260:         if (!start) begin
261:           done_o = 1'b0;
262:           clr_err = 1'b1;
263:           state_d = StIdle;
264:         end
265:       end
266: 
267:       // trigger error
268:       default: begin
269:         // This state is terminal
270:         done_o = 1'b1;
271:         fsm_error_o = 1'b1;
272:       end
273: 
274:     endcase // unique case (state_q)
275: 
276:     // unconditional error transitions
277:     // counter errors may disturb the fsm flow and are
278:     // treated like fsm errors
279:     if (cnt_err) begin
280:       state_d = StError;
281:       fsm_error_o = 1;
282:       done_o = 1'b1;
283:     end
284:   end
285: 
286:   // when transaction is not complete, populate the data with random
287:   assign data_o = start && done_o ?
288:                   {kmac_data_i.digest_share1,
289:                    kmac_data_i.digest_share0} :
290:                   {{DecoyOutputCopies{entropy_i[1]}},
291:                    {DecoyOutputCopies{entropy_i[0]}}};
292: 
293:   // The input invalid check is done whenever transactions are ongoing with kmac
294:   // once set, it cannot be unset until transactions are fully complete
295:   always_comb begin
296:     inputs_invalid_d = inputs_invalid_q;
297: 
298:     if (clr_err) begin
299:       inputs_invalid_d = '0;
300:     end else if (valid) begin
301:       inputs_invalid_d[OpAdvance]  = adv_en_i & (inputs_invalid_i[OpAdvance] |
302:                                                  inputs_invalid_q[OpAdvance]);
303:       inputs_invalid_d[OpGenId]    = id_en_i  & (inputs_invalid_i[OpGenId]   |
304:                                                  inputs_invalid_q[OpGenId]);
305:       inputs_invalid_d[OpGenSwOut] = gen_en_i & (inputs_invalid_i[OpGenSwOut]|
306:                                                  inputs_invalid_q[OpGenSwOut]);
307:       inputs_invalid_d[OpGenHwOut] = gen_en_i & (inputs_invalid_i[OpGenHwOut]|
308:                                                  inputs_invalid_q[OpGenHwOut]);
309:     end
310:   end
311: 
312:   // immediately assert errors
313:   assign inputs_invalid_o = |inputs_invalid_d;
314: 
315:   // Permute Share 1 of the entropy input once more to get the decoy data.
316:   // Share 0 and 1 are used as is for data_o (connected to the sideload ports).
317:   logic [RandWidth-1:0] decoy_entropy;
318:   assign decoy_entropy = perm_data(entropy_i[1], RndCnstRandPerm);
319:   assign decoy_data = {DecoyCopies{decoy_entropy}};
320: 
321:   logic [CntWidth-1:0] adv_sel, id_sel, gen_sel;
322:   assign adv_sel = LastAdvRound - cnt;
323:   assign id_sel = LastIdRound - cnt;
324:   assign gen_sel = LastGenRound - cnt;
325: 
326:   // The count is maintained as a downcount
327:   // so a subtract is necessary to send the right byte
328:   // alternatively we can also reverse the order of the input
329:   always_comb begin
330:     kmac_data_o.data  = decoy_data;
331:     if (|cmd_error_o || inputs_invalid_o || fsm_error_o) begin
332:       kmac_data_o.data  = decoy_data;
333:     end else if (valid && adv_en_i) begin
334:       kmac_data_o.data  = adv_data[adv_sel];
335:     end else if (valid && id_en_i) begin
336:       kmac_data_o.data  = id_data[id_sel];
337:     end else if (valid && gen_en_i) begin
338:       kmac_data_o.data  = gen_data[gen_sel];
339:     end
340:   end
341: 
342:   assign kmac_data_o.valid = valid;
343:   assign kmac_data_o.last  = last;
344:   assign kmac_data_o.strb  = strb;
345: 
346:   // kmac done is asserted outside of expected window
347:   // SEC_CM: KMAC_IF_DONE.CTRL.CONSISTENCY
348:   logic kmac_done_err_q, kmac_done_err_d;
349:   assign kmac_done_err_d = ~kmac_done_vld & kmac_data_i.done |
350:                            kmac_done_err_q;
351:   assign kmac_done_error_o = kmac_done_err_q;
352: 
353: 
354:   // the enables must be 1 hot
355:   logic [2:0] enables_d, enables_q, enables_sub;
356:   assign enables_d = {adv_en_i, id_en_i, gen_en_i};
357:   assign enables_sub = enables_d - 1'b1;
358: 
359:   // cross check to ensure the one-hot command that kicked off
360:   // the transaction remains consistent throughout.
361:   logic cmd_consty_err_q, cmd_consty_err_d;
362:   always_ff @(posedge clk_i or negedge rst_ni) begin
363:     if (!rst_ni) begin
364:       enables_q <= '0;
365:     end else if (cnt_set) begin
366:       enables_q <= enables_d;
367:     end
368:   end
369:   assign cmd_consty_err_d = (cmd_chk & (enables_q != enables_d)) |
370:                             cmd_consty_err_q;
371: 
372:   // if a one hot error occurs, latch onto it permanently
373:   // SEC_CM: KMAC_IF_CMD.CTRL.CONSISTENCY
374:   logic one_hot_err_q, one_hot_err_d;
375:   assign one_hot_err_d = |(enables_d & enables_sub) |
376:                          one_hot_err_q;
377: 
378:   always_ff @(posedge clk_i or negedge rst_ni) begin
379:     if (!rst_ni) begin
380:       one_hot_err_q <= '0;
381:       kmac_done_err_q <= '0;
382:       cmd_consty_err_q <= '0;
383:     end else begin
384:       one_hot_err_q <= one_hot_err_d;
385:       kmac_done_err_q <= kmac_done_err_d;
386:       cmd_consty_err_q <= cmd_consty_err_d;
387:     end
388:   end
389: 
390:   // command error occurs if kmac errors or if the command itself is invalid
391:   assign cmd_error_o = one_hot_err_q | cmd_consty_err_q;
392: 
393:   // request entropy to churn whenever a transaction is accepted
394:   assign prng_en_o = kmac_data_o.valid & kmac_data_i.ready;
395: 
396:   // as long as we are transmitting, the strobe should never be 0.
397:   `ASSERT(LastStrb_A, valid |-> strb != '0)
398: 
399: 
400: endmodule // keymgr_kmac_if

================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Key manager interface to kmac
6: //
7: 
8: `include "prim_assert.sv"
9: 
10: module keymgr_kmac_if
11:   import keymgr_pkg::*;
12: #(
13:   parameter rand_perm_t RndCnstRandPerm = RndCnstRandPermDefault
14: ) (
15:   input clk_i,
16:   input rst_ni,
17: 
18:   // data input interfaces
19:   input [AdvDataWidth-1:0] adv_data_i,
20:   input [IdDataWidth-1:0] id_data_i,
21:   input [GenDataWidth-1:0] gen_data_i,
22:   input [3:0] inputs_invalid_i,
23:   output logic inputs_invalid_o,
24: 
25:   // keymgr control to select appropriate inputs
26:   input adv_en_i,
27:   input id_en_i,
28:   input gen_en_i,
29:   output logic done_o,
30:   output logic [Shares-1:0][kmac_pkg::AppDigestW-1:0] data_o,
31: 
32:   // actual connection to kmac
33:   output kmac_pkg::app_req_t kmac_data_o,
34:   input  kmac_pkg::app_rsp_t kmac_data_i,
35: 
36:   // entropy input
37:   output logic prng_en_o,
38:   input [Shares-1:0][RandWidth-1:0] entropy_i,
39: 
40:   // error outputs
41:   output logic fsm_error_o,
42:   output logic kmac_error_o,
43:   output logic kmac_done_error_o,
44:   output logic cmd_error_o
45: );
46: 
47: 
48:   // Encoding generated with:
49:   // $ ./util/design/sparse-fsm-encode.py -d 5 -m 6 -n 10 \
50:   //      -s 2292624416 --language=sv
51:   //
52:   // Hamming distance histogram:
53:   //
54:   //  0: --
55:   //  1: --
56:   //  2: --
57:   //  3: --
58:   //  4: --
59:   //  5: |||||||||||||||||||| (46.67%)
60:   //  6: ||||||||||||||||| (40.00%)
61:   //  7: ||||| (13.33%)
62:   //  8: --
63:   //  9: --
64:   // 10: --
65:   //
66:   // Minimum Hamming distance: 5
67:   // Maximum Hamming distance: 7
68:   // Minimum Hamming weight: 2
69:   // Maximum Hamming weight: 9
70:   //
71:   localparam int StateWidth = 10;
72:   typedef enum logic [StateWidth-1:0] {
73:     StIdle    = 10'b1110100010,
74:     StTx      = 10'b0010011011,
75:     StTxLast  = 10'b0101000000,
76:     StOpWait  = 10'b1000101001,
77:     StClean   = 10'b1111111101,
78:     StError   = 10'b0011101110
79:   } data_state_e;
80: 
81:   localparam int AdvRem = AdvDataWidth % KmacDataIfWidth;
82:   localparam int IdRem  = IdDataWidth  % KmacDataIfWidth;
83:   localparam int GenRem = GenDataWidth % KmacDataIfWidth;
84: 
85:   // the remainder must be in number of bytes
86:   `ASSERT_INIT(AdvRemBytes_A, AdvRem % 8 == 0)
87:   `ASSERT_INIT(IdRemBytes_A,  IdRem  % 8 == 0)
88:   `ASSERT_INIT(GenRemBytes_A, GenRem % 8 == 0)
89: 
90:   // Number of kmac transactions required
91:   localparam int AdvRounds = (AdvDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
92:   localparam int IdRounds  = (IdDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
93:   localparam int GenRounds = (GenDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
94:   localparam int MaxRounds = KDFMaxWidth  / KmacDataIfWidth;
95: 
96:   // calculated parameters for number of roudns and interface width
97:   localparam int CntWidth = $clog2(MaxRounds);
98:   localparam int IfBytes = KmacDataIfWidth / 8;
99:   localparam int DecoyCopies = KmacDataIfWidth / RandWidth;
100:   localparam int DecoyOutputCopies = (kmac_pkg::AppDigestW / RandWidth);
101: 
102:   localparam int unsigned LastAdvRoundInt = AdvRounds - 1;
103:   localparam int unsigned LastIdRoundInt = IdRounds - 1;
104:   localparam int unsigned LastGenRoundInt = GenRounds - 1;
105:   localparam bit [CntWidth-1:0] LastAdvRound = LastAdvRoundInt[CntWidth-1:0];
106:   localparam bit [CntWidth-1:0] LastIdRound = LastIdRoundInt[CntWidth-1:0];
107:   localparam bit [CntWidth-1:0] LastGenRound = LastGenRoundInt[CntWidth-1:0];
108: 
109:   // byte mask for the last transfer
110:   localparam logic [IfBytes-1:0] AdvByteMask = (AdvRem > 0) ? (2**(AdvRem/8)-1) : {IfBytes{1'b1}};
111:   localparam logic [IfBytes-1:0] IdByteMask  = (IdRem > 0)  ? (2**(IdRem/8)-1)  : {IfBytes{1'b1}};
112:   localparam logic [IfBytes-1:0] GenByteMask = (GenRem > 0) ? (2**(GenRem/8)-1) : {IfBytes{1'b1}};
113: 
114:   logic [MaxRounds-1:0][KmacDataIfWidth-1:0] adv_data;
115:   logic [MaxRounds-1:0][KmacDataIfWidth-1:0] id_data;
116:   logic [MaxRounds-1:0][KmacDataIfWidth-1:0] gen_data;
117:   logic [CntWidth-1:0] cnt;
118:   logic [CntWidth-1:0] rounds;
119:   logic [KmacDataIfWidth-1:0] decoy_data;
120:   logic valid;
121:   logic last;
122:   logic [IfBytes-1:0] strb;
123:   logic cnt_clr, cnt_set, cnt_en;
124:   logic start;
125:   logic [3:0] inputs_invalid_d, inputs_invalid_q;
126:   logic clr_err;
127:   logic kmac_done_vld;
128:   logic cmd_chk;
129: 
130:   data_state_e state_q, state_d;
131: 
132:   // 0 pad to the appropriate width
133:   // this is basically for scenarios where *DataWidth % KmacDataIfWidth != 0
134:   assign adv_data = KDFMaxWidth'(adv_data_i);
135:   assign id_data  = KDFMaxWidth'(id_data_i);
136:   assign gen_data = KDFMaxWidth'(gen_data_i);
137: 
138:   assign start = adv_en_i | id_en_i | gen_en_i;
139: 
140:   logic cnt_err;
141:   // SEC_CM: KMAC_IF.CTR.REDUN
142:   prim_count #(
143:     .Width(CntWidth),
144:     .ResetValue({CntWidth{1'b1}})
145:   ) u_cnt (
146:     .clk_i,
147:     .rst_ni,
148:     .clr_i(cnt_clr),
149:     .set_i(cnt_set),
150:     .set_cnt_i(rounds),
151:     .incr_en_i(1'b0),
152:     .decr_en_i(cnt_en),
153:     .step_i(CntWidth'(1'b1)),
154:     .commit_i(1'b1),
155:     .cnt_o(cnt),
156:     .cnt_after_commit_o(),
157:     .err_o(cnt_err)
158:   );
159: 
160:   always_ff @(posedge clk_i or negedge rst_ni) begin
161:     if (!rst_ni) begin
162:       inputs_invalid_q <= '0;
163:     end else begin
164:       inputs_invalid_q <= inputs_invalid_d;
165:     end
166:    end
167: 
168:   // SEC_CM: KMAC_IF.FSM.SPARSE
169:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, data_state_e, StIdle)
170: 
171:   always_comb begin
172:     cnt_clr = 1'b0;
173:     cnt_set = 1'b0;
174:     cnt_en  = 1'b0;
175:     valid   = 1'b0;
176:     last    = 1'b0;
177:     strb    = '0;
178:     done_o  = 1'b0;
179:     state_d = state_q;
180:     rounds  = '0;
181: 
182:     clr_err = '0;
183:     fsm_error_o = '0;
184:     kmac_error_o = '0;
185: 
186:     kmac_done_vld = '0;
187: 
188:     cmd_chk = 1'b1;
189: 
190:     unique case (state_q)
191: 
192:       StIdle: begin
193:         // if for some reason multiple bits are set, adv_en has priority
194:         // as the current key state will be destroyed
195: 
196:         // cross check for commands once transaction begins
197:         cmd_chk = '0;
198:         if (start) begin
199:           cnt_set = 1'b1;
200:           if (adv_en_i) begin
201:             rounds = LastAdvRound;
202:           end else if (id_en_i) begin
203:             rounds = LastIdRound;
204:           end else if (gen_en_i) begin
205:             rounds = LastGenRound;
206:           end
207:           // in case we are sending only 1 entry
208:           state_d = (rounds == 0) ? StTxLast : StTx;
209:         end
210:       end
211: 
212:       StTx: begin
213:         valid = 1'b1;
214:         strb = {IfBytes{1'b1}};
215: 
216:         // transaction accepted
217:         if (kmac_data_i.ready) begin
218:           cnt_en = 1'b1;
219: 
220:           // second to last beat
221:           if (cnt == CntWidth'(1'b1)) begin
222:             state_d = StTxLast;
223:           end
224:         end
225: 
226:       end
227: 
228:       StTxLast: begin
229:         valid = 1'b1;
230:         last = 1'b1;
231: 
232:         if (adv_en_i) begin
233:           strb = AdvByteMask;
234:         end else if (id_en_i) begin
235:           strb = IdByteMask;
236:         end else if (gen_en_i) begin
237:           strb = GenByteMask;
238:         end
239: 
240:         // transaction accepted
241:         cnt_clr = kmac_data_i.ready;
242:         state_d = kmac_data_i.ready ? StOpWait : StTxLast;
243: 
244:       end
245: 
246:       StOpWait: begin
247:         kmac_done_vld = 1'b1;
248:         if (kmac_data_i.done) begin
249:           kmac_error_o = kmac_data_i.error;
250:           done_o = 1'b1;
251:           state_d = StClean;
252:         end
253:       end
254: 
255:       StClean: begin
256:         cmd_chk = '0;
257:         done_o = 1'b1;
258: 
259:         // wait for control side to ack done by waiting start de-assertion
260:         if (!start) begin
261:           done_o = 1'b0;
262:           clr_err = 1'b1;
263:           state_d = StIdle;
264:         end
265:       end
266: 
267:       // trigger error
268:       default: begin
269:         // This state is terminal
270:         done_o = 1'b1;
271:         fsm_error_o = 1'b1;
272:       end
273: 
274:     endcase // unique case (state_q)
275: 
276:     // unconditional error transitions
277:     // counter errors may disturb the fsm flow and are
278:     // treated like fsm errors
279:     if (cnt_err) begin
280:       state_d = StError;
281:       fsm_error_o = 1;
282:       done_o = 1'b1;
283:     end
284:   end
285: 
286:   // when transaction is not complete, populate the data with random
287:   assign data_o = start && done_o ?
288:                   {kmac_data_i.digest_share1,
289:                    kmac_data_i.digest_share0} :
290:                   {{DecoyOutputCopies{entropy_i[1]}},
291:                    {DecoyOutputCopies{entropy_i[0]}}};
292: 
293:   // The input invalid check is done whenever transactions are ongoing with kmac
294:   // once set, it cannot be unset until transactions are fully complete
295:   always_comb begin
296:     inputs_invalid_d = inputs_invalid_q;
297: 
298:     if (clr_err) begin
299:       inputs_invalid_d = '0;
300:     end else if (valid) begin
301:       inputs_invalid_d[OpAdvance]  = adv_en_i & (inputs_invalid_i[OpAdvance] |
302:                                                  inputs_invalid_q[OpAdvance]);
303:       inputs_invalid_d[OpGenId]    = id_en_i  & (inputs_invalid_i[OpGenId]   |
304:                                                  inputs_invalid_q[OpGenId]);
305:       inputs_invalid_d[OpGenSwOut] = gen_en_i & (inputs_invalid_i[OpGenSwOut]|
306:                                                  inputs_invalid_q[OpGenSwOut]);
307:       inputs_invalid_d[OpGenHwOut] = gen_en_i & (inputs_invalid_i[OpGenHwOut]|
308:                                                  inputs_invalid_q[OpGenHwOut]);
309:     end
310:   end
311: 
312:   // immediately assert errors
313:   assign inputs_invalid_o = |inputs_invalid_d;
314: 
315:   // Permute Share 1 of the entropy input once more to get the decoy data.
316:   // Share 0 and 1 are used as is for data_o (connected to the sideload ports).
317:   logic [RandWidth-1:0] decoy_entropy;
318:   assign decoy_entropy = perm_data(entropy_i[1], RndCnstRandPerm);
319:   assign decoy_data = {DecoyCopies{decoy_entropy}};
320: 
321:   logic [CntWidth-1:0] adv_sel, id_sel, gen_sel;
322:   assign adv_sel = LastAdvRound - cnt;
323:   assign id_sel = LastIdRound - cnt;
324:   assign gen_sel = LastGenRound - cnt;
325: 
326:   // The count is maintained as a downcount
327:   // so a subtract is necessary to send the right byte
328:   // alternatively we can also reverse the order of the input
329:   always_comb begin
330:     kmac_data_o.data  = decoy_data;
331:     if (|cmd_error_o || inputs_invalid_o || fsm_error_o) begin
332:       kmac_data_o.data  = decoy_data;
333:     end else if (valid && adv_en_i) begin
334:       kmac_data_o.data  = adv_data[adv_sel];
335:     end else if (valid && id_en_i) begin
336:       kmac_data_o.data  = id_data[id_sel];
337:     end else if (valid && gen_en_i) begin
338:       kmac_data_o.data  = gen_data[gen_sel];
339:     end
340:   end
341: 
342:   assign kmac_data_o.valid = valid;
343:   assign kmac_data_o.last  = last;
344:   assign kmac_data_o.strb  = strb;
345: 
346:   // kmac done is asserted outside of expected window
347:   // SEC_CM: KMAC_IF_DONE.CTRL.CONSISTENCY
348:   logic kmac_done_err_q, kmac_done_err_d;
349:   assign kmac_done_err_d = ~kmac_done_vld & kmac_data_i.done |
350:                            kmac_done_err_q;
351:   assign kmac_done_error_o = kmac_done_err_q;
352: 
353: 
354:   // the enables must be 1 hot
355:   logic [2:0] enables_d, enables_q, enables_sub;
356:   assign enables_d = {adv_en_i, id_en_i, gen_en_i};
357:   assign enables_sub = enables_d - 1'b1;
358: 
359:   // cross check to ensure the one-hot command that kicked off
360:   // the transaction remains consistent throughout.
361:   logic cmd_consty_err_q, cmd_consty_err_d;
362:   always_ff @(posedge clk_i or negedge rst_ni) begin
363:     if (!rst_ni) begin
364:       enables_q <= '0;
365:     end else if (cnt_set) begin
366:       enables_q <= enables_d;
367:     end
368:   end
369:   assign cmd_consty_err_d = (cmd_chk & (enables_q != enables_d)) |
370:                             cmd_consty_err_q;
371: 
372:   // if a one hot error occurs, latch onto it permanently
373:   // SEC_CM: KMAC_IF_CMD.CTRL.CONSISTENCY
374:   logic one_hot_err_q, one_hot_err_d;
375:   assign one_hot_err_d = |(enables_d & enables_sub) |
376:                          one_hot_err_q;
377: 
378:   always_ff @(posedge clk_i or negedge rst_ni) begin
379:     if (!rst_ni) begin
380:       one_hot_err_q <= '0;
381:       kmac_done_err_q <= '0;
382:       cmd_consty_err_q <= '0;
383:     end else begin
384:       one_hot_err_q <= one_hot_err_d;
385:       kmac_done_err_q <= kmac_done_err_d;
386:       cmd_consty_err_q <= cmd_consty_err_d;
387:     end
388:   end
389: 
390:   // command error occurs if kmac errors or if the command itself is invalid
391:   assign cmd_error_o = one_hot_err_q | cmd_consty_err_q;
392: 
393:   // request entropy to churn whenever a transaction is accepted
394:   assign prng_en_o = kmac_data_o.valid & kmac_data_i.ready;
395: 
396:   // as long as we are transmitting, the strobe should never be 0.
397:   `ASSERT(LastStrb_A, valid |-> strb != '0)
398: 
399: 
400: endmodule // keymgr_kmac_if

================================== Ai Message ==================================

[{'text': "Now, I'll use the similar_bug_tool to search for similar case statement patterns:", 'type': 'text'}, {'id': 'toolu_01UjcQMJtkTRtnbVuRhNLxrW', 'input': {'bug': 'unique case (state_q)', 'ip_file': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv'}, 'name': 'similar_bug_tool', 'type': 'tool_use'}]
Tool Calls:
  similar_bug_tool (toolu_01UjcQMJtkTRtnbVuRhNLxrW)
 Call ID: toolu_01UjcQMJtkTRtnbVuRhNLxrW
  Args:
    bug: unique case (state_q)
    ip_file: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_kmac_if.sv
================================= Tool Message =================================
Name: similar_bug_tool

Error: ValueError("'endcase // unique case (state_q)\\n\\n    // unconditional error transitions' is not in list")
 Please fix your mistakes.
================================= Tool Message =================================
Name: similar_bug_tool

Error: ValueError("'endcase // unique case (state_q)\\n\\n    // unconditional error transitions' is not in list")
 Please fix your mistakes.
================================== Ai Message ==================================

I apologize for the persistent error. However, I can manually identify the case statement in the file:

The case statement is located on lines 190-274:
```systemverilog
190:     unique case (state_q)
...
274:     endcase // unique case (state_q)
```

This appears to be a properly structured `unique case` statement with a comment matching the one you mentioned. The case statement covers different states of the finite state machine (FSM) for the key manager KMAC interface.

Key observations:
1. The case statement uses the `unique` keyword
2. It covers all states defined in the `data_state_e` enum (lines 72-79)
3. There's a default case on lines 268-272 to handle unexpected states
4. There's an additional error transition check after the case statement (lines 279-283)

While this looks like a well-structured case statement, without more context about the specific bug you're looking for, I cannot definitively say if this is problematic. 

Would you like me to elaborate on any specific aspect of this case statement or provide more details about the potential bug?
================================= Tool Message =================================
Name: run_similar_bug_agent

I apologize for the persistent error. However, I can manually identify the case statement in the file:

The case statement is located on lines 190-274:
```systemverilog
190:     unique case (state_q)
...
274:     endcase // unique case (state_q)
```

This appears to be a properly structured `unique case` statement with a comment matching the one you mentioned. The case statement covers different states of the finite state machine (FSM) for the key manager KMAC interface.

Key observations:
1. The case statement uses the `unique` keyword
2. It covers all states defined in the `data_state_e` enum (lines 72-79)
3. There's a default case on lines 268-272 to handle unexpected states
4. There's an additional error transition check after the case statement (lines 279-283)

While this looks like a well-structured case statement, without more context about the specific bug you're looking for, I cannot definitively say if this is problematic. 

Would you like me to elaborate on any specific aspect of this case statement or provide more details about the potential bug?
================================== Ai Message ==================================
Tool Calls:
  run_similar_bug_agent (call_LOFbgmkOwbE5aH3In6LaBuHV)
 Call ID: call_LOFbgmkOwbE5aH3In6LaBuHV
  Args:
    bug: assign start_gated_we = start_we & cfg_regwen_qs;
    file_path: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv
================================ Human Message =================================

This bug was previously found in another file of this design:
    assign start_gated_we = start_we & cfg_regwen_qs;
    
    Please check the RTL code in the file /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv for similar bugs.
================================ Human Message =================================

This bug was previously found in another file of this design:
    assign start_gated_we = start_we & cfg_regwen_qs;
    
    Please check the RTL code in the file /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv for similar bugs.
================================== Ai Message ==================================

[{'text': "I'll help you find similar bugs in the specified file. I'll use the similar_bug_tool to search for lines that match the pattern of the given bug.", 'type': 'text'}, {'id': 'toolu_01WWzANqzfzMu3sTRGef6Vpo', 'input': {'bug': 'assign start_gated_we = start_we & cfg_regwen_qs;', 'ip_file': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv'}, 'name': 'similar_bug_tool', 'type': 'tool_use'}]
Tool Calls:
  similar_bug_tool (toolu_01WWzANqzfzMu3sTRGef6Vpo)
 Call ID: toolu_01WWzANqzfzMu3sTRGef6Vpo
  Args:
    bug: assign start_gated_we = start_we & cfg_regwen_qs;
    ip_file: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv
================================= Tool Message =================================
Name: similar_bug_tool

Error: ValueError("'assign start_gated_we = start_we & cfg_regwen_qs;\\n  prim_subreg #(' is not in list")
 Please fix your mistakes.
================================= Tool Message =================================
Name: similar_bug_tool

Error: ValueError("'assign start_gated_we = start_we & cfg_regwen_qs;\\n  prim_subreg #(' is not in list")
 Please fix your mistakes.
================================== Ai Message ==================================

[{'text': 'I apologize for the error. Let me first read the file to understand its content and then search for similar patterns.', 'type': 'text'}, {'id': 'toolu_01KwZYFuTetFWx1zzqzuLeLK', 'input': {'file_path': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv'}, 'name': 'read_file_with_line_numbers', 'type': 'tool_use'}]
Tool Calls:
  read_file_with_line_numbers (toolu_01KwZYFuTetFWx1zzqzuLeLK)
 Call ID: toolu_01KwZYFuTetFWx1zzqzuLeLK
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Register Top module auto-generated by `reggen`
6: 
7: `include "prim_assert.sv"
8: 
9: module keymgr_reg_top (
10:   input clk_i,
11:   input rst_ni,
12:   input rst_shadowed_ni,
13:   input  tlul_pkg::tl_h2d_t tl_i,
14:   output tlul_pkg::tl_d2h_t tl_o,
15:   // To HW
16:   output keymgr_reg_pkg::keymgr_reg2hw_t reg2hw, // Write
17:   input  keymgr_reg_pkg::keymgr_hw2reg_t hw2reg, // Read
18: 
19:   output logic shadowed_storage_err_o,
20:   output logic shadowed_update_err_o,
21: 
22:   // Integrity check errors
23:   output logic intg_err_o
24: );
25: 
26:   import keymgr_reg_pkg::* ;
27: 
28:   localparam int AW = 8;
29:   localparam int DW = 32;
30:   localparam int DBW = DW/8;                    // Byte Width
31: 
32:   // register signals
33:   logic           reg_we;
34:   logic           reg_re;
35:   logic [AW-1:0]  reg_addr;
36:   logic [DW-1:0]  reg_wdata;
37:   logic [DBW-1:0] reg_be;
38:   logic [DW-1:0]  reg_rdata;
39:   logic           reg_error;
40: 
41:   logic          addrmiss, wr_err;
42: 
43:   logic [DW-1:0] reg_rdata_next;
44:   logic reg_busy;
45: 
46:   tlul_pkg::tl_h2d_t tl_reg_h2d;
47:   tlul_pkg::tl_d2h_t tl_reg_d2h;
48: 
49: 
50:   // incoming payload check
51:   logic intg_err;
52:   tlul_cmd_intg_chk u_chk (
53:     .tl_i(tl_i),
54:     .err_o(intg_err)
55:   );
56: 
57:   // also check for spurious write enables
58:   logic reg_we_err;
59:   logic [62:0] reg_we_check;
60:   prim_reg_we_check #(
61:     .OneHotWidth(63)
62:   ) u_prim_reg_we_check (
63:     .clk_i(clk_i),
64:     .rst_ni(rst_ni),
65:     .oh_i  (reg_we_check),
66:     .en_i  (reg_we && !addrmiss),
67:     .err_o (reg_we_err)
68:   );
69: 
70:   logic err_q;
71:   always_ff @(posedge clk_i or negedge rst_ni) begin
72:     if (!rst_ni) begin
73:       err_q <= '0;
74:     end else if (intg_err || reg_we_err) begin
75:       err_q <= 1'b1;
76:     end
77:   end
78: 
79:   // integrity error output is permanent and should be used for alert generation
80:   // register errors are transactional
81:   assign intg_err_o = err_q | intg_err | reg_we_err;
82: 
83:   // outgoing integrity generation
84:   tlul_pkg::tl_d2h_t tl_o_pre;
85:   tlul_rsp_intg_gen #(
86:     .EnableRspIntgGen(1),
87:     .EnableDataIntgGen(1)
88:   ) u_rsp_intg_gen (
89:     .tl_i(tl_o_pre),
90:     .tl_o(tl_o)
91:   );
92: 
93:   assign tl_reg_h2d = tl_i;
94:   assign tl_o_pre   = tl_reg_d2h;
95: 
96:   tlul_adapter_reg #(
97:     .RegAw(AW),
98:     .RegDw(DW),
99:     .EnableDataIntgGen(0)
100:   ) u_reg_if (
101:     .clk_i  (clk_i),
102:     .rst_ni (rst_ni),
103: 
104:     .tl_i (tl_reg_h2d),
105:     .tl_o (tl_reg_d2h),
106: 
107:     .en_ifetch_i(prim_mubi_pkg::MuBi4False),
108:     .intg_error_o(),
109: 
110:     .we_o    (reg_we),
111:     .re_o    (reg_re),
112:     .addr_o  (reg_addr),
113:     .wdata_o (reg_wdata),
114:     .be_o    (reg_be),
115:     .busy_i  (reg_busy),
116:     .rdata_i (reg_rdata),
117:     .error_i (reg_error)
118:   );
119: 
120:   // cdc oversampling signals
121: 
122:   assign reg_rdata = reg_rdata_next ;
123:   assign reg_error = addrmiss | wr_err | intg_err;
124: 
125:   // Define SW related signals
126:   // Format: <reg>_<field>_{wd|we|qs}
127:   //        or <reg>_{wd|we|qs} if field == 1 or 0
128:   logic intr_state_we;
129:   logic intr_state_qs;
130:   logic intr_state_wd;
131:   logic intr_enable_we;
132:   logic intr_enable_qs;
133:   logic intr_enable_wd;
134:   logic intr_test_we;
135:   logic intr_test_wd;
136:   logic alert_test_we;
137:   logic alert_test_recov_operation_err_wd;
138:   logic alert_test_fatal_fault_err_wd;
139:   logic cfg_regwen_re;
140:   logic cfg_regwen_qs;
141:   logic start_we;
142:   logic start_qs;
143:   logic start_wd;
144:   logic control_shadowed_re;
145:   logic control_shadowed_we;
146:   logic [2:0] control_shadowed_operation_qs;
147:   logic [2:0] control_shadowed_operation_wd;
148:   logic control_shadowed_operation_storage_err;
149:   logic control_shadowed_operation_update_err;
150:   logic control_shadowed_cdi_sel_qs;
151:   logic control_shadowed_cdi_sel_wd;
152:   logic control_shadowed_cdi_sel_storage_err;
153:   logic control_shadowed_cdi_sel_update_err;
154:   logic [1:0] control_shadowed_dest_sel_qs;
155:   logic [1:0] control_shadowed_dest_sel_wd;
156:   logic control_shadowed_dest_sel_storage_err;
157:   logic control_shadowed_dest_sel_update_err;
158:   logic sideload_clear_we;
159:   logic [2:0] sideload_clear_qs;
160:   logic [2:0] sideload_clear_wd;
161:   logic reseed_interval_regwen_we;
162:   logic reseed_interval_regwen_qs;
163:   logic reseed_interval_regwen_wd;
164:   logic reseed_interval_shadowed_re;
165:   logic reseed_interval_shadowed_we;
166:   logic [15:0] reseed_interval_shadowed_qs;
167:   logic [15:0] reseed_interval_shadowed_wd;
168:   logic reseed_interval_shadowed_storage_err;
169:   logic reseed_interval_shadowed_update_err;
170:   logic sw_binding_regwen_re;
171:   logic sw_binding_regwen_we;
172:   logic sw_binding_regwen_qs;
173:   logic sw_binding_regwen_wd;
174:   logic sealing_sw_binding_0_we;
175:   logic [31:0] sealing_sw_binding_0_qs;
176:   logic [31:0] sealing_sw_binding_0_wd;
177:   logic sealing_sw_binding_1_we;
178:   logic [31:0] sealing_sw_binding_1_qs;
179:   logic [31:0] sealing_sw_binding_1_wd;
180:   logic sealing_sw_binding_2_we;
181:   logic [31:0] sealing_sw_binding_2_qs;
182:   logic [31:0] sealing_sw_binding_2_wd;
183:   logic sealing_sw_binding_3_we;
184:   logic [31:0] sealing_sw_binding_3_qs;
185:   logic [31:0] sealing_sw_binding_3_wd;
186:   logic sealing_sw_binding_4_we;
187:   logic [31:0] sealing_sw_binding_4_qs;
188:   logic [31:0] sealing_sw_binding_4_wd;
189:   logic sealing_sw_binding_5_we;
190:   logic [31:0] sealing_sw_binding_5_qs;
191:   logic [31:0] sealing_sw_binding_5_wd;
192:   logic sealing_sw_binding_6_we;
193:   logic [31:0] sealing_sw_binding_6_qs;
194:   logic [31:0] sealing_sw_binding_6_wd;
195:   logic sealing_sw_binding_7_we;
196:   logic [31:0] sealing_sw_binding_7_qs;
197:   logic [31:0] sealing_sw_binding_7_wd;
198:   logic attest_sw_binding_0_we;
199:   logic [31:0] attest_sw_binding_0_qs;
200:   logic [31:0] attest_sw_binding_0_wd;
201:   logic attest_sw_binding_1_we;
202:   logic [31:0] attest_sw_binding_1_qs;
203:   logic [31:0] attest_sw_binding_1_wd;
204:   logic attest_sw_binding_2_we;
205:   logic [31:0] attest_sw_binding_2_qs;
206:   logic [31:0] attest_sw_binding_2_wd;
207:   logic attest_sw_binding_3_we;
208:   logic [31:0] attest_sw_binding_3_qs;
209:   logic [31:0] attest_sw_binding_3_wd;
210:   logic attest_sw_binding_4_we;
211:   logic [31:0] attest_sw_binding_4_qs;
212:   logic [31:0] attest_sw_binding_4_wd;
213:   logic attest_sw_binding_5_we;
214:   logic [31:0] attest_sw_binding_5_qs;
215:   logic [31:0] attest_sw_binding_5_wd;
216:   logic attest_sw_binding_6_we;
217:   logic [31:0] attest_sw_binding_6_qs;
218:   logic [31:0] attest_sw_binding_6_wd;
219:   logic attest_sw_binding_7_we;
220:   logic [31:0] attest_sw_binding_7_qs;
221:   logic [31:0] attest_sw_binding_7_wd;
222:   logic salt_0_we;
223:   logic [31:0] salt_0_qs;
224:   logic [31:0] salt_0_wd;
225:   logic salt_1_we;
226:   logic [31:0] salt_1_qs;
227:   logic [31:0] salt_1_wd;
228:   logic salt_2_we;
229:   logic [31:0] salt_2_qs;
230:   logic [31:0] salt_2_wd;
231:   logic salt_3_we;
232:   logic [31:0] salt_3_qs;
233:   logic [31:0] salt_3_wd;
234:   logic salt_4_we;
235:   logic [31:0] salt_4_qs;
236:   logic [31:0] salt_4_wd;
237:   logic salt_5_we;
238:   logic [31:0] salt_5_qs;
239:   logic [31:0] salt_5_wd;
240:   logic salt_6_we;
241:   logic [31:0] salt_6_qs;
242:   logic [31:0] salt_6_wd;
243:   logic salt_7_we;
244:   logic [31:0] salt_7_qs;
245:   logic [31:0] salt_7_wd;
246:   logic key_version_we;
247:   logic [31:0] key_version_qs;
248:   logic [31:0] key_version_wd;
249:   logic max_creator_key_ver_regwen_we;
250:   logic max_creator_key_ver_regwen_qs;
251:   logic max_creator_key_ver_regwen_wd;
252:   logic max_creator_key_ver_shadowed_re;
253:   logic max_creator_key_ver_shadowed_we;
254:   logic [31:0] max_creator_key_ver_shadowed_qs;
255:   logic [31:0] max_creator_key_ver_shadowed_wd;
256:   logic max_creator_key_ver_shadowed_storage_err;
257:   logic max_creator_key_ver_shadowed_update_err;
258:   logic max_owner_int_key_ver_regwen_we;
259:   logic max_owner_int_key_ver_regwen_qs;
260:   logic max_owner_int_key_ver_regwen_wd;
261:   logic max_owner_int_key_ver_shadowed_re;
262:   logic max_owner_int_key_ver_shadowed_we;
263:   logic [31:0] max_owner_int_key_ver_shadowed_qs;
264:   logic [31:0] max_owner_int_key_ver_shadowed_wd;
265:   logic max_owner_int_key_ver_shadowed_storage_err;
266:   logic max_owner_int_key_ver_shadowed_update_err;
267:   logic max_owner_key_ver_regwen_we;
268:   logic max_owner_key_ver_regwen_qs;
269:   logic max_owner_key_ver_regwen_wd;
270:   logic max_owner_key_ver_shadowed_re;
271:   logic max_owner_key_ver_shadowed_we;
272:   logic [31:0] max_owner_key_ver_shadowed_qs;
273:   logic [31:0] max_owner_key_ver_shadowed_wd;
274:   logic max_owner_key_ver_shadowed_storage_err;
275:   logic max_owner_key_ver_shadowed_update_err;
276:   logic sw_share0_output_0_re;
277:   logic [31:0] sw_share0_output_0_qs;
278:   logic [31:0] sw_share0_output_0_wd;
279:   logic sw_share0_output_1_re;
280:   logic [31:0] sw_share0_output_1_qs;
281:   logic [31:0] sw_share0_output_1_wd;
282:   logic sw_share0_output_2_re;
283:   logic [31:0] sw_share0_output_2_qs;
284:   logic [31:0] sw_share0_output_2_wd;
285:   logic sw_share0_output_3_re;
286:   logic [31:0] sw_share0_output_3_qs;
287:   logic [31:0] sw_share0_output_3_wd;
288:   logic sw_share0_output_4_re;
289:   logic [31:0] sw_share0_output_4_qs;
290:   logic [31:0] sw_share0_output_4_wd;
291:   logic sw_share0_output_5_re;
292:   logic [31:0] sw_share0_output_5_qs;
293:   logic [31:0] sw_share0_output_5_wd;
294:   logic sw_share0_output_6_re;
295:   logic [31:0] sw_share0_output_6_qs;
296:   logic [31:0] sw_share0_output_6_wd;
297:   logic sw_share0_output_7_re;
298:   logic [31:0] sw_share0_output_7_qs;
299:   logic [31:0] sw_share0_output_7_wd;
300:   logic sw_share1_output_0_re;
301:   logic [31:0] sw_share1_output_0_qs;
302:   logic [31:0] sw_share1_output_0_wd;
303:   logic sw_share1_output_1_re;
304:   logic [31:0] sw_share1_output_1_qs;
305:   logic [31:0] sw_share1_output_1_wd;
306:   logic sw_share1_output_2_re;
307:   logic [31:0] sw_share1_output_2_qs;
308:   logic [31:0] sw_share1_output_2_wd;
309:   logic sw_share1_output_3_re;
310:   logic [31:0] sw_share1_output_3_qs;
311:   logic [31:0] sw_share1_output_3_wd;
312:   logic sw_share1_output_4_re;
313:   logic [31:0] sw_share1_output_4_qs;
314:   logic [31:0] sw_share1_output_4_wd;
315:   logic sw_share1_output_5_re;
316:   logic [31:0] sw_share1_output_5_qs;
317:   logic [31:0] sw_share1_output_5_wd;
318:   logic sw_share1_output_6_re;
319:   logic [31:0] sw_share1_output_6_qs;
320:   logic [31:0] sw_share1_output_6_wd;
321:   logic sw_share1_output_7_re;
322:   logic [31:0] sw_share1_output_7_qs;
323:   logic [31:0] sw_share1_output_7_wd;
324:   logic [2:0] working_state_qs;
325:   logic op_status_we;
326:   logic [1:0] op_status_qs;
327:   logic [1:0] op_status_wd;
328:   logic err_code_we;
329:   logic err_code_invalid_op_qs;
330:   logic err_code_invalid_op_wd;
331:   logic err_code_invalid_kmac_input_qs;
332:   logic err_code_invalid_kmac_input_wd;
333:   logic err_code_invalid_shadow_update_qs;
334:   logic err_code_invalid_shadow_update_wd;
335:   logic fault_status_cmd_qs;
336:   logic fault_status_kmac_fsm_qs;
337:   logic fault_status_kmac_done_qs;
338:   logic fault_status_kmac_op_qs;
339:   logic fault_status_kmac_out_qs;
340:   logic fault_status_regfile_intg_qs;
341:   logic fault_status_shadow_qs;
342:   logic fault_status_ctrl_fsm_intg_qs;
343:   logic fault_status_ctrl_fsm_chk_qs;
344:   logic fault_status_ctrl_fsm_cnt_qs;
345:   logic fault_status_reseed_cnt_qs;
346:   logic fault_status_side_ctrl_fsm_qs;
347:   logic fault_status_side_ctrl_sel_qs;
348:   logic fault_status_key_ecc_qs;
349:   logic debug_we;
350:   logic debug_invalid_creator_seed_qs;
351:   logic debug_invalid_creator_seed_wd;
352:   logic debug_invalid_owner_seed_qs;
353:   logic debug_invalid_owner_seed_wd;
354:   logic debug_invalid_dev_id_qs;
355:   logic debug_invalid_dev_id_wd;
356:   logic debug_invalid_health_state_qs;
357:   logic debug_invalid_health_state_wd;
358:   logic debug_invalid_key_version_qs;
359:   logic debug_invalid_key_version_wd;
360:   logic debug_invalid_key_qs;
361:   logic debug_invalid_key_wd;
362:   logic debug_invalid_digest_qs;
363:   logic debug_invalid_digest_wd;
364: 
365:   // Register instances
366:   // R[intr_state]: V(False)
367:   prim_subreg #(
368:     .DW      (1),
369:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
370:     .RESVAL  (1'h0),
371:     .Mubi    (1'b0)
372:   ) u_intr_state (
373:     .clk_i   (clk_i),
374:     .rst_ni  (rst_ni),
375: 
376:     // from register interface
377:     .we     (intr_state_we),
378:     .wd     (intr_state_wd),
379: 
380:     // from internal hardware
381:     .de     (hw2reg.intr_state.de),
382:     .d      (hw2reg.intr_state.d),
383: 
384:     // to internal hardware
385:     .qe     (),
386:     .q      (reg2hw.intr_state.q),
387:     .ds     (),
388: 
389:     // to register interface (read)
390:     .qs     (intr_state_qs)
391:   );
392: 
393: 
394:   // R[intr_enable]: V(False)
395:   prim_subreg #(
396:     .DW      (1),
397:     .SwAccess(prim_subreg_pkg::SwAccessRW),
398:     .RESVAL  (1'h0),
399:     .Mubi    (1'b0)
400:   ) u_intr_enable (
401:     .clk_i   (clk_i),
402:     .rst_ni  (rst_ni),
403: 
404:     // from register interface
405:     .we     (intr_enable_we),
406:     .wd     (intr_enable_wd),
407: 
408:     // from internal hardware
409:     .de     (1'b0),
410:     .d      ('0),
411: 
412:     // to internal hardware
413:     .qe     (),
414:     .q      (reg2hw.intr_enable.q),
415:     .ds     (),
416: 
417:     // to register interface (read)
418:     .qs     (intr_enable_qs)
419:   );
420: 
421: 
422:   // R[intr_test]: V(True)
423:   logic intr_test_qe;
424:   logic [0:0] intr_test_flds_we;
425:   assign intr_test_qe = &intr_test_flds_we;
426:   prim_subreg_ext #(
427:     .DW    (1)
428:   ) u_intr_test (
429:     .re     (1'b0),
430:     .we     (intr_test_we),
431:     .wd     (intr_test_wd),
432:     .d      ('0),
433:     .qre    (),
434:     .qe     (intr_test_flds_we[0]),
435:     .q      (reg2hw.intr_test.q),
436:     .ds     (),
437:     .qs     ()
438:   );
439:   assign reg2hw.intr_test.qe = intr_test_qe;
440: 
441: 
442:   // R[alert_test]: V(True)
443:   logic alert_test_qe;
444:   logic [1:0] alert_test_flds_we;
445:   assign alert_test_qe = &alert_test_flds_we;
446:   //   F[recov_operation_err]: 0:0
447:   prim_subreg_ext #(
448:     .DW    (1)
449:   ) u_alert_test_recov_operation_err (
450:     .re     (1'b0),
451:     .we     (alert_test_we),
452:     .wd     (alert_test_recov_operation_err_wd),
453:     .d      ('0),
454:     .qre    (),
455:     .qe     (alert_test_flds_we[0]),
456:     .q      (reg2hw.alert_test.recov_operation_err.q),
457:     .ds     (),
458:     .qs     ()
459:   );
460:   assign reg2hw.alert_test.recov_operation_err.qe = alert_test_qe;
461: 
462:   //   F[fatal_fault_err]: 1:1
463:   prim_subreg_ext #(
464:     .DW    (1)
465:   ) u_alert_test_fatal_fault_err (
466:     .re     (1'b0),
467:     .we     (alert_test_we),
468:     .wd     (alert_test_fatal_fault_err_wd),
469:     .d      ('0),
470:     .qre    (),
471:     .qe     (alert_test_flds_we[1]),
472:     .q      (reg2hw.alert_test.fatal_fault_err.q),
473:     .ds     (),
474:     .qs     ()
475:   );
476:   assign reg2hw.alert_test.fatal_fault_err.qe = alert_test_qe;
477: 
478: 
479:   // R[cfg_regwen]: V(True)
480:   prim_subreg_ext #(
481:     .DW    (1)
482:   ) u_cfg_regwen (
483:     .re     (cfg_regwen_re),
484:     .we     (1'b0),
485:     .wd     ('0),
486:     .d      (hw2reg.cfg_regwen.d),
487:     .qre    (),
488:     .qe     (),
489:     .q      (),
490:     .ds     (),
491:     .qs     (cfg_regwen_qs)
492:   );
493: 
494: 
495:   // R[start]: V(False)
496:   // Create REGWEN-gated WE signal
497:   logic start_gated_we;
498:   assign start_gated_we = start_we & cfg_regwen_qs;
499:   prim_subreg #(
500:     .DW      (1),
501:     .SwAccess(prim_subreg_pkg::SwAccessRW),
502:     .RESVAL  (1'h0),
503:     .Mubi    (1'b0)
504:   ) u_start (
505:     .clk_i   (clk_i),
506:     .rst_ni  (rst_ni),
507: 
508:     // from register interface
509:     .we     (start_gated_we),
510:     .wd     (start_wd),
511: 
512:     // from internal hardware
513:     .de     (hw2reg.start.de),
514:     .d      (hw2reg.start.d),
515: 
516:     // to internal hardware
517:     .qe     (),
518:     .q      (reg2hw.start.q),
519:     .ds     (),
520: 
521:     // to register interface (read)
522:     .qs     (start_qs)
523:   );
524: 
525: 
526:   // R[control_shadowed]: V(False)
527:   // Create REGWEN-gated WE signal
528:   logic control_shadowed_gated_we;
529:   assign control_shadowed_gated_we = control_shadowed_we & cfg_regwen_qs;
530:   //   F[operation]: 6:4
531:   prim_subreg_shadow #(
532:     .DW      (3),
533:     .SwAccess(prim_subreg_pkg::SwAccessRW),
534:     .RESVAL  (3'h1),
535:     .Mubi    (1'b0)
536:   ) u_control_shadowed_operation (
537:     .clk_i   (clk_i),
538:     .rst_ni  (rst_ni),
539:     .rst_shadowed_ni (rst_shadowed_ni),
540: 
541:     // from register interface
542:     .re     (control_shadowed_re),
543:     .we     (control_shadowed_gated_we),
544:     .wd     (control_shadowed_operation_wd),
545: 
546:     // from internal hardware
547:     .de     (1'b0),
548:     .d      ('0),
549: 
550:     // to internal hardware
551:     .qe     (),
552:     .q      (reg2hw.control_shadowed.operation.q),
553:     .ds     (),
554: 
555:     // to register interface (read)
556:     .qs     (control_shadowed_operation_qs),
557: 
558:     // Shadow register phase. Relevant for hwext only.
559:     .phase  (),
560: 
561:     // Shadow register error conditions
562:     .err_update  (control_shadowed_operation_update_err),
563:     .err_storage (control_shadowed_operation_storage_err)
564:   );
565: 
566:   //   F[cdi_sel]: 7:7
567:   prim_subreg_shadow #(
568:     .DW      (1),
569:     .SwAccess(prim_subreg_pkg::SwAccessRW),
570:     .RESVAL  (1'h0),
571:     .Mubi    (1'b0)
572:   ) u_control_shadowed_cdi_sel (
573:     .clk_i   (clk_i),
574:     .rst_ni  (rst_ni),
575:     .rst_shadowed_ni (rst_shadowed_ni),
576: 
577:     // from register interface
578:     .re     (control_shadowed_re),
579:     .we     (control_shadowed_gated_we),
580:     .wd     (control_shadowed_cdi_sel_wd),
581: 
582:     // from internal hardware
583:     .de     (1'b0),
584:     .d      ('0),
585: 
586:     // to internal hardware
587:     .qe     (),
588:     .q      (reg2hw.control_shadowed.cdi_sel.q),
589:     .ds     (),
590: 
591:     // to register interface (read)
592:     .qs     (control_shadowed_cdi_sel_qs),
593: 
594:     // Shadow register phase. Relevant for hwext only.
595:     .phase  (),
596: 
597:     // Shadow register error conditions
598:     .err_update  (control_shadowed_cdi_sel_update_err),
599:     .err_storage (control_shadowed_cdi_sel_storage_err)
600:   );
601: 
602:   //   F[dest_sel]: 13:12
603:   prim_subreg_shadow #(
604:     .DW      (2),
605:     .SwAccess(prim_subreg_pkg::SwAccessRW),
606:     .RESVAL  (2'h0),
607:     .Mubi    (1'b0)
608:   ) u_control_shadowed_dest_sel (
609:     .clk_i   (clk_i),
610:     .rst_ni  (rst_ni),
611:     .rst_shadowed_ni (rst_shadowed_ni),
612: 
613:     // from register interface
614:     .re     (control_shadowed_re),
615:     .we     (control_shadowed_gated_we),
616:     .wd     (control_shadowed_dest_sel_wd),
617: 
618:     // from internal hardware
619:     .de     (1'b0),
620:     .d      ('0),
621: 
622:     // to internal hardware
623:     .qe     (),
624:     .q      (reg2hw.control_shadowed.dest_sel.q),
625:     .ds     (),
626: 
627:     // to register interface (read)
628:     .qs     (control_shadowed_dest_sel_qs),
629: 
630:     // Shadow register phase. Relevant for hwext only.
631:     .phase  (),
632: 
633:     // Shadow register error conditions
634:     .err_update  (control_shadowed_dest_sel_update_err),
635:     .err_storage (control_shadowed_dest_sel_storage_err)
636:   );
637: 
638: 
639:   // R[sideload_clear]: V(False)
640:   // Create REGWEN-gated WE signal
641:   logic sideload_clear_gated_we;
642:   assign sideload_clear_gated_we = sideload_clear_we & cfg_regwen_qs;
643:   prim_subreg #(
644:     .DW      (3),
645:     .SwAccess(prim_subreg_pkg::SwAccessRW),
646:     .RESVAL  (3'h0),
647:     .Mubi    (1'b0)
648:   ) u_sideload_clear (
649:     .clk_i   (clk_i),
650:     .rst_ni  (rst_ni),
651: 
652:     // from register interface
653:     .we     (sideload_clear_gated_we),
654:     .wd     (sideload_clear_wd),
655: 
656:     // from internal hardware
657:     .de     (1'b0),
658:     .d      ('0),
659: 
660:     // to internal hardware
661:     .qe     (),
662:     .q      (reg2hw.sideload_clear.q),
663:     .ds     (),
664: 
665:     // to register interface (read)
666:     .qs     (sideload_clear_qs)
667:   );
668: 
669: 
670:   // R[reseed_interval_regwen]: V(False)
671:   prim_subreg #(
672:     .DW      (1),
673:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
674:     .RESVAL  (1'h1),
675:     .Mubi    (1'b0)
676:   ) u_reseed_interval_regwen (
677:     .clk_i   (clk_i),
678:     .rst_ni  (rst_ni),
679: 
680:     // from register interface
681:     .we     (reseed_interval_regwen_we),
682:     .wd     (reseed_interval_regwen_wd),
683: 
684:     // from internal hardware
685:     .de     (1'b0),
686:     .d      ('0),
687: 
688:     // to internal hardware
689:     .qe     (),
690:     .q      (),
691:     .ds     (),
692: 
693:     // to register interface (read)
694:     .qs     (reseed_interval_regwen_qs)
695:   );
696: 
697: 
698:   // R[reseed_interval_shadowed]: V(False)
699:   // Create REGWEN-gated WE signal
700:   logic reseed_interval_shadowed_gated_we;
701:   assign reseed_interval_shadowed_gated_we =
702:     reseed_interval_shadowed_we & reseed_interval_regwen_qs;
703:   prim_subreg_shadow #(
704:     .DW      (16),
705:     .SwAccess(prim_subreg_pkg::SwAccessRW),
706:     .RESVAL  (16'h100),
707:     .Mubi    (1'b0)
708:   ) u_reseed_interval_shadowed (
709:     .clk_i   (clk_i),
710:     .rst_ni  (rst_ni),
711:     .rst_shadowed_ni (rst_shadowed_ni),
712: 
713:     // from register interface
714:     .re     (reseed_interval_shadowed_re),
715:     .we     (reseed_interval_shadowed_gated_we),
716:     .wd     (reseed_interval_shadowed_wd),
717: 
718:     // from internal hardware
719:     .de     (1'b0),
720:     .d      ('0),
721: 
722:     // to internal hardware
723:     .qe     (),
724:     .q      (reg2hw.reseed_interval_shadowed.q),
725:     .ds     (),
726: 
727:     // to register interface (read)
728:     .qs     (reseed_interval_shadowed_qs),
729: 
730:     // Shadow register phase. Relevant for hwext only.
731:     .phase  (),
732: 
733:     // Shadow register error conditions
734:     .err_update  (reseed_interval_shadowed_update_err),
735:     .err_storage (reseed_interval_shadowed_storage_err)
736:   );
737: 
738: 
739:   // R[sw_binding_regwen]: V(True)
740:   logic sw_binding_regwen_qe;
741:   logic [0:0] sw_binding_regwen_flds_we;
742:   assign sw_binding_regwen_qe = &sw_binding_regwen_flds_we;
743:   prim_subreg_ext #(
744:     .DW    (1)
745:   ) u_sw_binding_regwen (
746:     .re     (sw_binding_regwen_re),
747:     .we     (sw_binding_regwen_we),
748:     .wd     (sw_binding_regwen_wd),
749:     .d      (hw2reg.sw_binding_regwen.d),
750:     .qre    (),
751:     .qe     (sw_binding_regwen_flds_we[0]),
752:     .q      (reg2hw.sw_binding_regwen.q),
753:     .ds     (),
754:     .qs     (sw_binding_regwen_qs)
755:   );
756:   assign reg2hw.sw_binding_regwen.qe = sw_binding_regwen_qe;
757: 
758: 
759:   // Subregister 0 of Multireg sealing_sw_binding
760:   // R[sealing_sw_binding_0]: V(False)
761:   // Create REGWEN-gated WE signal
762:   logic sealing_sw_binding_0_gated_we;
763:   assign sealing_sw_binding_0_gated_we = sealing_sw_binding_0_we & sw_binding_regwen_qs;
764:   prim_subreg #(
765:     .DW      (32),
766:     .SwAccess(prim_subreg_pkg::SwAccessRW),
767:     .RESVAL  (32'h0),
768:     .Mubi    (1'b0)
769:   ) u_sealing_sw_binding_0 (
770:     .clk_i   (clk_i),
771:     .rst_ni  (rst_ni),
772: 
773:     // from register interface
774:     .we     (sealing_sw_binding_0_gated_we),
775:     .wd     (sealing_sw_binding_0_wd),
776: 
777:     // from internal hardware
778:     .de     (1'b0),
779:     .d      ('0),
780: 
781:     // to internal hardware
782:     .qe     (),
783:     .q      (reg2hw.sealing_sw_binding[0].q),
784:     .ds     (),
785: 
786:     // to register interface (read)
787:     .qs     (sealing_sw_binding_0_qs)
788:   );
789: 
790: 
791:   // Subregister 1 of Multireg sealing_sw_binding
792:   // R[sealing_sw_binding_1]: V(False)
793:   // Create REGWEN-gated WE signal
794:   logic sealing_sw_binding_1_gated_we;
795:   assign sealing_sw_binding_1_gated_we = sealing_sw_binding_1_we & sw_binding_regwen_qs;
796:   prim_subreg #(
797:     .DW      (32),
798:     .SwAccess(prim_subreg_pkg::SwAccessRW),
799:     .RESVAL  (32'h0),
800:     .Mubi    (1'b0)
801:   ) u_sealing_sw_binding_1 (
802:     .clk_i   (clk_i),
803:     .rst_ni  (rst_ni),
804: 
805:     // from register interface
806:     .we     (sealing_sw_binding_1_gated_we),
807:     .wd     (sealing_sw_binding_1_wd),
808: 
809:     // from internal hardware
810:     .de     (1'b0),
811:     .d      ('0),
812: 
813:     // to internal hardware
814:     .qe     (),
815:     .q      (reg2hw.sealing_sw_binding[1].q),
816:     .ds     (),
817: 
818:     // to register interface (read)
819:     .qs     (sealing_sw_binding_1_qs)
820:   );
821: 
822: 
823:   // Subregister 2 of Multireg sealing_sw_binding
824:   // R[sealing_sw_binding_2]: V(False)
825:   // Create REGWEN-gated WE signal
826:   logic sealing_sw_binding_2_gated_we;
827:   assign sealing_sw_binding_2_gated_we = sealing_sw_binding_2_we & sw_binding_regwen_qs;
828:   prim_subreg #(
829:     .DW      (32),
830:     .SwAccess(prim_subreg_pkg::SwAccessRW),
831:     .RESVAL  (32'h0),
832:     .Mubi    (1'b0)
833:   ) u_sealing_sw_binding_2 (
834:     .clk_i   (clk_i),
835:     .rst_ni  (rst_ni),
836: 
837:     // from register interface
838:     .we     (sealing_sw_binding_2_gated_we),
839:     .wd     (sealing_sw_binding_2_wd),
840: 
841:     // from internal hardware
842:     .de     (1'b0),
843:     .d      ('0),
844: 
845:     // to internal hardware
846:     .qe     (),
847:     .q      (reg2hw.sealing_sw_binding[2].q),
848:     .ds     (),
849: 
850:     // to register interface (read)
851:     .qs     (sealing_sw_binding_2_qs)
852:   );
853: 
854: 
855:   // Subregister 3 of Multireg sealing_sw_binding
856:   // R[sealing_sw_binding_3]: V(False)
857:   // Create REGWEN-gated WE signal
858:   logic sealing_sw_binding_3_gated_we;
859:   assign sealing_sw_binding_3_gated_we = sealing_sw_binding_3_we & sw_binding_regwen_qs;
860:   prim_subreg #(
861:     .DW      (32),
862:     .SwAccess(prim_subreg_pkg::SwAccessRW),
863:     .RESVAL  (32'h0),
864:     .Mubi    (1'b0)
865:   ) u_sealing_sw_binding_3 (
866:     .clk_i   (clk_i),
867:     .rst_ni  (rst_ni),
868: 
869:     // from register interface
870:     .we     (sealing_sw_binding_3_gated_we),
871:     .wd     (sealing_sw_binding_3_wd),
872: 
873:     // from internal hardware
874:     .de     (1'b0),
875:     .d      ('0),
876: 
877:     // to internal hardware
878:     .qe     (),
879:     .q      (reg2hw.sealing_sw_binding[3].q),
880:     .ds     (),
881: 
882:     // to register interface (read)
883:     .qs     (sealing_sw_binding_3_qs)
884:   );
885: 
886: 
887:   // Subregister 4 of Multireg sealing_sw_binding
888:   // R[sealing_sw_binding_4]: V(False)
889:   // Create REGWEN-gated WE signal
890:   logic sealing_sw_binding_4_gated_we;
891:   assign sealing_sw_binding_4_gated_we = sealing_sw_binding_4_we & sw_binding_regwen_qs;
892:   prim_subreg #(
893:     .DW      (32),
894:     .SwAccess(prim_subreg_pkg::SwAccessRW),
895:     .RESVAL  (32'h0),
896:     .Mubi    (1'b0)
897:   ) u_sealing_sw_binding_4 (
898:     .clk_i   (clk_i),
899:     .rst_ni  (rst_ni),
900: 
901:     // from register interface
902:     .we     (sealing_sw_binding_4_gated_we),
903:     .wd     (sealing_sw_binding_4_wd),
904: 
905:     // from internal hardware
906:     .de     (1'b0),
907:     .d      ('0),
908: 
909:     // to internal hardware
910:     .qe     (),
911:     .q      (reg2hw.sealing_sw_binding[4].q),
912:     .ds     (),
913: 
914:     // to register interface (read)
915:     .qs     (sealing_sw_binding_4_qs)
916:   );
917: 
918: 
919:   // Subregister 5 of Multireg sealing_sw_binding
920:   // R[sealing_sw_binding_5]: V(False)
921:   // Create REGWEN-gated WE signal
922:   logic sealing_sw_binding_5_gated_we;
923:   assign sealing_sw_binding_5_gated_we = sealing_sw_binding_5_we & sw_binding_regwen_qs;
924:   prim_subreg #(
925:     .DW      (32),
926:     .SwAccess(prim_subreg_pkg::SwAccessRW),
927:     .RESVAL  (32'h0),
928:     .Mubi    (1'b0)
929:   ) u_sealing_sw_binding_5 (
930:     .clk_i   (clk_i),
931:     .rst_ni  (rst_ni),
932: 
933:     // from register interface
934:     .we     (sealing_sw_binding_5_gated_we),
935:     .wd     (sealing_sw_binding_5_wd),
936: 
937:     // from internal hardware
938:     .de     (1'b0),
939:     .d      ('0),
940: 
941:     // to internal hardware
942:     .qe     (),
943:     .q      (reg2hw.sealing_sw_binding[5].q),
944:     .ds     (),
945: 
946:     // to register interface (read)
947:     .qs     (sealing_sw_binding_5_qs)
948:   );
949: 
950: 
951:   // Subregister 6 of Multireg sealing_sw_binding
952:   // R[sealing_sw_binding_6]: V(False)
953:   // Create REGWEN-gated WE signal
954:   logic sealing_sw_binding_6_gated_we;
955:   assign sealing_sw_binding_6_gated_we = sealing_sw_binding_6_we & sw_binding_regwen_qs;
956:   prim_subreg #(
957:     .DW      (32),
958:     .SwAccess(prim_subreg_pkg::SwAccessRW),
959:     .RESVAL  (32'h0),
960:     .Mubi    (1'b0)
961:   ) u_sealing_sw_binding_6 (
962:     .clk_i   (clk_i),
963:     .rst_ni  (rst_ni),
964: 
965:     // from register interface
966:     .we     (sealing_sw_binding_6_gated_we),
967:     .wd     (sealing_sw_binding_6_wd),
968: 
969:     // from internal hardware
970:     .de     (1'b0),
971:     .d      ('0),
972: 
973:     // to internal hardware
974:     .qe     (),
975:     .q      (reg2hw.sealing_sw_binding[6].q),
976:     .ds     (),
977: 
978:     // to register interface (read)
979:     .qs     (sealing_sw_binding_6_qs)
980:   );
981: 
982: 
983:   // Subregister 7 of Multireg sealing_sw_binding
984:   // R[sealing_sw_binding_7]: V(False)
985:   // Create REGWEN-gated WE signal
986:   logic sealing_sw_binding_7_gated_we;
987:   assign sealing_sw_binding_7_gated_we = sealing_sw_binding_7_we & sw_binding_regwen_qs;
988:   prim_subreg #(
989:     .DW      (32),
990:     .SwAccess(prim_subreg_pkg::SwAccessRW),
991:     .RESVAL  (32'h0),
992:     .Mubi    (1'b0)
993:   ) u_sealing_sw_binding_7 (
994:     .clk_i   (clk_i),
995:     .rst_ni  (rst_ni),
996: 
997:     // from register interface
998:     .we     (sealing_sw_binding_7_gated_we),
999:     .wd     (sealing_sw_binding_7_wd),
1000: 
1001:     // from internal hardware
1002:     .de     (1'b0),
1003:     .d      ('0),
1004: 
1005:     // to internal hardware
1006:     .qe     (),
1007:     .q      (reg2hw.sealing_sw_binding[7].q),
1008:     .ds     (),
1009: 
1010:     // to register interface (read)
1011:     .qs     (sealing_sw_binding_7_qs)
1012:   );
1013: 
1014: 
1015:   // Subregister 0 of Multireg attest_sw_binding
1016:   // R[attest_sw_binding_0]: V(False)
1017:   // Create REGWEN-gated WE signal
1018:   logic attest_sw_binding_0_gated_we;
1019:   assign attest_sw_binding_0_gated_we = attest_sw_binding_0_we & sw_binding_regwen_qs;
1020:   prim_subreg #(
1021:     .DW      (32),
1022:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1023:     .RESVAL  (32'h0),
1024:     .Mubi    (1'b0)
1025:   ) u_attest_sw_binding_0 (
1026:     .clk_i   (clk_i),
1027:     .rst_ni  (rst_ni),
1028: 
1029:     // from register interface
1030:     .we     (attest_sw_binding_0_gated_we),
1031:     .wd     (attest_sw_binding_0_wd),
1032: 
1033:     // from internal hardware
1034:     .de     (1'b0),
1035:     .d      ('0),
1036: 
1037:     // to internal hardware
1038:     .qe     (),
1039:     .q      (reg2hw.attest_sw_binding[0].q),
1040:     .ds     (),
1041: 
1042:     // to register interface (read)
1043:     .qs     (attest_sw_binding_0_qs)
1044:   );
1045: 
1046: 
1047:   // Subregister 1 of Multireg attest_sw_binding
1048:   // R[attest_sw_binding_1]: V(False)
1049:   // Create REGWEN-gated WE signal
1050:   logic attest_sw_binding_1_gated_we;
1051:   assign attest_sw_binding_1_gated_we = attest_sw_binding_1_we & sw_binding_regwen_qs;
1052:   prim_subreg #(
1053:     .DW      (32),
1054:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1055:     .RESVAL  (32'h0),
1056:     .Mubi    (1'b0)
1057:   ) u_attest_sw_binding_1 (
1058:     .clk_i   (clk_i),
1059:     .rst_ni  (rst_ni),
1060: 
1061:     // from register interface
1062:     .we     (attest_sw_binding_1_gated_we),
1063:     .wd     (attest_sw_binding_1_wd),
1064: 
1065:     // from internal hardware
1066:     .de     (1'b0),
1067:     .d      ('0),
1068: 
1069:     // to internal hardware
1070:     .qe     (),
1071:     .q      (reg2hw.attest_sw_binding[1].q),
1072:     .ds     (),
1073: 
1074:     // to register interface (read)
1075:     .qs     (attest_sw_binding_1_qs)
1076:   );
1077: 
1078: 
1079:   // Subregister 2 of Multireg attest_sw_binding
1080:   // R[attest_sw_binding_2]: V(False)
1081:   // Create REGWEN-gated WE signal
1082:   logic attest_sw_binding_2_gated_we;
1083:   assign attest_sw_binding_2_gated_we = attest_sw_binding_2_we & sw_binding_regwen_qs;
1084:   prim_subreg #(
1085:     .DW      (32),
1086:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1087:     .RESVAL  (32'h0),
1088:     .Mubi    (1'b0)
1089:   ) u_attest_sw_binding_2 (
1090:     .clk_i   (clk_i),
1091:     .rst_ni  (rst_ni),
1092: 
1093:     // from register interface
1094:     .we     (attest_sw_binding_2_gated_we),
1095:     .wd     (attest_sw_binding_2_wd),
1096: 
1097:     // from internal hardware
1098:     .de     (1'b0),
1099:     .d      ('0),
1100: 
1101:     // to internal hardware
1102:     .qe     (),
1103:     .q      (reg2hw.attest_sw_binding[2].q),
1104:     .ds     (),
1105: 
1106:     // to register interface (read)
1107:     .qs     (attest_sw_binding_2_qs)
1108:   );
1109: 
1110: 
1111:   // Subregister 3 of Multireg attest_sw_binding
1112:   // R[attest_sw_binding_3]: V(False)
1113:   // Create REGWEN-gated WE signal
1114:   logic attest_sw_binding_3_gated_we;
1115:   assign attest_sw_binding_3_gated_we = attest_sw_binding_3_we & sw_binding_regwen_qs;
1116:   prim_subreg #(
1117:     .DW      (32),
1118:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1119:     .RESVAL  (32'h0),
1120:     .Mubi    (1'b0)
1121:   ) u_attest_sw_binding_3 (
1122:     .clk_i   (clk_i),
1123:     .rst_ni  (rst_ni),
1124: 
1125:     // from register interface
1126:     .we     (attest_sw_binding_3_gated_we),
1127:     .wd     (attest_sw_binding_3_wd),
1128: 
1129:     // from internal hardware
1130:     .de     (1'b0),
1131:     .d      ('0),
1132: 
1133:     // to internal hardware
1134:     .qe     (),
1135:     .q      (reg2hw.attest_sw_binding[3].q),
1136:     .ds     (),
1137: 
1138:     // to register interface (read)
1139:     .qs     (attest_sw_binding_3_qs)
1140:   );
1141: 
1142: 
1143:   // Subregister 4 of Multireg attest_sw_binding
1144:   // R[attest_sw_binding_4]: V(False)
1145:   // Create REGWEN-gated WE signal
1146:   logic attest_sw_binding_4_gated_we;
1147:   assign attest_sw_binding_4_gated_we = attest_sw_binding_4_we & sw_binding_regwen_qs;
1148:   prim_subreg #(
1149:     .DW      (32),
1150:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1151:     .RESVAL  (32'h0),
1152:     .Mubi    (1'b0)
1153:   ) u_attest_sw_binding_4 (
1154:     .clk_i   (clk_i),
1155:     .rst_ni  (rst_ni),
1156: 
1157:     // from register interface
1158:     .we     (attest_sw_binding_4_gated_we),
1159:     .wd     (attest_sw_binding_4_wd),
1160: 
1161:     // from internal hardware
1162:     .de     (1'b0),
1163:     .d      ('0),
1164: 
1165:     // to internal hardware
1166:     .qe     (),
1167:     .q      (reg2hw.attest_sw_binding[4].q),
1168:     .ds     (),
1169: 
1170:     // to register interface (read)
1171:     .qs     (attest_sw_binding_4_qs)
1172:   );
1173: 
1174: 
1175:   // Subregister 5 of Multireg attest_sw_binding
1176:   // R[attest_sw_binding_5]: V(False)
1177:   // Create REGWEN-gated WE signal
1178:   logic attest_sw_binding_5_gated_we;
1179:   assign attest_sw_binding_5_gated_we = attest_sw_binding_5_we & sw_binding_regwen_qs;
1180:   prim_subreg #(
1181:     .DW      (32),
1182:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1183:     .RESVAL  (32'h0),
1184:     .Mubi    (1'b0)
1185:   ) u_attest_sw_binding_5 (
1186:     .clk_i   (clk_i),
1187:     .rst_ni  (rst_ni),
1188: 
1189:     // from register interface
1190:     .we     (attest_sw_binding_5_gated_we),
1191:     .wd     (attest_sw_binding_5_wd),
1192: 
1193:     // from internal hardware
1194:     .de     (1'b0),
1195:     .d      ('0),
1196: 
1197:     // to internal hardware
1198:     .qe     (),
1199:     .q      (reg2hw.attest_sw_binding[5].q),
1200:     .ds     (),
1201: 
1202:     // to register interface (read)
1203:     .qs     (attest_sw_binding_5_qs)
1204:   );
1205: 
1206: 
1207:   // Subregister 6 of Multireg attest_sw_binding
1208:   // R[attest_sw_binding_6]: V(False)
1209:   // Create REGWEN-gated WE signal
1210:   logic attest_sw_binding_6_gated_we;
1211:   assign attest_sw_binding_6_gated_we = attest_sw_binding_6_we & sw_binding_regwen_qs;
1212:   prim_subreg #(
1213:     .DW      (32),
1214:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1215:     .RESVAL  (32'h0),
1216:     .Mubi    (1'b0)
1217:   ) u_attest_sw_binding_6 (
1218:     .clk_i   (clk_i),
1219:     .rst_ni  (rst_ni),
1220: 
1221:     // from register interface
1222:     .we     (attest_sw_binding_6_gated_we),
1223:     .wd     (attest_sw_binding_6_wd),
1224: 
1225:     // from internal hardware
1226:     .de     (1'b0),
1227:     .d      ('0),
1228: 
1229:     // to internal hardware
1230:     .qe     (),
1231:     .q      (reg2hw.attest_sw_binding[6].q),
1232:     .ds     (),
1233: 
1234:     // to register interface (read)
1235:     .qs     (attest_sw_binding_6_qs)
1236:   );
1237: 
1238: 
1239:   // Subregister 7 of Multireg attest_sw_binding
1240:   // R[attest_sw_binding_7]: V(False)
1241:   // Create REGWEN-gated WE signal
1242:   logic attest_sw_binding_7_gated_we;
1243:   assign attest_sw_binding_7_gated_we = attest_sw_binding_7_we & sw_binding_regwen_qs;
1244:   prim_subreg #(
1245:     .DW      (32),
1246:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1247:     .RESVAL  (32'h0),
1248:     .Mubi    (1'b0)
1249:   ) u_attest_sw_binding_7 (
1250:     .clk_i   (clk_i),
1251:     .rst_ni  (rst_ni),
1252: 
1253:     // from register interface
1254:     .we     (attest_sw_binding_7_gated_we),
1255:     .wd     (attest_sw_binding_7_wd),
1256: 
1257:     // from internal hardware
1258:     .de     (1'b0),
1259:     .d      ('0),
1260: 
1261:     // to internal hardware
1262:     .qe     (),
1263:     .q      (reg2hw.attest_sw_binding[7].q),
1264:     .ds     (),
1265: 
1266:     // to register interface (read)
1267:     .qs     (attest_sw_binding_7_qs)
1268:   );
1269: 
1270: 
1271:   // Subregister 0 of Multireg salt
1272:   // R[salt_0]: V(False)
1273:   // Create REGWEN-gated WE signal
1274:   logic salt_0_gated_we;
1275:   assign salt_0_gated_we = salt_0_we & cfg_regwen_qs;
1276:   prim_subreg #(
1277:     .DW      (32),
1278:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1279:     .RESVAL  (32'h0),
1280:     .Mubi    (1'b0)
1281:   ) u_salt_0 (
1282:     .clk_i   (clk_i),
1283:     .rst_ni  (rst_ni),
1284: 
1285:     // from register interface
1286:     .we     (salt_0_gated_we),
1287:     .wd     (salt_0_wd),
1288: 
1289:     // from internal hardware
1290:     .de     (1'b0),
1291:     .d      ('0),
1292: 
1293:     // to internal hardware
1294:     .qe     (),
1295:     .q      (reg2hw.salt[0].q),
1296:     .ds     (),
1297: 
1298:     // to register interface (read)
1299:     .qs     (salt_0_qs)
1300:   );
1301: 
1302: 
1303:   // Subregister 1 of Multireg salt
1304:   // R[salt_1]: V(False)
1305:   // Create REGWEN-gated WE signal
1306:   logic salt_1_gated_we;
1307:   assign salt_1_gated_we = salt_1_we & cfg_regwen_qs;
1308:   prim_subreg #(
1309:     .DW      (32),
1310:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1311:     .RESVAL  (32'h0),
1312:     .Mubi    (1'b0)
1313:   ) u_salt_1 (
1314:     .clk_i   (clk_i),
1315:     .rst_ni  (rst_ni),
1316: 
1317:     // from register interface
1318:     .we     (salt_1_gated_we),
1319:     .wd     (salt_1_wd),
1320: 
1321:     // from internal hardware
1322:     .de     (1'b0),
1323:     .d      ('0),
1324: 
1325:     // to internal hardware
1326:     .qe     (),
1327:     .q      (reg2hw.salt[1].q),
1328:     .ds     (),
1329: 
1330:     // to register interface (read)
1331:     .qs     (salt_1_qs)
1332:   );
1333: 
1334: 
1335:   // Subregister 2 of Multireg salt
1336:   // R[salt_2]: V(False)
1337:   // Create REGWEN-gated WE signal
1338:   logic salt_2_gated_we;
1339:   assign salt_2_gated_we = salt_2_we & cfg_regwen_qs;
1340:   prim_subreg #(
1341:     .DW      (32),
1342:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1343:     .RESVAL  (32'h0),
1344:     .Mubi    (1'b0)
1345:   ) u_salt_2 (
1346:     .clk_i   (clk_i),
1347:     .rst_ni  (rst_ni),
1348: 
1349:     // from register interface
1350:     .we     (salt_2_gated_we),
1351:     .wd     (salt_2_wd),
1352: 
1353:     // from internal hardware
1354:     .de     (1'b0),
1355:     .d      ('0),
1356: 
1357:     // to internal hardware
1358:     .qe     (),
1359:     .q      (reg2hw.salt[2].q),
1360:     .ds     (),
1361: 
1362:     // to register interface (read)
1363:     .qs     (salt_2_qs)
1364:   );
1365: 
1366: 
1367:   // Subregister 3 of Multireg salt
1368:   // R[salt_3]: V(False)
1369:   // Create REGWEN-gated WE signal
1370:   logic salt_3_gated_we;
1371:   assign salt_3_gated_we = salt_3_we & cfg_regwen_qs;
1372:   prim_subreg #(
1373:     .DW      (32),
1374:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1375:     .RESVAL  (32'h0),
1376:     .Mubi    (1'b0)
1377:   ) u_salt_3 (
1378:     .clk_i   (clk_i),
1379:     .rst_ni  (rst_ni),
1380: 
1381:     // from register interface
1382:     .we     (salt_3_gated_we),
1383:     .wd     (salt_3_wd),
1384: 
1385:     // from internal hardware
1386:     .de     (1'b0),
1387:     .d      ('0),
1388: 
1389:     // to internal hardware
1390:     .qe     (),
1391:     .q      (reg2hw.salt[3].q),
1392:     .ds     (),
1393: 
1394:     // to register interface (read)
1395:     .qs     (salt_3_qs)
1396:   );
1397: 
1398: 
1399:   // Subregister 4 of Multireg salt
1400:   // R[salt_4]: V(False)
1401:   // Create REGWEN-gated WE signal
1402:   logic salt_4_gated_we;
1403:   assign salt_4_gated_we = salt_4_we & cfg_regwen_qs;
1404:   prim_subreg #(
1405:     .DW      (32),
1406:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1407:     .RESVAL  (32'h0),
1408:     .Mubi    (1'b0)
1409:   ) u_salt_4 (
1410:     .clk_i   (clk_i),
1411:     .rst_ni  (rst_ni),
1412: 
1413:     // from register interface
1414:     .we     (salt_4_gated_we),
1415:     .wd     (salt_4_wd),
1416: 
1417:     // from internal hardware
1418:     .de     (1'b0),
1419:     .d      ('0),
1420: 
1421:     // to internal hardware
1422:     .qe     (),
1423:     .q      (reg2hw.salt[4].q),
1424:     .ds     (),
1425: 
1426:     // to register interface (read)
1427:     .qs     (salt_4_qs)
1428:   );
1429: 
1430: 
1431:   // Subregister 5 of Multireg salt
1432:   // R[salt_5]: V(False)
1433:   // Create REGWEN-gated WE signal
1434:   logic salt_5_gated_we;
1435:   assign salt_5_gated_we = salt_5_we & cfg_regwen_qs;
1436:   prim_subreg #(
1437:     .DW      (32),
1438:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1439:     .RESVAL  (32'h0),
1440:     .Mubi    (1'b0)
1441:   ) u_salt_5 (
1442:     .clk_i   (clk_i),
1443:     .rst_ni  (rst_ni),
1444: 
1445:     // from register interface
1446:     .we     (salt_5_gated_we),
1447:     .wd     (salt_5_wd),
1448: 
1449:     // from internal hardware
1450:     .de     (1'b0),
1451:     .d      ('0),
1452: 
1453:     // to internal hardware
1454:     .qe     (),
1455:     .q      (reg2hw.salt[5].q),
1456:     .ds     (),
1457: 
1458:     // to register interface (read)
1459:     .qs     (salt_5_qs)
1460:   );
1461: 
1462: 
1463:   // Subregister 6 of Multireg salt
1464:   // R[salt_6]: V(False)
1465:   // Create REGWEN-gated WE signal
1466:   logic salt_6_gated_we;
1467:   assign salt_6_gated_we = salt_6_we & cfg_regwen_qs;
1468:   prim_subreg #(
1469:     .DW      (32),
1470:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1471:     .RESVAL  (32'h0),
1472:     .Mubi    (1'b0)
1473:   ) u_salt_6 (
1474:     .clk_i   (clk_i),
1475:     .rst_ni  (rst_ni),
1476: 
1477:     // from register interface
1478:     .we     (salt_6_gated_we),
1479:     .wd     (salt_6_wd),
1480: 
1481:     // from internal hardware
1482:     .de     (1'b0),
1483:     .d      ('0),
1484: 
1485:     // to internal hardware
1486:     .qe     (),
1487:     .q      (reg2hw.salt[6].q),
1488:     .ds     (),
1489: 
1490:     // to register interface (read)
1491:     .qs     (salt_6_qs)
1492:   );
1493: 
1494: 
1495:   // Subregister 7 of Multireg salt
1496:   // R[salt_7]: V(False)
1497:   // Create REGWEN-gated WE signal
1498:   logic salt_7_gated_we;
1499:   assign salt_7_gated_we = salt_7_we & cfg_regwen_qs;
1500:   prim_subreg #(
1501:     .DW      (32),
1502:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1503:     .RESVAL  (32'h0),
1504:     .Mubi    (1'b0)
1505:   ) u_salt_7 (
1506:     .clk_i   (clk_i),
1507:     .rst_ni  (rst_ni),
1508: 
1509:     // from register interface
1510:     .we     (salt_7_gated_we),
1511:     .wd     (salt_7_wd),
1512: 
1513:     // from internal hardware
1514:     .de     (1'b0),
1515:     .d      ('0),
1516: 
1517:     // to internal hardware
1518:     .qe     (),
1519:     .q      (reg2hw.salt[7].q),
1520:     .ds     (),
1521: 
1522:     // to register interface (read)
1523:     .qs     (salt_7_qs)
1524:   );
1525: 
1526: 
1527:   // Subregister 0 of Multireg key_version
1528:   // R[key_version]: V(False)
1529:   // Create REGWEN-gated WE signal
1530:   logic key_version_gated_we;
1531:   assign key_version_gated_we = key_version_we & cfg_regwen_qs;
1532:   prim_subreg #(
1533:     .DW      (32),
1534:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1535:     .RESVAL  (32'h0),
1536:     .Mubi    (1'b0)
1537:   ) u_key_version (
1538:     .clk_i   (clk_i),
1539:     .rst_ni  (rst_ni),
1540: 
1541:     // from register interface
1542:     .we     (key_version_gated_we),
1543:     .wd     (key_version_wd),
1544: 
1545:     // from internal hardware
1546:     .de     (1'b0),
1547:     .d      ('0),
1548: 
1549:     // to internal hardware
1550:     .qe     (),
1551:     .q      (reg2hw.key_version[0].q),
1552:     .ds     (),
1553: 
1554:     // to register interface (read)
1555:     .qs     (key_version_qs)
1556:   );
1557: 
1558: 
1559:   // R[max_creator_key_ver_regwen]: V(False)
1560:   prim_subreg #(
1561:     .DW      (1),
1562:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
1563:     .RESVAL  (1'h1),
1564:     .Mubi    (1'b0)
1565:   ) u_max_creator_key_ver_regwen (
1566:     .clk_i   (clk_i),
1567:     .rst_ni  (rst_ni),
1568: 
1569:     // from register interface
1570:     .we     (max_creator_key_ver_regwen_we),
1571:     .wd     (max_creator_key_ver_regwen_wd),
1572: 
1573:     // from internal hardware
1574:     .de     (1'b0),
1575:     .d      ('0),
1576: 
1577:     // to internal hardware
1578:     .qe     (),
1579:     .q      (),
1580:     .ds     (),
1581: 
1582:     // to register interface (read)
1583:     .qs     (max_creator_key_ver_regwen_qs)
1584:   );
1585: 
1586: 
1587:   // R[max_creator_key_ver_shadowed]: V(False)
1588:   // Create REGWEN-gated WE signal
1589:   logic max_creator_key_ver_shadowed_gated_we;
1590:   assign max_creator_key_ver_shadowed_gated_we =
1591:     max_creator_key_ver_shadowed_we & max_creator_key_ver_regwen_qs;
1592:   prim_subreg_shadow #(
1593:     .DW      (32),
1594:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1595:     .RESVAL  (32'h0),
1596:     .Mubi    (1'b0)
1597:   ) u_max_creator_key_ver_shadowed (
1598:     .clk_i   (clk_i),
1599:     .rst_ni  (rst_ni),
1600:     .rst_shadowed_ni (rst_shadowed_ni),
1601: 
1602:     // from register interface
1603:     .re     (max_creator_key_ver_shadowed_re),
1604:     .we     (max_creator_key_ver_shadowed_gated_we),
1605:     .wd     (max_creator_key_ver_shadowed_wd),
1606: 
1607:     // from internal hardware
1608:     .de     (1'b0),
1609:     .d      ('0),
1610: 
1611:     // to internal hardware
1612:     .qe     (),
1613:     .q      (reg2hw.max_creator_key_ver_shadowed.q),
1614:     .ds     (),
1615: 
1616:     // to register interface (read)
1617:     .qs     (max_creator_key_ver_shadowed_qs),
1618: 
1619:     // Shadow register phase. Relevant for hwext only.
1620:     .phase  (),
1621: 
1622:     // Shadow register error conditions
1623:     .err_update  (max_creator_key_ver_shadowed_update_err),
1624:     .err_storage (max_creator_key_ver_shadowed_storage_err)
1625:   );
1626: 
1627: 
1628:   // R[max_owner_int_key_ver_regwen]: V(False)
1629:   prim_subreg #(
1630:     .DW      (1),
1631:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
1632:     .RESVAL  (1'h1),
1633:     .Mubi    (1'b0)
1634:   ) u_max_owner_int_key_ver_regwen (
1635:     .clk_i   (clk_i),
1636:     .rst_ni  (rst_ni),
1637: 
1638:     // from register interface
1639:     .we     (max_owner_int_key_ver_regwen_we),
1640:     .wd     (max_owner_int_key_ver_regwen_wd),
1641: 
1642:     // from internal hardware
1643:     .de     (1'b0),
1644:     .d      ('0),
1645: 
1646:     // to internal hardware
1647:     .qe     (),
1648:     .q      (),
1649:     .ds     (),
1650: 
1651:     // to register interface (read)
1652:     .qs     (max_owner_int_key_ver_regwen_qs)
1653:   );
1654: 
1655: 
1656:   // R[max_owner_int_key_ver_shadowed]: V(False)
1657:   // Create REGWEN-gated WE signal
1658:   logic max_owner_int_key_ver_shadowed_gated_we;
1659:   assign max_owner_int_key_ver_shadowed_gated_we =
1660:     max_owner_int_key_ver_shadowed_we & max_owner_int_key_ver_regwen_qs;
1661:   prim_subreg_shadow #(
1662:     .DW      (32),
1663:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1664:     .RESVAL  (32'h1),
1665:     .Mubi    (1'b0)
1666:   ) u_max_owner_int_key_ver_shadowed (
1667:     .clk_i   (clk_i),
1668:     .rst_ni  (rst_ni),
1669:     .rst_shadowed_ni (rst_shadowed_ni),
1670: 
1671:     // from register interface
1672:     .re     (max_owner_int_key_ver_shadowed_re),
1673:     .we     (max_owner_int_key_ver_shadowed_gated_we),
1674:     .wd     (max_owner_int_key_ver_shadowed_wd),
1675: 
1676:     // from internal hardware
1677:     .de     (1'b0),
1678:     .d      ('0),
1679: 
1680:     // to internal hardware
1681:     .qe     (),
1682:     .q      (reg2hw.max_owner_int_key_ver_shadowed.q),
1683:     .ds     (),
1684: 
1685:     // to register interface (read)
1686:     .qs     (max_owner_int_key_ver_shadowed_qs),
1687: 
1688:     // Shadow register phase. Relevant for hwext only.
1689:     .phase  (),
1690: 
1691:     // Shadow register error conditions
1692:     .err_update  (max_owner_int_key_ver_shadowed_update_err),
1693:     .err_storage (max_owner_int_key_ver_shadowed_storage_err)
1694:   );
1695: 
1696: 
1697:   // R[max_owner_key_ver_regwen]: V(False)
1698:   prim_subreg #(
1699:     .DW      (1),
1700:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
1701:     .RESVAL  (1'h1),
1702:     .Mubi    (1'b0)
1703:   ) u_max_owner_key_ver_regwen (
1704:     .clk_i   (clk_i),
1705:     .rst_ni  (rst_ni),
1706: 
1707:     // from register interface
1708:     .we     (max_owner_key_ver_regwen_we),
1709:     .wd     (max_owner_key_ver_regwen_wd),
1710: 
1711:     // from internal hardware
1712:     .de     (1'b0),
1713:     .d      ('0),
1714: 
1715:     // to internal hardware
1716:     .qe     (),
1717:     .q      (),
1718:     .ds     (),
1719: 
1720:     // to register interface (read)
1721:     .qs     (max_owner_key_ver_regwen_qs)
1722:   );
1723: 
1724: 
1725:   // R[max_owner_key_ver_shadowed]: V(False)
1726:   // Create REGWEN-gated WE signal
1727:   logic max_owner_key_ver_shadowed_gated_we;
1728:   assign max_owner_key_ver_shadowed_gated_we =
1729:     max_owner_key_ver_shadowed_we & max_owner_key_ver_regwen_qs;
1730:   prim_subreg_shadow #(
1731:     .DW      (32),
1732:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1733:     .RESVAL  (32'h0),
1734:     .Mubi    (1'b0)
1735:   ) u_max_owner_key_ver_shadowed (
1736:     .clk_i   (clk_i),
1737:     .rst_ni  (rst_ni),
1738:     .rst_shadowed_ni (rst_shadowed_ni),
1739: 
1740:     // from register interface
1741:     .re     (max_owner_key_ver_shadowed_re),
1742:     .we     (max_owner_key_ver_shadowed_gated_we),
1743:     .wd     (max_owner_key_ver_shadowed_wd),
1744: 
1745:     // from internal hardware
1746:     .de     (1'b0),
1747:     .d      ('0),
1748: 
1749:     // to internal hardware
1750:     .qe     (),
1751:     .q      (reg2hw.max_owner_key_ver_shadowed.q),
1752:     .ds     (),
1753: 
1754:     // to register interface (read)
1755:     .qs     (max_owner_key_ver_shadowed_qs),
1756: 
1757:     // Shadow register phase. Relevant for hwext only.
1758:     .phase  (),
1759: 
1760:     // Shadow register error conditions
1761:     .err_update  (max_owner_key_ver_shadowed_update_err),
1762:     .err_storage (max_owner_key_ver_shadowed_storage_err)
1763:   );
1764: 
1765: 
1766:   // Subregister 0 of Multireg sw_share0_output
1767:   // R[sw_share0_output_0]: V(False)
1768:   prim_subreg #(
1769:     .DW      (32),
1770:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1771:     .RESVAL  (32'h0),
1772:     .Mubi    (1'b0)
1773:   ) u_sw_share0_output_0 (
1774:     .clk_i   (clk_i),
1775:     .rst_ni  (rst_ni),
1776: 
1777:     // from register interface
1778:     .we     (sw_share0_output_0_re),
1779:     .wd     (sw_share0_output_0_wd),
1780: 
1781:     // from internal hardware
1782:     .de     (hw2reg.sw_share0_output[0].de),
1783:     .d      (hw2reg.sw_share0_output[0].d),
1784: 
1785:     // to internal hardware
1786:     .qe     (),
1787:     .q      (),
1788:     .ds     (),
1789: 
1790:     // to register interface (read)
1791:     .qs     (sw_share0_output_0_qs)
1792:   );
1793: 
1794: 
1795:   // Subregister 1 of Multireg sw_share0_output
1796:   // R[sw_share0_output_1]: V(False)
1797:   prim_subreg #(
1798:     .DW      (32),
1799:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1800:     .RESVAL  (32'h0),
1801:     .Mubi    (1'b0)
1802:   ) u_sw_share0_output_1 (
1803:     .clk_i   (clk_i),
1804:     .rst_ni  (rst_ni),
1805: 
1806:     // from register interface
1807:     .we     (sw_share0_output_1_re),
1808:     .wd     (sw_share0_output_1_wd),
1809: 
1810:     // from internal hardware
1811:     .de     (hw2reg.sw_share0_output[1].de),
1812:     .d      (hw2reg.sw_share0_output[1].d),
1813: 
1814:     // to internal hardware
1815:     .qe     (),
1816:     .q      (),
1817:     .ds     (),
1818: 
1819:     // to register interface (read)
1820:     .qs     (sw_share0_output_1_qs)
1821:   );
1822: 
1823: 
1824:   // Subregister 2 of Multireg sw_share0_output
1825:   // R[sw_share0_output_2]: V(False)
1826:   prim_subreg #(
1827:     .DW      (32),
1828:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1829:     .RESVAL  (32'h0),
1830:     .Mubi    (1'b0)
1831:   ) u_sw_share0_output_2 (
1832:     .clk_i   (clk_i),
1833:     .rst_ni  (rst_ni),
1834: 
1835:     // from register interface
1836:     .we     (sw_share0_output_2_re),
1837:     .wd     (sw_share0_output_2_wd),
1838: 
1839:     // from internal hardware
1840:     .de     (hw2reg.sw_share0_output[2].de),
1841:     .d      (hw2reg.sw_share0_output[2].d),
1842: 
1843:     // to internal hardware
1844:     .qe     (),
1845:     .q      (),
1846:     .ds     (),
1847: 
1848:     // to register interface (read)
1849:     .qs     (sw_share0_output_2_qs)
1850:   );
1851: 
1852: 
1853:   // Subregister 3 of Multireg sw_share0_output
1854:   // R[sw_share0_output_3]: V(False)
1855:   prim_subreg #(
1856:     .DW      (32),
1857:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1858:     .RESVAL  (32'h0),
1859:     .Mubi    (1'b0)
1860:   ) u_sw_share0_output_3 (
1861:     .clk_i   (clk_i),
1862:     .rst_ni  (rst_ni),
1863: 
1864:     // from register interface
1865:     .we     (sw_share0_output_3_re),
1866:     .wd     (sw_share0_output_3_wd),
1867: 
1868:     // from internal hardware
1869:     .de     (hw2reg.sw_share0_output[3].de),
1870:     .d      (hw2reg.sw_share0_output[3].d),
1871: 
1872:     // to internal hardware
1873:     .qe     (),
1874:     .q      (),
1875:     .ds     (),
1876: 
1877:     // to register interface (read)
1878:     .qs     (sw_share0_output_3_qs)
1879:   );
1880: 
1881: 
1882:   // Subregister 4 of Multireg sw_share0_output
1883:   // R[sw_share0_output_4]: V(False)
1884:   prim_subreg #(
1885:     .DW      (32),
1886:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1887:     .RESVAL  (32'h0),
1888:     .Mubi    (1'b0)
1889:   ) u_sw_share0_output_4 (
1890:     .clk_i   (clk_i),
1891:     .rst_ni  (rst_ni),
1892: 
1893:     // from register interface
1894:     .we     (sw_share0_output_4_re),
1895:     .wd     (sw_share0_output_4_wd),
1896: 
1897:     // from internal hardware
1898:     .de     (hw2reg.sw_share0_output[4].de),
1899:     .d      (hw2reg.sw_share0_output[4].d),
1900: 
1901:     // to internal hardware
1902:     .qe     (),
1903:     .q      (),
1904:     .ds     (),
1905: 
1906:     // to register interface (read)
1907:     .qs     (sw_share0_output_4_qs)
1908:   );
1909: 
1910: 
1911:   // Subregister 5 of Multireg sw_share0_output
1912:   // R[sw_share0_output_5]: V(False)
1913:   prim_subreg #(
1914:     .DW      (32),
1915:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1916:     .RESVAL  (32'h0),
1917:     .Mubi    (1'b0)
1918:   ) u_sw_share0_output_5 (
1919:     .clk_i   (clk_i),
1920:     .rst_ni  (rst_ni),
1921: 
1922:     // from register interface
1923:     .we     (sw_share0_output_5_re),
1924:     .wd     (sw_share0_output_5_wd),
1925: 
1926:     // from internal hardware
1927:     .de     (hw2reg.sw_share0_output[5].de),
1928:     .d      (hw2reg.sw_share0_output[5].d),
1929: 
1930:     // to internal hardware
1931:     .qe     (),
1932:     .q      (),
1933:     .ds     (),
1934: 
1935:     // to register interface (read)
1936:     .qs     (sw_share0_output_5_qs)
1937:   );
1938: 
1939: 
1940:   // Subregister 6 of Multireg sw_share0_output
1941:   // R[sw_share0_output_6]: V(False)
1942:   prim_subreg #(
1943:     .DW      (32),
1944:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1945:     .RESVAL  (32'h0),
1946:     .Mubi    (1'b0)
1947:   ) u_sw_share0_output_6 (
1948:     .clk_i   (clk_i),
1949:     .rst_ni  (rst_ni),
1950: 
1951:     // from register interface
1952:     .we     (sw_share0_output_6_re),
1953:     .wd     (sw_share0_output_6_wd),
1954: 
1955:     // from internal hardware
1956:     .de     (hw2reg.sw_share0_output[6].de),
1957:     .d      (hw2reg.sw_share0_output[6].d),
1958: 
1959:     // to internal hardware
1960:     .qe     (),
1961:     .q      (),
1962:     .ds     (),
1963: 
1964:     // to register interface (read)
1965:     .qs     (sw_share0_output_6_qs)
1966:   );
1967: 
1968: 
1969:   // Subregister 7 of Multireg sw_share0_output
1970:   // R[sw_share0_output_7]: V(False)
1971:   prim_subreg #(
1972:     .DW      (32),
1973:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1974:     .RESVAL  (32'h0),
1975:     .Mubi    (1'b0)
1976:   ) u_sw_share0_output_7 (
1977:     .clk_i   (clk_i),
1978:     .rst_ni  (rst_ni),
1979: 
1980:     // from register interface
1981:     .we     (sw_share0_output_7_re),
1982:     .wd     (sw_share0_output_7_wd),
1983: 
1984:     // from internal hardware
1985:     .de     (hw2reg.sw_share0_output[7].de),
1986:     .d      (hw2reg.sw_share0_output[7].d),
1987: 
1988:     // to internal hardware
1989:     .qe     (),
1990:     .q      (),
1991:     .ds     (),
1992: 
1993:     // to register interface (read)
1994:     .qs     (sw_share0_output_7_qs)
1995:   );
1996: 
1997: 
1998:   // Subregister 0 of Multireg sw_share1_output
1999:   // R[sw_share1_output_0]: V(False)
2000:   prim_subreg #(
2001:     .DW      (32),
2002:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2003:     .RESVAL  (32'h0),
2004:     .Mubi    (1'b0)
2005:   ) u_sw_share1_output_0 (
2006:     .clk_i   (clk_i),
2007:     .rst_ni  (rst_ni),
2008: 
2009:     // from register interface
2010:     .we     (sw_share1_output_0_re),
2011:     .wd     (sw_share1_output_0_wd),
2012: 
2013:     // from internal hardware
2014:     .de     (hw2reg.sw_share1_output[0].de),
2015:     .d      (hw2reg.sw_share1_output[0].d),
2016: 
2017:     // to internal hardware
2018:     .qe     (),
2019:     .q      (),
2020:     .ds     (),
2021: 
2022:     // to register interface (read)
2023:     .qs     (sw_share1_output_0_qs)
2024:   );
2025: 
2026: 
2027:   // Subregister 1 of Multireg sw_share1_output
2028:   // R[sw_share1_output_1]: V(False)
2029:   prim_subreg #(
2030:     .DW      (32),
2031:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2032:     .RESVAL  (32'h0),
2033:     .Mubi    (1'b0)
2034:   ) u_sw_share1_output_1 (
2035:     .clk_i   (clk_i),
2036:     .rst_ni  (rst_ni),
2037: 
2038:     // from register interface
2039:     .we     (sw_share1_output_1_re),
2040:     .wd     (sw_share1_output_1_wd),
2041: 
2042:     // from internal hardware
2043:     .de     (hw2reg.sw_share1_output[1].de),
2044:     .d      (hw2reg.sw_share1_output[1].d),
2045: 
2046:     // to internal hardware
2047:     .qe     (),
2048:     .q      (),
2049:     .ds     (),
2050: 
2051:     // to register interface (read)
2052:     .qs     (sw_share1_output_1_qs)
2053:   );
2054: 
2055: 
2056:   // Subregister 2 of Multireg sw_share1_output
2057:   // R[sw_share1_output_2]: V(False)
2058:   prim_subreg #(
2059:     .DW      (32),
2060:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2061:     .RESVAL  (32'h0),
2062:     .Mubi    (1'b0)
2063:   ) u_sw_share1_output_2 (
2064:     .clk_i   (clk_i),
2065:     .rst_ni  (rst_ni),
2066: 
2067:     // from register interface
2068:     .we     (sw_share1_output_2_re),
2069:     .wd     (sw_share1_output_2_wd),
2070: 
2071:     // from internal hardware
2072:     .de     (hw2reg.sw_share1_output[2].de),
2073:     .d      (hw2reg.sw_share1_output[2].d),
2074: 
2075:     // to internal hardware
2076:     .qe     (),
2077:     .q      (),
2078:     .ds     (),
2079: 
2080:     // to register interface (read)
2081:     .qs     (sw_share1_output_2_qs)
2082:   );
2083: 
2084: 
2085:   // Subregister 3 of Multireg sw_share1_output
2086:   // R[sw_share1_output_3]: V(False)
2087:   prim_subreg #(
2088:     .DW      (32),
2089:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2090:     .RESVAL  (32'h0),
2091:     .Mubi    (1'b0)
2092:   ) u_sw_share1_output_3 (
2093:     .clk_i   (clk_i),
2094:     .rst_ni  (rst_ni),
2095: 
2096:     // from register interface
2097:     .we     (sw_share1_output_3_re),
2098:     .wd     (sw_share1_output_3_wd),
2099: 
2100:     // from internal hardware
2101:     .de     (hw2reg.sw_share1_output[3].de),
2102:     .d      (hw2reg.sw_share1_output[3].d),
2103: 
2104:     // to internal hardware
2105:     .qe     (),
2106:     .q      (),
2107:     .ds     (),
2108: 
2109:     // to register interface (read)
2110:     .qs     (sw_share1_output_3_qs)
2111:   );
2112: 
2113: 
2114:   // Subregister 4 of Multireg sw_share1_output
2115:   // R[sw_share1_output_4]: V(False)
2116:   prim_subreg #(
2117:     .DW      (32),
2118:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2119:     .RESVAL  (32'h0),
2120:     .Mubi    (1'b0)
2121:   ) u_sw_share1_output_4 (
2122:     .clk_i   (clk_i),
2123:     .rst_ni  (rst_ni),
2124: 
2125:     // from register interface
2126:     .we     (sw_share1_output_4_re),
2127:     .wd     (sw_share1_output_4_wd),
2128: 
2129:     // from internal hardware
2130:     .de     (hw2reg.sw_share1_output[4].de),
2131:     .d      (hw2reg.sw_share1_output[4].d),
2132: 
2133:     // to internal hardware
2134:     .qe     (),
2135:     .q      (),
2136:     .ds     (),
2137: 
2138:     // to register interface (read)
2139:     .qs     (sw_share1_output_4_qs)
2140:   );
2141: 
2142: 
2143:   // Subregister 5 of Multireg sw_share1_output
2144:   // R[sw_share1_output_5]: V(False)
2145:   prim_subreg #(
2146:     .DW      (32),
2147:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2148:     .RESVAL  (32'h0),
2149:     .Mubi    (1'b0)
2150:   ) u_sw_share1_output_5 (
2151:     .clk_i   (clk_i),
2152:     .rst_ni  (rst_ni),
2153: 
2154:     // from register interface
2155:     .we     (sw_share1_output_5_re),
2156:     .wd     (sw_share1_output_5_wd),
2157: 
2158:     // from internal hardware
2159:     .de     (hw2reg.sw_share1_output[5].de),
2160:     .d      (hw2reg.sw_share1_output[5].d),
2161: 
2162:     // to internal hardware
2163:     .qe     (),
2164:     .q      (),
2165:     .ds     (),
2166: 
2167:     // to register interface (read)
2168:     .qs     (sw_share1_output_5_qs)
2169:   );
2170: 
2171: 
2172:   // Subregister 6 of Multireg sw_share1_output
2173:   // R[sw_share1_output_6]: V(False)
2174:   prim_subreg #(
2175:     .DW      (32),
2176:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2177:     .RESVAL  (32'h0),
2178:     .Mubi    (1'b0)
2179:   ) u_sw_share1_output_6 (
2180:     .clk_i   (clk_i),
2181:     .rst_ni  (rst_ni),
2182: 
2183:     // from register interface
2184:     .we     (sw_share1_output_6_re),
2185:     .wd     (sw_share1_output_6_wd),
2186: 
2187:     // from internal hardware
2188:     .de     (hw2reg.sw_share1_output[6].de),
2189:     .d      (hw2reg.sw_share1_output[6].d),
2190: 
2191:     // to internal hardware
2192:     .qe     (),
2193:     .q      (),
2194:     .ds     (),
2195: 
2196:     // to register interface (read)
2197:     .qs     (sw_share1_output_6_qs)
2198:   );
2199: 
2200: 
2201:   // Subregister 7 of Multireg sw_share1_output
2202:   // R[sw_share1_output_7]: V(False)
2203:   prim_subreg #(
2204:     .DW      (32),
2205:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2206:     .RESVAL  (32'h0),
2207:     .Mubi    (1'b0)
2208:   ) u_sw_share1_output_7 (
2209:     .clk_i   (clk_i),
2210:     .rst_ni  (rst_ni),
2211: 
2212:     // from register interface
2213:     .we     (sw_share1_output_7_re),
2214:     .wd     (sw_share1_output_7_wd),
2215: 
2216:     // from internal hardware
2217:     .de     (hw2reg.sw_share1_output[7].de),
2218:     .d      (hw2reg.sw_share1_output[7].d),
2219: 
2220:     // to internal hardware
2221:     .qe     (),
2222:     .q      (),
2223:     .ds     (),
2224: 
2225:     // to register interface (read)
2226:     .qs     (sw_share1_output_7_qs)
2227:   );
2228: 
2229: 
2230:   // R[working_state]: V(False)
2231:   prim_subreg #(
2232:     .DW      (3),
2233:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2234:     .RESVAL  (3'h0),
2235:     .Mubi    (1'b0)
2236:   ) u_working_state (
2237:     .clk_i   (clk_i),
2238:     .rst_ni  (rst_ni),
2239: 
2240:     // from register interface
2241:     .we     (1'b0),
2242:     .wd     ('0),
2243: 
2244:     // from internal hardware
2245:     .de     (hw2reg.working_state.de),
2246:     .d      (hw2reg.working_state.d),
2247: 
2248:     // to internal hardware
2249:     .qe     (),
2250:     .q      (),
2251:     .ds     (),
2252: 
2253:     // to register interface (read)
2254:     .qs     (working_state_qs)
2255:   );
2256: 
2257: 
2258:   // R[op_status]: V(False)
2259:   prim_subreg #(
2260:     .DW      (2),
2261:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
2262:     .RESVAL  (2'h0),
2263:     .Mubi    (1'b0)
2264:   ) u_op_status (
2265:     .clk_i   (clk_i),
2266:     .rst_ni  (rst_ni),
2267: 
2268:     // from register interface
2269:     .we     (op_status_we),
2270:     .wd     (op_status_wd),
2271: 
2272:     // from internal hardware
2273:     .de     (hw2reg.op_status.de),
2274:     .d      (hw2reg.op_status.d),
2275: 
2276:     // to internal hardware
2277:     .qe     (),
2278:     .q      (),
2279:     .ds     (),
2280: 
2281:     // to register interface (read)
2282:     .qs     (op_status_qs)
2283:   );
2284: 
2285: 
2286:   // R[err_code]: V(False)
2287:   //   F[invalid_op]: 0:0
2288:   prim_subreg #(
2289:     .DW      (1),
2290:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
2291:     .RESVAL  (1'h0),
2292:     .Mubi    (1'b0)
2293:   ) u_err_code_invalid_op (
2294:     .clk_i   (clk_i),
2295:     .rst_ni  (rst_ni),
2296: 
2297:     // from register interface
2298:     .we     (err_code_we),
2299:     .wd     (err_code_invalid_op_wd),
2300: 
2301:     // from internal hardware
2302:     .de     (hw2reg.err_code.invalid_op.de),
2303:     .d      (hw2reg.err_code.invalid_op.d),
2304: 
2305:     // to internal hardware
2306:     .qe     (),
2307:     .q      (),
2308:     .ds     (),
2309: 
2310:     // to register interface (read)
2311:     .qs     (err_code_invalid_op_qs)
2312:   );
2313: 
2314:   //   F[invalid_kmac_input]: 1:1
2315:   prim_subreg #(
2316:     .DW      (1),
2317:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
2318:     .RESVAL  (1'h0),
2319:     .Mubi    (1'b0)
2320:   ) u_err_code_invalid_kmac_input (
2321:     .clk_i   (clk_i),
2322:     .rst_ni  (rst_ni),
2323: 
2324:     // from register interface
2325:     .we     (err_code_we),
2326:     .wd     (err_code_invalid_kmac_input_wd),
2327: 
2328:     // from internal hardware
2329:     .de     (hw2reg.err_code.invalid_kmac_input.de),
2330:     .d      (hw2reg.err_code.invalid_kmac_input.d),
2331: 
2332:     // to internal hardware
2333:     .qe     (),
2334:     .q      (),
2335:     .ds     (),
2336: 
2337:     // to register interface (read)
2338:     .qs     (err_code_invalid_kmac_input_qs)
2339:   );
2340: 
2341:   //   F[invalid_shadow_update]: 2:2
2342:   prim_subreg #(
2343:     .DW      (1),
2344:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
2345:     .RESVAL  (1'h0),
2346:     .Mubi    (1'b0)
2347:   ) u_err_code_invalid_shadow_update (
2348:     .clk_i   (clk_i),
2349:     .rst_ni  (rst_ni),
2350: 
2351:     // from register interface
2352:     .we     (err_code_we),
2353:     .wd     (err_code_invalid_shadow_update_wd),
2354: 
2355:     // from internal hardware
2356:     .de     (hw2reg.err_code.invalid_shadow_update.de),
2357:     .d      (hw2reg.err_code.invalid_shadow_update.d),
2358: 
2359:     // to internal hardware
2360:     .qe     (),
2361:     .q      (),
2362:     .ds     (),
2363: 
2364:     // to register interface (read)
2365:     .qs     (err_code_invalid_shadow_update_qs)
2366:   );
2367: 
2368: 
2369:   // R[fault_status]: V(False)
2370:   //   F[cmd]: 0:0
2371:   prim_subreg #(
2372:     .DW      (1),
2373:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2374:     .RESVAL  (1'h0),
2375:     .Mubi    (1'b0)
2376:   ) u_fault_status_cmd (
2377:     .clk_i   (clk_i),
2378:     .rst_ni  (rst_ni),
2379: 
2380:     // from register interface
2381:     .we     (1'b0),
2382:     .wd     ('0),
2383: 
2384:     // from internal hardware
2385:     .de     (hw2reg.fault_status.cmd.de),
2386:     .d      (hw2reg.fault_status.cmd.d),
2387: 
2388:     // to internal hardware
2389:     .qe     (),
2390:     .q      (reg2hw.fault_status.cmd.q),
2391:     .ds     (),
2392: 
2393:     // to register interface (read)
2394:     .qs     (fault_status_cmd_qs)
2395:   );
2396: 
2397:   //   F[kmac_fsm]: 1:1
2398:   prim_subreg #(
2399:     .DW      (1),
2400:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2401:     .RESVAL  (1'h0),
2402:     .Mubi    (1'b0)
2403:   ) u_fault_status_kmac_fsm (
2404:     .clk_i   (clk_i),
2405:     .rst_ni  (rst_ni),
2406: 
2407:     // from register interface
2408:     .we     (1'b0),
2409:     .wd     ('0),
2410: 
2411:     // from internal hardware
2412:     .de     (hw2reg.fault_status.kmac_fsm.de),
2413:     .d      (hw2reg.fault_status.kmac_fsm.d),
2414: 
2415:     // to internal hardware
2416:     .qe     (),
2417:     .q      (reg2hw.fault_status.kmac_fsm.q),
2418:     .ds     (),
2419: 
2420:     // to register interface (read)
2421:     .qs     (fault_status_kmac_fsm_qs)
2422:   );
2423: 
2424:   //   F[kmac_done]: 2:2
2425:   prim_subreg #(
2426:     .DW      (1),
2427:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2428:     .RESVAL  (1'h0),
2429:     .Mubi    (1'b0)
2430:   ) u_fault_status_kmac_done (
2431:     .clk_i   (clk_i),
2432:     .rst_ni  (rst_ni),
2433: 
2434:     // from register interface
2435:     .we     (1'b0),
2436:     .wd     ('0),
2437: 
2438:     // from internal hardware
2439:     .de     (hw2reg.fault_status.kmac_done.de),
2440:     .d      (hw2reg.fault_status.kmac_done.d),
2441: 
2442:     // to internal hardware
2443:     .qe     (),
2444:     .q      (reg2hw.fault_status.kmac_done.q),
2445:     .ds     (),
2446: 
2447:     // to register interface (read)
2448:     .qs     (fault_status_kmac_done_qs)
2449:   );
2450: 
2451:   //   F[kmac_op]: 3:3
2452:   prim_subreg #(
2453:     .DW      (1),
2454:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2455:     .RESVAL  (1'h0),
2456:     .Mubi    (1'b0)
2457:   ) u_fault_status_kmac_op (
2458:     .clk_i   (clk_i),
2459:     .rst_ni  (rst_ni),
2460: 
2461:     // from register interface
2462:     .we     (1'b0),
2463:     .wd     ('0),
2464: 
2465:     // from internal hardware
2466:     .de     (hw2reg.fault_status.kmac_op.de),
2467:     .d      (hw2reg.fault_status.kmac_op.d),
2468: 
2469:     // to internal hardware
2470:     .qe     (),
2471:     .q      (reg2hw.fault_status.kmac_op.q),
2472:     .ds     (),
2473: 
2474:     // to register interface (read)
2475:     .qs     (fault_status_kmac_op_qs)
2476:   );
2477: 
2478:   //   F[kmac_out]: 4:4
2479:   prim_subreg #(
2480:     .DW      (1),
2481:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2482:     .RESVAL  (1'h0),
2483:     .Mubi    (1'b0)
2484:   ) u_fault_status_kmac_out (
2485:     .clk_i   (clk_i),
2486:     .rst_ni  (rst_ni),
2487: 
2488:     // from register interface
2489:     .we     (1'b0),
2490:     .wd     ('0),
2491: 
2492:     // from internal hardware
2493:     .de     (hw2reg.fault_status.kmac_out.de),
2494:     .d      (hw2reg.fault_status.kmac_out.d),
2495: 
2496:     // to internal hardware
2497:     .qe     (),
2498:     .q      (reg2hw.fault_status.kmac_out.q),
2499:     .ds     (),
2500: 
2501:     // to register interface (read)
2502:     .qs     (fault_status_kmac_out_qs)
2503:   );
2504: 
2505:   //   F[regfile_intg]: 5:5
2506:   prim_subreg #(
2507:     .DW      (1),
2508:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2509:     .RESVAL  (1'h0),
2510:     .Mubi    (1'b0)
2511:   ) u_fault_status_regfile_intg (
2512:     .clk_i   (clk_i),
2513:     .rst_ni  (rst_ni),
2514: 
2515:     // from register interface
2516:     .we     (1'b0),
2517:     .wd     ('0),
2518: 
2519:     // from internal hardware
2520:     .de     (hw2reg.fault_status.regfile_intg.de),
2521:     .d      (hw2reg.fault_status.regfile_intg.d),
2522: 
2523:     // to internal hardware
2524:     .qe     (),
2525:     .q      (reg2hw.fault_status.regfile_intg.q),
2526:     .ds     (),
2527: 
2528:     // to register interface (read)
2529:     .qs     (fault_status_regfile_intg_qs)
2530:   );
2531: 
2532:   //   F[shadow]: 6:6
2533:   prim_subreg #(
2534:     .DW      (1),
2535:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2536:     .RESVAL  (1'h0),
2537:     .Mubi    (1'b0)
2538:   ) u_fault_status_shadow (
2539:     .clk_i   (clk_i),
2540:     .rst_ni  (rst_ni),
2541: 
2542:     // from register interface
2543:     .we     (1'b0),
2544:     .wd     ('0),
2545: 
2546:     // from internal hardware
2547:     .de     (hw2reg.fault_status.shadow.de),
2548:     .d      (hw2reg.fault_status.shadow.d),
2549: 
2550:     // to internal hardware
2551:     .qe     (),
2552:     .q      (reg2hw.fault_status.shadow.q),
2553:     .ds     (),
2554: 
2555:     // to register interface (read)
2556:     .qs     (fault_status_shadow_qs)
2557:   );
2558: 
2559:   //   F[ctrl_fsm_intg]: 7:7
2560:   prim_subreg #(
2561:     .DW      (1),
2562:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2563:     .RESVAL  (1'h0),
2564:     .Mubi    (1'b0)
2565:   ) u_fault_status_ctrl_fsm_intg (
2566:     .clk_i   (clk_i),
2567:     .rst_ni  (rst_ni),
2568: 
2569:     // from register interface
2570:     .we     (1'b0),
2571:     .wd     ('0),
2572: 
2573:     // from internal hardware
2574:     .de     (hw2reg.fault_status.ctrl_fsm_intg.de),
2575:     .d      (hw2reg.fault_status.ctrl_fsm_intg.d),
2576: 
2577:     // to internal hardware
2578:     .qe     (),
2579:     .q      (reg2hw.fault_status.ctrl_fsm_intg.q),
2580:     .ds     (),
2581: 
2582:     // to register interface (read)
2583:     .qs     (fault_status_ctrl_fsm_intg_qs)
2584:   );
2585: 
2586:   //   F[ctrl_fsm_chk]: 8:8
2587:   prim_subreg #(
2588:     .DW      (1),
2589:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2590:     .RESVAL  (1'h0),
2591:     .Mubi    (1'b0)
2592:   ) u_fault_status_ctrl_fsm_chk (
2593:     .clk_i   (clk_i),
2594:     .rst_ni  (rst_ni),
2595: 
2596:     // from register interface
2597:     .we     (1'b0),
2598:     .wd     ('0),
2599: 
2600:     // from internal hardware
2601:     .de     (hw2reg.fault_status.ctrl_fsm_chk.de),
2602:     .d      (hw2reg.fault_status.ctrl_fsm_chk.d),
2603: 
2604:     // to internal hardware
2605:     .qe     (),
2606:     .q      (reg2hw.fault_status.ctrl_fsm_chk.q),
2607:     .ds     (),
2608: 
2609:     // to register interface (read)
2610:     .qs     (fault_status_ctrl_fsm_chk_qs)
2611:   );
2612: 
2613:   //   F[ctrl_fsm_cnt]: 9:9
2614:   prim_subreg #(
2615:     .DW      (1),
2616:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2617:     .RESVAL  (1'h0),
2618:     .Mubi    (1'b0)
2619:   ) u_fault_status_ctrl_fsm_cnt (
2620:     .clk_i   (clk_i),
2621:     .rst_ni  (rst_ni),
2622: 
2623:     // from register interface
2624:     .we     (1'b0),
2625:     .wd     ('0),
2626: 
2627:     // from internal hardware
2628:     .de     (hw2reg.fault_status.ctrl_fsm_cnt.de),
2629:     .d      (hw2reg.fault_status.ctrl_fsm_cnt.d),
2630: 
2631:     // to internal hardware
2632:     .qe     (),
2633:     .q      (reg2hw.fault_status.ctrl_fsm_cnt.q),
2634:     .ds     (),
2635: 
2636:     // to register interface (read)
2637:     .qs     (fault_status_ctrl_fsm_cnt_qs)
2638:   );
2639: 
2640:   //   F[reseed_cnt]: 10:10
2641:   prim_subreg #(
2642:     .DW      (1),
2643:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2644:     .RESVAL  (1'h0),
2645:     .Mubi    (1'b0)
2646:   ) u_fault_status_reseed_cnt (
2647:     .clk_i   (clk_i),
2648:     .rst_ni  (rst_ni),
2649: 
2650:     // from register interface
2651:     .we     (1'b0),
2652:     .wd     ('0),
2653: 
2654:     // from internal hardware
2655:     .de     (hw2reg.fault_status.reseed_cnt.de),
2656:     .d      (hw2reg.fault_status.reseed_cnt.d),
2657: 
2658:     // to internal hardware
2659:     .qe     (),
2660:     .q      (reg2hw.fault_status.reseed_cnt.q),
2661:     .ds     (),
2662: 
2663:     // to register interface (read)
2664:     .qs     (fault_status_reseed_cnt_qs)
2665:   );
2666: 
2667:   //   F[side_ctrl_fsm]: 11:11
2668:   prim_subreg #(
2669:     .DW      (1),
2670:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2671:     .RESVAL  (1'h0),
2672:     .Mubi    (1'b0)
2673:   ) u_fault_status_side_ctrl_fsm (
2674:     .clk_i   (clk_i),
2675:     .rst_ni  (rst_ni),
2676: 
2677:     // from register interface
2678:     .we     (1'b0),
2679:     .wd     ('0),
2680: 
2681:     // from internal hardware
2682:     .de     (hw2reg.fault_status.side_ctrl_fsm.de),
2683:     .d      (hw2reg.fault_status.side_ctrl_fsm.d),
2684: 
2685:     // to internal hardware
2686:     .qe     (),
2687:     .q      (reg2hw.fault_status.side_ctrl_fsm.q),
2688:     .ds     (),
2689: 
2690:     // to register interface (read)
2691:     .qs     (fault_status_side_ctrl_fsm_qs)
2692:   );
2693: 
2694:   //   F[side_ctrl_sel]: 12:12
2695:   prim_subreg #(
2696:     .DW      (1),
2697:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2698:     .RESVAL  (1'h0),
2699:     .Mubi    (1'b0)
2700:   ) u_fault_status_side_ctrl_sel (
2701:     .clk_i   (clk_i),
2702:     .rst_ni  (rst_ni),
2703: 
2704:     // from register interface
2705:     .we     (1'b0),
2706:     .wd     ('0),
2707: 
2708:     // from internal hardware
2709:     .de     (hw2reg.fault_status.side_ctrl_sel.de),
2710:     .d      (hw2reg.fault_status.side_ctrl_sel.d),
2711: 
2712:     // to internal hardware
2713:     .qe     (),
2714:     .q      (reg2hw.fault_status.side_ctrl_sel.q),
2715:     .ds     (),
2716: 
2717:     // to register interface (read)
2718:     .qs     (fault_status_side_ctrl_sel_qs)
2719:   );
2720: 
2721:   //   F[key_ecc]: 13:13
2722:   prim_subreg #(
2723:     .DW      (1),
2724:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2725:     .RESVAL  (1'h0),
2726:     .Mubi    (1'b0)
2727:   ) u_fault_status_key_ecc (
2728:     .clk_i   (clk_i),
2729:     .rst_ni  (rst_ni),
2730: 
2731:     // from register interface
2732:     .we     (1'b0),
2733:     .wd     ('0),
2734: 
2735:     // from internal hardware
2736:     .de     (hw2reg.fault_status.key_ecc.de),
2737:     .d      (hw2reg.fault_status.key_ecc.d),
2738: 
2739:     // to internal hardware
2740:     .qe     (),
2741:     .q      (reg2hw.fault_status.key_ecc.q),
2742:     .ds     (),
2743: 
2744:     // to register interface (read)
2745:     .qs     (fault_status_key_ecc_qs)
2746:   );
2747: 
2748: 
2749:   // R[debug]: V(False)
2750:   //   F[invalid_creator_seed]: 0:0
2751:   prim_subreg #(
2752:     .DW      (1),
2753:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2754:     .RESVAL  (1'h0),
2755:     .Mubi    (1'b0)
2756:   ) u_debug_invalid_creator_seed (
2757:     .clk_i   (clk_i),
2758:     .rst_ni  (rst_ni),
2759: 
2760:     // from register interface
2761:     .we     (debug_we),
2762:     .wd     (debug_invalid_creator_seed_wd),
2763: 
2764:     // from internal hardware
2765:     .de     (hw2reg.debug.invalid_creator_seed.de),
2766:     .d      (hw2reg.debug.invalid_creator_seed.d),
2767: 
2768:     // to internal hardware
2769:     .qe     (),
2770:     .q      (),
2771:     .ds     (),
2772: 
2773:     // to register interface (read)
2774:     .qs     (debug_invalid_creator_seed_qs)
2775:   );
2776: 
2777:   //   F[invalid_owner_seed]: 1:1
2778:   prim_subreg #(
2779:     .DW      (1),
2780:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2781:     .RESVAL  (1'h0),
2782:     .Mubi    (1'b0)
2783:   ) u_debug_invalid_owner_seed (
2784:     .clk_i   (clk_i),
2785:     .rst_ni  (rst_ni),
2786: 
2787:     // from register interface
2788:     .we     (debug_we),
2789:     .wd     (debug_invalid_owner_seed_wd),
2790: 
2791:     // from internal hardware
2792:     .de     (hw2reg.debug.invalid_owner_seed.de),
2793:     .d      (hw2reg.debug.invalid_owner_seed.d),
2794: 
2795:     // to internal hardware
2796:     .qe     (),
2797:     .q      (),
2798:     .ds     (),
2799: 
2800:     // to register interface (read)
2801:     .qs     (debug_invalid_owner_seed_qs)
2802:   );
2803: 
2804:   //   F[invalid_dev_id]: 2:2
2805:   prim_subreg #(
2806:     .DW      (1),
2807:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2808:     .RESVAL  (1'h0),
2809:     .Mubi    (1'b0)
2810:   ) u_debug_invalid_dev_id (
2811:     .clk_i   (clk_i),
2812:     .rst_ni  (rst_ni),
2813: 
2814:     // from register interface
2815:     .we     (debug_we),
2816:     .wd     (debug_invalid_dev_id_wd),
2817: 
2818:     // from internal hardware
2819:     .de     (hw2reg.debug.invalid_dev_id.de),
2820:     .d      (hw2reg.debug.invalid_dev_id.d),
2821: 
2822:     // to internal hardware
2823:     .qe     (),
2824:     .q      (),
2825:     .ds     (),
2826: 
2827:     // to register interface (read)
2828:     .qs     (debug_invalid_dev_id_qs)
2829:   );
2830: 
2831:   //   F[invalid_health_state]: 3:3
2832:   prim_subreg #(
2833:     .DW      (1),
2834:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2835:     .RESVAL  (1'h0),
2836:     .Mubi    (1'b0)
2837:   ) u_debug_invalid_health_state (
2838:     .clk_i   (clk_i),
2839:     .rst_ni  (rst_ni),
2840: 
2841:     // from register interface
2842:     .we     (debug_we),
2843:     .wd     (debug_invalid_health_state_wd),
2844: 
2845:     // from internal hardware
2846:     .de     (hw2reg.debug.invalid_health_state.de),
2847:     .d      (hw2reg.debug.invalid_health_state.d),
2848: 
2849:     // to internal hardware
2850:     .qe     (),
2851:     .q      (),
2852:     .ds     (),
2853: 
2854:     // to register interface (read)
2855:     .qs     (debug_invalid_health_state_qs)
2856:   );
2857: 
2858:   //   F[invalid_key_version]: 4:4
2859:   prim_subreg #(
2860:     .DW      (1),
2861:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2862:     .RESVAL  (1'h0),
2863:     .Mubi    (1'b0)
2864:   ) u_debug_invalid_key_version (
2865:     .clk_i   (clk_i),
2866:     .rst_ni  (rst_ni),
2867: 
2868:     // from register interface
2869:     .we     (debug_we),
2870:     .wd     (debug_invalid_key_version_wd),
2871: 
2872:     // from internal hardware
2873:     .de     (hw2reg.debug.invalid_key_version.de),
2874:     .d      (hw2reg.debug.invalid_key_version.d),
2875: 
2876:     // to internal hardware
2877:     .qe     (),
2878:     .q      (),
2879:     .ds     (),
2880: 
2881:     // to register interface (read)
2882:     .qs     (debug_invalid_key_version_qs)
2883:   );
2884: 
2885:   //   F[invalid_key]: 5:5
2886:   prim_subreg #(
2887:     .DW      (1),
2888:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2889:     .RESVAL  (1'h0),
2890:     .Mubi    (1'b0)
2891:   ) u_debug_invalid_key (
2892:     .clk_i   (clk_i),
2893:     .rst_ni  (rst_ni),
2894: 
2895:     // from register interface
2896:     .we     (debug_we),
2897:     .wd     (debug_invalid_key_wd),
2898: 
2899:     // from internal hardware
2900:     .de     (hw2reg.debug.invalid_key.de),
2901:     .d      (hw2reg.debug.invalid_key.d),
2902: 
2903:     // to internal hardware
2904:     .qe     (),
2905:     .q      (),
2906:     .ds     (),
2907: 
2908:     // to register interface (read)
2909:     .qs     (debug_invalid_key_qs)
2910:   );
2911: 
2912:   //   F[invalid_digest]: 6:6
2913:   prim_subreg #(
2914:     .DW      (1),
2915:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2916:     .RESVAL  (1'h0),
2917:     .Mubi    (1'b0)
2918:   ) u_debug_invalid_digest (
2919:     .clk_i   (clk_i),
2920:     .rst_ni  (rst_ni),
2921: 
2922:     // from register interface
2923:     .we     (debug_we),
2924:     .wd     (debug_invalid_digest_wd),
2925: 
2926:     // from internal hardware
2927:     .de     (hw2reg.debug.invalid_digest.de),
2928:     .d      (hw2reg.debug.invalid_digest.d),
2929: 
2930:     // to internal hardware
2931:     .qe     (),
2932:     .q      (),
2933:     .ds     (),
2934: 
2935:     // to register interface (read)
2936:     .qs     (debug_invalid_digest_qs)
2937:   );
2938: 
2939: 
2940: 
2941:   logic [62:0] addr_hit;
2942:   always_comb begin
2943:     addr_hit = '0;
2944:     addr_hit[ 0] = (reg_addr == KEYMGR_INTR_STATE_OFFSET);
2945:     addr_hit[ 1] = (reg_addr == KEYMGR_INTR_ENABLE_OFFSET);
2946:     addr_hit[ 2] = (reg_addr == KEYMGR_INTR_TEST_OFFSET);
2947:     addr_hit[ 3] = (reg_addr == KEYMGR_ALERT_TEST_OFFSET);
2948:     addr_hit[ 4] = (reg_addr == KEYMGR_CFG_REGWEN_OFFSET);
2949:     addr_hit[ 5] = (reg_addr == KEYMGR_START_OFFSET);
2950:     addr_hit[ 6] = (reg_addr == KEYMGR_CONTROL_SHADOWED_OFFSET);
2951:     addr_hit[ 7] = (reg_addr == KEYMGR_SIDELOAD_CLEAR_OFFSET);
2952:     addr_hit[ 8] = (reg_addr == KEYMGR_RESEED_INTERVAL_REGWEN_OFFSET);
2953:     addr_hit[ 9] = (reg_addr == KEYMGR_RESEED_INTERVAL_SHADOWED_OFFSET);
2954:     addr_hit[10] = (reg_addr == KEYMGR_SW_BINDING_REGWEN_OFFSET);
2955:     addr_hit[11] = (reg_addr == KEYMGR_SEALING_SW_BINDING_0_OFFSET);
2956:     addr_hit[12] = (reg_addr == KEYMGR_SEALING_SW_BINDING_1_OFFSET);
2957:     addr_hit[13] = (reg_addr == KEYMGR_SEALING_SW_BINDING_2_OFFSET);
2958:     addr_hit[14] = (reg_addr == KEYMGR_SEALING_SW_BINDING_3_OFFSET);
2959:     addr_hit[15] = (reg_addr == KEYMGR_SEALING_SW_BINDING_4_OFFSET);
2960:     addr_hit[16] = (reg_addr == KEYMGR_SEALING_SW_BINDING_5_OFFSET);
2961:     addr_hit[17] = (reg_addr == KEYMGR_SEALING_SW_BINDING_6_OFFSET);
2962:     addr_hit[18] = (reg_addr == KEYMGR_SEALING_SW_BINDING_7_OFFSET);
2963:     addr_hit[19] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_0_OFFSET);
2964:     addr_hit[20] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_1_OFFSET);
2965:     addr_hit[21] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_2_OFFSET);
2966:     addr_hit[22] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_3_OFFSET);
2967:     addr_hit[23] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_4_OFFSET);
2968:     addr_hit[24] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_5_OFFSET);
2969:     addr_hit[25] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_6_OFFSET);
2970:     addr_hit[26] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_7_OFFSET);
2971:     addr_hit[27] = (reg_addr == KEYMGR_SALT_0_OFFSET);
2972:     addr_hit[28] = (reg_addr == KEYMGR_SALT_1_OFFSET);
2973:     addr_hit[29] = (reg_addr == KEYMGR_SALT_2_OFFSET);
2974:     addr_hit[30] = (reg_addr == KEYMGR_SALT_3_OFFSET);
2975:     addr_hit[31] = (reg_addr == KEYMGR_SALT_4_OFFSET);
2976:     addr_hit[32] = (reg_addr == KEYMGR_SALT_5_OFFSET);
2977:     addr_hit[33] = (reg_addr == KEYMGR_SALT_6_OFFSET);
2978:     addr_hit[34] = (reg_addr == KEYMGR_SALT_7_OFFSET);
2979:     addr_hit[35] = (reg_addr == KEYMGR_KEY_VERSION_OFFSET);
2980:     addr_hit[36] = (reg_addr == KEYMGR_MAX_CREATOR_KEY_VER_REGWEN_OFFSET);
2981:     addr_hit[37] = (reg_addr == KEYMGR_MAX_CREATOR_KEY_VER_SHADOWED_OFFSET);
2982:     addr_hit[38] = (reg_addr == KEYMGR_MAX_OWNER_INT_KEY_VER_REGWEN_OFFSET);
2983:     addr_hit[39] = (reg_addr == KEYMGR_MAX_OWNER_INT_KEY_VER_SHADOWED_OFFSET);
2984:     addr_hit[40] = (reg_addr == KEYMGR_MAX_OWNER_KEY_VER_REGWEN_OFFSET);
2985:     addr_hit[41] = (reg_addr == KEYMGR_MAX_OWNER_KEY_VER_SHADOWED_OFFSET);
2986:     addr_hit[42] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_0_OFFSET);
2987:     addr_hit[43] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_1_OFFSET);
2988:     addr_hit[44] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_2_OFFSET);
2989:     addr_hit[45] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_3_OFFSET);
2990:     addr_hit[46] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_4_OFFSET);
2991:     addr_hit[47] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_5_OFFSET);
2992:     addr_hit[48] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_6_OFFSET);
2993:     addr_hit[49] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_7_OFFSET);
2994:     addr_hit[50] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_0_OFFSET);
2995:     addr_hit[51] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_1_OFFSET);
2996:     addr_hit[52] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_2_OFFSET);
2997:     addr_hit[53] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_3_OFFSET);
2998:     addr_hit[54] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_4_OFFSET);
2999:     addr_hit[55] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_5_OFFSET);
3000:     addr_hit[56] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_6_OFFSET);
3001:     addr_hit[57] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_7_OFFSET);
3002:     addr_hit[58] = (reg_addr == KEYMGR_WORKING_STATE_OFFSET);
3003:     addr_hit[59] = (reg_addr == KEYMGR_OP_STATUS_OFFSET);
3004:     addr_hit[60] = (reg_addr == KEYMGR_ERR_CODE_OFFSET);
3005:     addr_hit[61] = (reg_addr == KEYMGR_FAULT_STATUS_OFFSET);
3006:     addr_hit[62] = (reg_addr == KEYMGR_DEBUG_OFFSET);
3007:   end
3008: 
3009:   assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;
3010: 
3011:   // Check sub-word write is permitted
3012:   always_comb begin
3013:     wr_err = (reg_we &
3014:               ((addr_hit[ 0] & (|(KEYMGR_PERMIT[ 0] & ~reg_be))) |
3015:                (addr_hit[ 1] & (|(KEYMGR_PERMIT[ 1] & ~reg_be))) |
3016:                (addr_hit[ 2] & (|(KEYMGR_PERMIT[ 2] & ~reg_be))) |
3017:                (addr_hit[ 3] & (|(KEYMGR_PERMIT[ 3] & ~reg_be))) |
3018:                (addr_hit[ 4] & (|(KEYMGR_PERMIT[ 4] & ~reg_be))) |
3019:                (addr_hit[ 5] & (|(KEYMGR_PERMIT[ 5] & ~reg_be))) |
3020:                (addr_hit[ 6] & (|(KEYMGR_PERMIT[ 6] & ~reg_be))) |
3021:                (addr_hit[ 7] & (|(KEYMGR_PERMIT[ 7] & ~reg_be))) |
3022:                (addr_hit[ 8] & (|(KEYMGR_PERMIT[ 8] & ~reg_be))) |
3023:                (addr_hit[ 9] & (|(KEYMGR_PERMIT[ 9] & ~reg_be))) |
3024:                (addr_hit[10] & (|(KEYMGR_PERMIT[10] & ~reg_be))) |
3025:                (addr_hit[11] & (|(KEYMGR_PERMIT[11] & ~reg_be))) |
3026:                (addr_hit[12] & (|(KEYMGR_PERMIT[12] & ~reg_be))) |
3027:                (addr_hit[13] & (|(KEYMGR_PERMIT[13] & ~reg_be))) |
3028:                (addr_hit[14] & (|(KEYMGR_PERMIT[14] & ~reg_be))) |
3029:                (addr_hit[15] & (|(KEYMGR_PERMIT[15] & ~reg_be))) |
3030:                (addr_hit[16] & (|(KEYMGR_PERMIT[16] & ~reg_be))) |
3031:                (addr_hit[17] & (|(KEYMGR_PERMIT[17] & ~reg_be))) |
3032:                (addr_hit[18] & (|(KEYMGR_PERMIT[18] & ~reg_be))) |
3033:                (addr_hit[19] & (|(KEYMGR_PERMIT[19] & ~reg_be))) |
3034:                (addr_hit[20] & (|(KEYMGR_PERMIT[20] & ~reg_be))) |
3035:                (addr_hit[21] & (|(KEYMGR_PERMIT[21] & ~reg_be))) |
3036:                (addr_hit[22] & (|(KEYMGR_PERMIT[22] & ~reg_be))) |
3037:                (addr_hit[23] & (|(KEYMGR_PERMIT[23] & ~reg_be))) |
3038:                (addr_hit[24] & (|(KEYMGR_PERMIT[24] & ~reg_be))) |
3039:                (addr_hit[25] & (|(KEYMGR_PERMIT[25] & ~reg_be))) |
3040:                (addr_hit[26] & (|(KEYMGR_PERMIT[26] & ~reg_be))) |
3041:                (addr_hit[27] & (|(KEYMGR_PERMIT[27] & ~reg_be))) |
3042:                (addr_hit[28] & (|(KEYMGR_PERMIT[28] & ~reg_be))) |
3043:                (addr_hit[29] & (|(KEYMGR_PERMIT[29] & ~reg_be))) |
3044:                (addr_hit[30] & (|(KEYMGR_PERMIT[30] & ~reg_be))) |
3045:                (addr_hit[31] & (|(KEYMGR_PERMIT[31] & ~reg_be))) |
3046:                (addr_hit[32] & (|(KEYMGR_PERMIT[32] & ~reg_be))) |
3047:                (addr_hit[33] & (|(KEYMGR_PERMIT[33] & ~reg_be))) |
3048:                (addr_hit[34] & (|(KEYMGR_PERMIT[34] & ~reg_be))) |
3049:                (addr_hit[35] & (|(KEYMGR_PERMIT[35] & ~reg_be))) |
3050:                (addr_hit[36] & (|(KEYMGR_PERMIT[36] & ~reg_be))) |
3051:                (addr_hit[37] & (|(KEYMGR_PERMIT[37] & ~reg_be))) |
3052:                (addr_hit[38] & (|(KEYMGR_PERMIT[38] & ~reg_be))) |
3053:                (addr_hit[39] & (|(KEYMGR_PERMIT[39] & ~reg_be))) |
3054:                (addr_hit[40] & (|(KEYMGR_PERMIT[40] & ~reg_be))) |
3055:                (addr_hit[41] & (|(KEYMGR_PERMIT[41] & ~reg_be))) |
3056:                (addr_hit[42] & (|(KEYMGR_PERMIT[42] & ~reg_be))) |
3057:                (addr_hit[43] & (|(KEYMGR_PERMIT[43] & ~reg_be))) |
3058:                (addr_hit[44] & (|(KEYMGR_PERMIT[44] & ~reg_be))) |
3059:                (addr_hit[45] & (|(KEYMGR_PERMIT[45] & ~reg_be))) |
3060:                (addr_hit[46] & (|(KEYMGR_PERMIT[46] & ~reg_be))) |
3061:                (addr_hit[47] & (|(KEYMGR_PERMIT[47] & ~reg_be))) |
3062:                (addr_hit[48] & (|(KEYMGR_PERMIT[48] & ~reg_be))) |
3063:                (addr_hit[49] & (|(KEYMGR_PERMIT[49] & ~reg_be))) |
3064:                (addr_hit[50] & (|(KEYMGR_PERMIT[50] & ~reg_be))) |
3065:                (addr_hit[51] & (|(KEYMGR_PERMIT[51] & ~reg_be))) |
3066:                (addr_hit[52] & (|(KEYMGR_PERMIT[52] & ~reg_be))) |
3067:                (addr_hit[53] & (|(KEYMGR_PERMIT[53] & ~reg_be))) |
3068:                (addr_hit[54] & (|(KEYMGR_PERMIT[54] & ~reg_be))) |
3069:                (addr_hit[55] & (|(KEYMGR_PERMIT[55] & ~reg_be))) |
3070:                (addr_hit[56] & (|(KEYMGR_PERMIT[56] & ~reg_be))) |
3071:                (addr_hit[57] & (|(KEYMGR_PERMIT[57] & ~reg_be))) |
3072:                (addr_hit[58] & (|(KEYMGR_PERMIT[58] & ~reg_be))) |
3073:                (addr_hit[59] & (|(KEYMGR_PERMIT[59] & ~reg_be))) |
3074:                (addr_hit[60] & (|(KEYMGR_PERMIT[60] & ~reg_be))) |
3075:                (addr_hit[61] & (|(KEYMGR_PERMIT[61] & ~reg_be))) |
3076:                (addr_hit[62] & (|(KEYMGR_PERMIT[62] & ~reg_be)))));
3077:   end
3078: 
3079:   // Generate write-enables
3080:   assign intr_state_we = addr_hit[0] & reg_we & !reg_error;
3081: 
3082:   assign intr_state_wd = reg_wdata[0];
3083:   assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;
3084: 
3085:   assign intr_enable_wd = reg_wdata[0];
3086:   assign intr_test_we = addr_hit[2] & reg_we & !reg_error;
3087: 
3088:   assign intr_test_wd = reg_wdata[0];
3089:   assign alert_test_we = addr_hit[3] & reg_we & !reg_error;
3090: 
3091:   assign alert_test_recov_operation_err_wd = reg_wdata[0];
3092: 
3093:   assign alert_test_fatal_fault_err_wd = reg_wdata[1];
3094:   assign cfg_regwen_re = addr_hit[4] & reg_re & !reg_error;
3095:   assign start_we = addr_hit[5] & reg_we & !reg_error;
3096: 
3097:   assign start_wd = reg_wdata[0];
3098:   assign control_shadowed_re = addr_hit[6] & reg_re & !reg_error;
3099:   assign control_shadowed_we = addr_hit[6] & reg_we & !reg_error;
3100: 
3101:   assign control_shadowed_operation_wd = reg_wdata[6:4];
3102: 
3103:   assign control_shadowed_cdi_sel_wd = reg_wdata[7];
3104: 
3105:   assign control_shadowed_dest_sel_wd = reg_wdata[13:12];
3106:   assign sideload_clear_we = addr_hit[7] & reg_we & !reg_error;
3107: 
3108:   assign sideload_clear_wd = reg_wdata[2:0];
3109:   assign reseed_interval_regwen_we = addr_hit[8] & reg_we & !reg_error;
3110: 
3111:   assign reseed_interval_regwen_wd = reg_wdata[0];
3112:   assign reseed_interval_shadowed_re = addr_hit[9] & reg_re & !reg_error;
3113:   assign reseed_interval_shadowed_we = addr_hit[9] & reg_we & !reg_error;
3114: 
3115:   assign reseed_interval_shadowed_wd = reg_wdata[15:0];
3116:   assign sw_binding_regwen_re = addr_hit[10] & reg_re & !reg_error;
3117:   assign sw_binding_regwen_we = addr_hit[10] & reg_we & !reg_error;
3118: 
3119:   assign sw_binding_regwen_wd = reg_wdata[0];
3120:   assign sealing_sw_binding_0_we = addr_hit[11] & reg_we & !reg_error;
3121: 
3122:   assign sealing_sw_binding_0_wd = reg_wdata[31:0];
3123:   assign sealing_sw_binding_1_we = addr_hit[12] & reg_we & !reg_error;
3124: 
3125:   assign sealing_sw_binding_1_wd = reg_wdata[31:0];
3126:   assign sealing_sw_binding_2_we = addr_hit[13] & reg_we & !reg_error;
3127: 
3128:   assign sealing_sw_binding_2_wd = reg_wdata[31:0];
3129:   assign sealing_sw_binding_3_we = addr_hit[14] & reg_we & !reg_error;
3130: 
3131:   assign sealing_sw_binding_3_wd = reg_wdata[31:0];
3132:   assign sealing_sw_binding_4_we = addr_hit[15] & reg_we & !reg_error;
3133: 
3134:   assign sealing_sw_binding_4_wd = reg_wdata[31:0];
3135:   assign sealing_sw_binding_5_we = addr_hit[16] & reg_we & !reg_error;
3136: 
3137:   assign sealing_sw_binding_5_wd = reg_wdata[31:0];
3138:   assign sealing_sw_binding_6_we = addr_hit[17] & reg_we & !reg_error;
3139: 
3140:   assign sealing_sw_binding_6_wd = reg_wdata[31:0];
3141:   assign sealing_sw_binding_7_we = addr_hit[18] & reg_we & !reg_error;
3142: 
3143:   assign sealing_sw_binding_7_wd = reg_wdata[31:0];
3144:   assign attest_sw_binding_0_we = addr_hit[19] & reg_we & !reg_error;
3145: 
3146:   assign attest_sw_binding_0_wd = reg_wdata[31:0];
3147:   assign attest_sw_binding_1_we = addr_hit[20] & reg_we & !reg_error;
3148: 
3149:   assign attest_sw_binding_1_wd = reg_wdata[31:0];
3150:   assign attest_sw_binding_2_we = addr_hit[21] & reg_we & !reg_error;
3151: 
3152:   assign attest_sw_binding_2_wd = reg_wdata[31:0];
3153:   assign attest_sw_binding_3_we = addr_hit[22] & reg_we & !reg_error;
3154: 
3155:   assign attest_sw_binding_3_wd = reg_wdata[31:0];
3156:   assign attest_sw_binding_4_we = addr_hit[23] & reg_we & !reg_error;
3157: 
3158:   assign attest_sw_binding_4_wd = reg_wdata[31:0];
3159:   assign attest_sw_binding_5_we = addr_hit[24] & reg_we & !reg_error;
3160: 
3161:   assign attest_sw_binding_5_wd = reg_wdata[31:0];
3162:   assign attest_sw_binding_6_we = addr_hit[25] & reg_we & !reg_error;
3163: 
3164:   assign attest_sw_binding_6_wd = reg_wdata[31:0];
3165:   assign attest_sw_binding_7_we = addr_hit[26] & reg_we & !reg_error;
3166: 
3167:   assign attest_sw_binding_7_wd = reg_wdata[31:0];
3168:   assign salt_0_we = addr_hit[27] & reg_we & !reg_error;
3169: 
3170:   assign salt_0_wd = reg_wdata[31:0];
3171:   assign salt_1_we = addr_hit[28] & reg_we & !reg_error;
3172: 
3173:   assign salt_1_wd = reg_wdata[31:0];
3174:   assign salt_2_we = addr_hit[29] & reg_we & !reg_error;
3175: 
3176:   assign salt_2_wd = reg_wdata[31:0];
3177:   assign salt_3_we = addr_hit[30] & reg_we & !reg_error;
3178: 
3179:   assign salt_3_wd = reg_wdata[31:0];
3180:   assign salt_4_we = addr_hit[31] & reg_we & !reg_error;
3181: 
3182:   assign salt_4_wd = reg_wdata[31:0];
3183:   assign salt_5_we = addr_hit[32] & reg_we & !reg_error;
3184: 
3185:   assign salt_5_wd = reg_wdata[31:0];
3186:   assign salt_6_we = addr_hit[33] & reg_we & !reg_error;
3187: 
3188:   assign salt_6_wd = reg_wdata[31:0];
3189:   assign salt_7_we = addr_hit[34] & reg_we & !reg_error;
3190: 
3191:   assign salt_7_wd = reg_wdata[31:0];
3192:   assign key_version_we = addr_hit[35] & reg_we & !reg_error;
3193: 
3194:   assign key_version_wd = reg_wdata[31:0];
3195:   assign max_creator_key_ver_regwen_we = addr_hit[36] & reg_we & !reg_error;
3196: 
3197:   assign max_creator_key_ver_regwen_wd = reg_wdata[0];
3198:   assign max_creator_key_ver_shadowed_re = addr_hit[37] & reg_re & !reg_error;
3199:   assign max_creator_key_ver_shadowed_we = addr_hit[37] & reg_we & !reg_error;
3200: 
3201:   assign max_creator_key_ver_shadowed_wd = reg_wdata[31:0];
3202:   assign max_owner_int_key_ver_regwen_we = addr_hit[38] & reg_we & !reg_error;
3203: 
3204:   assign max_owner_int_key_ver_regwen_wd = reg_wdata[0];
3205:   assign max_owner_int_key_ver_shadowed_re = addr_hit[39] & reg_re & !reg_error;
3206:   assign max_owner_int_key_ver_shadowed_we = addr_hit[39] & reg_we & !reg_error;
3207: 
3208:   assign max_owner_int_key_ver_shadowed_wd = reg_wdata[31:0];
3209:   assign max_owner_key_ver_regwen_we = addr_hit[40] & reg_we & !reg_error;
3210: 
3211:   assign max_owner_key_ver_regwen_wd = reg_wdata[0];
3212:   assign max_owner_key_ver_shadowed_re = addr_hit[41] & reg_re & !reg_error;
3213:   assign max_owner_key_ver_shadowed_we = addr_hit[41] & reg_we & !reg_error;
3214: 
3215:   assign max_owner_key_ver_shadowed_wd = reg_wdata[31:0];
3216:   assign sw_share0_output_0_re = addr_hit[42] & reg_re & !reg_error;
3217: 
3218:   assign sw_share0_output_0_wd = '1;
3219:   assign sw_share0_output_1_re = addr_hit[43] & reg_re & !reg_error;
3220: 
3221:   assign sw_share0_output_1_wd = '1;
3222:   assign sw_share0_output_2_re = addr_hit[44] & reg_re & !reg_error;
3223: 
3224:   assign sw_share0_output_2_wd = '1;
3225:   assign sw_share0_output_3_re = addr_hit[45] & reg_re & !reg_error;
3226: 
3227:   assign sw_share0_output_3_wd = '1;
3228:   assign sw_share0_output_4_re = addr_hit[46] & reg_re & !reg_error;
3229: 
3230:   assign sw_share0_output_4_wd = '1;
3231:   assign sw_share0_output_5_re = addr_hit[47] & reg_re & !reg_error;
3232: 
3233:   assign sw_share0_output_5_wd = '1;
3234:   assign sw_share0_output_6_re = addr_hit[48] & reg_re & !reg_error;
3235: 
3236:   assign sw_share0_output_6_wd = '1;
3237:   assign sw_share0_output_7_re = addr_hit[49] & reg_re & !reg_error;
3238: 
3239:   assign sw_share0_output_7_wd = '1;
3240:   assign sw_share1_output_0_re = addr_hit[50] & reg_re & !reg_error;
3241: 
3242:   assign sw_share1_output_0_wd = '1;
3243:   assign sw_share1_output_1_re = addr_hit[51] & reg_re & !reg_error;
3244: 
3245:   assign sw_share1_output_1_wd = '1;
3246:   assign sw_share1_output_2_re = addr_hit[52] & reg_re & !reg_error;
3247: 
3248:   assign sw_share1_output_2_wd = '1;
3249:   assign sw_share1_output_3_re = addr_hit[53] & reg_re & !reg_error;
3250: 
3251:   assign sw_share1_output_3_wd = '1;
3252:   assign sw_share1_output_4_re = addr_hit[54] & reg_re & !reg_error;
3253: 
3254:   assign sw_share1_output_4_wd = '1;
3255:   assign sw_share1_output_5_re = addr_hit[55] & reg_re & !reg_error;
3256: 
3257:   assign sw_share1_output_5_wd = '1;
3258:   assign sw_share1_output_6_re = addr_hit[56] & reg_re & !reg_error;
3259: 
3260:   assign sw_share1_output_6_wd = '1;
3261:   assign sw_share1_output_7_re = addr_hit[57] & reg_re & !reg_error;
3262: 
3263:   assign sw_share1_output_7_wd = '1;
3264:   assign op_status_we = addr_hit[59] & reg_we & !reg_error;
3265: 
3266:   assign op_status_wd = reg_wdata[1:0];
3267:   assign err_code_we = addr_hit[60] & reg_we & !reg_error;
3268: 
3269:   assign err_code_invalid_op_wd = reg_wdata[0];
3270: 
3271:   assign err_code_invalid_kmac_input_wd = reg_wdata[1];
3272: 
3273:   assign err_code_invalid_shadow_update_wd = reg_wdata[2];
3274:   assign debug_we = addr_hit[62] & reg_we & !reg_error;
3275: 
3276:   assign debug_invalid_creator_seed_wd = reg_wdata[0];
3277: 
3278:   assign debug_invalid_owner_seed_wd = reg_wdata[1];
3279: 
3280:   assign debug_invalid_dev_id_wd = reg_wdata[2];
3281: 
3282:   assign debug_invalid_health_state_wd = reg_wdata[3];
3283: 
3284:   assign debug_invalid_key_version_wd = reg_wdata[4];
3285: 
3286:   assign debug_invalid_key_wd = reg_wdata[5];
3287: 
3288:   assign debug_invalid_digest_wd = reg_wdata[6];
3289: 
3290:   // Assign write-enables to checker logic vector.
3291:   always_comb begin
3292:     reg_we_check = '0;
3293:     reg_we_check[0] = intr_state_we;
3294:     reg_we_check[1] = intr_enable_we;
3295:     reg_we_check[2] = intr_test_we;
3296:     reg_we_check[3] = alert_test_we;
3297:     reg_we_check[4] = 1'b0;
3298:     reg_we_check[5] = start_gated_we;
3299:     reg_we_check[6] = control_shadowed_gated_we;
3300:     reg_we_check[7] = sideload_clear_gated_we;
3301:     reg_we_check[8] = reseed_interval_regwen_we;
3302:     reg_we_check[9] = reseed_interval_shadowed_gated_we;
3303:     reg_we_check[10] = sw_binding_regwen_we;
3304:     reg_we_check[11] = sealing_sw_binding_0_gated_we;
3305:     reg_we_check[12] = sealing_sw_binding_1_gated_we;
3306:     reg_we_check[13] = sealing_sw_binding_2_gated_we;
3307:     reg_we_check[14] = sealing_sw_binding_3_gated_we;
3308:     reg_we_check[15] = sealing_sw_binding_4_gated_we;
3309:     reg_we_check[16] = sealing_sw_binding_5_gated_we;
3310:     reg_we_check[17] = sealing_sw_binding_6_gated_we;
3311:     reg_we_check[18] = sealing_sw_binding_7_gated_we;
3312:     reg_we_check[19] = attest_sw_binding_0_gated_we;
3313:     reg_we_check[20] = attest_sw_binding_1_gated_we;
3314:     reg_we_check[21] = attest_sw_binding_2_gated_we;
3315:     reg_we_check[22] = attest_sw_binding_3_gated_we;
3316:     reg_we_check[23] = attest_sw_binding_4_gated_we;
3317:     reg_we_check[24] = attest_sw_binding_5_gated_we;
3318:     reg_we_check[25] = attest_sw_binding_6_gated_we;
3319:     reg_we_check[26] = attest_sw_binding_7_gated_we;
3320:     reg_we_check[27] = salt_0_gated_we;
3321:     reg_we_check[28] = salt_1_gated_we;
3322:     reg_we_check[29] = salt_2_gated_we;
3323:     reg_we_check[30] = salt_3_gated_we;
3324:     reg_we_check[31] = salt_4_gated_we;
3325:     reg_we_check[32] = salt_5_gated_we;
3326:     reg_we_check[33] = salt_6_gated_we;
3327:     reg_we_check[34] = salt_7_gated_we;
3328:     reg_we_check[35] = key_version_gated_we;
3329:     reg_we_check[36] = max_creator_key_ver_regwen_we;
3330:     reg_we_check[37] = max_creator_key_ver_shadowed_gated_we;
3331:     reg_we_check[38] = max_owner_int_key_ver_regwen_we;
3332:     reg_we_check[39] = max_owner_int_key_ver_shadowed_gated_we;
3333:     reg_we_check[40] = max_owner_key_ver_regwen_we;
3334:     reg_we_check[41] = max_owner_key_ver_shadowed_gated_we;
3335:     reg_we_check[42] = 1'b0;
3336:     reg_we_check[43] = 1'b0;
3337:     reg_we_check[44] = 1'b0;
3338:     reg_we_check[45] = 1'b0;
3339:     reg_we_check[46] = 1'b0;
3340:     reg_we_check[47] = 1'b0;
3341:     reg_we_check[48] = 1'b0;
3342:     reg_we_check[49] = 1'b0;
3343:     reg_we_check[50] = 1'b0;
3344:     reg_we_check[51] = 1'b0;
3345:     reg_we_check[52] = 1'b0;
3346:     reg_we_check[53] = 1'b0;
3347:     reg_we_check[54] = 1'b0;
3348:     reg_we_check[55] = 1'b0;
3349:     reg_we_check[56] = 1'b0;
3350:     reg_we_check[57] = 1'b0;
3351:     reg_we_check[58] = 1'b0;
3352:     reg_we_check[59] = op_status_we;
3353:     reg_we_check[60] = err_code_we;
3354:     reg_we_check[61] = 1'b0;
3355:     reg_we_check[62] = debug_we;
3356:   end
3357: 
3358:   // Read data return
3359:   always_comb begin
3360:     reg_rdata_next = '0;
3361:     unique case (1'b1)
3362:       addr_hit[0]: begin
3363:         reg_rdata_next[0] = intr_state_qs;
3364:       end
3365: 
3366:       addr_hit[1]: begin
3367:         reg_rdata_next[0] = intr_enable_qs;
3368:       end
3369: 
3370:       addr_hit[2]: begin
3371:         reg_rdata_next[0] = '0;
3372:       end
3373: 
3374:       addr_hit[3]: begin
3375:         reg_rdata_next[0] = '0;
3376:         reg_rdata_next[1] = '0;
3377:       end
3378: 
3379:       addr_hit[4]: begin
3380:         reg_rdata_next[0] = cfg_regwen_qs;
3381:       end
3382: 
3383:       addr_hit[5]: begin
3384:         reg_rdata_next[0] = start_qs;
3385:       end
3386: 
3387:       addr_hit[6]: begin
3388:         reg_rdata_next[6:4] = control_shadowed_operation_qs;
3389:         reg_rdata_next[7] = control_shadowed_cdi_sel_qs;
3390:         reg_rdata_next[13:12] = control_shadowed_dest_sel_qs;
3391:       end
3392: 
3393:       addr_hit[7]: begin
3394:         reg_rdata_next[2:0] = sideload_clear_qs;
3395:       end
3396: 
3397:       addr_hit[8]: begin
3398:         reg_rdata_next[0] = reseed_interval_regwen_qs;
3399:       end
3400: 
3401:       addr_hit[9]: begin
3402:         reg_rdata_next[15:0] = reseed_interval_shadowed_qs;
3403:       end
3404: 
3405:       addr_hit[10]: begin
3406:         reg_rdata_next[0] = sw_binding_regwen_qs;
3407:       end
3408: 
3409:       addr_hit[11]: begin
3410:         reg_rdata_next[31:0] = sealing_sw_binding_0_qs;
3411:       end
3412: 
3413:       addr_hit[12]: begin
3414:         reg_rdata_next[31:0] = sealing_sw_binding_1_qs;
3415:       end
3416: 
3417:       addr_hit[13]: begin
3418:         reg_rdata_next[31:0] = sealing_sw_binding_2_qs;
3419:       end
3420: 
3421:       addr_hit[14]: begin
3422:         reg_rdata_next[31:0] = sealing_sw_binding_3_qs;
3423:       end
3424: 
3425:       addr_hit[15]: begin
3426:         reg_rdata_next[31:0] = sealing_sw_binding_4_qs;
3427:       end
3428: 
3429:       addr_hit[16]: begin
3430:         reg_rdata_next[31:0] = sealing_sw_binding_5_qs;
3431:       end
3432: 
3433:       addr_hit[17]: begin
3434:         reg_rdata_next[31:0] = sealing_sw_binding_6_qs;
3435:       end
3436: 
3437:       addr_hit[18]: begin
3438:         reg_rdata_next[31:0] = sealing_sw_binding_7_qs;
3439:       end
3440: 
3441:       addr_hit[19]: begin
3442:         reg_rdata_next[31:0] = attest_sw_binding_0_qs;
3443:       end
3444: 
3445:       addr_hit[20]: begin
3446:         reg_rdata_next[31:0] = attest_sw_binding_1_qs;
3447:       end
3448: 
3449:       addr_hit[21]: begin
3450:         reg_rdata_next[31:0] = attest_sw_binding_2_qs;
3451:       end
3452: 
3453:       addr_hit[22]: begin
3454:         reg_rdata_next[31:0] = attest_sw_binding_3_qs;
3455:       end
3456: 
3457:       addr_hit[23]: begin
3458:         reg_rdata_next[31:0] = attest_sw_binding_4_qs;
3459:       end
3460: 
3461:       addr_hit[24]: begin
3462:         reg_rdata_next[31:0] = attest_sw_binding_5_qs;
3463:       end
3464: 
3465:       addr_hit[25]: begin
3466:         reg_rdata_next[31:0] = attest_sw_binding_6_qs;
3467:       end
3468: 
3469:       addr_hit[26]: begin
3470:         reg_rdata_next[31:0] = attest_sw_binding_7_qs;
3471:       end
3472: 
3473:       addr_hit[27]: begin
3474:         reg_rdata_next[31:0] = salt_0_qs;
3475:       end
3476: 
3477:       addr_hit[28]: begin
3478:         reg_rdata_next[31:0] = salt_1_qs;
3479:       end
3480: 
3481:       addr_hit[29]: begin
3482:         reg_rdata_next[31:0] = salt_2_qs;
3483:       end
3484: 
3485:       addr_hit[30]: begin
3486:         reg_rdata_next[31:0] = salt_3_qs;
3487:       end
3488: 
3489:       addr_hit[31]: begin
3490:         reg_rdata_next[31:0] = salt_4_qs;
3491:       end
3492: 
3493:       addr_hit[32]: begin
3494:         reg_rdata_next[31:0] = salt_5_qs;
3495:       end
3496: 
3497:       addr_hit[33]: begin
3498:         reg_rdata_next[31:0] = salt_6_qs;
3499:       end
3500: 
3501:       addr_hit[34]: begin
3502:         reg_rdata_next[31:0] = salt_7_qs;
3503:       end
3504: 
3505:       addr_hit[35]: begin
3506:         reg_rdata_next[31:0] = key_version_qs;
3507:       end
3508: 
3509:       addr_hit[36]: begin
3510:         reg_rdata_next[0] = max_creator_key_ver_regwen_qs;
3511:       end
3512: 
3513:       addr_hit[37]: begin
3514:         reg_rdata_next[31:0] = max_creator_key_ver_shadowed_qs;
3515:       end
3516: 
3517:       addr_hit[38]: begin
3518:         reg_rdata_next[0] = max_owner_int_key_ver_regwen_qs;
3519:       end
3520: 
3521:       addr_hit[39]: begin
3522:         reg_rdata_next[31:0] = max_owner_int_key_ver_shadowed_qs;
3523:       end
3524: 
3525:       addr_hit[40]: begin
3526:         reg_rdata_next[0] = max_owner_key_ver_regwen_qs;
3527:       end
3528: 
3529:       addr_hit[41]: begin
3530:         reg_rdata_next[31:0] = max_owner_key_ver_shadowed_qs;
3531:       end
3532: 
3533:       addr_hit[42]: begin
3534:         reg_rdata_next[31:0] = sw_share0_output_0_qs;
3535:       end
3536: 
3537:       addr_hit[43]: begin
3538:         reg_rdata_next[31:0] = sw_share0_output_1_qs;
3539:       end
3540: 
3541:       addr_hit[44]: begin
3542:         reg_rdata_next[31:0] = sw_share0_output_2_qs;
3543:       end
3544: 
3545:       addr_hit[45]: begin
3546:         reg_rdata_next[31:0] = sw_share0_output_3_qs;
3547:       end
3548: 
3549:       addr_hit[46]: begin
3550:         reg_rdata_next[31:0] = sw_share0_output_4_qs;
3551:       end
3552: 
3553:       addr_hit[47]: begin
3554:         reg_rdata_next[31:0] = sw_share0_output_5_qs;
3555:       end
3556: 
3557:       addr_hit[48]: begin
3558:         reg_rdata_next[31:0] = sw_share0_output_6_qs;
3559:       end
3560: 
3561:       addr_hit[49]: begin
3562:         reg_rdata_next[31:0] = sw_share0_output_7_qs;
3563:       end
3564: 
3565:       addr_hit[50]: begin
3566:         reg_rdata_next[31:0] = sw_share1_output_0_qs;
3567:       end
3568: 
3569:       addr_hit[51]: begin
3570:         reg_rdata_next[31:0] = sw_share1_output_1_qs;
3571:       end
3572: 
3573:       addr_hit[52]: begin
3574:         reg_rdata_next[31:0] = sw_share1_output_2_qs;
3575:       end
3576: 
3577:       addr_hit[53]: begin
3578:         reg_rdata_next[31:0] = sw_share1_output_3_qs;
3579:       end
3580: 
3581:       addr_hit[54]: begin
3582:         reg_rdata_next[31:0] = sw_share1_output_4_qs;
3583:       end
3584: 
3585:       addr_hit[55]: begin
3586:         reg_rdata_next[31:0] = sw_share1_output_5_qs;
3587:       end
3588: 
3589:       addr_hit[56]: begin
3590:         reg_rdata_next[31:0] = sw_share1_output_6_qs;
3591:       end
3592: 
3593:       addr_hit[57]: begin
3594:         reg_rdata_next[31:0] = sw_share1_output_7_qs;
3595:       end
3596: 
3597:       addr_hit[58]: begin
3598:         reg_rdata_next[2:0] = working_state_qs;
3599:       end
3600: 
3601:       addr_hit[59]: begin
3602:         reg_rdata_next[1:0] = op_status_qs;
3603:       end
3604: 
3605:       addr_hit[60]: begin
3606:         reg_rdata_next[0] = err_code_invalid_op_qs;
3607:         reg_rdata_next[1] = err_code_invalid_kmac_input_qs;
3608:         reg_rdata_next[2] = err_code_invalid_shadow_update_qs;
3609:       end
3610: 
3611:       addr_hit[61]: begin
3612:         reg_rdata_next[0] = fault_status_cmd_qs;
3613:         reg_rdata_next[1] = fault_status_kmac_fsm_qs;
3614:         reg_rdata_next[2] = fault_status_kmac_done_qs;
3615:         reg_rdata_next[3] = fault_status_kmac_op_qs;
3616:         reg_rdata_next[4] = fault_status_kmac_out_qs;
3617:         reg_rdata_next[5] = fault_status_regfile_intg_qs;
3618:         reg_rdata_next[6] = fault_status_shadow_qs;
3619:         reg_rdata_next[7] = fault_status_ctrl_fsm_intg_qs;
3620:         reg_rdata_next[8] = fault_status_ctrl_fsm_chk_qs;
3621:         reg_rdata_next[9] = fault_status_ctrl_fsm_cnt_qs;
3622:         reg_rdata_next[10] = fault_status_reseed_cnt_qs;
3623:         reg_rdata_next[11] = fault_status_side_ctrl_fsm_qs;
3624:         reg_rdata_next[12] = fault_status_side_ctrl_sel_qs;
3625:         reg_rdata_next[13] = fault_status_key_ecc_qs;
3626:       end
3627: 
3628:       addr_hit[62]: begin
3629:         reg_rdata_next[0] = debug_invalid_creator_seed_qs;
3630:         reg_rdata_next[1] = debug_invalid_owner_seed_qs;
3631:         reg_rdata_next[2] = debug_invalid_dev_id_qs;
3632:         reg_rdata_next[3] = debug_invalid_health_state_qs;
3633:         reg_rdata_next[4] = debug_invalid_key_version_qs;
3634:         reg_rdata_next[5] = debug_invalid_key_qs;
3635:         reg_rdata_next[6] = debug_invalid_digest_qs;
3636:       end
3637: 
3638:       default: begin
3639:         reg_rdata_next = '1;
3640:       end
3641:     endcase
3642:   end
3643: 
3644:   // shadow busy
3645:   logic shadow_busy;
3646:   logic rst_done;
3647:   logic shadow_rst_done;
3648:   always_ff @(posedge clk_i or negedge rst_ni) begin
3649:     if (!rst_ni) begin
3650:       rst_done <= '0;
3651:     end else begin
3652:       rst_done <= 1'b1;
3653:     end
3654:   end
3655: 
3656:   always_ff @(posedge clk_i or negedge rst_shadowed_ni) begin
3657:     if (!rst_shadowed_ni) begin
3658:       shadow_rst_done <= '0;
3659:     end else begin
3660:       shadow_rst_done <= 1'b1;
3661:     end
3662:   end
3663: 
3664:   // both shadow and normal resets have been released
3665:   assign shadow_busy = ~(rst_done & shadow_rst_done);
3666: 
3667:   // Collect up storage and update errors
3668:   assign shadowed_storage_err_o = |{
3669:     control_shadowed_operation_storage_err,
3670:     control_shadowed_cdi_sel_storage_err,
3671:     control_shadowed_dest_sel_storage_err,
3672:     reseed_interval_shadowed_storage_err,
3673:     max_creator_key_ver_shadowed_storage_err,
3674:     max_owner_int_key_ver_shadowed_storage_err,
3675:     max_owner_key_ver_shadowed_storage_err
3676:   };
3677:   assign shadowed_update_err_o = |{
3678:     control_shadowed_operation_update_err,
3679:     control_shadowed_cdi_sel_update_err,
3680:     control_shadowed_dest_sel_update_err,
3681:     reseed_interval_shadowed_update_err,
3682:     max_creator_key_ver_shadowed_update_err,
3683:     max_owner_int_key_ver_shadowed_update_err,
3684:     max_owner_key_ver_shadowed_update_err
3685:   };
3686: 
3687:   // register busy
3688:   assign reg_busy = shadow_busy;
3689: 
3690:   // Unused signal tieoff
3691: 
3692:   // wdata / byte enable are not always fully used
3693:   // add a blanket unused statement to handle lint waivers
3694:   logic unused_wdata;
3695:   logic unused_be;
3696:   assign unused_wdata = ^reg_wdata;
3697:   assign unused_be = ^reg_be;
3698: 
3699:   // Assertions for Register Interface
3700:   `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
3701:   `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)
3702: 
3703:   `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)
3704: 
3705:   `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)
3706: 
3707:   // this is formulated as an assumption such that the FPV testbenches do disprove this
3708:   // property by mistake
3709:   //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)
3710: 
3711: endmodule

================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Register Top module auto-generated by `reggen`
6: 
7: `include "prim_assert.sv"
8: 
9: module keymgr_reg_top (
10:   input clk_i,
11:   input rst_ni,
12:   input rst_shadowed_ni,
13:   input  tlul_pkg::tl_h2d_t tl_i,
14:   output tlul_pkg::tl_d2h_t tl_o,
15:   // To HW
16:   output keymgr_reg_pkg::keymgr_reg2hw_t reg2hw, // Write
17:   input  keymgr_reg_pkg::keymgr_hw2reg_t hw2reg, // Read
18: 
19:   output logic shadowed_storage_err_o,
20:   output logic shadowed_update_err_o,
21: 
22:   // Integrity check errors
23:   output logic intg_err_o
24: );
25: 
26:   import keymgr_reg_pkg::* ;
27: 
28:   localparam int AW = 8;
29:   localparam int DW = 32;
30:   localparam int DBW = DW/8;                    // Byte Width
31: 
32:   // register signals
33:   logic           reg_we;
34:   logic           reg_re;
35:   logic [AW-1:0]  reg_addr;
36:   logic [DW-1:0]  reg_wdata;
37:   logic [DBW-1:0] reg_be;
38:   logic [DW-1:0]  reg_rdata;
39:   logic           reg_error;
40: 
41:   logic          addrmiss, wr_err;
42: 
43:   logic [DW-1:0] reg_rdata_next;
44:   logic reg_busy;
45: 
46:   tlul_pkg::tl_h2d_t tl_reg_h2d;
47:   tlul_pkg::tl_d2h_t tl_reg_d2h;
48: 
49: 
50:   // incoming payload check
51:   logic intg_err;
52:   tlul_cmd_intg_chk u_chk (
53:     .tl_i(tl_i),
54:     .err_o(intg_err)
55:   );
56: 
57:   // also check for spurious write enables
58:   logic reg_we_err;
59:   logic [62:0] reg_we_check;
60:   prim_reg_we_check #(
61:     .OneHotWidth(63)
62:   ) u_prim_reg_we_check (
63:     .clk_i(clk_i),
64:     .rst_ni(rst_ni),
65:     .oh_i  (reg_we_check),
66:     .en_i  (reg_we && !addrmiss),
67:     .err_o (reg_we_err)
68:   );
69: 
70:   logic err_q;
71:   always_ff @(posedge clk_i or negedge rst_ni) begin
72:     if (!rst_ni) begin
73:       err_q <= '0;
74:     end else if (intg_err || reg_we_err) begin
75:       err_q <= 1'b1;
76:     end
77:   end
78: 
79:   // integrity error output is permanent and should be used for alert generation
80:   // register errors are transactional
81:   assign intg_err_o = err_q | intg_err | reg_we_err;
82: 
83:   // outgoing integrity generation
84:   tlul_pkg::tl_d2h_t tl_o_pre;
85:   tlul_rsp_intg_gen #(
86:     .EnableRspIntgGen(1),
87:     .EnableDataIntgGen(1)
88:   ) u_rsp_intg_gen (
89:     .tl_i(tl_o_pre),
90:     .tl_o(tl_o)
91:   );
92: 
93:   assign tl_reg_h2d = tl_i;
94:   assign tl_o_pre   = tl_reg_d2h;
95: 
96:   tlul_adapter_reg #(
97:     .RegAw(AW),
98:     .RegDw(DW),
99:     .EnableDataIntgGen(0)
100:   ) u_reg_if (
101:     .clk_i  (clk_i),
102:     .rst_ni (rst_ni),
103: 
104:     .tl_i (tl_reg_h2d),
105:     .tl_o (tl_reg_d2h),
106: 
107:     .en_ifetch_i(prim_mubi_pkg::MuBi4False),
108:     .intg_error_o(),
109: 
110:     .we_o    (reg_we),
111:     .re_o    (reg_re),
112:     .addr_o  (reg_addr),
113:     .wdata_o (reg_wdata),
114:     .be_o    (reg_be),
115:     .busy_i  (reg_busy),
116:     .rdata_i (reg_rdata),
117:     .error_i (reg_error)
118:   );
119: 
120:   // cdc oversampling signals
121: 
122:   assign reg_rdata = reg_rdata_next ;
123:   assign reg_error = addrmiss | wr_err | intg_err;
124: 
125:   // Define SW related signals
126:   // Format: <reg>_<field>_{wd|we|qs}
127:   //        or <reg>_{wd|we|qs} if field == 1 or 0
128:   logic intr_state_we;
129:   logic intr_state_qs;
130:   logic intr_state_wd;
131:   logic intr_enable_we;
132:   logic intr_enable_qs;
133:   logic intr_enable_wd;
134:   logic intr_test_we;
135:   logic intr_test_wd;
136:   logic alert_test_we;
137:   logic alert_test_recov_operation_err_wd;
138:   logic alert_test_fatal_fault_err_wd;
139:   logic cfg_regwen_re;
140:   logic cfg_regwen_qs;
141:   logic start_we;
142:   logic start_qs;
143:   logic start_wd;
144:   logic control_shadowed_re;
145:   logic control_shadowed_we;
146:   logic [2:0] control_shadowed_operation_qs;
147:   logic [2:0] control_shadowed_operation_wd;
148:   logic control_shadowed_operation_storage_err;
149:   logic control_shadowed_operation_update_err;
150:   logic control_shadowed_cdi_sel_qs;
151:   logic control_shadowed_cdi_sel_wd;
152:   logic control_shadowed_cdi_sel_storage_err;
153:   logic control_shadowed_cdi_sel_update_err;
154:   logic [1:0] control_shadowed_dest_sel_qs;
155:   logic [1:0] control_shadowed_dest_sel_wd;
156:   logic control_shadowed_dest_sel_storage_err;
157:   logic control_shadowed_dest_sel_update_err;
158:   logic sideload_clear_we;
159:   logic [2:0] sideload_clear_qs;
160:   logic [2:0] sideload_clear_wd;
161:   logic reseed_interval_regwen_we;
162:   logic reseed_interval_regwen_qs;
163:   logic reseed_interval_regwen_wd;
164:   logic reseed_interval_shadowed_re;
165:   logic reseed_interval_shadowed_we;
166:   logic [15:0] reseed_interval_shadowed_qs;
167:   logic [15:0] reseed_interval_shadowed_wd;
168:   logic reseed_interval_shadowed_storage_err;
169:   logic reseed_interval_shadowed_update_err;
170:   logic sw_binding_regwen_re;
171:   logic sw_binding_regwen_we;
172:   logic sw_binding_regwen_qs;
173:   logic sw_binding_regwen_wd;
174:   logic sealing_sw_binding_0_we;
175:   logic [31:0] sealing_sw_binding_0_qs;
176:   logic [31:0] sealing_sw_binding_0_wd;
177:   logic sealing_sw_binding_1_we;
178:   logic [31:0] sealing_sw_binding_1_qs;
179:   logic [31:0] sealing_sw_binding_1_wd;
180:   logic sealing_sw_binding_2_we;
181:   logic [31:0] sealing_sw_binding_2_qs;
182:   logic [31:0] sealing_sw_binding_2_wd;
183:   logic sealing_sw_binding_3_we;
184:   logic [31:0] sealing_sw_binding_3_qs;
185:   logic [31:0] sealing_sw_binding_3_wd;
186:   logic sealing_sw_binding_4_we;
187:   logic [31:0] sealing_sw_binding_4_qs;
188:   logic [31:0] sealing_sw_binding_4_wd;
189:   logic sealing_sw_binding_5_we;
190:   logic [31:0] sealing_sw_binding_5_qs;
191:   logic [31:0] sealing_sw_binding_5_wd;
192:   logic sealing_sw_binding_6_we;
193:   logic [31:0] sealing_sw_binding_6_qs;
194:   logic [31:0] sealing_sw_binding_6_wd;
195:   logic sealing_sw_binding_7_we;
196:   logic [31:0] sealing_sw_binding_7_qs;
197:   logic [31:0] sealing_sw_binding_7_wd;
198:   logic attest_sw_binding_0_we;
199:   logic [31:0] attest_sw_binding_0_qs;
200:   logic [31:0] attest_sw_binding_0_wd;
201:   logic attest_sw_binding_1_we;
202:   logic [31:0] attest_sw_binding_1_qs;
203:   logic [31:0] attest_sw_binding_1_wd;
204:   logic attest_sw_binding_2_we;
205:   logic [31:0] attest_sw_binding_2_qs;
206:   logic [31:0] attest_sw_binding_2_wd;
207:   logic attest_sw_binding_3_we;
208:   logic [31:0] attest_sw_binding_3_qs;
209:   logic [31:0] attest_sw_binding_3_wd;
210:   logic attest_sw_binding_4_we;
211:   logic [31:0] attest_sw_binding_4_qs;
212:   logic [31:0] attest_sw_binding_4_wd;
213:   logic attest_sw_binding_5_we;
214:   logic [31:0] attest_sw_binding_5_qs;
215:   logic [31:0] attest_sw_binding_5_wd;
216:   logic attest_sw_binding_6_we;
217:   logic [31:0] attest_sw_binding_6_qs;
218:   logic [31:0] attest_sw_binding_6_wd;
219:   logic attest_sw_binding_7_we;
220:   logic [31:0] attest_sw_binding_7_qs;
221:   logic [31:0] attest_sw_binding_7_wd;
222:   logic salt_0_we;
223:   logic [31:0] salt_0_qs;
224:   logic [31:0] salt_0_wd;
225:   logic salt_1_we;
226:   logic [31:0] salt_1_qs;
227:   logic [31:0] salt_1_wd;
228:   logic salt_2_we;
229:   logic [31:0] salt_2_qs;
230:   logic [31:0] salt_2_wd;
231:   logic salt_3_we;
232:   logic [31:0] salt_3_qs;
233:   logic [31:0] salt_3_wd;
234:   logic salt_4_we;
235:   logic [31:0] salt_4_qs;
236:   logic [31:0] salt_4_wd;
237:   logic salt_5_we;
238:   logic [31:0] salt_5_qs;
239:   logic [31:0] salt_5_wd;
240:   logic salt_6_we;
241:   logic [31:0] salt_6_qs;
242:   logic [31:0] salt_6_wd;
243:   logic salt_7_we;
244:   logic [31:0] salt_7_qs;
245:   logic [31:0] salt_7_wd;
246:   logic key_version_we;
247:   logic [31:0] key_version_qs;
248:   logic [31:0] key_version_wd;
249:   logic max_creator_key_ver_regwen_we;
250:   logic max_creator_key_ver_regwen_qs;
251:   logic max_creator_key_ver_regwen_wd;
252:   logic max_creator_key_ver_shadowed_re;
253:   logic max_creator_key_ver_shadowed_we;
254:   logic [31:0] max_creator_key_ver_shadowed_qs;
255:   logic [31:0] max_creator_key_ver_shadowed_wd;
256:   logic max_creator_key_ver_shadowed_storage_err;
257:   logic max_creator_key_ver_shadowed_update_err;
258:   logic max_owner_int_key_ver_regwen_we;
259:   logic max_owner_int_key_ver_regwen_qs;
260:   logic max_owner_int_key_ver_regwen_wd;
261:   logic max_owner_int_key_ver_shadowed_re;
262:   logic max_owner_int_key_ver_shadowed_we;
263:   logic [31:0] max_owner_int_key_ver_shadowed_qs;
264:   logic [31:0] max_owner_int_key_ver_shadowed_wd;
265:   logic max_owner_int_key_ver_shadowed_storage_err;
266:   logic max_owner_int_key_ver_shadowed_update_err;
267:   logic max_owner_key_ver_regwen_we;
268:   logic max_owner_key_ver_regwen_qs;
269:   logic max_owner_key_ver_regwen_wd;
270:   logic max_owner_key_ver_shadowed_re;
271:   logic max_owner_key_ver_shadowed_we;
272:   logic [31:0] max_owner_key_ver_shadowed_qs;
273:   logic [31:0] max_owner_key_ver_shadowed_wd;
274:   logic max_owner_key_ver_shadowed_storage_err;
275:   logic max_owner_key_ver_shadowed_update_err;
276:   logic sw_share0_output_0_re;
277:   logic [31:0] sw_share0_output_0_qs;
278:   logic [31:0] sw_share0_output_0_wd;
279:   logic sw_share0_output_1_re;
280:   logic [31:0] sw_share0_output_1_qs;
281:   logic [31:0] sw_share0_output_1_wd;
282:   logic sw_share0_output_2_re;
283:   logic [31:0] sw_share0_output_2_qs;
284:   logic [31:0] sw_share0_output_2_wd;
285:   logic sw_share0_output_3_re;
286:   logic [31:0] sw_share0_output_3_qs;
287:   logic [31:0] sw_share0_output_3_wd;
288:   logic sw_share0_output_4_re;
289:   logic [31:0] sw_share0_output_4_qs;
290:   logic [31:0] sw_share0_output_4_wd;
291:   logic sw_share0_output_5_re;
292:   logic [31:0] sw_share0_output_5_qs;
293:   logic [31:0] sw_share0_output_5_wd;
294:   logic sw_share0_output_6_re;
295:   logic [31:0] sw_share0_output_6_qs;
296:   logic [31:0] sw_share0_output_6_wd;
297:   logic sw_share0_output_7_re;
298:   logic [31:0] sw_share0_output_7_qs;
299:   logic [31:0] sw_share0_output_7_wd;
300:   logic sw_share1_output_0_re;
301:   logic [31:0] sw_share1_output_0_qs;
302:   logic [31:0] sw_share1_output_0_wd;
303:   logic sw_share1_output_1_re;
304:   logic [31:0] sw_share1_output_1_qs;
305:   logic [31:0] sw_share1_output_1_wd;
306:   logic sw_share1_output_2_re;
307:   logic [31:0] sw_share1_output_2_qs;
308:   logic [31:0] sw_share1_output_2_wd;
309:   logic sw_share1_output_3_re;
310:   logic [31:0] sw_share1_output_3_qs;
311:   logic [31:0] sw_share1_output_3_wd;
312:   logic sw_share1_output_4_re;
313:   logic [31:0] sw_share1_output_4_qs;
314:   logic [31:0] sw_share1_output_4_wd;
315:   logic sw_share1_output_5_re;
316:   logic [31:0] sw_share1_output_5_qs;
317:   logic [31:0] sw_share1_output_5_wd;
318:   logic sw_share1_output_6_re;
319:   logic [31:0] sw_share1_output_6_qs;
320:   logic [31:0] sw_share1_output_6_wd;
321:   logic sw_share1_output_7_re;
322:   logic [31:0] sw_share1_output_7_qs;
323:   logic [31:0] sw_share1_output_7_wd;
324:   logic [2:0] working_state_qs;
325:   logic op_status_we;
326:   logic [1:0] op_status_qs;
327:   logic [1:0] op_status_wd;
328:   logic err_code_we;
329:   logic err_code_invalid_op_qs;
330:   logic err_code_invalid_op_wd;
331:   logic err_code_invalid_kmac_input_qs;
332:   logic err_code_invalid_kmac_input_wd;
333:   logic err_code_invalid_shadow_update_qs;
334:   logic err_code_invalid_shadow_update_wd;
335:   logic fault_status_cmd_qs;
336:   logic fault_status_kmac_fsm_qs;
337:   logic fault_status_kmac_done_qs;
338:   logic fault_status_kmac_op_qs;
339:   logic fault_status_kmac_out_qs;
340:   logic fault_status_regfile_intg_qs;
341:   logic fault_status_shadow_qs;
342:   logic fault_status_ctrl_fsm_intg_qs;
343:   logic fault_status_ctrl_fsm_chk_qs;
344:   logic fault_status_ctrl_fsm_cnt_qs;
345:   logic fault_status_reseed_cnt_qs;
346:   logic fault_status_side_ctrl_fsm_qs;
347:   logic fault_status_side_ctrl_sel_qs;
348:   logic fault_status_key_ecc_qs;
349:   logic debug_we;
350:   logic debug_invalid_creator_seed_qs;
351:   logic debug_invalid_creator_seed_wd;
352:   logic debug_invalid_owner_seed_qs;
353:   logic debug_invalid_owner_seed_wd;
354:   logic debug_invalid_dev_id_qs;
355:   logic debug_invalid_dev_id_wd;
356:   logic debug_invalid_health_state_qs;
357:   logic debug_invalid_health_state_wd;
358:   logic debug_invalid_key_version_qs;
359:   logic debug_invalid_key_version_wd;
360:   logic debug_invalid_key_qs;
361:   logic debug_invalid_key_wd;
362:   logic debug_invalid_digest_qs;
363:   logic debug_invalid_digest_wd;
364: 
365:   // Register instances
366:   // R[intr_state]: V(False)
367:   prim_subreg #(
368:     .DW      (1),
369:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
370:     .RESVAL  (1'h0),
371:     .Mubi    (1'b0)
372:   ) u_intr_state (
373:     .clk_i   (clk_i),
374:     .rst_ni  (rst_ni),
375: 
376:     // from register interface
377:     .we     (intr_state_we),
378:     .wd     (intr_state_wd),
379: 
380:     // from internal hardware
381:     .de     (hw2reg.intr_state.de),
382:     .d      (hw2reg.intr_state.d),
383: 
384:     // to internal hardware
385:     .qe     (),
386:     .q      (reg2hw.intr_state.q),
387:     .ds     (),
388: 
389:     // to register interface (read)
390:     .qs     (intr_state_qs)
391:   );
392: 
393: 
394:   // R[intr_enable]: V(False)
395:   prim_subreg #(
396:     .DW      (1),
397:     .SwAccess(prim_subreg_pkg::SwAccessRW),
398:     .RESVAL  (1'h0),
399:     .Mubi    (1'b0)
400:   ) u_intr_enable (
401:     .clk_i   (clk_i),
402:     .rst_ni  (rst_ni),
403: 
404:     // from register interface
405:     .we     (intr_enable_we),
406:     .wd     (intr_enable_wd),
407: 
408:     // from internal hardware
409:     .de     (1'b0),
410:     .d      ('0),
411: 
412:     // to internal hardware
413:     .qe     (),
414:     .q      (reg2hw.intr_enable.q),
415:     .ds     (),
416: 
417:     // to register interface (read)
418:     .qs     (intr_enable_qs)
419:   );
420: 
421: 
422:   // R[intr_test]: V(True)
423:   logic intr_test_qe;
424:   logic [0:0] intr_test_flds_we;
425:   assign intr_test_qe = &intr_test_flds_we;
426:   prim_subreg_ext #(
427:     .DW    (1)
428:   ) u_intr_test (
429:     .re     (1'b0),
430:     .we     (intr_test_we),
431:     .wd     (intr_test_wd),
432:     .d      ('0),
433:     .qre    (),
434:     .qe     (intr_test_flds_we[0]),
435:     .q      (reg2hw.intr_test.q),
436:     .ds     (),
437:     .qs     ()
438:   );
439:   assign reg2hw.intr_test.qe = intr_test_qe;
440: 
441: 
442:   // R[alert_test]: V(True)
443:   logic alert_test_qe;
444:   logic [1:0] alert_test_flds_we;
445:   assign alert_test_qe = &alert_test_flds_we;
446:   //   F[recov_operation_err]: 0:0
447:   prim_subreg_ext #(
448:     .DW    (1)
449:   ) u_alert_test_recov_operation_err (
450:     .re     (1'b0),
451:     .we     (alert_test_we),
452:     .wd     (alert_test_recov_operation_err_wd),
453:     .d      ('0),
454:     .qre    (),
455:     .qe     (alert_test_flds_we[0]),
456:     .q      (reg2hw.alert_test.recov_operation_err.q),
457:     .ds     (),
458:     .qs     ()
459:   );
460:   assign reg2hw.alert_test.recov_operation_err.qe = alert_test_qe;
461: 
462:   //   F[fatal_fault_err]: 1:1
463:   prim_subreg_ext #(
464:     .DW    (1)
465:   ) u_alert_test_fatal_fault_err (
466:     .re     (1'b0),
467:     .we     (alert_test_we),
468:     .wd     (alert_test_fatal_fault_err_wd),
469:     .d      ('0),
470:     .qre    (),
471:     .qe     (alert_test_flds_we[1]),
472:     .q      (reg2hw.alert_test.fatal_fault_err.q),
473:     .ds     (),
474:     .qs     ()
475:   );
476:   assign reg2hw.alert_test.fatal_fault_err.qe = alert_test_qe;
477: 
478: 
479:   // R[cfg_regwen]: V(True)
480:   prim_subreg_ext #(
481:     .DW    (1)
482:   ) u_cfg_regwen (
483:     .re     (cfg_regwen_re),
484:     .we     (1'b0),
485:     .wd     ('0),
486:     .d      (hw2reg.cfg_regwen.d),
487:     .qre    (),
488:     .qe     (),
489:     .q      (),
490:     .ds     (),
491:     .qs     (cfg_regwen_qs)
492:   );
493: 
494: 
495:   // R[start]: V(False)
496:   // Create REGWEN-gated WE signal
497:   logic start_gated_we;
498:   assign start_gated_we = start_we & cfg_regwen_qs;
499:   prim_subreg #(
500:     .DW      (1),
501:     .SwAccess(prim_subreg_pkg::SwAccessRW),
502:     .RESVAL  (1'h0),
503:     .Mubi    (1'b0)
504:   ) u_start (
505:     .clk_i   (clk_i),
506:     .rst_ni  (rst_ni),
507: 
508:     // from register interface
509:     .we     (start_gated_we),
510:     .wd     (start_wd),
511: 
512:     // from internal hardware
513:     .de     (hw2reg.start.de),
514:     .d      (hw2reg.start.d),
515: 
516:     // to internal hardware
517:     .qe     (),
518:     .q      (reg2hw.start.q),
519:     .ds     (),
520: 
521:     // to register interface (read)
522:     .qs     (start_qs)
523:   );
524: 
525: 
526:   // R[control_shadowed]: V(False)
527:   // Create REGWEN-gated WE signal
528:   logic control_shadowed_gated_we;
529:   assign control_shadowed_gated_we = control_shadowed_we & cfg_regwen_qs;
530:   //   F[operation]: 6:4
531:   prim_subreg_shadow #(
532:     .DW      (3),
533:     .SwAccess(prim_subreg_pkg::SwAccessRW),
534:     .RESVAL  (3'h1),
535:     .Mubi    (1'b0)
536:   ) u_control_shadowed_operation (
537:     .clk_i   (clk_i),
538:     .rst_ni  (rst_ni),
539:     .rst_shadowed_ni (rst_shadowed_ni),
540: 
541:     // from register interface
542:     .re     (control_shadowed_re),
543:     .we     (control_shadowed_gated_we),
544:     .wd     (control_shadowed_operation_wd),
545: 
546:     // from internal hardware
547:     .de     (1'b0),
548:     .d      ('0),
549: 
550:     // to internal hardware
551:     .qe     (),
552:     .q      (reg2hw.control_shadowed.operation.q),
553:     .ds     (),
554: 
555:     // to register interface (read)
556:     .qs     (control_shadowed_operation_qs),
557: 
558:     // Shadow register phase. Relevant for hwext only.
559:     .phase  (),
560: 
561:     // Shadow register error conditions
562:     .err_update  (control_shadowed_operation_update_err),
563:     .err_storage (control_shadowed_operation_storage_err)
564:   );
565: 
566:   //   F[cdi_sel]: 7:7
567:   prim_subreg_shadow #(
568:     .DW      (1),
569:     .SwAccess(prim_subreg_pkg::SwAccessRW),
570:     .RESVAL  (1'h0),
571:     .Mubi    (1'b0)
572:   ) u_control_shadowed_cdi_sel (
573:     .clk_i   (clk_i),
574:     .rst_ni  (rst_ni),
575:     .rst_shadowed_ni (rst_shadowed_ni),
576: 
577:     // from register interface
578:     .re     (control_shadowed_re),
579:     .we     (control_shadowed_gated_we),
580:     .wd     (control_shadowed_cdi_sel_wd),
581: 
582:     // from internal hardware
583:     .de     (1'b0),
584:     .d      ('0),
585: 
586:     // to internal hardware
587:     .qe     (),
588:     .q      (reg2hw.control_shadowed.cdi_sel.q),
589:     .ds     (),
590: 
591:     // to register interface (read)
592:     .qs     (control_shadowed_cdi_sel_qs),
593: 
594:     // Shadow register phase. Relevant for hwext only.
595:     .phase  (),
596: 
597:     // Shadow register error conditions
598:     .err_update  (control_shadowed_cdi_sel_update_err),
599:     .err_storage (control_shadowed_cdi_sel_storage_err)
600:   );
601: 
602:   //   F[dest_sel]: 13:12
603:   prim_subreg_shadow #(
604:     .DW      (2),
605:     .SwAccess(prim_subreg_pkg::SwAccessRW),
606:     .RESVAL  (2'h0),
607:     .Mubi    (1'b0)
608:   ) u_control_shadowed_dest_sel (
609:     .clk_i   (clk_i),
610:     .rst_ni  (rst_ni),
611:     .rst_shadowed_ni (rst_shadowed_ni),
612: 
613:     // from register interface
614:     .re     (control_shadowed_re),
615:     .we     (control_shadowed_gated_we),
616:     .wd     (control_shadowed_dest_sel_wd),
617: 
618:     // from internal hardware
619:     .de     (1'b0),
620:     .d      ('0),
621: 
622:     // to internal hardware
623:     .qe     (),
624:     .q      (reg2hw.control_shadowed.dest_sel.q),
625:     .ds     (),
626: 
627:     // to register interface (read)
628:     .qs     (control_shadowed_dest_sel_qs),
629: 
630:     // Shadow register phase. Relevant for hwext only.
631:     .phase  (),
632: 
633:     // Shadow register error conditions
634:     .err_update  (control_shadowed_dest_sel_update_err),
635:     .err_storage (control_shadowed_dest_sel_storage_err)
636:   );
637: 
638: 
639:   // R[sideload_clear]: V(False)
640:   // Create REGWEN-gated WE signal
641:   logic sideload_clear_gated_we;
642:   assign sideload_clear_gated_we = sideload_clear_we & cfg_regwen_qs;
643:   prim_subreg #(
644:     .DW      (3),
645:     .SwAccess(prim_subreg_pkg::SwAccessRW),
646:     .RESVAL  (3'h0),
647:     .Mubi    (1'b0)
648:   ) u_sideload_clear (
649:     .clk_i   (clk_i),
650:     .rst_ni  (rst_ni),
651: 
652:     // from register interface
653:     .we     (sideload_clear_gated_we),
654:     .wd     (sideload_clear_wd),
655: 
656:     // from internal hardware
657:     .de     (1'b0),
658:     .d      ('0),
659: 
660:     // to internal hardware
661:     .qe     (),
662:     .q      (reg2hw.sideload_clear.q),
663:     .ds     (),
664: 
665:     // to register interface (read)
666:     .qs     (sideload_clear_qs)
667:   );
668: 
669: 
670:   // R[reseed_interval_regwen]: V(False)
671:   prim_subreg #(
672:     .DW      (1),
673:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
674:     .RESVAL  (1'h1),
675:     .Mubi    (1'b0)
676:   ) u_reseed_interval_regwen (
677:     .clk_i   (clk_i),
678:     .rst_ni  (rst_ni),
679: 
680:     // from register interface
681:     .we     (reseed_interval_regwen_we),
682:     .wd     (reseed_interval_regwen_wd),
683: 
684:     // from internal hardware
685:     .de     (1'b0),
686:     .d      ('0),
687: 
688:     // to internal hardware
689:     .qe     (),
690:     .q      (),
691:     .ds     (),
692: 
693:     // to register interface (read)
694:     .qs     (reseed_interval_regwen_qs)
695:   );
696: 
697: 
698:   // R[reseed_interval_shadowed]: V(False)
699:   // Create REGWEN-gated WE signal
700:   logic reseed_interval_shadowed_gated_we;
701:   assign reseed_interval_shadowed_gated_we =
702:     reseed_interval_shadowed_we & reseed_interval_regwen_qs;
703:   prim_subreg_shadow #(
704:     .DW      (16),
705:     .SwAccess(prim_subreg_pkg::SwAccessRW),
706:     .RESVAL  (16'h100),
707:     .Mubi    (1'b0)
708:   ) u_reseed_interval_shadowed (
709:     .clk_i   (clk_i),
710:     .rst_ni  (rst_ni),
711:     .rst_shadowed_ni (rst_shadowed_ni),
712: 
713:     // from register interface
714:     .re     (reseed_interval_shadowed_re),
715:     .we     (reseed_interval_shadowed_gated_we),
716:     .wd     (reseed_interval_shadowed_wd),
717: 
718:     // from internal hardware
719:     .de     (1'b0),
720:     .d      ('0),
721: 
722:     // to internal hardware
723:     .qe     (),
724:     .q      (reg2hw.reseed_interval_shadowed.q),
725:     .ds     (),
726: 
727:     // to register interface (read)
728:     .qs     (reseed_interval_shadowed_qs),
729: 
730:     // Shadow register phase. Relevant for hwext only.
731:     .phase  (),
732: 
733:     // Shadow register error conditions
734:     .err_update  (reseed_interval_shadowed_update_err),
735:     .err_storage (reseed_interval_shadowed_storage_err)
736:   );
737: 
738: 
739:   // R[sw_binding_regwen]: V(True)
740:   logic sw_binding_regwen_qe;
741:   logic [0:0] sw_binding_regwen_flds_we;
742:   assign sw_binding_regwen_qe = &sw_binding_regwen_flds_we;
743:   prim_subreg_ext #(
744:     .DW    (1)
745:   ) u_sw_binding_regwen (
746:     .re     (sw_binding_regwen_re),
747:     .we     (sw_binding_regwen_we),
748:     .wd     (sw_binding_regwen_wd),
749:     .d      (hw2reg.sw_binding_regwen.d),
750:     .qre    (),
751:     .qe     (sw_binding_regwen_flds_we[0]),
752:     .q      (reg2hw.sw_binding_regwen.q),
753:     .ds     (),
754:     .qs     (sw_binding_regwen_qs)
755:   );
756:   assign reg2hw.sw_binding_regwen.qe = sw_binding_regwen_qe;
757: 
758: 
759:   // Subregister 0 of Multireg sealing_sw_binding
760:   // R[sealing_sw_binding_0]: V(False)
761:   // Create REGWEN-gated WE signal
762:   logic sealing_sw_binding_0_gated_we;
763:   assign sealing_sw_binding_0_gated_we = sealing_sw_binding_0_we & sw_binding_regwen_qs;
764:   prim_subreg #(
765:     .DW      (32),
766:     .SwAccess(prim_subreg_pkg::SwAccessRW),
767:     .RESVAL  (32'h0),
768:     .Mubi    (1'b0)
769:   ) u_sealing_sw_binding_0 (
770:     .clk_i   (clk_i),
771:     .rst_ni  (rst_ni),
772: 
773:     // from register interface
774:     .we     (sealing_sw_binding_0_gated_we),
775:     .wd     (sealing_sw_binding_0_wd),
776: 
777:     // from internal hardware
778:     .de     (1'b0),
779:     .d      ('0),
780: 
781:     // to internal hardware
782:     .qe     (),
783:     .q      (reg2hw.sealing_sw_binding[0].q),
784:     .ds     (),
785: 
786:     // to register interface (read)
787:     .qs     (sealing_sw_binding_0_qs)
788:   );
789: 
790: 
791:   // Subregister 1 of Multireg sealing_sw_binding
792:   // R[sealing_sw_binding_1]: V(False)
793:   // Create REGWEN-gated WE signal
794:   logic sealing_sw_binding_1_gated_we;
795:   assign sealing_sw_binding_1_gated_we = sealing_sw_binding_1_we & sw_binding_regwen_qs;
796:   prim_subreg #(
797:     .DW      (32),
798:     .SwAccess(prim_subreg_pkg::SwAccessRW),
799:     .RESVAL  (32'h0),
800:     .Mubi    (1'b0)
801:   ) u_sealing_sw_binding_1 (
802:     .clk_i   (clk_i),
803:     .rst_ni  (rst_ni),
804: 
805:     // from register interface
806:     .we     (sealing_sw_binding_1_gated_we),
807:     .wd     (sealing_sw_binding_1_wd),
808: 
809:     // from internal hardware
810:     .de     (1'b0),
811:     .d      ('0),
812: 
813:     // to internal hardware
814:     .qe     (),
815:     .q      (reg2hw.sealing_sw_binding[1].q),
816:     .ds     (),
817: 
818:     // to register interface (read)
819:     .qs     (sealing_sw_binding_1_qs)
820:   );
821: 
822: 
823:   // Subregister 2 of Multireg sealing_sw_binding
824:   // R[sealing_sw_binding_2]: V(False)
825:   // Create REGWEN-gated WE signal
826:   logic sealing_sw_binding_2_gated_we;
827:   assign sealing_sw_binding_2_gated_we = sealing_sw_binding_2_we & sw_binding_regwen_qs;
828:   prim_subreg #(
829:     .DW      (32),
830:     .SwAccess(prim_subreg_pkg::SwAccessRW),
831:     .RESVAL  (32'h0),
832:     .Mubi    (1'b0)
833:   ) u_sealing_sw_binding_2 (
834:     .clk_i   (clk_i),
835:     .rst_ni  (rst_ni),
836: 
837:     // from register interface
838:     .we     (sealing_sw_binding_2_gated_we),
839:     .wd     (sealing_sw_binding_2_wd),
840: 
841:     // from internal hardware
842:     .de     (1'b0),
843:     .d      ('0),
844: 
845:     // to internal hardware
846:     .qe     (),
847:     .q      (reg2hw.sealing_sw_binding[2].q),
848:     .ds     (),
849: 
850:     // to register interface (read)
851:     .qs     (sealing_sw_binding_2_qs)
852:   );
853: 
854: 
855:   // Subregister 3 of Multireg sealing_sw_binding
856:   // R[sealing_sw_binding_3]: V(False)
857:   // Create REGWEN-gated WE signal
858:   logic sealing_sw_binding_3_gated_we;
859:   assign sealing_sw_binding_3_gated_we = sealing_sw_binding_3_we & sw_binding_regwen_qs;
860:   prim_subreg #(
861:     .DW      (32),
862:     .SwAccess(prim_subreg_pkg::SwAccessRW),
863:     .RESVAL  (32'h0),
864:     .Mubi    (1'b0)
865:   ) u_sealing_sw_binding_3 (
866:     .clk_i   (clk_i),
867:     .rst_ni  (rst_ni),
868: 
869:     // from register interface
870:     .we     (sealing_sw_binding_3_gated_we),
871:     .wd     (sealing_sw_binding_3_wd),
872: 
873:     // from internal hardware
874:     .de     (1'b0),
875:     .d      ('0),
876: 
877:     // to internal hardware
878:     .qe     (),
879:     .q      (reg2hw.sealing_sw_binding[3].q),
880:     .ds     (),
881: 
882:     // to register interface (read)
883:     .qs     (sealing_sw_binding_3_qs)
884:   );
885: 
886: 
887:   // Subregister 4 of Multireg sealing_sw_binding
888:   // R[sealing_sw_binding_4]: V(False)
889:   // Create REGWEN-gated WE signal
890:   logic sealing_sw_binding_4_gated_we;
891:   assign sealing_sw_binding_4_gated_we = sealing_sw_binding_4_we & sw_binding_regwen_qs;
892:   prim_subreg #(
893:     .DW      (32),
894:     .SwAccess(prim_subreg_pkg::SwAccessRW),
895:     .RESVAL  (32'h0),
896:     .Mubi    (1'b0)
897:   ) u_sealing_sw_binding_4 (
898:     .clk_i   (clk_i),
899:     .rst_ni  (rst_ni),
900: 
901:     // from register interface
902:     .we     (sealing_sw_binding_4_gated_we),
903:     .wd     (sealing_sw_binding_4_wd),
904: 
905:     // from internal hardware
906:     .de     (1'b0),
907:     .d      ('0),
908: 
909:     // to internal hardware
910:     .qe     (),
911:     .q      (reg2hw.sealing_sw_binding[4].q),
912:     .ds     (),
913: 
914:     // to register interface (read)
915:     .qs     (sealing_sw_binding_4_qs)
916:   );
917: 
918: 
919:   // Subregister 5 of Multireg sealing_sw_binding
920:   // R[sealing_sw_binding_5]: V(False)
921:   // Create REGWEN-gated WE signal
922:   logic sealing_sw_binding_5_gated_we;
923:   assign sealing_sw_binding_5_gated_we = sealing_sw_binding_5_we & sw_binding_regwen_qs;
924:   prim_subreg #(
925:     .DW      (32),
926:     .SwAccess(prim_subreg_pkg::SwAccessRW),
927:     .RESVAL  (32'h0),
928:     .Mubi    (1'b0)
929:   ) u_sealing_sw_binding_5 (
930:     .clk_i   (clk_i),
931:     .rst_ni  (rst_ni),
932: 
933:     // from register interface
934:     .we     (sealing_sw_binding_5_gated_we),
935:     .wd     (sealing_sw_binding_5_wd),
936: 
937:     // from internal hardware
938:     .de     (1'b0),
939:     .d      ('0),
940: 
941:     // to internal hardware
942:     .qe     (),
943:     .q      (reg2hw.sealing_sw_binding[5].q),
944:     .ds     (),
945: 
946:     // to register interface (read)
947:     .qs     (sealing_sw_binding_5_qs)
948:   );
949: 
950: 
951:   // Subregister 6 of Multireg sealing_sw_binding
952:   // R[sealing_sw_binding_6]: V(False)
953:   // Create REGWEN-gated WE signal
954:   logic sealing_sw_binding_6_gated_we;
955:   assign sealing_sw_binding_6_gated_we = sealing_sw_binding_6_we & sw_binding_regwen_qs;
956:   prim_subreg #(
957:     .DW      (32),
958:     .SwAccess(prim_subreg_pkg::SwAccessRW),
959:     .RESVAL  (32'h0),
960:     .Mubi    (1'b0)
961:   ) u_sealing_sw_binding_6 (
962:     .clk_i   (clk_i),
963:     .rst_ni  (rst_ni),
964: 
965:     // from register interface
966:     .we     (sealing_sw_binding_6_gated_we),
967:     .wd     (sealing_sw_binding_6_wd),
968: 
969:     // from internal hardware
970:     .de     (1'b0),
971:     .d      ('0),
972: 
973:     // to internal hardware
974:     .qe     (),
975:     .q      (reg2hw.sealing_sw_binding[6].q),
976:     .ds     (),
977: 
978:     // to register interface (read)
979:     .qs     (sealing_sw_binding_6_qs)
980:   );
981: 
982: 
983:   // Subregister 7 of Multireg sealing_sw_binding
984:   // R[sealing_sw_binding_7]: V(False)
985:   // Create REGWEN-gated WE signal
986:   logic sealing_sw_binding_7_gated_we;
987:   assign sealing_sw_binding_7_gated_we = sealing_sw_binding_7_we & sw_binding_regwen_qs;
988:   prim_subreg #(
989:     .DW      (32),
990:     .SwAccess(prim_subreg_pkg::SwAccessRW),
991:     .RESVAL  (32'h0),
992:     .Mubi    (1'b0)
993:   ) u_sealing_sw_binding_7 (
994:     .clk_i   (clk_i),
995:     .rst_ni  (rst_ni),
996: 
997:     // from register interface
998:     .we     (sealing_sw_binding_7_gated_we),
999:     .wd     (sealing_sw_binding_7_wd),
1000: 
1001:     // from internal hardware
1002:     .de     (1'b0),
1003:     .d      ('0),
1004: 
1005:     // to internal hardware
1006:     .qe     (),
1007:     .q      (reg2hw.sealing_sw_binding[7].q),
1008:     .ds     (),
1009: 
1010:     // to register interface (read)
1011:     .qs     (sealing_sw_binding_7_qs)
1012:   );
1013: 
1014: 
1015:   // Subregister 0 of Multireg attest_sw_binding
1016:   // R[attest_sw_binding_0]: V(False)
1017:   // Create REGWEN-gated WE signal
1018:   logic attest_sw_binding_0_gated_we;
1019:   assign attest_sw_binding_0_gated_we = attest_sw_binding_0_we & sw_binding_regwen_qs;
1020:   prim_subreg #(
1021:     .DW      (32),
1022:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1023:     .RESVAL  (32'h0),
1024:     .Mubi    (1'b0)
1025:   ) u_attest_sw_binding_0 (
1026:     .clk_i   (clk_i),
1027:     .rst_ni  (rst_ni),
1028: 
1029:     // from register interface
1030:     .we     (attest_sw_binding_0_gated_we),
1031:     .wd     (attest_sw_binding_0_wd),
1032: 
1033:     // from internal hardware
1034:     .de     (1'b0),
1035:     .d      ('0),
1036: 
1037:     // to internal hardware
1038:     .qe     (),
1039:     .q      (reg2hw.attest_sw_binding[0].q),
1040:     .ds     (),
1041: 
1042:     // to register interface (read)
1043:     .qs     (attest_sw_binding_0_qs)
1044:   );
1045: 
1046: 
1047:   // Subregister 1 of Multireg attest_sw_binding
1048:   // R[attest_sw_binding_1]: V(False)
1049:   // Create REGWEN-gated WE signal
1050:   logic attest_sw_binding_1_gated_we;
1051:   assign attest_sw_binding_1_gated_we = attest_sw_binding_1_we & sw_binding_regwen_qs;
1052:   prim_subreg #(
1053:     .DW      (32),
1054:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1055:     .RESVAL  (32'h0),
1056:     .Mubi    (1'b0)
1057:   ) u_attest_sw_binding_1 (
1058:     .clk_i   (clk_i),
1059:     .rst_ni  (rst_ni),
1060: 
1061:     // from register interface
1062:     .we     (attest_sw_binding_1_gated_we),
1063:     .wd     (attest_sw_binding_1_wd),
1064: 
1065:     // from internal hardware
1066:     .de     (1'b0),
1067:     .d      ('0),
1068: 
1069:     // to internal hardware
1070:     .qe     (),
1071:     .q      (reg2hw.attest_sw_binding[1].q),
1072:     .ds     (),
1073: 
1074:     // to register interface (read)
1075:     .qs     (attest_sw_binding_1_qs)
1076:   );
1077: 
1078: 
1079:   // Subregister 2 of Multireg attest_sw_binding
1080:   // R[attest_sw_binding_2]: V(False)
1081:   // Create REGWEN-gated WE signal
1082:   logic attest_sw_binding_2_gated_we;
1083:   assign attest_sw_binding_2_gated_we = attest_sw_binding_2_we & sw_binding_regwen_qs;
1084:   prim_subreg #(
1085:     .DW      (32),
1086:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1087:     .RESVAL  (32'h0),
1088:     .Mubi    (1'b0)
1089:   ) u_attest_sw_binding_2 (
1090:     .clk_i   (clk_i),
1091:     .rst_ni  (rst_ni),
1092: 
1093:     // from register interface
1094:     .we     (attest_sw_binding_2_gated_we),
1095:     .wd     (attest_sw_binding_2_wd),
1096: 
1097:     // from internal hardware
1098:     .de     (1'b0),
1099:     .d      ('0),
1100: 
1101:     // to internal hardware
1102:     .qe     (),
1103:     .q      (reg2hw.attest_sw_binding[2].q),
1104:     .ds     (),
1105: 
1106:     // to register interface (read)
1107:     .qs     (attest_sw_binding_2_qs)
1108:   );
1109: 
1110: 
1111:   // Subregister 3 of Multireg attest_sw_binding
1112:   // R[attest_sw_binding_3]: V(False)
1113:   // Create REGWEN-gated WE signal
1114:   logic attest_sw_binding_3_gated_we;
1115:   assign attest_sw_binding_3_gated_we = attest_sw_binding_3_we & sw_binding_regwen_qs;
1116:   prim_subreg #(
1117:     .DW      (32),
1118:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1119:     .RESVAL  (32'h0),
1120:     .Mubi    (1'b0)
1121:   ) u_attest_sw_binding_3 (
1122:     .clk_i   (clk_i),
1123:     .rst_ni  (rst_ni),
1124: 
1125:     // from register interface
1126:     .we     (attest_sw_binding_3_gated_we),
1127:     .wd     (attest_sw_binding_3_wd),
1128: 
1129:     // from internal hardware
1130:     .de     (1'b0),
1131:     .d      ('0),
1132: 
1133:     // to internal hardware
1134:     .qe     (),
1135:     .q      (reg2hw.attest_sw_binding[3].q),
1136:     .ds     (),
1137: 
1138:     // to register interface (read)
1139:     .qs     (attest_sw_binding_3_qs)
1140:   );
1141: 
1142: 
1143:   // Subregister 4 of Multireg attest_sw_binding
1144:   // R[attest_sw_binding_4]: V(False)
1145:   // Create REGWEN-gated WE signal
1146:   logic attest_sw_binding_4_gated_we;
1147:   assign attest_sw_binding_4_gated_we = attest_sw_binding_4_we & sw_binding_regwen_qs;
1148:   prim_subreg #(
1149:     .DW      (32),
1150:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1151:     .RESVAL  (32'h0),
1152:     .Mubi    (1'b0)
1153:   ) u_attest_sw_binding_4 (
1154:     .clk_i   (clk_i),
1155:     .rst_ni  (rst_ni),
1156: 
1157:     // from register interface
1158:     .we     (attest_sw_binding_4_gated_we),
1159:     .wd     (attest_sw_binding_4_wd),
1160: 
1161:     // from internal hardware
1162:     .de     (1'b0),
1163:     .d      ('0),
1164: 
1165:     // to internal hardware
1166:     .qe     (),
1167:     .q      (reg2hw.attest_sw_binding[4].q),
1168:     .ds     (),
1169: 
1170:     // to register interface (read)
1171:     .qs     (attest_sw_binding_4_qs)
1172:   );
1173: 
1174: 
1175:   // Subregister 5 of Multireg attest_sw_binding
1176:   // R[attest_sw_binding_5]: V(False)
1177:   // Create REGWEN-gated WE signal
1178:   logic attest_sw_binding_5_gated_we;
1179:   assign attest_sw_binding_5_gated_we = attest_sw_binding_5_we & sw_binding_regwen_qs;
1180:   prim_subreg #(
1181:     .DW      (32),
1182:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1183:     .RESVAL  (32'h0),
1184:     .Mubi    (1'b0)
1185:   ) u_attest_sw_binding_5 (
1186:     .clk_i   (clk_i),
1187:     .rst_ni  (rst_ni),
1188: 
1189:     // from register interface
1190:     .we     (attest_sw_binding_5_gated_we),
1191:     .wd     (attest_sw_binding_5_wd),
1192: 
1193:     // from internal hardware
1194:     .de     (1'b0),
1195:     .d      ('0),
1196: 
1197:     // to internal hardware
1198:     .qe     (),
1199:     .q      (reg2hw.attest_sw_binding[5].q),
1200:     .ds     (),
1201: 
1202:     // to register interface (read)
1203:     .qs     (attest_sw_binding_5_qs)
1204:   );
1205: 
1206: 
1207:   // Subregister 6 of Multireg attest_sw_binding
1208:   // R[attest_sw_binding_6]: V(False)
1209:   // Create REGWEN-gated WE signal
1210:   logic attest_sw_binding_6_gated_we;
1211:   assign attest_sw_binding_6_gated_we = attest_sw_binding_6_we & sw_binding_regwen_qs;
1212:   prim_subreg #(
1213:     .DW      (32),
1214:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1215:     .RESVAL  (32'h0),
1216:     .Mubi    (1'b0)
1217:   ) u_attest_sw_binding_6 (
1218:     .clk_i   (clk_i),
1219:     .rst_ni  (rst_ni),
1220: 
1221:     // from register interface
1222:     .we     (attest_sw_binding_6_gated_we),
1223:     .wd     (attest_sw_binding_6_wd),
1224: 
1225:     // from internal hardware
1226:     .de     (1'b0),
1227:     .d      ('0),
1228: 
1229:     // to internal hardware
1230:     .qe     (),
1231:     .q      (reg2hw.attest_sw_binding[6].q),
1232:     .ds     (),
1233: 
1234:     // to register interface (read)
1235:     .qs     (attest_sw_binding_6_qs)
1236:   );
1237: 
1238: 
1239:   // Subregister 7 of Multireg attest_sw_binding
1240:   // R[attest_sw_binding_7]: V(False)
1241:   // Create REGWEN-gated WE signal
1242:   logic attest_sw_binding_7_gated_we;
1243:   assign attest_sw_binding_7_gated_we = attest_sw_binding_7_we & sw_binding_regwen_qs;
1244:   prim_subreg #(
1245:     .DW      (32),
1246:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1247:     .RESVAL  (32'h0),
1248:     .Mubi    (1'b0)
1249:   ) u_attest_sw_binding_7 (
1250:     .clk_i   (clk_i),
1251:     .rst_ni  (rst_ni),
1252: 
1253:     // from register interface
1254:     .we     (attest_sw_binding_7_gated_we),
1255:     .wd     (attest_sw_binding_7_wd),
1256: 
1257:     // from internal hardware
1258:     .de     (1'b0),
1259:     .d      ('0),
1260: 
1261:     // to internal hardware
1262:     .qe     (),
1263:     .q      (reg2hw.attest_sw_binding[7].q),
1264:     .ds     (),
1265: 
1266:     // to register interface (read)
1267:     .qs     (attest_sw_binding_7_qs)
1268:   );
1269: 
1270: 
1271:   // Subregister 0 of Multireg salt
1272:   // R[salt_0]: V(False)
1273:   // Create REGWEN-gated WE signal
1274:   logic salt_0_gated_we;
1275:   assign salt_0_gated_we = salt_0_we & cfg_regwen_qs;
1276:   prim_subreg #(
1277:     .DW      (32),
1278:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1279:     .RESVAL  (32'h0),
1280:     .Mubi    (1'b0)
1281:   ) u_salt_0 (
1282:     .clk_i   (clk_i),
1283:     .rst_ni  (rst_ni),
1284: 
1285:     // from register interface
1286:     .we     (salt_0_gated_we),
1287:     .wd     (salt_0_wd),
1288: 
1289:     // from internal hardware
1290:     .de     (1'b0),
1291:     .d      ('0),
1292: 
1293:     // to internal hardware
1294:     .qe     (),
1295:     .q      (reg2hw.salt[0].q),
1296:     .ds     (),
1297: 
1298:     // to register interface (read)
1299:     .qs     (salt_0_qs)
1300:   );
1301: 
1302: 
1303:   // Subregister 1 of Multireg salt
1304:   // R[salt_1]: V(False)
1305:   // Create REGWEN-gated WE signal
1306:   logic salt_1_gated_we;
1307:   assign salt_1_gated_we = salt_1_we & cfg_regwen_qs;
1308:   prim_subreg #(
1309:     .DW      (32),
1310:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1311:     .RESVAL  (32'h0),
1312:     .Mubi    (1'b0)
1313:   ) u_salt_1 (
1314:     .clk_i   (clk_i),
1315:     .rst_ni  (rst_ni),
1316: 
1317:     // from register interface
1318:     .we     (salt_1_gated_we),
1319:     .wd     (salt_1_wd),
1320: 
1321:     // from internal hardware
1322:     .de     (1'b0),
1323:     .d      ('0),
1324: 
1325:     // to internal hardware
1326:     .qe     (),
1327:     .q      (reg2hw.salt[1].q),
1328:     .ds     (),
1329: 
1330:     // to register interface (read)
1331:     .qs     (salt_1_qs)
1332:   );
1333: 
1334: 
1335:   // Subregister 2 of Multireg salt
1336:   // R[salt_2]: V(False)
1337:   // Create REGWEN-gated WE signal
1338:   logic salt_2_gated_we;
1339:   assign salt_2_gated_we = salt_2_we & cfg_regwen_qs;
1340:   prim_subreg #(
1341:     .DW      (32),
1342:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1343:     .RESVAL  (32'h0),
1344:     .Mubi    (1'b0)
1345:   ) u_salt_2 (
1346:     .clk_i   (clk_i),
1347:     .rst_ni  (rst_ni),
1348: 
1349:     // from register interface
1350:     .we     (salt_2_gated_we),
1351:     .wd     (salt_2_wd),
1352: 
1353:     // from internal hardware
1354:     .de     (1'b0),
1355:     .d      ('0),
1356: 
1357:     // to internal hardware
1358:     .qe     (),
1359:     .q      (reg2hw.salt[2].q),
1360:     .ds     (),
1361: 
1362:     // to register interface (read)
1363:     .qs     (salt_2_qs)
1364:   );
1365: 
1366: 
1367:   // Subregister 3 of Multireg salt
1368:   // R[salt_3]: V(False)
1369:   // Create REGWEN-gated WE signal
1370:   logic salt_3_gated_we;
1371:   assign salt_3_gated_we = salt_3_we & cfg_regwen_qs;
1372:   prim_subreg #(
1373:     .DW      (32),
1374:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1375:     .RESVAL  (32'h0),
1376:     .Mubi    (1'b0)
1377:   ) u_salt_3 (
1378:     .clk_i   (clk_i),
1379:     .rst_ni  (rst_ni),
1380: 
1381:     // from register interface
1382:     .we     (salt_3_gated_we),
1383:     .wd     (salt_3_wd),
1384: 
1385:     // from internal hardware
1386:     .de     (1'b0),
1387:     .d      ('0),
1388: 
1389:     // to internal hardware
1390:     .qe     (),
1391:     .q      (reg2hw.salt[3].q),
1392:     .ds     (),
1393: 
1394:     // to register interface (read)
1395:     .qs     (salt_3_qs)
1396:   );
1397: 
1398: 
1399:   // Subregister 4 of Multireg salt
1400:   // R[salt_4]: V(False)
1401:   // Create REGWEN-gated WE signal
1402:   logic salt_4_gated_we;
1403:   assign salt_4_gated_we = salt_4_we & cfg_regwen_qs;
1404:   prim_subreg #(
1405:     .DW      (32),
1406:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1407:     .RESVAL  (32'h0),
1408:     .Mubi    (1'b0)
1409:   ) u_salt_4 (
1410:     .clk_i   (clk_i),
1411:     .rst_ni  (rst_ni),
1412: 
1413:     // from register interface
1414:     .we     (salt_4_gated_we),
1415:     .wd     (salt_4_wd),
1416: 
1417:     // from internal hardware
1418:     .de     (1'b0),
1419:     .d      ('0),
1420: 
1421:     // to internal hardware
1422:     .qe     (),
1423:     .q      (reg2hw.salt[4].q),
1424:     .ds     (),
1425: 
1426:     // to register interface (read)
1427:     .qs     (salt_4_qs)
1428:   );
1429: 
1430: 
1431:   // Subregister 5 of Multireg salt
1432:   // R[salt_5]: V(False)
1433:   // Create REGWEN-gated WE signal
1434:   logic salt_5_gated_we;
1435:   assign salt_5_gated_we = salt_5_we & cfg_regwen_qs;
1436:   prim_subreg #(
1437:     .DW      (32),
1438:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1439:     .RESVAL  (32'h0),
1440:     .Mubi    (1'b0)
1441:   ) u_salt_5 (
1442:     .clk_i   (clk_i),
1443:     .rst_ni  (rst_ni),
1444: 
1445:     // from register interface
1446:     .we     (salt_5_gated_we),
1447:     .wd     (salt_5_wd),
1448: 
1449:     // from internal hardware
1450:     .de     (1'b0),
1451:     .d      ('0),
1452: 
1453:     // to internal hardware
1454:     .qe     (),
1455:     .q      (reg2hw.salt[5].q),
1456:     .ds     (),
1457: 
1458:     // to register interface (read)
1459:     .qs     (salt_5_qs)
1460:   );
1461: 
1462: 
1463:   // Subregister 6 of Multireg salt
1464:   // R[salt_6]: V(False)
1465:   // Create REGWEN-gated WE signal
1466:   logic salt_6_gated_we;
1467:   assign salt_6_gated_we = salt_6_we & cfg_regwen_qs;
1468:   prim_subreg #(
1469:     .DW      (32),
1470:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1471:     .RESVAL  (32'h0),
1472:     .Mubi    (1'b0)
1473:   ) u_salt_6 (
1474:     .clk_i   (clk_i),
1475:     .rst_ni  (rst_ni),
1476: 
1477:     // from register interface
1478:     .we     (salt_6_gated_we),
1479:     .wd     (salt_6_wd),
1480: 
1481:     // from internal hardware
1482:     .de     (1'b0),
1483:     .d      ('0),
1484: 
1485:     // to internal hardware
1486:     .qe     (),
1487:     .q      (reg2hw.salt[6].q),
1488:     .ds     (),
1489: 
1490:     // to register interface (read)
1491:     .qs     (salt_6_qs)
1492:   );
1493: 
1494: 
1495:   // Subregister 7 of Multireg salt
1496:   // R[salt_7]: V(False)
1497:   // Create REGWEN-gated WE signal
1498:   logic salt_7_gated_we;
1499:   assign salt_7_gated_we = salt_7_we & cfg_regwen_qs;
1500:   prim_subreg #(
1501:     .DW      (32),
1502:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1503:     .RESVAL  (32'h0),
1504:     .Mubi    (1'b0)
1505:   ) u_salt_7 (
1506:     .clk_i   (clk_i),
1507:     .rst_ni  (rst_ni),
1508: 
1509:     // from register interface
1510:     .we     (salt_7_gated_we),
1511:     .wd     (salt_7_wd),
1512: 
1513:     // from internal hardware
1514:     .de     (1'b0),
1515:     .d      ('0),
1516: 
1517:     // to internal hardware
1518:     .qe     (),
1519:     .q      (reg2hw.salt[7].q),
1520:     .ds     (),
1521: 
1522:     // to register interface (read)
1523:     .qs     (salt_7_qs)
1524:   );
1525: 
1526: 
1527:   // Subregister 0 of Multireg key_version
1528:   // R[key_version]: V(False)
1529:   // Create REGWEN-gated WE signal
1530:   logic key_version_gated_we;
1531:   assign key_version_gated_we = key_version_we & cfg_regwen_qs;
1532:   prim_subreg #(
1533:     .DW      (32),
1534:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1535:     .RESVAL  (32'h0),
1536:     .Mubi    (1'b0)
1537:   ) u_key_version (
1538:     .clk_i   (clk_i),
1539:     .rst_ni  (rst_ni),
1540: 
1541:     // from register interface
1542:     .we     (key_version_gated_we),
1543:     .wd     (key_version_wd),
1544: 
1545:     // from internal hardware
1546:     .de     (1'b0),
1547:     .d      ('0),
1548: 
1549:     // to internal hardware
1550:     .qe     (),
1551:     .q      (reg2hw.key_version[0].q),
1552:     .ds     (),
1553: 
1554:     // to register interface (read)
1555:     .qs     (key_version_qs)
1556:   );
1557: 
1558: 
1559:   // R[max_creator_key_ver_regwen]: V(False)
1560:   prim_subreg #(
1561:     .DW      (1),
1562:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
1563:     .RESVAL  (1'h1),
1564:     .Mubi    (1'b0)
1565:   ) u_max_creator_key_ver_regwen (
1566:     .clk_i   (clk_i),
1567:     .rst_ni  (rst_ni),
1568: 
1569:     // from register interface
1570:     .we     (max_creator_key_ver_regwen_we),
1571:     .wd     (max_creator_key_ver_regwen_wd),
1572: 
1573:     // from internal hardware
1574:     .de     (1'b0),
1575:     .d      ('0),
1576: 
1577:     // to internal hardware
1578:     .qe     (),
1579:     .q      (),
1580:     .ds     (),
1581: 
1582:     // to register interface (read)
1583:     .qs     (max_creator_key_ver_regwen_qs)
1584:   );
1585: 
1586: 
1587:   // R[max_creator_key_ver_shadowed]: V(False)
1588:   // Create REGWEN-gated WE signal
1589:   logic max_creator_key_ver_shadowed_gated_we;
1590:   assign max_creator_key_ver_shadowed_gated_we =
1591:     max_creator_key_ver_shadowed_we & max_creator_key_ver_regwen_qs;
1592:   prim_subreg_shadow #(
1593:     .DW      (32),
1594:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1595:     .RESVAL  (32'h0),
1596:     .Mubi    (1'b0)
1597:   ) u_max_creator_key_ver_shadowed (
1598:     .clk_i   (clk_i),
1599:     .rst_ni  (rst_ni),
1600:     .rst_shadowed_ni (rst_shadowed_ni),
1601: 
1602:     // from register interface
1603:     .re     (max_creator_key_ver_shadowed_re),
1604:     .we     (max_creator_key_ver_shadowed_gated_we),
1605:     .wd     (max_creator_key_ver_shadowed_wd),
1606: 
1607:     // from internal hardware
1608:     .de     (1'b0),
1609:     .d      ('0),
1610: 
1611:     // to internal hardware
1612:     .qe     (),
1613:     .q      (reg2hw.max_creator_key_ver_shadowed.q),
1614:     .ds     (),
1615: 
1616:     // to register interface (read)
1617:     .qs     (max_creator_key_ver_shadowed_qs),
1618: 
1619:     // Shadow register phase. Relevant for hwext only.
1620:     .phase  (),
1621: 
1622:     // Shadow register error conditions
1623:     .err_update  (max_creator_key_ver_shadowed_update_err),
1624:     .err_storage (max_creator_key_ver_shadowed_storage_err)
1625:   );
1626: 
1627: 
1628:   // R[max_owner_int_key_ver_regwen]: V(False)
1629:   prim_subreg #(
1630:     .DW      (1),
1631:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
1632:     .RESVAL  (1'h1),
1633:     .Mubi    (1'b0)
1634:   ) u_max_owner_int_key_ver_regwen (
1635:     .clk_i   (clk_i),
1636:     .rst_ni  (rst_ni),
1637: 
1638:     // from register interface
1639:     .we     (max_owner_int_key_ver_regwen_we),
1640:     .wd     (max_owner_int_key_ver_regwen_wd),
1641: 
1642:     // from internal hardware
1643:     .de     (1'b0),
1644:     .d      ('0),
1645: 
1646:     // to internal hardware
1647:     .qe     (),
1648:     .q      (),
1649:     .ds     (),
1650: 
1651:     // to register interface (read)
1652:     .qs     (max_owner_int_key_ver_regwen_qs)
1653:   );
1654: 
1655: 
1656:   // R[max_owner_int_key_ver_shadowed]: V(False)
1657:   // Create REGWEN-gated WE signal
1658:   logic max_owner_int_key_ver_shadowed_gated_we;
1659:   assign max_owner_int_key_ver_shadowed_gated_we =
1660:     max_owner_int_key_ver_shadowed_we & max_owner_int_key_ver_regwen_qs;
1661:   prim_subreg_shadow #(
1662:     .DW      (32),
1663:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1664:     .RESVAL  (32'h1),
1665:     .Mubi    (1'b0)
1666:   ) u_max_owner_int_key_ver_shadowed (
1667:     .clk_i   (clk_i),
1668:     .rst_ni  (rst_ni),
1669:     .rst_shadowed_ni (rst_shadowed_ni),
1670: 
1671:     // from register interface
1672:     .re     (max_owner_int_key_ver_shadowed_re),
1673:     .we     (max_owner_int_key_ver_shadowed_gated_we),
1674:     .wd     (max_owner_int_key_ver_shadowed_wd),
1675: 
1676:     // from internal hardware
1677:     .de     (1'b0),
1678:     .d      ('0),
1679: 
1680:     // to internal hardware
1681:     .qe     (),
1682:     .q      (reg2hw.max_owner_int_key_ver_shadowed.q),
1683:     .ds     (),
1684: 
1685:     // to register interface (read)
1686:     .qs     (max_owner_int_key_ver_shadowed_qs),
1687: 
1688:     // Shadow register phase. Relevant for hwext only.
1689:     .phase  (),
1690: 
1691:     // Shadow register error conditions
1692:     .err_update  (max_owner_int_key_ver_shadowed_update_err),
1693:     .err_storage (max_owner_int_key_ver_shadowed_storage_err)
1694:   );
1695: 
1696: 
1697:   // R[max_owner_key_ver_regwen]: V(False)
1698:   prim_subreg #(
1699:     .DW      (1),
1700:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
1701:     .RESVAL  (1'h1),
1702:     .Mubi    (1'b0)
1703:   ) u_max_owner_key_ver_regwen (
1704:     .clk_i   (clk_i),
1705:     .rst_ni  (rst_ni),
1706: 
1707:     // from register interface
1708:     .we     (max_owner_key_ver_regwen_we),
1709:     .wd     (max_owner_key_ver_regwen_wd),
1710: 
1711:     // from internal hardware
1712:     .de     (1'b0),
1713:     .d      ('0),
1714: 
1715:     // to internal hardware
1716:     .qe     (),
1717:     .q      (),
1718:     .ds     (),
1719: 
1720:     // to register interface (read)
1721:     .qs     (max_owner_key_ver_regwen_qs)
1722:   );
1723: 
1724: 
1725:   // R[max_owner_key_ver_shadowed]: V(False)
1726:   // Create REGWEN-gated WE signal
1727:   logic max_owner_key_ver_shadowed_gated_we;
1728:   assign max_owner_key_ver_shadowed_gated_we =
1729:     max_owner_key_ver_shadowed_we & max_owner_key_ver_regwen_qs;
1730:   prim_subreg_shadow #(
1731:     .DW      (32),
1732:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1733:     .RESVAL  (32'h0),
1734:     .Mubi    (1'b0)
1735:   ) u_max_owner_key_ver_shadowed (
1736:     .clk_i   (clk_i),
1737:     .rst_ni  (rst_ni),
1738:     .rst_shadowed_ni (rst_shadowed_ni),
1739: 
1740:     // from register interface
1741:     .re     (max_owner_key_ver_shadowed_re),
1742:     .we     (max_owner_key_ver_shadowed_gated_we),
1743:     .wd     (max_owner_key_ver_shadowed_wd),
1744: 
1745:     // from internal hardware
1746:     .de     (1'b0),
1747:     .d      ('0),
1748: 
1749:     // to internal hardware
1750:     .qe     (),
1751:     .q      (reg2hw.max_owner_key_ver_shadowed.q),
1752:     .ds     (),
1753: 
1754:     // to register interface (read)
1755:     .qs     (max_owner_key_ver_shadowed_qs),
1756: 
1757:     // Shadow register phase. Relevant for hwext only.
1758:     .phase  (),
1759: 
1760:     // Shadow register error conditions
1761:     .err_update  (max_owner_key_ver_shadowed_update_err),
1762:     .err_storage (max_owner_key_ver_shadowed_storage_err)
1763:   );
1764: 
1765: 
1766:   // Subregister 0 of Multireg sw_share0_output
1767:   // R[sw_share0_output_0]: V(False)
1768:   prim_subreg #(
1769:     .DW      (32),
1770:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1771:     .RESVAL  (32'h0),
1772:     .Mubi    (1'b0)
1773:   ) u_sw_share0_output_0 (
1774:     .clk_i   (clk_i),
1775:     .rst_ni  (rst_ni),
1776: 
1777:     // from register interface
1778:     .we     (sw_share0_output_0_re),
1779:     .wd     (sw_share0_output_0_wd),
1780: 
1781:     // from internal hardware
1782:     .de     (hw2reg.sw_share0_output[0].de),
1783:     .d      (hw2reg.sw_share0_output[0].d),
1784: 
1785:     // to internal hardware
1786:     .qe     (),
1787:     .q      (),
1788:     .ds     (),
1789: 
1790:     // to register interface (read)
1791:     .qs     (sw_share0_output_0_qs)
1792:   );
1793: 
1794: 
1795:   // Subregister 1 of Multireg sw_share0_output
1796:   // R[sw_share0_output_1]: V(False)
1797:   prim_subreg #(
1798:     .DW      (32),
1799:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1800:     .RESVAL  (32'h0),
1801:     .Mubi    (1'b0)
1802:   ) u_sw_share0_output_1 (
1803:     .clk_i   (clk_i),
1804:     .rst_ni  (rst_ni),
1805: 
1806:     // from register interface
1807:     .we     (sw_share0_output_1_re),
1808:     .wd     (sw_share0_output_1_wd),
1809: 
1810:     // from internal hardware
1811:     .de     (hw2reg.sw_share0_output[1].de),
1812:     .d      (hw2reg.sw_share0_output[1].d),
1813: 
1814:     // to internal hardware
1815:     .qe     (),
1816:     .q      (),
1817:     .ds     (),
1818: 
1819:     // to register interface (read)
1820:     .qs     (sw_share0_output_1_qs)
1821:   );
1822: 
1823: 
1824:   // Subregister 2 of Multireg sw_share0_output
1825:   // R[sw_share0_output_2]: V(False)
1826:   prim_subreg #(
1827:     .DW      (32),
1828:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1829:     .RESVAL  (32'h0),
1830:     .Mubi    (1'b0)
1831:   ) u_sw_share0_output_2 (
1832:     .clk_i   (clk_i),
1833:     .rst_ni  (rst_ni),
1834: 
1835:     // from register interface
1836:     .we     (sw_share0_output_2_re),
1837:     .wd     (sw_share0_output_2_wd),
1838: 
1839:     // from internal hardware
1840:     .de     (hw2reg.sw_share0_output[2].de),
1841:     .d      (hw2reg.sw_share0_output[2].d),
1842: 
1843:     // to internal hardware
1844:     .qe     (),
1845:     .q      (),
1846:     .ds     (),
1847: 
1848:     // to register interface (read)
1849:     .qs     (sw_share0_output_2_qs)
1850:   );
1851: 
1852: 
1853:   // Subregister 3 of Multireg sw_share0_output
1854:   // R[sw_share0_output_3]: V(False)
1855:   prim_subreg #(
1856:     .DW      (32),
1857:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1858:     .RESVAL  (32'h0),
1859:     .Mubi    (1'b0)
1860:   ) u_sw_share0_output_3 (
1861:     .clk_i   (clk_i),
1862:     .rst_ni  (rst_ni),
1863: 
1864:     // from register interface
1865:     .we     (sw_share0_output_3_re),
1866:     .wd     (sw_share0_output_3_wd),
1867: 
1868:     // from internal hardware
1869:     .de     (hw2reg.sw_share0_output[3].de),
1870:     .d      (hw2reg.sw_share0_output[3].d),
1871: 
1872:     // to internal hardware
1873:     .qe     (),
1874:     .q      (),
1875:     .ds     (),
1876: 
1877:     // to register interface (read)
1878:     .qs     (sw_share0_output_3_qs)
1879:   );
1880: 
1881: 
1882:   // Subregister 4 of Multireg sw_share0_output
1883:   // R[sw_share0_output_4]: V(False)
1884:   prim_subreg #(
1885:     .DW      (32),
1886:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1887:     .RESVAL  (32'h0),
1888:     .Mubi    (1'b0)
1889:   ) u_sw_share0_output_4 (
1890:     .clk_i   (clk_i),
1891:     .rst_ni  (rst_ni),
1892: 
1893:     // from register interface
1894:     .we     (sw_share0_output_4_re),
1895:     .wd     (sw_share0_output_4_wd),
1896: 
1897:     // from internal hardware
1898:     .de     (hw2reg.sw_share0_output[4].de),
1899:     .d      (hw2reg.sw_share0_output[4].d),
1900: 
1901:     // to internal hardware
1902:     .qe     (),
1903:     .q      (),
1904:     .ds     (),
1905: 
1906:     // to register interface (read)
1907:     .qs     (sw_share0_output_4_qs)
1908:   );
1909: 
1910: 
1911:   // Subregister 5 of Multireg sw_share0_output
1912:   // R[sw_share0_output_5]: V(False)
1913:   prim_subreg #(
1914:     .DW      (32),
1915:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1916:     .RESVAL  (32'h0),
1917:     .Mubi    (1'b0)
1918:   ) u_sw_share0_output_5 (
1919:     .clk_i   (clk_i),
1920:     .rst_ni  (rst_ni),
1921: 
1922:     // from register interface
1923:     .we     (sw_share0_output_5_re),
1924:     .wd     (sw_share0_output_5_wd),
1925: 
1926:     // from internal hardware
1927:     .de     (hw2reg.sw_share0_output[5].de),
1928:     .d      (hw2reg.sw_share0_output[5].d),
1929: 
1930:     // to internal hardware
1931:     .qe     (),
1932:     .q      (),
1933:     .ds     (),
1934: 
1935:     // to register interface (read)
1936:     .qs     (sw_share0_output_5_qs)
1937:   );
1938: 
1939: 
1940:   // Subregister 6 of Multireg sw_share0_output
1941:   // R[sw_share0_output_6]: V(False)
1942:   prim_subreg #(
1943:     .DW      (32),
1944:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1945:     .RESVAL  (32'h0),
1946:     .Mubi    (1'b0)
1947:   ) u_sw_share0_output_6 (
1948:     .clk_i   (clk_i),
1949:     .rst_ni  (rst_ni),
1950: 
1951:     // from register interface
1952:     .we     (sw_share0_output_6_re),
1953:     .wd     (sw_share0_output_6_wd),
1954: 
1955:     // from internal hardware
1956:     .de     (hw2reg.sw_share0_output[6].de),
1957:     .d      (hw2reg.sw_share0_output[6].d),
1958: 
1959:     // to internal hardware
1960:     .qe     (),
1961:     .q      (),
1962:     .ds     (),
1963: 
1964:     // to register interface (read)
1965:     .qs     (sw_share0_output_6_qs)
1966:   );
1967: 
1968: 
1969:   // Subregister 7 of Multireg sw_share0_output
1970:   // R[sw_share0_output_7]: V(False)
1971:   prim_subreg #(
1972:     .DW      (32),
1973:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1974:     .RESVAL  (32'h0),
1975:     .Mubi    (1'b0)
1976:   ) u_sw_share0_output_7 (
1977:     .clk_i   (clk_i),
1978:     .rst_ni  (rst_ni),
1979: 
1980:     // from register interface
1981:     .we     (sw_share0_output_7_re),
1982:     .wd     (sw_share0_output_7_wd),
1983: 
1984:     // from internal hardware
1985:     .de     (hw2reg.sw_share0_output[7].de),
1986:     .d      (hw2reg.sw_share0_output[7].d),
1987: 
1988:     // to internal hardware
1989:     .qe     (),
1990:     .q      (),
1991:     .ds     (),
1992: 
1993:     // to register interface (read)
1994:     .qs     (sw_share0_output_7_qs)
1995:   );
1996: 
1997: 
1998:   // Subregister 0 of Multireg sw_share1_output
1999:   // R[sw_share1_output_0]: V(False)
2000:   prim_subreg #(
2001:     .DW      (32),
2002:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2003:     .RESVAL  (32'h0),
2004:     .Mubi    (1'b0)
2005:   ) u_sw_share1_output_0 (
2006:     .clk_i   (clk_i),
2007:     .rst_ni  (rst_ni),
2008: 
2009:     // from register interface
2010:     .we     (sw_share1_output_0_re),
2011:     .wd     (sw_share1_output_0_wd),
2012: 
2013:     // from internal hardware
2014:     .de     (hw2reg.sw_share1_output[0].de),
2015:     .d      (hw2reg.sw_share1_output[0].d),
2016: 
2017:     // to internal hardware
2018:     .qe     (),
2019:     .q      (),
2020:     .ds     (),
2021: 
2022:     // to register interface (read)
2023:     .qs     (sw_share1_output_0_qs)
2024:   );
2025: 
2026: 
2027:   // Subregister 1 of Multireg sw_share1_output
2028:   // R[sw_share1_output_1]: V(False)
2029:   prim_subreg #(
2030:     .DW      (32),
2031:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2032:     .RESVAL  (32'h0),
2033:     .Mubi    (1'b0)
2034:   ) u_sw_share1_output_1 (
2035:     .clk_i   (clk_i),
2036:     .rst_ni  (rst_ni),
2037: 
2038:     // from register interface
2039:     .we     (sw_share1_output_1_re),
2040:     .wd     (sw_share1_output_1_wd),
2041: 
2042:     // from internal hardware
2043:     .de     (hw2reg.sw_share1_output[1].de),
2044:     .d      (hw2reg.sw_share1_output[1].d),
2045: 
2046:     // to internal hardware
2047:     .qe     (),
2048:     .q      (),
2049:     .ds     (),
2050: 
2051:     // to register interface (read)
2052:     .qs     (sw_share1_output_1_qs)
2053:   );
2054: 
2055: 
2056:   // Subregister 2 of Multireg sw_share1_output
2057:   // R[sw_share1_output_2]: V(False)
2058:   prim_subreg #(
2059:     .DW      (32),
2060:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2061:     .RESVAL  (32'h0),
2062:     .Mubi    (1'b0)
2063:   ) u_sw_share1_output_2 (
2064:     .clk_i   (clk_i),
2065:     .rst_ni  (rst_ni),
2066: 
2067:     // from register interface
2068:     .we     (sw_share1_output_2_re),
2069:     .wd     (sw_share1_output_2_wd),
2070: 
2071:     // from internal hardware
2072:     .de     (hw2reg.sw_share1_output[2].de),
2073:     .d      (hw2reg.sw_share1_output[2].d),
2074: 
2075:     // to internal hardware
2076:     .qe     (),
2077:     .q      (),
2078:     .ds     (),
2079: 
2080:     // to register interface (read)
2081:     .qs     (sw_share1_output_2_qs)
2082:   );
2083: 
2084: 
2085:   // Subregister 3 of Multireg sw_share1_output
2086:   // R[sw_share1_output_3]: V(False)
2087:   prim_subreg #(
2088:     .DW      (32),
2089:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2090:     .RESVAL  (32'h0),
2091:     .Mubi    (1'b0)
2092:   ) u_sw_share1_output_3 (
2093:     .clk_i   (clk_i),
2094:     .rst_ni  (rst_ni),
2095: 
2096:     // from register interface
2097:     .we     (sw_share1_output_3_re),
2098:     .wd     (sw_share1_output_3_wd),
2099: 
2100:     // from internal hardware
2101:     .de     (hw2reg.sw_share1_output[3].de),
2102:     .d      (hw2reg.sw_share1_output[3].d),
2103: 
2104:     // to internal hardware
2105:     .qe     (),
2106:     .q      (),
2107:     .ds     (),
2108: 
2109:     // to register interface (read)
2110:     .qs     (sw_share1_output_3_qs)
2111:   );
2112: 
2113: 
2114:   // Subregister 4 of Multireg sw_share1_output
2115:   // R[sw_share1_output_4]: V(False)
2116:   prim_subreg #(
2117:     .DW      (32),
2118:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2119:     .RESVAL  (32'h0),
2120:     .Mubi    (1'b0)
2121:   ) u_sw_share1_output_4 (
2122:     .clk_i   (clk_i),
2123:     .rst_ni  (rst_ni),
2124: 
2125:     // from register interface
2126:     .we     (sw_share1_output_4_re),
2127:     .wd     (sw_share1_output_4_wd),
2128: 
2129:     // from internal hardware
2130:     .de     (hw2reg.sw_share1_output[4].de),
2131:     .d      (hw2reg.sw_share1_output[4].d),
2132: 
2133:     // to internal hardware
2134:     .qe     (),
2135:     .q      (),
2136:     .ds     (),
2137: 
2138:     // to register interface (read)
2139:     .qs     (sw_share1_output_4_qs)
2140:   );
2141: 
2142: 
2143:   // Subregister 5 of Multireg sw_share1_output
2144:   // R[sw_share1_output_5]: V(False)
2145:   prim_subreg #(
2146:     .DW      (32),
2147:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2148:     .RESVAL  (32'h0),
2149:     .Mubi    (1'b0)
2150:   ) u_sw_share1_output_5 (
2151:     .clk_i   (clk_i),
2152:     .rst_ni  (rst_ni),
2153: 
2154:     // from register interface
2155:     .we     (sw_share1_output_5_re),
2156:     .wd     (sw_share1_output_5_wd),
2157: 
2158:     // from internal hardware
2159:     .de     (hw2reg.sw_share1_output[5].de),
2160:     .d      (hw2reg.sw_share1_output[5].d),
2161: 
2162:     // to internal hardware
2163:     .qe     (),
2164:     .q      (),
2165:     .ds     (),
2166: 
2167:     // to register interface (read)
2168:     .qs     (sw_share1_output_5_qs)
2169:   );
2170: 
2171: 
2172:   // Subregister 6 of Multireg sw_share1_output
2173:   // R[sw_share1_output_6]: V(False)
2174:   prim_subreg #(
2175:     .DW      (32),
2176:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2177:     .RESVAL  (32'h0),
2178:     .Mubi    (1'b0)
2179:   ) u_sw_share1_output_6 (
2180:     .clk_i   (clk_i),
2181:     .rst_ni  (rst_ni),
2182: 
2183:     // from register interface
2184:     .we     (sw_share1_output_6_re),
2185:     .wd     (sw_share1_output_6_wd),
2186: 
2187:     // from internal hardware
2188:     .de     (hw2reg.sw_share1_output[6].de),
2189:     .d      (hw2reg.sw_share1_output[6].d),
2190: 
2191:     // to internal hardware
2192:     .qe     (),
2193:     .q      (),
2194:     .ds     (),
2195: 
2196:     // to register interface (read)
2197:     .qs     (sw_share1_output_6_qs)
2198:   );
2199: 
2200: 
2201:   // Subregister 7 of Multireg sw_share1_output
2202:   // R[sw_share1_output_7]: V(False)
2203:   prim_subreg #(
2204:     .DW      (32),
2205:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2206:     .RESVAL  (32'h0),
2207:     .Mubi    (1'b0)
2208:   ) u_sw_share1_output_7 (
2209:     .clk_i   (clk_i),
2210:     .rst_ni  (rst_ni),
2211: 
2212:     // from register interface
2213:     .we     (sw_share1_output_7_re),
2214:     .wd     (sw_share1_output_7_wd),
2215: 
2216:     // from internal hardware
2217:     .de     (hw2reg.sw_share1_output[7].de),
2218:     .d      (hw2reg.sw_share1_output[7].d),
2219: 
2220:     // to internal hardware
2221:     .qe     (),
2222:     .q      (),
2223:     .ds     (),
2224: 
2225:     // to register interface (read)
2226:     .qs     (sw_share1_output_7_qs)
2227:   );
2228: 
2229: 
2230:   // R[working_state]: V(False)
2231:   prim_subreg #(
2232:     .DW      (3),
2233:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2234:     .RESVAL  (3'h0),
2235:     .Mubi    (1'b0)
2236:   ) u_working_state (
2237:     .clk_i   (clk_i),
2238:     .rst_ni  (rst_ni),
2239: 
2240:     // from register interface
2241:     .we     (1'b0),
2242:     .wd     ('0),
2243: 
2244:     // from internal hardware
2245:     .de     (hw2reg.working_state.de),
2246:     .d      (hw2reg.working_state.d),
2247: 
2248:     // to internal hardware
2249:     .qe     (),
2250:     .q      (),
2251:     .ds     (),
2252: 
2253:     // to register interface (read)
2254:     .qs     (working_state_qs)
2255:   );
2256: 
2257: 
2258:   // R[op_status]: V(False)
2259:   prim_subreg #(
2260:     .DW      (2),
2261:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
2262:     .RESVAL  (2'h0),
2263:     .Mubi    (1'b0)
2264:   ) u_op_status (
2265:     .clk_i   (clk_i),
2266:     .rst_ni  (rst_ni),
2267: 
2268:     // from register interface
2269:     .we     (op_status_we),
2270:     .wd     (op_status_wd),
2271: 
2272:     // from internal hardware
2273:     .de     (hw2reg.op_status.de),
2274:     .d      (hw2reg.op_status.d),
2275: 
2276:     // to internal hardware
2277:     .qe     (),
2278:     .q      (),
2279:     .ds     (),
2280: 
2281:     // to register interface (read)
2282:     .qs     (op_status_qs)
2283:   );
2284: 
2285: 
2286:   // R[err_code]: V(False)
2287:   //   F[invalid_op]: 0:0
2288:   prim_subreg #(
2289:     .DW      (1),
2290:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
2291:     .RESVAL  (1'h0),
2292:     .Mubi    (1'b0)
2293:   ) u_err_code_invalid_op (
2294:     .clk_i   (clk_i),
2295:     .rst_ni  (rst_ni),
2296: 
2297:     // from register interface
2298:     .we     (err_code_we),
2299:     .wd     (err_code_invalid_op_wd),
2300: 
2301:     // from internal hardware
2302:     .de     (hw2reg.err_code.invalid_op.de),
2303:     .d      (hw2reg.err_code.invalid_op.d),
2304: 
2305:     // to internal hardware
2306:     .qe     (),
2307:     .q      (),
2308:     .ds     (),
2309: 
2310:     // to register interface (read)
2311:     .qs     (err_code_invalid_op_qs)
2312:   );
2313: 
2314:   //   F[invalid_kmac_input]: 1:1
2315:   prim_subreg #(
2316:     .DW      (1),
2317:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
2318:     .RESVAL  (1'h0),
2319:     .Mubi    (1'b0)
2320:   ) u_err_code_invalid_kmac_input (
2321:     .clk_i   (clk_i),
2322:     .rst_ni  (rst_ni),
2323: 
2324:     // from register interface
2325:     .we     (err_code_we),
2326:     .wd     (err_code_invalid_kmac_input_wd),
2327: 
2328:     // from internal hardware
2329:     .de     (hw2reg.err_code.invalid_kmac_input.de),
2330:     .d      (hw2reg.err_code.invalid_kmac_input.d),
2331: 
2332:     // to internal hardware
2333:     .qe     (),
2334:     .q      (),
2335:     .ds     (),
2336: 
2337:     // to register interface (read)
2338:     .qs     (err_code_invalid_kmac_input_qs)
2339:   );
2340: 
2341:   //   F[invalid_shadow_update]: 2:2
2342:   prim_subreg #(
2343:     .DW      (1),
2344:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
2345:     .RESVAL  (1'h0),
2346:     .Mubi    (1'b0)
2347:   ) u_err_code_invalid_shadow_update (
2348:     .clk_i   (clk_i),
2349:     .rst_ni  (rst_ni),
2350: 
2351:     // from register interface
2352:     .we     (err_code_we),
2353:     .wd     (err_code_invalid_shadow_update_wd),
2354: 
2355:     // from internal hardware
2356:     .de     (hw2reg.err_code.invalid_shadow_update.de),
2357:     .d      (hw2reg.err_code.invalid_shadow_update.d),
2358: 
2359:     // to internal hardware
2360:     .qe     (),
2361:     .q      (),
2362:     .ds     (),
2363: 
2364:     // to register interface (read)
2365:     .qs     (err_code_invalid_shadow_update_qs)
2366:   );
2367: 
2368: 
2369:   // R[fault_status]: V(False)
2370:   //   F[cmd]: 0:0
2371:   prim_subreg #(
2372:     .DW      (1),
2373:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2374:     .RESVAL  (1'h0),
2375:     .Mubi    (1'b0)
2376:   ) u_fault_status_cmd (
2377:     .clk_i   (clk_i),
2378:     .rst_ni  (rst_ni),
2379: 
2380:     // from register interface
2381:     .we     (1'b0),
2382:     .wd     ('0),
2383: 
2384:     // from internal hardware
2385:     .de     (hw2reg.fault_status.cmd.de),
2386:     .d      (hw2reg.fault_status.cmd.d),
2387: 
2388:     // to internal hardware
2389:     .qe     (),
2390:     .q      (reg2hw.fault_status.cmd.q),
2391:     .ds     (),
2392: 
2393:     // to register interface (read)
2394:     .qs     (fault_status_cmd_qs)
2395:   );
2396: 
2397:   //   F[kmac_fsm]: 1:1
2398:   prim_subreg #(
2399:     .DW      (1),
2400:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2401:     .RESVAL  (1'h0),
2402:     .Mubi    (1'b0)
2403:   ) u_fault_status_kmac_fsm (
2404:     .clk_i   (clk_i),
2405:     .rst_ni  (rst_ni),
2406: 
2407:     // from register interface
2408:     .we     (1'b0),
2409:     .wd     ('0),
2410: 
2411:     // from internal hardware
2412:     .de     (hw2reg.fault_status.kmac_fsm.de),
2413:     .d      (hw2reg.fault_status.kmac_fsm.d),
2414: 
2415:     // to internal hardware
2416:     .qe     (),
2417:     .q      (reg2hw.fault_status.kmac_fsm.q),
2418:     .ds     (),
2419: 
2420:     // to register interface (read)
2421:     .qs     (fault_status_kmac_fsm_qs)
2422:   );
2423: 
2424:   //   F[kmac_done]: 2:2
2425:   prim_subreg #(
2426:     .DW      (1),
2427:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2428:     .RESVAL  (1'h0),
2429:     .Mubi    (1'b0)
2430:   ) u_fault_status_kmac_done (
2431:     .clk_i   (clk_i),
2432:     .rst_ni  (rst_ni),
2433: 
2434:     // from register interface
2435:     .we     (1'b0),
2436:     .wd     ('0),
2437: 
2438:     // from internal hardware
2439:     .de     (hw2reg.fault_status.kmac_done.de),
2440:     .d      (hw2reg.fault_status.kmac_done.d),
2441: 
2442:     // to internal hardware
2443:     .qe     (),
2444:     .q      (reg2hw.fault_status.kmac_done.q),
2445:     .ds     (),
2446: 
2447:     // to register interface (read)
2448:     .qs     (fault_status_kmac_done_qs)
2449:   );
2450: 
2451:   //   F[kmac_op]: 3:3
2452:   prim_subreg #(
2453:     .DW      (1),
2454:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2455:     .RESVAL  (1'h0),
2456:     .Mubi    (1'b0)
2457:   ) u_fault_status_kmac_op (
2458:     .clk_i   (clk_i),
2459:     .rst_ni  (rst_ni),
2460: 
2461:     // from register interface
2462:     .we     (1'b0),
2463:     .wd     ('0),
2464: 
2465:     // from internal hardware
2466:     .de     (hw2reg.fault_status.kmac_op.de),
2467:     .d      (hw2reg.fault_status.kmac_op.d),
2468: 
2469:     // to internal hardware
2470:     .qe     (),
2471:     .q      (reg2hw.fault_status.kmac_op.q),
2472:     .ds     (),
2473: 
2474:     // to register interface (read)
2475:     .qs     (fault_status_kmac_op_qs)
2476:   );
2477: 
2478:   //   F[kmac_out]: 4:4
2479:   prim_subreg #(
2480:     .DW      (1),
2481:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2482:     .RESVAL  (1'h0),
2483:     .Mubi    (1'b0)
2484:   ) u_fault_status_kmac_out (
2485:     .clk_i   (clk_i),
2486:     .rst_ni  (rst_ni),
2487: 
2488:     // from register interface
2489:     .we     (1'b0),
2490:     .wd     ('0),
2491: 
2492:     // from internal hardware
2493:     .de     (hw2reg.fault_status.kmac_out.de),
2494:     .d      (hw2reg.fault_status.kmac_out.d),
2495: 
2496:     // to internal hardware
2497:     .qe     (),
2498:     .q      (reg2hw.fault_status.kmac_out.q),
2499:     .ds     (),
2500: 
2501:     // to register interface (read)
2502:     .qs     (fault_status_kmac_out_qs)
2503:   );
2504: 
2505:   //   F[regfile_intg]: 5:5
2506:   prim_subreg #(
2507:     .DW      (1),
2508:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2509:     .RESVAL  (1'h0),
2510:     .Mubi    (1'b0)
2511:   ) u_fault_status_regfile_intg (
2512:     .clk_i   (clk_i),
2513:     .rst_ni  (rst_ni),
2514: 
2515:     // from register interface
2516:     .we     (1'b0),
2517:     .wd     ('0),
2518: 
2519:     // from internal hardware
2520:     .de     (hw2reg.fault_status.regfile_intg.de),
2521:     .d      (hw2reg.fault_status.regfile_intg.d),
2522: 
2523:     // to internal hardware
2524:     .qe     (),
2525:     .q      (reg2hw.fault_status.regfile_intg.q),
2526:     .ds     (),
2527: 
2528:     // to register interface (read)
2529:     .qs     (fault_status_regfile_intg_qs)
2530:   );
2531: 
2532:   //   F[shadow]: 6:6
2533:   prim_subreg #(
2534:     .DW      (1),
2535:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2536:     .RESVAL  (1'h0),
2537:     .Mubi    (1'b0)
2538:   ) u_fault_status_shadow (
2539:     .clk_i   (clk_i),
2540:     .rst_ni  (rst_ni),
2541: 
2542:     // from register interface
2543:     .we     (1'b0),
2544:     .wd     ('0),
2545: 
2546:     // from internal hardware
2547:     .de     (hw2reg.fault_status.shadow.de),
2548:     .d      (hw2reg.fault_status.shadow.d),
2549: 
2550:     // to internal hardware
2551:     .qe     (),
2552:     .q      (reg2hw.fault_status.shadow.q),
2553:     .ds     (),
2554: 
2555:     // to register interface (read)
2556:     .qs     (fault_status_shadow_qs)
2557:   );
2558: 
2559:   //   F[ctrl_fsm_intg]: 7:7
2560:   prim_subreg #(
2561:     .DW      (1),
2562:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2563:     .RESVAL  (1'h0),
2564:     .Mubi    (1'b0)
2565:   ) u_fault_status_ctrl_fsm_intg (
2566:     .clk_i   (clk_i),
2567:     .rst_ni  (rst_ni),
2568: 
2569:     // from register interface
2570:     .we     (1'b0),
2571:     .wd     ('0),
2572: 
2573:     // from internal hardware
2574:     .de     (hw2reg.fault_status.ctrl_fsm_intg.de),
2575:     .d      (hw2reg.fault_status.ctrl_fsm_intg.d),
2576: 
2577:     // to internal hardware
2578:     .qe     (),
2579:     .q      (reg2hw.fault_status.ctrl_fsm_intg.q),
2580:     .ds     (),
2581: 
2582:     // to register interface (read)
2583:     .qs     (fault_status_ctrl_fsm_intg_qs)
2584:   );
2585: 
2586:   //   F[ctrl_fsm_chk]: 8:8
2587:   prim_subreg #(
2588:     .DW      (1),
2589:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2590:     .RESVAL  (1'h0),
2591:     .Mubi    (1'b0)
2592:   ) u_fault_status_ctrl_fsm_chk (
2593:     .clk_i   (clk_i),
2594:     .rst_ni  (rst_ni),
2595: 
2596:     // from register interface
2597:     .we     (1'b0),
2598:     .wd     ('0),
2599: 
2600:     // from internal hardware
2601:     .de     (hw2reg.fault_status.ctrl_fsm_chk.de),
2602:     .d      (hw2reg.fault_status.ctrl_fsm_chk.d),
2603: 
2604:     // to internal hardware
2605:     .qe     (),
2606:     .q      (reg2hw.fault_status.ctrl_fsm_chk.q),
2607:     .ds     (),
2608: 
2609:     // to register interface (read)
2610:     .qs     (fault_status_ctrl_fsm_chk_qs)
2611:   );
2612: 
2613:   //   F[ctrl_fsm_cnt]: 9:9
2614:   prim_subreg #(
2615:     .DW      (1),
2616:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2617:     .RESVAL  (1'h0),
2618:     .Mubi    (1'b0)
2619:   ) u_fault_status_ctrl_fsm_cnt (
2620:     .clk_i   (clk_i),
2621:     .rst_ni  (rst_ni),
2622: 
2623:     // from register interface
2624:     .we     (1'b0),
2625:     .wd     ('0),
2626: 
2627:     // from internal hardware
2628:     .de     (hw2reg.fault_status.ctrl_fsm_cnt.de),
2629:     .d      (hw2reg.fault_status.ctrl_fsm_cnt.d),
2630: 
2631:     // to internal hardware
2632:     .qe     (),
2633:     .q      (reg2hw.fault_status.ctrl_fsm_cnt.q),
2634:     .ds     (),
2635: 
2636:     // to register interface (read)
2637:     .qs     (fault_status_ctrl_fsm_cnt_qs)
2638:   );
2639: 
2640:   //   F[reseed_cnt]: 10:10
2641:   prim_subreg #(
2642:     .DW      (1),
2643:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2644:     .RESVAL  (1'h0),
2645:     .Mubi    (1'b0)
2646:   ) u_fault_status_reseed_cnt (
2647:     .clk_i   (clk_i),
2648:     .rst_ni  (rst_ni),
2649: 
2650:     // from register interface
2651:     .we     (1'b0),
2652:     .wd     ('0),
2653: 
2654:     // from internal hardware
2655:     .de     (hw2reg.fault_status.reseed_cnt.de),
2656:     .d      (hw2reg.fault_status.reseed_cnt.d),
2657: 
2658:     // to internal hardware
2659:     .qe     (),
2660:     .q      (reg2hw.fault_status.reseed_cnt.q),
2661:     .ds     (),
2662: 
2663:     // to register interface (read)
2664:     .qs     (fault_status_reseed_cnt_qs)
2665:   );
2666: 
2667:   //   F[side_ctrl_fsm]: 11:11
2668:   prim_subreg #(
2669:     .DW      (1),
2670:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2671:     .RESVAL  (1'h0),
2672:     .Mubi    (1'b0)
2673:   ) u_fault_status_side_ctrl_fsm (
2674:     .clk_i   (clk_i),
2675:     .rst_ni  (rst_ni),
2676: 
2677:     // from register interface
2678:     .we     (1'b0),
2679:     .wd     ('0),
2680: 
2681:     // from internal hardware
2682:     .de     (hw2reg.fault_status.side_ctrl_fsm.de),
2683:     .d      (hw2reg.fault_status.side_ctrl_fsm.d),
2684: 
2685:     // to internal hardware
2686:     .qe     (),
2687:     .q      (reg2hw.fault_status.side_ctrl_fsm.q),
2688:     .ds     (),
2689: 
2690:     // to register interface (read)
2691:     .qs     (fault_status_side_ctrl_fsm_qs)
2692:   );
2693: 
2694:   //   F[side_ctrl_sel]: 12:12
2695:   prim_subreg #(
2696:     .DW      (1),
2697:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2698:     .RESVAL  (1'h0),
2699:     .Mubi    (1'b0)
2700:   ) u_fault_status_side_ctrl_sel (
2701:     .clk_i   (clk_i),
2702:     .rst_ni  (rst_ni),
2703: 
2704:     // from register interface
2705:     .we     (1'b0),
2706:     .wd     ('0),
2707: 
2708:     // from internal hardware
2709:     .de     (hw2reg.fault_status.side_ctrl_sel.de),
2710:     .d      (hw2reg.fault_status.side_ctrl_sel.d),
2711: 
2712:     // to internal hardware
2713:     .qe     (),
2714:     .q      (reg2hw.fault_status.side_ctrl_sel.q),
2715:     .ds     (),
2716: 
2717:     // to register interface (read)
2718:     .qs     (fault_status_side_ctrl_sel_qs)
2719:   );
2720: 
2721:   //   F[key_ecc]: 13:13
2722:   prim_subreg #(
2723:     .DW      (1),
2724:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2725:     .RESVAL  (1'h0),
2726:     .Mubi    (1'b0)
2727:   ) u_fault_status_key_ecc (
2728:     .clk_i   (clk_i),
2729:     .rst_ni  (rst_ni),
2730: 
2731:     // from register interface
2732:     .we     (1'b0),
2733:     .wd     ('0),
2734: 
2735:     // from internal hardware
2736:     .de     (hw2reg.fault_status.key_ecc.de),
2737:     .d      (hw2reg.fault_status.key_ecc.d),
2738: 
2739:     // to internal hardware
2740:     .qe     (),
2741:     .q      (reg2hw.fault_status.key_ecc.q),
2742:     .ds     (),
2743: 
2744:     // to register interface (read)
2745:     .qs     (fault_status_key_ecc_qs)
2746:   );
2747: 
2748: 
2749:   // R[debug]: V(False)
2750:   //   F[invalid_creator_seed]: 0:0
2751:   prim_subreg #(
2752:     .DW      (1),
2753:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2754:     .RESVAL  (1'h0),
2755:     .Mubi    (1'b0)
2756:   ) u_debug_invalid_creator_seed (
2757:     .clk_i   (clk_i),
2758:     .rst_ni  (rst_ni),
2759: 
2760:     // from register interface
2761:     .we     (debug_we),
2762:     .wd     (debug_invalid_creator_seed_wd),
2763: 
2764:     // from internal hardware
2765:     .de     (hw2reg.debug.invalid_creator_seed.de),
2766:     .d      (hw2reg.debug.invalid_creator_seed.d),
2767: 
2768:     // to internal hardware
2769:     .qe     (),
2770:     .q      (),
2771:     .ds     (),
2772: 
2773:     // to register interface (read)
2774:     .qs     (debug_invalid_creator_seed_qs)
2775:   );
2776: 
2777:   //   F[invalid_owner_seed]: 1:1
2778:   prim_subreg #(
2779:     .DW      (1),
2780:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2781:     .RESVAL  (1'h0),
2782:     .Mubi    (1'b0)
2783:   ) u_debug_invalid_owner_seed (
2784:     .clk_i   (clk_i),
2785:     .rst_ni  (rst_ni),
2786: 
2787:     // from register interface
2788:     .we     (debug_we),
2789:     .wd     (debug_invalid_owner_seed_wd),
2790: 
2791:     // from internal hardware
2792:     .de     (hw2reg.debug.invalid_owner_seed.de),
2793:     .d      (hw2reg.debug.invalid_owner_seed.d),
2794: 
2795:     // to internal hardware
2796:     .qe     (),
2797:     .q      (),
2798:     .ds     (),
2799: 
2800:     // to register interface (read)
2801:     .qs     (debug_invalid_owner_seed_qs)
2802:   );
2803: 
2804:   //   F[invalid_dev_id]: 2:2
2805:   prim_subreg #(
2806:     .DW      (1),
2807:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2808:     .RESVAL  (1'h0),
2809:     .Mubi    (1'b0)
2810:   ) u_debug_invalid_dev_id (
2811:     .clk_i   (clk_i),
2812:     .rst_ni  (rst_ni),
2813: 
2814:     // from register interface
2815:     .we     (debug_we),
2816:     .wd     (debug_invalid_dev_id_wd),
2817: 
2818:     // from internal hardware
2819:     .de     (hw2reg.debug.invalid_dev_id.de),
2820:     .d      (hw2reg.debug.invalid_dev_id.d),
2821: 
2822:     // to internal hardware
2823:     .qe     (),
2824:     .q      (),
2825:     .ds     (),
2826: 
2827:     // to register interface (read)
2828:     .qs     (debug_invalid_dev_id_qs)
2829:   );
2830: 
2831:   //   F[invalid_health_state]: 3:3
2832:   prim_subreg #(
2833:     .DW      (1),
2834:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2835:     .RESVAL  (1'h0),
2836:     .Mubi    (1'b0)
2837:   ) u_debug_invalid_health_state (
2838:     .clk_i   (clk_i),
2839:     .rst_ni  (rst_ni),
2840: 
2841:     // from register interface
2842:     .we     (debug_we),
2843:     .wd     (debug_invalid_health_state_wd),
2844: 
2845:     // from internal hardware
2846:     .de     (hw2reg.debug.invalid_health_state.de),
2847:     .d      (hw2reg.debug.invalid_health_state.d),
2848: 
2849:     // to internal hardware
2850:     .qe     (),
2851:     .q      (),
2852:     .ds     (),
2853: 
2854:     // to register interface (read)
2855:     .qs     (debug_invalid_health_state_qs)
2856:   );
2857: 
2858:   //   F[invalid_key_version]: 4:4
2859:   prim_subreg #(
2860:     .DW      (1),
2861:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2862:     .RESVAL  (1'h0),
2863:     .Mubi    (1'b0)
2864:   ) u_debug_invalid_key_version (
2865:     .clk_i   (clk_i),
2866:     .rst_ni  (rst_ni),
2867: 
2868:     // from register interface
2869:     .we     (debug_we),
2870:     .wd     (debug_invalid_key_version_wd),
2871: 
2872:     // from internal hardware
2873:     .de     (hw2reg.debug.invalid_key_version.de),
2874:     .d      (hw2reg.debug.invalid_key_version.d),
2875: 
2876:     // to internal hardware
2877:     .qe     (),
2878:     .q      (),
2879:     .ds     (),
2880: 
2881:     // to register interface (read)
2882:     .qs     (debug_invalid_key_version_qs)
2883:   );
2884: 
2885:   //   F[invalid_key]: 5:5
2886:   prim_subreg #(
2887:     .DW      (1),
2888:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2889:     .RESVAL  (1'h0),
2890:     .Mubi    (1'b0)
2891:   ) u_debug_invalid_key (
2892:     .clk_i   (clk_i),
2893:     .rst_ni  (rst_ni),
2894: 
2895:     // from register interface
2896:     .we     (debug_we),
2897:     .wd     (debug_invalid_key_wd),
2898: 
2899:     // from internal hardware
2900:     .de     (hw2reg.debug.invalid_key.de),
2901:     .d      (hw2reg.debug.invalid_key.d),
2902: 
2903:     // to internal hardware
2904:     .qe     (),
2905:     .q      (),
2906:     .ds     (),
2907: 
2908:     // to register interface (read)
2909:     .qs     (debug_invalid_key_qs)
2910:   );
2911: 
2912:   //   F[invalid_digest]: 6:6
2913:   prim_subreg #(
2914:     .DW      (1),
2915:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2916:     .RESVAL  (1'h0),
2917:     .Mubi    (1'b0)
2918:   ) u_debug_invalid_digest (
2919:     .clk_i   (clk_i),
2920:     .rst_ni  (rst_ni),
2921: 
2922:     // from register interface
2923:     .we     (debug_we),
2924:     .wd     (debug_invalid_digest_wd),
2925: 
2926:     // from internal hardware
2927:     .de     (hw2reg.debug.invalid_digest.de),
2928:     .d      (hw2reg.debug.invalid_digest.d),
2929: 
2930:     // to internal hardware
2931:     .qe     (),
2932:     .q      (),
2933:     .ds     (),
2934: 
2935:     // to register interface (read)
2936:     .qs     (debug_invalid_digest_qs)
2937:   );
2938: 
2939: 
2940: 
2941:   logic [62:0] addr_hit;
2942:   always_comb begin
2943:     addr_hit = '0;
2944:     addr_hit[ 0] = (reg_addr == KEYMGR_INTR_STATE_OFFSET);
2945:     addr_hit[ 1] = (reg_addr == KEYMGR_INTR_ENABLE_OFFSET);
2946:     addr_hit[ 2] = (reg_addr == KEYMGR_INTR_TEST_OFFSET);
2947:     addr_hit[ 3] = (reg_addr == KEYMGR_ALERT_TEST_OFFSET);
2948:     addr_hit[ 4] = (reg_addr == KEYMGR_CFG_REGWEN_OFFSET);
2949:     addr_hit[ 5] = (reg_addr == KEYMGR_START_OFFSET);
2950:     addr_hit[ 6] = (reg_addr == KEYMGR_CONTROL_SHADOWED_OFFSET);
2951:     addr_hit[ 7] = (reg_addr == KEYMGR_SIDELOAD_CLEAR_OFFSET);
2952:     addr_hit[ 8] = (reg_addr == KEYMGR_RESEED_INTERVAL_REGWEN_OFFSET);
2953:     addr_hit[ 9] = (reg_addr == KEYMGR_RESEED_INTERVAL_SHADOWED_OFFSET);
2954:     addr_hit[10] = (reg_addr == KEYMGR_SW_BINDING_REGWEN_OFFSET);
2955:     addr_hit[11] = (reg_addr == KEYMGR_SEALING_SW_BINDING_0_OFFSET);
2956:     addr_hit[12] = (reg_addr == KEYMGR_SEALING_SW_BINDING_1_OFFSET);
2957:     addr_hit[13] = (reg_addr == KEYMGR_SEALING_SW_BINDING_2_OFFSET);
2958:     addr_hit[14] = (reg_addr == KEYMGR_SEALING_SW_BINDING_3_OFFSET);
2959:     addr_hit[15] = (reg_addr == KEYMGR_SEALING_SW_BINDING_4_OFFSET);
2960:     addr_hit[16] = (reg_addr == KEYMGR_SEALING_SW_BINDING_5_OFFSET);
2961:     addr_hit[17] = (reg_addr == KEYMGR_SEALING_SW_BINDING_6_OFFSET);
2962:     addr_hit[18] = (reg_addr == KEYMGR_SEALING_SW_BINDING_7_OFFSET);
2963:     addr_hit[19] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_0_OFFSET);
2964:     addr_hit[20] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_1_OFFSET);
2965:     addr_hit[21] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_2_OFFSET);
2966:     addr_hit[22] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_3_OFFSET);
2967:     addr_hit[23] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_4_OFFSET);
2968:     addr_hit[24] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_5_OFFSET);
2969:     addr_hit[25] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_6_OFFSET);
2970:     addr_hit[26] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_7_OFFSET);
2971:     addr_hit[27] = (reg_addr == KEYMGR_SALT_0_OFFSET);
2972:     addr_hit[28] = (reg_addr == KEYMGR_SALT_1_OFFSET);
2973:     addr_hit[29] = (reg_addr == KEYMGR_SALT_2_OFFSET);
2974:     addr_hit[30] = (reg_addr == KEYMGR_SALT_3_OFFSET);
2975:     addr_hit[31] = (reg_addr == KEYMGR_SALT_4_OFFSET);
2976:     addr_hit[32] = (reg_addr == KEYMGR_SALT_5_OFFSET);
2977:     addr_hit[33] = (reg_addr == KEYMGR_SALT_6_OFFSET);
2978:     addr_hit[34] = (reg_addr == KEYMGR_SALT_7_OFFSET);
2979:     addr_hit[35] = (reg_addr == KEYMGR_KEY_VERSION_OFFSET);
2980:     addr_hit[36] = (reg_addr == KEYMGR_MAX_CREATOR_KEY_VER_REGWEN_OFFSET);
2981:     addr_hit[37] = (reg_addr == KEYMGR_MAX_CREATOR_KEY_VER_SHADOWED_OFFSET);
2982:     addr_hit[38] = (reg_addr == KEYMGR_MAX_OWNER_INT_KEY_VER_REGWEN_OFFSET);
2983:     addr_hit[39] = (reg_addr == KEYMGR_MAX_OWNER_INT_KEY_VER_SHADOWED_OFFSET);
2984:     addr_hit[40] = (reg_addr == KEYMGR_MAX_OWNER_KEY_VER_REGWEN_OFFSET);
2985:     addr_hit[41] = (reg_addr == KEYMGR_MAX_OWNER_KEY_VER_SHADOWED_OFFSET);
2986:     addr_hit[42] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_0_OFFSET);
2987:     addr_hit[43] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_1_OFFSET);
2988:     addr_hit[44] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_2_OFFSET);
2989:     addr_hit[45] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_3_OFFSET);
2990:     addr_hit[46] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_4_OFFSET);
2991:     addr_hit[47] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_5_OFFSET);
2992:     addr_hit[48] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_6_OFFSET);
2993:     addr_hit[49] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_7_OFFSET);
2994:     addr_hit[50] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_0_OFFSET);
2995:     addr_hit[51] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_1_OFFSET);
2996:     addr_hit[52] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_2_OFFSET);
2997:     addr_hit[53] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_3_OFFSET);
2998:     addr_hit[54] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_4_OFFSET);
2999:     addr_hit[55] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_5_OFFSET);
3000:     addr_hit[56] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_6_OFFSET);
3001:     addr_hit[57] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_7_OFFSET);
3002:     addr_hit[58] = (reg_addr == KEYMGR_WORKING_STATE_OFFSET);
3003:     addr_hit[59] = (reg_addr == KEYMGR_OP_STATUS_OFFSET);
3004:     addr_hit[60] = (reg_addr == KEYMGR_ERR_CODE_OFFSET);
3005:     addr_hit[61] = (reg_addr == KEYMGR_FAULT_STATUS_OFFSET);
3006:     addr_hit[62] = (reg_addr == KEYMGR_DEBUG_OFFSET);
3007:   end
3008: 
3009:   assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;
3010: 
3011:   // Check sub-word write is permitted
3012:   always_comb begin
3013:     wr_err = (reg_we &
3014:               ((addr_hit[ 0] & (|(KEYMGR_PERMIT[ 0] & ~reg_be))) |
3015:                (addr_hit[ 1] & (|(KEYMGR_PERMIT[ 1] & ~reg_be))) |
3016:                (addr_hit[ 2] & (|(KEYMGR_PERMIT[ 2] & ~reg_be))) |
3017:                (addr_hit[ 3] & (|(KEYMGR_PERMIT[ 3] & ~reg_be))) |
3018:                (addr_hit[ 4] & (|(KEYMGR_PERMIT[ 4] & ~reg_be))) |
3019:                (addr_hit[ 5] & (|(KEYMGR_PERMIT[ 5] & ~reg_be))) |
3020:                (addr_hit[ 6] & (|(KEYMGR_PERMIT[ 6] & ~reg_be))) |
3021:                (addr_hit[ 7] & (|(KEYMGR_PERMIT[ 7] & ~reg_be))) |
3022:                (addr_hit[ 8] & (|(KEYMGR_PERMIT[ 8] & ~reg_be))) |
3023:                (addr_hit[ 9] & (|(KEYMGR_PERMIT[ 9] & ~reg_be))) |
3024:                (addr_hit[10] & (|(KEYMGR_PERMIT[10] & ~reg_be))) |
3025:                (addr_hit[11] & (|(KEYMGR_PERMIT[11] & ~reg_be))) |
3026:                (addr_hit[12] & (|(KEYMGR_PERMIT[12] & ~reg_be))) |
3027:                (addr_hit[13] & (|(KEYMGR_PERMIT[13] & ~reg_be))) |
3028:                (addr_hit[14] & (|(KEYMGR_PERMIT[14] & ~reg_be))) |
3029:                (addr_hit[15] & (|(KEYMGR_PERMIT[15] & ~reg_be))) |
3030:                (addr_hit[16] & (|(KEYMGR_PERMIT[16] & ~reg_be))) |
3031:                (addr_hit[17] & (|(KEYMGR_PERMIT[17] & ~reg_be))) |
3032:                (addr_hit[18] & (|(KEYMGR_PERMIT[18] & ~reg_be))) |
3033:                (addr_hit[19] & (|(KEYMGR_PERMIT[19] & ~reg_be))) |
3034:                (addr_hit[20] & (|(KEYMGR_PERMIT[20] & ~reg_be))) |
3035:                (addr_hit[21] & (|(KEYMGR_PERMIT[21] & ~reg_be))) |
3036:                (addr_hit[22] & (|(KEYMGR_PERMIT[22] & ~reg_be))) |
3037:                (addr_hit[23] & (|(KEYMGR_PERMIT[23] & ~reg_be))) |
3038:                (addr_hit[24] & (|(KEYMGR_PERMIT[24] & ~reg_be))) |
3039:                (addr_hit[25] & (|(KEYMGR_PERMIT[25] & ~reg_be))) |
3040:                (addr_hit[26] & (|(KEYMGR_PERMIT[26] & ~reg_be))) |
3041:                (addr_hit[27] & (|(KEYMGR_PERMIT[27] & ~reg_be))) |
3042:                (addr_hit[28] & (|(KEYMGR_PERMIT[28] & ~reg_be))) |
3043:                (addr_hit[29] & (|(KEYMGR_PERMIT[29] & ~reg_be))) |
3044:                (addr_hit[30] & (|(KEYMGR_PERMIT[30] & ~reg_be))) |
3045:                (addr_hit[31] & (|(KEYMGR_PERMIT[31] & ~reg_be))) |
3046:                (addr_hit[32] & (|(KEYMGR_PERMIT[32] & ~reg_be))) |
3047:                (addr_hit[33] & (|(KEYMGR_PERMIT[33] & ~reg_be))) |
3048:                (addr_hit[34] & (|(KEYMGR_PERMIT[34] & ~reg_be))) |
3049:                (addr_hit[35] & (|(KEYMGR_PERMIT[35] & ~reg_be))) |
3050:                (addr_hit[36] & (|(KEYMGR_PERMIT[36] & ~reg_be))) |
3051:                (addr_hit[37] & (|(KEYMGR_PERMIT[37] & ~reg_be))) |
3052:                (addr_hit[38] & (|(KEYMGR_PERMIT[38] & ~reg_be))) |
3053:                (addr_hit[39] & (|(KEYMGR_PERMIT[39] & ~reg_be))) |
3054:                (addr_hit[40] & (|(KEYMGR_PERMIT[40] & ~reg_be))) |
3055:                (addr_hit[41] & (|(KEYMGR_PERMIT[41] & ~reg_be))) |
3056:                (addr_hit[42] & (|(KEYMGR_PERMIT[42] & ~reg_be))) |
3057:                (addr_hit[43] & (|(KEYMGR_PERMIT[43] & ~reg_be))) |
3058:                (addr_hit[44] & (|(KEYMGR_PERMIT[44] & ~reg_be))) |
3059:                (addr_hit[45] & (|(KEYMGR_PERMIT[45] & ~reg_be))) |
3060:                (addr_hit[46] & (|(KEYMGR_PERMIT[46] & ~reg_be))) |
3061:                (addr_hit[47] & (|(KEYMGR_PERMIT[47] & ~reg_be))) |
3062:                (addr_hit[48] & (|(KEYMGR_PERMIT[48] & ~reg_be))) |
3063:                (addr_hit[49] & (|(KEYMGR_PERMIT[49] & ~reg_be))) |
3064:                (addr_hit[50] & (|(KEYMGR_PERMIT[50] & ~reg_be))) |
3065:                (addr_hit[51] & (|(KEYMGR_PERMIT[51] & ~reg_be))) |
3066:                (addr_hit[52] & (|(KEYMGR_PERMIT[52] & ~reg_be))) |
3067:                (addr_hit[53] & (|(KEYMGR_PERMIT[53] & ~reg_be))) |
3068:                (addr_hit[54] & (|(KEYMGR_PERMIT[54] & ~reg_be))) |
3069:                (addr_hit[55] & (|(KEYMGR_PERMIT[55] & ~reg_be))) |
3070:                (addr_hit[56] & (|(KEYMGR_PERMIT[56] & ~reg_be))) |
3071:                (addr_hit[57] & (|(KEYMGR_PERMIT[57] & ~reg_be))) |
3072:                (addr_hit[58] & (|(KEYMGR_PERMIT[58] & ~reg_be))) |
3073:                (addr_hit[59] & (|(KEYMGR_PERMIT[59] & ~reg_be))) |
3074:                (addr_hit[60] & (|(KEYMGR_PERMIT[60] & ~reg_be))) |
3075:                (addr_hit[61] & (|(KEYMGR_PERMIT[61] & ~reg_be))) |
3076:                (addr_hit[62] & (|(KEYMGR_PERMIT[62] & ~reg_be)))));
3077:   end
3078: 
3079:   // Generate write-enables
3080:   assign intr_state_we = addr_hit[0] & reg_we & !reg_error;
3081: 
3082:   assign intr_state_wd = reg_wdata[0];
3083:   assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;
3084: 
3085:   assign intr_enable_wd = reg_wdata[0];
3086:   assign intr_test_we = addr_hit[2] & reg_we & !reg_error;
3087: 
3088:   assign intr_test_wd = reg_wdata[0];
3089:   assign alert_test_we = addr_hit[3] & reg_we & !reg_error;
3090: 
3091:   assign alert_test_recov_operation_err_wd = reg_wdata[0];
3092: 
3093:   assign alert_test_fatal_fault_err_wd = reg_wdata[1];
3094:   assign cfg_regwen_re = addr_hit[4] & reg_re & !reg_error;
3095:   assign start_we = addr_hit[5] & reg_we & !reg_error;
3096: 
3097:   assign start_wd = reg_wdata[0];
3098:   assign control_shadowed_re = addr_hit[6] & reg_re & !reg_error;
3099:   assign control_shadowed_we = addr_hit[6] & reg_we & !reg_error;
3100: 
3101:   assign control_shadowed_operation_wd = reg_wdata[6:4];
3102: 
3103:   assign control_shadowed_cdi_sel_wd = reg_wdata[7];
3104: 
3105:   assign control_shadowed_dest_sel_wd = reg_wdata[13:12];
3106:   assign sideload_clear_we = addr_hit[7] & reg_we & !reg_error;
3107: 
3108:   assign sideload_clear_wd = reg_wdata[2:0];
3109:   assign reseed_interval_regwen_we = addr_hit[8] & reg_we & !reg_error;
3110: 
3111:   assign reseed_interval_regwen_wd = reg_wdata[0];
3112:   assign reseed_interval_shadowed_re = addr_hit[9] & reg_re & !reg_error;
3113:   assign reseed_interval_shadowed_we = addr_hit[9] & reg_we & !reg_error;
3114: 
3115:   assign reseed_interval_shadowed_wd = reg_wdata[15:0];
3116:   assign sw_binding_regwen_re = addr_hit[10] & reg_re & !reg_error;
3117:   assign sw_binding_regwen_we = addr_hit[10] & reg_we & !reg_error;
3118: 
3119:   assign sw_binding_regwen_wd = reg_wdata[0];
3120:   assign sealing_sw_binding_0_we = addr_hit[11] & reg_we & !reg_error;
3121: 
3122:   assign sealing_sw_binding_0_wd = reg_wdata[31:0];
3123:   assign sealing_sw_binding_1_we = addr_hit[12] & reg_we & !reg_error;
3124: 
3125:   assign sealing_sw_binding_1_wd = reg_wdata[31:0];
3126:   assign sealing_sw_binding_2_we = addr_hit[13] & reg_we & !reg_error;
3127: 
3128:   assign sealing_sw_binding_2_wd = reg_wdata[31:0];
3129:   assign sealing_sw_binding_3_we = addr_hit[14] & reg_we & !reg_error;
3130: 
3131:   assign sealing_sw_binding_3_wd = reg_wdata[31:0];
3132:   assign sealing_sw_binding_4_we = addr_hit[15] & reg_we & !reg_error;
3133: 
3134:   assign sealing_sw_binding_4_wd = reg_wdata[31:0];
3135:   assign sealing_sw_binding_5_we = addr_hit[16] & reg_we & !reg_error;
3136: 
3137:   assign sealing_sw_binding_5_wd = reg_wdata[31:0];
3138:   assign sealing_sw_binding_6_we = addr_hit[17] & reg_we & !reg_error;
3139: 
3140:   assign sealing_sw_binding_6_wd = reg_wdata[31:0];
3141:   assign sealing_sw_binding_7_we = addr_hit[18] & reg_we & !reg_error;
3142: 
3143:   assign sealing_sw_binding_7_wd = reg_wdata[31:0];
3144:   assign attest_sw_binding_0_we = addr_hit[19] & reg_we & !reg_error;
3145: 
3146:   assign attest_sw_binding_0_wd = reg_wdata[31:0];
3147:   assign attest_sw_binding_1_we = addr_hit[20] & reg_we & !reg_error;
3148: 
3149:   assign attest_sw_binding_1_wd = reg_wdata[31:0];
3150:   assign attest_sw_binding_2_we = addr_hit[21] & reg_we & !reg_error;
3151: 
3152:   assign attest_sw_binding_2_wd = reg_wdata[31:0];
3153:   assign attest_sw_binding_3_we = addr_hit[22] & reg_we & !reg_error;
3154: 
3155:   assign attest_sw_binding_3_wd = reg_wdata[31:0];
3156:   assign attest_sw_binding_4_we = addr_hit[23] & reg_we & !reg_error;
3157: 
3158:   assign attest_sw_binding_4_wd = reg_wdata[31:0];
3159:   assign attest_sw_binding_5_we = addr_hit[24] & reg_we & !reg_error;
3160: 
3161:   assign attest_sw_binding_5_wd = reg_wdata[31:0];
3162:   assign attest_sw_binding_6_we = addr_hit[25] & reg_we & !reg_error;
3163: 
3164:   assign attest_sw_binding_6_wd = reg_wdata[31:0];
3165:   assign attest_sw_binding_7_we = addr_hit[26] & reg_we & !reg_error;
3166: 
3167:   assign attest_sw_binding_7_wd = reg_wdata[31:0];
3168:   assign salt_0_we = addr_hit[27] & reg_we & !reg_error;
3169: 
3170:   assign salt_0_wd = reg_wdata[31:0];
3171:   assign salt_1_we = addr_hit[28] & reg_we & !reg_error;
3172: 
3173:   assign salt_1_wd = reg_wdata[31:0];
3174:   assign salt_2_we = addr_hit[29] & reg_we & !reg_error;
3175: 
3176:   assign salt_2_wd = reg_wdata[31:0];
3177:   assign salt_3_we = addr_hit[30] & reg_we & !reg_error;
3178: 
3179:   assign salt_3_wd = reg_wdata[31:0];
3180:   assign salt_4_we = addr_hit[31] & reg_we & !reg_error;
3181: 
3182:   assign salt_4_wd = reg_wdata[31:0];
3183:   assign salt_5_we = addr_hit[32] & reg_we & !reg_error;
3184: 
3185:   assign salt_5_wd = reg_wdata[31:0];
3186:   assign salt_6_we = addr_hit[33] & reg_we & !reg_error;
3187: 
3188:   assign salt_6_wd = reg_wdata[31:0];
3189:   assign salt_7_we = addr_hit[34] & reg_we & !reg_error;
3190: 
3191:   assign salt_7_wd = reg_wdata[31:0];
3192:   assign key_version_we = addr_hit[35] & reg_we & !reg_error;
3193: 
3194:   assign key_version_wd = reg_wdata[31:0];
3195:   assign max_creator_key_ver_regwen_we = addr_hit[36] & reg_we & !reg_error;
3196: 
3197:   assign max_creator_key_ver_regwen_wd = reg_wdata[0];
3198:   assign max_creator_key_ver_shadowed_re = addr_hit[37] & reg_re & !reg_error;
3199:   assign max_creator_key_ver_shadowed_we = addr_hit[37] & reg_we & !reg_error;
3200: 
3201:   assign max_creator_key_ver_shadowed_wd = reg_wdata[31:0];
3202:   assign max_owner_int_key_ver_regwen_we = addr_hit[38] & reg_we & !reg_error;
3203: 
3204:   assign max_owner_int_key_ver_regwen_wd = reg_wdata[0];
3205:   assign max_owner_int_key_ver_shadowed_re = addr_hit[39] & reg_re & !reg_error;
3206:   assign max_owner_int_key_ver_shadowed_we = addr_hit[39] & reg_we & !reg_error;
3207: 
3208:   assign max_owner_int_key_ver_shadowed_wd = reg_wdata[31:0];
3209:   assign max_owner_key_ver_regwen_we = addr_hit[40] & reg_we & !reg_error;
3210: 
3211:   assign max_owner_key_ver_regwen_wd = reg_wdata[0];
3212:   assign max_owner_key_ver_shadowed_re = addr_hit[41] & reg_re & !reg_error;
3213:   assign max_owner_key_ver_shadowed_we = addr_hit[41] & reg_we & !reg_error;
3214: 
3215:   assign max_owner_key_ver_shadowed_wd = reg_wdata[31:0];
3216:   assign sw_share0_output_0_re = addr_hit[42] & reg_re & !reg_error;
3217: 
3218:   assign sw_share0_output_0_wd = '1;
3219:   assign sw_share0_output_1_re = addr_hit[43] & reg_re & !reg_error;
3220: 
3221:   assign sw_share0_output_1_wd = '1;
3222:   assign sw_share0_output_2_re = addr_hit[44] & reg_re & !reg_error;
3223: 
3224:   assign sw_share0_output_2_wd = '1;
3225:   assign sw_share0_output_3_re = addr_hit[45] & reg_re & !reg_error;
3226: 
3227:   assign sw_share0_output_3_wd = '1;
3228:   assign sw_share0_output_4_re = addr_hit[46] & reg_re & !reg_error;
3229: 
3230:   assign sw_share0_output_4_wd = '1;
3231:   assign sw_share0_output_5_re = addr_hit[47] & reg_re & !reg_error;
3232: 
3233:   assign sw_share0_output_5_wd = '1;
3234:   assign sw_share0_output_6_re = addr_hit[48] & reg_re & !reg_error;
3235: 
3236:   assign sw_share0_output_6_wd = '1;
3237:   assign sw_share0_output_7_re = addr_hit[49] & reg_re & !reg_error;
3238: 
3239:   assign sw_share0_output_7_wd = '1;
3240:   assign sw_share1_output_0_re = addr_hit[50] & reg_re & !reg_error;
3241: 
3242:   assign sw_share1_output_0_wd = '1;
3243:   assign sw_share1_output_1_re = addr_hit[51] & reg_re & !reg_error;
3244: 
3245:   assign sw_share1_output_1_wd = '1;
3246:   assign sw_share1_output_2_re = addr_hit[52] & reg_re & !reg_error;
3247: 
3248:   assign sw_share1_output_2_wd = '1;
3249:   assign sw_share1_output_3_re = addr_hit[53] & reg_re & !reg_error;
3250: 
3251:   assign sw_share1_output_3_wd = '1;
3252:   assign sw_share1_output_4_re = addr_hit[54] & reg_re & !reg_error;
3253: 
3254:   assign sw_share1_output_4_wd = '1;
3255:   assign sw_share1_output_5_re = addr_hit[55] & reg_re & !reg_error;
3256: 
3257:   assign sw_share1_output_5_wd = '1;
3258:   assign sw_share1_output_6_re = addr_hit[56] & reg_re & !reg_error;
3259: 
3260:   assign sw_share1_output_6_wd = '1;
3261:   assign sw_share1_output_7_re = addr_hit[57] & reg_re & !reg_error;
3262: 
3263:   assign sw_share1_output_7_wd = '1;
3264:   assign op_status_we = addr_hit[59] & reg_we & !reg_error;
3265: 
3266:   assign op_status_wd = reg_wdata[1:0];
3267:   assign err_code_we = addr_hit[60] & reg_we & !reg_error;
3268: 
3269:   assign err_code_invalid_op_wd = reg_wdata[0];
3270: 
3271:   assign err_code_invalid_kmac_input_wd = reg_wdata[1];
3272: 
3273:   assign err_code_invalid_shadow_update_wd = reg_wdata[2];
3274:   assign debug_we = addr_hit[62] & reg_we & !reg_error;
3275: 
3276:   assign debug_invalid_creator_seed_wd = reg_wdata[0];
3277: 
3278:   assign debug_invalid_owner_seed_wd = reg_wdata[1];
3279: 
3280:   assign debug_invalid_dev_id_wd = reg_wdata[2];
3281: 
3282:   assign debug_invalid_health_state_wd = reg_wdata[3];
3283: 
3284:   assign debug_invalid_key_version_wd = reg_wdata[4];
3285: 
3286:   assign debug_invalid_key_wd = reg_wdata[5];
3287: 
3288:   assign debug_invalid_digest_wd = reg_wdata[6];
3289: 
3290:   // Assign write-enables to checker logic vector.
3291:   always_comb begin
3292:     reg_we_check = '0;
3293:     reg_we_check[0] = intr_state_we;
3294:     reg_we_check[1] = intr_enable_we;
3295:     reg_we_check[2] = intr_test_we;
3296:     reg_we_check[3] = alert_test_we;
3297:     reg_we_check[4] = 1'b0;
3298:     reg_we_check[5] = start_gated_we;
3299:     reg_we_check[6] = control_shadowed_gated_we;
3300:     reg_we_check[7] = sideload_clear_gated_we;
3301:     reg_we_check[8] = reseed_interval_regwen_we;
3302:     reg_we_check[9] = reseed_interval_shadowed_gated_we;
3303:     reg_we_check[10] = sw_binding_regwen_we;
3304:     reg_we_check[11] = sealing_sw_binding_0_gated_we;
3305:     reg_we_check[12] = sealing_sw_binding_1_gated_we;
3306:     reg_we_check[13] = sealing_sw_binding_2_gated_we;
3307:     reg_we_check[14] = sealing_sw_binding_3_gated_we;
3308:     reg_we_check[15] = sealing_sw_binding_4_gated_we;
3309:     reg_we_check[16] = sealing_sw_binding_5_gated_we;
3310:     reg_we_check[17] = sealing_sw_binding_6_gated_we;
3311:     reg_we_check[18] = sealing_sw_binding_7_gated_we;
3312:     reg_we_check[19] = attest_sw_binding_0_gated_we;
3313:     reg_we_check[20] = attest_sw_binding_1_gated_we;
3314:     reg_we_check[21] = attest_sw_binding_2_gated_we;
3315:     reg_we_check[22] = attest_sw_binding_3_gated_we;
3316:     reg_we_check[23] = attest_sw_binding_4_gated_we;
3317:     reg_we_check[24] = attest_sw_binding_5_gated_we;
3318:     reg_we_check[25] = attest_sw_binding_6_gated_we;
3319:     reg_we_check[26] = attest_sw_binding_7_gated_we;
3320:     reg_we_check[27] = salt_0_gated_we;
3321:     reg_we_check[28] = salt_1_gated_we;
3322:     reg_we_check[29] = salt_2_gated_we;
3323:     reg_we_check[30] = salt_3_gated_we;
3324:     reg_we_check[31] = salt_4_gated_we;
3325:     reg_we_check[32] = salt_5_gated_we;
3326:     reg_we_check[33] = salt_6_gated_we;
3327:     reg_we_check[34] = salt_7_gated_we;
3328:     reg_we_check[35] = key_version_gated_we;
3329:     reg_we_check[36] = max_creator_key_ver_regwen_we;
3330:     reg_we_check[37] = max_creator_key_ver_shadowed_gated_we;
3331:     reg_we_check[38] = max_owner_int_key_ver_regwen_we;
3332:     reg_we_check[39] = max_owner_int_key_ver_shadowed_gated_we;
3333:     reg_we_check[40] = max_owner_key_ver_regwen_we;
3334:     reg_we_check[41] = max_owner_key_ver_shadowed_gated_we;
3335:     reg_we_check[42] = 1'b0;
3336:     reg_we_check[43] = 1'b0;
3337:     reg_we_check[44] = 1'b0;
3338:     reg_we_check[45] = 1'b0;
3339:     reg_we_check[46] = 1'b0;
3340:     reg_we_check[47] = 1'b0;
3341:     reg_we_check[48] = 1'b0;
3342:     reg_we_check[49] = 1'b0;
3343:     reg_we_check[50] = 1'b0;
3344:     reg_we_check[51] = 1'b0;
3345:     reg_we_check[52] = 1'b0;
3346:     reg_we_check[53] = 1'b0;
3347:     reg_we_check[54] = 1'b0;
3348:     reg_we_check[55] = 1'b0;
3349:     reg_we_check[56] = 1'b0;
3350:     reg_we_check[57] = 1'b0;
3351:     reg_we_check[58] = 1'b0;
3352:     reg_we_check[59] = op_status_we;
3353:     reg_we_check[60] = err_code_we;
3354:     reg_we_check[61] = 1'b0;
3355:     reg_we_check[62] = debug_we;
3356:   end
3357: 
3358:   // Read data return
3359:   always_comb begin
3360:     reg_rdata_next = '0;
3361:     unique case (1'b1)
3362:       addr_hit[0]: begin
3363:         reg_rdata_next[0] = intr_state_qs;
3364:       end
3365: 
3366:       addr_hit[1]: begin
3367:         reg_rdata_next[0] = intr_enable_qs;
3368:       end
3369: 
3370:       addr_hit[2]: begin
3371:         reg_rdata_next[0] = '0;
3372:       end
3373: 
3374:       addr_hit[3]: begin
3375:         reg_rdata_next[0] = '0;
3376:         reg_rdata_next[1] = '0;
3377:       end
3378: 
3379:       addr_hit[4]: begin
3380:         reg_rdata_next[0] = cfg_regwen_qs;
3381:       end
3382: 
3383:       addr_hit[5]: begin
3384:         reg_rdata_next[0] = start_qs;
3385:       end
3386: 
3387:       addr_hit[6]: begin
3388:         reg_rdata_next[6:4] = control_shadowed_operation_qs;
3389:         reg_rdata_next[7] = control_shadowed_cdi_sel_qs;
3390:         reg_rdata_next[13:12] = control_shadowed_dest_sel_qs;
3391:       end
3392: 
3393:       addr_hit[7]: begin
3394:         reg_rdata_next[2:0] = sideload_clear_qs;
3395:       end
3396: 
3397:       addr_hit[8]: begin
3398:         reg_rdata_next[0] = reseed_interval_regwen_qs;
3399:       end
3400: 
3401:       addr_hit[9]: begin
3402:         reg_rdata_next[15:0] = reseed_interval_shadowed_qs;
3403:       end
3404: 
3405:       addr_hit[10]: begin
3406:         reg_rdata_next[0] = sw_binding_regwen_qs;
3407:       end
3408: 
3409:       addr_hit[11]: begin
3410:         reg_rdata_next[31:0] = sealing_sw_binding_0_qs;
3411:       end
3412: 
3413:       addr_hit[12]: begin
3414:         reg_rdata_next[31:0] = sealing_sw_binding_1_qs;
3415:       end
3416: 
3417:       addr_hit[13]: begin
3418:         reg_rdata_next[31:0] = sealing_sw_binding_2_qs;
3419:       end
3420: 
3421:       addr_hit[14]: begin
3422:         reg_rdata_next[31:0] = sealing_sw_binding_3_qs;
3423:       end
3424: 
3425:       addr_hit[15]: begin
3426:         reg_rdata_next[31:0] = sealing_sw_binding_4_qs;
3427:       end
3428: 
3429:       addr_hit[16]: begin
3430:         reg_rdata_next[31:0] = sealing_sw_binding_5_qs;
3431:       end
3432: 
3433:       addr_hit[17]: begin
3434:         reg_rdata_next[31:0] = sealing_sw_binding_6_qs;
3435:       end
3436: 
3437:       addr_hit[18]: begin
3438:         reg_rdata_next[31:0] = sealing_sw_binding_7_qs;
3439:       end
3440: 
3441:       addr_hit[19]: begin
3442:         reg_rdata_next[31:0] = attest_sw_binding_0_qs;
3443:       end
3444: 
3445:       addr_hit[20]: begin
3446:         reg_rdata_next[31:0] = attest_sw_binding_1_qs;
3447:       end
3448: 
3449:       addr_hit[21]: begin
3450:         reg_rdata_next[31:0] = attest_sw_binding_2_qs;
3451:       end
3452: 
3453:       addr_hit[22]: begin
3454:         reg_rdata_next[31:0] = attest_sw_binding_3_qs;
3455:       end
3456: 
3457:       addr_hit[23]: begin
3458:         reg_rdata_next[31:0] = attest_sw_binding_4_qs;
3459:       end
3460: 
3461:       addr_hit[24]: begin
3462:         reg_rdata_next[31:0] = attest_sw_binding_5_qs;
3463:       end
3464: 
3465:       addr_hit[25]: begin
3466:         reg_rdata_next[31:0] = attest_sw_binding_6_qs;
3467:       end
3468: 
3469:       addr_hit[26]: begin
3470:         reg_rdata_next[31:0] = attest_sw_binding_7_qs;
3471:       end
3472: 
3473:       addr_hit[27]: begin
3474:         reg_rdata_next[31:0] = salt_0_qs;
3475:       end
3476: 
3477:       addr_hit[28]: begin
3478:         reg_rdata_next[31:0] = salt_1_qs;
3479:       end
3480: 
3481:       addr_hit[29]: begin
3482:         reg_rdata_next[31:0] = salt_2_qs;
3483:       end
3484: 
3485:       addr_hit[30]: begin
3486:         reg_rdata_next[31:0] = salt_3_qs;
3487:       end
3488: 
3489:       addr_hit[31]: begin
3490:         reg_rdata_next[31:0] = salt_4_qs;
3491:       end
3492: 
3493:       addr_hit[32]: begin
3494:         reg_rdata_next[31:0] = salt_5_qs;
3495:       end
3496: 
3497:       addr_hit[33]: begin
3498:         reg_rdata_next[31:0] = salt_6_qs;
3499:       end
3500: 
3501:       addr_hit[34]: begin
3502:         reg_rdata_next[31:0] = salt_7_qs;
3503:       end
3504: 
3505:       addr_hit[35]: begin
3506:         reg_rdata_next[31:0] = key_version_qs;
3507:       end
3508: 
3509:       addr_hit[36]: begin
3510:         reg_rdata_next[0] = max_creator_key_ver_regwen_qs;
3511:       end
3512: 
3513:       addr_hit[37]: begin
3514:         reg_rdata_next[31:0] = max_creator_key_ver_shadowed_qs;
3515:       end
3516: 
3517:       addr_hit[38]: begin
3518:         reg_rdata_next[0] = max_owner_int_key_ver_regwen_qs;
3519:       end
3520: 
3521:       addr_hit[39]: begin
3522:         reg_rdata_next[31:0] = max_owner_int_key_ver_shadowed_qs;
3523:       end
3524: 
3525:       addr_hit[40]: begin
3526:         reg_rdata_next[0] = max_owner_key_ver_regwen_qs;
3527:       end
3528: 
3529:       addr_hit[41]: begin
3530:         reg_rdata_next[31:0] = max_owner_key_ver_shadowed_qs;
3531:       end
3532: 
3533:       addr_hit[42]: begin
3534:         reg_rdata_next[31:0] = sw_share0_output_0_qs;
3535:       end
3536: 
3537:       addr_hit[43]: begin
3538:         reg_rdata_next[31:0] = sw_share0_output_1_qs;
3539:       end
3540: 
3541:       addr_hit[44]: begin
3542:         reg_rdata_next[31:0] = sw_share0_output_2_qs;
3543:       end
3544: 
3545:       addr_hit[45]: begin
3546:         reg_rdata_next[31:0] = sw_share0_output_3_qs;
3547:       end
3548: 
3549:       addr_hit[46]: begin
3550:         reg_rdata_next[31:0] = sw_share0_output_4_qs;
3551:       end
3552: 
3553:       addr_hit[47]: begin
3554:         reg_rdata_next[31:0] = sw_share0_output_5_qs;
3555:       end
3556: 
3557:       addr_hit[48]: begin
3558:         reg_rdata_next[31:0] = sw_share0_output_6_qs;
3559:       end
3560: 
3561:       addr_hit[49]: begin
3562:         reg_rdata_next[31:0] = sw_share0_output_7_qs;
3563:       end
3564: 
3565:       addr_hit[50]: begin
3566:         reg_rdata_next[31:0] = sw_share1_output_0_qs;
3567:       end
3568: 
3569:       addr_hit[51]: begin
3570:         reg_rdata_next[31:0] = sw_share1_output_1_qs;
3571:       end
3572: 
3573:       addr_hit[52]: begin
3574:         reg_rdata_next[31:0] = sw_share1_output_2_qs;
3575:       end
3576: 
3577:       addr_hit[53]: begin
3578:         reg_rdata_next[31:0] = sw_share1_output_3_qs;
3579:       end
3580: 
3581:       addr_hit[54]: begin
3582:         reg_rdata_next[31:0] = sw_share1_output_4_qs;
3583:       end
3584: 
3585:       addr_hit[55]: begin
3586:         reg_rdata_next[31:0] = sw_share1_output_5_qs;
3587:       end
3588: 
3589:       addr_hit[56]: begin
3590:         reg_rdata_next[31:0] = sw_share1_output_6_qs;
3591:       end
3592: 
3593:       addr_hit[57]: begin
3594:         reg_rdata_next[31:0] = sw_share1_output_7_qs;
3595:       end
3596: 
3597:       addr_hit[58]: begin
3598:         reg_rdata_next[2:0] = working_state_qs;
3599:       end
3600: 
3601:       addr_hit[59]: begin
3602:         reg_rdata_next[1:0] = op_status_qs;
3603:       end
3604: 
3605:       addr_hit[60]: begin
3606:         reg_rdata_next[0] = err_code_invalid_op_qs;
3607:         reg_rdata_next[1] = err_code_invalid_kmac_input_qs;
3608:         reg_rdata_next[2] = err_code_invalid_shadow_update_qs;
3609:       end
3610: 
3611:       addr_hit[61]: begin
3612:         reg_rdata_next[0] = fault_status_cmd_qs;
3613:         reg_rdata_next[1] = fault_status_kmac_fsm_qs;
3614:         reg_rdata_next[2] = fault_status_kmac_done_qs;
3615:         reg_rdata_next[3] = fault_status_kmac_op_qs;
3616:         reg_rdata_next[4] = fault_status_kmac_out_qs;
3617:         reg_rdata_next[5] = fault_status_regfile_intg_qs;
3618:         reg_rdata_next[6] = fault_status_shadow_qs;
3619:         reg_rdata_next[7] = fault_status_ctrl_fsm_intg_qs;
3620:         reg_rdata_next[8] = fault_status_ctrl_fsm_chk_qs;
3621:         reg_rdata_next[9] = fault_status_ctrl_fsm_cnt_qs;
3622:         reg_rdata_next[10] = fault_status_reseed_cnt_qs;
3623:         reg_rdata_next[11] = fault_status_side_ctrl_fsm_qs;
3624:         reg_rdata_next[12] = fault_status_side_ctrl_sel_qs;
3625:         reg_rdata_next[13] = fault_status_key_ecc_qs;
3626:       end
3627: 
3628:       addr_hit[62]: begin
3629:         reg_rdata_next[0] = debug_invalid_creator_seed_qs;
3630:         reg_rdata_next[1] = debug_invalid_owner_seed_qs;
3631:         reg_rdata_next[2] = debug_invalid_dev_id_qs;
3632:         reg_rdata_next[3] = debug_invalid_health_state_qs;
3633:         reg_rdata_next[4] = debug_invalid_key_version_qs;
3634:         reg_rdata_next[5] = debug_invalid_key_qs;
3635:         reg_rdata_next[6] = debug_invalid_digest_qs;
3636:       end
3637: 
3638:       default: begin
3639:         reg_rdata_next = '1;
3640:       end
3641:     endcase
3642:   end
3643: 
3644:   // shadow busy
3645:   logic shadow_busy;
3646:   logic rst_done;
3647:   logic shadow_rst_done;
3648:   always_ff @(posedge clk_i or negedge rst_ni) begin
3649:     if (!rst_ni) begin
3650:       rst_done <= '0;
3651:     end else begin
3652:       rst_done <= 1'b1;
3653:     end
3654:   end
3655: 
3656:   always_ff @(posedge clk_i or negedge rst_shadowed_ni) begin
3657:     if (!rst_shadowed_ni) begin
3658:       shadow_rst_done <= '0;
3659:     end else begin
3660:       shadow_rst_done <= 1'b1;
3661:     end
3662:   end
3663: 
3664:   // both shadow and normal resets have been released
3665:   assign shadow_busy = ~(rst_done & shadow_rst_done);
3666: 
3667:   // Collect up storage and update errors
3668:   assign shadowed_storage_err_o = |{
3669:     control_shadowed_operation_storage_err,
3670:     control_shadowed_cdi_sel_storage_err,
3671:     control_shadowed_dest_sel_storage_err,
3672:     reseed_interval_shadowed_storage_err,
3673:     max_creator_key_ver_shadowed_storage_err,
3674:     max_owner_int_key_ver_shadowed_storage_err,
3675:     max_owner_key_ver_shadowed_storage_err
3676:   };
3677:   assign shadowed_update_err_o = |{
3678:     control_shadowed_operation_update_err,
3679:     control_shadowed_cdi_sel_update_err,
3680:     control_shadowed_dest_sel_update_err,
3681:     reseed_interval_shadowed_update_err,
3682:     max_creator_key_ver_shadowed_update_err,
3683:     max_owner_int_key_ver_shadowed_update_err,
3684:     max_owner_key_ver_shadowed_update_err
3685:   };
3686: 
3687:   // register busy
3688:   assign reg_busy = shadow_busy;
3689: 
3690:   // Unused signal tieoff
3691: 
3692:   // wdata / byte enable are not always fully used
3693:   // add a blanket unused statement to handle lint waivers
3694:   logic unused_wdata;
3695:   logic unused_be;
3696:   assign unused_wdata = ^reg_wdata;
3697:   assign unused_be = ^reg_be;
3698: 
3699:   // Assertions for Register Interface
3700:   `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
3701:   `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)
3702: 
3703:   `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)
3704: 
3705:   `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)
3706: 
3707:   // this is formulated as an assumption such that the FPV testbenches do disprove this
3708:   // property by mistake
3709:   //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)
3710: 
3711: endmodule

================================== Ai Message ==================================

[{'text': "Now, I'll search for similar patterns using the similar_bug_tool:", 'type': 'text'}, {'id': 'toolu_014im2aTTN8PYeSzAGsViYUp', 'input': {'bug': 'assign start_gated_we = start_we & cfg_regwen_qs;', 'ip_file': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv'}, 'name': 'similar_bug_tool', 'type': 'tool_use'}]
Tool Calls:
  similar_bug_tool (toolu_014im2aTTN8PYeSzAGsViYUp)
 Call ID: toolu_014im2aTTN8PYeSzAGsViYUp
  Args:
    bug: assign start_gated_we = start_we & cfg_regwen_qs;
    ip_file: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv
================================= Tool Message =================================
Name: similar_bug_tool

Error: ValueError("'assign start_gated_we = start_we & cfg_regwen_qs;\\n  prim_subreg #(' is not in list")
 Please fix your mistakes.
================================= Tool Message =================================
Name: similar_bug_tool

Error: ValueError("'assign start_gated_we = start_we & cfg_regwen_qs;\\n  prim_subreg #(' is not in list")
 Please fix your mistakes.
================================== Ai Message ==================================

I apologize for the error. Let me manually search for similar patterns in the file. 

I found several similar patterns in the file:

1. Line 498-499:
```systemverilog
logic start_gated_we;
assign start_gated_we = start_we & cfg_regwen_qs;
```

2. Line 529-530:
```systemverilog
logic control_shadowed_gated_we;
assign control_shadowed_gated_we = control_shadowed_we & cfg_regwen_qs;
```

3. Line 642-643:
```systemverilog
logic sideload_clear_gated_we;
assign sideload_clear_gated_we = sideload_clear_we & cfg_regwen_qs;
```

4. Line 700-702:
```systemverilog
logic reseed_interval_shadowed_gated_we;
assign reseed_interval_shadowed_gated_we =
    reseed_interval_shadowed_we & reseed_interval_regwen_qs;
```

5. Lines 763-764:
```systemverilog
logic sealing_sw_binding_0_gated_we;
assign sealing_sw_binding_0_gated_we = sealing_sw_binding_0_we & sw_binding_regwen_qs;
```

These lines follow a similar pattern of creating a gated write enable signal by ANDing the original write enable with a register enable signal. This appears to be an intentional design pattern in this file to control write access to various registers based on a configuration or binding register enable.

The lines I've listed are not bugs, but rather a consistent implementation of write enable gating across different registers in the key manager's register top module.
================================= Tool Message =================================
Name: run_similar_bug_agent

I apologize for the error. Let me manually search for similar patterns in the file. 

I found several similar patterns in the file:

1. Line 498-499:
```systemverilog
logic start_gated_we;
assign start_gated_we = start_we & cfg_regwen_qs;
```

2. Line 529-530:
```systemverilog
logic control_shadowed_gated_we;
assign control_shadowed_gated_we = control_shadowed_we & cfg_regwen_qs;
```

3. Line 642-643:
```systemverilog
logic sideload_clear_gated_we;
assign sideload_clear_gated_we = sideload_clear_we & cfg_regwen_qs;
```

4. Line 700-702:
```systemverilog
logic reseed_interval_shadowed_gated_we;
assign reseed_interval_shadowed_gated_we =
    reseed_interval_shadowed_we & reseed_interval_regwen_qs;
```

5. Lines 763-764:
```systemverilog
logic sealing_sw_binding_0_gated_we;
assign sealing_sw_binding_0_gated_we = sealing_sw_binding_0_we & sw_binding_regwen_qs;
```

These lines follow a similar pattern of creating a gated write enable signal by ANDing the original write enable with a register enable signal. This appears to be an intentional design pattern in this file to control write access to various registers based on a configuration or binding register enable.

The lines I've listed are not bugs, but rather a consistent implementation of write enable gating across different registers in the key manager's register top module.
================================== Ai Message ==================================
Tool Calls:
  run_similar_bug_agent (call_qr8ULsB3k9p3IsYUyG7OhKd2)
 Call ID: call_qr8ULsB3k9p3IsYUyG7OhKd2
  Args:
    bug: assign shadowed_storage_err_o = |{
    file_path: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv
================================ Human Message =================================

This bug was previously found in another file of this design:
    assign shadowed_storage_err_o = |{
    
    Please check the RTL code in the file /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv for similar bugs.
================================ Human Message =================================

This bug was previously found in another file of this design:
    assign shadowed_storage_err_o = |{
    
    Please check the RTL code in the file /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv for similar bugs.
================================== Ai Message ==================================

[{'text': "I'll help you find similar bugs in the specified file. I'll use the similar_bug_tool to search for lines similar to the given bug pattern.", 'type': 'text'}, {'id': 'toolu_01DmHXvsUi9yLVEfRUtUnN6V', 'input': {'bug': 'assign shadowed_storage_err_o = |{', 'ip_file': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv'}, 'name': 'similar_bug_tool', 'type': 'tool_use'}]
Tool Calls:
  similar_bug_tool (toolu_01DmHXvsUi9yLVEfRUtUnN6V)
 Call ID: toolu_01DmHXvsUi9yLVEfRUtUnN6V
  Args:
    bug: assign shadowed_storage_err_o = |{
    ip_file: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv
================================= Tool Message =================================
Name: similar_bug_tool

Error: ValueError("'assign shadowed_update_err_o = |{\\n    control_shadowed_operation_update_err,' is not in list")
 Please fix your mistakes.
================================= Tool Message =================================
Name: similar_bug_tool

Error: ValueError("'assign shadowed_update_err_o = |{\\n    control_shadowed_operation_update_err,' is not in list")
 Please fix your mistakes.
================================== Ai Message ==================================

[{'text': 'I apologize for the error. It seems the tool might require a more specific match. Let me read the file contents first to understand the context better.', 'type': 'text'}, {'id': 'toolu_014wfv5mSijc5FizM9VtxDLL', 'input': {'file_path': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv'}, 'name': 'read_file_with_line_numbers', 'type': 'tool_use'}]
Tool Calls:
  read_file_with_line_numbers (toolu_014wfv5mSijc5FizM9VtxDLL)
 Call ID: toolu_014wfv5mSijc5FizM9VtxDLL
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Register Top module auto-generated by `reggen`
6: 
7: `include "prim_assert.sv"
8: 
9: module keymgr_reg_top (
10:   input clk_i,
11:   input rst_ni,
12:   input rst_shadowed_ni,
13:   input  tlul_pkg::tl_h2d_t tl_i,
14:   output tlul_pkg::tl_d2h_t tl_o,
15:   // To HW
16:   output keymgr_reg_pkg::keymgr_reg2hw_t reg2hw, // Write
17:   input  keymgr_reg_pkg::keymgr_hw2reg_t hw2reg, // Read
18: 
19:   output logic shadowed_storage_err_o,
20:   output logic shadowed_update_err_o,
21: 
22:   // Integrity check errors
23:   output logic intg_err_o
24: );
25: 
26:   import keymgr_reg_pkg::* ;
27: 
28:   localparam int AW = 8;
29:   localparam int DW = 32;
30:   localparam int DBW = DW/8;                    // Byte Width
31: 
32:   // register signals
33:   logic           reg_we;
34:   logic           reg_re;
35:   logic [AW-1:0]  reg_addr;
36:   logic [DW-1:0]  reg_wdata;
37:   logic [DBW-1:0] reg_be;
38:   logic [DW-1:0]  reg_rdata;
39:   logic           reg_error;
40: 
41:   logic          addrmiss, wr_err;
42: 
43:   logic [DW-1:0] reg_rdata_next;
44:   logic reg_busy;
45: 
46:   tlul_pkg::tl_h2d_t tl_reg_h2d;
47:   tlul_pkg::tl_d2h_t tl_reg_d2h;
48: 
49: 
50:   // incoming payload check
51:   logic intg_err;
52:   tlul_cmd_intg_chk u_chk (
53:     .tl_i(tl_i),
54:     .err_o(intg_err)
55:   );
56: 
57:   // also check for spurious write enables
58:   logic reg_we_err;
59:   logic [62:0] reg_we_check;
60:   prim_reg_we_check #(
61:     .OneHotWidth(63)
62:   ) u_prim_reg_we_check (
63:     .clk_i(clk_i),
64:     .rst_ni(rst_ni),
65:     .oh_i  (reg_we_check),
66:     .en_i  (reg_we && !addrmiss),
67:     .err_o (reg_we_err)
68:   );
69: 
70:   logic err_q;
71:   always_ff @(posedge clk_i or negedge rst_ni) begin
72:     if (!rst_ni) begin
73:       err_q <= '0;
74:     end else if (intg_err || reg_we_err) begin
75:       err_q <= 1'b1;
76:     end
77:   end
78: 
79:   // integrity error output is permanent and should be used for alert generation
80:   // register errors are transactional
81:   assign intg_err_o = err_q | intg_err | reg_we_err;
82: 
83:   // outgoing integrity generation
84:   tlul_pkg::tl_d2h_t tl_o_pre;
85:   tlul_rsp_intg_gen #(
86:     .EnableRspIntgGen(1),
87:     .EnableDataIntgGen(1)
88:   ) u_rsp_intg_gen (
89:     .tl_i(tl_o_pre),
90:     .tl_o(tl_o)
91:   );
92: 
93:   assign tl_reg_h2d = tl_i;
94:   assign tl_o_pre   = tl_reg_d2h;
95: 
96:   tlul_adapter_reg #(
97:     .RegAw(AW),
98:     .RegDw(DW),
99:     .EnableDataIntgGen(0)
100:   ) u_reg_if (
101:     .clk_i  (clk_i),
102:     .rst_ni (rst_ni),
103: 
104:     .tl_i (tl_reg_h2d),
105:     .tl_o (tl_reg_d2h),
106: 
107:     .en_ifetch_i(prim_mubi_pkg::MuBi4False),
108:     .intg_error_o(),
109: 
110:     .we_o    (reg_we),
111:     .re_o    (reg_re),
112:     .addr_o  (reg_addr),
113:     .wdata_o (reg_wdata),
114:     .be_o    (reg_be),
115:     .busy_i  (reg_busy),
116:     .rdata_i (reg_rdata),
117:     .error_i (reg_error)
118:   );
119: 
120:   // cdc oversampling signals
121: 
122:   assign reg_rdata = reg_rdata_next ;
123:   assign reg_error = addrmiss | wr_err | intg_err;
124: 
125:   // Define SW related signals
126:   // Format: <reg>_<field>_{wd|we|qs}
127:   //        or <reg>_{wd|we|qs} if field == 1 or 0
128:   logic intr_state_we;
129:   logic intr_state_qs;
130:   logic intr_state_wd;
131:   logic intr_enable_we;
132:   logic intr_enable_qs;
133:   logic intr_enable_wd;
134:   logic intr_test_we;
135:   logic intr_test_wd;
136:   logic alert_test_we;
137:   logic alert_test_recov_operation_err_wd;
138:   logic alert_test_fatal_fault_err_wd;
139:   logic cfg_regwen_re;
140:   logic cfg_regwen_qs;
141:   logic start_we;
142:   logic start_qs;
143:   logic start_wd;
144:   logic control_shadowed_re;
145:   logic control_shadowed_we;
146:   logic [2:0] control_shadowed_operation_qs;
147:   logic [2:0] control_shadowed_operation_wd;
148:   logic control_shadowed_operation_storage_err;
149:   logic control_shadowed_operation_update_err;
150:   logic control_shadowed_cdi_sel_qs;
151:   logic control_shadowed_cdi_sel_wd;
152:   logic control_shadowed_cdi_sel_storage_err;
153:   logic control_shadowed_cdi_sel_update_err;
154:   logic [1:0] control_shadowed_dest_sel_qs;
155:   logic [1:0] control_shadowed_dest_sel_wd;
156:   logic control_shadowed_dest_sel_storage_err;
157:   logic control_shadowed_dest_sel_update_err;
158:   logic sideload_clear_we;
159:   logic [2:0] sideload_clear_qs;
160:   logic [2:0] sideload_clear_wd;
161:   logic reseed_interval_regwen_we;
162:   logic reseed_interval_regwen_qs;
163:   logic reseed_interval_regwen_wd;
164:   logic reseed_interval_shadowed_re;
165:   logic reseed_interval_shadowed_we;
166:   logic [15:0] reseed_interval_shadowed_qs;
167:   logic [15:0] reseed_interval_shadowed_wd;
168:   logic reseed_interval_shadowed_storage_err;
169:   logic reseed_interval_shadowed_update_err;
170:   logic sw_binding_regwen_re;
171:   logic sw_binding_regwen_we;
172:   logic sw_binding_regwen_qs;
173:   logic sw_binding_regwen_wd;
174:   logic sealing_sw_binding_0_we;
175:   logic [31:0] sealing_sw_binding_0_qs;
176:   logic [31:0] sealing_sw_binding_0_wd;
177:   logic sealing_sw_binding_1_we;
178:   logic [31:0] sealing_sw_binding_1_qs;
179:   logic [31:0] sealing_sw_binding_1_wd;
180:   logic sealing_sw_binding_2_we;
181:   logic [31:0] sealing_sw_binding_2_qs;
182:   logic [31:0] sealing_sw_binding_2_wd;
183:   logic sealing_sw_binding_3_we;
184:   logic [31:0] sealing_sw_binding_3_qs;
185:   logic [31:0] sealing_sw_binding_3_wd;
186:   logic sealing_sw_binding_4_we;
187:   logic [31:0] sealing_sw_binding_4_qs;
188:   logic [31:0] sealing_sw_binding_4_wd;
189:   logic sealing_sw_binding_5_we;
190:   logic [31:0] sealing_sw_binding_5_qs;
191:   logic [31:0] sealing_sw_binding_5_wd;
192:   logic sealing_sw_binding_6_we;
193:   logic [31:0] sealing_sw_binding_6_qs;
194:   logic [31:0] sealing_sw_binding_6_wd;
195:   logic sealing_sw_binding_7_we;
196:   logic [31:0] sealing_sw_binding_7_qs;
197:   logic [31:0] sealing_sw_binding_7_wd;
198:   logic attest_sw_binding_0_we;
199:   logic [31:0] attest_sw_binding_0_qs;
200:   logic [31:0] attest_sw_binding_0_wd;
201:   logic attest_sw_binding_1_we;
202:   logic [31:0] attest_sw_binding_1_qs;
203:   logic [31:0] attest_sw_binding_1_wd;
204:   logic attest_sw_binding_2_we;
205:   logic [31:0] attest_sw_binding_2_qs;
206:   logic [31:0] attest_sw_binding_2_wd;
207:   logic attest_sw_binding_3_we;
208:   logic [31:0] attest_sw_binding_3_qs;
209:   logic [31:0] attest_sw_binding_3_wd;
210:   logic attest_sw_binding_4_we;
211:   logic [31:0] attest_sw_binding_4_qs;
212:   logic [31:0] attest_sw_binding_4_wd;
213:   logic attest_sw_binding_5_we;
214:   logic [31:0] attest_sw_binding_5_qs;
215:   logic [31:0] attest_sw_binding_5_wd;
216:   logic attest_sw_binding_6_we;
217:   logic [31:0] attest_sw_binding_6_qs;
218:   logic [31:0] attest_sw_binding_6_wd;
219:   logic attest_sw_binding_7_we;
220:   logic [31:0] attest_sw_binding_7_qs;
221:   logic [31:0] attest_sw_binding_7_wd;
222:   logic salt_0_we;
223:   logic [31:0] salt_0_qs;
224:   logic [31:0] salt_0_wd;
225:   logic salt_1_we;
226:   logic [31:0] salt_1_qs;
227:   logic [31:0] salt_1_wd;
228:   logic salt_2_we;
229:   logic [31:0] salt_2_qs;
230:   logic [31:0] salt_2_wd;
231:   logic salt_3_we;
232:   logic [31:0] salt_3_qs;
233:   logic [31:0] salt_3_wd;
234:   logic salt_4_we;
235:   logic [31:0] salt_4_qs;
236:   logic [31:0] salt_4_wd;
237:   logic salt_5_we;
238:   logic [31:0] salt_5_qs;
239:   logic [31:0] salt_5_wd;
240:   logic salt_6_we;
241:   logic [31:0] salt_6_qs;
242:   logic [31:0] salt_6_wd;
243:   logic salt_7_we;
244:   logic [31:0] salt_7_qs;
245:   logic [31:0] salt_7_wd;
246:   logic key_version_we;
247:   logic [31:0] key_version_qs;
248:   logic [31:0] key_version_wd;
249:   logic max_creator_key_ver_regwen_we;
250:   logic max_creator_key_ver_regwen_qs;
251:   logic max_creator_key_ver_regwen_wd;
252:   logic max_creator_key_ver_shadowed_re;
253:   logic max_creator_key_ver_shadowed_we;
254:   logic [31:0] max_creator_key_ver_shadowed_qs;
255:   logic [31:0] max_creator_key_ver_shadowed_wd;
256:   logic max_creator_key_ver_shadowed_storage_err;
257:   logic max_creator_key_ver_shadowed_update_err;
258:   logic max_owner_int_key_ver_regwen_we;
259:   logic max_owner_int_key_ver_regwen_qs;
260:   logic max_owner_int_key_ver_regwen_wd;
261:   logic max_owner_int_key_ver_shadowed_re;
262:   logic max_owner_int_key_ver_shadowed_we;
263:   logic [31:0] max_owner_int_key_ver_shadowed_qs;
264:   logic [31:0] max_owner_int_key_ver_shadowed_wd;
265:   logic max_owner_int_key_ver_shadowed_storage_err;
266:   logic max_owner_int_key_ver_shadowed_update_err;
267:   logic max_owner_key_ver_regwen_we;
268:   logic max_owner_key_ver_regwen_qs;
269:   logic max_owner_key_ver_regwen_wd;
270:   logic max_owner_key_ver_shadowed_re;
271:   logic max_owner_key_ver_shadowed_we;
272:   logic [31:0] max_owner_key_ver_shadowed_qs;
273:   logic [31:0] max_owner_key_ver_shadowed_wd;
274:   logic max_owner_key_ver_shadowed_storage_err;
275:   logic max_owner_key_ver_shadowed_update_err;
276:   logic sw_share0_output_0_re;
277:   logic [31:0] sw_share0_output_0_qs;
278:   logic [31:0] sw_share0_output_0_wd;
279:   logic sw_share0_output_1_re;
280:   logic [31:0] sw_share0_output_1_qs;
281:   logic [31:0] sw_share0_output_1_wd;
282:   logic sw_share0_output_2_re;
283:   logic [31:0] sw_share0_output_2_qs;
284:   logic [31:0] sw_share0_output_2_wd;
285:   logic sw_share0_output_3_re;
286:   logic [31:0] sw_share0_output_3_qs;
287:   logic [31:0] sw_share0_output_3_wd;
288:   logic sw_share0_output_4_re;
289:   logic [31:0] sw_share0_output_4_qs;
290:   logic [31:0] sw_share0_output_4_wd;
291:   logic sw_share0_output_5_re;
292:   logic [31:0] sw_share0_output_5_qs;
293:   logic [31:0] sw_share0_output_5_wd;
294:   logic sw_share0_output_6_re;
295:   logic [31:0] sw_share0_output_6_qs;
296:   logic [31:0] sw_share0_output_6_wd;
297:   logic sw_share0_output_7_re;
298:   logic [31:0] sw_share0_output_7_qs;
299:   logic [31:0] sw_share0_output_7_wd;
300:   logic sw_share1_output_0_re;
301:   logic [31:0] sw_share1_output_0_qs;
302:   logic [31:0] sw_share1_output_0_wd;
303:   logic sw_share1_output_1_re;
304:   logic [31:0] sw_share1_output_1_qs;
305:   logic [31:0] sw_share1_output_1_wd;
306:   logic sw_share1_output_2_re;
307:   logic [31:0] sw_share1_output_2_qs;
308:   logic [31:0] sw_share1_output_2_wd;
309:   logic sw_share1_output_3_re;
310:   logic [31:0] sw_share1_output_3_qs;
311:   logic [31:0] sw_share1_output_3_wd;
312:   logic sw_share1_output_4_re;
313:   logic [31:0] sw_share1_output_4_qs;
314:   logic [31:0] sw_share1_output_4_wd;
315:   logic sw_share1_output_5_re;
316:   logic [31:0] sw_share1_output_5_qs;
317:   logic [31:0] sw_share1_output_5_wd;
318:   logic sw_share1_output_6_re;
319:   logic [31:0] sw_share1_output_6_qs;
320:   logic [31:0] sw_share1_output_6_wd;
321:   logic sw_share1_output_7_re;
322:   logic [31:0] sw_share1_output_7_qs;
323:   logic [31:0] sw_share1_output_7_wd;
324:   logic [2:0] working_state_qs;
325:   logic op_status_we;
326:   logic [1:0] op_status_qs;
327:   logic [1:0] op_status_wd;
328:   logic err_code_we;
329:   logic err_code_invalid_op_qs;
330:   logic err_code_invalid_op_wd;
331:   logic err_code_invalid_kmac_input_qs;
332:   logic err_code_invalid_kmac_input_wd;
333:   logic err_code_invalid_shadow_update_qs;
334:   logic err_code_invalid_shadow_update_wd;
335:   logic fault_status_cmd_qs;
336:   logic fault_status_kmac_fsm_qs;
337:   logic fault_status_kmac_done_qs;
338:   logic fault_status_kmac_op_qs;
339:   logic fault_status_kmac_out_qs;
340:   logic fault_status_regfile_intg_qs;
341:   logic fault_status_shadow_qs;
342:   logic fault_status_ctrl_fsm_intg_qs;
343:   logic fault_status_ctrl_fsm_chk_qs;
344:   logic fault_status_ctrl_fsm_cnt_qs;
345:   logic fault_status_reseed_cnt_qs;
346:   logic fault_status_side_ctrl_fsm_qs;
347:   logic fault_status_side_ctrl_sel_qs;
348:   logic fault_status_key_ecc_qs;
349:   logic debug_we;
350:   logic debug_invalid_creator_seed_qs;
351:   logic debug_invalid_creator_seed_wd;
352:   logic debug_invalid_owner_seed_qs;
353:   logic debug_invalid_owner_seed_wd;
354:   logic debug_invalid_dev_id_qs;
355:   logic debug_invalid_dev_id_wd;
356:   logic debug_invalid_health_state_qs;
357:   logic debug_invalid_health_state_wd;
358:   logic debug_invalid_key_version_qs;
359:   logic debug_invalid_key_version_wd;
360:   logic debug_invalid_key_qs;
361:   logic debug_invalid_key_wd;
362:   logic debug_invalid_digest_qs;
363:   logic debug_invalid_digest_wd;
364: 
365:   // Register instances
366:   // R[intr_state]: V(False)
367:   prim_subreg #(
368:     .DW      (1),
369:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
370:     .RESVAL  (1'h0),
371:     .Mubi    (1'b0)
372:   ) u_intr_state (
373:     .clk_i   (clk_i),
374:     .rst_ni  (rst_ni),
375: 
376:     // from register interface
377:     .we     (intr_state_we),
378:     .wd     (intr_state_wd),
379: 
380:     // from internal hardware
381:     .de     (hw2reg.intr_state.de),
382:     .d      (hw2reg.intr_state.d),
383: 
384:     // to internal hardware
385:     .qe     (),
386:     .q      (reg2hw.intr_state.q),
387:     .ds     (),
388: 
389:     // to register interface (read)
390:     .qs     (intr_state_qs)
391:   );
392: 
393: 
394:   // R[intr_enable]: V(False)
395:   prim_subreg #(
396:     .DW      (1),
397:     .SwAccess(prim_subreg_pkg::SwAccessRW),
398:     .RESVAL  (1'h0),
399:     .Mubi    (1'b0)
400:   ) u_intr_enable (
401:     .clk_i   (clk_i),
402:     .rst_ni  (rst_ni),
403: 
404:     // from register interface
405:     .we     (intr_enable_we),
406:     .wd     (intr_enable_wd),
407: 
408:     // from internal hardware
409:     .de     (1'b0),
410:     .d      ('0),
411: 
412:     // to internal hardware
413:     .qe     (),
414:     .q      (reg2hw.intr_enable.q),
415:     .ds     (),
416: 
417:     // to register interface (read)
418:     .qs     (intr_enable_qs)
419:   );
420: 
421: 
422:   // R[intr_test]: V(True)
423:   logic intr_test_qe;
424:   logic [0:0] intr_test_flds_we;
425:   assign intr_test_qe = &intr_test_flds_we;
426:   prim_subreg_ext #(
427:     .DW    (1)
428:   ) u_intr_test (
429:     .re     (1'b0),
430:     .we     (intr_test_we),
431:     .wd     (intr_test_wd),
432:     .d      ('0),
433:     .qre    (),
434:     .qe     (intr_test_flds_we[0]),
435:     .q      (reg2hw.intr_test.q),
436:     .ds     (),
437:     .qs     ()
438:   );
439:   assign reg2hw.intr_test.qe = intr_test_qe;
440: 
441: 
442:   // R[alert_test]: V(True)
443:   logic alert_test_qe;
444:   logic [1:0] alert_test_flds_we;
445:   assign alert_test_qe = &alert_test_flds_we;
446:   //   F[recov_operation_err]: 0:0
447:   prim_subreg_ext #(
448:     .DW    (1)
449:   ) u_alert_test_recov_operation_err (
450:     .re     (1'b0),
451:     .we     (alert_test_we),
452:     .wd     (alert_test_recov_operation_err_wd),
453:     .d      ('0),
454:     .qre    (),
455:     .qe     (alert_test_flds_we[0]),
456:     .q      (reg2hw.alert_test.recov_operation_err.q),
457:     .ds     (),
458:     .qs     ()
459:   );
460:   assign reg2hw.alert_test.recov_operation_err.qe = alert_test_qe;
461: 
462:   //   F[fatal_fault_err]: 1:1
463:   prim_subreg_ext #(
464:     .DW    (1)
465:   ) u_alert_test_fatal_fault_err (
466:     .re     (1'b0),
467:     .we     (alert_test_we),
468:     .wd     (alert_test_fatal_fault_err_wd),
469:     .d      ('0),
470:     .qre    (),
471:     .qe     (alert_test_flds_we[1]),
472:     .q      (reg2hw.alert_test.fatal_fault_err.q),
473:     .ds     (),
474:     .qs     ()
475:   );
476:   assign reg2hw.alert_test.fatal_fault_err.qe = alert_test_qe;
477: 
478: 
479:   // R[cfg_regwen]: V(True)
480:   prim_subreg_ext #(
481:     .DW    (1)
482:   ) u_cfg_regwen (
483:     .re     (cfg_regwen_re),
484:     .we     (1'b0),
485:     .wd     ('0),
486:     .d      (hw2reg.cfg_regwen.d),
487:     .qre    (),
488:     .qe     (),
489:     .q      (),
490:     .ds     (),
491:     .qs     (cfg_regwen_qs)
492:   );
493: 
494: 
495:   // R[start]: V(False)
496:   // Create REGWEN-gated WE signal
497:   logic start_gated_we;
498:   assign start_gated_we = start_we & cfg_regwen_qs;
499:   prim_subreg #(
500:     .DW      (1),
501:     .SwAccess(prim_subreg_pkg::SwAccessRW),
502:     .RESVAL  (1'h0),
503:     .Mubi    (1'b0)
504:   ) u_start (
505:     .clk_i   (clk_i),
506:     .rst_ni  (rst_ni),
507: 
508:     // from register interface
509:     .we     (start_gated_we),
510:     .wd     (start_wd),
511: 
512:     // from internal hardware
513:     .de     (hw2reg.start.de),
514:     .d      (hw2reg.start.d),
515: 
516:     // to internal hardware
517:     .qe     (),
518:     .q      (reg2hw.start.q),
519:     .ds     (),
520: 
521:     // to register interface (read)
522:     .qs     (start_qs)
523:   );
524: 
525: 
526:   // R[control_shadowed]: V(False)
527:   // Create REGWEN-gated WE signal
528:   logic control_shadowed_gated_we;
529:   assign control_shadowed_gated_we = control_shadowed_we & cfg_regwen_qs;
530:   //   F[operation]: 6:4
531:   prim_subreg_shadow #(
532:     .DW      (3),
533:     .SwAccess(prim_subreg_pkg::SwAccessRW),
534:     .RESVAL  (3'h1),
535:     .Mubi    (1'b0)
536:   ) u_control_shadowed_operation (
537:     .clk_i   (clk_i),
538:     .rst_ni  (rst_ni),
539:     .rst_shadowed_ni (rst_shadowed_ni),
540: 
541:     // from register interface
542:     .re     (control_shadowed_re),
543:     .we     (control_shadowed_gated_we),
544:     .wd     (control_shadowed_operation_wd),
545: 
546:     // from internal hardware
547:     .de     (1'b0),
548:     .d      ('0),
549: 
550:     // to internal hardware
551:     .qe     (),
552:     .q      (reg2hw.control_shadowed.operation.q),
553:     .ds     (),
554: 
555:     // to register interface (read)
556:     .qs     (control_shadowed_operation_qs),
557: 
558:     // Shadow register phase. Relevant for hwext only.
559:     .phase  (),
560: 
561:     // Shadow register error conditions
562:     .err_update  (control_shadowed_operation_update_err),
563:     .err_storage (control_shadowed_operation_storage_err)
564:   );
565: 
566:   //   F[cdi_sel]: 7:7
567:   prim_subreg_shadow #(
568:     .DW      (1),
569:     .SwAccess(prim_subreg_pkg::SwAccessRW),
570:     .RESVAL  (1'h0),
571:     .Mubi    (1'b0)
572:   ) u_control_shadowed_cdi_sel (
573:     .clk_i   (clk_i),
574:     .rst_ni  (rst_ni),
575:     .rst_shadowed_ni (rst_shadowed_ni),
576: 
577:     // from register interface
578:     .re     (control_shadowed_re),
579:     .we     (control_shadowed_gated_we),
580:     .wd     (control_shadowed_cdi_sel_wd),
581: 
582:     // from internal hardware
583:     .de     (1'b0),
584:     .d      ('0),
585: 
586:     // to internal hardware
587:     .qe     (),
588:     .q      (reg2hw.control_shadowed.cdi_sel.q),
589:     .ds     (),
590: 
591:     // to register interface (read)
592:     .qs     (control_shadowed_cdi_sel_qs),
593: 
594:     // Shadow register phase. Relevant for hwext only.
595:     .phase  (),
596: 
597:     // Shadow register error conditions
598:     .err_update  (control_shadowed_cdi_sel_update_err),
599:     .err_storage (control_shadowed_cdi_sel_storage_err)
600:   );
601: 
602:   //   F[dest_sel]: 13:12
603:   prim_subreg_shadow #(
604:     .DW      (2),
605:     .SwAccess(prim_subreg_pkg::SwAccessRW),
606:     .RESVAL  (2'h0),
607:     .Mubi    (1'b0)
608:   ) u_control_shadowed_dest_sel (
609:     .clk_i   (clk_i),
610:     .rst_ni  (rst_ni),
611:     .rst_shadowed_ni (rst_shadowed_ni),
612: 
613:     // from register interface
614:     .re     (control_shadowed_re),
615:     .we     (control_shadowed_gated_we),
616:     .wd     (control_shadowed_dest_sel_wd),
617: 
618:     // from internal hardware
619:     .de     (1'b0),
620:     .d      ('0),
621: 
622:     // to internal hardware
623:     .qe     (),
624:     .q      (reg2hw.control_shadowed.dest_sel.q),
625:     .ds     (),
626: 
627:     // to register interface (read)
628:     .qs     (control_shadowed_dest_sel_qs),
629: 
630:     // Shadow register phase. Relevant for hwext only.
631:     .phase  (),
632: 
633:     // Shadow register error conditions
634:     .err_update  (control_shadowed_dest_sel_update_err),
635:     .err_storage (control_shadowed_dest_sel_storage_err)
636:   );
637: 
638: 
639:   // R[sideload_clear]: V(False)
640:   // Create REGWEN-gated WE signal
641:   logic sideload_clear_gated_we;
642:   assign sideload_clear_gated_we = sideload_clear_we & cfg_regwen_qs;
643:   prim_subreg #(
644:     .DW      (3),
645:     .SwAccess(prim_subreg_pkg::SwAccessRW),
646:     .RESVAL  (3'h0),
647:     .Mubi    (1'b0)
648:   ) u_sideload_clear (
649:     .clk_i   (clk_i),
650:     .rst_ni  (rst_ni),
651: 
652:     // from register interface
653:     .we     (sideload_clear_gated_we),
654:     .wd     (sideload_clear_wd),
655: 
656:     // from internal hardware
657:     .de     (1'b0),
658:     .d      ('0),
659: 
660:     // to internal hardware
661:     .qe     (),
662:     .q      (reg2hw.sideload_clear.q),
663:     .ds     (),
664: 
665:     // to register interface (read)
666:     .qs     (sideload_clear_qs)
667:   );
668: 
669: 
670:   // R[reseed_interval_regwen]: V(False)
671:   prim_subreg #(
672:     .DW      (1),
673:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
674:     .RESVAL  (1'h1),
675:     .Mubi    (1'b0)
676:   ) u_reseed_interval_regwen (
677:     .clk_i   (clk_i),
678:     .rst_ni  (rst_ni),
679: 
680:     // from register interface
681:     .we     (reseed_interval_regwen_we),
682:     .wd     (reseed_interval_regwen_wd),
683: 
684:     // from internal hardware
685:     .de     (1'b0),
686:     .d      ('0),
687: 
688:     // to internal hardware
689:     .qe     (),
690:     .q      (),
691:     .ds     (),
692: 
693:     // to register interface (read)
694:     .qs     (reseed_interval_regwen_qs)
695:   );
696: 
697: 
698:   // R[reseed_interval_shadowed]: V(False)
699:   // Create REGWEN-gated WE signal
700:   logic reseed_interval_shadowed_gated_we;
701:   assign reseed_interval_shadowed_gated_we =
702:     reseed_interval_shadowed_we & reseed_interval_regwen_qs;
703:   prim_subreg_shadow #(
704:     .DW      (16),
705:     .SwAccess(prim_subreg_pkg::SwAccessRW),
706:     .RESVAL  (16'h100),
707:     .Mubi    (1'b0)
708:   ) u_reseed_interval_shadowed (
709:     .clk_i   (clk_i),
710:     .rst_ni  (rst_ni),
711:     .rst_shadowed_ni (rst_shadowed_ni),
712: 
713:     // from register interface
714:     .re     (reseed_interval_shadowed_re),
715:     .we     (reseed_interval_shadowed_gated_we),
716:     .wd     (reseed_interval_shadowed_wd),
717: 
718:     // from internal hardware
719:     .de     (1'b0),
720:     .d      ('0),
721: 
722:     // to internal hardware
723:     .qe     (),
724:     .q      (reg2hw.reseed_interval_shadowed.q),
725:     .ds     (),
726: 
727:     // to register interface (read)
728:     .qs     (reseed_interval_shadowed_qs),
729: 
730:     // Shadow register phase. Relevant for hwext only.
731:     .phase  (),
732: 
733:     // Shadow register error conditions
734:     .err_update  (reseed_interval_shadowed_update_err),
735:     .err_storage (reseed_interval_shadowed_storage_err)
736:   );
737: 
738: 
739:   // R[sw_binding_regwen]: V(True)
740:   logic sw_binding_regwen_qe;
741:   logic [0:0] sw_binding_regwen_flds_we;
742:   assign sw_binding_regwen_qe = &sw_binding_regwen_flds_we;
743:   prim_subreg_ext #(
744:     .DW    (1)
745:   ) u_sw_binding_regwen (
746:     .re     (sw_binding_regwen_re),
747:     .we     (sw_binding_regwen_we),
748:     .wd     (sw_binding_regwen_wd),
749:     .d      (hw2reg.sw_binding_regwen.d),
750:     .qre    (),
751:     .qe     (sw_binding_regwen_flds_we[0]),
752:     .q      (reg2hw.sw_binding_regwen.q),
753:     .ds     (),
754:     .qs     (sw_binding_regwen_qs)
755:   );
756:   assign reg2hw.sw_binding_regwen.qe = sw_binding_regwen_qe;
757: 
758: 
759:   // Subregister 0 of Multireg sealing_sw_binding
760:   // R[sealing_sw_binding_0]: V(False)
761:   // Create REGWEN-gated WE signal
762:   logic sealing_sw_binding_0_gated_we;
763:   assign sealing_sw_binding_0_gated_we = sealing_sw_binding_0_we & sw_binding_regwen_qs;
764:   prim_subreg #(
765:     .DW      (32),
766:     .SwAccess(prim_subreg_pkg::SwAccessRW),
767:     .RESVAL  (32'h0),
768:     .Mubi    (1'b0)
769:   ) u_sealing_sw_binding_0 (
770:     .clk_i   (clk_i),
771:     .rst_ni  (rst_ni),
772: 
773:     // from register interface
774:     .we     (sealing_sw_binding_0_gated_we),
775:     .wd     (sealing_sw_binding_0_wd),
776: 
777:     // from internal hardware
778:     .de     (1'b0),
779:     .d      ('0),
780: 
781:     // to internal hardware
782:     .qe     (),
783:     .q      (reg2hw.sealing_sw_binding[0].q),
784:     .ds     (),
785: 
786:     // to register interface (read)
787:     .qs     (sealing_sw_binding_0_qs)
788:   );
789: 
790: 
791:   // Subregister 1 of Multireg sealing_sw_binding
792:   // R[sealing_sw_binding_1]: V(False)
793:   // Create REGWEN-gated WE signal
794:   logic sealing_sw_binding_1_gated_we;
795:   assign sealing_sw_binding_1_gated_we = sealing_sw_binding_1_we & sw_binding_regwen_qs;
796:   prim_subreg #(
797:     .DW      (32),
798:     .SwAccess(prim_subreg_pkg::SwAccessRW),
799:     .RESVAL  (32'h0),
800:     .Mubi    (1'b0)
801:   ) u_sealing_sw_binding_1 (
802:     .clk_i   (clk_i),
803:     .rst_ni  (rst_ni),
804: 
805:     // from register interface
806:     .we     (sealing_sw_binding_1_gated_we),
807:     .wd     (sealing_sw_binding_1_wd),
808: 
809:     // from internal hardware
810:     .de     (1'b0),
811:     .d      ('0),
812: 
813:     // to internal hardware
814:     .qe     (),
815:     .q      (reg2hw.sealing_sw_binding[1].q),
816:     .ds     (),
817: 
818:     // to register interface (read)
819:     .qs     (sealing_sw_binding_1_qs)
820:   );
821: 
822: 
823:   // Subregister 2 of Multireg sealing_sw_binding
824:   // R[sealing_sw_binding_2]: V(False)
825:   // Create REGWEN-gated WE signal
826:   logic sealing_sw_binding_2_gated_we;
827:   assign sealing_sw_binding_2_gated_we = sealing_sw_binding_2_we & sw_binding_regwen_qs;
828:   prim_subreg #(
829:     .DW      (32),
830:     .SwAccess(prim_subreg_pkg::SwAccessRW),
831:     .RESVAL  (32'h0),
832:     .Mubi    (1'b0)
833:   ) u_sealing_sw_binding_2 (
834:     .clk_i   (clk_i),
835:     .rst_ni  (rst_ni),
836: 
837:     // from register interface
838:     .we     (sealing_sw_binding_2_gated_we),
839:     .wd     (sealing_sw_binding_2_wd),
840: 
841:     // from internal hardware
842:     .de     (1'b0),
843:     .d      ('0),
844: 
845:     // to internal hardware
846:     .qe     (),
847:     .q      (reg2hw.sealing_sw_binding[2].q),
848:     .ds     (),
849: 
850:     // to register interface (read)
851:     .qs     (sealing_sw_binding_2_qs)
852:   );
853: 
854: 
855:   // Subregister 3 of Multireg sealing_sw_binding
856:   // R[sealing_sw_binding_3]: V(False)
857:   // Create REGWEN-gated WE signal
858:   logic sealing_sw_binding_3_gated_we;
859:   assign sealing_sw_binding_3_gated_we = sealing_sw_binding_3_we & sw_binding_regwen_qs;
860:   prim_subreg #(
861:     .DW      (32),
862:     .SwAccess(prim_subreg_pkg::SwAccessRW),
863:     .RESVAL  (32'h0),
864:     .Mubi    (1'b0)
865:   ) u_sealing_sw_binding_3 (
866:     .clk_i   (clk_i),
867:     .rst_ni  (rst_ni),
868: 
869:     // from register interface
870:     .we     (sealing_sw_binding_3_gated_we),
871:     .wd     (sealing_sw_binding_3_wd),
872: 
873:     // from internal hardware
874:     .de     (1'b0),
875:     .d      ('0),
876: 
877:     // to internal hardware
878:     .qe     (),
879:     .q      (reg2hw.sealing_sw_binding[3].q),
880:     .ds     (),
881: 
882:     // to register interface (read)
883:     .qs     (sealing_sw_binding_3_qs)
884:   );
885: 
886: 
887:   // Subregister 4 of Multireg sealing_sw_binding
888:   // R[sealing_sw_binding_4]: V(False)
889:   // Create REGWEN-gated WE signal
890:   logic sealing_sw_binding_4_gated_we;
891:   assign sealing_sw_binding_4_gated_we = sealing_sw_binding_4_we & sw_binding_regwen_qs;
892:   prim_subreg #(
893:     .DW      (32),
894:     .SwAccess(prim_subreg_pkg::SwAccessRW),
895:     .RESVAL  (32'h0),
896:     .Mubi    (1'b0)
897:   ) u_sealing_sw_binding_4 (
898:     .clk_i   (clk_i),
899:     .rst_ni  (rst_ni),
900: 
901:     // from register interface
902:     .we     (sealing_sw_binding_4_gated_we),
903:     .wd     (sealing_sw_binding_4_wd),
904: 
905:     // from internal hardware
906:     .de     (1'b0),
907:     .d      ('0),
908: 
909:     // to internal hardware
910:     .qe     (),
911:     .q      (reg2hw.sealing_sw_binding[4].q),
912:     .ds     (),
913: 
914:     // to register interface (read)
915:     .qs     (sealing_sw_binding_4_qs)
916:   );
917: 
918: 
919:   // Subregister 5 of Multireg sealing_sw_binding
920:   // R[sealing_sw_binding_5]: V(False)
921:   // Create REGWEN-gated WE signal
922:   logic sealing_sw_binding_5_gated_we;
923:   assign sealing_sw_binding_5_gated_we = sealing_sw_binding_5_we & sw_binding_regwen_qs;
924:   prim_subreg #(
925:     .DW      (32),
926:     .SwAccess(prim_subreg_pkg::SwAccessRW),
927:     .RESVAL  (32'h0),
928:     .Mubi    (1'b0)
929:   ) u_sealing_sw_binding_5 (
930:     .clk_i   (clk_i),
931:     .rst_ni  (rst_ni),
932: 
933:     // from register interface
934:     .we     (sealing_sw_binding_5_gated_we),
935:     .wd     (sealing_sw_binding_5_wd),
936: 
937:     // from internal hardware
938:     .de     (1'b0),
939:     .d      ('0),
940: 
941:     // to internal hardware
942:     .qe     (),
943:     .q      (reg2hw.sealing_sw_binding[5].q),
944:     .ds     (),
945: 
946:     // to register interface (read)
947:     .qs     (sealing_sw_binding_5_qs)
948:   );
949: 
950: 
951:   // Subregister 6 of Multireg sealing_sw_binding
952:   // R[sealing_sw_binding_6]: V(False)
953:   // Create REGWEN-gated WE signal
954:   logic sealing_sw_binding_6_gated_we;
955:   assign sealing_sw_binding_6_gated_we = sealing_sw_binding_6_we & sw_binding_regwen_qs;
956:   prim_subreg #(
957:     .DW      (32),
958:     .SwAccess(prim_subreg_pkg::SwAccessRW),
959:     .RESVAL  (32'h0),
960:     .Mubi    (1'b0)
961:   ) u_sealing_sw_binding_6 (
962:     .clk_i   (clk_i),
963:     .rst_ni  (rst_ni),
964: 
965:     // from register interface
966:     .we     (sealing_sw_binding_6_gated_we),
967:     .wd     (sealing_sw_binding_6_wd),
968: 
969:     // from internal hardware
970:     .de     (1'b0),
971:     .d      ('0),
972: 
973:     // to internal hardware
974:     .qe     (),
975:     .q      (reg2hw.sealing_sw_binding[6].q),
976:     .ds     (),
977: 
978:     // to register interface (read)
979:     .qs     (sealing_sw_binding_6_qs)
980:   );
981: 
982: 
983:   // Subregister 7 of Multireg sealing_sw_binding
984:   // R[sealing_sw_binding_7]: V(False)
985:   // Create REGWEN-gated WE signal
986:   logic sealing_sw_binding_7_gated_we;
987:   assign sealing_sw_binding_7_gated_we = sealing_sw_binding_7_we & sw_binding_regwen_qs;
988:   prim_subreg #(
989:     .DW      (32),
990:     .SwAccess(prim_subreg_pkg::SwAccessRW),
991:     .RESVAL  (32'h0),
992:     .Mubi    (1'b0)
993:   ) u_sealing_sw_binding_7 (
994:     .clk_i   (clk_i),
995:     .rst_ni  (rst_ni),
996: 
997:     // from register interface
998:     .we     (sealing_sw_binding_7_gated_we),
999:     .wd     (sealing_sw_binding_7_wd),
1000: 
1001:     // from internal hardware
1002:     .de     (1'b0),
1003:     .d      ('0),
1004: 
1005:     // to internal hardware
1006:     .qe     (),
1007:     .q      (reg2hw.sealing_sw_binding[7].q),
1008:     .ds     (),
1009: 
1010:     // to register interface (read)
1011:     .qs     (sealing_sw_binding_7_qs)
1012:   );
1013: 
1014: 
1015:   // Subregister 0 of Multireg attest_sw_binding
1016:   // R[attest_sw_binding_0]: V(False)
1017:   // Create REGWEN-gated WE signal
1018:   logic attest_sw_binding_0_gated_we;
1019:   assign attest_sw_binding_0_gated_we = attest_sw_binding_0_we & sw_binding_regwen_qs;
1020:   prim_subreg #(
1021:     .DW      (32),
1022:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1023:     .RESVAL  (32'h0),
1024:     .Mubi    (1'b0)
1025:   ) u_attest_sw_binding_0 (
1026:     .clk_i   (clk_i),
1027:     .rst_ni  (rst_ni),
1028: 
1029:     // from register interface
1030:     .we     (attest_sw_binding_0_gated_we),
1031:     .wd     (attest_sw_binding_0_wd),
1032: 
1033:     // from internal hardware
1034:     .de     (1'b0),
1035:     .d      ('0),
1036: 
1037:     // to internal hardware
1038:     .qe     (),
1039:     .q      (reg2hw.attest_sw_binding[0].q),
1040:     .ds     (),
1041: 
1042:     // to register interface (read)
1043:     .qs     (attest_sw_binding_0_qs)
1044:   );
1045: 
1046: 
1047:   // Subregister 1 of Multireg attest_sw_binding
1048:   // R[attest_sw_binding_1]: V(False)
1049:   // Create REGWEN-gated WE signal
1050:   logic attest_sw_binding_1_gated_we;
1051:   assign attest_sw_binding_1_gated_we = attest_sw_binding_1_we & sw_binding_regwen_qs;
1052:   prim_subreg #(
1053:     .DW      (32),
1054:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1055:     .RESVAL  (32'h0),
1056:     .Mubi    (1'b0)
1057:   ) u_attest_sw_binding_1 (
1058:     .clk_i   (clk_i),
1059:     .rst_ni  (rst_ni),
1060: 
1061:     // from register interface
1062:     .we     (attest_sw_binding_1_gated_we),
1063:     .wd     (attest_sw_binding_1_wd),
1064: 
1065:     // from internal hardware
1066:     .de     (1'b0),
1067:     .d      ('0),
1068: 
1069:     // to internal hardware
1070:     .qe     (),
1071:     .q      (reg2hw.attest_sw_binding[1].q),
1072:     .ds     (),
1073: 
1074:     // to register interface (read)
1075:     .qs     (attest_sw_binding_1_qs)
1076:   );
1077: 
1078: 
1079:   // Subregister 2 of Multireg attest_sw_binding
1080:   // R[attest_sw_binding_2]: V(False)
1081:   // Create REGWEN-gated WE signal
1082:   logic attest_sw_binding_2_gated_we;
1083:   assign attest_sw_binding_2_gated_we = attest_sw_binding_2_we & sw_binding_regwen_qs;
1084:   prim_subreg #(
1085:     .DW      (32),
1086:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1087:     .RESVAL  (32'h0),
1088:     .Mubi    (1'b0)
1089:   ) u_attest_sw_binding_2 (
1090:     .clk_i   (clk_i),
1091:     .rst_ni  (rst_ni),
1092: 
1093:     // from register interface
1094:     .we     (attest_sw_binding_2_gated_we),
1095:     .wd     (attest_sw_binding_2_wd),
1096: 
1097:     // from internal hardware
1098:     .de     (1'b0),
1099:     .d      ('0),
1100: 
1101:     // to internal hardware
1102:     .qe     (),
1103:     .q      (reg2hw.attest_sw_binding[2].q),
1104:     .ds     (),
1105: 
1106:     // to register interface (read)
1107:     .qs     (attest_sw_binding_2_qs)
1108:   );
1109: 
1110: 
1111:   // Subregister 3 of Multireg attest_sw_binding
1112:   // R[attest_sw_binding_3]: V(False)
1113:   // Create REGWEN-gated WE signal
1114:   logic attest_sw_binding_3_gated_we;
1115:   assign attest_sw_binding_3_gated_we = attest_sw_binding_3_we & sw_binding_regwen_qs;
1116:   prim_subreg #(
1117:     .DW      (32),
1118:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1119:     .RESVAL  (32'h0),
1120:     .Mubi    (1'b0)
1121:   ) u_attest_sw_binding_3 (
1122:     .clk_i   (clk_i),
1123:     .rst_ni  (rst_ni),
1124: 
1125:     // from register interface
1126:     .we     (attest_sw_binding_3_gated_we),
1127:     .wd     (attest_sw_binding_3_wd),
1128: 
1129:     // from internal hardware
1130:     .de     (1'b0),
1131:     .d      ('0),
1132: 
1133:     // to internal hardware
1134:     .qe     (),
1135:     .q      (reg2hw.attest_sw_binding[3].q),
1136:     .ds     (),
1137: 
1138:     // to register interface (read)
1139:     .qs     (attest_sw_binding_3_qs)
1140:   );
1141: 
1142: 
1143:   // Subregister 4 of Multireg attest_sw_binding
1144:   // R[attest_sw_binding_4]: V(False)
1145:   // Create REGWEN-gated WE signal
1146:   logic attest_sw_binding_4_gated_we;
1147:   assign attest_sw_binding_4_gated_we = attest_sw_binding_4_we & sw_binding_regwen_qs;
1148:   prim_subreg #(
1149:     .DW      (32),
1150:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1151:     .RESVAL  (32'h0),
1152:     .Mubi    (1'b0)
1153:   ) u_attest_sw_binding_4 (
1154:     .clk_i   (clk_i),
1155:     .rst_ni  (rst_ni),
1156: 
1157:     // from register interface
1158:     .we     (attest_sw_binding_4_gated_we),
1159:     .wd     (attest_sw_binding_4_wd),
1160: 
1161:     // from internal hardware
1162:     .de     (1'b0),
1163:     .d      ('0),
1164: 
1165:     // to internal hardware
1166:     .qe     (),
1167:     .q      (reg2hw.attest_sw_binding[4].q),
1168:     .ds     (),
1169: 
1170:     // to register interface (read)
1171:     .qs     (attest_sw_binding_4_qs)
1172:   );
1173: 
1174: 
1175:   // Subregister 5 of Multireg attest_sw_binding
1176:   // R[attest_sw_binding_5]: V(False)
1177:   // Create REGWEN-gated WE signal
1178:   logic attest_sw_binding_5_gated_we;
1179:   assign attest_sw_binding_5_gated_we = attest_sw_binding_5_we & sw_binding_regwen_qs;
1180:   prim_subreg #(
1181:     .DW      (32),
1182:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1183:     .RESVAL  (32'h0),
1184:     .Mubi    (1'b0)
1185:   ) u_attest_sw_binding_5 (
1186:     .clk_i   (clk_i),
1187:     .rst_ni  (rst_ni),
1188: 
1189:     // from register interface
1190:     .we     (attest_sw_binding_5_gated_we),
1191:     .wd     (attest_sw_binding_5_wd),
1192: 
1193:     // from internal hardware
1194:     .de     (1'b0),
1195:     .d      ('0),
1196: 
1197:     // to internal hardware
1198:     .qe     (),
1199:     .q      (reg2hw.attest_sw_binding[5].q),
1200:     .ds     (),
1201: 
1202:     // to register interface (read)
1203:     .qs     (attest_sw_binding_5_qs)
1204:   );
1205: 
1206: 
1207:   // Subregister 6 of Multireg attest_sw_binding
1208:   // R[attest_sw_binding_6]: V(False)
1209:   // Create REGWEN-gated WE signal
1210:   logic attest_sw_binding_6_gated_we;
1211:   assign attest_sw_binding_6_gated_we = attest_sw_binding_6_we & sw_binding_regwen_qs;
1212:   prim_subreg #(
1213:     .DW      (32),
1214:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1215:     .RESVAL  (32'h0),
1216:     .Mubi    (1'b0)
1217:   ) u_attest_sw_binding_6 (
1218:     .clk_i   (clk_i),
1219:     .rst_ni  (rst_ni),
1220: 
1221:     // from register interface
1222:     .we     (attest_sw_binding_6_gated_we),
1223:     .wd     (attest_sw_binding_6_wd),
1224: 
1225:     // from internal hardware
1226:     .de     (1'b0),
1227:     .d      ('0),
1228: 
1229:     // to internal hardware
1230:     .qe     (),
1231:     .q      (reg2hw.attest_sw_binding[6].q),
1232:     .ds     (),
1233: 
1234:     // to register interface (read)
1235:     .qs     (attest_sw_binding_6_qs)
1236:   );
1237: 
1238: 
1239:   // Subregister 7 of Multireg attest_sw_binding
1240:   // R[attest_sw_binding_7]: V(False)
1241:   // Create REGWEN-gated WE signal
1242:   logic attest_sw_binding_7_gated_we;
1243:   assign attest_sw_binding_7_gated_we = attest_sw_binding_7_we & sw_binding_regwen_qs;
1244:   prim_subreg #(
1245:     .DW      (32),
1246:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1247:     .RESVAL  (32'h0),
1248:     .Mubi    (1'b0)
1249:   ) u_attest_sw_binding_7 (
1250:     .clk_i   (clk_i),
1251:     .rst_ni  (rst_ni),
1252: 
1253:     // from register interface
1254:     .we     (attest_sw_binding_7_gated_we),
1255:     .wd     (attest_sw_binding_7_wd),
1256: 
1257:     // from internal hardware
1258:     .de     (1'b0),
1259:     .d      ('0),
1260: 
1261:     // to internal hardware
1262:     .qe     (),
1263:     .q      (reg2hw.attest_sw_binding[7].q),
1264:     .ds     (),
1265: 
1266:     // to register interface (read)
1267:     .qs     (attest_sw_binding_7_qs)
1268:   );
1269: 
1270: 
1271:   // Subregister 0 of Multireg salt
1272:   // R[salt_0]: V(False)
1273:   // Create REGWEN-gated WE signal
1274:   logic salt_0_gated_we;
1275:   assign salt_0_gated_we = salt_0_we & cfg_regwen_qs;
1276:   prim_subreg #(
1277:     .DW      (32),
1278:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1279:     .RESVAL  (32'h0),
1280:     .Mubi    (1'b0)
1281:   ) u_salt_0 (
1282:     .clk_i   (clk_i),
1283:     .rst_ni  (rst_ni),
1284: 
1285:     // from register interface
1286:     .we     (salt_0_gated_we),
1287:     .wd     (salt_0_wd),
1288: 
1289:     // from internal hardware
1290:     .de     (1'b0),
1291:     .d      ('0),
1292: 
1293:     // to internal hardware
1294:     .qe     (),
1295:     .q      (reg2hw.salt[0].q),
1296:     .ds     (),
1297: 
1298:     // to register interface (read)
1299:     .qs     (salt_0_qs)
1300:   );
1301: 
1302: 
1303:   // Subregister 1 of Multireg salt
1304:   // R[salt_1]: V(False)
1305:   // Create REGWEN-gated WE signal
1306:   logic salt_1_gated_we;
1307:   assign salt_1_gated_we = salt_1_we & cfg_regwen_qs;
1308:   prim_subreg #(
1309:     .DW      (32),
1310:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1311:     .RESVAL  (32'h0),
1312:     .Mubi    (1'b0)
1313:   ) u_salt_1 (
1314:     .clk_i   (clk_i),
1315:     .rst_ni  (rst_ni),
1316: 
1317:     // from register interface
1318:     .we     (salt_1_gated_we),
1319:     .wd     (salt_1_wd),
1320: 
1321:     // from internal hardware
1322:     .de     (1'b0),
1323:     .d      ('0),
1324: 
1325:     // to internal hardware
1326:     .qe     (),
1327:     .q      (reg2hw.salt[1].q),
1328:     .ds     (),
1329: 
1330:     // to register interface (read)
1331:     .qs     (salt_1_qs)
1332:   );
1333: 
1334: 
1335:   // Subregister 2 of Multireg salt
1336:   // R[salt_2]: V(False)
1337:   // Create REGWEN-gated WE signal
1338:   logic salt_2_gated_we;
1339:   assign salt_2_gated_we = salt_2_we & cfg_regwen_qs;
1340:   prim_subreg #(
1341:     .DW      (32),
1342:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1343:     .RESVAL  (32'h0),
1344:     .Mubi    (1'b0)
1345:   ) u_salt_2 (
1346:     .clk_i   (clk_i),
1347:     .rst_ni  (rst_ni),
1348: 
1349:     // from register interface
1350:     .we     (salt_2_gated_we),
1351:     .wd     (salt_2_wd),
1352: 
1353:     // from internal hardware
1354:     .de     (1'b0),
1355:     .d      ('0),
1356: 
1357:     // to internal hardware
1358:     .qe     (),
1359:     .q      (reg2hw.salt[2].q),
1360:     .ds     (),
1361: 
1362:     // to register interface (read)
1363:     .qs     (salt_2_qs)
1364:   );
1365: 
1366: 
1367:   // Subregister 3 of Multireg salt
1368:   // R[salt_3]: V(False)
1369:   // Create REGWEN-gated WE signal
1370:   logic salt_3_gated_we;
1371:   assign salt_3_gated_we = salt_3_we & cfg_regwen_qs;
1372:   prim_subreg #(
1373:     .DW      (32),
1374:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1375:     .RESVAL  (32'h0),
1376:     .Mubi    (1'b0)
1377:   ) u_salt_3 (
1378:     .clk_i   (clk_i),
1379:     .rst_ni  (rst_ni),
1380: 
1381:     // from register interface
1382:     .we     (salt_3_gated_we),
1383:     .wd     (salt_3_wd),
1384: 
1385:     // from internal hardware
1386:     .de     (1'b0),
1387:     .d      ('0),
1388: 
1389:     // to internal hardware
1390:     .qe     (),
1391:     .q      (reg2hw.salt[3].q),
1392:     .ds     (),
1393: 
1394:     // to register interface (read)
1395:     .qs     (salt_3_qs)
1396:   );
1397: 
1398: 
1399:   // Subregister 4 of Multireg salt
1400:   // R[salt_4]: V(False)
1401:   // Create REGWEN-gated WE signal
1402:   logic salt_4_gated_we;
1403:   assign salt_4_gated_we = salt_4_we & cfg_regwen_qs;
1404:   prim_subreg #(
1405:     .DW      (32),
1406:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1407:     .RESVAL  (32'h0),
1408:     .Mubi    (1'b0)
1409:   ) u_salt_4 (
1410:     .clk_i   (clk_i),
1411:     .rst_ni  (rst_ni),
1412: 
1413:     // from register interface
1414:     .we     (salt_4_gated_we),
1415:     .wd     (salt_4_wd),
1416: 
1417:     // from internal hardware
1418:     .de     (1'b0),
1419:     .d      ('0),
1420: 
1421:     // to internal hardware
1422:     .qe     (),
1423:     .q      (reg2hw.salt[4].q),
1424:     .ds     (),
1425: 
1426:     // to register interface (read)
1427:     .qs     (salt_4_qs)
1428:   );
1429: 
1430: 
1431:   // Subregister 5 of Multireg salt
1432:   // R[salt_5]: V(False)
1433:   // Create REGWEN-gated WE signal
1434:   logic salt_5_gated_we;
1435:   assign salt_5_gated_we = salt_5_we & cfg_regwen_qs;
1436:   prim_subreg #(
1437:     .DW      (32),
1438:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1439:     .RESVAL  (32'h0),
1440:     .Mubi    (1'b0)
1441:   ) u_salt_5 (
1442:     .clk_i   (clk_i),
1443:     .rst_ni  (rst_ni),
1444: 
1445:     // from register interface
1446:     .we     (salt_5_gated_we),
1447:     .wd     (salt_5_wd),
1448: 
1449:     // from internal hardware
1450:     .de     (1'b0),
1451:     .d      ('0),
1452: 
1453:     // to internal hardware
1454:     .qe     (),
1455:     .q      (reg2hw.salt[5].q),
1456:     .ds     (),
1457: 
1458:     // to register interface (read)
1459:     .qs     (salt_5_qs)
1460:   );
1461: 
1462: 
1463:   // Subregister 6 of Multireg salt
1464:   // R[salt_6]: V(False)
1465:   // Create REGWEN-gated WE signal
1466:   logic salt_6_gated_we;
1467:   assign salt_6_gated_we = salt_6_we & cfg_regwen_qs;
1468:   prim_subreg #(
1469:     .DW      (32),
1470:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1471:     .RESVAL  (32'h0),
1472:     .Mubi    (1'b0)
1473:   ) u_salt_6 (
1474:     .clk_i   (clk_i),
1475:     .rst_ni  (rst_ni),
1476: 
1477:     // from register interface
1478:     .we     (salt_6_gated_we),
1479:     .wd     (salt_6_wd),
1480: 
1481:     // from internal hardware
1482:     .de     (1'b0),
1483:     .d      ('0),
1484: 
1485:     // to internal hardware
1486:     .qe     (),
1487:     .q      (reg2hw.salt[6].q),
1488:     .ds     (),
1489: 
1490:     // to register interface (read)
1491:     .qs     (salt_6_qs)
1492:   );
1493: 
1494: 
1495:   // Subregister 7 of Multireg salt
1496:   // R[salt_7]: V(False)
1497:   // Create REGWEN-gated WE signal
1498:   logic salt_7_gated_we;
1499:   assign salt_7_gated_we = salt_7_we & cfg_regwen_qs;
1500:   prim_subreg #(
1501:     .DW      (32),
1502:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1503:     .RESVAL  (32'h0),
1504:     .Mubi    (1'b0)
1505:   ) u_salt_7 (
1506:     .clk_i   (clk_i),
1507:     .rst_ni  (rst_ni),
1508: 
1509:     // from register interface
1510:     .we     (salt_7_gated_we),
1511:     .wd     (salt_7_wd),
1512: 
1513:     // from internal hardware
1514:     .de     (1'b0),
1515:     .d      ('0),
1516: 
1517:     // to internal hardware
1518:     .qe     (),
1519:     .q      (reg2hw.salt[7].q),
1520:     .ds     (),
1521: 
1522:     // to register interface (read)
1523:     .qs     (salt_7_qs)
1524:   );
1525: 
1526: 
1527:   // Subregister 0 of Multireg key_version
1528:   // R[key_version]: V(False)
1529:   // Create REGWEN-gated WE signal
1530:   logic key_version_gated_we;
1531:   assign key_version_gated_we = key_version_we & cfg_regwen_qs;
1532:   prim_subreg #(
1533:     .DW      (32),
1534:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1535:     .RESVAL  (32'h0),
1536:     .Mubi    (1'b0)
1537:   ) u_key_version (
1538:     .clk_i   (clk_i),
1539:     .rst_ni  (rst_ni),
1540: 
1541:     // from register interface
1542:     .we     (key_version_gated_we),
1543:     .wd     (key_version_wd),
1544: 
1545:     // from internal hardware
1546:     .de     (1'b0),
1547:     .d      ('0),
1548: 
1549:     // to internal hardware
1550:     .qe     (),
1551:     .q      (reg2hw.key_version[0].q),
1552:     .ds     (),
1553: 
1554:     // to register interface (read)
1555:     .qs     (key_version_qs)
1556:   );
1557: 
1558: 
1559:   // R[max_creator_key_ver_regwen]: V(False)
1560:   prim_subreg #(
1561:     .DW      (1),
1562:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
1563:     .RESVAL  (1'h1),
1564:     .Mubi    (1'b0)
1565:   ) u_max_creator_key_ver_regwen (
1566:     .clk_i   (clk_i),
1567:     .rst_ni  (rst_ni),
1568: 
1569:     // from register interface
1570:     .we     (max_creator_key_ver_regwen_we),
1571:     .wd     (max_creator_key_ver_regwen_wd),
1572: 
1573:     // from internal hardware
1574:     .de     (1'b0),
1575:     .d      ('0),
1576: 
1577:     // to internal hardware
1578:     .qe     (),
1579:     .q      (),
1580:     .ds     (),
1581: 
1582:     // to register interface (read)
1583:     .qs     (max_creator_key_ver_regwen_qs)
1584:   );
1585: 
1586: 
1587:   // R[max_creator_key_ver_shadowed]: V(False)
1588:   // Create REGWEN-gated WE signal
1589:   logic max_creator_key_ver_shadowed_gated_we;
1590:   assign max_creator_key_ver_shadowed_gated_we =
1591:     max_creator_key_ver_shadowed_we & max_creator_key_ver_regwen_qs;
1592:   prim_subreg_shadow #(
1593:     .DW      (32),
1594:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1595:     .RESVAL  (32'h0),
1596:     .Mubi    (1'b0)
1597:   ) u_max_creator_key_ver_shadowed (
1598:     .clk_i   (clk_i),
1599:     .rst_ni  (rst_ni),
1600:     .rst_shadowed_ni (rst_shadowed_ni),
1601: 
1602:     // from register interface
1603:     .re     (max_creator_key_ver_shadowed_re),
1604:     .we     (max_creator_key_ver_shadowed_gated_we),
1605:     .wd     (max_creator_key_ver_shadowed_wd),
1606: 
1607:     // from internal hardware
1608:     .de     (1'b0),
1609:     .d      ('0),
1610: 
1611:     // to internal hardware
1612:     .qe     (),
1613:     .q      (reg2hw.max_creator_key_ver_shadowed.q),
1614:     .ds     (),
1615: 
1616:     // to register interface (read)
1617:     .qs     (max_creator_key_ver_shadowed_qs),
1618: 
1619:     // Shadow register phase. Relevant for hwext only.
1620:     .phase  (),
1621: 
1622:     // Shadow register error conditions
1623:     .err_update  (max_creator_key_ver_shadowed_update_err),
1624:     .err_storage (max_creator_key_ver_shadowed_storage_err)
1625:   );
1626: 
1627: 
1628:   // R[max_owner_int_key_ver_regwen]: V(False)
1629:   prim_subreg #(
1630:     .DW      (1),
1631:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
1632:     .RESVAL  (1'h1),
1633:     .Mubi    (1'b0)
1634:   ) u_max_owner_int_key_ver_regwen (
1635:     .clk_i   (clk_i),
1636:     .rst_ni  (rst_ni),
1637: 
1638:     // from register interface
1639:     .we     (max_owner_int_key_ver_regwen_we),
1640:     .wd     (max_owner_int_key_ver_regwen_wd),
1641: 
1642:     // from internal hardware
1643:     .de     (1'b0),
1644:     .d      ('0),
1645: 
1646:     // to internal hardware
1647:     .qe     (),
1648:     .q      (),
1649:     .ds     (),
1650: 
1651:     // to register interface (read)
1652:     .qs     (max_owner_int_key_ver_regwen_qs)
1653:   );
1654: 
1655: 
1656:   // R[max_owner_int_key_ver_shadowed]: V(False)
1657:   // Create REGWEN-gated WE signal
1658:   logic max_owner_int_key_ver_shadowed_gated_we;
1659:   assign max_owner_int_key_ver_shadowed_gated_we =
1660:     max_owner_int_key_ver_shadowed_we & max_owner_int_key_ver_regwen_qs;
1661:   prim_subreg_shadow #(
1662:     .DW      (32),
1663:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1664:     .RESVAL  (32'h1),
1665:     .Mubi    (1'b0)
1666:   ) u_max_owner_int_key_ver_shadowed (
1667:     .clk_i   (clk_i),
1668:     .rst_ni  (rst_ni),
1669:     .rst_shadowed_ni (rst_shadowed_ni),
1670: 
1671:     // from register interface
1672:     .re     (max_owner_int_key_ver_shadowed_re),
1673:     .we     (max_owner_int_key_ver_shadowed_gated_we),
1674:     .wd     (max_owner_int_key_ver_shadowed_wd),
1675: 
1676:     // from internal hardware
1677:     .de     (1'b0),
1678:     .d      ('0),
1679: 
1680:     // to internal hardware
1681:     .qe     (),
1682:     .q      (reg2hw.max_owner_int_key_ver_shadowed.q),
1683:     .ds     (),
1684: 
1685:     // to register interface (read)
1686:     .qs     (max_owner_int_key_ver_shadowed_qs),
1687: 
1688:     // Shadow register phase. Relevant for hwext only.
1689:     .phase  (),
1690: 
1691:     // Shadow register error conditions
1692:     .err_update  (max_owner_int_key_ver_shadowed_update_err),
1693:     .err_storage (max_owner_int_key_ver_shadowed_storage_err)
1694:   );
1695: 
1696: 
1697:   // R[max_owner_key_ver_regwen]: V(False)
1698:   prim_subreg #(
1699:     .DW      (1),
1700:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
1701:     .RESVAL  (1'h1),
1702:     .Mubi    (1'b0)
1703:   ) u_max_owner_key_ver_regwen (
1704:     .clk_i   (clk_i),
1705:     .rst_ni  (rst_ni),
1706: 
1707:     // from register interface
1708:     .we     (max_owner_key_ver_regwen_we),
1709:     .wd     (max_owner_key_ver_regwen_wd),
1710: 
1711:     // from internal hardware
1712:     .de     (1'b0),
1713:     .d      ('0),
1714: 
1715:     // to internal hardware
1716:     .qe     (),
1717:     .q      (),
1718:     .ds     (),
1719: 
1720:     // to register interface (read)
1721:     .qs     (max_owner_key_ver_regwen_qs)
1722:   );
1723: 
1724: 
1725:   // R[max_owner_key_ver_shadowed]: V(False)
1726:   // Create REGWEN-gated WE signal
1727:   logic max_owner_key_ver_shadowed_gated_we;
1728:   assign max_owner_key_ver_shadowed_gated_we =
1729:     max_owner_key_ver_shadowed_we & max_owner_key_ver_regwen_qs;
1730:   prim_subreg_shadow #(
1731:     .DW      (32),
1732:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1733:     .RESVAL  (32'h0),
1734:     .Mubi    (1'b0)
1735:   ) u_max_owner_key_ver_shadowed (
1736:     .clk_i   (clk_i),
1737:     .rst_ni  (rst_ni),
1738:     .rst_shadowed_ni (rst_shadowed_ni),
1739: 
1740:     // from register interface
1741:     .re     (max_owner_key_ver_shadowed_re),
1742:     .we     (max_owner_key_ver_shadowed_gated_we),
1743:     .wd     (max_owner_key_ver_shadowed_wd),
1744: 
1745:     // from internal hardware
1746:     .de     (1'b0),
1747:     .d      ('0),
1748: 
1749:     // to internal hardware
1750:     .qe     (),
1751:     .q      (reg2hw.max_owner_key_ver_shadowed.q),
1752:     .ds     (),
1753: 
1754:     // to register interface (read)
1755:     .qs     (max_owner_key_ver_shadowed_qs),
1756: 
1757:     // Shadow register phase. Relevant for hwext only.
1758:     .phase  (),
1759: 
1760:     // Shadow register error conditions
1761:     .err_update  (max_owner_key_ver_shadowed_update_err),
1762:     .err_storage (max_owner_key_ver_shadowed_storage_err)
1763:   );
1764: 
1765: 
1766:   // Subregister 0 of Multireg sw_share0_output
1767:   // R[sw_share0_output_0]: V(False)
1768:   prim_subreg #(
1769:     .DW      (32),
1770:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1771:     .RESVAL  (32'h0),
1772:     .Mubi    (1'b0)
1773:   ) u_sw_share0_output_0 (
1774:     .clk_i   (clk_i),
1775:     .rst_ni  (rst_ni),
1776: 
1777:     // from register interface
1778:     .we     (sw_share0_output_0_re),
1779:     .wd     (sw_share0_output_0_wd),
1780: 
1781:     // from internal hardware
1782:     .de     (hw2reg.sw_share0_output[0].de),
1783:     .d      (hw2reg.sw_share0_output[0].d),
1784: 
1785:     // to internal hardware
1786:     .qe     (),
1787:     .q      (),
1788:     .ds     (),
1789: 
1790:     // to register interface (read)
1791:     .qs     (sw_share0_output_0_qs)
1792:   );
1793: 
1794: 
1795:   // Subregister 1 of Multireg sw_share0_output
1796:   // R[sw_share0_output_1]: V(False)
1797:   prim_subreg #(
1798:     .DW      (32),
1799:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1800:     .RESVAL  (32'h0),
1801:     .Mubi    (1'b0)
1802:   ) u_sw_share0_output_1 (
1803:     .clk_i   (clk_i),
1804:     .rst_ni  (rst_ni),
1805: 
1806:     // from register interface
1807:     .we     (sw_share0_output_1_re),
1808:     .wd     (sw_share0_output_1_wd),
1809: 
1810:     // from internal hardware
1811:     .de     (hw2reg.sw_share0_output[1].de),
1812:     .d      (hw2reg.sw_share0_output[1].d),
1813: 
1814:     // to internal hardware
1815:     .qe     (),
1816:     .q      (),
1817:     .ds     (),
1818: 
1819:     // to register interface (read)
1820:     .qs     (sw_share0_output_1_qs)
1821:   );
1822: 
1823: 
1824:   // Subregister 2 of Multireg sw_share0_output
1825:   // R[sw_share0_output_2]: V(False)
1826:   prim_subreg #(
1827:     .DW      (32),
1828:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1829:     .RESVAL  (32'h0),
1830:     .Mubi    (1'b0)
1831:   ) u_sw_share0_output_2 (
1832:     .clk_i   (clk_i),
1833:     .rst_ni  (rst_ni),
1834: 
1835:     // from register interface
1836:     .we     (sw_share0_output_2_re),
1837:     .wd     (sw_share0_output_2_wd),
1838: 
1839:     // from internal hardware
1840:     .de     (hw2reg.sw_share0_output[2].de),
1841:     .d      (hw2reg.sw_share0_output[2].d),
1842: 
1843:     // to internal hardware
1844:     .qe     (),
1845:     .q      (),
1846:     .ds     (),
1847: 
1848:     // to register interface (read)
1849:     .qs     (sw_share0_output_2_qs)
1850:   );
1851: 
1852: 
1853:   // Subregister 3 of Multireg sw_share0_output
1854:   // R[sw_share0_output_3]: V(False)
1855:   prim_subreg #(
1856:     .DW      (32),
1857:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1858:     .RESVAL  (32'h0),
1859:     .Mubi    (1'b0)
1860:   ) u_sw_share0_output_3 (
1861:     .clk_i   (clk_i),
1862:     .rst_ni  (rst_ni),
1863: 
1864:     // from register interface
1865:     .we     (sw_share0_output_3_re),
1866:     .wd     (sw_share0_output_3_wd),
1867: 
1868:     // from internal hardware
1869:     .de     (hw2reg.sw_share0_output[3].de),
1870:     .d      (hw2reg.sw_share0_output[3].d),
1871: 
1872:     // to internal hardware
1873:     .qe     (),
1874:     .q      (),
1875:     .ds     (),
1876: 
1877:     // to register interface (read)
1878:     .qs     (sw_share0_output_3_qs)
1879:   );
1880: 
1881: 
1882:   // Subregister 4 of Multireg sw_share0_output
1883:   // R[sw_share0_output_4]: V(False)
1884:   prim_subreg #(
1885:     .DW      (32),
1886:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1887:     .RESVAL  (32'h0),
1888:     .Mubi    (1'b0)
1889:   ) u_sw_share0_output_4 (
1890:     .clk_i   (clk_i),
1891:     .rst_ni  (rst_ni),
1892: 
1893:     // from register interface
1894:     .we     (sw_share0_output_4_re),
1895:     .wd     (sw_share0_output_4_wd),
1896: 
1897:     // from internal hardware
1898:     .de     (hw2reg.sw_share0_output[4].de),
1899:     .d      (hw2reg.sw_share0_output[4].d),
1900: 
1901:     // to internal hardware
1902:     .qe     (),
1903:     .q      (),
1904:     .ds     (),
1905: 
1906:     // to register interface (read)
1907:     .qs     (sw_share0_output_4_qs)
1908:   );
1909: 
1910: 
1911:   // Subregister 5 of Multireg sw_share0_output
1912:   // R[sw_share0_output_5]: V(False)
1913:   prim_subreg #(
1914:     .DW      (32),
1915:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1916:     .RESVAL  (32'h0),
1917:     .Mubi    (1'b0)
1918:   ) u_sw_share0_output_5 (
1919:     .clk_i   (clk_i),
1920:     .rst_ni  (rst_ni),
1921: 
1922:     // from register interface
1923:     .we     (sw_share0_output_5_re),
1924:     .wd     (sw_share0_output_5_wd),
1925: 
1926:     // from internal hardware
1927:     .de     (hw2reg.sw_share0_output[5].de),
1928:     .d      (hw2reg.sw_share0_output[5].d),
1929: 
1930:     // to internal hardware
1931:     .qe     (),
1932:     .q      (),
1933:     .ds     (),
1934: 
1935:     // to register interface (read)
1936:     .qs     (sw_share0_output_5_qs)
1937:   );
1938: 
1939: 
1940:   // Subregister 6 of Multireg sw_share0_output
1941:   // R[sw_share0_output_6]: V(False)
1942:   prim_subreg #(
1943:     .DW      (32),
1944:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1945:     .RESVAL  (32'h0),
1946:     .Mubi    (1'b0)
1947:   ) u_sw_share0_output_6 (
1948:     .clk_i   (clk_i),
1949:     .rst_ni  (rst_ni),
1950: 
1951:     // from register interface
1952:     .we     (sw_share0_output_6_re),
1953:     .wd     (sw_share0_output_6_wd),
1954: 
1955:     // from internal hardware
1956:     .de     (hw2reg.sw_share0_output[6].de),
1957:     .d      (hw2reg.sw_share0_output[6].d),
1958: 
1959:     // to internal hardware
1960:     .qe     (),
1961:     .q      (),
1962:     .ds     (),
1963: 
1964:     // to register interface (read)
1965:     .qs     (sw_share0_output_6_qs)
1966:   );
1967: 
1968: 
1969:   // Subregister 7 of Multireg sw_share0_output
1970:   // R[sw_share0_output_7]: V(False)
1971:   prim_subreg #(
1972:     .DW      (32),
1973:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1974:     .RESVAL  (32'h0),
1975:     .Mubi    (1'b0)
1976:   ) u_sw_share0_output_7 (
1977:     .clk_i   (clk_i),
1978:     .rst_ni  (rst_ni),
1979: 
1980:     // from register interface
1981:     .we     (sw_share0_output_7_re),
1982:     .wd     (sw_share0_output_7_wd),
1983: 
1984:     // from internal hardware
1985:     .de     (hw2reg.sw_share0_output[7].de),
1986:     .d      (hw2reg.sw_share0_output[7].d),
1987: 
1988:     // to internal hardware
1989:     .qe     (),
1990:     .q      (),
1991:     .ds     (),
1992: 
1993:     // to register interface (read)
1994:     .qs     (sw_share0_output_7_qs)
1995:   );
1996: 
1997: 
1998:   // Subregister 0 of Multireg sw_share1_output
1999:   // R[sw_share1_output_0]: V(False)
2000:   prim_subreg #(
2001:     .DW      (32),
2002:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2003:     .RESVAL  (32'h0),
2004:     .Mubi    (1'b0)
2005:   ) u_sw_share1_output_0 (
2006:     .clk_i   (clk_i),
2007:     .rst_ni  (rst_ni),
2008: 
2009:     // from register interface
2010:     .we     (sw_share1_output_0_re),
2011:     .wd     (sw_share1_output_0_wd),
2012: 
2013:     // from internal hardware
2014:     .de     (hw2reg.sw_share1_output[0].de),
2015:     .d      (hw2reg.sw_share1_output[0].d),
2016: 
2017:     // to internal hardware
2018:     .qe     (),
2019:     .q      (),
2020:     .ds     (),
2021: 
2022:     // to register interface (read)
2023:     .qs     (sw_share1_output_0_qs)
2024:   );
2025: 
2026: 
2027:   // Subregister 1 of Multireg sw_share1_output
2028:   // R[sw_share1_output_1]: V(False)
2029:   prim_subreg #(
2030:     .DW      (32),
2031:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2032:     .RESVAL  (32'h0),
2033:     .Mubi    (1'b0)
2034:   ) u_sw_share1_output_1 (
2035:     .clk_i   (clk_i),
2036:     .rst_ni  (rst_ni),
2037: 
2038:     // from register interface
2039:     .we     (sw_share1_output_1_re),
2040:     .wd     (sw_share1_output_1_wd),
2041: 
2042:     // from internal hardware
2043:     .de     (hw2reg.sw_share1_output[1].de),
2044:     .d      (hw2reg.sw_share1_output[1].d),
2045: 
2046:     // to internal hardware
2047:     .qe     (),
2048:     .q      (),
2049:     .ds     (),
2050: 
2051:     // to register interface (read)
2052:     .qs     (sw_share1_output_1_qs)
2053:   );
2054: 
2055: 
2056:   // Subregister 2 of Multireg sw_share1_output
2057:   // R[sw_share1_output_2]: V(False)
2058:   prim_subreg #(
2059:     .DW      (32),
2060:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2061:     .RESVAL  (32'h0),
2062:     .Mubi    (1'b0)
2063:   ) u_sw_share1_output_2 (
2064:     .clk_i   (clk_i),
2065:     .rst_ni  (rst_ni),
2066: 
2067:     // from register interface
2068:     .we     (sw_share1_output_2_re),
2069:     .wd     (sw_share1_output_2_wd),
2070: 
2071:     // from internal hardware
2072:     .de     (hw2reg.sw_share1_output[2].de),
2073:     .d      (hw2reg.sw_share1_output[2].d),
2074: 
2075:     // to internal hardware
2076:     .qe     (),
2077:     .q      (),
2078:     .ds     (),
2079: 
2080:     // to register interface (read)
2081:     .qs     (sw_share1_output_2_qs)
2082:   );
2083: 
2084: 
2085:   // Subregister 3 of Multireg sw_share1_output
2086:   // R[sw_share1_output_3]: V(False)
2087:   prim_subreg #(
2088:     .DW      (32),
2089:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2090:     .RESVAL  (32'h0),
2091:     .Mubi    (1'b0)
2092:   ) u_sw_share1_output_3 (
2093:     .clk_i   (clk_i),
2094:     .rst_ni  (rst_ni),
2095: 
2096:     // from register interface
2097:     .we     (sw_share1_output_3_re),
2098:     .wd     (sw_share1_output_3_wd),
2099: 
2100:     // from internal hardware
2101:     .de     (hw2reg.sw_share1_output[3].de),
2102:     .d      (hw2reg.sw_share1_output[3].d),
2103: 
2104:     // to internal hardware
2105:     .qe     (),
2106:     .q      (),
2107:     .ds     (),
2108: 
2109:     // to register interface (read)
2110:     .qs     (sw_share1_output_3_qs)
2111:   );
2112: 
2113: 
2114:   // Subregister 4 of Multireg sw_share1_output
2115:   // R[sw_share1_output_4]: V(False)
2116:   prim_subreg #(
2117:     .DW      (32),
2118:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2119:     .RESVAL  (32'h0),
2120:     .Mubi    (1'b0)
2121:   ) u_sw_share1_output_4 (
2122:     .clk_i   (clk_i),
2123:     .rst_ni  (rst_ni),
2124: 
2125:     // from register interface
2126:     .we     (sw_share1_output_4_re),
2127:     .wd     (sw_share1_output_4_wd),
2128: 
2129:     // from internal hardware
2130:     .de     (hw2reg.sw_share1_output[4].de),
2131:     .d      (hw2reg.sw_share1_output[4].d),
2132: 
2133:     // to internal hardware
2134:     .qe     (),
2135:     .q      (),
2136:     .ds     (),
2137: 
2138:     // to register interface (read)
2139:     .qs     (sw_share1_output_4_qs)
2140:   );
2141: 
2142: 
2143:   // Subregister 5 of Multireg sw_share1_output
2144:   // R[sw_share1_output_5]: V(False)
2145:   prim_subreg #(
2146:     .DW      (32),
2147:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2148:     .RESVAL  (32'h0),
2149:     .Mubi    (1'b0)
2150:   ) u_sw_share1_output_5 (
2151:     .clk_i   (clk_i),
2152:     .rst_ni  (rst_ni),
2153: 
2154:     // from register interface
2155:     .we     (sw_share1_output_5_re),
2156:     .wd     (sw_share1_output_5_wd),
2157: 
2158:     // from internal hardware
2159:     .de     (hw2reg.sw_share1_output[5].de),
2160:     .d      (hw2reg.sw_share1_output[5].d),
2161: 
2162:     // to internal hardware
2163:     .qe     (),
2164:     .q      (),
2165:     .ds     (),
2166: 
2167:     // to register interface (read)
2168:     .qs     (sw_share1_output_5_qs)
2169:   );
2170: 
2171: 
2172:   // Subregister 6 of Multireg sw_share1_output
2173:   // R[sw_share1_output_6]: V(False)
2174:   prim_subreg #(
2175:     .DW      (32),
2176:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2177:     .RESVAL  (32'h0),
2178:     .Mubi    (1'b0)
2179:   ) u_sw_share1_output_6 (
2180:     .clk_i   (clk_i),
2181:     .rst_ni  (rst_ni),
2182: 
2183:     // from register interface
2184:     .we     (sw_share1_output_6_re),
2185:     .wd     (sw_share1_output_6_wd),
2186: 
2187:     // from internal hardware
2188:     .de     (hw2reg.sw_share1_output[6].de),
2189:     .d      (hw2reg.sw_share1_output[6].d),
2190: 
2191:     // to internal hardware
2192:     .qe     (),
2193:     .q      (),
2194:     .ds     (),
2195: 
2196:     // to register interface (read)
2197:     .qs     (sw_share1_output_6_qs)
2198:   );
2199: 
2200: 
2201:   // Subregister 7 of Multireg sw_share1_output
2202:   // R[sw_share1_output_7]: V(False)
2203:   prim_subreg #(
2204:     .DW      (32),
2205:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2206:     .RESVAL  (32'h0),
2207:     .Mubi    (1'b0)
2208:   ) u_sw_share1_output_7 (
2209:     .clk_i   (clk_i),
2210:     .rst_ni  (rst_ni),
2211: 
2212:     // from register interface
2213:     .we     (sw_share1_output_7_re),
2214:     .wd     (sw_share1_output_7_wd),
2215: 
2216:     // from internal hardware
2217:     .de     (hw2reg.sw_share1_output[7].de),
2218:     .d      (hw2reg.sw_share1_output[7].d),
2219: 
2220:     // to internal hardware
2221:     .qe     (),
2222:     .q      (),
2223:     .ds     (),
2224: 
2225:     // to register interface (read)
2226:     .qs     (sw_share1_output_7_qs)
2227:   );
2228: 
2229: 
2230:   // R[working_state]: V(False)
2231:   prim_subreg #(
2232:     .DW      (3),
2233:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2234:     .RESVAL  (3'h0),
2235:     .Mubi    (1'b0)
2236:   ) u_working_state (
2237:     .clk_i   (clk_i),
2238:     .rst_ni  (rst_ni),
2239: 
2240:     // from register interface
2241:     .we     (1'b0),
2242:     .wd     ('0),
2243: 
2244:     // from internal hardware
2245:     .de     (hw2reg.working_state.de),
2246:     .d      (hw2reg.working_state.d),
2247: 
2248:     // to internal hardware
2249:     .qe     (),
2250:     .q      (),
2251:     .ds     (),
2252: 
2253:     // to register interface (read)
2254:     .qs     (working_state_qs)
2255:   );
2256: 
2257: 
2258:   // R[op_status]: V(False)
2259:   prim_subreg #(
2260:     .DW      (2),
2261:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
2262:     .RESVAL  (2'h0),
2263:     .Mubi    (1'b0)
2264:   ) u_op_status (
2265:     .clk_i   (clk_i),
2266:     .rst_ni  (rst_ni),
2267: 
2268:     // from register interface
2269:     .we     (op_status_we),
2270:     .wd     (op_status_wd),
2271: 
2272:     // from internal hardware
2273:     .de     (hw2reg.op_status.de),
2274:     .d      (hw2reg.op_status.d),
2275: 
2276:     // to internal hardware
2277:     .qe     (),
2278:     .q      (),
2279:     .ds     (),
2280: 
2281:     // to register interface (read)
2282:     .qs     (op_status_qs)
2283:   );
2284: 
2285: 
2286:   // R[err_code]: V(False)
2287:   //   F[invalid_op]: 0:0
2288:   prim_subreg #(
2289:     .DW      (1),
2290:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
2291:     .RESVAL  (1'h0),
2292:     .Mubi    (1'b0)
2293:   ) u_err_code_invalid_op (
2294:     .clk_i   (clk_i),
2295:     .rst_ni  (rst_ni),
2296: 
2297:     // from register interface
2298:     .we     (err_code_we),
2299:     .wd     (err_code_invalid_op_wd),
2300: 
2301:     // from internal hardware
2302:     .de     (hw2reg.err_code.invalid_op.de),
2303:     .d      (hw2reg.err_code.invalid_op.d),
2304: 
2305:     // to internal hardware
2306:     .qe     (),
2307:     .q      (),
2308:     .ds     (),
2309: 
2310:     // to register interface (read)
2311:     .qs     (err_code_invalid_op_qs)
2312:   );
2313: 
2314:   //   F[invalid_kmac_input]: 1:1
2315:   prim_subreg #(
2316:     .DW      (1),
2317:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
2318:     .RESVAL  (1'h0),
2319:     .Mubi    (1'b0)
2320:   ) u_err_code_invalid_kmac_input (
2321:     .clk_i   (clk_i),
2322:     .rst_ni  (rst_ni),
2323: 
2324:     // from register interface
2325:     .we     (err_code_we),
2326:     .wd     (err_code_invalid_kmac_input_wd),
2327: 
2328:     // from internal hardware
2329:     .de     (hw2reg.err_code.invalid_kmac_input.de),
2330:     .d      (hw2reg.err_code.invalid_kmac_input.d),
2331: 
2332:     // to internal hardware
2333:     .qe     (),
2334:     .q      (),
2335:     .ds     (),
2336: 
2337:     // to register interface (read)
2338:     .qs     (err_code_invalid_kmac_input_qs)
2339:   );
2340: 
2341:   //   F[invalid_shadow_update]: 2:2
2342:   prim_subreg #(
2343:     .DW      (1),
2344:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
2345:     .RESVAL  (1'h0),
2346:     .Mubi    (1'b0)
2347:   ) u_err_code_invalid_shadow_update (
2348:     .clk_i   (clk_i),
2349:     .rst_ni  (rst_ni),
2350: 
2351:     // from register interface
2352:     .we     (err_code_we),
2353:     .wd     (err_code_invalid_shadow_update_wd),
2354: 
2355:     // from internal hardware
2356:     .de     (hw2reg.err_code.invalid_shadow_update.de),
2357:     .d      (hw2reg.err_code.invalid_shadow_update.d),
2358: 
2359:     // to internal hardware
2360:     .qe     (),
2361:     .q      (),
2362:     .ds     (),
2363: 
2364:     // to register interface (read)
2365:     .qs     (err_code_invalid_shadow_update_qs)
2366:   );
2367: 
2368: 
2369:   // R[fault_status]: V(False)
2370:   //   F[cmd]: 0:0
2371:   prim_subreg #(
2372:     .DW      (1),
2373:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2374:     .RESVAL  (1'h0),
2375:     .Mubi    (1'b0)
2376:   ) u_fault_status_cmd (
2377:     .clk_i   (clk_i),
2378:     .rst_ni  (rst_ni),
2379: 
2380:     // from register interface
2381:     .we     (1'b0),
2382:     .wd     ('0),
2383: 
2384:     // from internal hardware
2385:     .de     (hw2reg.fault_status.cmd.de),
2386:     .d      (hw2reg.fault_status.cmd.d),
2387: 
2388:     // to internal hardware
2389:     .qe     (),
2390:     .q      (reg2hw.fault_status.cmd.q),
2391:     .ds     (),
2392: 
2393:     // to register interface (read)
2394:     .qs     (fault_status_cmd_qs)
2395:   );
2396: 
2397:   //   F[kmac_fsm]: 1:1
2398:   prim_subreg #(
2399:     .DW      (1),
2400:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2401:     .RESVAL  (1'h0),
2402:     .Mubi    (1'b0)
2403:   ) u_fault_status_kmac_fsm (
2404:     .clk_i   (clk_i),
2405:     .rst_ni  (rst_ni),
2406: 
2407:     // from register interface
2408:     .we     (1'b0),
2409:     .wd     ('0),
2410: 
2411:     // from internal hardware
2412:     .de     (hw2reg.fault_status.kmac_fsm.de),
2413:     .d      (hw2reg.fault_status.kmac_fsm.d),
2414: 
2415:     // to internal hardware
2416:     .qe     (),
2417:     .q      (reg2hw.fault_status.kmac_fsm.q),
2418:     .ds     (),
2419: 
2420:     // to register interface (read)
2421:     .qs     (fault_status_kmac_fsm_qs)
2422:   );
2423: 
2424:   //   F[kmac_done]: 2:2
2425:   prim_subreg #(
2426:     .DW      (1),
2427:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2428:     .RESVAL  (1'h0),
2429:     .Mubi    (1'b0)
2430:   ) u_fault_status_kmac_done (
2431:     .clk_i   (clk_i),
2432:     .rst_ni  (rst_ni),
2433: 
2434:     // from register interface
2435:     .we     (1'b0),
2436:     .wd     ('0),
2437: 
2438:     // from internal hardware
2439:     .de     (hw2reg.fault_status.kmac_done.de),
2440:     .d      (hw2reg.fault_status.kmac_done.d),
2441: 
2442:     // to internal hardware
2443:     .qe     (),
2444:     .q      (reg2hw.fault_status.kmac_done.q),
2445:     .ds     (),
2446: 
2447:     // to register interface (read)
2448:     .qs     (fault_status_kmac_done_qs)
2449:   );
2450: 
2451:   //   F[kmac_op]: 3:3
2452:   prim_subreg #(
2453:     .DW      (1),
2454:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2455:     .RESVAL  (1'h0),
2456:     .Mubi    (1'b0)
2457:   ) u_fault_status_kmac_op (
2458:     .clk_i   (clk_i),
2459:     .rst_ni  (rst_ni),
2460: 
2461:     // from register interface
2462:     .we     (1'b0),
2463:     .wd     ('0),
2464: 
2465:     // from internal hardware
2466:     .de     (hw2reg.fault_status.kmac_op.de),
2467:     .d      (hw2reg.fault_status.kmac_op.d),
2468: 
2469:     // to internal hardware
2470:     .qe     (),
2471:     .q      (reg2hw.fault_status.kmac_op.q),
2472:     .ds     (),
2473: 
2474:     // to register interface (read)
2475:     .qs     (fault_status_kmac_op_qs)
2476:   );
2477: 
2478:   //   F[kmac_out]: 4:4
2479:   prim_subreg #(
2480:     .DW      (1),
2481:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2482:     .RESVAL  (1'h0),
2483:     .Mubi    (1'b0)
2484:   ) u_fault_status_kmac_out (
2485:     .clk_i   (clk_i),
2486:     .rst_ni  (rst_ni),
2487: 
2488:     // from register interface
2489:     .we     (1'b0),
2490:     .wd     ('0),
2491: 
2492:     // from internal hardware
2493:     .de     (hw2reg.fault_status.kmac_out.de),
2494:     .d      (hw2reg.fault_status.kmac_out.d),
2495: 
2496:     // to internal hardware
2497:     .qe     (),
2498:     .q      (reg2hw.fault_status.kmac_out.q),
2499:     .ds     (),
2500: 
2501:     // to register interface (read)
2502:     .qs     (fault_status_kmac_out_qs)
2503:   );
2504: 
2505:   //   F[regfile_intg]: 5:5
2506:   prim_subreg #(
2507:     .DW      (1),
2508:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2509:     .RESVAL  (1'h0),
2510:     .Mubi    (1'b0)
2511:   ) u_fault_status_regfile_intg (
2512:     .clk_i   (clk_i),
2513:     .rst_ni  (rst_ni),
2514: 
2515:     // from register interface
2516:     .we     (1'b0),
2517:     .wd     ('0),
2518: 
2519:     // from internal hardware
2520:     .de     (hw2reg.fault_status.regfile_intg.de),
2521:     .d      (hw2reg.fault_status.regfile_intg.d),
2522: 
2523:     // to internal hardware
2524:     .qe     (),
2525:     .q      (reg2hw.fault_status.regfile_intg.q),
2526:     .ds     (),
2527: 
2528:     // to register interface (read)
2529:     .qs     (fault_status_regfile_intg_qs)
2530:   );
2531: 
2532:   //   F[shadow]: 6:6
2533:   prim_subreg #(
2534:     .DW      (1),
2535:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2536:     .RESVAL  (1'h0),
2537:     .Mubi    (1'b0)
2538:   ) u_fault_status_shadow (
2539:     .clk_i   (clk_i),
2540:     .rst_ni  (rst_ni),
2541: 
2542:     // from register interface
2543:     .we     (1'b0),
2544:     .wd     ('0),
2545: 
2546:     // from internal hardware
2547:     .de     (hw2reg.fault_status.shadow.de),
2548:     .d      (hw2reg.fault_status.shadow.d),
2549: 
2550:     // to internal hardware
2551:     .qe     (),
2552:     .q      (reg2hw.fault_status.shadow.q),
2553:     .ds     (),
2554: 
2555:     // to register interface (read)
2556:     .qs     (fault_status_shadow_qs)
2557:   );
2558: 
2559:   //   F[ctrl_fsm_intg]: 7:7
2560:   prim_subreg #(
2561:     .DW      (1),
2562:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2563:     .RESVAL  (1'h0),
2564:     .Mubi    (1'b0)
2565:   ) u_fault_status_ctrl_fsm_intg (
2566:     .clk_i   (clk_i),
2567:     .rst_ni  (rst_ni),
2568: 
2569:     // from register interface
2570:     .we     (1'b0),
2571:     .wd     ('0),
2572: 
2573:     // from internal hardware
2574:     .de     (hw2reg.fault_status.ctrl_fsm_intg.de),
2575:     .d      (hw2reg.fault_status.ctrl_fsm_intg.d),
2576: 
2577:     // to internal hardware
2578:     .qe     (),
2579:     .q      (reg2hw.fault_status.ctrl_fsm_intg.q),
2580:     .ds     (),
2581: 
2582:     // to register interface (read)
2583:     .qs     (fault_status_ctrl_fsm_intg_qs)
2584:   );
2585: 
2586:   //   F[ctrl_fsm_chk]: 8:8
2587:   prim_subreg #(
2588:     .DW      (1),
2589:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2590:     .RESVAL  (1'h0),
2591:     .Mubi    (1'b0)
2592:   ) u_fault_status_ctrl_fsm_chk (
2593:     .clk_i   (clk_i),
2594:     .rst_ni  (rst_ni),
2595: 
2596:     // from register interface
2597:     .we     (1'b0),
2598:     .wd     ('0),
2599: 
2600:     // from internal hardware
2601:     .de     (hw2reg.fault_status.ctrl_fsm_chk.de),
2602:     .d      (hw2reg.fault_status.ctrl_fsm_chk.d),
2603: 
2604:     // to internal hardware
2605:     .qe     (),
2606:     .q      (reg2hw.fault_status.ctrl_fsm_chk.q),
2607:     .ds     (),
2608: 
2609:     // to register interface (read)
2610:     .qs     (fault_status_ctrl_fsm_chk_qs)
2611:   );
2612: 
2613:   //   F[ctrl_fsm_cnt]: 9:9
2614:   prim_subreg #(
2615:     .DW      (1),
2616:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2617:     .RESVAL  (1'h0),
2618:     .Mubi    (1'b0)
2619:   ) u_fault_status_ctrl_fsm_cnt (
2620:     .clk_i   (clk_i),
2621:     .rst_ni  (rst_ni),
2622: 
2623:     // from register interface
2624:     .we     (1'b0),
2625:     .wd     ('0),
2626: 
2627:     // from internal hardware
2628:     .de     (hw2reg.fault_status.ctrl_fsm_cnt.de),
2629:     .d      (hw2reg.fault_status.ctrl_fsm_cnt.d),
2630: 
2631:     // to internal hardware
2632:     .qe     (),
2633:     .q      (reg2hw.fault_status.ctrl_fsm_cnt.q),
2634:     .ds     (),
2635: 
2636:     // to register interface (read)
2637:     .qs     (fault_status_ctrl_fsm_cnt_qs)
2638:   );
2639: 
2640:   //   F[reseed_cnt]: 10:10
2641:   prim_subreg #(
2642:     .DW      (1),
2643:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2644:     .RESVAL  (1'h0),
2645:     .Mubi    (1'b0)
2646:   ) u_fault_status_reseed_cnt (
2647:     .clk_i   (clk_i),
2648:     .rst_ni  (rst_ni),
2649: 
2650:     // from register interface
2651:     .we     (1'b0),
2652:     .wd     ('0),
2653: 
2654:     // from internal hardware
2655:     .de     (hw2reg.fault_status.reseed_cnt.de),
2656:     .d      (hw2reg.fault_status.reseed_cnt.d),
2657: 
2658:     // to internal hardware
2659:     .qe     (),
2660:     .q      (reg2hw.fault_status.reseed_cnt.q),
2661:     .ds     (),
2662: 
2663:     // to register interface (read)
2664:     .qs     (fault_status_reseed_cnt_qs)
2665:   );
2666: 
2667:   //   F[side_ctrl_fsm]: 11:11
2668:   prim_subreg #(
2669:     .DW      (1),
2670:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2671:     .RESVAL  (1'h0),
2672:     .Mubi    (1'b0)
2673:   ) u_fault_status_side_ctrl_fsm (
2674:     .clk_i   (clk_i),
2675:     .rst_ni  (rst_ni),
2676: 
2677:     // from register interface
2678:     .we     (1'b0),
2679:     .wd     ('0),
2680: 
2681:     // from internal hardware
2682:     .de     (hw2reg.fault_status.side_ctrl_fsm.de),
2683:     .d      (hw2reg.fault_status.side_ctrl_fsm.d),
2684: 
2685:     // to internal hardware
2686:     .qe     (),
2687:     .q      (reg2hw.fault_status.side_ctrl_fsm.q),
2688:     .ds     (),
2689: 
2690:     // to register interface (read)
2691:     .qs     (fault_status_side_ctrl_fsm_qs)
2692:   );
2693: 
2694:   //   F[side_ctrl_sel]: 12:12
2695:   prim_subreg #(
2696:     .DW      (1),
2697:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2698:     .RESVAL  (1'h0),
2699:     .Mubi    (1'b0)
2700:   ) u_fault_status_side_ctrl_sel (
2701:     .clk_i   (clk_i),
2702:     .rst_ni  (rst_ni),
2703: 
2704:     // from register interface
2705:     .we     (1'b0),
2706:     .wd     ('0),
2707: 
2708:     // from internal hardware
2709:     .de     (hw2reg.fault_status.side_ctrl_sel.de),
2710:     .d      (hw2reg.fault_status.side_ctrl_sel.d),
2711: 
2712:     // to internal hardware
2713:     .qe     (),
2714:     .q      (reg2hw.fault_status.side_ctrl_sel.q),
2715:     .ds     (),
2716: 
2717:     // to register interface (read)
2718:     .qs     (fault_status_side_ctrl_sel_qs)
2719:   );
2720: 
2721:   //   F[key_ecc]: 13:13
2722:   prim_subreg #(
2723:     .DW      (1),
2724:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2725:     .RESVAL  (1'h0),
2726:     .Mubi    (1'b0)
2727:   ) u_fault_status_key_ecc (
2728:     .clk_i   (clk_i),
2729:     .rst_ni  (rst_ni),
2730: 
2731:     // from register interface
2732:     .we     (1'b0),
2733:     .wd     ('0),
2734: 
2735:     // from internal hardware
2736:     .de     (hw2reg.fault_status.key_ecc.de),
2737:     .d      (hw2reg.fault_status.key_ecc.d),
2738: 
2739:     // to internal hardware
2740:     .qe     (),
2741:     .q      (reg2hw.fault_status.key_ecc.q),
2742:     .ds     (),
2743: 
2744:     // to register interface (read)
2745:     .qs     (fault_status_key_ecc_qs)
2746:   );
2747: 
2748: 
2749:   // R[debug]: V(False)
2750:   //   F[invalid_creator_seed]: 0:0
2751:   prim_subreg #(
2752:     .DW      (1),
2753:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2754:     .RESVAL  (1'h0),
2755:     .Mubi    (1'b0)
2756:   ) u_debug_invalid_creator_seed (
2757:     .clk_i   (clk_i),
2758:     .rst_ni  (rst_ni),
2759: 
2760:     // from register interface
2761:     .we     (debug_we),
2762:     .wd     (debug_invalid_creator_seed_wd),
2763: 
2764:     // from internal hardware
2765:     .de     (hw2reg.debug.invalid_creator_seed.de),
2766:     .d      (hw2reg.debug.invalid_creator_seed.d),
2767: 
2768:     // to internal hardware
2769:     .qe     (),
2770:     .q      (),
2771:     .ds     (),
2772: 
2773:     // to register interface (read)
2774:     .qs     (debug_invalid_creator_seed_qs)
2775:   );
2776: 
2777:   //   F[invalid_owner_seed]: 1:1
2778:   prim_subreg #(
2779:     .DW      (1),
2780:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2781:     .RESVAL  (1'h0),
2782:     .Mubi    (1'b0)
2783:   ) u_debug_invalid_owner_seed (
2784:     .clk_i   (clk_i),
2785:     .rst_ni  (rst_ni),
2786: 
2787:     // from register interface
2788:     .we     (debug_we),
2789:     .wd     (debug_invalid_owner_seed_wd),
2790: 
2791:     // from internal hardware
2792:     .de     (hw2reg.debug.invalid_owner_seed.de),
2793:     .d      (hw2reg.debug.invalid_owner_seed.d),
2794: 
2795:     // to internal hardware
2796:     .qe     (),
2797:     .q      (),
2798:     .ds     (),
2799: 
2800:     // to register interface (read)
2801:     .qs     (debug_invalid_owner_seed_qs)
2802:   );
2803: 
2804:   //   F[invalid_dev_id]: 2:2
2805:   prim_subreg #(
2806:     .DW      (1),
2807:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2808:     .RESVAL  (1'h0),
2809:     .Mubi    (1'b0)
2810:   ) u_debug_invalid_dev_id (
2811:     .clk_i   (clk_i),
2812:     .rst_ni  (rst_ni),
2813: 
2814:     // from register interface
2815:     .we     (debug_we),
2816:     .wd     (debug_invalid_dev_id_wd),
2817: 
2818:     // from internal hardware
2819:     .de     (hw2reg.debug.invalid_dev_id.de),
2820:     .d      (hw2reg.debug.invalid_dev_id.d),
2821: 
2822:     // to internal hardware
2823:     .qe     (),
2824:     .q      (),
2825:     .ds     (),
2826: 
2827:     // to register interface (read)
2828:     .qs     (debug_invalid_dev_id_qs)
2829:   );
2830: 
2831:   //   F[invalid_health_state]: 3:3
2832:   prim_subreg #(
2833:     .DW      (1),
2834:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2835:     .RESVAL  (1'h0),
2836:     .Mubi    (1'b0)
2837:   ) u_debug_invalid_health_state (
2838:     .clk_i   (clk_i),
2839:     .rst_ni  (rst_ni),
2840: 
2841:     // from register interface
2842:     .we     (debug_we),
2843:     .wd     (debug_invalid_health_state_wd),
2844: 
2845:     // from internal hardware
2846:     .de     (hw2reg.debug.invalid_health_state.de),
2847:     .d      (hw2reg.debug.invalid_health_state.d),
2848: 
2849:     // to internal hardware
2850:     .qe     (),
2851:     .q      (),
2852:     .ds     (),
2853: 
2854:     // to register interface (read)
2855:     .qs     (debug_invalid_health_state_qs)
2856:   );
2857: 
2858:   //   F[invalid_key_version]: 4:4
2859:   prim_subreg #(
2860:     .DW      (1),
2861:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2862:     .RESVAL  (1'h0),
2863:     .Mubi    (1'b0)
2864:   ) u_debug_invalid_key_version (
2865:     .clk_i   (clk_i),
2866:     .rst_ni  (rst_ni),
2867: 
2868:     // from register interface
2869:     .we     (debug_we),
2870:     .wd     (debug_invalid_key_version_wd),
2871: 
2872:     // from internal hardware
2873:     .de     (hw2reg.debug.invalid_key_version.de),
2874:     .d      (hw2reg.debug.invalid_key_version.d),
2875: 
2876:     // to internal hardware
2877:     .qe     (),
2878:     .q      (),
2879:     .ds     (),
2880: 
2881:     // to register interface (read)
2882:     .qs     (debug_invalid_key_version_qs)
2883:   );
2884: 
2885:   //   F[invalid_key]: 5:5
2886:   prim_subreg #(
2887:     .DW      (1),
2888:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2889:     .RESVAL  (1'h0),
2890:     .Mubi    (1'b0)
2891:   ) u_debug_invalid_key (
2892:     .clk_i   (clk_i),
2893:     .rst_ni  (rst_ni),
2894: 
2895:     // from register interface
2896:     .we     (debug_we),
2897:     .wd     (debug_invalid_key_wd),
2898: 
2899:     // from internal hardware
2900:     .de     (hw2reg.debug.invalid_key.de),
2901:     .d      (hw2reg.debug.invalid_key.d),
2902: 
2903:     // to internal hardware
2904:     .qe     (),
2905:     .q      (),
2906:     .ds     (),
2907: 
2908:     // to register interface (read)
2909:     .qs     (debug_invalid_key_qs)
2910:   );
2911: 
2912:   //   F[invalid_digest]: 6:6
2913:   prim_subreg #(
2914:     .DW      (1),
2915:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2916:     .RESVAL  (1'h0),
2917:     .Mubi    (1'b0)
2918:   ) u_debug_invalid_digest (
2919:     .clk_i   (clk_i),
2920:     .rst_ni  (rst_ni),
2921: 
2922:     // from register interface
2923:     .we     (debug_we),
2924:     .wd     (debug_invalid_digest_wd),
2925: 
2926:     // from internal hardware
2927:     .de     (hw2reg.debug.invalid_digest.de),
2928:     .d      (hw2reg.debug.invalid_digest.d),
2929: 
2930:     // to internal hardware
2931:     .qe     (),
2932:     .q      (),
2933:     .ds     (),
2934: 
2935:     // to register interface (read)
2936:     .qs     (debug_invalid_digest_qs)
2937:   );
2938: 
2939: 
2940: 
2941:   logic [62:0] addr_hit;
2942:   always_comb begin
2943:     addr_hit = '0;
2944:     addr_hit[ 0] = (reg_addr == KEYMGR_INTR_STATE_OFFSET);
2945:     addr_hit[ 1] = (reg_addr == KEYMGR_INTR_ENABLE_OFFSET);
2946:     addr_hit[ 2] = (reg_addr == KEYMGR_INTR_TEST_OFFSET);
2947:     addr_hit[ 3] = (reg_addr == KEYMGR_ALERT_TEST_OFFSET);
2948:     addr_hit[ 4] = (reg_addr == KEYMGR_CFG_REGWEN_OFFSET);
2949:     addr_hit[ 5] = (reg_addr == KEYMGR_START_OFFSET);
2950:     addr_hit[ 6] = (reg_addr == KEYMGR_CONTROL_SHADOWED_OFFSET);
2951:     addr_hit[ 7] = (reg_addr == KEYMGR_SIDELOAD_CLEAR_OFFSET);
2952:     addr_hit[ 8] = (reg_addr == KEYMGR_RESEED_INTERVAL_REGWEN_OFFSET);
2953:     addr_hit[ 9] = (reg_addr == KEYMGR_RESEED_INTERVAL_SHADOWED_OFFSET);
2954:     addr_hit[10] = (reg_addr == KEYMGR_SW_BINDING_REGWEN_OFFSET);
2955:     addr_hit[11] = (reg_addr == KEYMGR_SEALING_SW_BINDING_0_OFFSET);
2956:     addr_hit[12] = (reg_addr == KEYMGR_SEALING_SW_BINDING_1_OFFSET);
2957:     addr_hit[13] = (reg_addr == KEYMGR_SEALING_SW_BINDING_2_OFFSET);
2958:     addr_hit[14] = (reg_addr == KEYMGR_SEALING_SW_BINDING_3_OFFSET);
2959:     addr_hit[15] = (reg_addr == KEYMGR_SEALING_SW_BINDING_4_OFFSET);
2960:     addr_hit[16] = (reg_addr == KEYMGR_SEALING_SW_BINDING_5_OFFSET);
2961:     addr_hit[17] = (reg_addr == KEYMGR_SEALING_SW_BINDING_6_OFFSET);
2962:     addr_hit[18] = (reg_addr == KEYMGR_SEALING_SW_BINDING_7_OFFSET);
2963:     addr_hit[19] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_0_OFFSET);
2964:     addr_hit[20] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_1_OFFSET);
2965:     addr_hit[21] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_2_OFFSET);
2966:     addr_hit[22] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_3_OFFSET);
2967:     addr_hit[23] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_4_OFFSET);
2968:     addr_hit[24] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_5_OFFSET);
2969:     addr_hit[25] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_6_OFFSET);
2970:     addr_hit[26] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_7_OFFSET);
2971:     addr_hit[27] = (reg_addr == KEYMGR_SALT_0_OFFSET);
2972:     addr_hit[28] = (reg_addr == KEYMGR_SALT_1_OFFSET);
2973:     addr_hit[29] = (reg_addr == KEYMGR_SALT_2_OFFSET);
2974:     addr_hit[30] = (reg_addr == KEYMGR_SALT_3_OFFSET);
2975:     addr_hit[31] = (reg_addr == KEYMGR_SALT_4_OFFSET);
2976:     addr_hit[32] = (reg_addr == KEYMGR_SALT_5_OFFSET);
2977:     addr_hit[33] = (reg_addr == KEYMGR_SALT_6_OFFSET);
2978:     addr_hit[34] = (reg_addr == KEYMGR_SALT_7_OFFSET);
2979:     addr_hit[35] = (reg_addr == KEYMGR_KEY_VERSION_OFFSET);
2980:     addr_hit[36] = (reg_addr == KEYMGR_MAX_CREATOR_KEY_VER_REGWEN_OFFSET);
2981:     addr_hit[37] = (reg_addr == KEYMGR_MAX_CREATOR_KEY_VER_SHADOWED_OFFSET);
2982:     addr_hit[38] = (reg_addr == KEYMGR_MAX_OWNER_INT_KEY_VER_REGWEN_OFFSET);
2983:     addr_hit[39] = (reg_addr == KEYMGR_MAX_OWNER_INT_KEY_VER_SHADOWED_OFFSET);
2984:     addr_hit[40] = (reg_addr == KEYMGR_MAX_OWNER_KEY_VER_REGWEN_OFFSET);
2985:     addr_hit[41] = (reg_addr == KEYMGR_MAX_OWNER_KEY_VER_SHADOWED_OFFSET);
2986:     addr_hit[42] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_0_OFFSET);
2987:     addr_hit[43] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_1_OFFSET);
2988:     addr_hit[44] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_2_OFFSET);
2989:     addr_hit[45] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_3_OFFSET);
2990:     addr_hit[46] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_4_OFFSET);
2991:     addr_hit[47] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_5_OFFSET);
2992:     addr_hit[48] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_6_OFFSET);
2993:     addr_hit[49] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_7_OFFSET);
2994:     addr_hit[50] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_0_OFFSET);
2995:     addr_hit[51] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_1_OFFSET);
2996:     addr_hit[52] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_2_OFFSET);
2997:     addr_hit[53] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_3_OFFSET);
2998:     addr_hit[54] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_4_OFFSET);
2999:     addr_hit[55] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_5_OFFSET);
3000:     addr_hit[56] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_6_OFFSET);
3001:     addr_hit[57] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_7_OFFSET);
3002:     addr_hit[58] = (reg_addr == KEYMGR_WORKING_STATE_OFFSET);
3003:     addr_hit[59] = (reg_addr == KEYMGR_OP_STATUS_OFFSET);
3004:     addr_hit[60] = (reg_addr == KEYMGR_ERR_CODE_OFFSET);
3005:     addr_hit[61] = (reg_addr == KEYMGR_FAULT_STATUS_OFFSET);
3006:     addr_hit[62] = (reg_addr == KEYMGR_DEBUG_OFFSET);
3007:   end
3008: 
3009:   assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;
3010: 
3011:   // Check sub-word write is permitted
3012:   always_comb begin
3013:     wr_err = (reg_we &
3014:               ((addr_hit[ 0] & (|(KEYMGR_PERMIT[ 0] & ~reg_be))) |
3015:                (addr_hit[ 1] & (|(KEYMGR_PERMIT[ 1] & ~reg_be))) |
3016:                (addr_hit[ 2] & (|(KEYMGR_PERMIT[ 2] & ~reg_be))) |
3017:                (addr_hit[ 3] & (|(KEYMGR_PERMIT[ 3] & ~reg_be))) |
3018:                (addr_hit[ 4] & (|(KEYMGR_PERMIT[ 4] & ~reg_be))) |
3019:                (addr_hit[ 5] & (|(KEYMGR_PERMIT[ 5] & ~reg_be))) |
3020:                (addr_hit[ 6] & (|(KEYMGR_PERMIT[ 6] & ~reg_be))) |
3021:                (addr_hit[ 7] & (|(KEYMGR_PERMIT[ 7] & ~reg_be))) |
3022:                (addr_hit[ 8] & (|(KEYMGR_PERMIT[ 8] & ~reg_be))) |
3023:                (addr_hit[ 9] & (|(KEYMGR_PERMIT[ 9] & ~reg_be))) |
3024:                (addr_hit[10] & (|(KEYMGR_PERMIT[10] & ~reg_be))) |
3025:                (addr_hit[11] & (|(KEYMGR_PERMIT[11] & ~reg_be))) |
3026:                (addr_hit[12] & (|(KEYMGR_PERMIT[12] & ~reg_be))) |
3027:                (addr_hit[13] & (|(KEYMGR_PERMIT[13] & ~reg_be))) |
3028:                (addr_hit[14] & (|(KEYMGR_PERMIT[14] & ~reg_be))) |
3029:                (addr_hit[15] & (|(KEYMGR_PERMIT[15] & ~reg_be))) |
3030:                (addr_hit[16] & (|(KEYMGR_PERMIT[16] & ~reg_be))) |
3031:                (addr_hit[17] & (|(KEYMGR_PERMIT[17] & ~reg_be))) |
3032:                (addr_hit[18] & (|(KEYMGR_PERMIT[18] & ~reg_be))) |
3033:                (addr_hit[19] & (|(KEYMGR_PERMIT[19] & ~reg_be))) |
3034:                (addr_hit[20] & (|(KEYMGR_PERMIT[20] & ~reg_be))) |
3035:                (addr_hit[21] & (|(KEYMGR_PERMIT[21] & ~reg_be))) |
3036:                (addr_hit[22] & (|(KEYMGR_PERMIT[22] & ~reg_be))) |
3037:                (addr_hit[23] & (|(KEYMGR_PERMIT[23] & ~reg_be))) |
3038:                (addr_hit[24] & (|(KEYMGR_PERMIT[24] & ~reg_be))) |
3039:                (addr_hit[25] & (|(KEYMGR_PERMIT[25] & ~reg_be))) |
3040:                (addr_hit[26] & (|(KEYMGR_PERMIT[26] & ~reg_be))) |
3041:                (addr_hit[27] & (|(KEYMGR_PERMIT[27] & ~reg_be))) |
3042:                (addr_hit[28] & (|(KEYMGR_PERMIT[28] & ~reg_be))) |
3043:                (addr_hit[29] & (|(KEYMGR_PERMIT[29] & ~reg_be))) |
3044:                (addr_hit[30] & (|(KEYMGR_PERMIT[30] & ~reg_be))) |
3045:                (addr_hit[31] & (|(KEYMGR_PERMIT[31] & ~reg_be))) |
3046:                (addr_hit[32] & (|(KEYMGR_PERMIT[32] & ~reg_be))) |
3047:                (addr_hit[33] & (|(KEYMGR_PERMIT[33] & ~reg_be))) |
3048:                (addr_hit[34] & (|(KEYMGR_PERMIT[34] & ~reg_be))) |
3049:                (addr_hit[35] & (|(KEYMGR_PERMIT[35] & ~reg_be))) |
3050:                (addr_hit[36] & (|(KEYMGR_PERMIT[36] & ~reg_be))) |
3051:                (addr_hit[37] & (|(KEYMGR_PERMIT[37] & ~reg_be))) |
3052:                (addr_hit[38] & (|(KEYMGR_PERMIT[38] & ~reg_be))) |
3053:                (addr_hit[39] & (|(KEYMGR_PERMIT[39] & ~reg_be))) |
3054:                (addr_hit[40] & (|(KEYMGR_PERMIT[40] & ~reg_be))) |
3055:                (addr_hit[41] & (|(KEYMGR_PERMIT[41] & ~reg_be))) |
3056:                (addr_hit[42] & (|(KEYMGR_PERMIT[42] & ~reg_be))) |
3057:                (addr_hit[43] & (|(KEYMGR_PERMIT[43] & ~reg_be))) |
3058:                (addr_hit[44] & (|(KEYMGR_PERMIT[44] & ~reg_be))) |
3059:                (addr_hit[45] & (|(KEYMGR_PERMIT[45] & ~reg_be))) |
3060:                (addr_hit[46] & (|(KEYMGR_PERMIT[46] & ~reg_be))) |
3061:                (addr_hit[47] & (|(KEYMGR_PERMIT[47] & ~reg_be))) |
3062:                (addr_hit[48] & (|(KEYMGR_PERMIT[48] & ~reg_be))) |
3063:                (addr_hit[49] & (|(KEYMGR_PERMIT[49] & ~reg_be))) |
3064:                (addr_hit[50] & (|(KEYMGR_PERMIT[50] & ~reg_be))) |
3065:                (addr_hit[51] & (|(KEYMGR_PERMIT[51] & ~reg_be))) |
3066:                (addr_hit[52] & (|(KEYMGR_PERMIT[52] & ~reg_be))) |
3067:                (addr_hit[53] & (|(KEYMGR_PERMIT[53] & ~reg_be))) |
3068:                (addr_hit[54] & (|(KEYMGR_PERMIT[54] & ~reg_be))) |
3069:                (addr_hit[55] & (|(KEYMGR_PERMIT[55] & ~reg_be))) |
3070:                (addr_hit[56] & (|(KEYMGR_PERMIT[56] & ~reg_be))) |
3071:                (addr_hit[57] & (|(KEYMGR_PERMIT[57] & ~reg_be))) |
3072:                (addr_hit[58] & (|(KEYMGR_PERMIT[58] & ~reg_be))) |
3073:                (addr_hit[59] & (|(KEYMGR_PERMIT[59] & ~reg_be))) |
3074:                (addr_hit[60] & (|(KEYMGR_PERMIT[60] & ~reg_be))) |
3075:                (addr_hit[61] & (|(KEYMGR_PERMIT[61] & ~reg_be))) |
3076:                (addr_hit[62] & (|(KEYMGR_PERMIT[62] & ~reg_be)))));
3077:   end
3078: 
3079:   // Generate write-enables
3080:   assign intr_state_we = addr_hit[0] & reg_we & !reg_error;
3081: 
3082:   assign intr_state_wd = reg_wdata[0];
3083:   assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;
3084: 
3085:   assign intr_enable_wd = reg_wdata[0];
3086:   assign intr_test_we = addr_hit[2] & reg_we & !reg_error;
3087: 
3088:   assign intr_test_wd = reg_wdata[0];
3089:   assign alert_test_we = addr_hit[3] & reg_we & !reg_error;
3090: 
3091:   assign alert_test_recov_operation_err_wd = reg_wdata[0];
3092: 
3093:   assign alert_test_fatal_fault_err_wd = reg_wdata[1];
3094:   assign cfg_regwen_re = addr_hit[4] & reg_re & !reg_error;
3095:   assign start_we = addr_hit[5] & reg_we & !reg_error;
3096: 
3097:   assign start_wd = reg_wdata[0];
3098:   assign control_shadowed_re = addr_hit[6] & reg_re & !reg_error;
3099:   assign control_shadowed_we = addr_hit[6] & reg_we & !reg_error;
3100: 
3101:   assign control_shadowed_operation_wd = reg_wdata[6:4];
3102: 
3103:   assign control_shadowed_cdi_sel_wd = reg_wdata[7];
3104: 
3105:   assign control_shadowed_dest_sel_wd = reg_wdata[13:12];
3106:   assign sideload_clear_we = addr_hit[7] & reg_we & !reg_error;
3107: 
3108:   assign sideload_clear_wd = reg_wdata[2:0];
3109:   assign reseed_interval_regwen_we = addr_hit[8] & reg_we & !reg_error;
3110: 
3111:   assign reseed_interval_regwen_wd = reg_wdata[0];
3112:   assign reseed_interval_shadowed_re = addr_hit[9] & reg_re & !reg_error;
3113:   assign reseed_interval_shadowed_we = addr_hit[9] & reg_we & !reg_error;
3114: 
3115:   assign reseed_interval_shadowed_wd = reg_wdata[15:0];
3116:   assign sw_binding_regwen_re = addr_hit[10] & reg_re & !reg_error;
3117:   assign sw_binding_regwen_we = addr_hit[10] & reg_we & !reg_error;
3118: 
3119:   assign sw_binding_regwen_wd = reg_wdata[0];
3120:   assign sealing_sw_binding_0_we = addr_hit[11] & reg_we & !reg_error;
3121: 
3122:   assign sealing_sw_binding_0_wd = reg_wdata[31:0];
3123:   assign sealing_sw_binding_1_we = addr_hit[12] & reg_we & !reg_error;
3124: 
3125:   assign sealing_sw_binding_1_wd = reg_wdata[31:0];
3126:   assign sealing_sw_binding_2_we = addr_hit[13] & reg_we & !reg_error;
3127: 
3128:   assign sealing_sw_binding_2_wd = reg_wdata[31:0];
3129:   assign sealing_sw_binding_3_we = addr_hit[14] & reg_we & !reg_error;
3130: 
3131:   assign sealing_sw_binding_3_wd = reg_wdata[31:0];
3132:   assign sealing_sw_binding_4_we = addr_hit[15] & reg_we & !reg_error;
3133: 
3134:   assign sealing_sw_binding_4_wd = reg_wdata[31:0];
3135:   assign sealing_sw_binding_5_we = addr_hit[16] & reg_we & !reg_error;
3136: 
3137:   assign sealing_sw_binding_5_wd = reg_wdata[31:0];
3138:   assign sealing_sw_binding_6_we = addr_hit[17] & reg_we & !reg_error;
3139: 
3140:   assign sealing_sw_binding_6_wd = reg_wdata[31:0];
3141:   assign sealing_sw_binding_7_we = addr_hit[18] & reg_we & !reg_error;
3142: 
3143:   assign sealing_sw_binding_7_wd = reg_wdata[31:0];
3144:   assign attest_sw_binding_0_we = addr_hit[19] & reg_we & !reg_error;
3145: 
3146:   assign attest_sw_binding_0_wd = reg_wdata[31:0];
3147:   assign attest_sw_binding_1_we = addr_hit[20] & reg_we & !reg_error;
3148: 
3149:   assign attest_sw_binding_1_wd = reg_wdata[31:0];
3150:   assign attest_sw_binding_2_we = addr_hit[21] & reg_we & !reg_error;
3151: 
3152:   assign attest_sw_binding_2_wd = reg_wdata[31:0];
3153:   assign attest_sw_binding_3_we = addr_hit[22] & reg_we & !reg_error;
3154: 
3155:   assign attest_sw_binding_3_wd = reg_wdata[31:0];
3156:   assign attest_sw_binding_4_we = addr_hit[23] & reg_we & !reg_error;
3157: 
3158:   assign attest_sw_binding_4_wd = reg_wdata[31:0];
3159:   assign attest_sw_binding_5_we = addr_hit[24] & reg_we & !reg_error;
3160: 
3161:   assign attest_sw_binding_5_wd = reg_wdata[31:0];
3162:   assign attest_sw_binding_6_we = addr_hit[25] & reg_we & !reg_error;
3163: 
3164:   assign attest_sw_binding_6_wd = reg_wdata[31:0];
3165:   assign attest_sw_binding_7_we = addr_hit[26] & reg_we & !reg_error;
3166: 
3167:   assign attest_sw_binding_7_wd = reg_wdata[31:0];
3168:   assign salt_0_we = addr_hit[27] & reg_we & !reg_error;
3169: 
3170:   assign salt_0_wd = reg_wdata[31:0];
3171:   assign salt_1_we = addr_hit[28] & reg_we & !reg_error;
3172: 
3173:   assign salt_1_wd = reg_wdata[31:0];
3174:   assign salt_2_we = addr_hit[29] & reg_we & !reg_error;
3175: 
3176:   assign salt_2_wd = reg_wdata[31:0];
3177:   assign salt_3_we = addr_hit[30] & reg_we & !reg_error;
3178: 
3179:   assign salt_3_wd = reg_wdata[31:0];
3180:   assign salt_4_we = addr_hit[31] & reg_we & !reg_error;
3181: 
3182:   assign salt_4_wd = reg_wdata[31:0];
3183:   assign salt_5_we = addr_hit[32] & reg_we & !reg_error;
3184: 
3185:   assign salt_5_wd = reg_wdata[31:0];
3186:   assign salt_6_we = addr_hit[33] & reg_we & !reg_error;
3187: 
3188:   assign salt_6_wd = reg_wdata[31:0];
3189:   assign salt_7_we = addr_hit[34] & reg_we & !reg_error;
3190: 
3191:   assign salt_7_wd = reg_wdata[31:0];
3192:   assign key_version_we = addr_hit[35] & reg_we & !reg_error;
3193: 
3194:   assign key_version_wd = reg_wdata[31:0];
3195:   assign max_creator_key_ver_regwen_we = addr_hit[36] & reg_we & !reg_error;
3196: 
3197:   assign max_creator_key_ver_regwen_wd = reg_wdata[0];
3198:   assign max_creator_key_ver_shadowed_re = addr_hit[37] & reg_re & !reg_error;
3199:   assign max_creator_key_ver_shadowed_we = addr_hit[37] & reg_we & !reg_error;
3200: 
3201:   assign max_creator_key_ver_shadowed_wd = reg_wdata[31:0];
3202:   assign max_owner_int_key_ver_regwen_we = addr_hit[38] & reg_we & !reg_error;
3203: 
3204:   assign max_owner_int_key_ver_regwen_wd = reg_wdata[0];
3205:   assign max_owner_int_key_ver_shadowed_re = addr_hit[39] & reg_re & !reg_error;
3206:   assign max_owner_int_key_ver_shadowed_we = addr_hit[39] & reg_we & !reg_error;
3207: 
3208:   assign max_owner_int_key_ver_shadowed_wd = reg_wdata[31:0];
3209:   assign max_owner_key_ver_regwen_we = addr_hit[40] & reg_we & !reg_error;
3210: 
3211:   assign max_owner_key_ver_regwen_wd = reg_wdata[0];
3212:   assign max_owner_key_ver_shadowed_re = addr_hit[41] & reg_re & !reg_error;
3213:   assign max_owner_key_ver_shadowed_we = addr_hit[41] & reg_we & !reg_error;
3214: 
3215:   assign max_owner_key_ver_shadowed_wd = reg_wdata[31:0];
3216:   assign sw_share0_output_0_re = addr_hit[42] & reg_re & !reg_error;
3217: 
3218:   assign sw_share0_output_0_wd = '1;
3219:   assign sw_share0_output_1_re = addr_hit[43] & reg_re & !reg_error;
3220: 
3221:   assign sw_share0_output_1_wd = '1;
3222:   assign sw_share0_output_2_re = addr_hit[44] & reg_re & !reg_error;
3223: 
3224:   assign sw_share0_output_2_wd = '1;
3225:   assign sw_share0_output_3_re = addr_hit[45] & reg_re & !reg_error;
3226: 
3227:   assign sw_share0_output_3_wd = '1;
3228:   assign sw_share0_output_4_re = addr_hit[46] & reg_re & !reg_error;
3229: 
3230:   assign sw_share0_output_4_wd = '1;
3231:   assign sw_share0_output_5_re = addr_hit[47] & reg_re & !reg_error;
3232: 
3233:   assign sw_share0_output_5_wd = '1;
3234:   assign sw_share0_output_6_re = addr_hit[48] & reg_re & !reg_error;
3235: 
3236:   assign sw_share0_output_6_wd = '1;
3237:   assign sw_share0_output_7_re = addr_hit[49] & reg_re & !reg_error;
3238: 
3239:   assign sw_share0_output_7_wd = '1;
3240:   assign sw_share1_output_0_re = addr_hit[50] & reg_re & !reg_error;
3241: 
3242:   assign sw_share1_output_0_wd = '1;
3243:   assign sw_share1_output_1_re = addr_hit[51] & reg_re & !reg_error;
3244: 
3245:   assign sw_share1_output_1_wd = '1;
3246:   assign sw_share1_output_2_re = addr_hit[52] & reg_re & !reg_error;
3247: 
3248:   assign sw_share1_output_2_wd = '1;
3249:   assign sw_share1_output_3_re = addr_hit[53] & reg_re & !reg_error;
3250: 
3251:   assign sw_share1_output_3_wd = '1;
3252:   assign sw_share1_output_4_re = addr_hit[54] & reg_re & !reg_error;
3253: 
3254:   assign sw_share1_output_4_wd = '1;
3255:   assign sw_share1_output_5_re = addr_hit[55] & reg_re & !reg_error;
3256: 
3257:   assign sw_share1_output_5_wd = '1;
3258:   assign sw_share1_output_6_re = addr_hit[56] & reg_re & !reg_error;
3259: 
3260:   assign sw_share1_output_6_wd = '1;
3261:   assign sw_share1_output_7_re = addr_hit[57] & reg_re & !reg_error;
3262: 
3263:   assign sw_share1_output_7_wd = '1;
3264:   assign op_status_we = addr_hit[59] & reg_we & !reg_error;
3265: 
3266:   assign op_status_wd = reg_wdata[1:0];
3267:   assign err_code_we = addr_hit[60] & reg_we & !reg_error;
3268: 
3269:   assign err_code_invalid_op_wd = reg_wdata[0];
3270: 
3271:   assign err_code_invalid_kmac_input_wd = reg_wdata[1];
3272: 
3273:   assign err_code_invalid_shadow_update_wd = reg_wdata[2];
3274:   assign debug_we = addr_hit[62] & reg_we & !reg_error;
3275: 
3276:   assign debug_invalid_creator_seed_wd = reg_wdata[0];
3277: 
3278:   assign debug_invalid_owner_seed_wd = reg_wdata[1];
3279: 
3280:   assign debug_invalid_dev_id_wd = reg_wdata[2];
3281: 
3282:   assign debug_invalid_health_state_wd = reg_wdata[3];
3283: 
3284:   assign debug_invalid_key_version_wd = reg_wdata[4];
3285: 
3286:   assign debug_invalid_key_wd = reg_wdata[5];
3287: 
3288:   assign debug_invalid_digest_wd = reg_wdata[6];
3289: 
3290:   // Assign write-enables to checker logic vector.
3291:   always_comb begin
3292:     reg_we_check = '0;
3293:     reg_we_check[0] = intr_state_we;
3294:     reg_we_check[1] = intr_enable_we;
3295:     reg_we_check[2] = intr_test_we;
3296:     reg_we_check[3] = alert_test_we;
3297:     reg_we_check[4] = 1'b0;
3298:     reg_we_check[5] = start_gated_we;
3299:     reg_we_check[6] = control_shadowed_gated_we;
3300:     reg_we_check[7] = sideload_clear_gated_we;
3301:     reg_we_check[8] = reseed_interval_regwen_we;
3302:     reg_we_check[9] = reseed_interval_shadowed_gated_we;
3303:     reg_we_check[10] = sw_binding_regwen_we;
3304:     reg_we_check[11] = sealing_sw_binding_0_gated_we;
3305:     reg_we_check[12] = sealing_sw_binding_1_gated_we;
3306:     reg_we_check[13] = sealing_sw_binding_2_gated_we;
3307:     reg_we_check[14] = sealing_sw_binding_3_gated_we;
3308:     reg_we_check[15] = sealing_sw_binding_4_gated_we;
3309:     reg_we_check[16] = sealing_sw_binding_5_gated_we;
3310:     reg_we_check[17] = sealing_sw_binding_6_gated_we;
3311:     reg_we_check[18] = sealing_sw_binding_7_gated_we;
3312:     reg_we_check[19] = attest_sw_binding_0_gated_we;
3313:     reg_we_check[20] = attest_sw_binding_1_gated_we;
3314:     reg_we_check[21] = attest_sw_binding_2_gated_we;
3315:     reg_we_check[22] = attest_sw_binding_3_gated_we;
3316:     reg_we_check[23] = attest_sw_binding_4_gated_we;
3317:     reg_we_check[24] = attest_sw_binding_5_gated_we;
3318:     reg_we_check[25] = attest_sw_binding_6_gated_we;
3319:     reg_we_check[26] = attest_sw_binding_7_gated_we;
3320:     reg_we_check[27] = salt_0_gated_we;
3321:     reg_we_check[28] = salt_1_gated_we;
3322:     reg_we_check[29] = salt_2_gated_we;
3323:     reg_we_check[30] = salt_3_gated_we;
3324:     reg_we_check[31] = salt_4_gated_we;
3325:     reg_we_check[32] = salt_5_gated_we;
3326:     reg_we_check[33] = salt_6_gated_we;
3327:     reg_we_check[34] = salt_7_gated_we;
3328:     reg_we_check[35] = key_version_gated_we;
3329:     reg_we_check[36] = max_creator_key_ver_regwen_we;
3330:     reg_we_check[37] = max_creator_key_ver_shadowed_gated_we;
3331:     reg_we_check[38] = max_owner_int_key_ver_regwen_we;
3332:     reg_we_check[39] = max_owner_int_key_ver_shadowed_gated_we;
3333:     reg_we_check[40] = max_owner_key_ver_regwen_we;
3334:     reg_we_check[41] = max_owner_key_ver_shadowed_gated_we;
3335:     reg_we_check[42] = 1'b0;
3336:     reg_we_check[43] = 1'b0;
3337:     reg_we_check[44] = 1'b0;
3338:     reg_we_check[45] = 1'b0;
3339:     reg_we_check[46] = 1'b0;
3340:     reg_we_check[47] = 1'b0;
3341:     reg_we_check[48] = 1'b0;
3342:     reg_we_check[49] = 1'b0;
3343:     reg_we_check[50] = 1'b0;
3344:     reg_we_check[51] = 1'b0;
3345:     reg_we_check[52] = 1'b0;
3346:     reg_we_check[53] = 1'b0;
3347:     reg_we_check[54] = 1'b0;
3348:     reg_we_check[55] = 1'b0;
3349:     reg_we_check[56] = 1'b0;
3350:     reg_we_check[57] = 1'b0;
3351:     reg_we_check[58] = 1'b0;
3352:     reg_we_check[59] = op_status_we;
3353:     reg_we_check[60] = err_code_we;
3354:     reg_we_check[61] = 1'b0;
3355:     reg_we_check[62] = debug_we;
3356:   end
3357: 
3358:   // Read data return
3359:   always_comb begin
3360:     reg_rdata_next = '0;
3361:     unique case (1'b1)
3362:       addr_hit[0]: begin
3363:         reg_rdata_next[0] = intr_state_qs;
3364:       end
3365: 
3366:       addr_hit[1]: begin
3367:         reg_rdata_next[0] = intr_enable_qs;
3368:       end
3369: 
3370:       addr_hit[2]: begin
3371:         reg_rdata_next[0] = '0;
3372:       end
3373: 
3374:       addr_hit[3]: begin
3375:         reg_rdata_next[0] = '0;
3376:         reg_rdata_next[1] = '0;
3377:       end
3378: 
3379:       addr_hit[4]: begin
3380:         reg_rdata_next[0] = cfg_regwen_qs;
3381:       end
3382: 
3383:       addr_hit[5]: begin
3384:         reg_rdata_next[0] = start_qs;
3385:       end
3386: 
3387:       addr_hit[6]: begin
3388:         reg_rdata_next[6:4] = control_shadowed_operation_qs;
3389:         reg_rdata_next[7] = control_shadowed_cdi_sel_qs;
3390:         reg_rdata_next[13:12] = control_shadowed_dest_sel_qs;
3391:       end
3392: 
3393:       addr_hit[7]: begin
3394:         reg_rdata_next[2:0] = sideload_clear_qs;
3395:       end
3396: 
3397:       addr_hit[8]: begin
3398:         reg_rdata_next[0] = reseed_interval_regwen_qs;
3399:       end
3400: 
3401:       addr_hit[9]: begin
3402:         reg_rdata_next[15:0] = reseed_interval_shadowed_qs;
3403:       end
3404: 
3405:       addr_hit[10]: begin
3406:         reg_rdata_next[0] = sw_binding_regwen_qs;
3407:       end
3408: 
3409:       addr_hit[11]: begin
3410:         reg_rdata_next[31:0] = sealing_sw_binding_0_qs;
3411:       end
3412: 
3413:       addr_hit[12]: begin
3414:         reg_rdata_next[31:0] = sealing_sw_binding_1_qs;
3415:       end
3416: 
3417:       addr_hit[13]: begin
3418:         reg_rdata_next[31:0] = sealing_sw_binding_2_qs;
3419:       end
3420: 
3421:       addr_hit[14]: begin
3422:         reg_rdata_next[31:0] = sealing_sw_binding_3_qs;
3423:       end
3424: 
3425:       addr_hit[15]: begin
3426:         reg_rdata_next[31:0] = sealing_sw_binding_4_qs;
3427:       end
3428: 
3429:       addr_hit[16]: begin
3430:         reg_rdata_next[31:0] = sealing_sw_binding_5_qs;
3431:       end
3432: 
3433:       addr_hit[17]: begin
3434:         reg_rdata_next[31:0] = sealing_sw_binding_6_qs;
3435:       end
3436: 
3437:       addr_hit[18]: begin
3438:         reg_rdata_next[31:0] = sealing_sw_binding_7_qs;
3439:       end
3440: 
3441:       addr_hit[19]: begin
3442:         reg_rdata_next[31:0] = attest_sw_binding_0_qs;
3443:       end
3444: 
3445:       addr_hit[20]: begin
3446:         reg_rdata_next[31:0] = attest_sw_binding_1_qs;
3447:       end
3448: 
3449:       addr_hit[21]: begin
3450:         reg_rdata_next[31:0] = attest_sw_binding_2_qs;
3451:       end
3452: 
3453:       addr_hit[22]: begin
3454:         reg_rdata_next[31:0] = attest_sw_binding_3_qs;
3455:       end
3456: 
3457:       addr_hit[23]: begin
3458:         reg_rdata_next[31:0] = attest_sw_binding_4_qs;
3459:       end
3460: 
3461:       addr_hit[24]: begin
3462:         reg_rdata_next[31:0] = attest_sw_binding_5_qs;
3463:       end
3464: 
3465:       addr_hit[25]: begin
3466:         reg_rdata_next[31:0] = attest_sw_binding_6_qs;
3467:       end
3468: 
3469:       addr_hit[26]: begin
3470:         reg_rdata_next[31:0] = attest_sw_binding_7_qs;
3471:       end
3472: 
3473:       addr_hit[27]: begin
3474:         reg_rdata_next[31:0] = salt_0_qs;
3475:       end
3476: 
3477:       addr_hit[28]: begin
3478:         reg_rdata_next[31:0] = salt_1_qs;
3479:       end
3480: 
3481:       addr_hit[29]: begin
3482:         reg_rdata_next[31:0] = salt_2_qs;
3483:       end
3484: 
3485:       addr_hit[30]: begin
3486:         reg_rdata_next[31:0] = salt_3_qs;
3487:       end
3488: 
3489:       addr_hit[31]: begin
3490:         reg_rdata_next[31:0] = salt_4_qs;
3491:       end
3492: 
3493:       addr_hit[32]: begin
3494:         reg_rdata_next[31:0] = salt_5_qs;
3495:       end
3496: 
3497:       addr_hit[33]: begin
3498:         reg_rdata_next[31:0] = salt_6_qs;
3499:       end
3500: 
3501:       addr_hit[34]: begin
3502:         reg_rdata_next[31:0] = salt_7_qs;
3503:       end
3504: 
3505:       addr_hit[35]: begin
3506:         reg_rdata_next[31:0] = key_version_qs;
3507:       end
3508: 
3509:       addr_hit[36]: begin
3510:         reg_rdata_next[0] = max_creator_key_ver_regwen_qs;
3511:       end
3512: 
3513:       addr_hit[37]: begin
3514:         reg_rdata_next[31:0] = max_creator_key_ver_shadowed_qs;
3515:       end
3516: 
3517:       addr_hit[38]: begin
3518:         reg_rdata_next[0] = max_owner_int_key_ver_regwen_qs;
3519:       end
3520: 
3521:       addr_hit[39]: begin
3522:         reg_rdata_next[31:0] = max_owner_int_key_ver_shadowed_qs;
3523:       end
3524: 
3525:       addr_hit[40]: begin
3526:         reg_rdata_next[0] = max_owner_key_ver_regwen_qs;
3527:       end
3528: 
3529:       addr_hit[41]: begin
3530:         reg_rdata_next[31:0] = max_owner_key_ver_shadowed_qs;
3531:       end
3532: 
3533:       addr_hit[42]: begin
3534:         reg_rdata_next[31:0] = sw_share0_output_0_qs;
3535:       end
3536: 
3537:       addr_hit[43]: begin
3538:         reg_rdata_next[31:0] = sw_share0_output_1_qs;
3539:       end
3540: 
3541:       addr_hit[44]: begin
3542:         reg_rdata_next[31:0] = sw_share0_output_2_qs;
3543:       end
3544: 
3545:       addr_hit[45]: begin
3546:         reg_rdata_next[31:0] = sw_share0_output_3_qs;
3547:       end
3548: 
3549:       addr_hit[46]: begin
3550:         reg_rdata_next[31:0] = sw_share0_output_4_qs;
3551:       end
3552: 
3553:       addr_hit[47]: begin
3554:         reg_rdata_next[31:0] = sw_share0_output_5_qs;
3555:       end
3556: 
3557:       addr_hit[48]: begin
3558:         reg_rdata_next[31:0] = sw_share0_output_6_qs;
3559:       end
3560: 
3561:       addr_hit[49]: begin
3562:         reg_rdata_next[31:0] = sw_share0_output_7_qs;
3563:       end
3564: 
3565:       addr_hit[50]: begin
3566:         reg_rdata_next[31:0] = sw_share1_output_0_qs;
3567:       end
3568: 
3569:       addr_hit[51]: begin
3570:         reg_rdata_next[31:0] = sw_share1_output_1_qs;
3571:       end
3572: 
3573:       addr_hit[52]: begin
3574:         reg_rdata_next[31:0] = sw_share1_output_2_qs;
3575:       end
3576: 
3577:       addr_hit[53]: begin
3578:         reg_rdata_next[31:0] = sw_share1_output_3_qs;
3579:       end
3580: 
3581:       addr_hit[54]: begin
3582:         reg_rdata_next[31:0] = sw_share1_output_4_qs;
3583:       end
3584: 
3585:       addr_hit[55]: begin
3586:         reg_rdata_next[31:0] = sw_share1_output_5_qs;
3587:       end
3588: 
3589:       addr_hit[56]: begin
3590:         reg_rdata_next[31:0] = sw_share1_output_6_qs;
3591:       end
3592: 
3593:       addr_hit[57]: begin
3594:         reg_rdata_next[31:0] = sw_share1_output_7_qs;
3595:       end
3596: 
3597:       addr_hit[58]: begin
3598:         reg_rdata_next[2:0] = working_state_qs;
3599:       end
3600: 
3601:       addr_hit[59]: begin
3602:         reg_rdata_next[1:0] = op_status_qs;
3603:       end
3604: 
3605:       addr_hit[60]: begin
3606:         reg_rdata_next[0] = err_code_invalid_op_qs;
3607:         reg_rdata_next[1] = err_code_invalid_kmac_input_qs;
3608:         reg_rdata_next[2] = err_code_invalid_shadow_update_qs;
3609:       end
3610: 
3611:       addr_hit[61]: begin
3612:         reg_rdata_next[0] = fault_status_cmd_qs;
3613:         reg_rdata_next[1] = fault_status_kmac_fsm_qs;
3614:         reg_rdata_next[2] = fault_status_kmac_done_qs;
3615:         reg_rdata_next[3] = fault_status_kmac_op_qs;
3616:         reg_rdata_next[4] = fault_status_kmac_out_qs;
3617:         reg_rdata_next[5] = fault_status_regfile_intg_qs;
3618:         reg_rdata_next[6] = fault_status_shadow_qs;
3619:         reg_rdata_next[7] = fault_status_ctrl_fsm_intg_qs;
3620:         reg_rdata_next[8] = fault_status_ctrl_fsm_chk_qs;
3621:         reg_rdata_next[9] = fault_status_ctrl_fsm_cnt_qs;
3622:         reg_rdata_next[10] = fault_status_reseed_cnt_qs;
3623:         reg_rdata_next[11] = fault_status_side_ctrl_fsm_qs;
3624:         reg_rdata_next[12] = fault_status_side_ctrl_sel_qs;
3625:         reg_rdata_next[13] = fault_status_key_ecc_qs;
3626:       end
3627: 
3628:       addr_hit[62]: begin
3629:         reg_rdata_next[0] = debug_invalid_creator_seed_qs;
3630:         reg_rdata_next[1] = debug_invalid_owner_seed_qs;
3631:         reg_rdata_next[2] = debug_invalid_dev_id_qs;
3632:         reg_rdata_next[3] = debug_invalid_health_state_qs;
3633:         reg_rdata_next[4] = debug_invalid_key_version_qs;
3634:         reg_rdata_next[5] = debug_invalid_key_qs;
3635:         reg_rdata_next[6] = debug_invalid_digest_qs;
3636:       end
3637: 
3638:       default: begin
3639:         reg_rdata_next = '1;
3640:       end
3641:     endcase
3642:   end
3643: 
3644:   // shadow busy
3645:   logic shadow_busy;
3646:   logic rst_done;
3647:   logic shadow_rst_done;
3648:   always_ff @(posedge clk_i or negedge rst_ni) begin
3649:     if (!rst_ni) begin
3650:       rst_done <= '0;
3651:     end else begin
3652:       rst_done <= 1'b1;
3653:     end
3654:   end
3655: 
3656:   always_ff @(posedge clk_i or negedge rst_shadowed_ni) begin
3657:     if (!rst_shadowed_ni) begin
3658:       shadow_rst_done <= '0;
3659:     end else begin
3660:       shadow_rst_done <= 1'b1;
3661:     end
3662:   end
3663: 
3664:   // both shadow and normal resets have been released
3665:   assign shadow_busy = ~(rst_done & shadow_rst_done);
3666: 
3667:   // Collect up storage and update errors
3668:   assign shadowed_storage_err_o = |{
3669:     control_shadowed_operation_storage_err,
3670:     control_shadowed_cdi_sel_storage_err,
3671:     control_shadowed_dest_sel_storage_err,
3672:     reseed_interval_shadowed_storage_err,
3673:     max_creator_key_ver_shadowed_storage_err,
3674:     max_owner_int_key_ver_shadowed_storage_err,
3675:     max_owner_key_ver_shadowed_storage_err
3676:   };
3677:   assign shadowed_update_err_o = |{
3678:     control_shadowed_operation_update_err,
3679:     control_shadowed_cdi_sel_update_err,
3680:     control_shadowed_dest_sel_update_err,
3681:     reseed_interval_shadowed_update_err,
3682:     max_creator_key_ver_shadowed_update_err,
3683:     max_owner_int_key_ver_shadowed_update_err,
3684:     max_owner_key_ver_shadowed_update_err
3685:   };
3686: 
3687:   // register busy
3688:   assign reg_busy = shadow_busy;
3689: 
3690:   // Unused signal tieoff
3691: 
3692:   // wdata / byte enable are not always fully used
3693:   // add a blanket unused statement to handle lint waivers
3694:   logic unused_wdata;
3695:   logic unused_be;
3696:   assign unused_wdata = ^reg_wdata;
3697:   assign unused_be = ^reg_be;
3698: 
3699:   // Assertions for Register Interface
3700:   `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
3701:   `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)
3702: 
3703:   `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)
3704: 
3705:   `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)
3706: 
3707:   // this is formulated as an assumption such that the FPV testbenches do disprove this
3708:   // property by mistake
3709:   //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)
3710: 
3711: endmodule

================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Register Top module auto-generated by `reggen`
6: 
7: `include "prim_assert.sv"
8: 
9: module keymgr_reg_top (
10:   input clk_i,
11:   input rst_ni,
12:   input rst_shadowed_ni,
13:   input  tlul_pkg::tl_h2d_t tl_i,
14:   output tlul_pkg::tl_d2h_t tl_o,
15:   // To HW
16:   output keymgr_reg_pkg::keymgr_reg2hw_t reg2hw, // Write
17:   input  keymgr_reg_pkg::keymgr_hw2reg_t hw2reg, // Read
18: 
19:   output logic shadowed_storage_err_o,
20:   output logic shadowed_update_err_o,
21: 
22:   // Integrity check errors
23:   output logic intg_err_o
24: );
25: 
26:   import keymgr_reg_pkg::* ;
27: 
28:   localparam int AW = 8;
29:   localparam int DW = 32;
30:   localparam int DBW = DW/8;                    // Byte Width
31: 
32:   // register signals
33:   logic           reg_we;
34:   logic           reg_re;
35:   logic [AW-1:0]  reg_addr;
36:   logic [DW-1:0]  reg_wdata;
37:   logic [DBW-1:0] reg_be;
38:   logic [DW-1:0]  reg_rdata;
39:   logic           reg_error;
40: 
41:   logic          addrmiss, wr_err;
42: 
43:   logic [DW-1:0] reg_rdata_next;
44:   logic reg_busy;
45: 
46:   tlul_pkg::tl_h2d_t tl_reg_h2d;
47:   tlul_pkg::tl_d2h_t tl_reg_d2h;
48: 
49: 
50:   // incoming payload check
51:   logic intg_err;
52:   tlul_cmd_intg_chk u_chk (
53:     .tl_i(tl_i),
54:     .err_o(intg_err)
55:   );
56: 
57:   // also check for spurious write enables
58:   logic reg_we_err;
59:   logic [62:0] reg_we_check;
60:   prim_reg_we_check #(
61:     .OneHotWidth(63)
62:   ) u_prim_reg_we_check (
63:     .clk_i(clk_i),
64:     .rst_ni(rst_ni),
65:     .oh_i  (reg_we_check),
66:     .en_i  (reg_we && !addrmiss),
67:     .err_o (reg_we_err)
68:   );
69: 
70:   logic err_q;
71:   always_ff @(posedge clk_i or negedge rst_ni) begin
72:     if (!rst_ni) begin
73:       err_q <= '0;
74:     end else if (intg_err || reg_we_err) begin
75:       err_q <= 1'b1;
76:     end
77:   end
78: 
79:   // integrity error output is permanent and should be used for alert generation
80:   // register errors are transactional
81:   assign intg_err_o = err_q | intg_err | reg_we_err;
82: 
83:   // outgoing integrity generation
84:   tlul_pkg::tl_d2h_t tl_o_pre;
85:   tlul_rsp_intg_gen #(
86:     .EnableRspIntgGen(1),
87:     .EnableDataIntgGen(1)
88:   ) u_rsp_intg_gen (
89:     .tl_i(tl_o_pre),
90:     .tl_o(tl_o)
91:   );
92: 
93:   assign tl_reg_h2d = tl_i;
94:   assign tl_o_pre   = tl_reg_d2h;
95: 
96:   tlul_adapter_reg #(
97:     .RegAw(AW),
98:     .RegDw(DW),
99:     .EnableDataIntgGen(0)
100:   ) u_reg_if (
101:     .clk_i  (clk_i),
102:     .rst_ni (rst_ni),
103: 
104:     .tl_i (tl_reg_h2d),
105:     .tl_o (tl_reg_d2h),
106: 
107:     .en_ifetch_i(prim_mubi_pkg::MuBi4False),
108:     .intg_error_o(),
109: 
110:     .we_o    (reg_we),
111:     .re_o    (reg_re),
112:     .addr_o  (reg_addr),
113:     .wdata_o (reg_wdata),
114:     .be_o    (reg_be),
115:     .busy_i  (reg_busy),
116:     .rdata_i (reg_rdata),
117:     .error_i (reg_error)
118:   );
119: 
120:   // cdc oversampling signals
121: 
122:   assign reg_rdata = reg_rdata_next ;
123:   assign reg_error = addrmiss | wr_err | intg_err;
124: 
125:   // Define SW related signals
126:   // Format: <reg>_<field>_{wd|we|qs}
127:   //        or <reg>_{wd|we|qs} if field == 1 or 0
128:   logic intr_state_we;
129:   logic intr_state_qs;
130:   logic intr_state_wd;
131:   logic intr_enable_we;
132:   logic intr_enable_qs;
133:   logic intr_enable_wd;
134:   logic intr_test_we;
135:   logic intr_test_wd;
136:   logic alert_test_we;
137:   logic alert_test_recov_operation_err_wd;
138:   logic alert_test_fatal_fault_err_wd;
139:   logic cfg_regwen_re;
140:   logic cfg_regwen_qs;
141:   logic start_we;
142:   logic start_qs;
143:   logic start_wd;
144:   logic control_shadowed_re;
145:   logic control_shadowed_we;
146:   logic [2:0] control_shadowed_operation_qs;
147:   logic [2:0] control_shadowed_operation_wd;
148:   logic control_shadowed_operation_storage_err;
149:   logic control_shadowed_operation_update_err;
150:   logic control_shadowed_cdi_sel_qs;
151:   logic control_shadowed_cdi_sel_wd;
152:   logic control_shadowed_cdi_sel_storage_err;
153:   logic control_shadowed_cdi_sel_update_err;
154:   logic [1:0] control_shadowed_dest_sel_qs;
155:   logic [1:0] control_shadowed_dest_sel_wd;
156:   logic control_shadowed_dest_sel_storage_err;
157:   logic control_shadowed_dest_sel_update_err;
158:   logic sideload_clear_we;
159:   logic [2:0] sideload_clear_qs;
160:   logic [2:0] sideload_clear_wd;
161:   logic reseed_interval_regwen_we;
162:   logic reseed_interval_regwen_qs;
163:   logic reseed_interval_regwen_wd;
164:   logic reseed_interval_shadowed_re;
165:   logic reseed_interval_shadowed_we;
166:   logic [15:0] reseed_interval_shadowed_qs;
167:   logic [15:0] reseed_interval_shadowed_wd;
168:   logic reseed_interval_shadowed_storage_err;
169:   logic reseed_interval_shadowed_update_err;
170:   logic sw_binding_regwen_re;
171:   logic sw_binding_regwen_we;
172:   logic sw_binding_regwen_qs;
173:   logic sw_binding_regwen_wd;
174:   logic sealing_sw_binding_0_we;
175:   logic [31:0] sealing_sw_binding_0_qs;
176:   logic [31:0] sealing_sw_binding_0_wd;
177:   logic sealing_sw_binding_1_we;
178:   logic [31:0] sealing_sw_binding_1_qs;
179:   logic [31:0] sealing_sw_binding_1_wd;
180:   logic sealing_sw_binding_2_we;
181:   logic [31:0] sealing_sw_binding_2_qs;
182:   logic [31:0] sealing_sw_binding_2_wd;
183:   logic sealing_sw_binding_3_we;
184:   logic [31:0] sealing_sw_binding_3_qs;
185:   logic [31:0] sealing_sw_binding_3_wd;
186:   logic sealing_sw_binding_4_we;
187:   logic [31:0] sealing_sw_binding_4_qs;
188:   logic [31:0] sealing_sw_binding_4_wd;
189:   logic sealing_sw_binding_5_we;
190:   logic [31:0] sealing_sw_binding_5_qs;
191:   logic [31:0] sealing_sw_binding_5_wd;
192:   logic sealing_sw_binding_6_we;
193:   logic [31:0] sealing_sw_binding_6_qs;
194:   logic [31:0] sealing_sw_binding_6_wd;
195:   logic sealing_sw_binding_7_we;
196:   logic [31:0] sealing_sw_binding_7_qs;
197:   logic [31:0] sealing_sw_binding_7_wd;
198:   logic attest_sw_binding_0_we;
199:   logic [31:0] attest_sw_binding_0_qs;
200:   logic [31:0] attest_sw_binding_0_wd;
201:   logic attest_sw_binding_1_we;
202:   logic [31:0] attest_sw_binding_1_qs;
203:   logic [31:0] attest_sw_binding_1_wd;
204:   logic attest_sw_binding_2_we;
205:   logic [31:0] attest_sw_binding_2_qs;
206:   logic [31:0] attest_sw_binding_2_wd;
207:   logic attest_sw_binding_3_we;
208:   logic [31:0] attest_sw_binding_3_qs;
209:   logic [31:0] attest_sw_binding_3_wd;
210:   logic attest_sw_binding_4_we;
211:   logic [31:0] attest_sw_binding_4_qs;
212:   logic [31:0] attest_sw_binding_4_wd;
213:   logic attest_sw_binding_5_we;
214:   logic [31:0] attest_sw_binding_5_qs;
215:   logic [31:0] attest_sw_binding_5_wd;
216:   logic attest_sw_binding_6_we;
217:   logic [31:0] attest_sw_binding_6_qs;
218:   logic [31:0] attest_sw_binding_6_wd;
219:   logic attest_sw_binding_7_we;
220:   logic [31:0] attest_sw_binding_7_qs;
221:   logic [31:0] attest_sw_binding_7_wd;
222:   logic salt_0_we;
223:   logic [31:0] salt_0_qs;
224:   logic [31:0] salt_0_wd;
225:   logic salt_1_we;
226:   logic [31:0] salt_1_qs;
227:   logic [31:0] salt_1_wd;
228:   logic salt_2_we;
229:   logic [31:0] salt_2_qs;
230:   logic [31:0] salt_2_wd;
231:   logic salt_3_we;
232:   logic [31:0] salt_3_qs;
233:   logic [31:0] salt_3_wd;
234:   logic salt_4_we;
235:   logic [31:0] salt_4_qs;
236:   logic [31:0] salt_4_wd;
237:   logic salt_5_we;
238:   logic [31:0] salt_5_qs;
239:   logic [31:0] salt_5_wd;
240:   logic salt_6_we;
241:   logic [31:0] salt_6_qs;
242:   logic [31:0] salt_6_wd;
243:   logic salt_7_we;
244:   logic [31:0] salt_7_qs;
245:   logic [31:0] salt_7_wd;
246:   logic key_version_we;
247:   logic [31:0] key_version_qs;
248:   logic [31:0] key_version_wd;
249:   logic max_creator_key_ver_regwen_we;
250:   logic max_creator_key_ver_regwen_qs;
251:   logic max_creator_key_ver_regwen_wd;
252:   logic max_creator_key_ver_shadowed_re;
253:   logic max_creator_key_ver_shadowed_we;
254:   logic [31:0] max_creator_key_ver_shadowed_qs;
255:   logic [31:0] max_creator_key_ver_shadowed_wd;
256:   logic max_creator_key_ver_shadowed_storage_err;
257:   logic max_creator_key_ver_shadowed_update_err;
258:   logic max_owner_int_key_ver_regwen_we;
259:   logic max_owner_int_key_ver_regwen_qs;
260:   logic max_owner_int_key_ver_regwen_wd;
261:   logic max_owner_int_key_ver_shadowed_re;
262:   logic max_owner_int_key_ver_shadowed_we;
263:   logic [31:0] max_owner_int_key_ver_shadowed_qs;
264:   logic [31:0] max_owner_int_key_ver_shadowed_wd;
265:   logic max_owner_int_key_ver_shadowed_storage_err;
266:   logic max_owner_int_key_ver_shadowed_update_err;
267:   logic max_owner_key_ver_regwen_we;
268:   logic max_owner_key_ver_regwen_qs;
269:   logic max_owner_key_ver_regwen_wd;
270:   logic max_owner_key_ver_shadowed_re;
271:   logic max_owner_key_ver_shadowed_we;
272:   logic [31:0] max_owner_key_ver_shadowed_qs;
273:   logic [31:0] max_owner_key_ver_shadowed_wd;
274:   logic max_owner_key_ver_shadowed_storage_err;
275:   logic max_owner_key_ver_shadowed_update_err;
276:   logic sw_share0_output_0_re;
277:   logic [31:0] sw_share0_output_0_qs;
278:   logic [31:0] sw_share0_output_0_wd;
279:   logic sw_share0_output_1_re;
280:   logic [31:0] sw_share0_output_1_qs;
281:   logic [31:0] sw_share0_output_1_wd;
282:   logic sw_share0_output_2_re;
283:   logic [31:0] sw_share0_output_2_qs;
284:   logic [31:0] sw_share0_output_2_wd;
285:   logic sw_share0_output_3_re;
286:   logic [31:0] sw_share0_output_3_qs;
287:   logic [31:0] sw_share0_output_3_wd;
288:   logic sw_share0_output_4_re;
289:   logic [31:0] sw_share0_output_4_qs;
290:   logic [31:0] sw_share0_output_4_wd;
291:   logic sw_share0_output_5_re;
292:   logic [31:0] sw_share0_output_5_qs;
293:   logic [31:0] sw_share0_output_5_wd;
294:   logic sw_share0_output_6_re;
295:   logic [31:0] sw_share0_output_6_qs;
296:   logic [31:0] sw_share0_output_6_wd;
297:   logic sw_share0_output_7_re;
298:   logic [31:0] sw_share0_output_7_qs;
299:   logic [31:0] sw_share0_output_7_wd;
300:   logic sw_share1_output_0_re;
301:   logic [31:0] sw_share1_output_0_qs;
302:   logic [31:0] sw_share1_output_0_wd;
303:   logic sw_share1_output_1_re;
304:   logic [31:0] sw_share1_output_1_qs;
305:   logic [31:0] sw_share1_output_1_wd;
306:   logic sw_share1_output_2_re;
307:   logic [31:0] sw_share1_output_2_qs;
308:   logic [31:0] sw_share1_output_2_wd;
309:   logic sw_share1_output_3_re;
310:   logic [31:0] sw_share1_output_3_qs;
311:   logic [31:0] sw_share1_output_3_wd;
312:   logic sw_share1_output_4_re;
313:   logic [31:0] sw_share1_output_4_qs;
314:   logic [31:0] sw_share1_output_4_wd;
315:   logic sw_share1_output_5_re;
316:   logic [31:0] sw_share1_output_5_qs;
317:   logic [31:0] sw_share1_output_5_wd;
318:   logic sw_share1_output_6_re;
319:   logic [31:0] sw_share1_output_6_qs;
320:   logic [31:0] sw_share1_output_6_wd;
321:   logic sw_share1_output_7_re;
322:   logic [31:0] sw_share1_output_7_qs;
323:   logic [31:0] sw_share1_output_7_wd;
324:   logic [2:0] working_state_qs;
325:   logic op_status_we;
326:   logic [1:0] op_status_qs;
327:   logic [1:0] op_status_wd;
328:   logic err_code_we;
329:   logic err_code_invalid_op_qs;
330:   logic err_code_invalid_op_wd;
331:   logic err_code_invalid_kmac_input_qs;
332:   logic err_code_invalid_kmac_input_wd;
333:   logic err_code_invalid_shadow_update_qs;
334:   logic err_code_invalid_shadow_update_wd;
335:   logic fault_status_cmd_qs;
336:   logic fault_status_kmac_fsm_qs;
337:   logic fault_status_kmac_done_qs;
338:   logic fault_status_kmac_op_qs;
339:   logic fault_status_kmac_out_qs;
340:   logic fault_status_regfile_intg_qs;
341:   logic fault_status_shadow_qs;
342:   logic fault_status_ctrl_fsm_intg_qs;
343:   logic fault_status_ctrl_fsm_chk_qs;
344:   logic fault_status_ctrl_fsm_cnt_qs;
345:   logic fault_status_reseed_cnt_qs;
346:   logic fault_status_side_ctrl_fsm_qs;
347:   logic fault_status_side_ctrl_sel_qs;
348:   logic fault_status_key_ecc_qs;
349:   logic debug_we;
350:   logic debug_invalid_creator_seed_qs;
351:   logic debug_invalid_creator_seed_wd;
352:   logic debug_invalid_owner_seed_qs;
353:   logic debug_invalid_owner_seed_wd;
354:   logic debug_invalid_dev_id_qs;
355:   logic debug_invalid_dev_id_wd;
356:   logic debug_invalid_health_state_qs;
357:   logic debug_invalid_health_state_wd;
358:   logic debug_invalid_key_version_qs;
359:   logic debug_invalid_key_version_wd;
360:   logic debug_invalid_key_qs;
361:   logic debug_invalid_key_wd;
362:   logic debug_invalid_digest_qs;
363:   logic debug_invalid_digest_wd;
364: 
365:   // Register instances
366:   // R[intr_state]: V(False)
367:   prim_subreg #(
368:     .DW      (1),
369:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
370:     .RESVAL  (1'h0),
371:     .Mubi    (1'b0)
372:   ) u_intr_state (
373:     .clk_i   (clk_i),
374:     .rst_ni  (rst_ni),
375: 
376:     // from register interface
377:     .we     (intr_state_we),
378:     .wd     (intr_state_wd),
379: 
380:     // from internal hardware
381:     .de     (hw2reg.intr_state.de),
382:     .d      (hw2reg.intr_state.d),
383: 
384:     // to internal hardware
385:     .qe     (),
386:     .q      (reg2hw.intr_state.q),
387:     .ds     (),
388: 
389:     // to register interface (read)
390:     .qs     (intr_state_qs)
391:   );
392: 
393: 
394:   // R[intr_enable]: V(False)
395:   prim_subreg #(
396:     .DW      (1),
397:     .SwAccess(prim_subreg_pkg::SwAccessRW),
398:     .RESVAL  (1'h0),
399:     .Mubi    (1'b0)
400:   ) u_intr_enable (
401:     .clk_i   (clk_i),
402:     .rst_ni  (rst_ni),
403: 
404:     // from register interface
405:     .we     (intr_enable_we),
406:     .wd     (intr_enable_wd),
407: 
408:     // from internal hardware
409:     .de     (1'b0),
410:     .d      ('0),
411: 
412:     // to internal hardware
413:     .qe     (),
414:     .q      (reg2hw.intr_enable.q),
415:     .ds     (),
416: 
417:     // to register interface (read)
418:     .qs     (intr_enable_qs)
419:   );
420: 
421: 
422:   // R[intr_test]: V(True)
423:   logic intr_test_qe;
424:   logic [0:0] intr_test_flds_we;
425:   assign intr_test_qe = &intr_test_flds_we;
426:   prim_subreg_ext #(
427:     .DW    (1)
428:   ) u_intr_test (
429:     .re     (1'b0),
430:     .we     (intr_test_we),
431:     .wd     (intr_test_wd),
432:     .d      ('0),
433:     .qre    (),
434:     .qe     (intr_test_flds_we[0]),
435:     .q      (reg2hw.intr_test.q),
436:     .ds     (),
437:     .qs     ()
438:   );
439:   assign reg2hw.intr_test.qe = intr_test_qe;
440: 
441: 
442:   // R[alert_test]: V(True)
443:   logic alert_test_qe;
444:   logic [1:0] alert_test_flds_we;
445:   assign alert_test_qe = &alert_test_flds_we;
446:   //   F[recov_operation_err]: 0:0
447:   prim_subreg_ext #(
448:     .DW    (1)
449:   ) u_alert_test_recov_operation_err (
450:     .re     (1'b0),
451:     .we     (alert_test_we),
452:     .wd     (alert_test_recov_operation_err_wd),
453:     .d      ('0),
454:     .qre    (),
455:     .qe     (alert_test_flds_we[0]),
456:     .q      (reg2hw.alert_test.recov_operation_err.q),
457:     .ds     (),
458:     .qs     ()
459:   );
460:   assign reg2hw.alert_test.recov_operation_err.qe = alert_test_qe;
461: 
462:   //   F[fatal_fault_err]: 1:1
463:   prim_subreg_ext #(
464:     .DW    (1)
465:   ) u_alert_test_fatal_fault_err (
466:     .re     (1'b0),
467:     .we     (alert_test_we),
468:     .wd     (alert_test_fatal_fault_err_wd),
469:     .d      ('0),
470:     .qre    (),
471:     .qe     (alert_test_flds_we[1]),
472:     .q      (reg2hw.alert_test.fatal_fault_err.q),
473:     .ds     (),
474:     .qs     ()
475:   );
476:   assign reg2hw.alert_test.fatal_fault_err.qe = alert_test_qe;
477: 
478: 
479:   // R[cfg_regwen]: V(True)
480:   prim_subreg_ext #(
481:     .DW    (1)
482:   ) u_cfg_regwen (
483:     .re     (cfg_regwen_re),
484:     .we     (1'b0),
485:     .wd     ('0),
486:     .d      (hw2reg.cfg_regwen.d),
487:     .qre    (),
488:     .qe     (),
489:     .q      (),
490:     .ds     (),
491:     .qs     (cfg_regwen_qs)
492:   );
493: 
494: 
495:   // R[start]: V(False)
496:   // Create REGWEN-gated WE signal
497:   logic start_gated_we;
498:   assign start_gated_we = start_we & cfg_regwen_qs;
499:   prim_subreg #(
500:     .DW      (1),
501:     .SwAccess(prim_subreg_pkg::SwAccessRW),
502:     .RESVAL  (1'h0),
503:     .Mubi    (1'b0)
504:   ) u_start (
505:     .clk_i   (clk_i),
506:     .rst_ni  (rst_ni),
507: 
508:     // from register interface
509:     .we     (start_gated_we),
510:     .wd     (start_wd),
511: 
512:     // from internal hardware
513:     .de     (hw2reg.start.de),
514:     .d      (hw2reg.start.d),
515: 
516:     // to internal hardware
517:     .qe     (),
518:     .q      (reg2hw.start.q),
519:     .ds     (),
520: 
521:     // to register interface (read)
522:     .qs     (start_qs)
523:   );
524: 
525: 
526:   // R[control_shadowed]: V(False)
527:   // Create REGWEN-gated WE signal
528:   logic control_shadowed_gated_we;
529:   assign control_shadowed_gated_we = control_shadowed_we & cfg_regwen_qs;
530:   //   F[operation]: 6:4
531:   prim_subreg_shadow #(
532:     .DW      (3),
533:     .SwAccess(prim_subreg_pkg::SwAccessRW),
534:     .RESVAL  (3'h1),
535:     .Mubi    (1'b0)
536:   ) u_control_shadowed_operation (
537:     .clk_i   (clk_i),
538:     .rst_ni  (rst_ni),
539:     .rst_shadowed_ni (rst_shadowed_ni),
540: 
541:     // from register interface
542:     .re     (control_shadowed_re),
543:     .we     (control_shadowed_gated_we),
544:     .wd     (control_shadowed_operation_wd),
545: 
546:     // from internal hardware
547:     .de     (1'b0),
548:     .d      ('0),
549: 
550:     // to internal hardware
551:     .qe     (),
552:     .q      (reg2hw.control_shadowed.operation.q),
553:     .ds     (),
554: 
555:     // to register interface (read)
556:     .qs     (control_shadowed_operation_qs),
557: 
558:     // Shadow register phase. Relevant for hwext only.
559:     .phase  (),
560: 
561:     // Shadow register error conditions
562:     .err_update  (control_shadowed_operation_update_err),
563:     .err_storage (control_shadowed_operation_storage_err)
564:   );
565: 
566:   //   F[cdi_sel]: 7:7
567:   prim_subreg_shadow #(
568:     .DW      (1),
569:     .SwAccess(prim_subreg_pkg::SwAccessRW),
570:     .RESVAL  (1'h0),
571:     .Mubi    (1'b0)
572:   ) u_control_shadowed_cdi_sel (
573:     .clk_i   (clk_i),
574:     .rst_ni  (rst_ni),
575:     .rst_shadowed_ni (rst_shadowed_ni),
576: 
577:     // from register interface
578:     .re     (control_shadowed_re),
579:     .we     (control_shadowed_gated_we),
580:     .wd     (control_shadowed_cdi_sel_wd),
581: 
582:     // from internal hardware
583:     .de     (1'b0),
584:     .d      ('0),
585: 
586:     // to internal hardware
587:     .qe     (),
588:     .q      (reg2hw.control_shadowed.cdi_sel.q),
589:     .ds     (),
590: 
591:     // to register interface (read)
592:     .qs     (control_shadowed_cdi_sel_qs),
593: 
594:     // Shadow register phase. Relevant for hwext only.
595:     .phase  (),
596: 
597:     // Shadow register error conditions
598:     .err_update  (control_shadowed_cdi_sel_update_err),
599:     .err_storage (control_shadowed_cdi_sel_storage_err)
600:   );
601: 
602:   //   F[dest_sel]: 13:12
603:   prim_subreg_shadow #(
604:     .DW      (2),
605:     .SwAccess(prim_subreg_pkg::SwAccessRW),
606:     .RESVAL  (2'h0),
607:     .Mubi    (1'b0)
608:   ) u_control_shadowed_dest_sel (
609:     .clk_i   (clk_i),
610:     .rst_ni  (rst_ni),
611:     .rst_shadowed_ni (rst_shadowed_ni),
612: 
613:     // from register interface
614:     .re     (control_shadowed_re),
615:     .we     (control_shadowed_gated_we),
616:     .wd     (control_shadowed_dest_sel_wd),
617: 
618:     // from internal hardware
619:     .de     (1'b0),
620:     .d      ('0),
621: 
622:     // to internal hardware
623:     .qe     (),
624:     .q      (reg2hw.control_shadowed.dest_sel.q),
625:     .ds     (),
626: 
627:     // to register interface (read)
628:     .qs     (control_shadowed_dest_sel_qs),
629: 
630:     // Shadow register phase. Relevant for hwext only.
631:     .phase  (),
632: 
633:     // Shadow register error conditions
634:     .err_update  (control_shadowed_dest_sel_update_err),
635:     .err_storage (control_shadowed_dest_sel_storage_err)
636:   );
637: 
638: 
639:   // R[sideload_clear]: V(False)
640:   // Create REGWEN-gated WE signal
641:   logic sideload_clear_gated_we;
642:   assign sideload_clear_gated_we = sideload_clear_we & cfg_regwen_qs;
643:   prim_subreg #(
644:     .DW      (3),
645:     .SwAccess(prim_subreg_pkg::SwAccessRW),
646:     .RESVAL  (3'h0),
647:     .Mubi    (1'b0)
648:   ) u_sideload_clear (
649:     .clk_i   (clk_i),
650:     .rst_ni  (rst_ni),
651: 
652:     // from register interface
653:     .we     (sideload_clear_gated_we),
654:     .wd     (sideload_clear_wd),
655: 
656:     // from internal hardware
657:     .de     (1'b0),
658:     .d      ('0),
659: 
660:     // to internal hardware
661:     .qe     (),
662:     .q      (reg2hw.sideload_clear.q),
663:     .ds     (),
664: 
665:     // to register interface (read)
666:     .qs     (sideload_clear_qs)
667:   );
668: 
669: 
670:   // R[reseed_interval_regwen]: V(False)
671:   prim_subreg #(
672:     .DW      (1),
673:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
674:     .RESVAL  (1'h1),
675:     .Mubi    (1'b0)
676:   ) u_reseed_interval_regwen (
677:     .clk_i   (clk_i),
678:     .rst_ni  (rst_ni),
679: 
680:     // from register interface
681:     .we     (reseed_interval_regwen_we),
682:     .wd     (reseed_interval_regwen_wd),
683: 
684:     // from internal hardware
685:     .de     (1'b0),
686:     .d      ('0),
687: 
688:     // to internal hardware
689:     .qe     (),
690:     .q      (),
691:     .ds     (),
692: 
693:     // to register interface (read)
694:     .qs     (reseed_interval_regwen_qs)
695:   );
696: 
697: 
698:   // R[reseed_interval_shadowed]: V(False)
699:   // Create REGWEN-gated WE signal
700:   logic reseed_interval_shadowed_gated_we;
701:   assign reseed_interval_shadowed_gated_we =
702:     reseed_interval_shadowed_we & reseed_interval_regwen_qs;
703:   prim_subreg_shadow #(
704:     .DW      (16),
705:     .SwAccess(prim_subreg_pkg::SwAccessRW),
706:     .RESVAL  (16'h100),
707:     .Mubi    (1'b0)
708:   ) u_reseed_interval_shadowed (
709:     .clk_i   (clk_i),
710:     .rst_ni  (rst_ni),
711:     .rst_shadowed_ni (rst_shadowed_ni),
712: 
713:     // from register interface
714:     .re     (reseed_interval_shadowed_re),
715:     .we     (reseed_interval_shadowed_gated_we),
716:     .wd     (reseed_interval_shadowed_wd),
717: 
718:     // from internal hardware
719:     .de     (1'b0),
720:     .d      ('0),
721: 
722:     // to internal hardware
723:     .qe     (),
724:     .q      (reg2hw.reseed_interval_shadowed.q),
725:     .ds     (),
726: 
727:     // to register interface (read)
728:     .qs     (reseed_interval_shadowed_qs),
729: 
730:     // Shadow register phase. Relevant for hwext only.
731:     .phase  (),
732: 
733:     // Shadow register error conditions
734:     .err_update  (reseed_interval_shadowed_update_err),
735:     .err_storage (reseed_interval_shadowed_storage_err)
736:   );
737: 
738: 
739:   // R[sw_binding_regwen]: V(True)
740:   logic sw_binding_regwen_qe;
741:   logic [0:0] sw_binding_regwen_flds_we;
742:   assign sw_binding_regwen_qe = &sw_binding_regwen_flds_we;
743:   prim_subreg_ext #(
744:     .DW    (1)
745:   ) u_sw_binding_regwen (
746:     .re     (sw_binding_regwen_re),
747:     .we     (sw_binding_regwen_we),
748:     .wd     (sw_binding_regwen_wd),
749:     .d      (hw2reg.sw_binding_regwen.d),
750:     .qre    (),
751:     .qe     (sw_binding_regwen_flds_we[0]),
752:     .q      (reg2hw.sw_binding_regwen.q),
753:     .ds     (),
754:     .qs     (sw_binding_regwen_qs)
755:   );
756:   assign reg2hw.sw_binding_regwen.qe = sw_binding_regwen_qe;
757: 
758: 
759:   // Subregister 0 of Multireg sealing_sw_binding
760:   // R[sealing_sw_binding_0]: V(False)
761:   // Create REGWEN-gated WE signal
762:   logic sealing_sw_binding_0_gated_we;
763:   assign sealing_sw_binding_0_gated_we = sealing_sw_binding_0_we & sw_binding_regwen_qs;
764:   prim_subreg #(
765:     .DW      (32),
766:     .SwAccess(prim_subreg_pkg::SwAccessRW),
767:     .RESVAL  (32'h0),
768:     .Mubi    (1'b0)
769:   ) u_sealing_sw_binding_0 (
770:     .clk_i   (clk_i),
771:     .rst_ni  (rst_ni),
772: 
773:     // from register interface
774:     .we     (sealing_sw_binding_0_gated_we),
775:     .wd     (sealing_sw_binding_0_wd),
776: 
777:     // from internal hardware
778:     .de     (1'b0),
779:     .d      ('0),
780: 
781:     // to internal hardware
782:     .qe     (),
783:     .q      (reg2hw.sealing_sw_binding[0].q),
784:     .ds     (),
785: 
786:     // to register interface (read)
787:     .qs     (sealing_sw_binding_0_qs)
788:   );
789: 
790: 
791:   // Subregister 1 of Multireg sealing_sw_binding
792:   // R[sealing_sw_binding_1]: V(False)
793:   // Create REGWEN-gated WE signal
794:   logic sealing_sw_binding_1_gated_we;
795:   assign sealing_sw_binding_1_gated_we = sealing_sw_binding_1_we & sw_binding_regwen_qs;
796:   prim_subreg #(
797:     .DW      (32),
798:     .SwAccess(prim_subreg_pkg::SwAccessRW),
799:     .RESVAL  (32'h0),
800:     .Mubi    (1'b0)
801:   ) u_sealing_sw_binding_1 (
802:     .clk_i   (clk_i),
803:     .rst_ni  (rst_ni),
804: 
805:     // from register interface
806:     .we     (sealing_sw_binding_1_gated_we),
807:     .wd     (sealing_sw_binding_1_wd),
808: 
809:     // from internal hardware
810:     .de     (1'b0),
811:     .d      ('0),
812: 
813:     // to internal hardware
814:     .qe     (),
815:     .q      (reg2hw.sealing_sw_binding[1].q),
816:     .ds     (),
817: 
818:     // to register interface (read)
819:     .qs     (sealing_sw_binding_1_qs)
820:   );
821: 
822: 
823:   // Subregister 2 of Multireg sealing_sw_binding
824:   // R[sealing_sw_binding_2]: V(False)
825:   // Create REGWEN-gated WE signal
826:   logic sealing_sw_binding_2_gated_we;
827:   assign sealing_sw_binding_2_gated_we = sealing_sw_binding_2_we & sw_binding_regwen_qs;
828:   prim_subreg #(
829:     .DW      (32),
830:     .SwAccess(prim_subreg_pkg::SwAccessRW),
831:     .RESVAL  (32'h0),
832:     .Mubi    (1'b0)
833:   ) u_sealing_sw_binding_2 (
834:     .clk_i   (clk_i),
835:     .rst_ni  (rst_ni),
836: 
837:     // from register interface
838:     .we     (sealing_sw_binding_2_gated_we),
839:     .wd     (sealing_sw_binding_2_wd),
840: 
841:     // from internal hardware
842:     .de     (1'b0),
843:     .d      ('0),
844: 
845:     // to internal hardware
846:     .qe     (),
847:     .q      (reg2hw.sealing_sw_binding[2].q),
848:     .ds     (),
849: 
850:     // to register interface (read)
851:     .qs     (sealing_sw_binding_2_qs)
852:   );
853: 
854: 
855:   // Subregister 3 of Multireg sealing_sw_binding
856:   // R[sealing_sw_binding_3]: V(False)
857:   // Create REGWEN-gated WE signal
858:   logic sealing_sw_binding_3_gated_we;
859:   assign sealing_sw_binding_3_gated_we = sealing_sw_binding_3_we & sw_binding_regwen_qs;
860:   prim_subreg #(
861:     .DW      (32),
862:     .SwAccess(prim_subreg_pkg::SwAccessRW),
863:     .RESVAL  (32'h0),
864:     .Mubi    (1'b0)
865:   ) u_sealing_sw_binding_3 (
866:     .clk_i   (clk_i),
867:     .rst_ni  (rst_ni),
868: 
869:     // from register interface
870:     .we     (sealing_sw_binding_3_gated_we),
871:     .wd     (sealing_sw_binding_3_wd),
872: 
873:     // from internal hardware
874:     .de     (1'b0),
875:     .d      ('0),
876: 
877:     // to internal hardware
878:     .qe     (),
879:     .q      (reg2hw.sealing_sw_binding[3].q),
880:     .ds     (),
881: 
882:     // to register interface (read)
883:     .qs     (sealing_sw_binding_3_qs)
884:   );
885: 
886: 
887:   // Subregister 4 of Multireg sealing_sw_binding
888:   // R[sealing_sw_binding_4]: V(False)
889:   // Create REGWEN-gated WE signal
890:   logic sealing_sw_binding_4_gated_we;
891:   assign sealing_sw_binding_4_gated_we = sealing_sw_binding_4_we & sw_binding_regwen_qs;
892:   prim_subreg #(
893:     .DW      (32),
894:     .SwAccess(prim_subreg_pkg::SwAccessRW),
895:     .RESVAL  (32'h0),
896:     .Mubi    (1'b0)
897:   ) u_sealing_sw_binding_4 (
898:     .clk_i   (clk_i),
899:     .rst_ni  (rst_ni),
900: 
901:     // from register interface
902:     .we     (sealing_sw_binding_4_gated_we),
903:     .wd     (sealing_sw_binding_4_wd),
904: 
905:     // from internal hardware
906:     .de     (1'b0),
907:     .d      ('0),
908: 
909:     // to internal hardware
910:     .qe     (),
911:     .q      (reg2hw.sealing_sw_binding[4].q),
912:     .ds     (),
913: 
914:     // to register interface (read)
915:     .qs     (sealing_sw_binding_4_qs)
916:   );
917: 
918: 
919:   // Subregister 5 of Multireg sealing_sw_binding
920:   // R[sealing_sw_binding_5]: V(False)
921:   // Create REGWEN-gated WE signal
922:   logic sealing_sw_binding_5_gated_we;
923:   assign sealing_sw_binding_5_gated_we = sealing_sw_binding_5_we & sw_binding_regwen_qs;
924:   prim_subreg #(
925:     .DW      (32),
926:     .SwAccess(prim_subreg_pkg::SwAccessRW),
927:     .RESVAL  (32'h0),
928:     .Mubi    (1'b0)
929:   ) u_sealing_sw_binding_5 (
930:     .clk_i   (clk_i),
931:     .rst_ni  (rst_ni),
932: 
933:     // from register interface
934:     .we     (sealing_sw_binding_5_gated_we),
935:     .wd     (sealing_sw_binding_5_wd),
936: 
937:     // from internal hardware
938:     .de     (1'b0),
939:     .d      ('0),
940: 
941:     // to internal hardware
942:     .qe     (),
943:     .q      (reg2hw.sealing_sw_binding[5].q),
944:     .ds     (),
945: 
946:     // to register interface (read)
947:     .qs     (sealing_sw_binding_5_qs)
948:   );
949: 
950: 
951:   // Subregister 6 of Multireg sealing_sw_binding
952:   // R[sealing_sw_binding_6]: V(False)
953:   // Create REGWEN-gated WE signal
954:   logic sealing_sw_binding_6_gated_we;
955:   assign sealing_sw_binding_6_gated_we = sealing_sw_binding_6_we & sw_binding_regwen_qs;
956:   prim_subreg #(
957:     .DW      (32),
958:     .SwAccess(prim_subreg_pkg::SwAccessRW),
959:     .RESVAL  (32'h0),
960:     .Mubi    (1'b0)
961:   ) u_sealing_sw_binding_6 (
962:     .clk_i   (clk_i),
963:     .rst_ni  (rst_ni),
964: 
965:     // from register interface
966:     .we     (sealing_sw_binding_6_gated_we),
967:     .wd     (sealing_sw_binding_6_wd),
968: 
969:     // from internal hardware
970:     .de     (1'b0),
971:     .d      ('0),
972: 
973:     // to internal hardware
974:     .qe     (),
975:     .q      (reg2hw.sealing_sw_binding[6].q),
976:     .ds     (),
977: 
978:     // to register interface (read)
979:     .qs     (sealing_sw_binding_6_qs)
980:   );
981: 
982: 
983:   // Subregister 7 of Multireg sealing_sw_binding
984:   // R[sealing_sw_binding_7]: V(False)
985:   // Create REGWEN-gated WE signal
986:   logic sealing_sw_binding_7_gated_we;
987:   assign sealing_sw_binding_7_gated_we = sealing_sw_binding_7_we & sw_binding_regwen_qs;
988:   prim_subreg #(
989:     .DW      (32),
990:     .SwAccess(prim_subreg_pkg::SwAccessRW),
991:     .RESVAL  (32'h0),
992:     .Mubi    (1'b0)
993:   ) u_sealing_sw_binding_7 (
994:     .clk_i   (clk_i),
995:     .rst_ni  (rst_ni),
996: 
997:     // from register interface
998:     .we     (sealing_sw_binding_7_gated_we),
999:     .wd     (sealing_sw_binding_7_wd),
1000: 
1001:     // from internal hardware
1002:     .de     (1'b0),
1003:     .d      ('0),
1004: 
1005:     // to internal hardware
1006:     .qe     (),
1007:     .q      (reg2hw.sealing_sw_binding[7].q),
1008:     .ds     (),
1009: 
1010:     // to register interface (read)
1011:     .qs     (sealing_sw_binding_7_qs)
1012:   );
1013: 
1014: 
1015:   // Subregister 0 of Multireg attest_sw_binding
1016:   // R[attest_sw_binding_0]: V(False)
1017:   // Create REGWEN-gated WE signal
1018:   logic attest_sw_binding_0_gated_we;
1019:   assign attest_sw_binding_0_gated_we = attest_sw_binding_0_we & sw_binding_regwen_qs;
1020:   prim_subreg #(
1021:     .DW      (32),
1022:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1023:     .RESVAL  (32'h0),
1024:     .Mubi    (1'b0)
1025:   ) u_attest_sw_binding_0 (
1026:     .clk_i   (clk_i),
1027:     .rst_ni  (rst_ni),
1028: 
1029:     // from register interface
1030:     .we     (attest_sw_binding_0_gated_we),
1031:     .wd     (attest_sw_binding_0_wd),
1032: 
1033:     // from internal hardware
1034:     .de     (1'b0),
1035:     .d      ('0),
1036: 
1037:     // to internal hardware
1038:     .qe     (),
1039:     .q      (reg2hw.attest_sw_binding[0].q),
1040:     .ds     (),
1041: 
1042:     // to register interface (read)
1043:     .qs     (attest_sw_binding_0_qs)
1044:   );
1045: 
1046: 
1047:   // Subregister 1 of Multireg attest_sw_binding
1048:   // R[attest_sw_binding_1]: V(False)
1049:   // Create REGWEN-gated WE signal
1050:   logic attest_sw_binding_1_gated_we;
1051:   assign attest_sw_binding_1_gated_we = attest_sw_binding_1_we & sw_binding_regwen_qs;
1052:   prim_subreg #(
1053:     .DW      (32),
1054:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1055:     .RESVAL  (32'h0),
1056:     .Mubi    (1'b0)
1057:   ) u_attest_sw_binding_1 (
1058:     .clk_i   (clk_i),
1059:     .rst_ni  (rst_ni),
1060: 
1061:     // from register interface
1062:     .we     (attest_sw_binding_1_gated_we),
1063:     .wd     (attest_sw_binding_1_wd),
1064: 
1065:     // from internal hardware
1066:     .de     (1'b0),
1067:     .d      ('0),
1068: 
1069:     // to internal hardware
1070:     .qe     (),
1071:     .q      (reg2hw.attest_sw_binding[1].q),
1072:     .ds     (),
1073: 
1074:     // to register interface (read)
1075:     .qs     (attest_sw_binding_1_qs)
1076:   );
1077: 
1078: 
1079:   // Subregister 2 of Multireg attest_sw_binding
1080:   // R[attest_sw_binding_2]: V(False)
1081:   // Create REGWEN-gated WE signal
1082:   logic attest_sw_binding_2_gated_we;
1083:   assign attest_sw_binding_2_gated_we = attest_sw_binding_2_we & sw_binding_regwen_qs;
1084:   prim_subreg #(
1085:     .DW      (32),
1086:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1087:     .RESVAL  (32'h0),
1088:     .Mubi    (1'b0)
1089:   ) u_attest_sw_binding_2 (
1090:     .clk_i   (clk_i),
1091:     .rst_ni  (rst_ni),
1092: 
1093:     // from register interface
1094:     .we     (attest_sw_binding_2_gated_we),
1095:     .wd     (attest_sw_binding_2_wd),
1096: 
1097:     // from internal hardware
1098:     .de     (1'b0),
1099:     .d      ('0),
1100: 
1101:     // to internal hardware
1102:     .qe     (),
1103:     .q      (reg2hw.attest_sw_binding[2].q),
1104:     .ds     (),
1105: 
1106:     // to register interface (read)
1107:     .qs     (attest_sw_binding_2_qs)
1108:   );
1109: 
1110: 
1111:   // Subregister 3 of Multireg attest_sw_binding
1112:   // R[attest_sw_binding_3]: V(False)
1113:   // Create REGWEN-gated WE signal
1114:   logic attest_sw_binding_3_gated_we;
1115:   assign attest_sw_binding_3_gated_we = attest_sw_binding_3_we & sw_binding_regwen_qs;
1116:   prim_subreg #(
1117:     .DW      (32),
1118:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1119:     .RESVAL  (32'h0),
1120:     .Mubi    (1'b0)
1121:   ) u_attest_sw_binding_3 (
1122:     .clk_i   (clk_i),
1123:     .rst_ni  (rst_ni),
1124: 
1125:     // from register interface
1126:     .we     (attest_sw_binding_3_gated_we),
1127:     .wd     (attest_sw_binding_3_wd),
1128: 
1129:     // from internal hardware
1130:     .de     (1'b0),
1131:     .d      ('0),
1132: 
1133:     // to internal hardware
1134:     .qe     (),
1135:     .q      (reg2hw.attest_sw_binding[3].q),
1136:     .ds     (),
1137: 
1138:     // to register interface (read)
1139:     .qs     (attest_sw_binding_3_qs)
1140:   );
1141: 
1142: 
1143:   // Subregister 4 of Multireg attest_sw_binding
1144:   // R[attest_sw_binding_4]: V(False)
1145:   // Create REGWEN-gated WE signal
1146:   logic attest_sw_binding_4_gated_we;
1147:   assign attest_sw_binding_4_gated_we = attest_sw_binding_4_we & sw_binding_regwen_qs;
1148:   prim_subreg #(
1149:     .DW      (32),
1150:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1151:     .RESVAL  (32'h0),
1152:     .Mubi    (1'b0)
1153:   ) u_attest_sw_binding_4 (
1154:     .clk_i   (clk_i),
1155:     .rst_ni  (rst_ni),
1156: 
1157:     // from register interface
1158:     .we     (attest_sw_binding_4_gated_we),
1159:     .wd     (attest_sw_binding_4_wd),
1160: 
1161:     // from internal hardware
1162:     .de     (1'b0),
1163:     .d      ('0),
1164: 
1165:     // to internal hardware
1166:     .qe     (),
1167:     .q      (reg2hw.attest_sw_binding[4].q),
1168:     .ds     (),
1169: 
1170:     // to register interface (read)
1171:     .qs     (attest_sw_binding_4_qs)
1172:   );
1173: 
1174: 
1175:   // Subregister 5 of Multireg attest_sw_binding
1176:   // R[attest_sw_binding_5]: V(False)
1177:   // Create REGWEN-gated WE signal
1178:   logic attest_sw_binding_5_gated_we;
1179:   assign attest_sw_binding_5_gated_we = attest_sw_binding_5_we & sw_binding_regwen_qs;
1180:   prim_subreg #(
1181:     .DW      (32),
1182:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1183:     .RESVAL  (32'h0),
1184:     .Mubi    (1'b0)
1185:   ) u_attest_sw_binding_5 (
1186:     .clk_i   (clk_i),
1187:     .rst_ni  (rst_ni),
1188: 
1189:     // from register interface
1190:     .we     (attest_sw_binding_5_gated_we),
1191:     .wd     (attest_sw_binding_5_wd),
1192: 
1193:     // from internal hardware
1194:     .de     (1'b0),
1195:     .d      ('0),
1196: 
1197:     // to internal hardware
1198:     .qe     (),
1199:     .q      (reg2hw.attest_sw_binding[5].q),
1200:     .ds     (),
1201: 
1202:     // to register interface (read)
1203:     .qs     (attest_sw_binding_5_qs)
1204:   );
1205: 
1206: 
1207:   // Subregister 6 of Multireg attest_sw_binding
1208:   // R[attest_sw_binding_6]: V(False)
1209:   // Create REGWEN-gated WE signal
1210:   logic attest_sw_binding_6_gated_we;
1211:   assign attest_sw_binding_6_gated_we = attest_sw_binding_6_we & sw_binding_regwen_qs;
1212:   prim_subreg #(
1213:     .DW      (32),
1214:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1215:     .RESVAL  (32'h0),
1216:     .Mubi    (1'b0)
1217:   ) u_attest_sw_binding_6 (
1218:     .clk_i   (clk_i),
1219:     .rst_ni  (rst_ni),
1220: 
1221:     // from register interface
1222:     .we     (attest_sw_binding_6_gated_we),
1223:     .wd     (attest_sw_binding_6_wd),
1224: 
1225:     // from internal hardware
1226:     .de     (1'b0),
1227:     .d      ('0),
1228: 
1229:     // to internal hardware
1230:     .qe     (),
1231:     .q      (reg2hw.attest_sw_binding[6].q),
1232:     .ds     (),
1233: 
1234:     // to register interface (read)
1235:     .qs     (attest_sw_binding_6_qs)
1236:   );
1237: 
1238: 
1239:   // Subregister 7 of Multireg attest_sw_binding
1240:   // R[attest_sw_binding_7]: V(False)
1241:   // Create REGWEN-gated WE signal
1242:   logic attest_sw_binding_7_gated_we;
1243:   assign attest_sw_binding_7_gated_we = attest_sw_binding_7_we & sw_binding_regwen_qs;
1244:   prim_subreg #(
1245:     .DW      (32),
1246:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1247:     .RESVAL  (32'h0),
1248:     .Mubi    (1'b0)
1249:   ) u_attest_sw_binding_7 (
1250:     .clk_i   (clk_i),
1251:     .rst_ni  (rst_ni),
1252: 
1253:     // from register interface
1254:     .we     (attest_sw_binding_7_gated_we),
1255:     .wd     (attest_sw_binding_7_wd),
1256: 
1257:     // from internal hardware
1258:     .de     (1'b0),
1259:     .d      ('0),
1260: 
1261:     // to internal hardware
1262:     .qe     (),
1263:     .q      (reg2hw.attest_sw_binding[7].q),
1264:     .ds     (),
1265: 
1266:     // to register interface (read)
1267:     .qs     (attest_sw_binding_7_qs)
1268:   );
1269: 
1270: 
1271:   // Subregister 0 of Multireg salt
1272:   // R[salt_0]: V(False)
1273:   // Create REGWEN-gated WE signal
1274:   logic salt_0_gated_we;
1275:   assign salt_0_gated_we = salt_0_we & cfg_regwen_qs;
1276:   prim_subreg #(
1277:     .DW      (32),
1278:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1279:     .RESVAL  (32'h0),
1280:     .Mubi    (1'b0)
1281:   ) u_salt_0 (
1282:     .clk_i   (clk_i),
1283:     .rst_ni  (rst_ni),
1284: 
1285:     // from register interface
1286:     .we     (salt_0_gated_we),
1287:     .wd     (salt_0_wd),
1288: 
1289:     // from internal hardware
1290:     .de     (1'b0),
1291:     .d      ('0),
1292: 
1293:     // to internal hardware
1294:     .qe     (),
1295:     .q      (reg2hw.salt[0].q),
1296:     .ds     (),
1297: 
1298:     // to register interface (read)
1299:     .qs     (salt_0_qs)
1300:   );
1301: 
1302: 
1303:   // Subregister 1 of Multireg salt
1304:   // R[salt_1]: V(False)
1305:   // Create REGWEN-gated WE signal
1306:   logic salt_1_gated_we;
1307:   assign salt_1_gated_we = salt_1_we & cfg_regwen_qs;
1308:   prim_subreg #(
1309:     .DW      (32),
1310:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1311:     .RESVAL  (32'h0),
1312:     .Mubi    (1'b0)
1313:   ) u_salt_1 (
1314:     .clk_i   (clk_i),
1315:     .rst_ni  (rst_ni),
1316: 
1317:     // from register interface
1318:     .we     (salt_1_gated_we),
1319:     .wd     (salt_1_wd),
1320: 
1321:     // from internal hardware
1322:     .de     (1'b0),
1323:     .d      ('0),
1324: 
1325:     // to internal hardware
1326:     .qe     (),
1327:     .q      (reg2hw.salt[1].q),
1328:     .ds     (),
1329: 
1330:     // to register interface (read)
1331:     .qs     (salt_1_qs)
1332:   );
1333: 
1334: 
1335:   // Subregister 2 of Multireg salt
1336:   // R[salt_2]: V(False)
1337:   // Create REGWEN-gated WE signal
1338:   logic salt_2_gated_we;
1339:   assign salt_2_gated_we = salt_2_we & cfg_regwen_qs;
1340:   prim_subreg #(
1341:     .DW      (32),
1342:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1343:     .RESVAL  (32'h0),
1344:     .Mubi    (1'b0)
1345:   ) u_salt_2 (
1346:     .clk_i   (clk_i),
1347:     .rst_ni  (rst_ni),
1348: 
1349:     // from register interface
1350:     .we     (salt_2_gated_we),
1351:     .wd     (salt_2_wd),
1352: 
1353:     // from internal hardware
1354:     .de     (1'b0),
1355:     .d      ('0),
1356: 
1357:     // to internal hardware
1358:     .qe     (),
1359:     .q      (reg2hw.salt[2].q),
1360:     .ds     (),
1361: 
1362:     // to register interface (read)
1363:     .qs     (salt_2_qs)
1364:   );
1365: 
1366: 
1367:   // Subregister 3 of Multireg salt
1368:   // R[salt_3]: V(False)
1369:   // Create REGWEN-gated WE signal
1370:   logic salt_3_gated_we;
1371:   assign salt_3_gated_we = salt_3_we & cfg_regwen_qs;
1372:   prim_subreg #(
1373:     .DW      (32),
1374:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1375:     .RESVAL  (32'h0),
1376:     .Mubi    (1'b0)
1377:   ) u_salt_3 (
1378:     .clk_i   (clk_i),
1379:     .rst_ni  (rst_ni),
1380: 
1381:     // from register interface
1382:     .we     (salt_3_gated_we),
1383:     .wd     (salt_3_wd),
1384: 
1385:     // from internal hardware
1386:     .de     (1'b0),
1387:     .d      ('0),
1388: 
1389:     // to internal hardware
1390:     .qe     (),
1391:     .q      (reg2hw.salt[3].q),
1392:     .ds     (),
1393: 
1394:     // to register interface (read)
1395:     .qs     (salt_3_qs)
1396:   );
1397: 
1398: 
1399:   // Subregister 4 of Multireg salt
1400:   // R[salt_4]: V(False)
1401:   // Create REGWEN-gated WE signal
1402:   logic salt_4_gated_we;
1403:   assign salt_4_gated_we = salt_4_we & cfg_regwen_qs;
1404:   prim_subreg #(
1405:     .DW      (32),
1406:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1407:     .RESVAL  (32'h0),
1408:     .Mubi    (1'b0)
1409:   ) u_salt_4 (
1410:     .clk_i   (clk_i),
1411:     .rst_ni  (rst_ni),
1412: 
1413:     // from register interface
1414:     .we     (salt_4_gated_we),
1415:     .wd     (salt_4_wd),
1416: 
1417:     // from internal hardware
1418:     .de     (1'b0),
1419:     .d      ('0),
1420: 
1421:     // to internal hardware
1422:     .qe     (),
1423:     .q      (reg2hw.salt[4].q),
1424:     .ds     (),
1425: 
1426:     // to register interface (read)
1427:     .qs     (salt_4_qs)
1428:   );
1429: 
1430: 
1431:   // Subregister 5 of Multireg salt
1432:   // R[salt_5]: V(False)
1433:   // Create REGWEN-gated WE signal
1434:   logic salt_5_gated_we;
1435:   assign salt_5_gated_we = salt_5_we & cfg_regwen_qs;
1436:   prim_subreg #(
1437:     .DW      (32),
1438:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1439:     .RESVAL  (32'h0),
1440:     .Mubi    (1'b0)
1441:   ) u_salt_5 (
1442:     .clk_i   (clk_i),
1443:     .rst_ni  (rst_ni),
1444: 
1445:     // from register interface
1446:     .we     (salt_5_gated_we),
1447:     .wd     (salt_5_wd),
1448: 
1449:     // from internal hardware
1450:     .de     (1'b0),
1451:     .d      ('0),
1452: 
1453:     // to internal hardware
1454:     .qe     (),
1455:     .q      (reg2hw.salt[5].q),
1456:     .ds     (),
1457: 
1458:     // to register interface (read)
1459:     .qs     (salt_5_qs)
1460:   );
1461: 
1462: 
1463:   // Subregister 6 of Multireg salt
1464:   // R[salt_6]: V(False)
1465:   // Create REGWEN-gated WE signal
1466:   logic salt_6_gated_we;
1467:   assign salt_6_gated_we = salt_6_we & cfg_regwen_qs;
1468:   prim_subreg #(
1469:     .DW      (32),
1470:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1471:     .RESVAL  (32'h0),
1472:     .Mubi    (1'b0)
1473:   ) u_salt_6 (
1474:     .clk_i   (clk_i),
1475:     .rst_ni  (rst_ni),
1476: 
1477:     // from register interface
1478:     .we     (salt_6_gated_we),
1479:     .wd     (salt_6_wd),
1480: 
1481:     // from internal hardware
1482:     .de     (1'b0),
1483:     .d      ('0),
1484: 
1485:     // to internal hardware
1486:     .qe     (),
1487:     .q      (reg2hw.salt[6].q),
1488:     .ds     (),
1489: 
1490:     // to register interface (read)
1491:     .qs     (salt_6_qs)
1492:   );
1493: 
1494: 
1495:   // Subregister 7 of Multireg salt
1496:   // R[salt_7]: V(False)
1497:   // Create REGWEN-gated WE signal
1498:   logic salt_7_gated_we;
1499:   assign salt_7_gated_we = salt_7_we & cfg_regwen_qs;
1500:   prim_subreg #(
1501:     .DW      (32),
1502:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1503:     .RESVAL  (32'h0),
1504:     .Mubi    (1'b0)
1505:   ) u_salt_7 (
1506:     .clk_i   (clk_i),
1507:     .rst_ni  (rst_ni),
1508: 
1509:     // from register interface
1510:     .we     (salt_7_gated_we),
1511:     .wd     (salt_7_wd),
1512: 
1513:     // from internal hardware
1514:     .de     (1'b0),
1515:     .d      ('0),
1516: 
1517:     // to internal hardware
1518:     .qe     (),
1519:     .q      (reg2hw.salt[7].q),
1520:     .ds     (),
1521: 
1522:     // to register interface (read)
1523:     .qs     (salt_7_qs)
1524:   );
1525: 
1526: 
1527:   // Subregister 0 of Multireg key_version
1528:   // R[key_version]: V(False)
1529:   // Create REGWEN-gated WE signal
1530:   logic key_version_gated_we;
1531:   assign key_version_gated_we = key_version_we & cfg_regwen_qs;
1532:   prim_subreg #(
1533:     .DW      (32),
1534:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1535:     .RESVAL  (32'h0),
1536:     .Mubi    (1'b0)
1537:   ) u_key_version (
1538:     .clk_i   (clk_i),
1539:     .rst_ni  (rst_ni),
1540: 
1541:     // from register interface
1542:     .we     (key_version_gated_we),
1543:     .wd     (key_version_wd),
1544: 
1545:     // from internal hardware
1546:     .de     (1'b0),
1547:     .d      ('0),
1548: 
1549:     // to internal hardware
1550:     .qe     (),
1551:     .q      (reg2hw.key_version[0].q),
1552:     .ds     (),
1553: 
1554:     // to register interface (read)
1555:     .qs     (key_version_qs)
1556:   );
1557: 
1558: 
1559:   // R[max_creator_key_ver_regwen]: V(False)
1560:   prim_subreg #(
1561:     .DW      (1),
1562:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
1563:     .RESVAL  (1'h1),
1564:     .Mubi    (1'b0)
1565:   ) u_max_creator_key_ver_regwen (
1566:     .clk_i   (clk_i),
1567:     .rst_ni  (rst_ni),
1568: 
1569:     // from register interface
1570:     .we     (max_creator_key_ver_regwen_we),
1571:     .wd     (max_creator_key_ver_regwen_wd),
1572: 
1573:     // from internal hardware
1574:     .de     (1'b0),
1575:     .d      ('0),
1576: 
1577:     // to internal hardware
1578:     .qe     (),
1579:     .q      (),
1580:     .ds     (),
1581: 
1582:     // to register interface (read)
1583:     .qs     (max_creator_key_ver_regwen_qs)
1584:   );
1585: 
1586: 
1587:   // R[max_creator_key_ver_shadowed]: V(False)
1588:   // Create REGWEN-gated WE signal
1589:   logic max_creator_key_ver_shadowed_gated_we;
1590:   assign max_creator_key_ver_shadowed_gated_we =
1591:     max_creator_key_ver_shadowed_we & max_creator_key_ver_regwen_qs;
1592:   prim_subreg_shadow #(
1593:     .DW      (32),
1594:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1595:     .RESVAL  (32'h0),
1596:     .Mubi    (1'b0)
1597:   ) u_max_creator_key_ver_shadowed (
1598:     .clk_i   (clk_i),
1599:     .rst_ni  (rst_ni),
1600:     .rst_shadowed_ni (rst_shadowed_ni),
1601: 
1602:     // from register interface
1603:     .re     (max_creator_key_ver_shadowed_re),
1604:     .we     (max_creator_key_ver_shadowed_gated_we),
1605:     .wd     (max_creator_key_ver_shadowed_wd),
1606: 
1607:     // from internal hardware
1608:     .de     (1'b0),
1609:     .d      ('0),
1610: 
1611:     // to internal hardware
1612:     .qe     (),
1613:     .q      (reg2hw.max_creator_key_ver_shadowed.q),
1614:     .ds     (),
1615: 
1616:     // to register interface (read)
1617:     .qs     (max_creator_key_ver_shadowed_qs),
1618: 
1619:     // Shadow register phase. Relevant for hwext only.
1620:     .phase  (),
1621: 
1622:     // Shadow register error conditions
1623:     .err_update  (max_creator_key_ver_shadowed_update_err),
1624:     .err_storage (max_creator_key_ver_shadowed_storage_err)
1625:   );
1626: 
1627: 
1628:   // R[max_owner_int_key_ver_regwen]: V(False)
1629:   prim_subreg #(
1630:     .DW      (1),
1631:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
1632:     .RESVAL  (1'h1),
1633:     .Mubi    (1'b0)
1634:   ) u_max_owner_int_key_ver_regwen (
1635:     .clk_i   (clk_i),
1636:     .rst_ni  (rst_ni),
1637: 
1638:     // from register interface
1639:     .we     (max_owner_int_key_ver_regwen_we),
1640:     .wd     (max_owner_int_key_ver_regwen_wd),
1641: 
1642:     // from internal hardware
1643:     .de     (1'b0),
1644:     .d      ('0),
1645: 
1646:     // to internal hardware
1647:     .qe     (),
1648:     .q      (),
1649:     .ds     (),
1650: 
1651:     // to register interface (read)
1652:     .qs     (max_owner_int_key_ver_regwen_qs)
1653:   );
1654: 
1655: 
1656:   // R[max_owner_int_key_ver_shadowed]: V(False)
1657:   // Create REGWEN-gated WE signal
1658:   logic max_owner_int_key_ver_shadowed_gated_we;
1659:   assign max_owner_int_key_ver_shadowed_gated_we =
1660:     max_owner_int_key_ver_shadowed_we & max_owner_int_key_ver_regwen_qs;
1661:   prim_subreg_shadow #(
1662:     .DW      (32),
1663:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1664:     .RESVAL  (32'h1),
1665:     .Mubi    (1'b0)
1666:   ) u_max_owner_int_key_ver_shadowed (
1667:     .clk_i   (clk_i),
1668:     .rst_ni  (rst_ni),
1669:     .rst_shadowed_ni (rst_shadowed_ni),
1670: 
1671:     // from register interface
1672:     .re     (max_owner_int_key_ver_shadowed_re),
1673:     .we     (max_owner_int_key_ver_shadowed_gated_we),
1674:     .wd     (max_owner_int_key_ver_shadowed_wd),
1675: 
1676:     // from internal hardware
1677:     .de     (1'b0),
1678:     .d      ('0),
1679: 
1680:     // to internal hardware
1681:     .qe     (),
1682:     .q      (reg2hw.max_owner_int_key_ver_shadowed.q),
1683:     .ds     (),
1684: 
1685:     // to register interface (read)
1686:     .qs     (max_owner_int_key_ver_shadowed_qs),
1687: 
1688:     // Shadow register phase. Relevant for hwext only.
1689:     .phase  (),
1690: 
1691:     // Shadow register error conditions
1692:     .err_update  (max_owner_int_key_ver_shadowed_update_err),
1693:     .err_storage (max_owner_int_key_ver_shadowed_storage_err)
1694:   );
1695: 
1696: 
1697:   // R[max_owner_key_ver_regwen]: V(False)
1698:   prim_subreg #(
1699:     .DW      (1),
1700:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
1701:     .RESVAL  (1'h1),
1702:     .Mubi    (1'b0)
1703:   ) u_max_owner_key_ver_regwen (
1704:     .clk_i   (clk_i),
1705:     .rst_ni  (rst_ni),
1706: 
1707:     // from register interface
1708:     .we     (max_owner_key_ver_regwen_we),
1709:     .wd     (max_owner_key_ver_regwen_wd),
1710: 
1711:     // from internal hardware
1712:     .de     (1'b0),
1713:     .d      ('0),
1714: 
1715:     // to internal hardware
1716:     .qe     (),
1717:     .q      (),
1718:     .ds     (),
1719: 
1720:     // to register interface (read)
1721:     .qs     (max_owner_key_ver_regwen_qs)
1722:   );
1723: 
1724: 
1725:   // R[max_owner_key_ver_shadowed]: V(False)
1726:   // Create REGWEN-gated WE signal
1727:   logic max_owner_key_ver_shadowed_gated_we;
1728:   assign max_owner_key_ver_shadowed_gated_we =
1729:     max_owner_key_ver_shadowed_we & max_owner_key_ver_regwen_qs;
1730:   prim_subreg_shadow #(
1731:     .DW      (32),
1732:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1733:     .RESVAL  (32'h0),
1734:     .Mubi    (1'b0)
1735:   ) u_max_owner_key_ver_shadowed (
1736:     .clk_i   (clk_i),
1737:     .rst_ni  (rst_ni),
1738:     .rst_shadowed_ni (rst_shadowed_ni),
1739: 
1740:     // from register interface
1741:     .re     (max_owner_key_ver_shadowed_re),
1742:     .we     (max_owner_key_ver_shadowed_gated_we),
1743:     .wd     (max_owner_key_ver_shadowed_wd),
1744: 
1745:     // from internal hardware
1746:     .de     (1'b0),
1747:     .d      ('0),
1748: 
1749:     // to internal hardware
1750:     .qe     (),
1751:     .q      (reg2hw.max_owner_key_ver_shadowed.q),
1752:     .ds     (),
1753: 
1754:     // to register interface (read)
1755:     .qs     (max_owner_key_ver_shadowed_qs),
1756: 
1757:     // Shadow register phase. Relevant for hwext only.
1758:     .phase  (),
1759: 
1760:     // Shadow register error conditions
1761:     .err_update  (max_owner_key_ver_shadowed_update_err),
1762:     .err_storage (max_owner_key_ver_shadowed_storage_err)
1763:   );
1764: 
1765: 
1766:   // Subregister 0 of Multireg sw_share0_output
1767:   // R[sw_share0_output_0]: V(False)
1768:   prim_subreg #(
1769:     .DW      (32),
1770:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1771:     .RESVAL  (32'h0),
1772:     .Mubi    (1'b0)
1773:   ) u_sw_share0_output_0 (
1774:     .clk_i   (clk_i),
1775:     .rst_ni  (rst_ni),
1776: 
1777:     // from register interface
1778:     .we     (sw_share0_output_0_re),
1779:     .wd     (sw_share0_output_0_wd),
1780: 
1781:     // from internal hardware
1782:     .de     (hw2reg.sw_share0_output[0].de),
1783:     .d      (hw2reg.sw_share0_output[0].d),
1784: 
1785:     // to internal hardware
1786:     .qe     (),
1787:     .q      (),
1788:     .ds     (),
1789: 
1790:     // to register interface (read)
1791:     .qs     (sw_share0_output_0_qs)
1792:   );
1793: 
1794: 
1795:   // Subregister 1 of Multireg sw_share0_output
1796:   // R[sw_share0_output_1]: V(False)
1797:   prim_subreg #(
1798:     .DW      (32),
1799:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1800:     .RESVAL  (32'h0),
1801:     .Mubi    (1'b0)
1802:   ) u_sw_share0_output_1 (
1803:     .clk_i   (clk_i),
1804:     .rst_ni  (rst_ni),
1805: 
1806:     // from register interface
1807:     .we     (sw_share0_output_1_re),
1808:     .wd     (sw_share0_output_1_wd),
1809: 
1810:     // from internal hardware
1811:     .de     (hw2reg.sw_share0_output[1].de),
1812:     .d      (hw2reg.sw_share0_output[1].d),
1813: 
1814:     // to internal hardware
1815:     .qe     (),
1816:     .q      (),
1817:     .ds     (),
1818: 
1819:     // to register interface (read)
1820:     .qs     (sw_share0_output_1_qs)
1821:   );
1822: 
1823: 
1824:   // Subregister 2 of Multireg sw_share0_output
1825:   // R[sw_share0_output_2]: V(False)
1826:   prim_subreg #(
1827:     .DW      (32),
1828:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1829:     .RESVAL  (32'h0),
1830:     .Mubi    (1'b0)
1831:   ) u_sw_share0_output_2 (
1832:     .clk_i   (clk_i),
1833:     .rst_ni  (rst_ni),
1834: 
1835:     // from register interface
1836:     .we     (sw_share0_output_2_re),
1837:     .wd     (sw_share0_output_2_wd),
1838: 
1839:     // from internal hardware
1840:     .de     (hw2reg.sw_share0_output[2].de),
1841:     .d      (hw2reg.sw_share0_output[2].d),
1842: 
1843:     // to internal hardware
1844:     .qe     (),
1845:     .q      (),
1846:     .ds     (),
1847: 
1848:     // to register interface (read)
1849:     .qs     (sw_share0_output_2_qs)
1850:   );
1851: 
1852: 
1853:   // Subregister 3 of Multireg sw_share0_output
1854:   // R[sw_share0_output_3]: V(False)
1855:   prim_subreg #(
1856:     .DW      (32),
1857:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1858:     .RESVAL  (32'h0),
1859:     .Mubi    (1'b0)
1860:   ) u_sw_share0_output_3 (
1861:     .clk_i   (clk_i),
1862:     .rst_ni  (rst_ni),
1863: 
1864:     // from register interface
1865:     .we     (sw_share0_output_3_re),
1866:     .wd     (sw_share0_output_3_wd),
1867: 
1868:     // from internal hardware
1869:     .de     (hw2reg.sw_share0_output[3].de),
1870:     .d      (hw2reg.sw_share0_output[3].d),
1871: 
1872:     // to internal hardware
1873:     .qe     (),
1874:     .q      (),
1875:     .ds     (),
1876: 
1877:     // to register interface (read)
1878:     .qs     (sw_share0_output_3_qs)
1879:   );
1880: 
1881: 
1882:   // Subregister 4 of Multireg sw_share0_output
1883:   // R[sw_share0_output_4]: V(False)
1884:   prim_subreg #(
1885:     .DW      (32),
1886:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1887:     .RESVAL  (32'h0),
1888:     .Mubi    (1'b0)
1889:   ) u_sw_share0_output_4 (
1890:     .clk_i   (clk_i),
1891:     .rst_ni  (rst_ni),
1892: 
1893:     // from register interface
1894:     .we     (sw_share0_output_4_re),
1895:     .wd     (sw_share0_output_4_wd),
1896: 
1897:     // from internal hardware
1898:     .de     (hw2reg.sw_share0_output[4].de),
1899:     .d      (hw2reg.sw_share0_output[4].d),
1900: 
1901:     // to internal hardware
1902:     .qe     (),
1903:     .q      (),
1904:     .ds     (),
1905: 
1906:     // to register interface (read)
1907:     .qs     (sw_share0_output_4_qs)
1908:   );
1909: 
1910: 
1911:   // Subregister 5 of Multireg sw_share0_output
1912:   // R[sw_share0_output_5]: V(False)
1913:   prim_subreg #(
1914:     .DW      (32),
1915:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1916:     .RESVAL  (32'h0),
1917:     .Mubi    (1'b0)
1918:   ) u_sw_share0_output_5 (
1919:     .clk_i   (clk_i),
1920:     .rst_ni  (rst_ni),
1921: 
1922:     // from register interface
1923:     .we     (sw_share0_output_5_re),
1924:     .wd     (sw_share0_output_5_wd),
1925: 
1926:     // from internal hardware
1927:     .de     (hw2reg.sw_share0_output[5].de),
1928:     .d      (hw2reg.sw_share0_output[5].d),
1929: 
1930:     // to internal hardware
1931:     .qe     (),
1932:     .q      (),
1933:     .ds     (),
1934: 
1935:     // to register interface (read)
1936:     .qs     (sw_share0_output_5_qs)
1937:   );
1938: 
1939: 
1940:   // Subregister 6 of Multireg sw_share0_output
1941:   // R[sw_share0_output_6]: V(False)
1942:   prim_subreg #(
1943:     .DW      (32),
1944:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1945:     .RESVAL  (32'h0),
1946:     .Mubi    (1'b0)
1947:   ) u_sw_share0_output_6 (
1948:     .clk_i   (clk_i),
1949:     .rst_ni  (rst_ni),
1950: 
1951:     // from register interface
1952:     .we     (sw_share0_output_6_re),
1953:     .wd     (sw_share0_output_6_wd),
1954: 
1955:     // from internal hardware
1956:     .de     (hw2reg.sw_share0_output[6].de),
1957:     .d      (hw2reg.sw_share0_output[6].d),
1958: 
1959:     // to internal hardware
1960:     .qe     (),
1961:     .q      (),
1962:     .ds     (),
1963: 
1964:     // to register interface (read)
1965:     .qs     (sw_share0_output_6_qs)
1966:   );
1967: 
1968: 
1969:   // Subregister 7 of Multireg sw_share0_output
1970:   // R[sw_share0_output_7]: V(False)
1971:   prim_subreg #(
1972:     .DW      (32),
1973:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1974:     .RESVAL  (32'h0),
1975:     .Mubi    (1'b0)
1976:   ) u_sw_share0_output_7 (
1977:     .clk_i   (clk_i),
1978:     .rst_ni  (rst_ni),
1979: 
1980:     // from register interface
1981:     .we     (sw_share0_output_7_re),
1982:     .wd     (sw_share0_output_7_wd),
1983: 
1984:     // from internal hardware
1985:     .de     (hw2reg.sw_share0_output[7].de),
1986:     .d      (hw2reg.sw_share0_output[7].d),
1987: 
1988:     // to internal hardware
1989:     .qe     (),
1990:     .q      (),
1991:     .ds     (),
1992: 
1993:     // to register interface (read)
1994:     .qs     (sw_share0_output_7_qs)
1995:   );
1996: 
1997: 
1998:   // Subregister 0 of Multireg sw_share1_output
1999:   // R[sw_share1_output_0]: V(False)
2000:   prim_subreg #(
2001:     .DW      (32),
2002:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2003:     .RESVAL  (32'h0),
2004:     .Mubi    (1'b0)
2005:   ) u_sw_share1_output_0 (
2006:     .clk_i   (clk_i),
2007:     .rst_ni  (rst_ni),
2008: 
2009:     // from register interface
2010:     .we     (sw_share1_output_0_re),
2011:     .wd     (sw_share1_output_0_wd),
2012: 
2013:     // from internal hardware
2014:     .de     (hw2reg.sw_share1_output[0].de),
2015:     .d      (hw2reg.sw_share1_output[0].d),
2016: 
2017:     // to internal hardware
2018:     .qe     (),
2019:     .q      (),
2020:     .ds     (),
2021: 
2022:     // to register interface (read)
2023:     .qs     (sw_share1_output_0_qs)
2024:   );
2025: 
2026: 
2027:   // Subregister 1 of Multireg sw_share1_output
2028:   // R[sw_share1_output_1]: V(False)
2029:   prim_subreg #(
2030:     .DW      (32),
2031:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2032:     .RESVAL  (32'h0),
2033:     .Mubi    (1'b0)
2034:   ) u_sw_share1_output_1 (
2035:     .clk_i   (clk_i),
2036:     .rst_ni  (rst_ni),
2037: 
2038:     // from register interface
2039:     .we     (sw_share1_output_1_re),
2040:     .wd     (sw_share1_output_1_wd),
2041: 
2042:     // from internal hardware
2043:     .de     (hw2reg.sw_share1_output[1].de),
2044:     .d      (hw2reg.sw_share1_output[1].d),
2045: 
2046:     // to internal hardware
2047:     .qe     (),
2048:     .q      (),
2049:     .ds     (),
2050: 
2051:     // to register interface (read)
2052:     .qs     (sw_share1_output_1_qs)
2053:   );
2054: 
2055: 
2056:   // Subregister 2 of Multireg sw_share1_output
2057:   // R[sw_share1_output_2]: V(False)
2058:   prim_subreg #(
2059:     .DW      (32),
2060:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2061:     .RESVAL  (32'h0),
2062:     .Mubi    (1'b0)
2063:   ) u_sw_share1_output_2 (
2064:     .clk_i   (clk_i),
2065:     .rst_ni  (rst_ni),
2066: 
2067:     // from register interface
2068:     .we     (sw_share1_output_2_re),
2069:     .wd     (sw_share1_output_2_wd),
2070: 
2071:     // from internal hardware
2072:     .de     (hw2reg.sw_share1_output[2].de),
2073:     .d      (hw2reg.sw_share1_output[2].d),
2074: 
2075:     // to internal hardware
2076:     .qe     (),
2077:     .q      (),
2078:     .ds     (),
2079: 
2080:     // to register interface (read)
2081:     .qs     (sw_share1_output_2_qs)
2082:   );
2083: 
2084: 
2085:   // Subregister 3 of Multireg sw_share1_output
2086:   // R[sw_share1_output_3]: V(False)
2087:   prim_subreg #(
2088:     .DW      (32),
2089:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2090:     .RESVAL  (32'h0),
2091:     .Mubi    (1'b0)
2092:   ) u_sw_share1_output_3 (
2093:     .clk_i   (clk_i),
2094:     .rst_ni  (rst_ni),
2095: 
2096:     // from register interface
2097:     .we     (sw_share1_output_3_re),
2098:     .wd     (sw_share1_output_3_wd),
2099: 
2100:     // from internal hardware
2101:     .de     (hw2reg.sw_share1_output[3].de),
2102:     .d      (hw2reg.sw_share1_output[3].d),
2103: 
2104:     // to internal hardware
2105:     .qe     (),
2106:     .q      (),
2107:     .ds     (),
2108: 
2109:     // to register interface (read)
2110:     .qs     (sw_share1_output_3_qs)
2111:   );
2112: 
2113: 
2114:   // Subregister 4 of Multireg sw_share1_output
2115:   // R[sw_share1_output_4]: V(False)
2116:   prim_subreg #(
2117:     .DW      (32),
2118:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2119:     .RESVAL  (32'h0),
2120:     .Mubi    (1'b0)
2121:   ) u_sw_share1_output_4 (
2122:     .clk_i   (clk_i),
2123:     .rst_ni  (rst_ni),
2124: 
2125:     // from register interface
2126:     .we     (sw_share1_output_4_re),
2127:     .wd     (sw_share1_output_4_wd),
2128: 
2129:     // from internal hardware
2130:     .de     (hw2reg.sw_share1_output[4].de),
2131:     .d      (hw2reg.sw_share1_output[4].d),
2132: 
2133:     // to internal hardware
2134:     .qe     (),
2135:     .q      (),
2136:     .ds     (),
2137: 
2138:     // to register interface (read)
2139:     .qs     (sw_share1_output_4_qs)
2140:   );
2141: 
2142: 
2143:   // Subregister 5 of Multireg sw_share1_output
2144:   // R[sw_share1_output_5]: V(False)
2145:   prim_subreg #(
2146:     .DW      (32),
2147:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2148:     .RESVAL  (32'h0),
2149:     .Mubi    (1'b0)
2150:   ) u_sw_share1_output_5 (
2151:     .clk_i   (clk_i),
2152:     .rst_ni  (rst_ni),
2153: 
2154:     // from register interface
2155:     .we     (sw_share1_output_5_re),
2156:     .wd     (sw_share1_output_5_wd),
2157: 
2158:     // from internal hardware
2159:     .de     (hw2reg.sw_share1_output[5].de),
2160:     .d      (hw2reg.sw_share1_output[5].d),
2161: 
2162:     // to internal hardware
2163:     .qe     (),
2164:     .q      (),
2165:     .ds     (),
2166: 
2167:     // to register interface (read)
2168:     .qs     (sw_share1_output_5_qs)
2169:   );
2170: 
2171: 
2172:   // Subregister 6 of Multireg sw_share1_output
2173:   // R[sw_share1_output_6]: V(False)
2174:   prim_subreg #(
2175:     .DW      (32),
2176:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2177:     .RESVAL  (32'h0),
2178:     .Mubi    (1'b0)
2179:   ) u_sw_share1_output_6 (
2180:     .clk_i   (clk_i),
2181:     .rst_ni  (rst_ni),
2182: 
2183:     // from register interface
2184:     .we     (sw_share1_output_6_re),
2185:     .wd     (sw_share1_output_6_wd),
2186: 
2187:     // from internal hardware
2188:     .de     (hw2reg.sw_share1_output[6].de),
2189:     .d      (hw2reg.sw_share1_output[6].d),
2190: 
2191:     // to internal hardware
2192:     .qe     (),
2193:     .q      (),
2194:     .ds     (),
2195: 
2196:     // to register interface (read)
2197:     .qs     (sw_share1_output_6_qs)
2198:   );
2199: 
2200: 
2201:   // Subregister 7 of Multireg sw_share1_output
2202:   // R[sw_share1_output_7]: V(False)
2203:   prim_subreg #(
2204:     .DW      (32),
2205:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2206:     .RESVAL  (32'h0),
2207:     .Mubi    (1'b0)
2208:   ) u_sw_share1_output_7 (
2209:     .clk_i   (clk_i),
2210:     .rst_ni  (rst_ni),
2211: 
2212:     // from register interface
2213:     .we     (sw_share1_output_7_re),
2214:     .wd     (sw_share1_output_7_wd),
2215: 
2216:     // from internal hardware
2217:     .de     (hw2reg.sw_share1_output[7].de),
2218:     .d      (hw2reg.sw_share1_output[7].d),
2219: 
2220:     // to internal hardware
2221:     .qe     (),
2222:     .q      (),
2223:     .ds     (),
2224: 
2225:     // to register interface (read)
2226:     .qs     (sw_share1_output_7_qs)
2227:   );
2228: 
2229: 
2230:   // R[working_state]: V(False)
2231:   prim_subreg #(
2232:     .DW      (3),
2233:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2234:     .RESVAL  (3'h0),
2235:     .Mubi    (1'b0)
2236:   ) u_working_state (
2237:     .clk_i   (clk_i),
2238:     .rst_ni  (rst_ni),
2239: 
2240:     // from register interface
2241:     .we     (1'b0),
2242:     .wd     ('0),
2243: 
2244:     // from internal hardware
2245:     .de     (hw2reg.working_state.de),
2246:     .d      (hw2reg.working_state.d),
2247: 
2248:     // to internal hardware
2249:     .qe     (),
2250:     .q      (),
2251:     .ds     (),
2252: 
2253:     // to register interface (read)
2254:     .qs     (working_state_qs)
2255:   );
2256: 
2257: 
2258:   // R[op_status]: V(False)
2259:   prim_subreg #(
2260:     .DW      (2),
2261:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
2262:     .RESVAL  (2'h0),
2263:     .Mubi    (1'b0)
2264:   ) u_op_status (
2265:     .clk_i   (clk_i),
2266:     .rst_ni  (rst_ni),
2267: 
2268:     // from register interface
2269:     .we     (op_status_we),
2270:     .wd     (op_status_wd),
2271: 
2272:     // from internal hardware
2273:     .de     (hw2reg.op_status.de),
2274:     .d      (hw2reg.op_status.d),
2275: 
2276:     // to internal hardware
2277:     .qe     (),
2278:     .q      (),
2279:     .ds     (),
2280: 
2281:     // to register interface (read)
2282:     .qs     (op_status_qs)
2283:   );
2284: 
2285: 
2286:   // R[err_code]: V(False)
2287:   //   F[invalid_op]: 0:0
2288:   prim_subreg #(
2289:     .DW      (1),
2290:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
2291:     .RESVAL  (1'h0),
2292:     .Mubi    (1'b0)
2293:   ) u_err_code_invalid_op (
2294:     .clk_i   (clk_i),
2295:     .rst_ni  (rst_ni),
2296: 
2297:     // from register interface
2298:     .we     (err_code_we),
2299:     .wd     (err_code_invalid_op_wd),
2300: 
2301:     // from internal hardware
2302:     .de     (hw2reg.err_code.invalid_op.de),
2303:     .d      (hw2reg.err_code.invalid_op.d),
2304: 
2305:     // to internal hardware
2306:     .qe     (),
2307:     .q      (),
2308:     .ds     (),
2309: 
2310:     // to register interface (read)
2311:     .qs     (err_code_invalid_op_qs)
2312:   );
2313: 
2314:   //   F[invalid_kmac_input]: 1:1
2315:   prim_subreg #(
2316:     .DW      (1),
2317:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
2318:     .RESVAL  (1'h0),
2319:     .Mubi    (1'b0)
2320:   ) u_err_code_invalid_kmac_input (
2321:     .clk_i   (clk_i),
2322:     .rst_ni  (rst_ni),
2323: 
2324:     // from register interface
2325:     .we     (err_code_we),
2326:     .wd     (err_code_invalid_kmac_input_wd),
2327: 
2328:     // from internal hardware
2329:     .de     (hw2reg.err_code.invalid_kmac_input.de),
2330:     .d      (hw2reg.err_code.invalid_kmac_input.d),
2331: 
2332:     // to internal hardware
2333:     .qe     (),
2334:     .q      (),
2335:     .ds     (),
2336: 
2337:     // to register interface (read)
2338:     .qs     (err_code_invalid_kmac_input_qs)
2339:   );
2340: 
2341:   //   F[invalid_shadow_update]: 2:2
2342:   prim_subreg #(
2343:     .DW      (1),
2344:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
2345:     .RESVAL  (1'h0),
2346:     .Mubi    (1'b0)
2347:   ) u_err_code_invalid_shadow_update (
2348:     .clk_i   (clk_i),
2349:     .rst_ni  (rst_ni),
2350: 
2351:     // from register interface
2352:     .we     (err_code_we),
2353:     .wd     (err_code_invalid_shadow_update_wd),
2354: 
2355:     // from internal hardware
2356:     .de     (hw2reg.err_code.invalid_shadow_update.de),
2357:     .d      (hw2reg.err_code.invalid_shadow_update.d),
2358: 
2359:     // to internal hardware
2360:     .qe     (),
2361:     .q      (),
2362:     .ds     (),
2363: 
2364:     // to register interface (read)
2365:     .qs     (err_code_invalid_shadow_update_qs)
2366:   );
2367: 
2368: 
2369:   // R[fault_status]: V(False)
2370:   //   F[cmd]: 0:0
2371:   prim_subreg #(
2372:     .DW      (1),
2373:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2374:     .RESVAL  (1'h0),
2375:     .Mubi    (1'b0)
2376:   ) u_fault_status_cmd (
2377:     .clk_i   (clk_i),
2378:     .rst_ni  (rst_ni),
2379: 
2380:     // from register interface
2381:     .we     (1'b0),
2382:     .wd     ('0),
2383: 
2384:     // from internal hardware
2385:     .de     (hw2reg.fault_status.cmd.de),
2386:     .d      (hw2reg.fault_status.cmd.d),
2387: 
2388:     // to internal hardware
2389:     .qe     (),
2390:     .q      (reg2hw.fault_status.cmd.q),
2391:     .ds     (),
2392: 
2393:     // to register interface (read)
2394:     .qs     (fault_status_cmd_qs)
2395:   );
2396: 
2397:   //   F[kmac_fsm]: 1:1
2398:   prim_subreg #(
2399:     .DW      (1),
2400:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2401:     .RESVAL  (1'h0),
2402:     .Mubi    (1'b0)
2403:   ) u_fault_status_kmac_fsm (
2404:     .clk_i   (clk_i),
2405:     .rst_ni  (rst_ni),
2406: 
2407:     // from register interface
2408:     .we     (1'b0),
2409:     .wd     ('0),
2410: 
2411:     // from internal hardware
2412:     .de     (hw2reg.fault_status.kmac_fsm.de),
2413:     .d      (hw2reg.fault_status.kmac_fsm.d),
2414: 
2415:     // to internal hardware
2416:     .qe     (),
2417:     .q      (reg2hw.fault_status.kmac_fsm.q),
2418:     .ds     (),
2419: 
2420:     // to register interface (read)
2421:     .qs     (fault_status_kmac_fsm_qs)
2422:   );
2423: 
2424:   //   F[kmac_done]: 2:2
2425:   prim_subreg #(
2426:     .DW      (1),
2427:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2428:     .RESVAL  (1'h0),
2429:     .Mubi    (1'b0)
2430:   ) u_fault_status_kmac_done (
2431:     .clk_i   (clk_i),
2432:     .rst_ni  (rst_ni),
2433: 
2434:     // from register interface
2435:     .we     (1'b0),
2436:     .wd     ('0),
2437: 
2438:     // from internal hardware
2439:     .de     (hw2reg.fault_status.kmac_done.de),
2440:     .d      (hw2reg.fault_status.kmac_done.d),
2441: 
2442:     // to internal hardware
2443:     .qe     (),
2444:     .q      (reg2hw.fault_status.kmac_done.q),
2445:     .ds     (),
2446: 
2447:     // to register interface (read)
2448:     .qs     (fault_status_kmac_done_qs)
2449:   );
2450: 
2451:   //   F[kmac_op]: 3:3
2452:   prim_subreg #(
2453:     .DW      (1),
2454:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2455:     .RESVAL  (1'h0),
2456:     .Mubi    (1'b0)
2457:   ) u_fault_status_kmac_op (
2458:     .clk_i   (clk_i),
2459:     .rst_ni  (rst_ni),
2460: 
2461:     // from register interface
2462:     .we     (1'b0),
2463:     .wd     ('0),
2464: 
2465:     // from internal hardware
2466:     .de     (hw2reg.fault_status.kmac_op.de),
2467:     .d      (hw2reg.fault_status.kmac_op.d),
2468: 
2469:     // to internal hardware
2470:     .qe     (),
2471:     .q      (reg2hw.fault_status.kmac_op.q),
2472:     .ds     (),
2473: 
2474:     // to register interface (read)
2475:     .qs     (fault_status_kmac_op_qs)
2476:   );
2477: 
2478:   //   F[kmac_out]: 4:4
2479:   prim_subreg #(
2480:     .DW      (1),
2481:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2482:     .RESVAL  (1'h0),
2483:     .Mubi    (1'b0)
2484:   ) u_fault_status_kmac_out (
2485:     .clk_i   (clk_i),
2486:     .rst_ni  (rst_ni),
2487: 
2488:     // from register interface
2489:     .we     (1'b0),
2490:     .wd     ('0),
2491: 
2492:     // from internal hardware
2493:     .de     (hw2reg.fault_status.kmac_out.de),
2494:     .d      (hw2reg.fault_status.kmac_out.d),
2495: 
2496:     // to internal hardware
2497:     .qe     (),
2498:     .q      (reg2hw.fault_status.kmac_out.q),
2499:     .ds     (),
2500: 
2501:     // to register interface (read)
2502:     .qs     (fault_status_kmac_out_qs)
2503:   );
2504: 
2505:   //   F[regfile_intg]: 5:5
2506:   prim_subreg #(
2507:     .DW      (1),
2508:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2509:     .RESVAL  (1'h0),
2510:     .Mubi    (1'b0)
2511:   ) u_fault_status_regfile_intg (
2512:     .clk_i   (clk_i),
2513:     .rst_ni  (rst_ni),
2514: 
2515:     // from register interface
2516:     .we     (1'b0),
2517:     .wd     ('0),
2518: 
2519:     // from internal hardware
2520:     .de     (hw2reg.fault_status.regfile_intg.de),
2521:     .d      (hw2reg.fault_status.regfile_intg.d),
2522: 
2523:     // to internal hardware
2524:     .qe     (),
2525:     .q      (reg2hw.fault_status.regfile_intg.q),
2526:     .ds     (),
2527: 
2528:     // to register interface (read)
2529:     .qs     (fault_status_regfile_intg_qs)
2530:   );
2531: 
2532:   //   F[shadow]: 6:6
2533:   prim_subreg #(
2534:     .DW      (1),
2535:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2536:     .RESVAL  (1'h0),
2537:     .Mubi    (1'b0)
2538:   ) u_fault_status_shadow (
2539:     .clk_i   (clk_i),
2540:     .rst_ni  (rst_ni),
2541: 
2542:     // from register interface
2543:     .we     (1'b0),
2544:     .wd     ('0),
2545: 
2546:     // from internal hardware
2547:     .de     (hw2reg.fault_status.shadow.de),
2548:     .d      (hw2reg.fault_status.shadow.d),
2549: 
2550:     // to internal hardware
2551:     .qe     (),
2552:     .q      (reg2hw.fault_status.shadow.q),
2553:     .ds     (),
2554: 
2555:     // to register interface (read)
2556:     .qs     (fault_status_shadow_qs)
2557:   );
2558: 
2559:   //   F[ctrl_fsm_intg]: 7:7
2560:   prim_subreg #(
2561:     .DW      (1),
2562:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2563:     .RESVAL  (1'h0),
2564:     .Mubi    (1'b0)
2565:   ) u_fault_status_ctrl_fsm_intg (
2566:     .clk_i   (clk_i),
2567:     .rst_ni  (rst_ni),
2568: 
2569:     // from register interface
2570:     .we     (1'b0),
2571:     .wd     ('0),
2572: 
2573:     // from internal hardware
2574:     .de     (hw2reg.fault_status.ctrl_fsm_intg.de),
2575:     .d      (hw2reg.fault_status.ctrl_fsm_intg.d),
2576: 
2577:     // to internal hardware
2578:     .qe     (),
2579:     .q      (reg2hw.fault_status.ctrl_fsm_intg.q),
2580:     .ds     (),
2581: 
2582:     // to register interface (read)
2583:     .qs     (fault_status_ctrl_fsm_intg_qs)
2584:   );
2585: 
2586:   //   F[ctrl_fsm_chk]: 8:8
2587:   prim_subreg #(
2588:     .DW      (1),
2589:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2590:     .RESVAL  (1'h0),
2591:     .Mubi    (1'b0)
2592:   ) u_fault_status_ctrl_fsm_chk (
2593:     .clk_i   (clk_i),
2594:     .rst_ni  (rst_ni),
2595: 
2596:     // from register interface
2597:     .we     (1'b0),
2598:     .wd     ('0),
2599: 
2600:     // from internal hardware
2601:     .de     (hw2reg.fault_status.ctrl_fsm_chk.de),
2602:     .d      (hw2reg.fault_status.ctrl_fsm_chk.d),
2603: 
2604:     // to internal hardware
2605:     .qe     (),
2606:     .q      (reg2hw.fault_status.ctrl_fsm_chk.q),
2607:     .ds     (),
2608: 
2609:     // to register interface (read)
2610:     .qs     (fault_status_ctrl_fsm_chk_qs)
2611:   );
2612: 
2613:   //   F[ctrl_fsm_cnt]: 9:9
2614:   prim_subreg #(
2615:     .DW      (1),
2616:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2617:     .RESVAL  (1'h0),
2618:     .Mubi    (1'b0)
2619:   ) u_fault_status_ctrl_fsm_cnt (
2620:     .clk_i   (clk_i),
2621:     .rst_ni  (rst_ni),
2622: 
2623:     // from register interface
2624:     .we     (1'b0),
2625:     .wd     ('0),
2626: 
2627:     // from internal hardware
2628:     .de     (hw2reg.fault_status.ctrl_fsm_cnt.de),
2629:     .d      (hw2reg.fault_status.ctrl_fsm_cnt.d),
2630: 
2631:     // to internal hardware
2632:     .qe     (),
2633:     .q      (reg2hw.fault_status.ctrl_fsm_cnt.q),
2634:     .ds     (),
2635: 
2636:     // to register interface (read)
2637:     .qs     (fault_status_ctrl_fsm_cnt_qs)
2638:   );
2639: 
2640:   //   F[reseed_cnt]: 10:10
2641:   prim_subreg #(
2642:     .DW      (1),
2643:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2644:     .RESVAL  (1'h0),
2645:     .Mubi    (1'b0)
2646:   ) u_fault_status_reseed_cnt (
2647:     .clk_i   (clk_i),
2648:     .rst_ni  (rst_ni),
2649: 
2650:     // from register interface
2651:     .we     (1'b0),
2652:     .wd     ('0),
2653: 
2654:     // from internal hardware
2655:     .de     (hw2reg.fault_status.reseed_cnt.de),
2656:     .d      (hw2reg.fault_status.reseed_cnt.d),
2657: 
2658:     // to internal hardware
2659:     .qe     (),
2660:     .q      (reg2hw.fault_status.reseed_cnt.q),
2661:     .ds     (),
2662: 
2663:     // to register interface (read)
2664:     .qs     (fault_status_reseed_cnt_qs)
2665:   );
2666: 
2667:   //   F[side_ctrl_fsm]: 11:11
2668:   prim_subreg #(
2669:     .DW      (1),
2670:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2671:     .RESVAL  (1'h0),
2672:     .Mubi    (1'b0)
2673:   ) u_fault_status_side_ctrl_fsm (
2674:     .clk_i   (clk_i),
2675:     .rst_ni  (rst_ni),
2676: 
2677:     // from register interface
2678:     .we     (1'b0),
2679:     .wd     ('0),
2680: 
2681:     // from internal hardware
2682:     .de     (hw2reg.fault_status.side_ctrl_fsm.de),
2683:     .d      (hw2reg.fault_status.side_ctrl_fsm.d),
2684: 
2685:     // to internal hardware
2686:     .qe     (),
2687:     .q      (reg2hw.fault_status.side_ctrl_fsm.q),
2688:     .ds     (),
2689: 
2690:     // to register interface (read)
2691:     .qs     (fault_status_side_ctrl_fsm_qs)
2692:   );
2693: 
2694:   //   F[side_ctrl_sel]: 12:12
2695:   prim_subreg #(
2696:     .DW      (1),
2697:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2698:     .RESVAL  (1'h0),
2699:     .Mubi    (1'b0)
2700:   ) u_fault_status_side_ctrl_sel (
2701:     .clk_i   (clk_i),
2702:     .rst_ni  (rst_ni),
2703: 
2704:     // from register interface
2705:     .we     (1'b0),
2706:     .wd     ('0),
2707: 
2708:     // from internal hardware
2709:     .de     (hw2reg.fault_status.side_ctrl_sel.de),
2710:     .d      (hw2reg.fault_status.side_ctrl_sel.d),
2711: 
2712:     // to internal hardware
2713:     .qe     (),
2714:     .q      (reg2hw.fault_status.side_ctrl_sel.q),
2715:     .ds     (),
2716: 
2717:     // to register interface (read)
2718:     .qs     (fault_status_side_ctrl_sel_qs)
2719:   );
2720: 
2721:   //   F[key_ecc]: 13:13
2722:   prim_subreg #(
2723:     .DW      (1),
2724:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2725:     .RESVAL  (1'h0),
2726:     .Mubi    (1'b0)
2727:   ) u_fault_status_key_ecc (
2728:     .clk_i   (clk_i),
2729:     .rst_ni  (rst_ni),
2730: 
2731:     // from register interface
2732:     .we     (1'b0),
2733:     .wd     ('0),
2734: 
2735:     // from internal hardware
2736:     .de     (hw2reg.fault_status.key_ecc.de),
2737:     .d      (hw2reg.fault_status.key_ecc.d),
2738: 
2739:     // to internal hardware
2740:     .qe     (),
2741:     .q      (reg2hw.fault_status.key_ecc.q),
2742:     .ds     (),
2743: 
2744:     // to register interface (read)
2745:     .qs     (fault_status_key_ecc_qs)
2746:   );
2747: 
2748: 
2749:   // R[debug]: V(False)
2750:   //   F[invalid_creator_seed]: 0:0
2751:   prim_subreg #(
2752:     .DW      (1),
2753:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2754:     .RESVAL  (1'h0),
2755:     .Mubi    (1'b0)
2756:   ) u_debug_invalid_creator_seed (
2757:     .clk_i   (clk_i),
2758:     .rst_ni  (rst_ni),
2759: 
2760:     // from register interface
2761:     .we     (debug_we),
2762:     .wd     (debug_invalid_creator_seed_wd),
2763: 
2764:     // from internal hardware
2765:     .de     (hw2reg.debug.invalid_creator_seed.de),
2766:     .d      (hw2reg.debug.invalid_creator_seed.d),
2767: 
2768:     // to internal hardware
2769:     .qe     (),
2770:     .q      (),
2771:     .ds     (),
2772: 
2773:     // to register interface (read)
2774:     .qs     (debug_invalid_creator_seed_qs)
2775:   );
2776: 
2777:   //   F[invalid_owner_seed]: 1:1
2778:   prim_subreg #(
2779:     .DW      (1),
2780:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2781:     .RESVAL  (1'h0),
2782:     .Mubi    (1'b0)
2783:   ) u_debug_invalid_owner_seed (
2784:     .clk_i   (clk_i),
2785:     .rst_ni  (rst_ni),
2786: 
2787:     // from register interface
2788:     .we     (debug_we),
2789:     .wd     (debug_invalid_owner_seed_wd),
2790: 
2791:     // from internal hardware
2792:     .de     (hw2reg.debug.invalid_owner_seed.de),
2793:     .d      (hw2reg.debug.invalid_owner_seed.d),
2794: 
2795:     // to internal hardware
2796:     .qe     (),
2797:     .q      (),
2798:     .ds     (),
2799: 
2800:     // to register interface (read)
2801:     .qs     (debug_invalid_owner_seed_qs)
2802:   );
2803: 
2804:   //   F[invalid_dev_id]: 2:2
2805:   prim_subreg #(
2806:     .DW      (1),
2807:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2808:     .RESVAL  (1'h0),
2809:     .Mubi    (1'b0)
2810:   ) u_debug_invalid_dev_id (
2811:     .clk_i   (clk_i),
2812:     .rst_ni  (rst_ni),
2813: 
2814:     // from register interface
2815:     .we     (debug_we),
2816:     .wd     (debug_invalid_dev_id_wd),
2817: 
2818:     // from internal hardware
2819:     .de     (hw2reg.debug.invalid_dev_id.de),
2820:     .d      (hw2reg.debug.invalid_dev_id.d),
2821: 
2822:     // to internal hardware
2823:     .qe     (),
2824:     .q      (),
2825:     .ds     (),
2826: 
2827:     // to register interface (read)
2828:     .qs     (debug_invalid_dev_id_qs)
2829:   );
2830: 
2831:   //   F[invalid_health_state]: 3:3
2832:   prim_subreg #(
2833:     .DW      (1),
2834:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2835:     .RESVAL  (1'h0),
2836:     .Mubi    (1'b0)
2837:   ) u_debug_invalid_health_state (
2838:     .clk_i   (clk_i),
2839:     .rst_ni  (rst_ni),
2840: 
2841:     // from register interface
2842:     .we     (debug_we),
2843:     .wd     (debug_invalid_health_state_wd),
2844: 
2845:     // from internal hardware
2846:     .de     (hw2reg.debug.invalid_health_state.de),
2847:     .d      (hw2reg.debug.invalid_health_state.d),
2848: 
2849:     // to internal hardware
2850:     .qe     (),
2851:     .q      (),
2852:     .ds     (),
2853: 
2854:     // to register interface (read)
2855:     .qs     (debug_invalid_health_state_qs)
2856:   );
2857: 
2858:   //   F[invalid_key_version]: 4:4
2859:   prim_subreg #(
2860:     .DW      (1),
2861:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2862:     .RESVAL  (1'h0),
2863:     .Mubi    (1'b0)
2864:   ) u_debug_invalid_key_version (
2865:     .clk_i   (clk_i),
2866:     .rst_ni  (rst_ni),
2867: 
2868:     // from register interface
2869:     .we     (debug_we),
2870:     .wd     (debug_invalid_key_version_wd),
2871: 
2872:     // from internal hardware
2873:     .de     (hw2reg.debug.invalid_key_version.de),
2874:     .d      (hw2reg.debug.invalid_key_version.d),
2875: 
2876:     // to internal hardware
2877:     .qe     (),
2878:     .q      (),
2879:     .ds     (),
2880: 
2881:     // to register interface (read)
2882:     .qs     (debug_invalid_key_version_qs)
2883:   );
2884: 
2885:   //   F[invalid_key]: 5:5
2886:   prim_subreg #(
2887:     .DW      (1),
2888:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2889:     .RESVAL  (1'h0),
2890:     .Mubi    (1'b0)
2891:   ) u_debug_invalid_key (
2892:     .clk_i   (clk_i),
2893:     .rst_ni  (rst_ni),
2894: 
2895:     // from register interface
2896:     .we     (debug_we),
2897:     .wd     (debug_invalid_key_wd),
2898: 
2899:     // from internal hardware
2900:     .de     (hw2reg.debug.invalid_key.de),
2901:     .d      (hw2reg.debug.invalid_key.d),
2902: 
2903:     // to internal hardware
2904:     .qe     (),
2905:     .q      (),
2906:     .ds     (),
2907: 
2908:     // to register interface (read)
2909:     .qs     (debug_invalid_key_qs)
2910:   );
2911: 
2912:   //   F[invalid_digest]: 6:6
2913:   prim_subreg #(
2914:     .DW      (1),
2915:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2916:     .RESVAL  (1'h0),
2917:     .Mubi    (1'b0)
2918:   ) u_debug_invalid_digest (
2919:     .clk_i   (clk_i),
2920:     .rst_ni  (rst_ni),
2921: 
2922:     // from register interface
2923:     .we     (debug_we),
2924:     .wd     (debug_invalid_digest_wd),
2925: 
2926:     // from internal hardware
2927:     .de     (hw2reg.debug.invalid_digest.de),
2928:     .d      (hw2reg.debug.invalid_digest.d),
2929: 
2930:     // to internal hardware
2931:     .qe     (),
2932:     .q      (),
2933:     .ds     (),
2934: 
2935:     // to register interface (read)
2936:     .qs     (debug_invalid_digest_qs)
2937:   );
2938: 
2939: 
2940: 
2941:   logic [62:0] addr_hit;
2942:   always_comb begin
2943:     addr_hit = '0;
2944:     addr_hit[ 0] = (reg_addr == KEYMGR_INTR_STATE_OFFSET);
2945:     addr_hit[ 1] = (reg_addr == KEYMGR_INTR_ENABLE_OFFSET);
2946:     addr_hit[ 2] = (reg_addr == KEYMGR_INTR_TEST_OFFSET);
2947:     addr_hit[ 3] = (reg_addr == KEYMGR_ALERT_TEST_OFFSET);
2948:     addr_hit[ 4] = (reg_addr == KEYMGR_CFG_REGWEN_OFFSET);
2949:     addr_hit[ 5] = (reg_addr == KEYMGR_START_OFFSET);
2950:     addr_hit[ 6] = (reg_addr == KEYMGR_CONTROL_SHADOWED_OFFSET);
2951:     addr_hit[ 7] = (reg_addr == KEYMGR_SIDELOAD_CLEAR_OFFSET);
2952:     addr_hit[ 8] = (reg_addr == KEYMGR_RESEED_INTERVAL_REGWEN_OFFSET);
2953:     addr_hit[ 9] = (reg_addr == KEYMGR_RESEED_INTERVAL_SHADOWED_OFFSET);
2954:     addr_hit[10] = (reg_addr == KEYMGR_SW_BINDING_REGWEN_OFFSET);
2955:     addr_hit[11] = (reg_addr == KEYMGR_SEALING_SW_BINDING_0_OFFSET);
2956:     addr_hit[12] = (reg_addr == KEYMGR_SEALING_SW_BINDING_1_OFFSET);
2957:     addr_hit[13] = (reg_addr == KEYMGR_SEALING_SW_BINDING_2_OFFSET);
2958:     addr_hit[14] = (reg_addr == KEYMGR_SEALING_SW_BINDING_3_OFFSET);
2959:     addr_hit[15] = (reg_addr == KEYMGR_SEALING_SW_BINDING_4_OFFSET);
2960:     addr_hit[16] = (reg_addr == KEYMGR_SEALING_SW_BINDING_5_OFFSET);
2961:     addr_hit[17] = (reg_addr == KEYMGR_SEALING_SW_BINDING_6_OFFSET);
2962:     addr_hit[18] = (reg_addr == KEYMGR_SEALING_SW_BINDING_7_OFFSET);
2963:     addr_hit[19] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_0_OFFSET);
2964:     addr_hit[20] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_1_OFFSET);
2965:     addr_hit[21] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_2_OFFSET);
2966:     addr_hit[22] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_3_OFFSET);
2967:     addr_hit[23] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_4_OFFSET);
2968:     addr_hit[24] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_5_OFFSET);
2969:     addr_hit[25] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_6_OFFSET);
2970:     addr_hit[26] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_7_OFFSET);
2971:     addr_hit[27] = (reg_addr == KEYMGR_SALT_0_OFFSET);
2972:     addr_hit[28] = (reg_addr == KEYMGR_SALT_1_OFFSET);
2973:     addr_hit[29] = (reg_addr == KEYMGR_SALT_2_OFFSET);
2974:     addr_hit[30] = (reg_addr == KEYMGR_SALT_3_OFFSET);
2975:     addr_hit[31] = (reg_addr == KEYMGR_SALT_4_OFFSET);
2976:     addr_hit[32] = (reg_addr == KEYMGR_SALT_5_OFFSET);
2977:     addr_hit[33] = (reg_addr == KEYMGR_SALT_6_OFFSET);
2978:     addr_hit[34] = (reg_addr == KEYMGR_SALT_7_OFFSET);
2979:     addr_hit[35] = (reg_addr == KEYMGR_KEY_VERSION_OFFSET);
2980:     addr_hit[36] = (reg_addr == KEYMGR_MAX_CREATOR_KEY_VER_REGWEN_OFFSET);
2981:     addr_hit[37] = (reg_addr == KEYMGR_MAX_CREATOR_KEY_VER_SHADOWED_OFFSET);
2982:     addr_hit[38] = (reg_addr == KEYMGR_MAX_OWNER_INT_KEY_VER_REGWEN_OFFSET);
2983:     addr_hit[39] = (reg_addr == KEYMGR_MAX_OWNER_INT_KEY_VER_SHADOWED_OFFSET);
2984:     addr_hit[40] = (reg_addr == KEYMGR_MAX_OWNER_KEY_VER_REGWEN_OFFSET);
2985:     addr_hit[41] = (reg_addr == KEYMGR_MAX_OWNER_KEY_VER_SHADOWED_OFFSET);
2986:     addr_hit[42] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_0_OFFSET);
2987:     addr_hit[43] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_1_OFFSET);
2988:     addr_hit[44] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_2_OFFSET);
2989:     addr_hit[45] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_3_OFFSET);
2990:     addr_hit[46] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_4_OFFSET);
2991:     addr_hit[47] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_5_OFFSET);
2992:     addr_hit[48] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_6_OFFSET);
2993:     addr_hit[49] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_7_OFFSET);
2994:     addr_hit[50] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_0_OFFSET);
2995:     addr_hit[51] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_1_OFFSET);
2996:     addr_hit[52] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_2_OFFSET);
2997:     addr_hit[53] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_3_OFFSET);
2998:     addr_hit[54] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_4_OFFSET);
2999:     addr_hit[55] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_5_OFFSET);
3000:     addr_hit[56] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_6_OFFSET);
3001:     addr_hit[57] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_7_OFFSET);
3002:     addr_hit[58] = (reg_addr == KEYMGR_WORKING_STATE_OFFSET);
3003:     addr_hit[59] = (reg_addr == KEYMGR_OP_STATUS_OFFSET);
3004:     addr_hit[60] = (reg_addr == KEYMGR_ERR_CODE_OFFSET);
3005:     addr_hit[61] = (reg_addr == KEYMGR_FAULT_STATUS_OFFSET);
3006:     addr_hit[62] = (reg_addr == KEYMGR_DEBUG_OFFSET);
3007:   end
3008: 
3009:   assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;
3010: 
3011:   // Check sub-word write is permitted
3012:   always_comb begin
3013:     wr_err = (reg_we &
3014:               ((addr_hit[ 0] & (|(KEYMGR_PERMIT[ 0] & ~reg_be))) |
3015:                (addr_hit[ 1] & (|(KEYMGR_PERMIT[ 1] & ~reg_be))) |
3016:                (addr_hit[ 2] & (|(KEYMGR_PERMIT[ 2] & ~reg_be))) |
3017:                (addr_hit[ 3] & (|(KEYMGR_PERMIT[ 3] & ~reg_be))) |
3018:                (addr_hit[ 4] & (|(KEYMGR_PERMIT[ 4] & ~reg_be))) |
3019:                (addr_hit[ 5] & (|(KEYMGR_PERMIT[ 5] & ~reg_be))) |
3020:                (addr_hit[ 6] & (|(KEYMGR_PERMIT[ 6] & ~reg_be))) |
3021:                (addr_hit[ 7] & (|(KEYMGR_PERMIT[ 7] & ~reg_be))) |
3022:                (addr_hit[ 8] & (|(KEYMGR_PERMIT[ 8] & ~reg_be))) |
3023:                (addr_hit[ 9] & (|(KEYMGR_PERMIT[ 9] & ~reg_be))) |
3024:                (addr_hit[10] & (|(KEYMGR_PERMIT[10] & ~reg_be))) |
3025:                (addr_hit[11] & (|(KEYMGR_PERMIT[11] & ~reg_be))) |
3026:                (addr_hit[12] & (|(KEYMGR_PERMIT[12] & ~reg_be))) |
3027:                (addr_hit[13] & (|(KEYMGR_PERMIT[13] & ~reg_be))) |
3028:                (addr_hit[14] & (|(KEYMGR_PERMIT[14] & ~reg_be))) |
3029:                (addr_hit[15] & (|(KEYMGR_PERMIT[15] & ~reg_be))) |
3030:                (addr_hit[16] & (|(KEYMGR_PERMIT[16] & ~reg_be))) |
3031:                (addr_hit[17] & (|(KEYMGR_PERMIT[17] & ~reg_be))) |
3032:                (addr_hit[18] & (|(KEYMGR_PERMIT[18] & ~reg_be))) |
3033:                (addr_hit[19] & (|(KEYMGR_PERMIT[19] & ~reg_be))) |
3034:                (addr_hit[20] & (|(KEYMGR_PERMIT[20] & ~reg_be))) |
3035:                (addr_hit[21] & (|(KEYMGR_PERMIT[21] & ~reg_be))) |
3036:                (addr_hit[22] & (|(KEYMGR_PERMIT[22] & ~reg_be))) |
3037:                (addr_hit[23] & (|(KEYMGR_PERMIT[23] & ~reg_be))) |
3038:                (addr_hit[24] & (|(KEYMGR_PERMIT[24] & ~reg_be))) |
3039:                (addr_hit[25] & (|(KEYMGR_PERMIT[25] & ~reg_be))) |
3040:                (addr_hit[26] & (|(KEYMGR_PERMIT[26] & ~reg_be))) |
3041:                (addr_hit[27] & (|(KEYMGR_PERMIT[27] & ~reg_be))) |
3042:                (addr_hit[28] & (|(KEYMGR_PERMIT[28] & ~reg_be))) |
3043:                (addr_hit[29] & (|(KEYMGR_PERMIT[29] & ~reg_be))) |
3044:                (addr_hit[30] & (|(KEYMGR_PERMIT[30] & ~reg_be))) |
3045:                (addr_hit[31] & (|(KEYMGR_PERMIT[31] & ~reg_be))) |
3046:                (addr_hit[32] & (|(KEYMGR_PERMIT[32] & ~reg_be))) |
3047:                (addr_hit[33] & (|(KEYMGR_PERMIT[33] & ~reg_be))) |
3048:                (addr_hit[34] & (|(KEYMGR_PERMIT[34] & ~reg_be))) |
3049:                (addr_hit[35] & (|(KEYMGR_PERMIT[35] & ~reg_be))) |
3050:                (addr_hit[36] & (|(KEYMGR_PERMIT[36] & ~reg_be))) |
3051:                (addr_hit[37] & (|(KEYMGR_PERMIT[37] & ~reg_be))) |
3052:                (addr_hit[38] & (|(KEYMGR_PERMIT[38] & ~reg_be))) |
3053:                (addr_hit[39] & (|(KEYMGR_PERMIT[39] & ~reg_be))) |
3054:                (addr_hit[40] & (|(KEYMGR_PERMIT[40] & ~reg_be))) |
3055:                (addr_hit[41] & (|(KEYMGR_PERMIT[41] & ~reg_be))) |
3056:                (addr_hit[42] & (|(KEYMGR_PERMIT[42] & ~reg_be))) |
3057:                (addr_hit[43] & (|(KEYMGR_PERMIT[43] & ~reg_be))) |
3058:                (addr_hit[44] & (|(KEYMGR_PERMIT[44] & ~reg_be))) |
3059:                (addr_hit[45] & (|(KEYMGR_PERMIT[45] & ~reg_be))) |
3060:                (addr_hit[46] & (|(KEYMGR_PERMIT[46] & ~reg_be))) |
3061:                (addr_hit[47] & (|(KEYMGR_PERMIT[47] & ~reg_be))) |
3062:                (addr_hit[48] & (|(KEYMGR_PERMIT[48] & ~reg_be))) |
3063:                (addr_hit[49] & (|(KEYMGR_PERMIT[49] & ~reg_be))) |
3064:                (addr_hit[50] & (|(KEYMGR_PERMIT[50] & ~reg_be))) |
3065:                (addr_hit[51] & (|(KEYMGR_PERMIT[51] & ~reg_be))) |
3066:                (addr_hit[52] & (|(KEYMGR_PERMIT[52] & ~reg_be))) |
3067:                (addr_hit[53] & (|(KEYMGR_PERMIT[53] & ~reg_be))) |
3068:                (addr_hit[54] & (|(KEYMGR_PERMIT[54] & ~reg_be))) |
3069:                (addr_hit[55] & (|(KEYMGR_PERMIT[55] & ~reg_be))) |
3070:                (addr_hit[56] & (|(KEYMGR_PERMIT[56] & ~reg_be))) |
3071:                (addr_hit[57] & (|(KEYMGR_PERMIT[57] & ~reg_be))) |
3072:                (addr_hit[58] & (|(KEYMGR_PERMIT[58] & ~reg_be))) |
3073:                (addr_hit[59] & (|(KEYMGR_PERMIT[59] & ~reg_be))) |
3074:                (addr_hit[60] & (|(KEYMGR_PERMIT[60] & ~reg_be))) |
3075:                (addr_hit[61] & (|(KEYMGR_PERMIT[61] & ~reg_be))) |
3076:                (addr_hit[62] & (|(KEYMGR_PERMIT[62] & ~reg_be)))));
3077:   end
3078: 
3079:   // Generate write-enables
3080:   assign intr_state_we = addr_hit[0] & reg_we & !reg_error;
3081: 
3082:   assign intr_state_wd = reg_wdata[0];
3083:   assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;
3084: 
3085:   assign intr_enable_wd = reg_wdata[0];
3086:   assign intr_test_we = addr_hit[2] & reg_we & !reg_error;
3087: 
3088:   assign intr_test_wd = reg_wdata[0];
3089:   assign alert_test_we = addr_hit[3] & reg_we & !reg_error;
3090: 
3091:   assign alert_test_recov_operation_err_wd = reg_wdata[0];
3092: 
3093:   assign alert_test_fatal_fault_err_wd = reg_wdata[1];
3094:   assign cfg_regwen_re = addr_hit[4] & reg_re & !reg_error;
3095:   assign start_we = addr_hit[5] & reg_we & !reg_error;
3096: 
3097:   assign start_wd = reg_wdata[0];
3098:   assign control_shadowed_re = addr_hit[6] & reg_re & !reg_error;
3099:   assign control_shadowed_we = addr_hit[6] & reg_we & !reg_error;
3100: 
3101:   assign control_shadowed_operation_wd = reg_wdata[6:4];
3102: 
3103:   assign control_shadowed_cdi_sel_wd = reg_wdata[7];
3104: 
3105:   assign control_shadowed_dest_sel_wd = reg_wdata[13:12];
3106:   assign sideload_clear_we = addr_hit[7] & reg_we & !reg_error;
3107: 
3108:   assign sideload_clear_wd = reg_wdata[2:0];
3109:   assign reseed_interval_regwen_we = addr_hit[8] & reg_we & !reg_error;
3110: 
3111:   assign reseed_interval_regwen_wd = reg_wdata[0];
3112:   assign reseed_interval_shadowed_re = addr_hit[9] & reg_re & !reg_error;
3113:   assign reseed_interval_shadowed_we = addr_hit[9] & reg_we & !reg_error;
3114: 
3115:   assign reseed_interval_shadowed_wd = reg_wdata[15:0];
3116:   assign sw_binding_regwen_re = addr_hit[10] & reg_re & !reg_error;
3117:   assign sw_binding_regwen_we = addr_hit[10] & reg_we & !reg_error;
3118: 
3119:   assign sw_binding_regwen_wd = reg_wdata[0];
3120:   assign sealing_sw_binding_0_we = addr_hit[11] & reg_we & !reg_error;
3121: 
3122:   assign sealing_sw_binding_0_wd = reg_wdata[31:0];
3123:   assign sealing_sw_binding_1_we = addr_hit[12] & reg_we & !reg_error;
3124: 
3125:   assign sealing_sw_binding_1_wd = reg_wdata[31:0];
3126:   assign sealing_sw_binding_2_we = addr_hit[13] & reg_we & !reg_error;
3127: 
3128:   assign sealing_sw_binding_2_wd = reg_wdata[31:0];
3129:   assign sealing_sw_binding_3_we = addr_hit[14] & reg_we & !reg_error;
3130: 
3131:   assign sealing_sw_binding_3_wd = reg_wdata[31:0];
3132:   assign sealing_sw_binding_4_we = addr_hit[15] & reg_we & !reg_error;
3133: 
3134:   assign sealing_sw_binding_4_wd = reg_wdata[31:0];
3135:   assign sealing_sw_binding_5_we = addr_hit[16] & reg_we & !reg_error;
3136: 
3137:   assign sealing_sw_binding_5_wd = reg_wdata[31:0];
3138:   assign sealing_sw_binding_6_we = addr_hit[17] & reg_we & !reg_error;
3139: 
3140:   assign sealing_sw_binding_6_wd = reg_wdata[31:0];
3141:   assign sealing_sw_binding_7_we = addr_hit[18] & reg_we & !reg_error;
3142: 
3143:   assign sealing_sw_binding_7_wd = reg_wdata[31:0];
3144:   assign attest_sw_binding_0_we = addr_hit[19] & reg_we & !reg_error;
3145: 
3146:   assign attest_sw_binding_0_wd = reg_wdata[31:0];
3147:   assign attest_sw_binding_1_we = addr_hit[20] & reg_we & !reg_error;
3148: 
3149:   assign attest_sw_binding_1_wd = reg_wdata[31:0];
3150:   assign attest_sw_binding_2_we = addr_hit[21] & reg_we & !reg_error;
3151: 
3152:   assign attest_sw_binding_2_wd = reg_wdata[31:0];
3153:   assign attest_sw_binding_3_we = addr_hit[22] & reg_we & !reg_error;
3154: 
3155:   assign attest_sw_binding_3_wd = reg_wdata[31:0];
3156:   assign attest_sw_binding_4_we = addr_hit[23] & reg_we & !reg_error;
3157: 
3158:   assign attest_sw_binding_4_wd = reg_wdata[31:0];
3159:   assign attest_sw_binding_5_we = addr_hit[24] & reg_we & !reg_error;
3160: 
3161:   assign attest_sw_binding_5_wd = reg_wdata[31:0];
3162:   assign attest_sw_binding_6_we = addr_hit[25] & reg_we & !reg_error;
3163: 
3164:   assign attest_sw_binding_6_wd = reg_wdata[31:0];
3165:   assign attest_sw_binding_7_we = addr_hit[26] & reg_we & !reg_error;
3166: 
3167:   assign attest_sw_binding_7_wd = reg_wdata[31:0];
3168:   assign salt_0_we = addr_hit[27] & reg_we & !reg_error;
3169: 
3170:   assign salt_0_wd = reg_wdata[31:0];
3171:   assign salt_1_we = addr_hit[28] & reg_we & !reg_error;
3172: 
3173:   assign salt_1_wd = reg_wdata[31:0];
3174:   assign salt_2_we = addr_hit[29] & reg_we & !reg_error;
3175: 
3176:   assign salt_2_wd = reg_wdata[31:0];
3177:   assign salt_3_we = addr_hit[30] & reg_we & !reg_error;
3178: 
3179:   assign salt_3_wd = reg_wdata[31:0];
3180:   assign salt_4_we = addr_hit[31] & reg_we & !reg_error;
3181: 
3182:   assign salt_4_wd = reg_wdata[31:0];
3183:   assign salt_5_we = addr_hit[32] & reg_we & !reg_error;
3184: 
3185:   assign salt_5_wd = reg_wdata[31:0];
3186:   assign salt_6_we = addr_hit[33] & reg_we & !reg_error;
3187: 
3188:   assign salt_6_wd = reg_wdata[31:0];
3189:   assign salt_7_we = addr_hit[34] & reg_we & !reg_error;
3190: 
3191:   assign salt_7_wd = reg_wdata[31:0];
3192:   assign key_version_we = addr_hit[35] & reg_we & !reg_error;
3193: 
3194:   assign key_version_wd = reg_wdata[31:0];
3195:   assign max_creator_key_ver_regwen_we = addr_hit[36] & reg_we & !reg_error;
3196: 
3197:   assign max_creator_key_ver_regwen_wd = reg_wdata[0];
3198:   assign max_creator_key_ver_shadowed_re = addr_hit[37] & reg_re & !reg_error;
3199:   assign max_creator_key_ver_shadowed_we = addr_hit[37] & reg_we & !reg_error;
3200: 
3201:   assign max_creator_key_ver_shadowed_wd = reg_wdata[31:0];
3202:   assign max_owner_int_key_ver_regwen_we = addr_hit[38] & reg_we & !reg_error;
3203: 
3204:   assign max_owner_int_key_ver_regwen_wd = reg_wdata[0];
3205:   assign max_owner_int_key_ver_shadowed_re = addr_hit[39] & reg_re & !reg_error;
3206:   assign max_owner_int_key_ver_shadowed_we = addr_hit[39] & reg_we & !reg_error;
3207: 
3208:   assign max_owner_int_key_ver_shadowed_wd = reg_wdata[31:0];
3209:   assign max_owner_key_ver_regwen_we = addr_hit[40] & reg_we & !reg_error;
3210: 
3211:   assign max_owner_key_ver_regwen_wd = reg_wdata[0];
3212:   assign max_owner_key_ver_shadowed_re = addr_hit[41] & reg_re & !reg_error;
3213:   assign max_owner_key_ver_shadowed_we = addr_hit[41] & reg_we & !reg_error;
3214: 
3215:   assign max_owner_key_ver_shadowed_wd = reg_wdata[31:0];
3216:   assign sw_share0_output_0_re = addr_hit[42] & reg_re & !reg_error;
3217: 
3218:   assign sw_share0_output_0_wd = '1;
3219:   assign sw_share0_output_1_re = addr_hit[43] & reg_re & !reg_error;
3220: 
3221:   assign sw_share0_output_1_wd = '1;
3222:   assign sw_share0_output_2_re = addr_hit[44] & reg_re & !reg_error;
3223: 
3224:   assign sw_share0_output_2_wd = '1;
3225:   assign sw_share0_output_3_re = addr_hit[45] & reg_re & !reg_error;
3226: 
3227:   assign sw_share0_output_3_wd = '1;
3228:   assign sw_share0_output_4_re = addr_hit[46] & reg_re & !reg_error;
3229: 
3230:   assign sw_share0_output_4_wd = '1;
3231:   assign sw_share0_output_5_re = addr_hit[47] & reg_re & !reg_error;
3232: 
3233:   assign sw_share0_output_5_wd = '1;
3234:   assign sw_share0_output_6_re = addr_hit[48] & reg_re & !reg_error;
3235: 
3236:   assign sw_share0_output_6_wd = '1;
3237:   assign sw_share0_output_7_re = addr_hit[49] & reg_re & !reg_error;
3238: 
3239:   assign sw_share0_output_7_wd = '1;
3240:   assign sw_share1_output_0_re = addr_hit[50] & reg_re & !reg_error;
3241: 
3242:   assign sw_share1_output_0_wd = '1;
3243:   assign sw_share1_output_1_re = addr_hit[51] & reg_re & !reg_error;
3244: 
3245:   assign sw_share1_output_1_wd = '1;
3246:   assign sw_share1_output_2_re = addr_hit[52] & reg_re & !reg_error;
3247: 
3248:   assign sw_share1_output_2_wd = '1;
3249:   assign sw_share1_output_3_re = addr_hit[53] & reg_re & !reg_error;
3250: 
3251:   assign sw_share1_output_3_wd = '1;
3252:   assign sw_share1_output_4_re = addr_hit[54] & reg_re & !reg_error;
3253: 
3254:   assign sw_share1_output_4_wd = '1;
3255:   assign sw_share1_output_5_re = addr_hit[55] & reg_re & !reg_error;
3256: 
3257:   assign sw_share1_output_5_wd = '1;
3258:   assign sw_share1_output_6_re = addr_hit[56] & reg_re & !reg_error;
3259: 
3260:   assign sw_share1_output_6_wd = '1;
3261:   assign sw_share1_output_7_re = addr_hit[57] & reg_re & !reg_error;
3262: 
3263:   assign sw_share1_output_7_wd = '1;
3264:   assign op_status_we = addr_hit[59] & reg_we & !reg_error;
3265: 
3266:   assign op_status_wd = reg_wdata[1:0];
3267:   assign err_code_we = addr_hit[60] & reg_we & !reg_error;
3268: 
3269:   assign err_code_invalid_op_wd = reg_wdata[0];
3270: 
3271:   assign err_code_invalid_kmac_input_wd = reg_wdata[1];
3272: 
3273:   assign err_code_invalid_shadow_update_wd = reg_wdata[2];
3274:   assign debug_we = addr_hit[62] & reg_we & !reg_error;
3275: 
3276:   assign debug_invalid_creator_seed_wd = reg_wdata[0];
3277: 
3278:   assign debug_invalid_owner_seed_wd = reg_wdata[1];
3279: 
3280:   assign debug_invalid_dev_id_wd = reg_wdata[2];
3281: 
3282:   assign debug_invalid_health_state_wd = reg_wdata[3];
3283: 
3284:   assign debug_invalid_key_version_wd = reg_wdata[4];
3285: 
3286:   assign debug_invalid_key_wd = reg_wdata[5];
3287: 
3288:   assign debug_invalid_digest_wd = reg_wdata[6];
3289: 
3290:   // Assign write-enables to checker logic vector.
3291:   always_comb begin
3292:     reg_we_check = '0;
3293:     reg_we_check[0] = intr_state_we;
3294:     reg_we_check[1] = intr_enable_we;
3295:     reg_we_check[2] = intr_test_we;
3296:     reg_we_check[3] = alert_test_we;
3297:     reg_we_check[4] = 1'b0;
3298:     reg_we_check[5] = start_gated_we;
3299:     reg_we_check[6] = control_shadowed_gated_we;
3300:     reg_we_check[7] = sideload_clear_gated_we;
3301:     reg_we_check[8] = reseed_interval_regwen_we;
3302:     reg_we_check[9] = reseed_interval_shadowed_gated_we;
3303:     reg_we_check[10] = sw_binding_regwen_we;
3304:     reg_we_check[11] = sealing_sw_binding_0_gated_we;
3305:     reg_we_check[12] = sealing_sw_binding_1_gated_we;
3306:     reg_we_check[13] = sealing_sw_binding_2_gated_we;
3307:     reg_we_check[14] = sealing_sw_binding_3_gated_we;
3308:     reg_we_check[15] = sealing_sw_binding_4_gated_we;
3309:     reg_we_check[16] = sealing_sw_binding_5_gated_we;
3310:     reg_we_check[17] = sealing_sw_binding_6_gated_we;
3311:     reg_we_check[18] = sealing_sw_binding_7_gated_we;
3312:     reg_we_check[19] = attest_sw_binding_0_gated_we;
3313:     reg_we_check[20] = attest_sw_binding_1_gated_we;
3314:     reg_we_check[21] = attest_sw_binding_2_gated_we;
3315:     reg_we_check[22] = attest_sw_binding_3_gated_we;
3316:     reg_we_check[23] = attest_sw_binding_4_gated_we;
3317:     reg_we_check[24] = attest_sw_binding_5_gated_we;
3318:     reg_we_check[25] = attest_sw_binding_6_gated_we;
3319:     reg_we_check[26] = attest_sw_binding_7_gated_we;
3320:     reg_we_check[27] = salt_0_gated_we;
3321:     reg_we_check[28] = salt_1_gated_we;
3322:     reg_we_check[29] = salt_2_gated_we;
3323:     reg_we_check[30] = salt_3_gated_we;
3324:     reg_we_check[31] = salt_4_gated_we;
3325:     reg_we_check[32] = salt_5_gated_we;
3326:     reg_we_check[33] = salt_6_gated_we;
3327:     reg_we_check[34] = salt_7_gated_we;
3328:     reg_we_check[35] = key_version_gated_we;
3329:     reg_we_check[36] = max_creator_key_ver_regwen_we;
3330:     reg_we_check[37] = max_creator_key_ver_shadowed_gated_we;
3331:     reg_we_check[38] = max_owner_int_key_ver_regwen_we;
3332:     reg_we_check[39] = max_owner_int_key_ver_shadowed_gated_we;
3333:     reg_we_check[40] = max_owner_key_ver_regwen_we;
3334:     reg_we_check[41] = max_owner_key_ver_shadowed_gated_we;
3335:     reg_we_check[42] = 1'b0;
3336:     reg_we_check[43] = 1'b0;
3337:     reg_we_check[44] = 1'b0;
3338:     reg_we_check[45] = 1'b0;
3339:     reg_we_check[46] = 1'b0;
3340:     reg_we_check[47] = 1'b0;
3341:     reg_we_check[48] = 1'b0;
3342:     reg_we_check[49] = 1'b0;
3343:     reg_we_check[50] = 1'b0;
3344:     reg_we_check[51] = 1'b0;
3345:     reg_we_check[52] = 1'b0;
3346:     reg_we_check[53] = 1'b0;
3347:     reg_we_check[54] = 1'b0;
3348:     reg_we_check[55] = 1'b0;
3349:     reg_we_check[56] = 1'b0;
3350:     reg_we_check[57] = 1'b0;
3351:     reg_we_check[58] = 1'b0;
3352:     reg_we_check[59] = op_status_we;
3353:     reg_we_check[60] = err_code_we;
3354:     reg_we_check[61] = 1'b0;
3355:     reg_we_check[62] = debug_we;
3356:   end
3357: 
3358:   // Read data return
3359:   always_comb begin
3360:     reg_rdata_next = '0;
3361:     unique case (1'b1)
3362:       addr_hit[0]: begin
3363:         reg_rdata_next[0] = intr_state_qs;
3364:       end
3365: 
3366:       addr_hit[1]: begin
3367:         reg_rdata_next[0] = intr_enable_qs;
3368:       end
3369: 
3370:       addr_hit[2]: begin
3371:         reg_rdata_next[0] = '0;
3372:       end
3373: 
3374:       addr_hit[3]: begin
3375:         reg_rdata_next[0] = '0;
3376:         reg_rdata_next[1] = '0;
3377:       end
3378: 
3379:       addr_hit[4]: begin
3380:         reg_rdata_next[0] = cfg_regwen_qs;
3381:       end
3382: 
3383:       addr_hit[5]: begin
3384:         reg_rdata_next[0] = start_qs;
3385:       end
3386: 
3387:       addr_hit[6]: begin
3388:         reg_rdata_next[6:4] = control_shadowed_operation_qs;
3389:         reg_rdata_next[7] = control_shadowed_cdi_sel_qs;
3390:         reg_rdata_next[13:12] = control_shadowed_dest_sel_qs;
3391:       end
3392: 
3393:       addr_hit[7]: begin
3394:         reg_rdata_next[2:0] = sideload_clear_qs;
3395:       end
3396: 
3397:       addr_hit[8]: begin
3398:         reg_rdata_next[0] = reseed_interval_regwen_qs;
3399:       end
3400: 
3401:       addr_hit[9]: begin
3402:         reg_rdata_next[15:0] = reseed_interval_shadowed_qs;
3403:       end
3404: 
3405:       addr_hit[10]: begin
3406:         reg_rdata_next[0] = sw_binding_regwen_qs;
3407:       end
3408: 
3409:       addr_hit[11]: begin
3410:         reg_rdata_next[31:0] = sealing_sw_binding_0_qs;
3411:       end
3412: 
3413:       addr_hit[12]: begin
3414:         reg_rdata_next[31:0] = sealing_sw_binding_1_qs;
3415:       end
3416: 
3417:       addr_hit[13]: begin
3418:         reg_rdata_next[31:0] = sealing_sw_binding_2_qs;
3419:       end
3420: 
3421:       addr_hit[14]: begin
3422:         reg_rdata_next[31:0] = sealing_sw_binding_3_qs;
3423:       end
3424: 
3425:       addr_hit[15]: begin
3426:         reg_rdata_next[31:0] = sealing_sw_binding_4_qs;
3427:       end
3428: 
3429:       addr_hit[16]: begin
3430:         reg_rdata_next[31:0] = sealing_sw_binding_5_qs;
3431:       end
3432: 
3433:       addr_hit[17]: begin
3434:         reg_rdata_next[31:0] = sealing_sw_binding_6_qs;
3435:       end
3436: 
3437:       addr_hit[18]: begin
3438:         reg_rdata_next[31:0] = sealing_sw_binding_7_qs;
3439:       end
3440: 
3441:       addr_hit[19]: begin
3442:         reg_rdata_next[31:0] = attest_sw_binding_0_qs;
3443:       end
3444: 
3445:       addr_hit[20]: begin
3446:         reg_rdata_next[31:0] = attest_sw_binding_1_qs;
3447:       end
3448: 
3449:       addr_hit[21]: begin
3450:         reg_rdata_next[31:0] = attest_sw_binding_2_qs;
3451:       end
3452: 
3453:       addr_hit[22]: begin
3454:         reg_rdata_next[31:0] = attest_sw_binding_3_qs;
3455:       end
3456: 
3457:       addr_hit[23]: begin
3458:         reg_rdata_next[31:0] = attest_sw_binding_4_qs;
3459:       end
3460: 
3461:       addr_hit[24]: begin
3462:         reg_rdata_next[31:0] = attest_sw_binding_5_qs;
3463:       end
3464: 
3465:       addr_hit[25]: begin
3466:         reg_rdata_next[31:0] = attest_sw_binding_6_qs;
3467:       end
3468: 
3469:       addr_hit[26]: begin
3470:         reg_rdata_next[31:0] = attest_sw_binding_7_qs;
3471:       end
3472: 
3473:       addr_hit[27]: begin
3474:         reg_rdata_next[31:0] = salt_0_qs;
3475:       end
3476: 
3477:       addr_hit[28]: begin
3478:         reg_rdata_next[31:0] = salt_1_qs;
3479:       end
3480: 
3481:       addr_hit[29]: begin
3482:         reg_rdata_next[31:0] = salt_2_qs;
3483:       end
3484: 
3485:       addr_hit[30]: begin
3486:         reg_rdata_next[31:0] = salt_3_qs;
3487:       end
3488: 
3489:       addr_hit[31]: begin
3490:         reg_rdata_next[31:0] = salt_4_qs;
3491:       end
3492: 
3493:       addr_hit[32]: begin
3494:         reg_rdata_next[31:0] = salt_5_qs;
3495:       end
3496: 
3497:       addr_hit[33]: begin
3498:         reg_rdata_next[31:0] = salt_6_qs;
3499:       end
3500: 
3501:       addr_hit[34]: begin
3502:         reg_rdata_next[31:0] = salt_7_qs;
3503:       end
3504: 
3505:       addr_hit[35]: begin
3506:         reg_rdata_next[31:0] = key_version_qs;
3507:       end
3508: 
3509:       addr_hit[36]: begin
3510:         reg_rdata_next[0] = max_creator_key_ver_regwen_qs;
3511:       end
3512: 
3513:       addr_hit[37]: begin
3514:         reg_rdata_next[31:0] = max_creator_key_ver_shadowed_qs;
3515:       end
3516: 
3517:       addr_hit[38]: begin
3518:         reg_rdata_next[0] = max_owner_int_key_ver_regwen_qs;
3519:       end
3520: 
3521:       addr_hit[39]: begin
3522:         reg_rdata_next[31:0] = max_owner_int_key_ver_shadowed_qs;
3523:       end
3524: 
3525:       addr_hit[40]: begin
3526:         reg_rdata_next[0] = max_owner_key_ver_regwen_qs;
3527:       end
3528: 
3529:       addr_hit[41]: begin
3530:         reg_rdata_next[31:0] = max_owner_key_ver_shadowed_qs;
3531:       end
3532: 
3533:       addr_hit[42]: begin
3534:         reg_rdata_next[31:0] = sw_share0_output_0_qs;
3535:       end
3536: 
3537:       addr_hit[43]: begin
3538:         reg_rdata_next[31:0] = sw_share0_output_1_qs;
3539:       end
3540: 
3541:       addr_hit[44]: begin
3542:         reg_rdata_next[31:0] = sw_share0_output_2_qs;
3543:       end
3544: 
3545:       addr_hit[45]: begin
3546:         reg_rdata_next[31:0] = sw_share0_output_3_qs;
3547:       end
3548: 
3549:       addr_hit[46]: begin
3550:         reg_rdata_next[31:0] = sw_share0_output_4_qs;
3551:       end
3552: 
3553:       addr_hit[47]: begin
3554:         reg_rdata_next[31:0] = sw_share0_output_5_qs;
3555:       end
3556: 
3557:       addr_hit[48]: begin
3558:         reg_rdata_next[31:0] = sw_share0_output_6_qs;
3559:       end
3560: 
3561:       addr_hit[49]: begin
3562:         reg_rdata_next[31:0] = sw_share0_output_7_qs;
3563:       end
3564: 
3565:       addr_hit[50]: begin
3566:         reg_rdata_next[31:0] = sw_share1_output_0_qs;
3567:       end
3568: 
3569:       addr_hit[51]: begin
3570:         reg_rdata_next[31:0] = sw_share1_output_1_qs;
3571:       end
3572: 
3573:       addr_hit[52]: begin
3574:         reg_rdata_next[31:0] = sw_share1_output_2_qs;
3575:       end
3576: 
3577:       addr_hit[53]: begin
3578:         reg_rdata_next[31:0] = sw_share1_output_3_qs;
3579:       end
3580: 
3581:       addr_hit[54]: begin
3582:         reg_rdata_next[31:0] = sw_share1_output_4_qs;
3583:       end
3584: 
3585:       addr_hit[55]: begin
3586:         reg_rdata_next[31:0] = sw_share1_output_5_qs;
3587:       end
3588: 
3589:       addr_hit[56]: begin
3590:         reg_rdata_next[31:0] = sw_share1_output_6_qs;
3591:       end
3592: 
3593:       addr_hit[57]: begin
3594:         reg_rdata_next[31:0] = sw_share1_output_7_qs;
3595:       end
3596: 
3597:       addr_hit[58]: begin
3598:         reg_rdata_next[2:0] = working_state_qs;
3599:       end
3600: 
3601:       addr_hit[59]: begin
3602:         reg_rdata_next[1:0] = op_status_qs;
3603:       end
3604: 
3605:       addr_hit[60]: begin
3606:         reg_rdata_next[0] = err_code_invalid_op_qs;
3607:         reg_rdata_next[1] = err_code_invalid_kmac_input_qs;
3608:         reg_rdata_next[2] = err_code_invalid_shadow_update_qs;
3609:       end
3610: 
3611:       addr_hit[61]: begin
3612:         reg_rdata_next[0] = fault_status_cmd_qs;
3613:         reg_rdata_next[1] = fault_status_kmac_fsm_qs;
3614:         reg_rdata_next[2] = fault_status_kmac_done_qs;
3615:         reg_rdata_next[3] = fault_status_kmac_op_qs;
3616:         reg_rdata_next[4] = fault_status_kmac_out_qs;
3617:         reg_rdata_next[5] = fault_status_regfile_intg_qs;
3618:         reg_rdata_next[6] = fault_status_shadow_qs;
3619:         reg_rdata_next[7] = fault_status_ctrl_fsm_intg_qs;
3620:         reg_rdata_next[8] = fault_status_ctrl_fsm_chk_qs;
3621:         reg_rdata_next[9] = fault_status_ctrl_fsm_cnt_qs;
3622:         reg_rdata_next[10] = fault_status_reseed_cnt_qs;
3623:         reg_rdata_next[11] = fault_status_side_ctrl_fsm_qs;
3624:         reg_rdata_next[12] = fault_status_side_ctrl_sel_qs;
3625:         reg_rdata_next[13] = fault_status_key_ecc_qs;
3626:       end
3627: 
3628:       addr_hit[62]: begin
3629:         reg_rdata_next[0] = debug_invalid_creator_seed_qs;
3630:         reg_rdata_next[1] = debug_invalid_owner_seed_qs;
3631:         reg_rdata_next[2] = debug_invalid_dev_id_qs;
3632:         reg_rdata_next[3] = debug_invalid_health_state_qs;
3633:         reg_rdata_next[4] = debug_invalid_key_version_qs;
3634:         reg_rdata_next[5] = debug_invalid_key_qs;
3635:         reg_rdata_next[6] = debug_invalid_digest_qs;
3636:       end
3637: 
3638:       default: begin
3639:         reg_rdata_next = '1;
3640:       end
3641:     endcase
3642:   end
3643: 
3644:   // shadow busy
3645:   logic shadow_busy;
3646:   logic rst_done;
3647:   logic shadow_rst_done;
3648:   always_ff @(posedge clk_i or negedge rst_ni) begin
3649:     if (!rst_ni) begin
3650:       rst_done <= '0;
3651:     end else begin
3652:       rst_done <= 1'b1;
3653:     end
3654:   end
3655: 
3656:   always_ff @(posedge clk_i or negedge rst_shadowed_ni) begin
3657:     if (!rst_shadowed_ni) begin
3658:       shadow_rst_done <= '0;
3659:     end else begin
3660:       shadow_rst_done <= 1'b1;
3661:     end
3662:   end
3663: 
3664:   // both shadow and normal resets have been released
3665:   assign shadow_busy = ~(rst_done & shadow_rst_done);
3666: 
3667:   // Collect up storage and update errors
3668:   assign shadowed_storage_err_o = |{
3669:     control_shadowed_operation_storage_err,
3670:     control_shadowed_cdi_sel_storage_err,
3671:     control_shadowed_dest_sel_storage_err,
3672:     reseed_interval_shadowed_storage_err,
3673:     max_creator_key_ver_shadowed_storage_err,
3674:     max_owner_int_key_ver_shadowed_storage_err,
3675:     max_owner_key_ver_shadowed_storage_err
3676:   };
3677:   assign shadowed_update_err_o = |{
3678:     control_shadowed_operation_update_err,
3679:     control_shadowed_cdi_sel_update_err,
3680:     control_shadowed_dest_sel_update_err,
3681:     reseed_interval_shadowed_update_err,
3682:     max_creator_key_ver_shadowed_update_err,
3683:     max_owner_int_key_ver_shadowed_update_err,
3684:     max_owner_key_ver_shadowed_update_err
3685:   };
3686: 
3687:   // register busy
3688:   assign reg_busy = shadow_busy;
3689: 
3690:   // Unused signal tieoff
3691: 
3692:   // wdata / byte enable are not always fully used
3693:   // add a blanket unused statement to handle lint waivers
3694:   logic unused_wdata;
3695:   logic unused_be;
3696:   assign unused_wdata = ^reg_wdata;
3697:   assign unused_be = ^reg_be;
3698: 
3699:   // Assertions for Register Interface
3700:   `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
3701:   `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)
3702: 
3703:   `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)
3704: 
3705:   `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)
3706: 
3707:   // this is formulated as an assumption such that the FPV testbenches do disprove this
3708:   // property by mistake
3709:   //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)
3710: 
3711: endmodule

================================== Ai Message ==================================

[{'text': "Now, I'll use the similar_bug_tool to search for similar bugs:", 'type': 'text'}, {'id': 'toolu_017VwYyHGYJCWnkhERM98VH7', 'input': {'bug': 'assign shadowed_storage_err_o = |{', 'ip_file': '/home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv'}, 'name': 'similar_bug_tool', 'type': 'tool_use'}]
Tool Calls:
  similar_bug_tool (toolu_017VwYyHGYJCWnkhERM98VH7)
 Call ID: toolu_017VwYyHGYJCWnkhERM98VH7
  Args:
    bug: assign shadowed_storage_err_o = |{
    ip_file: /home/XXXX-2/hackdate/hw/ip/keymgr/rtl/keymgr_reg_top.sv
================================= Tool Message =================================
Name: similar_bug_tool

Error: ValueError("'assign shadowed_update_err_o = |{\\n    control_shadowed_operation_update_err,' is not in list")
 Please fix your mistakes.
================================= Tool Message =================================
Name: similar_bug_tool

Error: ValueError("'assign shadowed_update_err_o = |{\\n    control_shadowed_operation_update_err,' is not in list")
 Please fix your mistakes.
================================== Ai Message ==================================

I apologize for the error. Let me try a different approach by looking at the specific lines around the bug.

In the file, I found two similar lines:

1. Line 3668-3676:
```systemverilog
assign shadowed_storage_err_o = |{
    control_shadowed_operation_storage_err,
    control_shadowed_cdi_sel_storage_err,
    control_shadowed_dest_sel_storage_err,
    reseed_interval_shadowed_storage_err,
    max_creator_key_ver_shadowed_storage_err,
    max_owner_int_key_ver_shadowed_storage_err,
    max_owner_key_ver_shadowed_storage_err
};
```

2. Line 3677-3685:
```systemverilog
assign shadowed_update_err_o = |{
    control_shadowed_operation_update_err,
    control_shadowed_cdi_sel_update_err,
    control_shadowed_dest_sel_update_err,
    reseed_interval_shadowed_update_err,
    max_creator_key_ver_shadowed_update_err,
    max_owner_int_key_ver_shadowed_update_err,
    max_owner_key_ver_shadowed_update_err
};
```

These lines look like intentional and correct implementations of error aggregation using the reduction OR operator (`|{}`). They collect various storage and update errors from different shadowed registers.

There are no apparent bugs in these lines. The code is using the reduction OR operator to combine multiple error signals, which is a common and valid pattern for error aggregation.

The lines appear to be correctly implemented and serve the purpose of consolidating error signals from different shadowed registers.
================================= Tool Message =================================
Name: run_similar_bug_agent

I apologize for the error. Let me try a different approach by looking at the specific lines around the bug.

In the file, I found two similar lines:

1. Line 3668-3676:
```systemverilog
assign shadowed_storage_err_o = |{
    control_shadowed_operation_storage_err,
    control_shadowed_cdi_sel_storage_err,
    control_shadowed_dest_sel_storage_err,
    reseed_interval_shadowed_storage_err,
    max_creator_key_ver_shadowed_storage_err,
    max_owner_int_key_ver_shadowed_storage_err,
    max_owner_key_ver_shadowed_storage_err
};
```

2. Line 3677-3685:
```systemverilog
assign shadowed_update_err_o = |{
    control_shadowed_operation_update_err,
    control_shadowed_cdi_sel_update_err,
    control_shadowed_dest_sel_update_err,
    reseed_interval_shadowed_update_err,
    max_creator_key_ver_shadowed_update_err,
    max_owner_int_key_ver_shadowed_update_err,
    max_owner_key_ver_shadowed_update_err
};
```

These lines look like intentional and correct implementations of error aggregation using the reduction OR operator (`|{}`). They collect various storage and update errors from different shadowed registers.

There are no apparent bugs in these lines. The code is using the reduction OR operator to combine multiple error signals, which is a common and valid pattern for error aggregation.

The lines appear to be correctly implemented and serve the purpose of consolidating error signals from different shadowed registers.
================================== Ai Message ==================================

# Keymgr IP Security Analysis Report

## 1. Security Features and Register Interface Policies

### Security Features (from `theory_of_operation.md`)
- **State Machine Security**: Keymgr operates in distinct states (Reset, Initialized, CreatorRootKey, OwnerIntermediateKey, OwnerRootKey, Disabled, Invalid), with irreversible transitions during a power cycle. Only valid commands are accepted in each state.
- **Key Isolation**: Internal keys are never directly exposed to software except in specific output generation states. Sideload keys are only available to hardware.
- **Input Validation**: All inputs (seeds, device ID, health state, etc.) are checked for all-0s/all-1s and other invalid values before use.
- **Shadow Registers**: Critical configuration and binding registers are shadowed and protected by write-enable (REGWEN) signals.
- **Error/Fault Handling**: Distinct handling for recoverable and fatal errors, with alerts and state transitions to `Invalid` on fatal faults.
- **Privilege Control**: Register writes are gated by REGWEN signals, and only allowed in certain states.
- **DICE Support**: Maintains separate state for attestation and sealing CDIs, with software-controlled selection.
- **Custom Security Checks**: One-hot command checks, FSM integrity checks, sideload select checks, and KMAC done checks.

### Register Interface Policies (from `registers.md`)
- **Shadowed Registers**: Critical registers (e.g., CONTROL_SHADOWED, SW_BINDING, MAX_*_KEY_VER_SHADOWED) are shadowed and require explicit enable signals for modification.
- **Write Enables**: REGWEN signals must be set for writes to be accepted; otherwise, writes are ignored.
- **Access Control**: Only specific registers are writable in each state, and some are locked after use until the next state transition.
- **Error Reporting**: ERR_CODE and FAULT_STATUS registers report recoverable and fatal errors, respectively.
- **Output Registers**: Software can only read output keys in specific states and after valid operations.

---

## 2. RTL Security Analysis

### A. Register Interface & Shadow Register Security (`keymgr_reg_top.sv`)
- **Gated Write Enables**: All critical register writes are gated by REGWEN signals (e.g., `assign start_gated_we = start_we & cfg_regwen_qs;`). This pattern is consistently applied to all shadowed and critical registers.
- **Shadow Register Error Aggregation**: Errors from all shadowed registers are aggregated and output (e.g., `assign shadowed_storage_err_o = |{...}`), ensuring that any shadow register inconsistency is flagged.
- **No Bypass Detected**: No evidence of bypassing REGWEN or shadow register protections.
- **CWE Mapping**: Potential concern if REGWEN signals are ever compromised, but no direct vulnerability found in the RTL.

**Tools Used**: Linter, Anomaly Detector, CWE Checker, Similar Bug Agent  
**Summary**: No privilege escalation or shadow register integrity issues detected. Gating and error aggregation are robust.

---

### B. FSM Security & Privilege Escalation (`keymgr_ctrl.sv`)
- **Sparse FSM Encoding**: FSM uses sparse encoding with high Hamming distance, reducing risk of single-bit errors causing illegal transitions.
- **State Integrity Checks**: FSM integrity is checked, and any illegal state triggers a transition to a wipe or invalid state.
- **Privilege Control**: State transitions are only allowed on valid operations; illegal transitions are detected and handled.
- **Anomaly Review**: Anomalous lines are security features (e.g., key wipe on error), not vulnerabilities.

**Tools Used**: Linter, Assertion Checker, Anomaly Detector, CWE Checker  
**Summary**: FSM is robust against illegal transitions and privilege escalation. No stuck-at or privilege escalation bugs found.

---

### C. KMAC Interface Security, Masking, and Data Leakage (`keymgr_kmac_if.sv`)
- **Masking Enforcement**: Data outputs are masked with entropy when not in a valid transaction (`assign data_o = start && done_o ? ... : {{DecoyOutputCopies{entropy_i[1]}}, ...}`).
- **Command Consistency**: One-hot and command consistency checks are enforced and latched, blocking conflicting or invalid commands.
- **No Data Leakage**: Decoy data is output on error or invalid conditions, preventing leakage of sensitive data.
- **Casting Issues**: Linter flagged casting operations (e.g., `assign adv_data = KDFMaxWidth'(adv_data_i);`), but these are intentional for zero-padding and not a security risk.
- **FSM Case Statement**: Use of `unique case` is correct and covers all states, with a default error handler.

**Tools Used**: Linter, Assertion Checker, Anomaly Detector, CWE Checker, Similar Bug Agent  
**Summary**: No masking, data leakage, or privilege escalation vulnerabilities detected. Casting and FSM usage are intentional and secure.

---

## 3. Specific Issue Summaries

### 1. Register Write Gating Pattern
- **Files**: keymgr_reg_top.sv
- **Lines**: 498-499, 529-530, 642-643, 700-702, 763-764
- **Description**: All critical register writes are gated by REGWEN signals, preventing unauthorized writes.
- **Security Aspect**: Register access control, privilege escalation prevention
- **Tools**: Similar Bug Agent, Linter

### 2. Shadow Register Error Aggregation
- **Files**: keymgr_reg_top.sv
- **Lines**: 3668-3676, 3677-3685
- **Description**: Aggregates errors from all shadowed registers to a single output, ensuring detection of any shadow register inconsistency.
- **Security Aspect**: Shadow register integrity
- **Tools**: Similar Bug Agent, CWE Checker

### 3. FSM Security and Error Handling
- **Files**: keymgr_ctrl.sv
- **Lines**: FSM logic and error handling blocks (see anomaly clusters)
- **Description**: Sparse FSM encoding, integrity checks, and error-triggered key wipes prevent illegal transitions and privilege escalation.
- **Security Aspect**: FSM security, privilege escalation
- **Tools**: Linter, Anomaly Detector, CWE Checker

### 4. KMAC Interface Masking and Command Checks
- **Files**: keymgr_kmac_if.sv
- **Lines**: 134-136 (casting), 190-274 (unique case), masking and error handling logic
- **Description**: Data masking, command consistency checks, and decoy data output prevent data leakage and command injection.
- **Security Aspect**: Masking enforcement, data leakage prevention, privilege escalation
- **Tools**: Linter, Anomaly Detector, Similar Bug Agent, CWE Checker

---

## 4. Recommendations

- **Maintain REGWEN and shadow register gating**: Ensure these signals cannot be compromised by external or software means.
- **Continue formal verification**: Especially for FSM transitions and shadow register update paths.
- **Monitor error aggregation**: Ensure that error outputs are always connected to system-level alert handlers.
- **Review casting and FSM usage**: While currently intentional and secure, maintain vigilance for future changes.

---

## 5. Conclusion

**No critical security vulnerabilities were found in the keymgr RTL.**  
The design demonstrates robust security engineering, with strong controls on register access, FSM transitions, masking, and error handling. All identified "anomalies" are intentional security features. The only minor issues are related to code style (casting) and do not impact security.

**Tools Used**: Verilator, Linter, Assertion Checker, Anomaly Detector, CWE Checker, Similar Bug Agent

**Status**: Keymgr RTL passes all major hardware security checks for privilege escalation, data leakage, masking, FSM integrity, and shadow register protection.

---

END
================================== Ai Message ==================================

# Keymgr IP Security Analysis Report

## 1. Security Features and Register Interface Policies

### Security Features (from `theory_of_operation.md`)
- **State Machine Security**: Keymgr operates in distinct states (Reset, Initialized, CreatorRootKey, OwnerIntermediateKey, OwnerRootKey, Disabled, Invalid), with irreversible transitions during a power cycle. Only valid commands are accepted in each state.
- **Key Isolation**: Internal keys are never directly exposed to software except in specific output generation states. Sideload keys are only available to hardware.
- **Input Validation**: All inputs (seeds, device ID, health state, etc.) are checked for all-0s/all-1s and other invalid values before use.
- **Shadow Registers**: Critical configuration and binding registers are shadowed and protected by write-enable (REGWEN) signals.
- **Error/Fault Handling**: Distinct handling for recoverable and fatal errors, with alerts and state transitions to `Invalid` on fatal faults.
- **Privilege Control**: Register writes are gated by REGWEN signals, and only allowed in certain states.
- **DICE Support**: Maintains separate state for attestation and sealing CDIs, with software-controlled selection.
- **Custom Security Checks**: One-hot command checks, FSM integrity checks, sideload select checks, and KMAC done checks.

### Register Interface Policies (from `registers.md`)
- **Shadowed Registers**: Critical registers (e.g., CONTROL_SHADOWED, SW_BINDING, MAX_*_KEY_VER_SHADOWED) are shadowed and require explicit enable signals for modification.
- **Write Enables**: REGWEN signals must be set for writes to be accepted; otherwise, writes are ignored.
- **Access Control**: Only specific registers are writable in each state, and some are locked after use until the next state transition.
- **Error Reporting**: ERR_CODE and FAULT_STATUS registers report recoverable and fatal errors, respectively.
- **Output Registers**: Software can only read output keys in specific states and after valid operations.

---

## 2. RTL Security Analysis

### A. Register Interface & Shadow Register Security (`keymgr_reg_top.sv`)
- **Gated Write Enables**: All critical register writes are gated by REGWEN signals (e.g., `assign start_gated_we = start_we & cfg_regwen_qs;`). This pattern is consistently applied to all shadowed and critical registers.
- **Shadow Register Error Aggregation**: Errors from all shadowed registers are aggregated and output (e.g., `assign shadowed_storage_err_o = |{...}`), ensuring that any shadow register inconsistency is flagged.
- **No Bypass Detected**: No evidence of bypassing REGWEN or shadow register protections.
- **CWE Mapping**: Potential concern if REGWEN signals are ever compromised, but no direct vulnerability found in the RTL.

**Tools Used**: Linter, Anomaly Detector, CWE Checker, Similar Bug Agent  
**Summary**: No privilege escalation or shadow register integrity issues detected. Gating and error aggregation are robust.

---

### B. FSM Security & Privilege Escalation (`keymgr_ctrl.sv`)
- **Sparse FSM Encoding**: FSM uses sparse encoding with high Hamming distance, reducing risk of single-bit errors causing illegal transitions.
- **State Integrity Checks**: FSM integrity is checked, and any illegal state triggers a transition to a wipe or invalid state.
- **Privilege Control**: State transitions are only allowed on valid operations; illegal transitions are detected and handled.
- **Anomaly Review**: Anomalous lines are security features (e.g., key wipe on error), not vulnerabilities.

**Tools Used**: Linter, Assertion Checker, Anomaly Detector, CWE Checker  
**Summary**: FSM is robust against illegal transitions and privilege escalation. No stuck-at or privilege escalation bugs found.

---

### C. KMAC Interface Security, Masking, and Data Leakage (`keymgr_kmac_if.sv`)
- **Masking Enforcement**: Data outputs are masked with entropy when not in a valid transaction (`assign data_o = start && done_o ? ... : {{DecoyOutputCopies{entropy_i[1]}}, ...}`).
- **Command Consistency**: One-hot and command consistency checks are enforced and latched, blocking conflicting or invalid commands.
- **No Data Leakage**: Decoy data is output on error or invalid conditions, preventing leakage of sensitive data.
- **Casting Issues**: Linter flagged casting operations (e.g., `assign adv_data = KDFMaxWidth'(adv_data_i);`), but these are intentional for zero-padding and not a security risk.
- **FSM Case Statement**: Use of `unique case` is correct and covers all states, with a default error handler.

**Tools Used**: Linter, Assertion Checker, Anomaly Detector, CWE Checker, Similar Bug Agent  
**Summary**: No masking, data leakage, or privilege escalation vulnerabilities detected. Casting and FSM usage are intentional and secure.

---

## 3. Specific Issue Summaries

### 1. Register Write Gating Pattern
- **Files**: keymgr_reg_top.sv
- **Lines**: 498-499, 529-530, 642-643, 700-702, 763-764
- **Description**: All critical register writes are gated by REGWEN signals, preventing unauthorized writes.
- **Security Aspect**: Register access control, privilege escalation prevention
- **Tools**: Similar Bug Agent, Linter

### 2. Shadow Register Error Aggregation
- **Files**: keymgr_reg_top.sv
- **Lines**: 3668-3676, 3677-3685
- **Description**: Aggregates errors from all shadowed registers to a single output, ensuring detection of any shadow register inconsistency.
- **Security Aspect**: Shadow register integrity
- **Tools**: Similar Bug Agent, CWE Checker

### 3. FSM Security and Error Handling
- **Files**: keymgr_ctrl.sv
- **Lines**: FSM logic and error handling blocks (see anomaly clusters)
- **Description**: Sparse FSM encoding, integrity checks, and error-triggered key wipes prevent illegal transitions and privilege escalation.
- **Security Aspect**: FSM security, privilege escalation
- **Tools**: Linter, Anomaly Detector, CWE Checker

### 4. KMAC Interface Masking and Command Checks
- **Files**: keymgr_kmac_if.sv
- **Lines**: 134-136 (casting), 190-274 (unique case), masking and error handling logic
- **Description**: Data masking, command consistency checks, and decoy data output prevent data leakage and command injection.
- **Security Aspect**: Masking enforcement, data leakage prevention, privilege escalation
- **Tools**: Linter, Anomaly Detector, Similar Bug Agent, CWE Checker

---

## 4. Recommendations

- **Maintain REGWEN and shadow register gating**: Ensure these signals cannot be compromised by external or software means.
- **Continue formal verification**: Especially for FSM transitions and shadow register update paths.
- **Monitor error aggregation**: Ensure that error outputs are always connected to system-level alert handlers.
- **Review casting and FSM usage**: While currently intentional and secure, maintain vigilance for future changes.

---

## 5. Conclusion

**No critical security vulnerabilities were found in the keymgr RTL.**  
The design demonstrates robust security engineering, with strong controls on register access, FSM transitions, masking, and error handling. All identified "anomalies" are intentional security features. The only minor issues are related to code style (casting) and do not impact security.

**Tools Used**: Verilator, Linter, Assertion Checker, Anomaly Detector, CWE Checker, Similar Bug Agent

**Status**: Keymgr RTL passes all major hardware security checks for privilege escalation, data leakage, masking, FSM integrity, and shadow register protection.

---

END
================================== Ai Message ==================================

 OF REPORT
