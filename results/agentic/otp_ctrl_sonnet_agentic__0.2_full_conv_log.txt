================================ System Message ================================


    You are a supervisor agent in a multi-agent system focused on identifying hardware security vulnerabilities in RTL code. 
    Your objective is to analyze the given SoC and generate a detailed security report.

    You have access to the following tools: ['run_anomaly_detector_agent', 'run_verilator_agent', 'run_llm_cwe_checker_agent', 'run_assertions_checker_agent', 'run_linter_agent', 'run_similar_bug_agent', 'list_dir', 'read_file', 'read_file_with_line_numbers']. Each tool specializes in a specific task:

    - Verilator Agent: Runs Verilator tests on the given IP and analyzes failing test reports to detect potential security issues.
    - Assertion Agent: Takes a Verilog file, a top module name, and a security aspect to check. It generates and runs security assertions on the RTL. Failing assertions indicate potential issues that require further localization.
    - Linter Agent: Accepts a Verilog file, top module, and security focus. It selects relevant lint checks and flags design violations tied to security concerns.
    - CWE Agent: Given a Verilog file, a top module, and a security aspect, this agent maps the RTL code to relevant CWEs and detects CWE-related vulnerabilities.
    - Similar Bug Agent: Accepts a file path and a line number (where a bug was found) to locate similar patterns or recurring bugs throughout the RTL code.

    Instructions for analysis:

    - Read the documentataion to identify security features and register interfaces policies.
    - Use Verilator, Assertion, Anomaly and Linter agents to uncover initial issues in the design.
    - If a bug is detected but not localized, use the CWE Agent to further inspect the related security aspect in the surrounding RTL.
    - After detecting any bugs, use the Similar Bug Agent to scan similar files (of the same or of different IPs) for similar vulnerabilities.

    Output Format:

    - For each identified issue, report:
    - File name
    - Line number(s)
    - Brief description of the issue
    - Security aspect affected
    - Tools used to identify the issue

    When your analysis is complete, end your response with "END".
    
================================ Human Message =================================

Identify security issues in the otp_ctrl IP of the OpenTitan SoC, located at /home/XXXX-2/hackdate.

    - All IPs are located in the 'hw/ip' directory.
    - RTL code for each IP is located in its 'rtl' subdirectory, with source files having the '.sv' extension.
        - reg_top files contain the register interface for the IP.
        - control/fsm files contain the control logic for the IP.
        - core files contain the core logic for the IP.
    - Documentation files (.md) are located in the 'doc' directories of each IP.
        - theory_of_operation explains the properties of the IP and its security features.
        - registers.md files contain the register interface and its read/write access policies.
    - Ignore '.core' files; they are used by build tools and are not relevant for security analysis.

    Focus on the otp_ctrl IP and make sure to analyze it thoroughly.

    First, identify the relevant security properties and read/write policies of the register interfaces from the documentation. 
    Then, use all available tools to perform a comprehensive security analysis on the RTL code.
    
================================== Ai Message ==================================
Tool Calls:
  list_dir (call_Qh8X8idjiyTpkIe4wt2EdZ32)
 Call ID: call_Qh8X8idjiyTpkIe4wt2EdZ32
  Args:
    dir_path: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/doc
================================= Tool Message =================================
Name: list_dir

Files in /home/XXXX-2/hackdate/hw/ip/otp_ctrl/doc:
checklist.md interfaces.md otp_ctrl_behavioral_model.svg otp_ctrl_blockdiag.svg otp_ctrl_buf_part_fsm.svg otp_ctrl_dai_fsm.svg otp_ctrl_digest_mechanism.svg otp_ctrl_digests.md otp_ctrl_field_descriptions.md otp_ctrl_kdi_fsm.svg otp_ctrl_key_req_ack.svg otp_ctrl_lci_fsm.svg otp_ctrl_mmap.md otp_ctrl_overview.svg otp_ctrl_partitions.md otp_ctrl_prim_otp.svg otp_ctrl_unbuf_part_fsm.svg programmers_guide.md registers.md theory_of_operation.md

Directories in /home/XXXX-2/hackdate/hw/ip/otp_ctrl/doc:

================================== Ai Message ==================================
Tool Calls:
  read_file (call_bf9bVQzCb3cv7xbgmWyKYrmB)
 Call ID: call_bf9bVQzCb3cv7xbgmWyKYrmB
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/doc/theory_of_operation.md
================================= Tool Message =================================
Name: read_file

# Theory of Operation

Conceptually speaking, the OTP functionality is at a high level split into "front-end" and "back-end".
The "front-end" contains the logical partitions that feed the hardware and software consumer interfaces of the system.
The "back-end" represents the programming interface used by hardware and software components to stage the upcoming values.
The diagram below illustrates this behavioral model.

![OTP Controller Block Diagram](../doc/otp_ctrl_behavioral_model.svg)

Note that the front-end contains both buffered and unbuffered partitions.
Buffered partitions are sensed once per power cycle and their contents are stored in registers, whereas unbuffered partitions are read on-demand.
The former are typically partitions that contain data like hardware configuration bits, key material and the life cycle state that need to be always available to the hardware, whereas the latter are large partitions that are accessed infrequently, such as the software configurations.
Values that are programmed into a buffered partition via the programming interface (coupled with read verification) are merely "staged", and do not take effect until the next power cycle.

The sections below describe the operation of various pieces of the OTP controller and how it supports the described functionality.

## Logical Partitions

The OTP is logically separated into partitions that represent different functions.
This means the isolation is virtual and maintained by the OTP controller instead of the underlying OTP IP.

Within each logical partition, there are specific enforceable properties

- Confidentiality via secret partitions
  - This controls whether a particular partition contains secret data.
  - If secret, a partition is not readable by software once locked, and is scrambled in storage.
- Read lockability
  - This controls whether a particular partition disables software readability for later stage software.
  - Some partitions can be locked statically (by computing and storing an associated digest in OTP), others can be read locked at runtime via CSRs.
- Write lockability
  - This controls whether a partition is locked and prevented from future updates.
  - A locked partition is stored alongside a digest to be used later for integrity verification.
- Integrity Verification
  - Once a partition is write-locked by calculating and writing a non-zero [digest](#locking-a-partition) to it, it can undergo periodic verification (time-scale configurable by software).
This verification takes two forms, partition integrity checks, and storage consistency checks.

Since the OTP is memory-like in nature (it only outputs a certain number of bits per address location), some of the logical partitions are buffered in registers for instantaneous and parallel access by hardware.
This is a critical point, since after power-up, these particular OTP contents are stored in flip flops and sourced to the system.
I.e., buffered partitions are **NOT** directly sourced from the OTP macro itself.
Thus the security of both volatile (OTP controller) and non-volatile (OTP IP) storage becomes important.

### Partition Listing and Description

The OTP controller for OpenTitan contains the seven logical partitions shown below.

{{#include otp_ctrl_partitions.md}}

Generally speaking, the production life cycle of a device is split into 5 stages "Manufacturing" -> "Calibration and Testing" -> "Provisioning" -> "Mission" -> "RMA".
OTP values are usually programmed during "Calibration and Testing", "Provisioning" and "RMA" stages, as explained below.
A detailed listing of all the items and the corresponding memory map can be found in the [Programmer's Guide](programmers_guide.md)) further below.

### Calibration and Test

During this stage, the device is tested for functionality and calibrated to ensure uniformity.
The calibration can focus on a number of things, but usually is centered around adjusting clock, voltage and timing sources to remove process variation.
These calibration values are programmed into the CREATOR_SW_CFG partition, as they are non-secret values meant to be read out by software and programmed into respective peripherals.

Early on during this stage, the various tokens are also programmed into the secret partitions and harvested by the silicon creator.

### Provisioning

During this stage, the device is provisioned with the final firmware and a "unique" seed or identity.
The secret partitions are populated with root secrets and keys that are critical to establishing the device identity.

As part of injecting the final firmware, the stock-keeping-unit-specific hardware and software configurations are also programmed.

### Life Cycle Partition

The life cycle partition is active throughout all stages and hence it is the **ONLY** partition that cannot be locked.
After the device finishes provisioning and goes into production, it must retain the ability to transition back to RMA in case of unexpected failures.

In order to support this transition, the [life cycle state](../../lc_ctrl/README.md) and counters must always be update-able.

## Locking a Partition

Write access to a partition can be permanently locked when software determines it will no longer make any updates to that partition.
To lock, an integrity constant is calculated and programmed alongside the other data of that partition.
The size of that integrity constant depends on the partition size granule, and is either 32bit or 64bit (see also [Direct Access Memory Map](#direct-access-memory-map)).

Once the "integrity digest" is non-zero, no further updates are allowed.
If the partition is secret, software is in addition no longer able to read its contents (see [Secret Partition description](#secret-vs-nonsecret-partitions)).

Note however, in all partitions, the digest itself is **ALWAYS** readable.
This gives software an opportunity to confirm that the locking operation has proceeded correctly, and if not, scrap the part immediately.

Calculation of the integrity digest depends on whether the partition requires periodic background verification.

### Vendor Test Partition

The vendor test partition is intended to be used for OTP programming smoke checks during the manufacturing flow.
The silicon creator may implement these checks inside the proprietary version of the `prim_otp` wrapper.
This partition behaves like any other SW partition, with the exception that ECC uncorrectable errors will not lead to fatal errors / alerts as they do in all other partitions.
This is due to the nature of the OTP programming smoke checks, which may leave certain OTP words in a state inconsistent with the ECC polynomial employed upon OTP readout.

### Software Configuration Partitions

The software configuration partitions are used as non-volatile storage for flags, configuration and calibration data.
As such, the contents of this partition are usually consumed once as part of code execution, or moved to another storage compartment somewhere in the design.
For example, the clock calibration values and the LDO calibration values are programmed to the analog sensor top (AST) at startup.

As such, it is not necessary to check periodically at the OTP source.
Instead, software can simply check as part of secure boot and take other measures when these values are programmed into peripherals.

For this partition it is thus the responsibility of software to calculate the integrity digest and program it into the OTP.
It is also reasonable to shadow (parts of) this partition in main memory, and there is not an immediate impact from OTP contents to hardware.

### Hardware Configuration and Secret Partitions

The hardware and secret partitions directly affect downstream hardware.
The contents must go through periodic integrity checks and therefore the stored digest is calculated by hardware when software provides the intent to lock (as opposed to the software partitions where the digest has to be calculated by software).

### Life Cycle Partition

The life cycle partition cannot be locked and will therefore not contain a stored digest.
Note however that only the life cycle controller has access to this partition, i.e., the Direct Access Interface (DAI) cannot read nor write from/to the life cycle partition.

## Secret vs Non-Secret Partitions

Non-secret OTP partitions hold data that can be public; or data that has no impact on security.
For example, the current value of lock bits or clock calibration values.
These values are stored in OTP as plaintext.

Secret partitions contain data that are critical to security, for example FLASH scrambling keys, device root secret and unlock tokens.
These values are stored scrambled in OTP, and are descrambled upon read.
The currently employed cipher is PRESENT, as it lends itself well to iterative decomposition, and it is a proven lightweight block cipher (see also [PRESENT Scrambling Primitive](../../prim/doc/prim_present.md).
The usage of a block cipher however implies that the secret partitions can only be written in 64bit chunks.

Further, the contents of a particular secret partition are not readable by software once locked (other than the digest which must be always readable); while non-secret partitions are always readable unless read accessibility is explicitly removed by software.

Unfortunately, secret partitions must utilize a global netlist key for the scrambling operation, as there is no other non-volatile storage to store a unique key.


## Partition Checks

### Integrity

Once the appropriate partitions have been locked, the hardware integrity checker employs two integrity checks to verify the content of the volatile buffer registers:

1. All buffered partitions have additional ECC protection (8bit ECC for each 64bit block) that is concurrently monitored.
2. The digest of the partition is recomputed at semi-random intervals and compared to the digest stored alongside the partition.

The purpose of this check is NOT to check between the storage flops and the OTP, but whether the buffer register contents remain consistent with the calculated digest.
This verification is primarily concerned with whether the storage flops have experienced fault attacks.
This check applies to only the HW_CFG* and SECRET* partitions.
If a failure is encountered, the OTP controller will send out a `fatal_check_error` alert and reset all of its hardware outputs to their defaults.

### Storage Consistency

This verification ensures the value stored in the buffer registers remain consistent with those in the OTP.
This process re-reads the OTP at semi-random intervals and confirms the value read is the same as the value stored.
Note, given there are integrity checks in parallel, it is not necessary for some partitions to check ALL read contents for consistency.
If there is an integrity digest, only the digest needs to be read; otherwise, all values must be read.


This check applies to LIFE_CYCLE, HW_CFG* and SECRET* partitions.
If a failure is encountered, the OTP controller will send out a `fatal_check_error` alert and reset all of its hardware outputs to their defaults.

Note that checks applied to life cycle could cause a failure if life cycle is updated, because life cycle is the only partition that may contain live updates.
The controller hence detects this condition based on the `lc_check_byp_en_i` signal coming from the life cycle controller, and pauses background checks on this partition in order to prevent false positives.

### Secret Partition Integrity Checks

Since the secret partitions are stored scrambled, this also implies the integrity digest is calculated over the scrambled form.
In order to balance the amount of buffer registers needed, only the decrypted form of the secret partitions is held in buffer registers.
Hardware calculates the digest by re-scrambling the data before passing it through the digest.


## Power-up and Sense

The OTP controller partition storage must output a specified safe default (it is not always 0 like a blank OTP) upon reset release.
This default output must remain until the OTP controller completes all checks.

The OTP controller reads from the OTP IP.
If the reads pass OTP IP internal checks (for example ECC or redundancy), the partition storage is updated; however the output is still held at the default state via an output mux.
After all read is complete, the OTP controller performs integrity checks on the HW_CFG* and SECRET* partitions.
If a partition fails the integrity checks at this point it would signal an initialization error in the status CSR and abort further initialization.

After all integrity checks are complete, the OTP controller releases the output gating and marks outputs as valid.
However, any partition marked with "error" continues to hold its output in the default state.

Once the above steps are complete, the partition storage in buffered registers is not updated again (except for updates to the life cycle partition through the life cycle interface).
I.e., values programmed to OTP via the programming interface will not be visible in buffered registers until after the next power cycle.

At this point, outputs of the partition storage are NOT expected to change unless a periodic check suddenly fails.
When this failure occurs, all outputs are reverted to their default state, and an alert is immediately triggered to the alert handler.
For timing purposes, OTP outputs can be treated as semi-static, as this error event should be rare and exceptional.


## Partition Defaults

Partition defaults are context specific.
For example, a hardware configuration item that locks down specific access should default to "no access".
This ensures that a glitch attack on the OTP cannot easily revert the design to an insecure state.

This hence suggests that when an OTP is all 0's and all 1's, it should, whenever possible, reflect an invalid or inert state in the encoding space of the affected item.
This also implies the reset state of consuming agents (for example key manager and life cycle), should default to invalid / inert state as well.


## Program and Read Ports

As shown previously, the OTP is split into a front and back end.
The back-end interface is primarily used to update OTP contents, and read back for debug and verification purposes.
Despite being a separate functional access port from the logical partitions, the program and read ports are subjected to the same access controls.

When a partition is write-locked, programming accesses are disallowed.
If the partition is secret, read accesses by the back-end interface are also disallowed (except for the digest which must always be readable).
Software can also disable any read accesses to the software configuration partitions via CSR settings to prevent later stage software from reading any content.

The exception to the above is the life cycle partition.
The life cycle controller interface also acts as a "back-end" interface that always has programming access to ensure life cycle state can be advanced.

Note, the program and read ports can conflict with ongoing background storage checks, and the OTP controller arbitrates between these two sides.
An in-progress operation will always be completed.
Afterwards, or when two requests arrive at the same time, the priority is life cycle > programming interface > on-demand read accesses via CSR windows > background checks.


## Programming the OTP

The OTP controller has two programming paths:

1. a functional programming path through software (the program port),
2. Life cycle programming path through hardware.

The functional interface is used to update all partitions except for life cycle.
As mentioned previously, any updates made during the current power cycle are **NOT** reflected in the buffered partitions until the next reboot.

The life cycle interface is used to update the life cycle state and transition counter only.
The commands are issued from the [life cycle controller](../../lc_ctrl/README.md), and similarly, successful or failed indications are also sent back to the life cycle controller.
Similar to the functional interface, the life cycle controller allows only one update per power cycle, and after a requested transition reverts to an inert state until reboot.

For more details on how the software programs the OTP, please refer to the [Programmer's Guide](programmers_guide.md)) further below.


## Design Details

### Block Diagram

The following is a high-level block diagram that illustrates everything that has been discussed.

![OTP Controller Block Diagram](../doc/otp_ctrl_blockdiag.svg)

Each of the partitions P0-P7 has its [own controller FSM](#partition-implementations) that interacts with the OTP wrapper and the [scrambling datapath](#scrambling-datapath) to fulfill its tasks.
The partitions expose the address ranges and access control information to the Direct Access Interface (DAI) in order to block accesses that go to locked address ranges.
Further, the only two blocks that have (conditional) write access to the OTP are the DAI and the Life Cycle Interface (LCI) blocks.
The partitions can only issue read transactions to the OTP macro.
Note that the access ranges of the DAI and the LCI are mutually exclusive.
I.e., the DAI cannot read from nor write to the life cycle partition.
The LCI cannot read the OTP, but is allowed to write to the life cycle partition.

The CSR node on the left side of this diagram connects to the DAI, the OTP partitions (P0-P7) and the OTP wrapper through a gated TL-UL interface.
All connections from the partitions to the CSR node are read-only, and typically only carry a subset of the information available.
E.g., the secret partitions only expose their digest value via the CSRs.

The Key Derivation Interface (KDI) on the bottom right side interacts with the scrambling datapath, the EDN and the partition holding the scrambling root keys in order to derive static and ephemeral scrambling keys for FLASH and SRAM scrambling.

The test access gate shown at the top of the block diagram is governed by the life cycle qualification signal `dft_en_i`, which is only enabled during the TEST_UNLOCKED* life cycle states.
Otherwise, test access via this TL-UL window is locked down.

In addition to the blocks mentioned so far, the OTP controller also contains an LFSR timer that creates pseudo-randomly distributed partition check requests, and provides pseudo random data at high bandwidth in the event of a secure erase request due to chip-wide alert escalation.
For security reasons, the LFSR is periodically reseeded with entropy coming from EDN.

### Data Allocation and Packing
#### Software View

The effective word width of an OTP IP typically depends on a couple of factors, including the redundancy scheme employed.
For this the design at hand, it is assumed that this native OTP word-width is 16bit.
For software convenience, however, these details are abstracted and the open-source OTP controller exposes the OTP storage as a linear address space of 32bit words, which is aligned with the machine word size of the Ibex processor.
Since the OTP IP employs a redundancy mechanism similar to ECC, this implies however that write operations take place at a granularity of 32bit blocks for non-secret and 64bit blocks for secret partitions (due to the scrambling).
Hence, software is responsible to appropriately pack and program items, since each 32bit location can only be programmed once.

#### Life Cycle View

Since the life cycle partition is the only partition that needs live updates in-field, proper care must be taken to properly encode data in this partition such that incremental updates are possible.
The life cycle state is hence encoded such that incremental updates to the state are always carried out at the granularity of a 16bit word.
Further, the life cycle transition counter is encoded such that each stroke consumes a full 16bit word for the same reason.

See [life cycle controller documentation](../../lc_ctrl/README.md) for more details on the life cycle encoding.

### Partition Controllers

In RTL, we distinguish between buffered and unbuffered partition modules.
These are parameterized, such that we can assemble the array of OTP partitions with these two modules only.
The corresponding controller FSMs are explained in more detail below.

#### Unbuffered Partition

![Unbuffered Partition FSM](../doc/otp_ctrl_unbuf_part_fsm.svg)

As shown above, the unbuffered partition module has a relatively simple controller FSM that only reads out the digest value of the partition upon initialization, and then basically waits for TL-UL read transactions to its corresponding window in the CSR space.

Write access through the DAI will be locked in case the digest is set to a non-zero value.
Also, read access through the DAI and the CSR window can be locked at runtime via a CSR.
Read transactions through the CSR window will error out if they are out of bounds, or if read access is locked.

Note that unrecoverable [OTP errors](#generalized-open-source-interface), ECC failures in the digest register or external escalation via `lc_escalate_en` will move the partition controller into a terminal error state.

#### Buffered Partition

![Buffered Partition FSM](../doc/otp_ctrl_buf_part_fsm.svg)

The controller FSM of the buffered partition module is more complex than the unbuffered counterpart, since it has to account for scrambling and digest calculation.

Upon initialization, the controller reads out the whole partition and descrambles it on the fly if needed.

Then, right after the initial readout, the partition controller jumps into the first integrity check, which behaves somewhat differently, depending on whether the partition is digest protected (or not) and/or scrambled (or not).
If the partition is not digest protected, or if the digest has not yet been computed, the check completes right away, and the buffered values are released for hardware broadcast.
Otherwise, the partition contents in the buffer registers are re-scrambled if needed, and a digest is computed on the fly.
If the computed digest matches with the one that has been read out before, the buffered registers are released for hardware broadcast.
Otherwise, the buffered values are gated to their default, and an alert is triggered through the error handling logic.

After initialization, the integrity check (as described above) and the consistency check can be triggered by the LFSR timer mechanism on a periodic basis.

The consistency check behaves differently, depending on whether the partition is digest protected or not.
If it is, the consistency check will read out the digest stored in OTP and compare it with the value stored in the buffer register.
Otherwise, if no digest is available, the controller will read out the whole partition from OTP, and compare it to the contents stored in the buffer registers.
In case of a mismatch, the buffered values are gated to their default, and an alert is triggered through the error handling logic.

Note that in case of unrecoverable OTP errors or ECC failures in the buffer registers, the partition controller FSM is moved into a terminal error state, which locks down all access through DAI and clamps the values that are broadcast in hardware to their defaults.

External escalation via the `lc_escalate_en` signal will move the partition controller FSM into the terminal error state as well.
See [life cycle controller documentation](../../lc_ctrl/README.md) for more details.

### Direct Access Interface Control

![Direct Access Interface FSM](../doc/otp_ctrl_dai_fsm.svg)

Upon reset release, the DAI controller first sends an initialization command to the OTP macro.
Once the OTP macro becomes operational, an initialization request is sent to all partition controllers, which will read out and initialize the corresponding buffer registers.
The DAI then becomes operational once all partitions have initialized, and supports read, write and digest calculation commands (see [here](#direct-access-interface) for more information about how to interact with the DAI through the CSRs).

Read and write commands transfer either 32bit or 64bit of data from the OTP to the corresponding CSR and vice versa. The access size is determined automatically, depending on whether the partition is scrambled or not. Also, (de)scrambling is performed transparently, depending on whether the partition is scrambled or not.

Digest calculation commands read out the complete contents of a particular partition, compute a digest and write that digest value to the predefined location at the end of the partition.

Note that any unrecoverable OTP error will move the DAI into a terminal error state, where all access through the DAI will be locked.
Also, the DAI consumes the read and write access information provided by the partition controller, and if a certain read or write access is not permitted, a recoverable error will be flagged in the status / error CSRs.

### Life Cycle Interface Control

![Life Cycle Interface FSM](../doc/otp_ctrl_lci_fsm.svg)

Upon reset release the LCI FSM waits until the OTP controller has initialized and the LCI gets enabled.
Once it is in the idle state, life cycle state updates can be initiated via the life cycle interface as [described here](#state-transitions).
The LCI controller takes the life cycle state to be programmed and writes all 16bit words to OTP.
In case of unrecoverable OTP errors, the FSM signals an error to the life cycle controller and moves into a terminal error state.

### Key Derivation Interface

![Key Derivation Interface FSM](../doc/otp_ctrl_kdi_fsm.svg)

Upon reset release the KDI FSM waits until the OTP controller has initialized and the KDI gets enabled.
Once it is in the idle state, key derivation can be requested via the [flash](#interface-to-flash-scrambler) and [sram](#interface-to-sram-and-otbn-scramblers) interfaces.
Based on which interface makes the request, the KDI controller will evaluate a variant of the PRESENT digest mechanism as described in more detail below.

### Scrambling Datapath

![OTP Digest Mechanism](../doc/otp_ctrl_digest_mechanism.svg)

The scrambling datapath is built around an iterative implementation of the [PRESENT lightweight cipher](../../prim/doc/prim_present.md) that performs one round per cycle.
The datapath contains some additional multiplexing circuitry to enable the DAI, KDI and partition controllers to evaluate different functions with the same datapath.
The algorithmic steps of these functions are explained in more detail below.

#### Scrambling

As illustrated in subfigure a) in the diagram above, the standard 128bit-key PRESENT configuration with 31 rounds is used for scrambling operations.
The key used for scrambling is a global netlist constant chosen by the silicon creator, and all secret partitions are encrypted using the their own distinct netlist constant.
Note that the amount of data that is being scrambled is small (160byte = 20 x 64bit blocks) and the scrambled data remains constant.
Hence, no additional masking or diversification scheme is applied since only a very limited amount of information can be gathered by observing the scrambling operation via side-channels.

#### Digest Calculation

The integrity digests used in the [partition checks](#partition-checks) are computed using a custom [Merkle-Damgard](XXXX) scheme, where the employed one-way compression function F is constructed by using PRESENT in a [Davies-Meyer arrangement](XXXX).
This is illustrated in subfigure b).

At the beginning of the digest calculation the 64bit state is initialized with an initialization vector (IV).
Then, the data to be digested is split into 128bit chunks, each of which is used as a 128bit key input for updating the 64bit state with the compression function F.
Chunks that are not aligned with 128bit are padded with zero, and the finalization operation consists of another 31-round encryption pass with a finalization constant.
Note that both the IV as well as the finalization constant are global netlist constants chosen by the silicon creator.

#### Scrambling Key Derivation

The key derivation functions for ephemeral SRAM and static FLASH scrambling keys employ a similar construction as the digest calculation function.
In particular, the keys are derived by repeatedly reducing a (partially random) block of data into a 64bit block, as illustrated in subfigures c) and d).

For ephemeral SRAM scrambling keys, the data block is composed of the 128bit SRAM_DATA_KEY_SEED stored in OTP, as well as 128bit of fresh entropy fetched from the EDN.
This process is repeated twice in order to produce a 128bit key.

For static FLASH scrambling keys, the data block is composed of a 128bit part of either the FLASH_DATA_KEY_SEED or the FLASH_ADDR_KEY_SEED stored in OTP.
These key seeds are 256bit in size, allowing to use a unique chunk of 128bit of key seed data to derive a 64bit halve of a particular scrambling key.

Note that the IV and finalization constants are distinct for SRAM and FLASH data and FLASH address scrambling keys.
These constants are chosen by the silicon creator prior to the tapeout.

### Access Arbitration

Access to the OTP wrapper and the scrambling datapath are both round-robin arbitrated, where the former arbitration occurs at cycle level (i.e., individual OTP memory accesses), and the latter occurs at the level of complete transactions (i.e., full digest or encryption).
Arbitration at transaction level is implemented similarly to cycle-based arbitration, with the difference that the grant signals remain asserted until the requestor deasserts the request (thereby releasing the arbiter, which acts as a mutex in this case).
This is behavior illustrated in the example below.

```wavejson
{signal: [
  {name: 'clk_i',                  wave: 'p............'},
  {name: 'part_scrmbl_mtx_req[0]', wave: '01....0.1....'},
  {name: 'part_scrmbl_mtx_req[1]', wave: '0.1......0...'},
  {name: 'part_scrmbl_mtx_req[2]', wave: '0.1........0.'},
  {},
  {name: 'part_scrmbl_mtx_gnt[0]', wave: '01....0....1.'},
  {name: 'part_scrmbl_mtx_gnt[1]', wave: '0.....1..0...'},
  {name: 'part_scrmbl_mtx_gnt[2]', wave: '0........1.0.'},
]}
```

### Primitive Wrapper and FPGA Emulation

![OTP Wrapper Block Diagram](../doc/otp_ctrl_prim_otp.svg)

The OTP IP is wrapped up in a primitive wrapper that exposes a TL-UL interface for testing purposes, and a generalized open-source interface for functional operation (described below).
Any OTP redundancy mechanism like per-word ECC is assumed to be handled inside the wrapper, which means that the word width exposed as part of the generalized interface is the effective word width.

Note that the register space exposed via the TL-UL test interface, as well as DFT and power-related signals are dependent on the underlying proprietary OTP IP.
They are therefore not further described in this document.

#### Generalized Open-source Interface

The generalized open-source interface uses a couple of parameters (defaults set for Earlgrey configuration).

Parameter      | Default | Top Earlgrey  | Description
---------------|---------|---------------|---------------
`Width`        | 16      | 16            | Native OTP word width.
`Depth`        | 1024    | 1024          | Depth of OTP macro.
`CmdWidth`     | 7       | 7             | Width of the OTP command.
`ErrWidth`     | 3       | 3             | Width of error code output signal.
`PwrSeqWidth`  | 2       | 2             | Width of power sequencing signals to/from AST.
`SizeWidth`    | 2       | 2             | Width of the size field.
`IfWidth`      | 2^`SizeWidth` * `Width` | 2^`SizeWidth` * `Width` | Data interface width.

The generalized open-source interface is a simple command interface with a ready / valid handshake that makes it possible to introduce back pressure if the OTP macro is not able to accept a command due to an ongoing operation.

In order to facilitate the scrambling and digest operations, the data width has been sized such that data blocks up to the PRESENT block size (64bit) can be transferred across the generalized interface. The actual size of a transfer is determined via the size_i field. Transfer sizes are specified in multiples of the native OTP block size, as listed below.

Value of `size_i` | #Native OTP Words | Bit Slice
------------------|-------------------|------------
2'b00             |                 1 | `{word0} = data[15:0]`
2'b01             |                 2 | `{word1, word0} = data[31:0]`
2'b10             |                 3 | `{word2, word1, word0} = data[47:0]`
2'b11             |                 4 | `{word3, word2, word1, word0} = data[63:0]`

Responses are returned in-order via an unidirectional response interface (i.e., without back pressure capability).
Downstream logic must be able to sink the response in any case.
The response optionally carries read data, depending on whether the operation that took place was a read or not.
Also, an error signal returns a non-zero error code in case an error occurred while carrying out the OTP command.

The signals pertaining to the generalized open-source interface are listed below.

Signal                  | Direction        | Type                        | Description
------------------------|------------------|-----------------------------|---------------
`fatal_alert_o`         | `output`         | `logic`                     | Fatal alert output from the primitive. This is connected to a separate alert channel in the instantiating IP. The instantiating IP latches the alert indication and continuously outputs alert events until reset.
`recov_alert_o`         | `output`         | `logic`                     | Recoverable alert output from the primitive. This is connected to a separate alert channel in the instantiating IP. Should only be pulsed high for each alert occurrence. The instantiating IP then sends out a single alert event for each pulse.
`ready_o`               | `output`         | `logic`                     | Ready signal for the command handshake.
`valid_i`               | `input`          | `logic`                     | Valid signal for the command handshake.
`size_i`                | `input`          | `logic [SizeWidth-1:0]`     | Number of native OTP words to transfer, minus one: `2'b00 = 1 native word` ... `2'b11 = 4 native words`.
`cmd_i`                 | `input`          | `logic [CmdWidth-1:0]`      | OTP command: `7'b1000101 = read`, `7'b0110111 = write`, `7'b1111001 = read raw`, `7'b1100010 = write raw`,  `7'b0101100 = initialize`
`addr_i`                | `input`          | `logic [$clog2(Depth)-1:0]` | OTP word address.
`wdata_i`               | `input`          | `logic [IfWidth-1:0]`       | Write data for write commands.
`valid_o`               | `output`         | `logic`                     | Valid signal for command response.
`rdata_o`               | `output`         | `logic [IfWidth-1:0]`       | Read data from read commands.
`err_o`                 | `output`         | `logic [ErrWidth-1:0]`      | Error code.

The `write raw` and `read raw` command instructs the `prim_otp` wrapper to store / read the data in raw format without generating nor checking integrity information.
That means that the wrapper must return the raw, uncorrected data and no integrity errors.

The `prim_otp` wrapper implements the `Macro*` error codes (0x0 - 0x4) defined in [OTP error handling](#error-handling).

The timing diagram below illustrates the timing of a command.
Note that both read and write commands return a response, and each command is independent of the previously issued commands.
The latency from accepting a command to returning a response depends on the underlying OTP IP and is typically larger than 10 cycles.
The returned values depend on the command type and whether an error occurred or not.

```wavejson
{
  signal: [
    { name: 'clk_i',    wave: 'p.............' },
    { name: 'ready_o',  wave: '0..10|.10.|...' , node: '...a...c'},
    { name: 'valid_i',  wave: '01..0|1.0.|...' },
    { name: 'size_i',   wave: '03..0|3.0.|...' },
    { name: 'cmd_i',    wave: '04..0|4.0.|...' },
    { name: 'wdata_i',  wave: '05..0|5.0.|...' },
    { name: 'valid_o',  wave: '0....|..10|.10' , node: '........b...d'},
    { name: 'rdata_o',  wave: '0....|..50|.50' },
    { name: 'err_o',    wave: '0....|..40|.40' },
  ],
  edge: [
   'a~>b',
   'c~>d',
  ],
  head: {
    text: 'Timing of an OTP command.',
  },
  foot: {
    text: "Cmd's are accepted in cycles 3/7, and the corresponding responses return in cycles 8/12.",
    tick: 0,
  }
}
```

Note that the open source OTP controller allows up to two outstanding OTP commands, meaning that it is permissible to acknowledge an incoming command and start working on it while the results of the last command are still in the process of being output (e.g., due to an output register stage).

#### Generic Simulation and FPGA Emulation Model

For open-source simulation and FPGA emulation, a synthesizable and generic OTP wrapper module is provided (`prim_generic_otp`).
This is automatically selected in the OpenTitan build flow via the technology primitive mechanism if no proprietary OTP IP is available for a specific technology.
The OTP storage in `prim_generic_otp` is emulated using a standard RAM primitive `prim_generic_ram_1p`.
While this storage element is volatile, the primitive is constructed such that the contents are not wiped upon a system-wide reset.
I.e., only a power-cycle wipes the RAM primitive, thereby enabling limited emulation of the OTP function and life cycle transitions also on an FPGA device.

================================== Ai Message ==================================
Tool Calls:
  read_file (call_hLHByQGhyBNde6ikRTOI6KSh)
 Call ID: call_hLHByQGhyBNde6ikRTOI6KSh
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/doc/registers.md
================================= Tool Message =================================
Name: read_file

# Registers

<!-- BEGIN CMDGEN util/regtool.py -d ./hw/ip/otp_ctrl/data/otp_ctrl.hjson -->
## Summary of the **`core`** interface's registers

| Name                                                                                   | Offset   |   Length | Description                                                                                         |
|:---------------------------------------------------------------------------------------|:---------|---------:|:----------------------------------------------------------------------------------------------------|
| otp_ctrl.[`INTR_STATE`](#intr_state)                                                   | 0x0      |        4 | Interrupt State Register                                                                            |
| otp_ctrl.[`INTR_ENABLE`](#intr_enable)                                                 | 0x4      |        4 | Interrupt Enable Register                                                                           |
| otp_ctrl.[`INTR_TEST`](#intr_test)                                                     | 0x8      |        4 | Interrupt Test Register                                                                             |
| otp_ctrl.[`ALERT_TEST`](#alert_test)                                                   | 0xc      |        4 | Alert Test Register                                                                                 |
| otp_ctrl.[`STATUS`](#status)                                                           | 0x10     |        4 | OTP status register.                                                                                |
| otp_ctrl.[`ERR_CODE_0`](#err_code)                                                     | 0x14     |        4 | This register holds information about error conditions that occurred in the agents                  |
| otp_ctrl.[`ERR_CODE_1`](#err_code)                                                     | 0x18     |        4 | This register holds information about error conditions that occurred in the agents                  |
| otp_ctrl.[`ERR_CODE_2`](#err_code)                                                     | 0x1c     |        4 | This register holds information about error conditions that occurred in the agents                  |
| otp_ctrl.[`ERR_CODE_3`](#err_code)                                                     | 0x20     |        4 | This register holds information about error conditions that occurred in the agents                  |
| otp_ctrl.[`ERR_CODE_4`](#err_code)                                                     | 0x24     |        4 | This register holds information about error conditions that occurred in the agents                  |
| otp_ctrl.[`ERR_CODE_5`](#err_code)                                                     | 0x28     |        4 | This register holds information about error conditions that occurred in the agents                  |
| otp_ctrl.[`ERR_CODE_6`](#err_code)                                                     | 0x2c     |        4 | This register holds information about error conditions that occurred in the agents                  |
| otp_ctrl.[`ERR_CODE_7`](#err_code)                                                     | 0x30     |        4 | This register holds information about error conditions that occurred in the agents                  |
| otp_ctrl.[`ERR_CODE_8`](#err_code)                                                     | 0x34     |        4 | This register holds information about error conditions that occurred in the agents                  |
| otp_ctrl.[`ERR_CODE_9`](#err_code)                                                     | 0x38     |        4 | This register holds information about error conditions that occurred in the agents                  |
| otp_ctrl.[`ERR_CODE_10`](#err_code)                                                    | 0x3c     |        4 | This register holds information about error conditions that occurred in the agents                  |
| otp_ctrl.[`ERR_CODE_11`](#err_code)                                                    | 0x40     |        4 | This register holds information about error conditions that occurred in the agents                  |
| otp_ctrl.[`ERR_CODE_12`](#err_code)                                                    | 0x44     |        4 | This register holds information about error conditions that occurred in the agents                  |
| otp_ctrl.[`DIRECT_ACCESS_REGWEN`](#direct_access_regwen)                               | 0x48     |        4 | Register write enable for all direct access interface registers.                                    |
| otp_ctrl.[`DIRECT_ACCESS_CMD`](#direct_access_cmd)                                     | 0x4c     |        4 | Command register for direct accesses.                                                               |
| otp_ctrl.[`DIRECT_ACCESS_ADDRESS`](#direct_access_address)                             | 0x50     |        4 | Address register for direct accesses.                                                               |
| otp_ctrl.[`DIRECT_ACCESS_WDATA_0`](#direct_access_wdata)                               | 0x54     |        4 | Write data for direct accesses.                                                                     |
| otp_ctrl.[`DIRECT_ACCESS_WDATA_1`](#direct_access_wdata)                               | 0x58     |        4 | Write data for direct accesses.                                                                     |
| otp_ctrl.[`DIRECT_ACCESS_RDATA_0`](#direct_access_rdata)                               | 0x5c     |        4 | Read data for direct accesses.                                                                      |
| otp_ctrl.[`DIRECT_ACCESS_RDATA_1`](#direct_access_rdata)                               | 0x60     |        4 | Read data for direct accesses.                                                                      |
| otp_ctrl.[`CHECK_TRIGGER_REGWEN`](#check_trigger_regwen)                               | 0x64     |        4 | Register write enable for !!CHECK_TRIGGER.                                                          |
| otp_ctrl.[`CHECK_TRIGGER`](#check_trigger)                                             | 0x68     |        4 | Command register for direct accesses.                                                               |
| otp_ctrl.[`CHECK_REGWEN`](#check_regwen)                                               | 0x6c     |        4 | Register write enable for !!INTEGRITY_CHECK_PERIOD and !!CONSISTENCY_CHECK_PERIOD.                  |
| otp_ctrl.[`CHECK_TIMEOUT`](#check_timeout)                                             | 0x70     |        4 | Timeout value for the integrity and consistency checks.                                             |
| otp_ctrl.[`INTEGRITY_CHECK_PERIOD`](#integrity_check_period)                           | 0x74     |        4 | This value specifies the maximum period that can be generated pseudo-randomly.                      |
| otp_ctrl.[`CONSISTENCY_CHECK_PERIOD`](#consistency_check_period)                       | 0x78     |        4 | This value specifies the maximum period that can be generated pseudo-randomly.                      |
| otp_ctrl.[`VENDOR_TEST_READ_LOCK`](#vendor_test_read_lock)                             | 0x7c     |        4 | Runtime read lock for the VENDOR_TEST partition.                                                    |
| otp_ctrl.[`CREATOR_SW_CFG_READ_LOCK`](#creator_sw_cfg_read_lock)                       | 0x80     |        4 | Runtime read lock for the CREATOR_SW_CFG partition.                                                 |
| otp_ctrl.[`OWNER_SW_CFG_READ_LOCK`](#owner_sw_cfg_read_lock)                           | 0x84     |        4 | Runtime read lock for the OWNER_SW_CFG partition.                                                   |
| otp_ctrl.[`ROT_CREATOR_AUTH_CODESIGN_READ_LOCK`](#rot_creator_auth_codesign_read_lock) | 0x88     |        4 | Runtime read lock for the ROT_CREATOR_AUTH_CODESIGN partition.                                      |
| otp_ctrl.[`ROT_CREATOR_AUTH_STATE_READ_LOCK`](#rot_creator_auth_state_read_lock)       | 0x8c     |        4 | Runtime read lock for the ROT_CREATOR_AUTH_STATE partition.                                         |
| otp_ctrl.[`VENDOR_TEST_DIGEST_0`](#vendor_test_digest)                                 | 0x90     |        4 | Integrity digest for the VENDOR_TEST partition.                                                     |
| otp_ctrl.[`VENDOR_TEST_DIGEST_1`](#vendor_test_digest)                                 | 0x94     |        4 | Integrity digest for the VENDOR_TEST partition.                                                     |
| otp_ctrl.[`CREATOR_SW_CFG_DIGEST_0`](#creator_sw_cfg_digest)                           | 0x98     |        4 | Integrity digest for the CREATOR_SW_CFG partition.                                                  |
| otp_ctrl.[`CREATOR_SW_CFG_DIGEST_1`](#creator_sw_cfg_digest)                           | 0x9c     |        4 | Integrity digest for the CREATOR_SW_CFG partition.                                                  |
| otp_ctrl.[`OWNER_SW_CFG_DIGEST_0`](#owner_sw_cfg_digest)                               | 0xa0     |        4 | Integrity digest for the OWNER_SW_CFG partition.                                                    |
| otp_ctrl.[`OWNER_SW_CFG_DIGEST_1`](#owner_sw_cfg_digest)                               | 0xa4     |        4 | Integrity digest for the OWNER_SW_CFG partition.                                                    |
| otp_ctrl.[`ROT_CREATOR_AUTH_CODESIGN_DIGEST_0`](#rot_creator_auth_codesign_digest)     | 0xa8     |        4 | Integrity digest for the ROT_CREATOR_AUTH_CODESIGN partition.                                       |
| otp_ctrl.[`ROT_CREATOR_AUTH_CODESIGN_DIGEST_1`](#rot_creator_auth_codesign_digest)     | 0xac     |        4 | Integrity digest for the ROT_CREATOR_AUTH_CODESIGN partition.                                       |
| otp_ctrl.[`ROT_CREATOR_AUTH_STATE_DIGEST_0`](#rot_creator_auth_state_digest)           | 0xb0     |        4 | Integrity digest for the ROT_CREATOR_AUTH_STATE partition.                                          |
| otp_ctrl.[`ROT_CREATOR_AUTH_STATE_DIGEST_1`](#rot_creator_auth_state_digest)           | 0xb4     |        4 | Integrity digest for the ROT_CREATOR_AUTH_STATE partition.                                          |
| otp_ctrl.[`HW_CFG0_DIGEST_0`](#hw_cfg0_digest)                                         | 0xb8     |        4 | Integrity digest for the HW_CFG0 partition.                                                         |
| otp_ctrl.[`HW_CFG0_DIGEST_1`](#hw_cfg0_digest)                                         | 0xbc     |        4 | Integrity digest for the HW_CFG0 partition.                                                         |
| otp_ctrl.[`HW_CFG1_DIGEST_0`](#hw_cfg1_digest)                                         | 0xc0     |        4 | Integrity digest for the HW_CFG1 partition.                                                         |
| otp_ctrl.[`HW_CFG1_DIGEST_1`](#hw_cfg1_digest)                                         | 0xc4     |        4 | Integrity digest for the HW_CFG1 partition.                                                         |
| otp_ctrl.[`SECRET0_DIGEST_0`](#secret0_digest)                                         | 0xc8     |        4 | Integrity digest for the SECRET0 partition.                                                         |
| otp_ctrl.[`SECRET0_DIGEST_1`](#secret0_digest)                                         | 0xcc     |        4 | Integrity digest for the SECRET0 partition.                                                         |
| otp_ctrl.[`SECRET1_DIGEST_0`](#secret1_digest)                                         | 0xd0     |        4 | Integrity digest for the SECRET1 partition.                                                         |
| otp_ctrl.[`SECRET1_DIGEST_1`](#secret1_digest)                                         | 0xd4     |        4 | Integrity digest for the SECRET1 partition.                                                         |
| otp_ctrl.[`SECRET2_DIGEST_0`](#secret2_digest)                                         | 0xd8     |        4 | Integrity digest for the SECRET2 partition.                                                         |
| otp_ctrl.[`SECRET2_DIGEST_1`](#secret2_digest)                                         | 0xdc     |        4 | Integrity digest for the SECRET2 partition.                                                         |
| otp_ctrl.[`SW_CFG_WINDOW`](#sw_cfg_window)                                             | 0x800    |     2048 | Any read to this window directly maps to the corresponding offset in the creator and owner software |

## INTR_STATE
Interrupt State Register
- Offset: `0x0`
- Reset default: `0x0`
- Reset mask: `0x3`

### Fields

```wavejson
{"reg": [{"name": "otp_operation_done", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"name": "otp_error", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"bits": 30}], "config": {"lanes": 1, "fontsize": 10, "vspace": 200}}
```

|  Bits  |  Type  |  Reset  | Name               | Description                                                                                                      |
|:------:|:------:|:-------:|:-------------------|:-----------------------------------------------------------------------------------------------------------------|
|  31:2  |        |         |                    | Reserved                                                                                                         |
|   1    |  rw1c  |   0x0   | otp_error          | An error has occurred in the OTP controller. Check the [`ERR_CODE`](#err_code) register to get more information. |
|   0    |  rw1c  |   0x0   | otp_operation_done | A direct access command or digest calculation operation has completed.                                           |

## INTR_ENABLE
Interrupt Enable Register
- Offset: `0x4`
- Reset default: `0x0`
- Reset mask: `0x3`

### Fields

```wavejson
{"reg": [{"name": "otp_operation_done", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "otp_error", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 30}], "config": {"lanes": 1, "fontsize": 10, "vspace": 200}}
```

|  Bits  |  Type  |  Reset  | Name               | Description                                                                  |
|:------:|:------:|:-------:|:-------------------|:-----------------------------------------------------------------------------|
|  31:2  |        |         |                    | Reserved                                                                     |
|   1    |   rw   |   0x0   | otp_error          | Enable interrupt when [`INTR_STATE.otp_error`](#intr_state) is set.          |
|   0    |   rw   |   0x0   | otp_operation_done | Enable interrupt when [`INTR_STATE.otp_operation_done`](#intr_state) is set. |

## INTR_TEST
Interrupt Test Register
- Offset: `0x8`
- Reset default: `0x0`
- Reset mask: `0x3`

### Fields

```wavejson
{"reg": [{"name": "otp_operation_done", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "otp_error", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 30}], "config": {"lanes": 1, "fontsize": 10, "vspace": 200}}
```

|  Bits  |  Type  |  Reset  | Name               | Description                                                           |
|:------:|:------:|:-------:|:-------------------|:----------------------------------------------------------------------|
|  31:2  |        |         |                    | Reserved                                                              |
|   1    |   wo   |   0x0   | otp_error          | Write 1 to force [`INTR_STATE.otp_error`](#intr_state) to 1.          |
|   0    |   wo   |   0x0   | otp_operation_done | Write 1 to force [`INTR_STATE.otp_operation_done`](#intr_state) to 1. |

## ALERT_TEST
Alert Test Register
- Offset: `0xc`
- Reset default: `0x0`
- Reset mask: `0x1f`

### Fields

```wavejson
{"reg": [{"name": "fatal_macro_error", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "fatal_check_error", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "fatal_bus_integ_error", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "fatal_prim_otp_alert", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "recov_prim_otp_alert", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 27}], "config": {"lanes": 1, "fontsize": 10, "vspace": 230}}
```

|  Bits  |  Type  |  Reset  | Name                  | Description                                      |
|:------:|:------:|:-------:|:----------------------|:-------------------------------------------------|
|  31:5  |        |         |                       | Reserved                                         |
|   4    |   wo   |   0x0   | recov_prim_otp_alert  | Write 1 to trigger one alert event of this kind. |
|   3    |   wo   |   0x0   | fatal_prim_otp_alert  | Write 1 to trigger one alert event of this kind. |
|   2    |   wo   |   0x0   | fatal_bus_integ_error | Write 1 to trigger one alert event of this kind. |
|   1    |   wo   |   0x0   | fatal_check_error     | Write 1 to trigger one alert event of this kind. |
|   0    |   wo   |   0x0   | fatal_macro_error     | Write 1 to trigger one alert event of this kind. |

## STATUS
OTP status register.
- Offset: `0x10`
- Reset default: `0x0`
- Reset mask: `0xfffff`

### Fields

```wavejson
{"reg": [{"name": "VENDOR_TEST_ERROR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "CREATOR_SW_CFG_ERROR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "OWNER_SW_CFG_ERROR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "ROT_CREATOR_AUTH_CODESIGN_ERROR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "ROT_CREATOR_AUTH_STATE_ERROR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "HW_CFG0_ERROR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "HW_CFG1_ERROR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "SECRET0_ERROR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "SECRET1_ERROR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "SECRET2_ERROR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "LIFE_CYCLE_ERROR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "DAI_ERROR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "LCI_ERROR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "TIMEOUT_ERROR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "LFSR_FSM_ERROR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "SCRAMBLING_FSM_ERROR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "KEY_DERIV_FSM_ERROR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "BUS_INTEG_ERROR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "DAI_IDLE", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "CHECK_PENDING", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 12}], "config": {"lanes": 1, "fontsize": 10, "vspace": 330}}
```

|  Bits  |  Type  |  Reset  | Name                            | Description                                                                                                                                           |
|:------:|:------:|:-------:|:--------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31:20  |        |         |                                 | Reserved                                                                                                                                              |
|   19   |   ro   |   0x0   | CHECK_PENDING                   | Set to 1 if an integrity or consistency check triggered by the LFSR timer or via [`CHECK_TRIGGER`](#check_trigger) is pending.                        |
|   18   |   ro   |   0x0   | DAI_IDLE                        | Set to 1 if the DAI is idle and ready to accept commands.                                                                                             |
|   17   |   ro   |   0x0   | BUS_INTEG_ERROR                 | This bit is set to 1 if a fatal bus integrity fault is detected. This error triggers a fatal_bus_integ_error alert.                                   |
|   16   |   ro   |   0x0   | KEY_DERIV_FSM_ERROR             | Set to 1 if the key derivation FSM has reached an invalid state. This raises an fatal_check_error alert and is an unrecoverable error condition.      |
|   15   |   ro   |   0x0   | SCRAMBLING_FSM_ERROR            | Set to 1 if the scrambling datapath FSM has reached an invalid state. This raises an fatal_check_error alert and is an unrecoverable error condition. |
|   14   |   ro   |   0x0   | LFSR_FSM_ERROR                  | Set to 1 if the LFSR timer FSM has reached an invalid state. This raises an fatal_check_error alert and is an unrecoverable error condition.          |
|   13   |   ro   |   0x0   | TIMEOUT_ERROR                   | Set to 1 if an integrity or consistency check times out. This raises an fatal_check_error alert and is an unrecoverable error condition.              |
|   12   |   ro   |   0x0   | LCI_ERROR                       | Set to 1 if an error occurred in the LCI. If set to 1, SW should check the [`ERR_CODE`](#err_code) register at the corresponding index.               |
|   11   |   ro   |   0x0   | DAI_ERROR                       | Set to 1 if an error occurred in the DAI. If set to 1, SW should check the [`ERR_CODE`](#err_code) register at the corresponding index.               |
|   10   |   ro   |   0x0   | LIFE_CYCLE_ERROR                | Set to 1 if an error occurred in this partition. If set to 1, SW should check the [`ERR_CODE`](#err_code) register at the corresponding index.        |
|   9    |   ro   |   0x0   | SECRET2_ERROR                   | Set to 1 if an error occurred in this partition. If set to 1, SW should check the [`ERR_CODE`](#err_code) register at the corresponding index.        |
|   8    |   ro   |   0x0   | SECRET1_ERROR                   | Set to 1 if an error occurred in this partition. If set to 1, SW should check the [`ERR_CODE`](#err_code) register at the corresponding index.        |
|   7    |   ro   |   0x0   | SECRET0_ERROR                   | Set to 1 if an error occurred in this partition. If set to 1, SW should check the [`ERR_CODE`](#err_code) register at the corresponding index.        |
|   6    |   ro   |   0x0   | HW_CFG1_ERROR                   | Set to 1 if an error occurred in this partition. If set to 1, SW should check the [`ERR_CODE`](#err_code) register at the corresponding index.        |
|   5    |   ro   |   0x0   | HW_CFG0_ERROR                   | Set to 1 if an error occurred in this partition. If set to 1, SW should check the [`ERR_CODE`](#err_code) register at the corresponding index.        |
|   4    |   ro   |   0x0   | ROT_CREATOR_AUTH_STATE_ERROR    | Set to 1 if an error occurred in this partition. If set to 1, SW should check the [`ERR_CODE`](#err_code) register at the corresponding index.        |
|   3    |   ro   |   0x0   | ROT_CREATOR_AUTH_CODESIGN_ERROR | Set to 1 if an error occurred in this partition. If set to 1, SW should check the [`ERR_CODE`](#err_code) register at the corresponding index.        |
|   2    |   ro   |   0x0   | OWNER_SW_CFG_ERROR              | Set to 1 if an error occurred in this partition. If set to 1, SW should check the [`ERR_CODE`](#err_code) register at the corresponding index.        |
|   1    |   ro   |   0x0   | CREATOR_SW_CFG_ERROR            | Set to 1 if an error occurred in this partition. If set to 1, SW should check the [`ERR_CODE`](#err_code) register at the corresponding index.        |
|   0    |   ro   |   0x0   | VENDOR_TEST_ERROR               | Set to 1 if an error occurred in this partition. If set to 1, SW should check the [`ERR_CODE`](#err_code) register at the corresponding index.        |

## ERR_CODE
This register holds information about error conditions that occurred in the agents
interacting with the OTP macro via the internal bus. The error codes should be checked
if the partitions, DAI or LCI flag an error in the [`STATUS`](#status) register, or when an
[`INTR_STATE.otp_error`](#intr_state) has been triggered. Note that all errors trigger an otp_error
interrupt, and in addition some errors may trigger either an fatal_macro_error or an
fatal_check_error alert.
- Reset default: `0x0`
- Reset mask: `0x7`

### Instances

| Name        | Offset   |
|:------------|:---------|
| ERR_CODE_0  | 0x14     |
| ERR_CODE_1  | 0x18     |
| ERR_CODE_2  | 0x1c     |
| ERR_CODE_3  | 0x20     |
| ERR_CODE_4  | 0x24     |
| ERR_CODE_5  | 0x28     |
| ERR_CODE_6  | 0x2c     |
| ERR_CODE_7  | 0x30     |
| ERR_CODE_8  | 0x34     |
| ERR_CODE_9  | 0x38     |
| ERR_CODE_10 | 0x3c     |
| ERR_CODE_11 | 0x40     |
| ERR_CODE_12 | 0x44     |


### Fields

```wavejson
{"reg": [{"name": "ERR_CODE", "bits": 3, "attr": ["ro"], "rotate": -90}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 100}}
```

|  Bits  |  Type  |  Reset  | Name                            |
|:------:|:------:|:-------:|:--------------------------------|
|  31:3  |        |         | Reserved                        |
|  2:0   |   ro   |   0x0   | [ERR_CODE](#err_code--err_code) |

### ERR_CODE . ERR_CODE

| Value   | Name                    | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|:--------|:------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0x0     | NO_ERROR                | No error condition has occurred.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 0x1     | MACRO_ERROR             | Returned if the OTP macro command was invalid or did not complete successfully due to a macro malfunction. This error should never occur during normal operation and is not recoverable. This error triggers an fatal_macro_error alert.                                                                                                                                                                                                                                                                                                                                                                             |
| 0x2     | MACRO_ECC_CORR_ERROR    | A correctable ECC error has occured during an OTP read operation. The corresponding controller automatically recovers from this error when issuing a new command.                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 0x3     | MACRO_ECC_UNCORR_ERROR  | An uncorrectable ECC error has occurred during an OTP read operation. This error should never occur during normal operation and is not recoverable. If this error is present this may be a sign that the device is malfunctioning. This error triggers an fatal_macro_error alert.                                                                                                                                                                                                                                                                                                                                   |
| 0x4     | MACRO_WRITE_BLANK_ERROR | This error is returned if a programming operation attempted to clear a bit that has previously been programmed to 1. The corresponding controller automatically recovers from this error when issuing a new command. Note however that the affected OTP word may be left in an inconsistent state if this error occurs. This can cause several issues when the word is accessed again (either as part of a regular read operation, as part of the readout at boot, or as part of a background check). It is important that SW ensures that each word is only written once, since this can render the device useless. |
| 0x5     | ACCESS_ERROR            | This error indicates that a locked memory region has been accessed. The corresponding controller automatically recovers from this error when issuing a new command.                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 0x6     | CHECK_FAIL_ERROR        | An ECC, integrity or consistency mismatch has been detected in the buffer registers. This error should never occur during normal operation and is not recoverable. This error triggers an fatal_check_error alert.                                                                                                                                                                                                                                                                                                                                                                                                   |
| 0x7     | FSM_STATE_ERROR         | The FSM of the corresponding controller has reached an invalid state, or the FSM has been moved into a terminal error state due to an escalation action via lc_escalate_en_i. This error should never occur during normal operation and is not recoverable. If this error is present, this is a sign that the device has fallen victim to an invasive attack. This error triggers an fatal_check_error alert.                                                                                                                                                                                                        |


## DIRECT_ACCESS_REGWEN
Register write enable for all direct access interface registers.
- Offset: `0x48`
- Reset default: `0x1`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "DIRECT_ACCESS_REGWEN", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 220}}
```

|  Bits  |  Type  |  Reset  | Name                                                                |
|:------:|:------:|:-------:|:--------------------------------------------------------------------|
|  31:1  |        |         | Reserved                                                            |
|   0    |  rw0c  |   0x1   | [DIRECT_ACCESS_REGWEN](#direct_access_regwen--direct_access_regwen) |

### DIRECT_ACCESS_REGWEN . DIRECT_ACCESS_REGWEN
This bit controls whether the DAI registers can be written.
Write 0 to it in order to clear the bit.

Note that the hardware also modulates this bit and sets it to 0 temporarily
during an OTP operation such that the corresponding address and data registers
cannot be modified while an operation is pending. The [`DAI_IDLE`](#dai_idle) status bit
will also be set to 0 in such a case.

## DIRECT_ACCESS_CMD
Command register for direct accesses.
- Offset: `0x4c`
- Reset default: `0x0`
- Reset mask: `0x7`
- Register enable: [`DIRECT_ACCESS_REGWEN`](#direct_access_regwen)

### Fields

```wavejson
{"reg": [{"name": "RD", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"name": "WR", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"name": "DIGEST", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                                                                                                                                                                                                                                                                                |
|:------:|:------:|:-------:|:-------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  31:3  |        |         |        | Reserved                                                                                                                                                                                                                                                                                   |
|   2    | r0w1c  |   0x0   | DIGEST | Initiates the digest calculation and locking sequence for the partition specified by [`DIRECT_ACCESS_ADDRESS.`](#direct_access_address)                                                                                                                                                    |
|   1    | r0w1c  |   0x0   | WR     | Initiates a programming sequence that writes the data in [`DIRECT_ACCESS_WDATA_0`](#direct_access_wdata_0) and [`DIRECT_ACCESS_WDATA_1`](#direct_access_wdata_1) (for 64bit partitions) to the location specified by [`DIRECT_ACCESS_ADDRESS.`](#direct_access_address)                    |
|   0    | r0w1c  |   0x0   | RD     | Initiates a readout sequence that reads the location specified by [`DIRECT_ACCESS_ADDRESS.`](#direct_access_address) The command places the data read into [`DIRECT_ACCESS_RDATA_0`](#direct_access_rdata_0) and [`DIRECT_ACCESS_RDATA_1`](#direct_access_rdata_1) (for 64bit partitions). |

## DIRECT_ACCESS_ADDRESS
Address register for direct accesses.
- Offset: `0x50`
- Reset default: `0x0`
- Reset mask: `0x7ff`
- Register enable: [`DIRECT_ACCESS_REGWEN`](#direct_access_regwen)

### Fields

```wavejson
{"reg": [{"name": "DIRECT_ACCESS_ADDRESS", "bits": 11, "attr": ["rw"], "rotate": -90}, {"bits": 21}], "config": {"lanes": 1, "fontsize": 10, "vspace": 230}}
```

|  Bits  |  Type  |  Reset  | Name                                                                   |
|:------:|:------:|:-------:|:-----------------------------------------------------------------------|
| 31:11  |        |         | Reserved                                                               |
|  10:0  |   rw   |   0x0   | [DIRECT_ACCESS_ADDRESS](#direct_access_address--direct_access_address) |

### DIRECT_ACCESS_ADDRESS . DIRECT_ACCESS_ADDRESS
This is the address for the OTP word to be read or written through
the direct access interface. Note that the address is aligned to the access size
internally, hence bits 1:0 are ignored for 32bit accesses, and bits 2:0 are ignored
for 64bit accesses.

For the digest calculation command, set this register to the partition base offset.

## DIRECT_ACCESS_WDATA
Write data for direct accesses.
Hardware automatically determines the access granule (32bit or 64bit) based on which
partition is being written to.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name                  | Offset   |
|:----------------------|:---------|
| DIRECT_ACCESS_WDATA_0 | 0x54     |
| DIRECT_ACCESS_WDATA_1 | 0x58     |


### Fields

```wavejson
{"reg": [{"name": "DIRECT_ACCESS_WDATA", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                | Description   |
|:------:|:------:|:-------:|:--------------------|:--------------|
|  31:0  |   rw   |   0x0   | DIRECT_ACCESS_WDATA |               |

## DIRECT_ACCESS_RDATA
Read data for direct accesses.
Hardware automatically determines the access granule (32bit or 64bit) based on which
partition is read from.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name                  | Offset   |
|:----------------------|:---------|
| DIRECT_ACCESS_RDATA_0 | 0x5c     |
| DIRECT_ACCESS_RDATA_1 | 0x60     |


### Fields

```wavejson
{"reg": [{"name": "DIRECT_ACCESS_RDATA", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                | Description   |
|:------:|:------:|:-------:|:--------------------|:--------------|
|  31:0  |   ro   |   0x0   | DIRECT_ACCESS_RDATA |               |

## CHECK_TRIGGER_REGWEN
Register write enable for [`CHECK_TRIGGER.`](#check_trigger)
- Offset: `0x64`
- Reset default: `0x1`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "CHECK_TRIGGER_REGWEN", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 220}}
```

|  Bits  |  Type  |  Reset  | Name                 | Description                                                                                                             |
|:------:|:------:|:-------:|:---------------------|:------------------------------------------------------------------------------------------------------------------------|
|  31:1  |        |         |                      | Reserved                                                                                                                |
|   0    |  rw0c  |   0x1   | CHECK_TRIGGER_REGWEN | When cleared to 0, the [`CHECK_TRIGGER`](#check_trigger) register cannot be written anymore. Write 0 to clear this bit. |

## CHECK_TRIGGER
Command register for direct accesses.
- Offset: `0x68`
- Reset default: `0x0`
- Reset mask: `0x3`
- Register enable: [`CHECK_TRIGGER_REGWEN`](#check_trigger_regwen)

### Fields

```wavejson
{"reg": [{"name": "INTEGRITY", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"name": "CONSISTENCY", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"bits": 30}], "config": {"lanes": 1, "fontsize": 10, "vspace": 130}}
```

|  Bits  |  Type  |  Reset  | Name                                       |
|:------:|:------:|:-------:|:-------------------------------------------|
|  31:2  |        |         | Reserved                                   |
|   1    | r0w1c  |   0x0   | [CONSISTENCY](#check_trigger--consistency) |
|   0    | r0w1c  |   0x0   | [INTEGRITY](#check_trigger--integrity)     |

### CHECK_TRIGGER . CONSISTENCY
Writing 1 to this bit triggers a consistency check. SW should monitor [`STATUS.CHECK_PENDING`](#status)
and wait until the check has been completed. If there are any errors, those will be flagged
in the [`STATUS`](#status) and [`ERR_CODE`](#err_code) registers, and via interrupts and alerts.

### CHECK_TRIGGER . INTEGRITY
Writing 1 to this bit triggers an integrity check. SW should monitor [`STATUS.CHECK_PENDING`](#status)
and wait until the check has been completed. If there are any errors, those will be flagged
in the [`STATUS`](#status) and [`ERR_CODE`](#err_code) registers, and via the interrupts and alerts.

## CHECK_REGWEN
Register write enable for [`INTEGRITY_CHECK_PERIOD`](#integrity_check_period) and [`CONSISTENCY_CHECK_PERIOD.`](#consistency_check_period)
- Offset: `0x6c`
- Reset default: `0x1`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "CHECK_REGWEN", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 140}}
```

|  Bits  |  Type  |  Reset  | Name         | Description                                                                                                                                                                                        |
|:------:|:------:|:-------:|:-------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  31:1  |        |         |              | Reserved                                                                                                                                                                                           |
|   0    |  rw0c  |   0x1   | CHECK_REGWEN | When cleared to 0, [`INTEGRITY_CHECK_PERIOD`](#integrity_check_period) and [`CONSISTENCY_CHECK_PERIOD`](#consistency_check_period) registers cannot be written anymore. Write 0 to clear this bit. |

## CHECK_TIMEOUT
Timeout value for the integrity and consistency checks.
- Offset: `0x70`
- Reset default: `0x0`
- Reset mask: `0xffffffff`
- Register enable: [`CHECK_REGWEN`](#check_regwen)

### Fields

```wavejson
{"reg": [{"name": "CHECK_TIMEOUT", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                                           |
|:------:|:------:|:-------:|:-----------------------------------------------|
|  31:0  |   rw   |   0x0   | [CHECK_TIMEOUT](#check_timeout--check_timeout) |

### CHECK_TIMEOUT . CHECK_TIMEOUT
Timeout value in cycles for the for the integrity and consistency checks. If an integrity or consistency
check does not complete within the timeout window, an error will be flagged in the [`STATUS`](#status) register,
an otp_error interrupt will be raised, and an fatal_check_error alert will be sent out. The timeout should
be set to a large value to stay on the safe side. The maximum check time can be upper bounded by the
number of cycles it takes to readout, scramble and digest the entire OTP array. Since this amounts to
roughly 25k cycles, it is recommended to set this value to at least 100'000 cycles in order to stay on the
safe side. A value of zero disables the timeout mechanism (default).

## INTEGRITY_CHECK_PERIOD
This value specifies the maximum period that can be generated pseudo-randomly.
Only applies to the HW_CFG* and SECRET* partitions once they are locked.
- Offset: `0x74`
- Reset default: `0x0`
- Reset mask: `0xffffffff`
- Register enable: [`CHECK_REGWEN`](#check_regwen)

### Fields

```wavejson
{"reg": [{"name": "INTEGRITY_CHECK_PERIOD", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                                                                      |
|:------:|:------:|:-------:|:--------------------------------------------------------------------------|
|  31:0  |   rw   |   0x0   | [INTEGRITY_CHECK_PERIOD](#integrity_check_period--integrity_check_period) |

### INTEGRITY_CHECK_PERIOD . INTEGRITY_CHECK_PERIOD
The pseudo-random period is generated using a 40bit LFSR internally, and this register defines
the bit mask to be applied to the LFSR output in order to limit its range. The value of this
register is left shifted by 8bits and the lower bits are set to 8'hFF in order to form the 40bit mask.
A recommended value is 0x3_FFFF, corresponding to a maximum period of ~2.8s at 24MHz.
A value of zero disables the timer (default). Note that a one-off check can always be triggered via
[`CHECK_TRIGGER.INTEGRITY.`](#check_trigger)

## CONSISTENCY_CHECK_PERIOD
This value specifies the maximum period that can be generated pseudo-randomly.
This applies to the LIFE_CYCLE partition and the HW_CFG* and SECRET* partitions once they are locked.
- Offset: `0x78`
- Reset default: `0x0`
- Reset mask: `0xffffffff`
- Register enable: [`CHECK_REGWEN`](#check_regwen)

### Fields

```wavejson
{"reg": [{"name": "CONSISTENCY_CHECK_PERIOD", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                                                                            |
|:------:|:------:|:-------:|:--------------------------------------------------------------------------------|
|  31:0  |   rw   |   0x0   | [CONSISTENCY_CHECK_PERIOD](#consistency_check_period--consistency_check_period) |

### CONSISTENCY_CHECK_PERIOD . CONSISTENCY_CHECK_PERIOD
The pseudo-random period is generated using a 40bit LFSR internally, and this register defines
the bit mask to be applied to the LFSR output in order to limit its range. The value of this
register is left shifted by 8bits and the lower bits are set to 8'hFF in order to form the 40bit mask.
A recommended value is 0x3FF_FFFF, corresponding to a maximum period of ~716s at 24MHz.
A value of zero disables the timer (default). Note that a one-off check can always be triggered via
[`CHECK_TRIGGER.CONSISTENCY.`](#check_trigger)

## VENDOR_TEST_READ_LOCK
Runtime read lock for the VENDOR_TEST partition.
- Offset: `0x7c`
- Reset default: `0x1`
- Reset mask: `0x1`
- Register enable: [`DIRECT_ACCESS_REGWEN`](#direct_access_regwen)

### Fields

```wavejson
{"reg": [{"name": "VENDOR_TEST_READ_LOCK", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 230}}
```

|  Bits  |  Type  |  Reset  | Name                  | Description                                                                                       |
|:------:|:------:|:-------:|:----------------------|:--------------------------------------------------------------------------------------------------|
|  31:1  |        |         |                       | Reserved                                                                                          |
|   0    |  rw0c  |   0x1   | VENDOR_TEST_READ_LOCK | When cleared to 0, read access to the VENDOR_TEST partition is locked. Write 0 to clear this bit. |

## CREATOR_SW_CFG_READ_LOCK
Runtime read lock for the CREATOR_SW_CFG partition.
- Offset: `0x80`
- Reset default: `0x1`
- Reset mask: `0x1`
- Register enable: [`DIRECT_ACCESS_REGWEN`](#direct_access_regwen)

### Fields

```wavejson
{"reg": [{"name": "CREATOR_SW_CFG_READ_LOCK", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 260}}
```

|  Bits  |  Type  |  Reset  | Name                     | Description                                                                                          |
|:------:|:------:|:-------:|:-------------------------|:-----------------------------------------------------------------------------------------------------|
|  31:1  |        |         |                          | Reserved                                                                                             |
|   0    |  rw0c  |   0x1   | CREATOR_SW_CFG_READ_LOCK | When cleared to 0, read access to the CREATOR_SW_CFG partition is locked. Write 0 to clear this bit. |

## OWNER_SW_CFG_READ_LOCK
Runtime read lock for the OWNER_SW_CFG partition.
- Offset: `0x84`
- Reset default: `0x1`
- Reset mask: `0x1`
- Register enable: [`DIRECT_ACCESS_REGWEN`](#direct_access_regwen)

### Fields

```wavejson
{"reg": [{"name": "OWNER_SW_CFG_READ_LOCK", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 240}}
```

|  Bits  |  Type  |  Reset  | Name                   | Description                                                                                        |
|:------:|:------:|:-------:|:-----------------------|:---------------------------------------------------------------------------------------------------|
|  31:1  |        |         |                        | Reserved                                                                                           |
|   0    |  rw0c  |   0x1   | OWNER_SW_CFG_READ_LOCK | When cleared to 0, read access to the OWNER_SW_CFG partition is locked. Write 0 to clear this bit. |

## ROT_CREATOR_AUTH_CODESIGN_READ_LOCK
Runtime read lock for the ROT_CREATOR_AUTH_CODESIGN partition.
- Offset: `0x88`
- Reset default: `0x1`
- Reset mask: `0x1`
- Register enable: [`DIRECT_ACCESS_REGWEN`](#direct_access_regwen)

### Fields

```wavejson
{"reg": [{"name": "ROT_CREATOR_AUTH_CODESIGN_READ_LOCK", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 370}}
```

|  Bits  |  Type  |  Reset  | Name                                | Description                                                                                                     |
|:------:|:------:|:-------:|:------------------------------------|:----------------------------------------------------------------------------------------------------------------|
|  31:1  |        |         |                                     | Reserved                                                                                                        |
|   0    |  rw0c  |   0x1   | ROT_CREATOR_AUTH_CODESIGN_READ_LOCK | When cleared to 0, read access to the ROT_CREATOR_AUTH_CODESIGN partition is locked. Write 0 to clear this bit. |

## ROT_CREATOR_AUTH_STATE_READ_LOCK
Runtime read lock for the ROT_CREATOR_AUTH_STATE partition.
- Offset: `0x8c`
- Reset default: `0x1`
- Reset mask: `0x1`
- Register enable: [`DIRECT_ACCESS_REGWEN`](#direct_access_regwen)

### Fields

```wavejson
{"reg": [{"name": "ROT_CREATOR_AUTH_STATE_READ_LOCK", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 340}}
```

|  Bits  |  Type  |  Reset  | Name                             | Description                                                                                                  |
|:------:|:------:|:-------:|:---------------------------------|:-------------------------------------------------------------------------------------------------------------|
|  31:1  |        |         |                                  | Reserved                                                                                                     |
|   0    |  rw0c  |   0x1   | ROT_CREATOR_AUTH_STATE_READ_LOCK | When cleared to 0, read access to the ROT_CREATOR_AUTH_STATE partition is locked. Write 0 to clear this bit. |

## VENDOR_TEST_DIGEST
Integrity digest for the VENDOR_TEST partition.
The integrity digest is 0 by default. Software must write this
digest value via the direct access interface in order to lock the partition.
After a reset, write access to the VENDOR_TEST partition is locked and
the digest becomes visible in this CSR.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name                 | Offset   |
|:---------------------|:---------|
| VENDOR_TEST_DIGEST_0 | 0x90     |
| VENDOR_TEST_DIGEST_1 | 0x94     |


### Fields

```wavejson
{"reg": [{"name": "VENDOR_TEST_DIGEST", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name               | Description   |
|:------:|:------:|:-------:|:-------------------|:--------------|
|  31:0  |   ro   |   0x0   | VENDOR_TEST_DIGEST |               |

## CREATOR_SW_CFG_DIGEST
Integrity digest for the CREATOR_SW_CFG partition.
The integrity digest is 0 by default. Software must write this
digest value via the direct access interface in order to lock the partition.
After a reset, write access to the CREATOR_SW_CFG partition is locked and
the digest becomes visible in this CSR.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name                    | Offset   |
|:------------------------|:---------|
| CREATOR_SW_CFG_DIGEST_0 | 0x98     |
| CREATOR_SW_CFG_DIGEST_1 | 0x9c     |


### Fields

```wavejson
{"reg": [{"name": "CREATOR_SW_CFG_DIGEST", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                  | Description   |
|:------:|:------:|:-------:|:----------------------|:--------------|
|  31:0  |   ro   |   0x0   | CREATOR_SW_CFG_DIGEST |               |

## OWNER_SW_CFG_DIGEST
Integrity digest for the OWNER_SW_CFG partition.
The integrity digest is 0 by default. Software must write this
digest value via the direct access interface in order to lock the partition.
After a reset, write access to the OWNER_SW_CFG partition is locked and
the digest becomes visible in this CSR.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name                  | Offset   |
|:----------------------|:---------|
| OWNER_SW_CFG_DIGEST_0 | 0xa0     |
| OWNER_SW_CFG_DIGEST_1 | 0xa4     |


### Fields

```wavejson
{"reg": [{"name": "OWNER_SW_CFG_DIGEST", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                | Description   |
|:------:|:------:|:-------:|:--------------------|:--------------|
|  31:0  |   ro   |   0x0   | OWNER_SW_CFG_DIGEST |               |

## ROT_CREATOR_AUTH_CODESIGN_DIGEST
Integrity digest for the ROT_CREATOR_AUTH_CODESIGN partition.
The integrity digest is 0 by default. Software must write this
digest value via the direct access interface in order to lock the partition.
After a reset, write access to the ROT_CREATOR_AUTH_CODESIGN partition is locked and
the digest becomes visible in this CSR.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name                               | Offset   |
|:-----------------------------------|:---------|
| ROT_CREATOR_AUTH_CODESIGN_DIGEST_0 | 0xa8     |
| ROT_CREATOR_AUTH_CODESIGN_DIGEST_1 | 0xac     |


### Fields

```wavejson
{"reg": [{"name": "ROT_CREATOR_AUTH_CODESIGN_DIGEST", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                             | Description   |
|:------:|:------:|:-------:|:---------------------------------|:--------------|
|  31:0  |   ro   |   0x0   | ROT_CREATOR_AUTH_CODESIGN_DIGEST |               |

## ROT_CREATOR_AUTH_STATE_DIGEST
Integrity digest for the ROT_CREATOR_AUTH_STATE partition.
The integrity digest is 0 by default. Software must write this
digest value via the direct access interface in order to lock the partition.
After a reset, write access to the ROT_CREATOR_AUTH_STATE partition is locked and
the digest becomes visible in this CSR.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name                            | Offset   |
|:--------------------------------|:---------|
| ROT_CREATOR_AUTH_STATE_DIGEST_0 | 0xb0     |
| ROT_CREATOR_AUTH_STATE_DIGEST_1 | 0xb4     |


### Fields

```wavejson
{"reg": [{"name": "ROT_CREATOR_AUTH_STATE_DIGEST", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                          | Description   |
|:------:|:------:|:-------:|:------------------------------|:--------------|
|  31:0  |   ro   |   0x0   | ROT_CREATOR_AUTH_STATE_DIGEST |               |

## HW_CFG0_DIGEST
Integrity digest for the HW_CFG0 partition.
The integrity digest is 0 by default. The digest calculation can be triggered via the [`DIRECT_ACCESS_CMD.`](#direct_access_cmd)
After a reset, the digest then becomes visible in this CSR, and the corresponding partition becomes write-locked.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name             | Offset   |
|:-----------------|:---------|
| HW_CFG0_DIGEST_0 | 0xb8     |
| HW_CFG0_DIGEST_1 | 0xbc     |


### Fields

```wavejson
{"reg": [{"name": "HW_CFG0_DIGEST", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name           | Description   |
|:------:|:------:|:-------:|:---------------|:--------------|
|  31:0  |   ro   |   0x0   | HW_CFG0_DIGEST |               |

## HW_CFG1_DIGEST
Integrity digest for the HW_CFG1 partition.
The integrity digest is 0 by default. The digest calculation can be triggered via the [`DIRECT_ACCESS_CMD.`](#direct_access_cmd)
After a reset, the digest then becomes visible in this CSR, and the corresponding partition becomes write-locked.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name             | Offset   |
|:-----------------|:---------|
| HW_CFG1_DIGEST_0 | 0xc0     |
| HW_CFG1_DIGEST_1 | 0xc4     |


### Fields

```wavejson
{"reg": [{"name": "HW_CFG1_DIGEST", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name           | Description   |
|:------:|:------:|:-------:|:---------------|:--------------|
|  31:0  |   ro   |   0x0   | HW_CFG1_DIGEST |               |

## SECRET0_DIGEST
Integrity digest for the SECRET0 partition.
The integrity digest is 0 by default. The digest calculation can be triggered via the [`DIRECT_ACCESS_CMD.`](#direct_access_cmd)
After a reset, the digest then becomes visible in this CSR, and the corresponding partition becomes write-locked.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name             | Offset   |
|:-----------------|:---------|
| SECRET0_DIGEST_0 | 0xc8     |
| SECRET0_DIGEST_1 | 0xcc     |


### Fields

```wavejson
{"reg": [{"name": "SECRET0_DIGEST", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name           | Description   |
|:------:|:------:|:-------:|:---------------|:--------------|
|  31:0  |   ro   |   0x0   | SECRET0_DIGEST |               |

## SECRET1_DIGEST
Integrity digest for the SECRET1 partition.
The integrity digest is 0 by default. The digest calculation can be triggered via the [`DIRECT_ACCESS_CMD.`](#direct_access_cmd)
After a reset, the digest then becomes visible in this CSR, and the corresponding partition becomes write-locked.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name             | Offset   |
|:-----------------|:---------|
| SECRET1_DIGEST_0 | 0xd0     |
| SECRET1_DIGEST_1 | 0xd4     |


### Fields

```wavejson
{"reg": [{"name": "SECRET1_DIGEST", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name           | Description   |
|:------:|:------:|:-------:|:---------------|:--------------|
|  31:0  |   ro   |   0x0   | SECRET1_DIGEST |               |

## SECRET2_DIGEST
Integrity digest for the SECRET2 partition.
The integrity digest is 0 by default. The digest calculation can be triggered via the [`DIRECT_ACCESS_CMD.`](#direct_access_cmd)
After a reset, the digest then becomes visible in this CSR, and the corresponding partition becomes write-locked.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name             | Offset   |
|:-----------------|:---------|
| SECRET2_DIGEST_0 | 0xd8     |
| SECRET2_DIGEST_1 | 0xdc     |


### Fields

```wavejson
{"reg": [{"name": "SECRET2_DIGEST", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name           | Description   |
|:------:|:------:|:-------:|:---------------|:--------------|
|  31:0  |   ro   |   0x0   | SECRET2_DIGEST |               |

## SW_CFG_WINDOW
Any read to this window directly maps to the corresponding offset in the creator and owner software
config partitions, and triggers an OTP readout of the bytes requested. Note that the transaction
will block until OTP readout has completed.

- Word Aligned Offset Range: `0x800`to`0xffc`
- Size (words): `512`
- Access: `ro`
- Byte writes are *not* supported.

## Summary of the **`prim`** interface's registers

| Name                     | Offset   |   Length | Description   |
|:-------------------------|:---------|---------:|:--------------|
| otp_ctrl.[`CSR0`](#csr0) | 0x0      |        4 |               |
| otp_ctrl.[`CSR1`](#csr1) | 0x4      |        4 |               |
| otp_ctrl.[`CSR2`](#csr2) | 0x8      |        4 |               |
| otp_ctrl.[`CSR3`](#csr3) | 0xc      |        4 |               |
| otp_ctrl.[`CSR4`](#csr4) | 0x10     |        4 |               |
| otp_ctrl.[`CSR5`](#csr5) | 0x14     |        4 |               |
| otp_ctrl.[`CSR6`](#csr6) | 0x18     |        4 |               |
| otp_ctrl.[`CSR7`](#csr7) | 0x1c     |        4 |               |

## CSR0

- Offset: `0x0`
- Reset default: `0x0`
- Reset mask: `0x7ff3ff7`

### Fields

```wavejson
{"reg": [{"name": "field0", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "field1", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "field2", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 1}, {"name": "field3", "bits": 10, "attr": ["rw"], "rotate": 0}, {"bits": 2}, {"name": "field4", "bits": 11, "attr": ["rw"], "rotate": 0}, {"bits": 5}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description   |
|:------:|:------:|:-------:|:-------|:--------------|
| 31:27  |        |         |        | Reserved      |
| 26:16  |   rw   |   0x0   | field4 |               |
| 15:14  |        |         |        | Reserved      |
|  13:4  |   rw   |   0x0   | field3 |               |
|   3    |        |         |        | Reserved      |
|   2    |   rw   |   0x0   | field2 |               |
|   1    |   rw   |   0x0   | field1 |               |
|   0    |   rw   |   0x0   | field0 |               |

## CSR1

- Offset: `0x4`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "field0", "bits": 7, "attr": ["rw"], "rotate": 0}, {"name": "field1", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "field2", "bits": 7, "attr": ["rw"], "rotate": 0}, {"name": "field3", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "field4", "bits": 16, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description   |
|:------:|:------:|:-------:|:-------|:--------------|
| 31:16  |   rw   |   0x0   | field4 |               |
|   15   |   rw   |   0x0   | field3 |               |
|  14:8  |   rw   |   0x0   | field2 |               |
|   7    |   rw   |   0x0   | field1 |               |
|  6:0   |   rw   |   0x0   | field0 |               |

## CSR2

- Offset: `0x8`
- Reset default: `0x0`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "field0", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description   |
|:------:|:------:|:-------:|:-------|:--------------|
|  31:1  |        |         |        | Reserved      |
|   0    |   rw   |   0x0   | field0 |               |

## CSR3

- Offset: `0xc`
- Reset default: `0x0`
- Reset mask: `0x7f3ff7`

### Fields

```wavejson
{"reg": [{"name": "field0", "bits": 3, "attr": ["rw1c"], "rotate": -90}, {"bits": 1}, {"name": "field1", "bits": 10, "attr": ["rw1c"], "rotate": 0}, {"bits": 2}, {"name": "field2", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"name": "field3", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "field4", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "field5", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "field6", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "field7", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "field8", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 9}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description   |
|:------:|:------:|:-------:|:-------|:--------------|
| 31:23  |        |         |        | Reserved      |
|   22   |   ro   |   0x0   | field8 |               |
|   21   |   ro   |   0x0   | field7 |               |
|   20   |   ro   |   0x0   | field6 |               |
|   19   |   ro   |   0x0   | field5 |               |
|   18   |   ro   |   0x0   | field4 |               |
|   17   |   ro   |   0x0   | field3 |               |
|   16   |  rw1c  |   0x0   | field2 |               |
| 15:14  |        |         |        | Reserved      |
|  13:4  |  rw1c  |   0x0   | field1 |               |
|   3    |        |         |        | Reserved      |
|  2:0   |  rw1c  |   0x0   | field0 |               |

## CSR4

- Offset: `0x10`
- Reset default: `0x0`
- Reset mask: `0x73ff`

### Fields

```wavejson
{"reg": [{"name": "field0", "bits": 10, "attr": ["rw"], "rotate": 0}, {"bits": 2}, {"name": "field1", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "field2", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "field3", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 17}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description   |
|:------:|:------:|:-------:|:-------|:--------------|
| 31:15  |        |         |        | Reserved      |
|   14   |   rw   |   0x0   | field3 |               |
|   13   |   rw   |   0x0   | field2 |               |
|   12   |   rw   |   0x0   | field1 |               |
| 11:10  |        |         |        | Reserved      |
|  9:0   |   rw   |   0x0   | field0 |               |

## CSR5

- Offset: `0x14`
- Reset default: `0x0`
- Reset mask: `0xffff3fff`

### Fields

```wavejson
{"reg": [{"name": "field0", "bits": 6, "attr": ["rw"], "rotate": 0}, {"name": "field1", "bits": 2, "attr": ["rw"], "rotate": -90}, {"name": "field2", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "field3", "bits": 3, "attr": ["ro"], "rotate": -90}, {"name": "field4", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "field5", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 2}, {"name": "field6", "bits": 16, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description   |
|:------:|:------:|:-------:|:-------|:--------------|
| 31:16  |   rw   |   0x0   | field6 |               |
| 15:14  |        |         |        | Reserved      |
|   13   |   ro   |   0x0   | field5 |               |
|   12   |   ro   |   0x0   | field4 |               |
|  11:9  |   ro   |   0x0   | field3 |               |
|   8    |   ro   |   0x0   | field2 |               |
|  7:6   |   rw   |   0x0   | field1 |               |
|  5:0   |   rw   |   0x0   | field0 |               |

## CSR6

- Offset: `0x18`
- Reset default: `0x0`
- Reset mask: `0xffff1bff`

### Fields

```wavejson
{"reg": [{"name": "field0", "bits": 10, "attr": ["rw"], "rotate": 0}, {"bits": 1}, {"name": "field1", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "field2", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 3}, {"name": "field3", "bits": 16, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description   |
|:------:|:------:|:-------:|:-------|:--------------|
| 31:16  |   rw   |   0x0   | field3 |               |
| 15:13  |        |         |        | Reserved      |
|   12   |   rw   |   0x0   | field2 |               |
|   11   |   rw   |   0x0   | field1 |               |
|   10   |        |         |        | Reserved      |
|  9:0   |   rw   |   0x0   | field0 |               |

## CSR7

- Offset: `0x1c`
- Reset default: `0x0`
- Reset mask: `0xc73f`

### Fields

```wavejson
{"reg": [{"name": "field0", "bits": 6, "attr": ["ro"], "rotate": 0}, {"bits": 2}, {"name": "field1", "bits": 3, "attr": ["ro"], "rotate": -90}, {"bits": 3}, {"name": "field2", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "field3", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 16}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description   |
|:------:|:------:|:-------:|:-------|:--------------|
| 31:16  |        |         |        | Reserved      |
|   15   |   ro   |   0x0   | field3 |               |
|   14   |   ro   |   0x0   | field2 |               |
| 13:11  |        |         |        | Reserved      |
|  10:8  |   ro   |   0x0   | field1 |               |
|  7:6   |        |         |        | Reserved      |
|  5:0   |   ro   |   0x0   | field0 |               |


<!-- END CMDGEN -->

================================== Ai Message ==================================
Tool Calls:
  list_dir (call_6mV8bRegR0cCRNMHVge8vBzg)
 Call ID: call_6mV8bRegR0cCRNMHVge8vBzg
  Args:
    dir_path: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl
================================= Tool Message =================================
Name: list_dir

Files in /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl:
otp_ctrl.sv otp_ctrl_core_reg_top.sv otp_ctrl_dai.sv otp_ctrl_ecc_reg.sv otp_ctrl_kdi.sv otp_ctrl_lci.sv otp_ctrl_lfsr_timer.sv otp_ctrl_part_buf.sv otp_ctrl_part_pkg.sv otp_ctrl_part_unbuf.sv otp_ctrl_pkg.sv otp_ctrl_prim_reg_top.sv otp_ctrl_reg_pkg.sv otp_ctrl_scrmbl.sv otp_ctrl_token_const.sv

Directories in /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl:

================================== Ai Message ==================================
Tool Calls:
  run_verilator_agent (call_U6MOYnGv3qeTpRsKLus4RpRg)
 Call ID: call_U6MOYnGv3qeTpRsKLus4RpRg
  Args:
    ip: otp_ctrl
================================ Human Message =================================

Run a security analysis on the otp_ctrl IP.

    Inspect the logs of failing runs and determine if there are security issues in the RTL.
    If any security issues are found, provide a detailed explanation of the issue and its location in the RTL code.
================================== Ai Message ==================================

[{'text': "I'll run a security analysis on the otp_ctrl IP by executing its verilator tests and then inspect any failing tests for potential security issues.", 'type': 'text'}, {'id': 'toolu_015zedsMqDWnkvXgKhaJmshJ', 'input': {'ip': 'otp_ctrl'}, 'name': 'run_verilator_tests', 'type': 'tool_use'}]
Tool Calls:
  run_verilator_tests (toolu_015zedsMqDWnkvXgKhaJmshJ)
 Call ID: toolu_015zedsMqDWnkvXgKhaJmshJ
  Args:
    ip: otp_ctrl
================================= Tool Message =================================
Name: run_verilator_tests

 0 processes.
FAILED: Build did NOT complete successfully (0 packages loaded, 3187 targets configured)
ERROR: Couldn't start the build. Unable to run tests

================================== Ai Message ==================================

I apologize, but it seems there was an issue running the verilator tests for the otp_ctrl IP. The build process failed to complete successfully, which means we can't analyze the test results as planned.

To proceed with the security analysis, we need to:

1. Check if the otp_ctrl IP exists in the system
2. Verify the correct path or name for the IP
3. Ensure the build environment is properly set up

Could you please confirm the correct name of the IP you want to analyze? Alternatively, we could try to list the available IPs in the system to identify the correct one to test.
================================= Tool Message =================================
Name: run_verilator_agent

I apologize, but it seems there was an issue running the verilator tests for the otp_ctrl IP. The build process failed to complete successfully, which means we can't analyze the test results as planned.

To proceed with the security analysis, we need to:

1. Check if the otp_ctrl IP exists in the system
2. Verify the correct path or name for the IP
3. Ensure the build environment is properly set up

Could you please confirm the correct name of the IP you want to analyze? Alternatively, we could try to list the available IPs in the system to identify the correct one to test.
================================== Ai Message ==================================
Tool Calls:
  run_linter_agent (call_EtnZqmVtEKYzXrTzXOQeKsqJ)
 Call ID: call_EtnZqmVtEKYzXrTzXOQeKsqJ
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_core_reg_top.sv
    top_module: otp_ctrl_core_reg_top
    security_objective: register interface security and access control
================================ Human Message =================================

Are there security concerns related to register interface security and access control in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_core_reg_top.sv

    And the top module is:

    otp_ctrl_core_reg_top

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Register Top module auto-generated by `reggen`

`include "prim_assert.sv"

module otp_ctrl_core_reg_top (
  input clk_i,
  input rst_ni,
  input  tlul_pkg::tl_h2d_t tl_i,
  output tlul_pkg::tl_d2h_t tl_o,

  // Output port for window
  output tlul_pkg::tl_h2d_t tl_win_o,
  input  tlul_pkg::tl_d2h_t tl_win_i,

  // To HW
  output otp_ctrl_reg_pkg::otp_ctrl_core_reg2hw_t reg2hw, // Write
  input  otp_ctrl_reg_pkg::otp_ctrl_core_hw2reg_t hw2reg, // Read

  // Integrity check errors
  output logic intg_err_o
);

  import otp_ctrl_reg_pkg::* ;

  localparam int AW = 12;
  localparam int DW = 32;
  localparam int DBW = DW/8;                    // Byte Width

  // register signals
  logic           reg_we;
  logic           reg_re;
  logic [AW-1:0]  reg_addr;
  logic [DW-1:0]  reg_wdata;
  logic [DBW-1:0] reg_be;
  logic [DW-1:0]  reg_rdata;
  logic           reg_error;

  logic          addrmiss, wr_err;

  logic [DW-1:0] reg_rdata_next;
  logic reg_busy;

  tlul_pkg::tl_h2d_t tl_reg_h2d;
  tlul_pkg::tl_d2h_t tl_reg_d2h;


  // incoming payload check
  logic intg_err;
  tlul_cmd_intg_chk u_chk (
    .tl_i(tl_i),
    .err_o(intg_err)
  );

  // also check for spurious write enables
  logic reg_we_err;
  logic [55:0] reg_we_check;
  prim_reg_we_check #(
    .OneHotWidth(56)
  ) u_prim_reg_we_check (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .oh_i  (reg_we_check),
    .en_i  (reg_we && !addrmiss),
    .err_o (reg_we_err)
  );

  logic err_q;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      err_q <= '0;
    end else if (intg_err || reg_we_err) begin
      err_q <= 1'b1;
    end
  end

  // integrity error output is permanent and should be used for alert generation
  // register errors are transactional
  assign intg_err_o = err_q | intg_err | reg_we_err;

  // outgoing integrity generation
  tlul_pkg::tl_d2h_t tl_o_pre;
  tlul_rsp_intg_gen #(
    .EnableRspIntgGen(1),
    .EnableDataIntgGen(1)
  ) u_rsp_intg_gen (
    .tl_i(tl_o_pre),
    .tl_o(tl_o)
  );

  tlul_pkg::tl_h2d_t tl_socket_h2d [2];
  tlul_pkg::tl_d2h_t tl_socket_d2h [2];

  logic [0:0] reg_steer;

  // socket_1n connection
  assign tl_reg_h2d = tl_socket_h2d[1];
  assign tl_socket_d2h[1] = tl_reg_d2h;

  assign tl_win_o = tl_socket_h2d[0];
  assign tl_socket_d2h[0] = tl_win_i;

  // Create Socket_1n
  tlul_socket_1n #(
    .N            (2),
    .HReqPass     (1'b1),
    .HRspPass     (1'b1),
    .DReqPass     ({2{1'b1}}),
    .DRspPass     ({2{1'b1}}),
    .HReqDepth    (4'h0),
    .HRspDepth    (4'h0),
    .DReqDepth    ({2{4'h0}}),
    .DRspDepth    ({2{4'h0}}),
    .ExplicitErrs (1'b0)
  ) u_socket (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),
    .tl_h_i (tl_i),
    .tl_h_o (tl_o_pre),
    .tl_d_o (tl_socket_h2d),
    .tl_d_i (tl_socket_d2h),
    .dev_select_i (reg_steer)
  );

  // Create steering logic
  always_comb begin
    reg_steer =
        tl_i.a_address[AW-1:0] inside {[2048:4095]} ? 1'd0 :
        // Default set to register
        1'd1;

    // Override this in case of an integrity error
    if (intg_err) begin
      reg_steer = 1'd1;
    end
  end

  tlul_adapter_reg #(
    .RegAw(AW),
    .RegDw(DW),
    .EnableDataIntgGen(0)
  ) u_reg_if (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),

    .tl_i (tl_reg_h2d),
    .tl_o (tl_reg_d2h),

    .en_ifetch_i(prim_mubi_pkg::MuBi4False),
    .intg_error_o(),

    .we_o    (reg_we),
    .re_o    (reg_re),
    .addr_o  (reg_addr),
    .wdata_o (reg_wdata),
    .be_o    (reg_be),
    .busy_i  (reg_busy),
    .rdata_i (reg_rdata),
    .error_i (reg_error)
  );

  // cdc oversampling signals

  assign reg_rdata = reg_rdata_next ;
  assign reg_error = addrmiss | wr_err | intg_err;

  // Define SW related signals
  // Format: <reg>_<field>_{wd|we|qs}
  //        or <reg>_{wd|we|qs} if field == 1 or 0
  logic intr_state_we;
  logic intr_state_otp_operation_done_qs;
  logic intr_state_otp_operation_done_wd;
  logic intr_state_otp_error_qs;
  logic intr_state_otp_error_wd;
  logic intr_enable_we;
  logic intr_enable_otp_operation_done_qs;
  logic intr_enable_otp_operation_done_wd;
  logic intr_enable_otp_error_qs;
  logic intr_enable_otp_error_wd;
  logic intr_test_we;
  logic intr_test_otp_operation_done_wd;
  logic intr_test_otp_error_wd;
  logic alert_test_we;
  logic alert_test_fatal_macro_error_wd;
  logic alert_test_fatal_check_error_wd;
  logic alert_test_fatal_bus_integ_error_wd;
  logic alert_test_fatal_prim_otp_alert_wd;
  logic alert_test_recov_prim_otp_alert_wd;
  logic status_re;
  logic status_vendor_test_error_qs;
  logic status_creator_sw_cfg_error_qs;
  logic status_owner_sw_cfg_error_qs;
  logic status_rot_creator_auth_codesign_error_qs;
  logic status_rot_creator_auth_state_error_qs;
  logic status_hw_cfg0_error_qs;
  logic status_hw_cfg1_error_qs;
  logic status_secret0_error_qs;
  logic status_secret1_error_qs;
  logic status_secret2_error_qs;
  logic status_life_cycle_error_qs;
  logic status_dai_error_qs;
  logic status_lci_error_qs;
  logic status_timeout_error_qs;
  logic status_lfsr_fsm_error_qs;
  logic status_scrambling_fsm_error_qs;
  logic status_key_deriv_fsm_error_qs;
  logic status_bus_integ_error_qs;
  logic status_dai_idle_qs;
  logic status_check_pending_qs;
  logic err_code_0_re;
  logic [2:0] err_code_0_qs;
  logic err_code_1_re;
  logic [2:0] err_code_1_qs;
  logic err_code_2_re;
  logic [2:0] err_code_2_qs;
  logic err_code_3_re;
  logic [2:0] err_code_3_qs;
  logic err_code_4_re;
  logic [2:0] err_code_4_qs;
  logic err_code_5_re;
  logic [2:0] err_code_5_qs;
  logic err_code_6_re;
  logic [2:0] err_code_6_qs;
  logic err_code_7_re;
  logic [2:0] err_code_7_qs;
  logic err_code_8_re;
  logic [2:0] err_code_8_qs;
  logic err_code_9_re;
  logic [2:0] err_code_9_qs;
  logic err_code_10_re;
  logic [2:0] err_code_10_qs;
  logic err_code_11_re;
  logic [2:0] err_code_11_qs;
  logic err_code_12_re;
  logic [2:0] err_code_12_qs;
  logic direct_access_regwen_re;
  logic direct_access_regwen_we;
  logic direct_access_regwen_qs;
  logic direct_access_regwen_wd;
  logic direct_access_cmd_we;
  logic direct_access_cmd_rd_wd;
  logic direct_access_cmd_wr_wd;
  logic direct_access_cmd_digest_wd;
  logic direct_access_address_we;
  logic [10:0] direct_access_address_qs;
  logic [10:0] direct_access_address_wd;
  logic direct_access_wdata_0_we;
  logic [31:0] direct_access_wdata_0_qs;
  logic [31:0] direct_access_wdata_0_wd;
  logic direct_access_wdata_1_we;
  logic [31:0] direct_access_wdata_1_qs;
  logic [31:0] direct_access_wdata_1_wd;
  logic direct_access_rdata_0_re;
  logic [31:0] direct_access_rdata_0_qs;
  logic direct_access_rdata_1_re;
  logic [31:0] direct_access_rdata_1_qs;
  logic check_trigger_regwen_we;
  logic check_trigger_regwen_qs;
  logic check_trigger_regwen_wd;
  logic check_trigger_we;
  logic check_trigger_integrity_wd;
  logic check_trigger_consistency_wd;
  logic check_regwen_we;
  logic check_regwen_qs;
  logic check_regwen_wd;
  logic check_timeout_we;
  logic [31:0] check_timeout_qs;
  logic [31:0] check_timeout_wd;
  logic integrity_check_period_we;
  logic [31:0] integrity_check_period_qs;
  logic [31:0] integrity_check_period_wd;
  logic consistency_check_period_we;
  logic [31:0] consistency_check_period_qs;
  logic [31:0] consistency_check_period_wd;
  logic vendor_test_read_lock_we;
  logic vendor_test_read_lock_qs;
  logic vendor_test_read_lock_wd;
  logic creator_sw_cfg_read_lock_we;
  logic creator_sw_cfg_read_lock_qs;
  logic creator_sw_cfg_read_lock_wd;
  logic owner_sw_cfg_read_lock_we;
  logic owner_sw_cfg_read_lock_qs;
  logic owner_sw_cfg_read_lock_wd;
  logic rot_creator_auth_codesign_read_lock_we;
  logic rot_creator_auth_codesign_read_lock_qs;
  logic rot_creator_auth_codesign_read_lock_wd;
  logic rot_creator_auth_state_read_lock_we;
  logic rot_creator_auth_state_read_lock_qs;
  logic rot_creator_auth_state_read_lock_wd;
  logic vendor_test_digest_0_re;
  logic [31:0] vendor_test_digest_0_qs;
  logic vendor_test_digest_1_re;
  logic [31:0] vendor_test_digest_1_qs;
  logic creator_sw_cfg_digest_0_re;
  logic [31:0] creator_sw_cfg_digest_0_qs;
  logic creator_sw_cfg_digest_1_re;
  logic [31:0] creator_sw_cfg_digest_1_qs;
  logic owner_sw_cfg_digest_0_re;
  logic [31:0] owner_sw_cfg_digest_0_qs;
  logic owner_sw_cfg_digest_1_re;
  logic [31:0] owner_sw_cfg_digest_1_qs;
  logic rot_creator_auth_codesign_digest_0_re;
  logic [31:0] rot_creator_auth_codesign_digest_0_qs;
  logic rot_creator_auth_codesign_digest_1_re;
  logic [31:0] rot_creator_auth_codesign_digest_1_qs;
  logic rot_creator_auth_state_digest_0_re;
  logic [31:0] rot_creator_auth_state_digest_0_qs;
  logic rot_creator_auth_state_digest_1_re;
  logic [31:0] rot_creator_auth_state_digest_1_qs;
  logic hw_cfg0_digest_0_re;
  logic [31:0] hw_cfg0_digest_0_qs;
  logic hw_cfg0_digest_1_re;
  logic [31:0] hw_cfg0_digest_1_qs;
  logic hw_cfg1_digest_0_re;
  logic [31:0] hw_cfg1_digest_0_qs;
  logic hw_cfg1_digest_1_re;
  logic [31:0] hw_cfg1_digest_1_qs;
  logic secret0_digest_0_re;
  logic [31:0] secret0_digest_0_qs;
  logic secret0_digest_1_re;
  logic [31:0] secret0_digest_1_qs;
  logic secret1_digest_0_re;
  logic [31:0] secret1_digest_0_qs;
  logic secret1_digest_1_re;
  logic [31:0] secret1_digest_1_qs;
  logic secret2_digest_0_re;
  logic [31:0] secret2_digest_0_qs;
  logic secret2_digest_1_re;
  logic [31:0] secret2_digest_1_qs;

  // Register instances
  // R[intr_state]: V(False)
  //   F[otp_operation_done]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_otp_operation_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_otp_operation_done_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.otp_operation_done.de),
    .d      (hw2reg.intr_state.otp_operation_done.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.otp_operation_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_otp_operation_done_qs)
  );

  //   F[otp_error]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_otp_error (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_otp_error_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.otp_error.de),
    .d      (hw2reg.intr_state.otp_error.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.otp_error.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_otp_error_qs)
  );


  // R[intr_enable]: V(False)
  //   F[otp_operation_done]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_otp_operation_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_otp_operation_done_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.otp_operation_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_otp_operation_done_qs)
  );

  //   F[otp_error]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_otp_error (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_otp_error_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.otp_error.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_otp_error_qs)
  );


  // R[intr_test]: V(True)
  logic intr_test_qe;
  logic [1:0] intr_test_flds_we;
  assign intr_test_qe = &intr_test_flds_we;
  //   F[otp_operation_done]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_otp_operation_done (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_otp_operation_done_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[0]),
    .q      (reg2hw.intr_test.otp_operation_done.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.otp_operation_done.qe = intr_test_qe;

  //   F[otp_error]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_otp_error (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_otp_error_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[1]),
    .q      (reg2hw.intr_test.otp_error.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.otp_error.qe = intr_test_qe;


  // R[alert_test]: V(True)
  logic alert_test_qe;
  logic [4:0] alert_test_flds_we;
  assign alert_test_qe = &alert_test_flds_we;
  //   F[fatal_macro_error]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_fatal_macro_error (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_fatal_macro_error_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[0]),
    .q      (reg2hw.alert_test.fatal_macro_error.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.fatal_macro_error.qe = alert_test_qe;

  //   F[fatal_check_error]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_fatal_check_error (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_fatal_check_error_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[1]),
    .q      (reg2hw.alert_test.fatal_check_error.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.fatal_check_error.qe = alert_test_qe;

  //   F[fatal_bus_integ_error]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_fatal_bus_integ_error (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_fatal_bus_integ_error_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[2]),
    .q      (reg2hw.alert_test.fatal_bus_integ_error.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.fatal_bus_integ_error.qe = alert_test_qe;

  //   F[fatal_prim_otp_alert]: 3:3
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_fatal_prim_otp_alert (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_fatal_prim_otp_alert_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[3]),
    .q      (reg2hw.alert_test.fatal_prim_otp_alert.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.fatal_prim_otp_alert.qe = alert_test_qe;

  //   F[recov_prim_otp_alert]: 4:4
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_recov_prim_otp_alert (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_recov_prim_otp_alert_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[4]),
    .q      (reg2hw.alert_test.recov_prim_otp_alert.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.recov_prim_otp_alert.qe = alert_test_qe;


  // R[status]: V(True)
  //   F[vendor_test_error]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_vendor_test_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.vendor_test_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_vendor_test_error_qs)
  );

  //   F[creator_sw_cfg_error]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_creator_sw_cfg_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.creator_sw_cfg_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_creator_sw_cfg_error_qs)
  );

  //   F[owner_sw_cfg_error]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_owner_sw_cfg_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.owner_sw_cfg_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_owner_sw_cfg_error_qs)
  );

  //   F[rot_creator_auth_codesign_error]: 3:3
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_rot_creator_auth_codesign_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.rot_creator_auth_codesign_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_rot_creator_auth_codesign_error_qs)
  );

  //   F[rot_creator_auth_state_error]: 4:4
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_rot_creator_auth_state_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.rot_creator_auth_state_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_rot_creator_auth_state_error_qs)
  );

  //   F[hw_cfg0_error]: 5:5
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_hw_cfg0_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.hw_cfg0_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_hw_cfg0_error_qs)
  );

  //   F[hw_cfg1_error]: 6:6
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_hw_cfg1_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.hw_cfg1_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_hw_cfg1_error_qs)
  );

  //   F[secret0_error]: 7:7
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_secret0_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.secret0_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_secret0_error_qs)
  );

  //   F[secret1_error]: 8:8
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_secret1_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.secret1_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_secret1_error_qs)
  );

  //   F[secret2_error]: 9:9
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_secret2_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.secret2_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_secret2_error_qs)
  );

  //   F[life_cycle_error]: 10:10
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_life_cycle_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.life_cycle_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_life_cycle_error_qs)
  );

  //   F[dai_error]: 11:11
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_dai_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.dai_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_dai_error_qs)
  );

  //   F[lci_error]: 12:12
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_lci_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.lci_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_lci_error_qs)
  );

  //   F[timeout_error]: 13:13
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_timeout_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.timeout_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_timeout_error_qs)
  );

  //   F[lfsr_fsm_error]: 14:14
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_lfsr_fsm_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.lfsr_fsm_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_lfsr_fsm_error_qs)
  );

  //   F[scrambling_fsm_error]: 15:15
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_scrambling_fsm_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.scrambling_fsm_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_scrambling_fsm_error_qs)
  );

  //   F[key_deriv_fsm_error]: 16:16
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_key_deriv_fsm_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.key_deriv_fsm_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_key_deriv_fsm_error_qs)
  );

  //   F[bus_integ_error]: 17:17
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_bus_integ_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.bus_integ_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_bus_integ_error_qs)
  );

  //   F[dai_idle]: 18:18
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_dai_idle (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.dai_idle.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_dai_idle_qs)
  );

  //   F[check_pending]: 19:19
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_check_pending (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.check_pending.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_check_pending_qs)
  );


  // Subregister 0 of Multireg err_code
  // R[err_code_0]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_0 (
    .re     (err_code_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_0_qs)
  );


  // Subregister 1 of Multireg err_code
  // R[err_code_1]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_1 (
    .re     (err_code_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_1_qs)
  );


  // Subregister 2 of Multireg err_code
  // R[err_code_2]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_2 (
    .re     (err_code_2_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[2].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_2_qs)
  );


  // Subregister 3 of Multireg err_code
  // R[err_code_3]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_3 (
    .re     (err_code_3_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[3].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_3_qs)
  );


  // Subregister 4 of Multireg err_code
  // R[err_code_4]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_4 (
    .re     (err_code_4_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[4].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_4_qs)
  );


  // Subregister 5 of Multireg err_code
  // R[err_code_5]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_5 (
    .re     (err_code_5_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[5].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_5_qs)
  );


  // Subregister 6 of Multireg err_code
  // R[err_code_6]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_6 (
    .re     (err_code_6_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[6].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_6_qs)
  );


  // Subregister 7 of Multireg err_code
  // R[err_code_7]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_7 (
    .re     (err_code_7_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[7].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_7_qs)
  );


  // Subregister 8 of Multireg err_code
  // R[err_code_8]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_8 (
    .re     (err_code_8_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[8].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_8_qs)
  );


  // Subregister 9 of Multireg err_code
  // R[err_code_9]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_9 (
    .re     (err_code_9_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[9].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_9_qs)
  );


  // Subregister 10 of Multireg err_code
  // R[err_code_10]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_10 (
    .re     (err_code_10_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[10].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_10_qs)
  );


  // Subregister 11 of Multireg err_code
  // R[err_code_11]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_11 (
    .re     (err_code_11_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[11].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_11_qs)
  );


  // Subregister 12 of Multireg err_code
  // R[err_code_12]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_12 (
    .re     (err_code_12_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[12].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_12_qs)
  );


  // R[direct_access_regwen]: V(True)
  logic direct_access_regwen_qe;
  logic [0:0] direct_access_regwen_flds_we;
  assign direct_access_regwen_qe = &direct_access_regwen_flds_we;
  prim_subreg_ext #(
    .DW    (1)
  ) u_direct_access_regwen (
    .re     (direct_access_regwen_re),
    .we     (direct_access_regwen_we),
    .wd     (direct_access_regwen_wd),
    .d      (hw2reg.direct_access_regwen.d),
    .qre    (),
    .qe     (direct_access_regwen_flds_we[0]),
    .q      (reg2hw.direct_access_regwen.q),
    .ds     (),
    .qs     (direct_access_regwen_qs)
  );
  assign reg2hw.direct_access_regwen.qe = direct_access_regwen_qe;


  // R[direct_access_cmd]: V(True)
  logic direct_access_cmd_qe;
  logic [2:0] direct_access_cmd_flds_we;
  assign direct_access_cmd_qe = &direct_access_cmd_flds_we;
  // Create REGWEN-gated WE signal
  logic direct_access_cmd_gated_we;
  assign direct_access_cmd_gated_we = direct_access_cmd_we & direct_access_regwen_qs;
  //   F[rd]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_direct_access_cmd_rd (
    .re     (1'b0),
    .we     (direct_access_cmd_gated_we),
    .wd     (direct_access_cmd_rd_wd),
    .d      ('0),
    .qre    (),
    .qe     (direct_access_cmd_flds_we[0]),
    .q      (reg2hw.direct_access_cmd.rd.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.direct_access_cmd.rd.qe = direct_access_cmd_qe;

  //   F[wr]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_direct_access_cmd_wr (
    .re     (1'b0),
    .we     (direct_access_cmd_gated_we),
    .wd     (direct_access_cmd_wr_wd),
    .d      ('0),
    .qre    (),
    .qe     (direct_access_cmd_flds_we[1]),
    .q      (reg2hw.direct_access_cmd.wr.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.direct_access_cmd.wr.qe = direct_access_cmd_qe;

  //   F[digest]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_direct_access_cmd_digest (
    .re     (1'b0),
    .we     (direct_access_cmd_gated_we),
    .wd     (direct_access_cmd_digest_wd),
    .d      ('0),
    .qre    (),
    .qe     (direct_access_cmd_flds_we[2]),
    .q      (reg2hw.direct_access_cmd.digest.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.direct_access_cmd.digest.qe = direct_access_cmd_qe;


  // R[direct_access_address]: V(False)
  // Create REGWEN-gated WE signal
  logic direct_access_address_gated_we;
  assign direct_access_address_gated_we = direct_access_address_we & direct_access_regwen_qs;
  prim_subreg #(
    .DW      (11),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (11'h0),
    .Mubi    (1'b0)
  ) u_direct_access_address (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (direct_access_address_gated_we),
    .wd     (direct_access_address_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.direct_access_address.q),
    .ds     (),

    // to register interface (read)
    .qs     (direct_access_address_qs)
  );


  // Subregister 0 of Multireg direct_access_wdata
  // R[direct_access_wdata_0]: V(False)
  // Create REGWEN-gated WE signal
  logic direct_access_wdata_0_gated_we;
  assign direct_access_wdata_0_gated_we = direct_access_wdata_0_we & direct_access_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_direct_access_wdata_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (direct_access_wdata_0_gated_we),
    .wd     (direct_access_wdata_0_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.direct_access_wdata[0].q),
    .ds     (),

    // to register interface (read)
    .qs     (direct_access_wdata_0_qs)
  );


  // Subregister 1 of Multireg direct_access_wdata
  // R[direct_access_wdata_1]: V(False)
  // Create REGWEN-gated WE signal
  logic direct_access_wdata_1_gated_we;
  assign direct_access_wdata_1_gated_we = direct_access_wdata_1_we & direct_access_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_direct_access_wdata_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (direct_access_wdata_1_gated_we),
    .wd     (direct_access_wdata_1_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.direct_access_wdata[1].q),
    .ds     (),

    // to register interface (read)
    .qs     (direct_access_wdata_1_qs)
  );


  // Subregister 0 of Multireg direct_access_rdata
  // R[direct_access_rdata_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_direct_access_rdata_0 (
    .re     (direct_access_rdata_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.direct_access_rdata[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (direct_access_rdata_0_qs)
  );


  // Subregister 1 of Multireg direct_access_rdata
  // R[direct_access_rdata_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_direct_access_rdata_1 (
    .re     (direct_access_rdata_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.direct_access_rdata[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (direct_access_rdata_1_qs)
  );


  // R[check_trigger_regwen]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_check_trigger_regwen (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (check_trigger_regwen_we),
    .wd     (check_trigger_regwen_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (check_trigger_regwen_qs)
  );


  // R[check_trigger]: V(True)
  logic check_trigger_qe;
  logic [1:0] check_trigger_flds_we;
  assign check_trigger_qe = &check_trigger_flds_we;
  // Create REGWEN-gated WE signal
  logic check_trigger_gated_we;
  assign check_trigger_gated_we = check_trigger_we & check_trigger_regwen_qs;
  //   F[integrity]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_check_trigger_integrity (
    .re     (1'b0),
    .we     (check_trigger_gated_we),
    .wd     (check_trigger_integrity_wd),
    .d      ('0),
    .qre    (),
    .qe     (check_trigger_flds_we[0]),
    .q      (reg2hw.check_trigger.integrity.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.check_trigger.integrity.qe = check_trigger_qe;

  //   F[consistency]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_check_trigger_consistency (
    .re     (1'b0),
    .we     (check_trigger_gated_we),
    .wd     (check_trigger_consistency_wd),
    .d      ('0),
    .qre    (),
    .qe     (check_trigger_flds_we[1]),
    .q      (reg2hw.check_trigger.consistency.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.check_trigger.consistency.qe = check_trigger_qe;


  // R[check_regwen]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_check_regwen (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (check_regwen_we),
    .wd     (check_regwen_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (check_regwen_qs)
  );


  // R[check_timeout]: V(False)
  // Create REGWEN-gated WE signal
  logic check_timeout_gated_we;
  assign check_timeout_gated_we = check_timeout_we & check_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_check_timeout (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (check_timeout_gated_we),
    .wd     (check_timeout_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.check_timeout.q),
    .ds     (),

    // to register interface (read)
    .qs     (check_timeout_qs)
  );


  // R[integrity_check_period]: V(False)
  // Create REGWEN-gated WE signal
  logic integrity_check_period_gated_we;
  assign integrity_check_period_gated_we = integrity_check_period_we & check_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_integrity_check_period (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (integrity_check_period_gated_we),
    .wd     (integrity_check_period_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.integrity_check_period.q),
    .ds     (),

    // to register interface (read)
    .qs     (integrity_check_period_qs)
  );


  // R[consistency_check_period]: V(False)
  // Create REGWEN-gated WE signal
  logic consistency_check_period_gated_we;
  assign consistency_check_period_gated_we = consistency_check_period_we & check_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_consistency_check_period (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (consistency_check_period_gated_we),
    .wd     (consistency_check_period_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.consistency_check_period.q),
    .ds     (),

    // to register interface (read)
    .qs     (consistency_check_period_qs)
  );


  // R[vendor_test_read_lock]: V(False)
  // Create REGWEN-gated WE signal
  logic vendor_test_read_lock_gated_we;
  assign vendor_test_read_lock_gated_we = vendor_test_read_lock_we & direct_access_regwen_qs;
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_vendor_test_read_lock (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (vendor_test_read_lock_gated_we),
    .wd     (vendor_test_read_lock_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.vendor_test_read_lock.q),
    .ds     (),

    // to register interface (read)
    .qs     (vendor_test_read_lock_qs)
  );


  // R[creator_sw_cfg_read_lock]: V(False)
  // Create REGWEN-gated WE signal
  logic creator_sw_cfg_read_lock_gated_we;
  assign creator_sw_cfg_read_lock_gated_we = creator_sw_cfg_read_lock_we & direct_access_regwen_qs;
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_creator_sw_cfg_read_lock (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (creator_sw_cfg_read_lock_gated_we),
    .wd     (creator_sw_cfg_read_lock_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.creator_sw_cfg_read_lock.q),
    .ds     (),

    // to register interface (read)
    .qs     (creator_sw_cfg_read_lock_qs)
  );


  // R[owner_sw_cfg_read_lock]: V(False)
  // Create REGWEN-gated WE signal
  logic owner_sw_cfg_read_lock_gated_we;
  assign owner_sw_cfg_read_lock_gated_we = owner_sw_cfg_read_lock_we & direct_access_regwen_qs;
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_owner_sw_cfg_read_lock (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (owner_sw_cfg_read_lock_gated_we),
    .wd     (owner_sw_cfg_read_lock_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.owner_sw_cfg_read_lock.q),
    .ds     (),

    // to register interface (read)
    .qs     (owner_sw_cfg_read_lock_qs)
  );


  // R[rot_creator_auth_codesign_read_lock]: V(False)
  // Create REGWEN-gated WE signal
  logic rot_creator_auth_codesign_read_lock_gated_we;
  assign rot_creator_auth_codesign_read_lock_gated_we =
    rot_creator_auth_codesign_read_lock_we & direct_access_regwen_qs;
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_rot_creator_auth_codesign_read_lock (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (rot_creator_auth_codesign_read_lock_gated_we),
    .wd     (rot_creator_auth_codesign_read_lock_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.rot_creator_auth_codesign_read_lock.q),
    .ds     (),

    // to register interface (read)
    .qs     (rot_creator_auth_codesign_read_lock_qs)
  );


  // R[rot_creator_auth_state_read_lock]: V(False)
  // Create REGWEN-gated WE signal
  logic rot_creator_auth_state_read_lock_gated_we;
  assign rot_creator_auth_state_read_lock_gated_we =
    rot_creator_auth_state_read_lock_we & direct_access_regwen_qs;
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_rot_creator_auth_state_read_lock (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (rot_creator_auth_state_read_lock_gated_we),
    .wd     (rot_creator_auth_state_read_lock_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.rot_creator_auth_state_read_lock.q),
    .ds     (),

    // to register interface (read)
    .qs     (rot_creator_auth_state_read_lock_qs)
  );


  // Subregister 0 of Multireg vendor_test_digest
  // R[vendor_test_digest_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_vendor_test_digest_0 (
    .re     (vendor_test_digest_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.vendor_test_digest[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (vendor_test_digest_0_qs)
  );


  // Subregister 1 of Multireg vendor_test_digest
  // R[vendor_test_digest_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_vendor_test_digest_1 (
    .re     (vendor_test_digest_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.vendor_test_digest[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (vendor_test_digest_1_qs)
  );


  // Subregister 0 of Multireg creator_sw_cfg_digest
  // R[creator_sw_cfg_digest_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_creator_sw_cfg_digest_0 (
    .re     (creator_sw_cfg_digest_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.creator_sw_cfg_digest[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (creator_sw_cfg_digest_0_qs)
  );


  // Subregister 1 of Multireg creator_sw_cfg_digest
  // R[creator_sw_cfg_digest_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_creator_sw_cfg_digest_1 (
    .re     (creator_sw_cfg_digest_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.creator_sw_cfg_digest[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (creator_sw_cfg_digest_1_qs)
  );


  // Subregister 0 of Multireg owner_sw_cfg_digest
  // R[owner_sw_cfg_digest_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_owner_sw_cfg_digest_0 (
    .re     (owner_sw_cfg_digest_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.owner_sw_cfg_digest[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (owner_sw_cfg_digest_0_qs)
  );


  // Subregister 1 of Multireg owner_sw_cfg_digest
  // R[owner_sw_cfg_digest_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_owner_sw_cfg_digest_1 (
    .re     (owner_sw_cfg_digest_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.owner_sw_cfg_digest[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (owner_sw_cfg_digest_1_qs)
  );


  // Subregister 0 of Multireg rot_creator_auth_codesign_digest
  // R[rot_creator_auth_codesign_digest_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_rot_creator_auth_codesign_digest_0 (
    .re     (rot_creator_auth_codesign_digest_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.rot_creator_auth_codesign_digest[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (rot_creator_auth_codesign_digest_0_qs)
  );


  // Subregister 1 of Multireg rot_creator_auth_codesign_digest
  // R[rot_creator_auth_codesign_digest_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_rot_creator_auth_codesign_digest_1 (
    .re     (rot_creator_auth_codesign_digest_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.rot_creator_auth_codesign_digest[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (rot_creator_auth_codesign_digest_1_qs)
  );


  // Subregister 0 of Multireg rot_creator_auth_state_digest
  // R[rot_creator_auth_state_digest_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_rot_creator_auth_state_digest_0 (
    .re     (rot_creator_auth_state_digest_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.rot_creator_auth_state_digest[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (rot_creator_auth_state_digest_0_qs)
  );


  // Subregister 1 of Multireg rot_creator_auth_state_digest
  // R[rot_creator_auth_state_digest_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_rot_creator_auth_state_digest_1 (
    .re     (rot_creator_auth_state_digest_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.rot_creator_auth_state_digest[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (rot_creator_auth_state_digest_1_qs)
  );


  // Subregister 0 of Multireg hw_cfg0_digest
  // R[hw_cfg0_digest_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_hw_cfg0_digest_0 (
    .re     (hw_cfg0_digest_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.hw_cfg0_digest[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (hw_cfg0_digest_0_qs)
  );


  // Subregister 1 of Multireg hw_cfg0_digest
  // R[hw_cfg0_digest_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_hw_cfg0_digest_1 (
    .re     (hw_cfg0_digest_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.hw_cfg0_digest[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (hw_cfg0_digest_1_qs)
  );


  // Subregister 0 of Multireg hw_cfg1_digest
  // R[hw_cfg1_digest_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_hw_cfg1_digest_0 (
    .re     (hw_cfg1_digest_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.hw_cfg1_digest[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (hw_cfg1_digest_0_qs)
  );


  // Subregister 1 of Multireg hw_cfg1_digest
  // R[hw_cfg1_digest_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_hw_cfg1_digest_1 (
    .re     (hw_cfg1_digest_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.hw_cfg1_digest[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (hw_cfg1_digest_1_qs)
  );


  // Subregister 0 of Multireg secret0_digest
  // R[secret0_digest_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_secret0_digest_0 (
    .re     (secret0_digest_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.secret0_digest[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (secret0_digest_0_qs)
  );


  // Subregister 1 of Multireg secret0_digest
  // R[secret0_digest_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_secret0_digest_1 (
    .re     (secret0_digest_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.secret0_digest[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (secret0_digest_1_qs)
  );


  // Subregister 0 of Multireg secret1_digest
  // R[secret1_digest_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_secret1_digest_0 (
    .re     (secret1_digest_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.secret1_digest[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (secret1_digest_0_qs)
  );


  // Subregister 1 of Multireg secret1_digest
  // R[secret1_digest_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_secret1_digest_1 (
    .re     (secret1_digest_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.secret1_digest[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (secret1_digest_1_qs)
  );


  // Subregister 0 of Multireg secret2_digest
  // R[secret2_digest_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_secret2_digest_0 (
    .re     (secret2_digest_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.secret2_digest[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (secret2_digest_0_qs)
  );


  // Subregister 1 of Multireg secret2_digest
  // R[secret2_digest_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_secret2_digest_1 (
    .re     (secret2_digest_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.secret2_digest[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (secret2_digest_1_qs)
  );



  logic [55:0] addr_hit;
  always_comb begin
    addr_hit = '0;
    addr_hit[ 0] = (reg_addr == OTP_CTRL_INTR_STATE_OFFSET);
    addr_hit[ 1] = (reg_addr == OTP_CTRL_INTR_ENABLE_OFFSET);
    addr_hit[ 2] = (reg_addr == OTP_CTRL_INTR_TEST_OFFSET);
    addr_hit[ 3] = (reg_addr == OTP_CTRL_ALERT_TEST_OFFSET);
    addr_hit[ 4] = (reg_addr == OTP_CTRL_STATUS_OFFSET);
    addr_hit[ 5] = (reg_addr == OTP_CTRL_ERR_CODE_0_OFFSET);
    addr_hit[ 6] = (reg_addr == OTP_CTRL_ERR_CODE_1_OFFSET);
    addr_hit[ 7] = (reg_addr == OTP_CTRL_ERR_CODE_2_OFFSET);
    addr_hit[ 8] = (reg_addr == OTP_CTRL_ERR_CODE_3_OFFSET);
    addr_hit[ 9] = (reg_addr == OTP_CTRL_ERR_CODE_4_OFFSET);
    addr_hit[10] = (reg_addr == OTP_CTRL_ERR_CODE_5_OFFSET);
    addr_hit[11] = (reg_addr == OTP_CTRL_ERR_CODE_6_OFFSET);
    addr_hit[12] = (reg_addr == OTP_CTRL_ERR_CODE_7_OFFSET);
    addr_hit[13] = (reg_addr == OTP_CTRL_ERR_CODE_8_OFFSET);
    addr_hit[14] = (reg_addr == OTP_CTRL_ERR_CODE_9_OFFSET);
    addr_hit[15] = (reg_addr == OTP_CTRL_ERR_CODE_10_OFFSET);
    addr_hit[16] = (reg_addr == OTP_CTRL_ERR_CODE_11_OFFSET);
    addr_hit[17] = (reg_addr == OTP_CTRL_ERR_CODE_12_OFFSET);
    addr_hit[18] = (reg_addr == OTP_CTRL_DIRECT_ACCESS_REGWEN_OFFSET);
    addr_hit[19] = (reg_addr == OTP_CTRL_DIRECT_ACCESS_CMD_OFFSET);
    addr_hit[20] = (reg_addr == OTP_CTRL_DIRECT_ACCESS_ADDRESS_OFFSET);
    addr_hit[21] = (reg_addr == OTP_CTRL_DIRECT_ACCESS_WDATA_0_OFFSET);
    addr_hit[22] = (reg_addr == OTP_CTRL_DIRECT_ACCESS_WDATA_1_OFFSET);
    addr_hit[23] = (reg_addr == OTP_CTRL_DIRECT_ACCESS_RDATA_0_OFFSET);
    addr_hit[24] = (reg_addr == OTP_CTRL_DIRECT_ACCESS_RDATA_1_OFFSET);
    addr_hit[25] = (reg_addr == OTP_CTRL_CHECK_TRIGGER_REGWEN_OFFSET);
    addr_hit[26] = (reg_addr == OTP_CTRL_CHECK_TRIGGER_OFFSET);
    addr_hit[27] = (reg_addr == OTP_CTRL_CHECK_REGWEN_OFFSET);
    addr_hit[28] = (reg_addr == OTP_CTRL_CHECK_TIMEOUT_OFFSET);
    addr_hit[29] = (reg_addr == OTP_CTRL_INTEGRITY_CHECK_PERIOD_OFFSET);
    addr_hit[30] = (reg_addr == OTP_CTRL_CONSISTENCY_CHECK_PERIOD_OFFSET);
    addr_hit[31] = (reg_addr == OTP_CTRL_VENDOR_TEST_READ_LOCK_OFFSET);
    addr_hit[32] = (reg_addr == OTP_CTRL_CREATOR_SW_CFG_READ_LOCK_OFFSET);
    addr_hit[33] = (reg_addr == OTP_CTRL_OWNER_SW_CFG_READ_LOCK_OFFSET);
    addr_hit[34] = (reg_addr == OTP_CTRL_ROT_CREATOR_AUTH_CODESIGN_READ_LOCK_OFFSET);
    addr_hit[35] = (reg_addr == OTP_CTRL_ROT_CREATOR_AUTH_STATE_READ_LOCK_OFFSET);
    addr_hit[36] = (reg_addr == OTP_CTRL_VENDOR_TEST_DIGEST_0_OFFSET);
    addr_hit[37] = (reg_addr == OTP_CTRL_VENDOR_TEST_DIGEST_1_OFFSET);
    addr_hit[38] = (reg_addr == OTP_CTRL_CREATOR_SW_CFG_DIGEST_0_OFFSET);
    addr_hit[39] = (reg_addr == OTP_CTRL_CREATOR_SW_CFG_DIGEST_1_OFFSET);
    addr_hit[40] = (reg_addr == OTP_CTRL_OWNER_SW_CFG_DIGEST_0_OFFSET);
    addr_hit[41] = (reg_addr == OTP_CTRL_OWNER_SW_CFG_DIGEST_1_OFFSET);
    addr_hit[42] = (reg_addr == OTP_CTRL_ROT_CREATOR_AUTH_CODESIGN_DIGEST_0_OFFSET);
    addr_hit[43] = (reg_addr == OTP_CTRL_ROT_CREATOR_AUTH_CODESIGN_DIGEST_1_OFFSET);
    addr_hit[44] = (reg_addr == OTP_CTRL_ROT_CREATOR_AUTH_STATE_DIGEST_0_OFFSET);
    addr_hit[45] = (reg_addr == OTP_CTRL_ROT_CREATOR_AUTH_STATE_DIGEST_1_OFFSET);
    addr_hit[46] = (reg_addr == OTP_CTRL_HW_CFG0_DIGEST_0_OFFSET);
    addr_hit[47] = (reg_addr == OTP_CTRL_HW_CFG0_DIGEST_1_OFFSET);
    addr_hit[48] = (reg_addr == OTP_CTRL_HW_CFG1_DIGEST_0_OFFSET);
    addr_hit[49] = (reg_addr == OTP_CTRL_HW_CFG1_DIGEST_1_OFFSET);
    addr_hit[50] = (reg_addr == OTP_CTRL_SECRET0_DIGEST_0_OFFSET);
    addr_hit[51] = (reg_addr == OTP_CTRL_SECRET0_DIGEST_1_OFFSET);
    addr_hit[52] = (reg_addr == OTP_CTRL_SECRET1_DIGEST_0_OFFSET);
    addr_hit[53] = (reg_addr == OTP_CTRL_SECRET1_DIGEST_1_OFFSET);
    addr_hit[54] = (reg_addr == OTP_CTRL_SECRET2_DIGEST_0_OFFSET);
    addr_hit[55] = (reg_addr == OTP_CTRL_SECRET2_DIGEST_1_OFFSET);
  end

  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;

  // Check sub-word write is permitted
  always_comb begin
    wr_err = (reg_we &
              ((addr_hit[ 0] & (|(OTP_CTRL_CORE_PERMIT[ 0] & ~reg_be))) |
               (addr_hit[ 1] & (|(OTP_CTRL_CORE_PERMIT[ 1] & ~reg_be))) |
               (addr_hit[ 2] & (|(OTP_CTRL_CORE_PERMIT[ 2] & ~reg_be))) |
               (addr_hit[ 3] & (|(OTP_CTRL_CORE_PERMIT[ 3] & ~reg_be))) |
               (addr_hit[ 4] & (|(OTP_CTRL_CORE_PERMIT[ 4] & ~reg_be))) |
               (addr_hit[ 5] & (|(OTP_CTRL_CORE_PERMIT[ 5] & ~reg_be))) |
               (addr_hit[ 6] & (|(OTP_CTRL_CORE_PERMIT[ 6] & ~reg_be))) |
               (addr_hit[ 7] & (|(OTP_CTRL_CORE_PERMIT[ 7] & ~reg_be))) |
               (addr_hit[ 8] & (|(OTP_CTRL_CORE_PERMIT[ 8] & ~reg_be))) |
               (addr_hit[ 9] & (|(OTP_CTRL_CORE_PERMIT[ 9] & ~reg_be))) |
               (addr_hit[10] & (|(OTP_CTRL_CORE_PERMIT[10] & ~reg_be))) |
               (addr_hit[11] & (|(OTP_CTRL_CORE_PERMIT[11] & ~reg_be))) |
               (addr_hit[12] & (|(OTP_CTRL_CORE_PERMIT[12] & ~reg_be))) |
               (addr_hit[13] & (|(OTP_CTRL_CORE_PERMIT[13] & ~reg_be))) |
               (addr_hit[14] & (|(OTP_CTRL_CORE_PERMIT[14] & ~reg_be))) |
               (addr_hit[15] & (|(OTP_CTRL_CORE_PERMIT[15] & ~reg_be))) |
               (addr_hit[16] & (|(OTP_CTRL_CORE_PERMIT[16] & ~reg_be))) |
               (addr_hit[17] & (|(OTP_CTRL_CORE_PERMIT[17] & ~reg_be))) |
               (addr_hit[18] & (|(OTP_CTRL_CORE_PERMIT[18] & ~reg_be))) |
               (addr_hit[19] & (|(OTP_CTRL_CORE_PERMIT[19] & ~reg_be))) |
               (addr_hit[20] & (|(OTP_CTRL_CORE_PERMIT[20] & ~reg_be))) |
               (addr_hit[21] & (|(OTP_CTRL_CORE_PERMIT[21] & ~reg_be))) |
               (addr_hit[22] & (|(OTP_CTRL_CORE_PERMIT[22] & ~reg_be))) |
               (addr_hit[23] & (|(OTP_CTRL_CORE_PERMIT[23] & ~reg_be))) |
               (addr_hit[24] & (|(OTP_CTRL_CORE_PERMIT[24] & ~reg_be))) |
               (addr_hit[25] & (|(OTP_CTRL_CORE_PERMIT[25] & ~reg_be))) |
               (addr_hit[26] & (|(OTP_CTRL_CORE_PERMIT[26] & ~reg_be))) |
               (addr_hit[27] & (|(OTP_CTRL_CORE_PERMIT[27] & ~reg_be))) |
               (addr_hit[28] & (|(OTP_CTRL_CORE_PERMIT[28] & ~reg_be))) |
               (addr_hit[29] & (|(OTP_CTRL_CORE_PERMIT[29] & ~reg_be))) |
               (addr_hit[30] & (|(OTP_CTRL_CORE_PERMIT[30] & ~reg_be))) |
               (addr_hit[31] & (|(OTP_CTRL_CORE_PERMIT[31] & ~reg_be))) |
               (addr_hit[32] & (|(OTP_CTRL_CORE_PERMIT[32] & ~reg_be))) |
               (addr_hit[33] & (|(OTP_CTRL_CORE_PERMIT[33] & ~reg_be))) |
               (addr_hit[34] & (|(OTP_CTRL_CORE_PERMIT[34] & ~reg_be))) |
               (addr_hit[35] & (|(OTP_CTRL_CORE_PERMIT[35] & ~reg_be))) |
               (addr_hit[36] & (|(OTP_CTRL_CORE_PERMIT[36] & ~reg_be))) |
               (addr_hit[37] & (|(OTP_CTRL_CORE_PERMIT[37] & ~reg_be))) |
               (addr_hit[38] & (|(OTP_CTRL_CORE_PERMIT[38] & ~reg_be))) |
               (addr_hit[39] & (|(OTP_CTRL_CORE_PERMIT[39] & ~reg_be))) |
               (addr_hit[40] & (|(OTP_CTRL_CORE_PERMIT[40] & ~reg_be))) |
               (addr_hit[41] & (|(OTP_CTRL_CORE_PERMIT[41] & ~reg_be))) |
               (addr_hit[42] & (|(OTP_CTRL_CORE_PERMIT[42] & ~reg_be))) |
               (addr_hit[43] & (|(OTP_CTRL_CORE_PERMIT[43] & ~reg_be))) |
               (addr_hit[44] & (|(OTP_CTRL_CORE_PERMIT[44] & ~reg_be))) |
               (addr_hit[45] & (|(OTP_CTRL_CORE_PERMIT[45] & ~reg_be))) |
               (addr_hit[46] & (|(OTP_CTRL_CORE_PERMIT[46] & ~reg_be))) |
               (addr_hit[47] & (|(OTP_CTRL_CORE_PERMIT[47] & ~reg_be))) |
               (addr_hit[48] & (|(OTP_CTRL_CORE_PERMIT[48] & ~reg_be))) |
               (addr_hit[49] & (|(OTP_CTRL_CORE_PERMIT[49] & ~reg_be))) |
               (addr_hit[50] & (|(OTP_CTRL_CORE_PERMIT[50] & ~reg_be))) |
               (addr_hit[51] & (|(OTP_CTRL_CORE_PERMIT[51] & ~reg_be))) |
               (addr_hit[52] & (|(OTP_CTRL_CORE_PERMIT[52] & ~reg_be))) |
               (addr_hit[53] & (|(OTP_CTRL_CORE_PERMIT[53] & ~reg_be))) |
               (addr_hit[54] & (|(OTP_CTRL_CORE_PERMIT[54] & ~reg_be))) |
               (addr_hit[55] & (|(OTP_CTRL_CORE_PERMIT[55] & ~reg_be)))));
  end

  // Generate write-enables
  assign intr_state_we = addr_hit[0] & reg_we & !reg_error;

  assign intr_state_otp_operation_done_wd = reg_wdata[0];

  assign intr_state_otp_error_wd = reg_wdata[1];
  assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;

  assign intr_enable_otp_operation_done_wd = reg_wdata[0];

  assign intr_enable_otp_error_wd = reg_wdata[1];
  assign intr_test_we = addr_hit[2] & reg_we & !reg_error;

  assign intr_test_otp_operation_done_wd = reg_wdata[0];

  assign intr_test_otp_error_wd = reg_wdata[1];
  assign alert_test_we = addr_hit[3] & reg_we & !reg_error;

  assign alert_test_fatal_macro_error_wd = reg_wdata[0];

  assign alert_test_fatal_check_error_wd = reg_wdata[1];

  assign alert_test_fatal_bus_integ_error_wd = reg_wdata[2];

  assign alert_test_fatal_prim_otp_alert_wd = reg_wdata[3];

  assign alert_test_recov_prim_otp_alert_wd = reg_wdata[4];
  assign status_re = addr_hit[4] & reg_re & !reg_error;
  assign err_code_0_re = addr_hit[5] & reg_re & !reg_error;
  assign err_code_1_re = addr_hit[6] & reg_re & !reg_error;
  assign err_code_2_re = addr_hit[7] & reg_re & !reg_error;
  assign err_code_3_re = addr_hit[8] & reg_re & !reg_error;
  assign err_code_4_re = addr_hit[9] & reg_re & !reg_error;
  assign err_code_5_re = addr_hit[10] & reg_re & !reg_error;
  assign err_code_6_re = addr_hit[11] & reg_re & !reg_error;
  assign err_code_7_re = addr_hit[12] & reg_re & !reg_error;
  assign err_code_8_re = addr_hit[13] & reg_re & !reg_error;
  assign err_code_9_re = addr_hit[14] & reg_re & !reg_error;
  assign err_code_10_re = addr_hit[15] & reg_re & !reg_error;
  assign err_code_11_re = addr_hit[16] & reg_re & !reg_error;
  assign err_code_12_re = addr_hit[17] & reg_re & !reg_error;
  assign direct_access_regwen_re = addr_hit[18] & reg_re & !reg_error;
  assign direct_access_regwen_we = addr_hit[18] & reg_we & !reg_error;

  assign direct_access_regwen_wd = reg_wdata[0];
  assign direct_access_cmd_we = addr_hit[19] & reg_we & !reg_error;

  assign direct_access_cmd_rd_wd = reg_wdata[0];

  assign direct_access_cmd_wr_wd = reg_wdata[1];

  assign direct_access_cmd_digest_wd = reg_wdata[2];
  assign direct_access_address_we = addr_hit[20] & reg_we & !reg_error;

  assign direct_access_address_wd = reg_wdata[10:0];
  assign direct_access_wdata_0_we = addr_hit[21] & reg_we & !reg_error;

  assign direct_access_wdata_0_wd = reg_wdata[31:0];
  assign direct_access_wdata_1_we = addr_hit[22] & reg_we & !reg_error;

  assign direct_access_wdata_1_wd = reg_wdata[31:0];
  assign direct_access_rdata_0_re = addr_hit[23] & reg_re & !reg_error;
  assign direct_access_rdata_1_re = addr_hit[24] & reg_re & !reg_error;
  assign check_trigger_regwen_we = addr_hit[25] & reg_we & !reg_error;

  assign check_trigger_regwen_wd = reg_wdata[0];
  assign check_trigger_we = addr_hit[26] & reg_we & !reg_error;

  assign check_trigger_integrity_wd = reg_wdata[0];

  assign check_trigger_consistency_wd = reg_wdata[1];
  assign check_regwen_we = addr_hit[27] & reg_we & !reg_error;

  assign check_regwen_wd = reg_wdata[0];
  assign check_timeout_we = addr_hit[28] & reg_we & !reg_error;

  assign check_timeout_wd = reg_wdata[31:0];
  assign integrity_check_period_we = addr_hit[29] & reg_we & !reg_error;

  assign integrity_check_period_wd = reg_wdata[31:0];
  assign consistency_check_period_we = addr_hit[30] & reg_we & !reg_error;

  assign consistency_check_period_wd = reg_wdata[31:0];
  assign vendor_test_read_lock_we = addr_hit[31] & reg_we & !reg_error;

  assign vendor_test_read_lock_wd = reg_wdata[0];
  assign creator_sw_cfg_read_lock_we = addr_hit[32] & reg_we & !reg_error;

  assign creator_sw_cfg_read_lock_wd = reg_wdata[0];
  assign owner_sw_cfg_read_lock_we = addr_hit[33] & reg_we & !reg_error;

  assign owner_sw_cfg_read_lock_wd = reg_wdata[0];
  assign rot_creator_auth_codesign_read_lock_we = addr_hit[34] & reg_we & !reg_error;

  assign rot_creator_auth_codesign_read_lock_wd = reg_wdata[0];
  assign rot_creator_auth_state_read_lock_we = addr_hit[35] & reg_we & !reg_error;

  assign rot_creator_auth_state_read_lock_wd = reg_wdata[0];
  assign vendor_test_digest_0_re = addr_hit[36] & reg_re & !reg_error;
  assign vendor_test_digest_1_re = addr_hit[37] & reg_re & !reg_error;
  assign creator_sw_cfg_digest_0_re = addr_hit[38] & reg_re & !reg_error;
  assign creator_sw_cfg_digest_1_re = addr_hit[39] & reg_re & !reg_error;
  assign owner_sw_cfg_digest_0_re = addr_hit[40] & reg_re & !reg_error;
  assign owner_sw_cfg_digest_1_re = addr_hit[41] & reg_re & !reg_error;
  assign rot_creator_auth_codesign_digest_0_re = addr_hit[42] & reg_re & !reg_error;
  assign rot_creator_auth_codesign_digest_1_re = addr_hit[43] & reg_re & !reg_error;
  assign rot_creator_auth_state_digest_0_re = addr_hit[44] & reg_re & !reg_error;
  assign rot_creator_auth_state_digest_1_re = addr_hit[45] & reg_re & !reg_error;
  assign hw_cfg0_digest_0_re = addr_hit[46] & reg_re & !reg_error;
  assign hw_cfg0_digest_1_re = addr_hit[47] & reg_re & !reg_error;
  assign hw_cfg1_digest_0_re = addr_hit[48] & reg_re & !reg_error;
  assign hw_cfg1_digest_1_re = addr_hit[49] & reg_re & !reg_error;
  assign secret0_digest_0_re = addr_hit[50] & reg_re & !reg_error;
  assign secret0_digest_1_re = addr_hit[51] & reg_re & !reg_error;
  assign secret1_digest_0_re = addr_hit[52] & reg_re & !reg_error;
  assign secret1_digest_1_re = addr_hit[53] & reg_re & !reg_error;
  assign secret2_digest_0_re = addr_hit[54] & reg_re & !reg_error;
  assign secret2_digest_1_re = addr_hit[55] & reg_re & !reg_error;

  // Assign write-enables to checker logic vector.
  always_comb begin
    reg_we_check = '0;
    reg_we_check[0] = intr_state_we;
    reg_we_check[1] = intr_enable_we;
    reg_we_check[2] = intr_test_we;
    reg_we_check[3] = alert_test_we;
    reg_we_check[4] = 1'b0;
    reg_we_check[5] = 1'b0;
    reg_we_check[6] = 1'b0;
    reg_we_check[7] = 1'b0;
    reg_we_check[8] = 1'b0;
    reg_we_check[9] = 1'b0;
    reg_we_check[10] = 1'b0;
    reg_we_check[11] = 1'b0;
    reg_we_check[12] = 1'b0;
    reg_we_check[13] = 1'b0;
    reg_we_check[14] = 1'b0;
    reg_we_check[15] = 1'b0;
    reg_we_check[16] = 1'b0;
    reg_we_check[17] = 1'b0;
    reg_we_check[18] = direct_access_regwen_we;
    reg_we_check[19] = direct_access_cmd_gated_we;
    reg_we_check[20] = direct_access_address_gated_we;
    reg_we_check[21] = direct_access_wdata_0_gated_we;
    reg_we_check[22] = direct_access_wdata_1_gated_we;
    reg_we_check[23] = 1'b0;
    reg_we_check[24] = 1'b0;
    reg_we_check[25] = check_trigger_regwen_we;
    reg_we_check[26] = check_trigger_gated_we;
    reg_we_check[27] = check_regwen_we;
    reg_we_check[28] = check_timeout_gated_we;
    reg_we_check[29] = integrity_check_period_gated_we;
    reg_we_check[30] = consistency_check_period_gated_we;
    reg_we_check[31] = vendor_test_read_lock_gated_we;
    reg_we_check[32] = creator_sw_cfg_read_lock_gated_we;
    reg_we_check[33] = owner_sw_cfg_read_lock_gated_we;
    reg_we_check[34] = rot_creator_auth_codesign_read_lock_gated_we;
    reg_we_check[35] = rot_creator_auth_state_read_lock_gated_we;
    reg_we_check[36] = 1'b0;
    reg_we_check[37] = 1'b0;
    reg_we_check[38] = 1'b0;
    reg_we_check[39] = 1'b0;
    reg_we_check[40] = 1'b0;
    reg_we_check[41] = 1'b0;
    reg_we_check[42] = 1'b0;
    reg_we_check[43] = 1'b0;
    reg_we_check[44] = 1'b0;
    reg_we_check[45] = 1'b0;
    reg_we_check[46] = 1'b0;
    reg_we_check[47] = 1'b0;
    reg_we_check[48] = 1'b0;
    reg_we_check[49] = 1'b0;
    reg_we_check[50] = 1'b0;
    reg_we_check[51] = 1'b0;
    reg_we_check[52] = 1'b0;
    reg_we_check[53] = 1'b0;
    reg_we_check[54] = 1'b0;
    reg_we_check[55] = 1'b0;
  end

  // Read data return
  always_comb begin
    reg_rdata_next = '0;
    unique case (1'b1)
      addr_hit[0]: begin
        reg_rdata_next[0] = intr_state_otp_operation_done_qs;
        reg_rdata_next[1] = intr_state_otp_error_qs;
      end

      addr_hit[1]: begin
        reg_rdata_next[0] = intr_enable_otp_operation_done_qs;
        reg_rdata_next[1] = intr_enable_otp_error_qs;
      end

      addr_hit[2]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
      end

      addr_hit[3]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
        reg_rdata_next[2] = '0;
        reg_rdata_next[3] = '0;
        reg_rdata_next[4] = '0;
      end

      addr_hit[4]: begin
        reg_rdata_next[0] = status_vendor_test_error_qs;
        reg_rdata_next[1] = status_creator_sw_cfg_error_qs;
        reg_rdata_next[2] = status_owner_sw_cfg_error_qs;
        reg_rdata_next[3] = status_rot_creator_auth_codesign_error_qs;
        reg_rdata_next[4] = status_rot_creator_auth_state_error_qs;
        reg_rdata_next[5] = status_hw_cfg0_error_qs;
        reg_rdata_next[6] = status_hw_cfg1_error_qs;
        reg_rdata_next[7] = status_secret0_error_qs;
        reg_rdata_next[8] = status_secret1_error_qs;
        reg_rdata_next[9] = status_secret2_error_qs;
        reg_rdata_next[10] = status_life_cycle_error_qs;
        reg_rdata_next[11] = status_dai_error_qs;
        reg_rdata_next[12] = status_lci_error_qs;
        reg_rdata_next[13] = status_timeout_error_qs;
        reg_rdata_next[14] = status_lfsr_fsm_error_qs;
        reg_rdata_next[15] = status_scrambling_fsm_error_qs;
        reg_rdata_next[16] = status_key_deriv_fsm_error_qs;
        reg_rdata_next[17] = status_bus_integ_error_qs;
        reg_rdata_next[18] = status_dai_idle_qs;
        reg_rdata_next[19] = status_check_pending_qs;
      end

      addr_hit[5]: begin
        reg_rdata_next[2:0] = err_code_0_qs;
      end

      addr_hit[6]: begin
        reg_rdata_next[2:0] = err_code_1_qs;
      end

      addr_hit[7]: begin
        reg_rdata_next[2:0] = err_code_2_qs;
      end

      addr_hit[8]: begin
        reg_rdata_next[2:0] = err_code_3_qs;
      end

      addr_hit[9]: begin
        reg_rdata_next[2:0] = err_code_4_qs;
      end

      addr_hit[10]: begin
        reg_rdata_next[2:0] = err_code_5_qs;
      end

      addr_hit[11]: begin
        reg_rdata_next[2:0] = err_code_6_qs;
      end

      addr_hit[12]: begin
        reg_rdata_next[2:0] = err_code_7_qs;
      end

      addr_hit[13]: begin
        reg_rdata_next[2:0] = err_code_8_qs;
      end

      addr_hit[14]: begin
        reg_rdata_next[2:0] = err_code_9_qs;
      end

      addr_hit[15]: begin
        reg_rdata_next[2:0] = err_code_10_qs;
      end

      addr_hit[16]: begin
        reg_rdata_next[2:0] = err_code_11_qs;
      end

      addr_hit[17]: begin
        reg_rdata_next[2:0] = err_code_12_qs;
      end

      addr_hit[18]: begin
        reg_rdata_next[0] = direct_access_regwen_qs;
      end

      addr_hit[19]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
        reg_rdata_next[2] = '0;
      end

      addr_hit[20]: begin
        reg_rdata_next[10:0] = direct_access_address_qs;
      end

      addr_hit[21]: begin
        reg_rdata_next[31:0] = direct_access_wdata_0_qs;
      end

      addr_hit[22]: begin
        reg_rdata_next[31:0] = direct_access_wdata_1_qs;
      end

      addr_hit[23]: begin
        reg_rdata_next[31:0] = direct_access_rdata_0_qs;
      end

      addr_hit[24]: begin
        reg_rdata_next[31:0] = direct_access_rdata_1_qs;
      end

      addr_hit[25]: begin
        reg_rdata_next[0] = check_trigger_regwen_qs;
      end

      addr_hit[26]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
      end

      addr_hit[27]: begin
        reg_rdata_next[0] = check_regwen_qs;
      end

      addr_hit[28]: begin
        reg_rdata_next[31:0] = check_timeout_qs;
      end

      addr_hit[29]: begin
        reg_rdata_next[31:0] = integrity_check_period_qs;
      end

      addr_hit[30]: begin
        reg_rdata_next[31:0] = consistency_check_period_qs;
      end

      addr_hit[31]: begin
        reg_rdata_next[0] = vendor_test_read_lock_qs;
      end

      addr_hit[32]: begin
        reg_rdata_next[0] = creator_sw_cfg_read_lock_qs;
      end

      addr_hit[33]: begin
        reg_rdata_next[0] = owner_sw_cfg_read_lock_qs;
      end

      addr_hit[34]: begin
        reg_rdata_next[0] = rot_creator_auth_codesign_read_lock_qs;
      end

      addr_hit[35]: begin
        reg_rdata_next[0] = rot_creator_auth_state_read_lock_qs;
      end

      addr_hit[36]: begin
        reg_rdata_next[31:0] = vendor_test_digest_0_qs;
      end

      addr_hit[37]: begin
        reg_rdata_next[31:0] = vendor_test_digest_1_qs;
      end

      addr_hit[38]: begin
        reg_rdata_next[31:0] = creator_sw_cfg_digest_0_qs;
      end

      addr_hit[39]: begin
        reg_rdata_next[31:0] = creator_sw_cfg_digest_1_qs;
      end

      addr_hit[40]: begin
        reg_rdata_next[31:0] = owner_sw_cfg_digest_0_qs;
      end

      addr_hit[41]: begin
        reg_rdata_next[31:0] = owner_sw_cfg_digest_1_qs;
      end

      addr_hit[42]: begin
        reg_rdata_next[31:0] = rot_creator_auth_codesign_digest_0_qs;
      end

      addr_hit[43]: begin
        reg_rdata_next[31:0] = rot_creator_auth_codesign_digest_1_qs;
      end

      addr_hit[44]: begin
        reg_rdata_next[31:0] = rot_creator_auth_state_digest_0_qs;
      end

      addr_hit[45]: begin
        reg_rdata_next[31:0] = rot_creator_auth_state_digest_1_qs;
      end

      addr_hit[46]: begin
        reg_rdata_next[31:0] = hw_cfg0_digest_0_qs;
      end

      addr_hit[47]: begin
        reg_rdata_next[31:0] = hw_cfg0_digest_1_qs;
      end

      addr_hit[48]: begin
        reg_rdata_next[31:0] = hw_cfg1_digest_0_qs;
      end

      addr_hit[49]: begin
        reg_rdata_next[31:0] = hw_cfg1_digest_1_qs;
      end

      addr_hit[50]: begin
        reg_rdata_next[31:0] = secret0_digest_0_qs;
      end

      addr_hit[51]: begin
        reg_rdata_next[31:0] = secret0_digest_1_qs;
      end

      addr_hit[52]: begin
        reg_rdata_next[31:0] = secret1_digest_0_qs;
      end

      addr_hit[53]: begin
        reg_rdata_next[31:0] = secret1_digest_1_qs;
      end

      addr_hit[54]: begin
        reg_rdata_next[31:0] = secret2_digest_0_qs;
      end

      addr_hit[55]: begin
        reg_rdata_next[31:0] = secret2_digest_1_qs;
      end

      default: begin
        reg_rdata_next = '1;
      end
    endcase
  end

  // shadow busy
  logic shadow_busy;
  assign shadow_busy = 1'b0;

  // register busy
  assign reg_busy = shadow_busy;

  // Unused signal tieoff

  // wdata / byte enable are not always fully used
  // add a blanket unused statement to handle lint waivers
  logic unused_wdata;
  logic unused_be;
  assign unused_wdata = ^reg_wdata;
  assign unused_be = ^reg_be;

  // Assertions for Register Interface
  `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
  `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)

  `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)

  `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)

  // this is formulated as an assumption such that the FPV testbenches do disprove this
  // property by mistake
  //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)

endmodule

    '''

    Identify relevant lint tags for the RTL to be checked for.
    Then run the tests using the linting tool.
    From the output of the linting tool, determine if there are security issues in the RTL.
================================== Ai Message ==================================
Tool Calls:
  retrieve_relevant_lint_tags (call_LSd5PwFUA6MbNdHYsFD6ylAC)
 Call ID: call_LSd5PwFUA6MbNdHYsFD6ylAC
  Args:
    query: register interface security access control
================================= Tool Message =================================
Name: retrieve_relevant_lint_tags

RegInputOutput-ML: Register the module output and input ports

RegInput-ML: Module input port should be registered


Rule_41: Primary port of a block is tied to global signal 


W215: Reports inappropriate bit-selects of integer or time variables 


STARC05-2.1.9.5: Do not use user-defined attributes in the design 

W240: An input has been declared but is not read


RegisterInfo-ML: Generate a report which includes all registers in RTL design 


InterfaceNameConflicts-ML: Interface Signal Name conflicts with other signal name 


STARC05-1.4.3.1b: Clocks should not be gated 


W500: A connection to a clock port is not a simple name


CheckPortType-ML: Complex port types are not allowed in module interface


W110: Identifies a module instance port connection that has incompatible width as compared to the port definition 


STARC05-1.2.1.1a: Design should use only one edge of a clock 


W401: Clock signal is not an input to the design unit 


MODULE_PORTS: Information about number of ports in each module 

Rule_2: Detects open input terminals


STARC05-1.1.1.9c: Top-level port names should follow recommended naming convention 


AutomaticFuncTask-ML: Use automatic functions/tasks in modules and interfaces 

W188: Do not write to input ports

PortOrder_A: Ports not declared in recommended order
================================== Ai Message ==================================
Tool Calls:
  lint_checker_tool (call_oXVDpQgxKICIQYDoq1oH0ZeB)
 Call ID: call_oXVDpQgxKICIQYDoq1oH0ZeB
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_core_reg_top.sv
    top_module: otp_ctrl_core_reg_top
    lint_tags: ['RegInputOutput-ML', 'RegInput-ML', 'Rule_41', 'STARC05-2.1.9.5', 'W240', 'RegisterInfo-ML', 'InterfaceNameConflicts-ML', 'STARC05-1.4.3.1b', 'W500', 'CheckPortType-ML', 'W110', 'STARC05-1.2.1.1a', 'W401', 'Rule_2', 'STARC05-1.1.1.9c', 'AutomaticFuncTask-ML', 'W188', 'PortOrder_A']
================================= Tool Message =================================
Name: lint_checker_tool

Successfully executed:
```lint checker tool
```
Output: 
  -----------------------------------------------------------------------------
  Report Summary
  -----------------------------------------------------------------------------
  Product Info
    Name    : VC Static Master Shell
    Version : U-2023.03-1 -- Apr 17, 2023

  Report Info
    Created : May 06, 2025  17:15:45

    TopLevelModule: otp_ctrl_core_reg_top

  -----------------------------------------------------------------------------
  Management Summary
  -----------------------------------------------------------------------------
  Stage             Family      Fatals    Errors  Warnings     Infos
  -----             --------  --------  --------  --------  --------
  LANGUAGE_CHECK    CODING           0        23         0         0
  STRUCTURAL_CHECK  CODING           0       255         0         0
  -----             --------  --------  --------  --------  --------
  Total                              0       278         0         0


  -----------------------------------------------------------------------------
  Tree Summary
  -----------------------------------------------------------------------------
  Severity  Stage             Tag                  Count
  --------  -----             -------------------  -----
  error     LANGUAGE_CHECK    CheckPortType-ML         6
  error     LANGUAGE_CHECK    W240                    17
  error     STRUCTURAL_CHECK  PortOrder_A             13
  error     STRUCTURAL_CHECK  RegInput-ML             58
  error     STRUCTURAL_CHECK  RegInputOutput-ML      183 *
  error     STRUCTURAL_CHECK  RegisterInfo-ML          1
  --------  -----             -------------------  -----
  Total                                              278

  * The following detailed reports have been limited to 100 per tag.


  -----------------------------------------------------------------------------
  CheckPortType-ML  (6 errors/0 waived)
  -----------------------------------------------------------------------------
  Tag            : CheckPortType-ML
  Description    : Port '[Mod_Port_Name]' of type '[NodeType]' is not allowed in module '[Module_Name]' port declaration
  Violation      : Lint:256
  Module         : otp_ctrl_core_reg_top
  FileName       : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber     : 12
  Statement      :   input  tlul_pkg::tl_h2d_t tl_i,
  Mod_Port_Name  : tl_i
  NodeType       : Struct
  Module_Name    : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag            : CheckPortType-ML
  Description    : Port '[Mod_Port_Name]' of type '[NodeType]' is not allowed in module '[Module_Name]' port declaration
  Violation      : Lint:261
  Module         : otp_ctrl_core_reg_top
  FileName       : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber     : 21
  Statement      :   input  otp_ctrl_reg_pkg::otp_ctrl_core_hw2reg_t hw2reg, // Read
  Mod_Port_Name  : hw2reg
  NodeType       : Struct
  Module_Name    : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag            : CheckPortType-ML
  Description    : Port '[Mod_Port_Name]' of type '[NodeType]' is not allowed in module '[Module_Name]' port declaration
  Violation      : Lint:260
  Module         : otp_ctrl_core_reg_top
  FileName       : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber     : 20
  Statement      :   output otp_ctrl_reg_pkg::otp_ctrl_core_reg2hw_t reg2hw, // Write
  Mod_Port_Name  : reg2hw
  NodeType       : Struct
  Module_Name    : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag            : CheckPortType-ML
  Description    : Port '[Mod_Port_Name]' of type '[NodeType]' is not allowed in module '[Module_Name]' port declaration
  Violation      : Lint:257
  Module         : otp_ctrl_core_reg_top
  FileName       : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber     : 13
  Statement      :   output tlul_pkg::tl_d2h_t tl_o,
  Mod_Port_Name  : tl_o
  NodeType       : Struct
  Module_Name    : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag            : CheckPortType-ML
  Description    : Port '[Mod_Port_Name]' of type '[NodeType]' is not allowed in module '[Module_Name]' port declaration
  Violation      : Lint:258
  Module         : otp_ctrl_core_reg_top
  FileName       : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber     : 16
  Statement      :   output tlul_pkg::tl_h2d_t tl_win_o,
  Mod_Port_Name  : tl_win_o
  NodeType       : Struct
  Module_Name    : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag            : CheckPortType-ML
  Description    : Port '[Mod_Port_Name]' of type '[NodeType]' is not allowed in module '[Module_Name]' port declaration
  Violation      : Lint:259
  Module         : otp_ctrl_core_reg_top
  FileName       : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber     : 17
  Statement      :   input  tlul_pkg::tl_d2h_t tl_win_i,
  Mod_Port_Name  : tl_win_i
  NodeType       : Struct
  Module_Name    : otp_ctrl_core_reg_top

  -----------------------------------------------------------------------------
  PortOrder_A  (13 errors/0 waived)
  -----------------------------------------------------------------------------
  Tag           : PortOrder_A
  Description   : Port '[ModPortName]' not defined in recommended order
  Violation     : Lint:2
  Module        : tlul_adapter_reg
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_adapter_reg_0.1/rtl/tlul_adapter_reg.sv
  LineNumber    : 53
  Statement     :   input                    error_i
  ModPortName   : error_i
  -----------------------------------------------------------------------------
  Tag           : PortOrder_A
  Description   : Port '[ModPortName]' not defined in recommended order
  Violation     : Lint:9
  Module        : otp_ctrl_core_reg_top
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber    : 17
  Statement     :   input  tlul_pkg::tl_d2h_t tl_win_i,
  ModPortName   : tl_win_i[65:0]
  -----------------------------------------------------------------------------
  Tag           : PortOrder_A
  Description   : Port '[ModPortName]' not defined in recommended order
  Violation     : Lint:11
  Module        : prim_fifo_sync
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_fifo_0/rtl/prim_fifo_sync.sv
  LineNumber    : 25
  Statement     :   input   [Width-1:0]     wdata_i,
  ModPortName   : wdata_i[107:0]
  -----------------------------------------------------------------------------
  Tag           : PortOrder_A
  Description   : Port '[ModPortName]' not defined in recommended order
  Violation     : Lint:12
  Module        : otp_ctrl_core_reg_top
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber    : 21
  Statement     :   input  otp_ctrl_reg_pkg::otp_ctrl_core_hw2reg_t hw2reg, // Read
  ModPortName   : hw2reg[767:0]
  -----------------------------------------------------------------------------
  Tag           : PortOrder_A
  Description   : Port '[ModPortName]' not defined in recommended order
  Violation     : Lint:4
  Module        : tlul_adapter_reg
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_adapter_reg_0.1/rtl/tlul_adapter_reg.sv
  LineNumber    : 51
  Statement     :   input        [RegDw-1:0] rdata_i,
  ModPortName   : rdata_i[31:0]
  -----------------------------------------------------------------------------
  Tag           : PortOrder_A
  Description   : Port '[ModPortName]' not defined in recommended order
  Violation     : Lint:7
  Module        : tlul_socket_1n
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber    : 67
  Statement     :   input  [NWD-1:0]          dev_select_i
  ModPortName   : dev_select_i[0]
  -----------------------------------------------------------------------------
  Tag           : PortOrder_A
  Description   : Port '[ModPortName]' not defined in recommended order
  Violation     : Lint:1
  Module        : tlul_adapter_reg
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_adapter_reg_0.1/rtl/tlul_adapter_reg.sv
  LineNumber    : 48
  Statement     :   input                    busy_i,
  ModPortName   : busy_i
  -----------------------------------------------------------------------------
  Tag           : PortOrder_A
  Description   : Port '[ModPortName]' not defined in recommended order
  Violation     : Lint:10
  Module        : tlul_fifo_sync
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_fifo_sync.sv
  LineNumber    : 25
  Statement     :   input  [SpareRspW-1:0]    spare_rsp_i,
  ModPortName   : spare_rsp_i[0]
  -----------------------------------------------------------------------------
  Tag           : PortOrder_A
  Description   : Port '[ModPortName]' not defined in recommended order
  Violation     : Lint:8
  Module        : tlul_fifo_sync
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_fifo_sync.sv
  LineNumber    : 22
  Statement     :   input  tlul_pkg::tl_d2h_t tl_d_i,
  ModPortName   : tl_d_i[65:0]
  -----------------------------------------------------------------------------
  Tag           : PortOrder_A
  Description   : Port '[ModPortName]' not defined in recommended order
  Violation     : Lint:3
  Module        : prim_fifo_sync
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_fifo_0/rtl/prim_fifo_sync.sv
  LineNumber    : 28
  Statement     :   input                   rready_i,
  ModPortName   : rready_i
  -----------------------------------------------------------------------------
  Tag           : PortOrder_A
  Description   : Port '[ModPortName]' not defined in recommended order
  Violation     : Lint:13
  Module        : tlul_adapter_reg
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_adapter_reg_0.1/rtl/tlul_adapter_reg.sv
  LineNumber    : 39
  Statement     :   input  mubi4_t  en_ifetch_i,
  ModPortName   : en_ifetch_i[3:0]
  -----------------------------------------------------------------------------
  Tag           : PortOrder_A
  Description   : Port '[ModPortName]' not defined in recommended order
  Violation     : Lint:5
  Module        : tlul_fifo_sync
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_fifo_sync.sv
  LineNumber    : 23
  Statement     :   input  [SpareReqW-1:0]    spare_req_i,
  ModPortName   : spare_req_i[0]
  -----------------------------------------------------------------------------
  Tag           : PortOrder_A
  Description   : Port '[ModPortName]' not defined in recommended order
  Violation     : Lint:6
  Module        : tlul_socket_1n
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber    : 66
  Statement     :   input  tlul_pkg::tl_d2h_t tl_d_i    [N],
  ModPortName   : tl_d_i[65:0][1:0]

  -----------------------------------------------------------------------------
  RegInput-ML  (58 errors/0 waived)
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:20
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_reg_we_check_0/rtl/prim_reg_we_check.sv
  LineNumber   : 15
  Statement    :   input                          rst_ni,
  Signal       : rst_ni
  Module       : prim_reg_we_check
  MASTER       : prim_reg_we_check
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:53
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_adapter_reg_0.1/rtl/tlul_adapter_reg.sv
  LineNumber   : 53
  Statement    :   input                    error_i
  Signal       : error_i
  Module       : tlul_adapter_reg
  MASTER       : tlul_adapter_reg
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:44
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_fifo_0/rtl/prim_fifo_sync.sv
  LineNumber   : 19
  Statement    :   input                   rst_ni,
  Signal       : rst_ni
  Module       : prim_fifo_sync
  MASTER       : prim_fifo_sync
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:27
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_onehot_check_0/rtl/prim_onehot_check.sv
  LineNumber   : 40
  Statement    :   input  logic [OneHotWidth-1:0] oh_i,
  Signal       : oh_i
  Module       : prim_onehot_check
  MASTER       : prim_onehot_check
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:69
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg_ext.sv
  LineNumber   : 14
  Statement    :   input [DW-1:0] d,
  Signal       : d
  Module       : prim_subreg_ext
  MASTER       : prim_subreg_ext
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:31
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_secded_0.1/rtl/prim_secded_inv_64_57_enc.sv
  LineNumber   : 8
  Statement    :   input        [56:0] data_i,
  Signal       : data_i
  Module       : prim_secded_inv_64_57_enc
  MASTER       : prim_secded_inv_64_57_enc
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:55
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_err.sv
  LineNumber   : 10
  Statement    :   input rst_ni,
  Signal       : rst_ni
  Module       : tlul_err
  MASTER       : tlul_err
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:64
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg_arb.sv
  LineNumber   : 21
  Statement    :   input [DW-1:0] d,
  Signal       : d
  Module       : prim_subreg_arb
  MASTER       : prim_subreg_arb
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:24
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_generic_buf_0/rtl/prim_generic_buf.sv
  LineNumber   : 10
  Statement    :   input        [Width-1:0] in_i,
  Signal       : in_i
  Module       : prim_generic_buf
  MASTER       : prim_generic_buf
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:15
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_trans_intg_0.1/rtl/tlul_cmd_intg_chk.sv
  LineNumber   : 13
  Statement    :   input  tl_h2d_t tl_i,
  Signal       : tl_i
  Module       : tlul_cmd_intg_chk
  MASTER       : tlul_cmd_intg_chk
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:54
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_err.sv
  LineNumber   : 9
  Statement    :   input clk_i,
  Signal       : clk_i
  Module       : tlul_err
  MASTER       : tlul_err
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:48
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_fifo_0/rtl/prim_fifo_sync.sv
  LineNumber   : 28
  Statement    :   input                   rready_i,
  Signal       : rready_i
  Module       : prim_fifo_sync
  MASTER       : prim_fifo_sync
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:47
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_fifo_0/rtl/prim_fifo_sync.sv
  LineNumber   : 25
  Statement    :   input   [Width-1:0]     wdata_i,
  Signal       : wdata_i
  Module       : prim_fifo_sync
  MASTER       : prim_fifo_sync
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:65
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg_arb.sv
  LineNumber   : 24
  Statement    :   input [DW-1:0] q,
  Signal       : q
  Module       : prim_subreg_arb
  MASTER       : prim_subreg_arb
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:40
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_fifo_sync.sv
  LineNumber   : 22
  Statement    :   input  tlul_pkg::tl_d2h_t tl_d_i,
  Signal       : tl_d_i
  Module       : tlul_fifo_sync
  MASTER       : tlul_fifo_sync
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:66
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg_ext.sv
  LineNumber   : 10
  Statement    :   input          re,
  Signal       : re
  Module       : prim_subreg_ext
  MASTER       : prim_subreg_ext
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:22
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_reg_we_check_0/rtl/prim_reg_we_check.sv
  LineNumber   : 18
  Statement    :   input  logic                   en_i,
  Signal       : en_i
  Module       : prim_reg_we_check
  MASTER       : prim_reg_we_check
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:52
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_adapter_reg_0.1/rtl/tlul_adapter_reg.sv
  LineNumber   : 51
  Statement    :   input        [RegDw-1:0] rdata_i,
  Signal       : rdata_i
  Module       : tlul_adapter_reg
  MASTER       : tlul_adapter_reg
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:56
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_err.sv
  LineNumber   : 12
  Statement    :   input tl_h2d_t tl_i,
  Signal       : tl_i
  Module       : tlul_err
  MASTER       : tlul_err
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:72
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber   : 12
  Statement    :   input  tlul_pkg::tl_h2d_t tl_i,
  Signal       : tl_i[108:0]
  Module       : otp_ctrl_core_reg_top
  MASTER       : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:61
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg_arb.sv
  LineNumber   : 16
  Statement    :   input          we,
  Signal       : we
  Module       : prim_subreg_arb
  MASTER       : prim_subreg_arb
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:37
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_fifo_sync.sv
  LineNumber   : 17
  Statement    :   input                     clk_i,
  Signal       : clk_i
  Module       : tlul_fifo_sync
  MASTER       : tlul_fifo_sync
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:28
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_onehot_check_0/rtl/prim_onehot_check.sv
  LineNumber   : 41
  Statement    :   input  logic [AddrWidth-1:0]   addr_i,
  Signal       : addr_i
  Module       : prim_onehot_check
  MASTER       : prim_onehot_check
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:49
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_adapter_reg_0.1/rtl/tlul_adapter_reg.sv
  LineNumber   : 35
  Statement    :   input  tl_h2d_t tl_i,
  Signal       : tl_i
  Module       : tlul_adapter_reg
  MASTER       : tlul_adapter_reg
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:59
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg.sv
  LineNumber   : 24
  Statement    :   input          de,
  Signal       : de
  Module       : prim_subreg
  MASTER       : prim_subreg
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:71
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber   : 21
  Statement    :   input  otp_ctrl_reg_pkg::otp_ctrl_core_hw2reg_t hw2reg, // Read
  Signal       : hw2reg[767:0]
  Module       : otp_ctrl_core_reg_top
  MASTER       : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:26
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_onehot_check_0/rtl/prim_onehot_check.sv
  LineNumber   : 38
  Statement    :   input                          rst_ni,
  Signal       : rst_ni
  Module       : prim_onehot_check
  MASTER       : prim_onehot_check
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:50
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_adapter_reg_0.1/rtl/tlul_adapter_reg.sv
  LineNumber   : 39
  Statement    :   input  mubi4_t  en_ifetch_i,
  Signal       : en_ifetch_i
  Module       : tlul_adapter_reg
  MASTER       : tlul_adapter_reg
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:36
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber   : 67
  Statement    :   input  [NWD-1:0]          dev_select_i
  Signal       : dev_select_i
  Module       : tlul_socket_1n
  MASTER       : tlul_socket_1n
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:23
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_abstract_buf_0/prim_buf.sv
  LineNumber   : 24
  Statement    :   input        [Width-1:0] in_i,
  Signal       : in_i
  Module       : prim_buf
  MASTER       : prim_buf
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:68
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg_ext.sv
  LineNumber   : 12
  Statement    :   input [DW-1:0] wd,
  Signal       : wd
  Module       : prim_subreg_ext
  MASTER       : prim_subreg_ext
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:62
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg_arb.sv
  LineNumber   : 17
  Statement    :   input [DW-1:0] wd,
  Signal       : wd
  Module       : prim_subreg_arb
  MASTER       : prim_subreg_arb
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:21
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_reg_we_check_0/rtl/prim_reg_we_check.sv
  LineNumber   : 17
  Statement    :   input  logic [OneHotWidth-1:0] oh_i,
  Signal       : oh_i
  Module       : prim_reg_we_check
  MASTER       : prim_reg_we_check
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:33
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_secded_0.1/rtl/prim_secded_inv_39_32_enc.sv
  LineNumber   : 8
  Statement    :   input        [31:0] data_i,
  Signal       : data_i
  Module       : prim_secded_inv_39_32_enc
  MASTER       : prim_secded_inv_39_32_enc
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:25
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_onehot_check_0/rtl/prim_onehot_check.sv
  LineNumber   : 37
  Statement    :   input                          clk_i,
  Signal       : clk_i
  Module       : prim_onehot_check
  MASTER       : prim_onehot_check
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:17
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_trans_intg_0.1/rtl/tlul_data_integ_dec.sv
  LineNumber   : 13
  Statement    :   input        [DataMaxWidth+DataIntgWidth-1:0] data_intg_i,
  Signal       : data_intg_i
  Module       : tlul_data_integ_dec
  MASTER       : tlul_data_integ_dec
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:46
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_fifo_0/rtl/prim_fifo_sync.sv
  LineNumber   : 23
  Statement    :   input                   wvalid_i,
  Signal       : wvalid_i
  Module       : prim_fifo_sync
  MASTER       : prim_fifo_sync
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:42
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_fifo_sync.sv
  LineNumber   : 25
  Statement    :   input  [SpareRspW-1:0]    spare_rsp_i,
  Signal       : spare_rsp_i
  Module       : tlul_fifo_sync
  MASTER       : tlul_fifo_sync
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:18
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_secded_0.1/rtl/prim_secded_inv_39_32_dec.sv
  LineNumber   : 8
  Statement    :   input        [38:0] data_i,
  Signal       : data_i
  Module       : prim_secded_inv_39_32_dec
  MASTER       : prim_secded_inv_39_32_dec
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:34
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber   : 63
  Statement    :   input  tlul_pkg::tl_h2d_t tl_h_i,
  Signal       : tl_h_i
  Module       : tlul_socket_1n
  MASTER       : tlul_socket_1n
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:51
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_adapter_reg_0.1/rtl/tlul_adapter_reg.sv
  LineNumber   : 48
  Statement    :   input                    busy_i,
  Signal       : busy_i
  Module       : tlul_adapter_reg
  MASTER       : tlul_adapter_reg
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:43
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_fifo_0/rtl/prim_fifo_sync.sv
  LineNumber   : 18
  Statement    :   input                   clk_i,
  Signal       : clk_i
  Module       : prim_fifo_sync
  MASTER       : prim_fifo_sync
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:29
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_onehot_check_0/rtl/prim_onehot_check.sv
  LineNumber   : 42
  Statement    :   input  logic                   en_i,
  Signal       : en_i
  Module       : prim_onehot_check
  MASTER       : prim_onehot_check
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:58
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg.sv
  LineNumber   : 21
  Statement    :   input [DW-1:0] wd,
  Signal       : wd
  Module       : prim_subreg
  MASTER       : prim_subreg
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:70
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber   : 17
  Statement    :   input  tlul_pkg::tl_d2h_t tl_win_i,
  Signal       : tl_win_i[65:0]
  Module       : otp_ctrl_core_reg_top
  MASTER       : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:57
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg.sv
  LineNumber   : 20
  Statement    :   input          we,
  Signal       : we
  Module       : prim_subreg
  MASTER       : prim_subreg
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:16
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_secded_0.1/rtl/prim_secded_inv_64_57_dec.sv
  LineNumber   : 8
  Statement    :   input        [63:0] data_i,
  Signal       : data_i
  Module       : prim_secded_inv_64_57_dec
  MASTER       : prim_secded_inv_64_57_dec
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:19
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_reg_we_check_0/rtl/prim_reg_we_check.sv
  LineNumber   : 14
  Statement    :   input                          clk_i,
  Signal       : clk_i
  Module       : prim_reg_we_check
  MASTER       : prim_reg_we_check
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:30
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_trans_intg_0.1/rtl/tlul_rsp_intg_gen.sv
  LineNumber   : 16
  Statement    :   input  tl_d2h_t tl_i,
  Signal       : tl_i
  Module       : tlul_rsp_intg_gen
  MASTER       : tlul_rsp_intg_gen
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:45
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_fifo_0/rtl/prim_fifo_sync.sv
  LineNumber   : 21
  Statement    :   input                   clr_i,
  Signal       : clr_i
  Module       : prim_fifo_sync
  MASTER       : prim_fifo_sync
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:63
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg_arb.sv
  LineNumber   : 20
  Statement    :   input          de,
  Signal       : de
  Module       : prim_subreg_arb
  MASTER       : prim_subreg_arb
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:60
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg.sv
  LineNumber   : 25
  Statement    :   input [DW-1:0] d,
  Signal       : d
  Module       : prim_subreg
  MASTER       : prim_subreg
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:41
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_fifo_sync.sv
  LineNumber   : 23
  Statement    :   input  [SpareReqW-1:0]    spare_req_i,
  Signal       : spare_req_i
  Module       : tlul_fifo_sync
  MASTER       : tlul_fifo_sync
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:32
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_trans_intg_0.1/rtl/tlul_data_integ_enc.sv
  LineNumber   : 13
  Statement    :   input        [DataMaxWidth-1:0]               data_i,
  Signal       : data_i
  Module       : tlul_data_integ_enc
  MASTER       : tlul_data_integ_enc
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:67
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg_ext.sv
  LineNumber   : 11
  Statement    :   input          we,
  Signal       : we
  Module       : prim_subreg_ext
  MASTER       : prim_subreg_ext
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:35
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber   : 66
  Statement    :   input  tlul_pkg::tl_d2h_t tl_d_i    [N],
  Signal       : tl_d_i
  Module       : tlul_socket_1n
  MASTER       : tlul_socket_1n
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:38
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_fifo_sync.sv
  LineNumber   : 18
  Statement    :   input                     rst_ni,
  Signal       : rst_ni
  Module       : tlul_fifo_sync
  MASTER       : tlul_fifo_sync
  -----------------------------------------------------------------------------
  Tag          : RegInput-ML
  Description  : Input port '[Signal]' is not registered [module:[MASTER]]
  Violation    : Lint:39
  FileName     : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_fifo_sync.sv
  LineNumber   : 19
  Statement    :   input  tlul_pkg::tl_h2d_t tl_h_i,
  Signal       : tl_h_i
  Module       : tlul_fifo_sync
  MASTER       : tlul_fifo_sync

  -----------------------------------------------------------------------------
  RegInputOutput-ML  (183 errors/0 waived)
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:153
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 132
  Statement           :   assign hold_all_requests =
  Signal              : spare_req_i
  Module              : tlul_fifo_sync
  DesignObjHierarchy  : u_socket/fifo_h
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:237
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_adapter_reg_0.1/rtl/tlul_adapter_reg.sv
  LineNumber          : 36
  Statement           :   output tl_d2h_t tl_o,
  Signal              : tl_o.d_sink[0]
  Module              : tlul_adapter_reg
  DesignObjHierarchy  : u_reg_if
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:243
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 65
  Statement           :   output tlul_pkg::tl_h2d_t tl_d_o    [N],
  Signal              : tl_d_o[0].a_source[7:0]
  Module              : tlul_socket_1n
  DesignObjHierarchy  : u_socket
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:143
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 66
  Statement           :   input  tlul_pkg::tl_d2h_t tl_d_i    [N],
  Signal              : tl_d_i[0].d_error
  Module              : tlul_socket_1n
  DesignObjHierarchy  : u_socket
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:160
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 112
  Statement           :   assign  accept_t_req = tl_t_o.a_valid & tl_t_i.a_ready;
  Signal              : wvalid_i
  Module              : prim_fifo_sync
  DesignObjHierarchy  : u_socket/fifo_h/reqfifo
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:205
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 65
  Statement           :   output tlul_pkg::tl_h2d_t tl_d_o    [N],
  Signal              : tl_d_o[1].a_address[31:0]
  Module              : tlul_socket_1n
  DesignObjHierarchy  : u_socket
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:121
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_onehot_check_0/rtl/prim_onehot_check.sv
  LineNumber          : 37
  Statement           :   input                          clk_i,
  Signal              : clk_i
  Module              : prim_onehot_check
  DesignObjHierarchy  : u_prim_reg_we_check/u_prim_onehot_check
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:110
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_secded_0.1/rtl/prim_secded_inv_39_32_dec.sv
  LineNumber          : 10
  Statement           :   output logic [6:0] syndrome_o,
  Signal              : syndrome_o
  Module              : prim_secded_inv_39_32_dec
  DesignObjHierarchy  : u_chk/u_tlul_data_integ_dec/u_data_chk
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:192
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg_arb.sv
  LineNumber          : 89
  Statement           :     assign wr_en   = we | de;
  Signal              : de
  Module              : prim_subreg_arb
  DesignObjHierarchy  : u_intr_state_otp_operation_done/wr_en_data_arb
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:241
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 66
  Statement           :   input  tlul_pkg::tl_d2h_t tl_d_i    [N],
  Signal              : tl_d_i[1].d_sink[0]
  Module              : tlul_socket_1n
  DesignObjHierarchy  : u_socket
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:115
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_onehot_check_0/rtl/prim_onehot_check.sv
  LineNumber          : 121
  Statement           :       assign enable_err = !en_i && or_tree[0];
  Signal              : en_i
  Module              : prim_reg_we_check
  DesignObjHierarchy  : u_prim_reg_we_check
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:161
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_fifo_0/rtl/prim_fifo_sync.sv
  LineNumber          : 24
  Statement           :   output                  wready_o,
  Signal              : wready_o
  Module              : prim_fifo_sync
  DesignObjHierarchy  : u_socket/fifo_h/reqfifo
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:227
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 66
  Statement           :   input  tlul_pkg::tl_d2h_t tl_d_i    [N],
  Signal              : tl_d_i[0].d_user.rsp_intg[6:0]
  Module              : tlul_socket_1n
  DesignObjHierarchy  : u_socket
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:195
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg.sv
  LineNumber          : 64
  Statement           :   assign ds = wr_en ? wr_data : qs;
  Signal              : wr_data
  Module              : prim_subreg_arb
  DesignObjHierarchy  : u_intr_state_otp_operation_done/wr_en_data_arb
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:109
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_secded_0.1/rtl/prim_secded_inv_39_32_dec.sv
  LineNumber          : 9
  Statement           :   output logic [31:0] data_o,
  Signal              : data_o
  Module              : prim_secded_inv_39_32_dec
  DesignObjHierarchy  : u_chk/u_tlul_data_integ_dec/u_data_chk
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:107
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_trans_intg_0.1/rtl/tlul_cmd_intg_chk.sv
  LineNumber          : 44
  Statement           :   assign err_o = tl_i.a_valid & (|err | (|data_err));
  Signal              : data_err_o
  Module              : tlul_data_integ_dec
  DesignObjHierarchy  : u_chk/u_tlul_data_integ_dec
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:89
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber          : 20
  Statement           :   output otp_ctrl_reg_pkg::otp_ctrl_core_reg2hw_t reg2hw, // Write
  Signal              : reg2hw.alert_test.fatal_bus_integ_error.qe
  Module              : otp_ctrl_core_reg_top
  DesignObjHierarchy  : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:90
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber          : 20
  Statement           :   output otp_ctrl_reg_pkg::otp_ctrl_core_reg2hw_t reg2hw, // Write
  Signal              : reg2hw.alert_test.fatal_bus_integ_error.q
  Module              : otp_ctrl_core_reg_top
  DesignObjHierarchy  : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:222
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 65
  Statement           :   output tlul_pkg::tl_h2d_t tl_d_o    [N],
  Signal              : tl_d_o[1].a_opcode[2:0]
  Module              : tlul_socket_1n
  DesignObjHierarchy  : u_socket
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:151
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_fifo_sync.sv
  LineNumber          : 21
  Statement           :   output tlul_pkg::tl_h2d_t tl_d_o,
  Signal              : tl_d_o.a_valid
  Module              : tlul_fifo_sync
  DesignObjHierarchy  : u_socket/fifo_h
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:127
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber          : 13
  Statement           :   output tlul_pkg::tl_d2h_t tl_o,
  Signal              : tl_i
  Module              : tlul_rsp_intg_gen
  DesignObjHierarchy  : u_rsp_intg_gen
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:245
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 66
  Statement           :   input  tlul_pkg::tl_d2h_t tl_d_i    [N],
  Signal              : tl_d_i[1].d_user.rsp_intg[6:0]
  Module              : tlul_socket_1n
  DesignObjHierarchy  : u_socket
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:234
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 65
  Statement           :   output tlul_pkg::tl_h2d_t tl_d_o    [N],
  Signal              : tl_d_o[1].a_user.instr_type[3:0]
  Module              : tlul_socket_1n
  DesignObjHierarchy  : u_socket
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:140
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 65
  Statement           :   output tlul_pkg::tl_h2d_t tl_d_o    [N],
  Signal              : tl_d_o[0].a_valid
  Module              : tlul_socket_1n
  DesignObjHierarchy  : u_socket
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:75
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber          : 20
  Statement           :   output otp_ctrl_reg_pkg::otp_ctrl_core_reg2hw_t reg2hw, // Write
  Signal              : reg2hw.check_trigger.consistency.qe
  Module              : otp_ctrl_core_reg_top
  DesignObjHierarchy  : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:175
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_adapter_reg_0.1/rtl/tlul_adapter_reg.sv
  LineNumber          : 46
  Statement           :   output logic [RegDw-1:0] wdata_o,
  Signal              : wdata_o
  Module              : tlul_adapter_reg
  DesignObjHierarchy  : u_reg_if
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:242
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 65
  Statement           :   output tlul_pkg::tl_h2d_t tl_d_o    [N],
  Signal              : tl_d_o[0].a_user.cmd_intg[6:0]
  Module              : tlul_socket_1n
  DesignObjHierarchy  : u_socket
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:111
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_trans_intg_0.1/rtl/tlul_data_integ_dec.sv
  LineNumber          : 25
  Statement           :   assign data_err_o = |data_err;
  Signal              : err_o
  Module              : prim_secded_inv_39_32_dec
  DesignObjHierarchy  : u_chk/u_tlul_data_integ_dec/u_data_chk
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:73
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber          : 20
  Statement           :   output otp_ctrl_reg_pkg::otp_ctrl_core_reg2hw_t reg2hw, // Write
  Signal              : reg2hw.check_trigger.integrity.qe
  Module              : otp_ctrl_core_reg_top
  DesignObjHierarchy  : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:142
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 66
  Statement           :   input  tlul_pkg::tl_d2h_t tl_d_i    [N],
  Signal              : tl_d_i[0].a_ready
  Module              : tlul_socket_1n
  DesignObjHierarchy  : u_socket
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:165
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_fifo_0/rtl/prim_fifo_sync.sv
  LineNumber          : 31
  Statement           :   output                  full_o,
  Signal              : full_o
  Module              : prim_fifo_sync
  DesignObjHierarchy  : u_socket/fifo_h/reqfifo
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:250
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_adapter_reg_0.1/rtl/tlul_adapter_reg.sv
  LineNumber          : 36
  Statement           :   output tl_d2h_t tl_o,
  Signal              : tl_o.d_user.rsp_intg[6:0]
  Module              : tlul_adapter_reg
  DesignObjHierarchy  : u_reg_if
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:226
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_adapter_reg_0.1/rtl/tlul_adapter_reg.sv
  LineNumber          : 36
  Statement           :   output tl_d2h_t tl_o,
  Signal              : tl_o.d_param[2:0]
  Module              : tlul_adapter_reg
  DesignObjHierarchy  : u_reg_if
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:254
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 65
  Statement           :   output tlul_pkg::tl_h2d_t tl_d_o    [N],
  Signal              : tl_d_o[1].a_user.data_intg[6:0]
  Module              : tlul_socket_1n
  DesignObjHierarchy  : u_socket
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:150
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_fifo_sync.sv
  LineNumber          : 21
  Statement           :   output tlul_pkg::tl_h2d_t tl_d_o,
  Signal              : tl_d_o.d_ready
  Module              : tlul_fifo_sync
  DesignObjHierarchy  : u_socket/fifo_h
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:154
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 99
  Statement           :     .spare_rsp_o ());
  Signal              : spare_rsp_i
  Module              : tlul_fifo_sync
  DesignObjHierarchy  : u_socket/fifo_h
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:85
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber          : 20
  Statement           :   output otp_ctrl_reg_pkg::otp_ctrl_core_reg2hw_t reg2hw, // Write
  Signal              : reg2hw.alert_test.fatal_macro_error.qe
  Module              : otp_ctrl_core_reg_top
  DesignObjHierarchy  : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:103
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_secded_0.1/rtl/prim_secded_inv_64_57_dec.sv
  LineNumber          : 9
  Statement           :   output logic [56:0] data_o,
  Signal              : data_o
  Module              : prim_secded_inv_64_57_dec
  DesignObjHierarchy  : u_chk/u_chk
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:124
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_onehot_check_0/rtl/prim_onehot_check.sv
  LineNumber          : 41
  Statement           :   input  logic [AddrWidth-1:0]   addr_i,
  Signal              : addr_i
  Module              : prim_onehot_check
  DesignObjHierarchy  : u_prim_reg_we_check/u_prim_onehot_check
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:95
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber          : 20
  Statement           :   output otp_ctrl_reg_pkg::otp_ctrl_core_reg2hw_t reg2hw, // Write
  Signal              : reg2hw.intr_test.otp_operation_done.qe
  Module              : otp_ctrl_core_reg_top
  DesignObjHierarchy  : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:162
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 132
  Statement           :   assign hold_all_requests =
  Signal              : wdata_i
  Module              : prim_fifo_sync
  DesignObjHierarchy  : u_socket/fifo_h/reqfifo
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:98
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber          : 20
  Statement           :   output otp_ctrl_reg_pkg::otp_ctrl_core_reg2hw_t reg2hw, // Write
  Signal              : reg2hw.intr_test.otp_error.q
  Module              : otp_ctrl_core_reg_top
  DesignObjHierarchy  : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:177
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_adapter_reg_0.1/rtl/tlul_adapter_reg.sv
  LineNumber          : 154
  Statement           :   assign tl_o_pre = '{
  Signal              : busy_i
  Module              : tlul_adapter_reg
  DesignObjHierarchy  : u_reg_if
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:158
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_fifo_0/rtl/prim_fifo_sync.sv
  LineNumber          : 19
  Statement           :   input                   rst_ni,
  Signal              : rst_ni
  Module              : prim_fifo_sync
  DesignObjHierarchy  : u_socket/fifo_h/reqfifo
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:207
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 65
  Statement           :   output tlul_pkg::tl_h2d_t tl_d_o    [N],
  Signal              : tl_d_o[0].a_user.rsvd[4:0]
  Module              : tlul_socket_1n
  DesignObjHierarchy  : u_socket
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:112
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_reg_we_check_0/rtl/prim_reg_we_check.sv
  LineNumber          : 14
  Statement           :   input                          clk_i,
  Signal              : clk_i
  Module              : prim_reg_we_check
  DesignObjHierarchy  : u_prim_reg_we_check
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:206
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber          : 13
  Statement           :   output tlul_pkg::tl_d2h_t tl_o,
  Signal              : tl_o[65:0]
  Module              : otp_ctrl_core_reg_top
  DesignObjHierarchy  : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:188
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg.sv
  LineNumber          : 28
  Statement           :   output logic          qe,
  Signal              : qe
  Module              : prim_subreg
  DesignObjHierarchy  : u_intr_state_otp_operation_done
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:217
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_trans_intg_0.1/rtl/tlul_cmd_intg_chk.sv
  LineNumber          : 49
  Statement           :   assign unused_tl = |tl_i;
  Signal              : tl_i[108:0]
  Module              : otp_ctrl_core_reg_top
  DesignObjHierarchy  : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:215
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_fifo_sync.sv
  LineNumber          : 21
  Statement           :   output tlul_pkg::tl_h2d_t tl_d_o,
  Signal              : tl_d_o.a_param[2:0]
  Module              : tlul_fifo_sync
  DesignObjHierarchy  : u_socket/fifo_h
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:116
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber          : 75
  Statement           :     end else if (intg_err || reg_we_err) begin
  Signal              : err_o
  Module              : prim_reg_we_check
  DesignObjHierarchy  : u_prim_reg_we_check
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:181
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_err.sv
  LineNumber          : 10
  Statement           :   input rst_ni,
  Signal              : rst_ni
  Module              : tlul_err
  DesignObjHierarchy  : u_reg_if/u_err
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:204
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg_ext.sv
  LineNumber          : 21
  Statement           :   output logic [DW-1:0] qs
  Signal              : qs
  Module              : prim_subreg_ext
  DesignObjHierarchy  : u_intr_test_otp_operation_done
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:239
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber          : 16
  Statement           :   output tlul_pkg::tl_h2d_t tl_win_o,
  Signal              : tl_win_o[108:0]
  Module              : otp_ctrl_core_reg_top
  DesignObjHierarchy  : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:169
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_adapter_reg_0.1/rtl/tlul_adapter_reg.sv
  LineNumber          : 36
  Statement           :   output tl_d2h_t tl_o,
  Signal              : tl_o.a_ready
  Module              : tlul_adapter_reg
  DesignObjHierarchy  : u_reg_if
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:183
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_adapter_reg_0.1/rtl/tlul_adapter_reg.sv
  LineNumber          : 208
  Statement           :   assign err_internal = addr_align_err | malformed_meta_err | tl_err | instr_error | intg_error;
  Signal              : err_o
  Module              : tlul_err
  DesignObjHierarchy  : u_reg_if/u_err
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:81
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber          : 20
  Statement           :   output otp_ctrl_reg_pkg::otp_ctrl_core_reg2hw_t reg2hw, // Write
  Signal              : reg2hw.direct_access_cmd.digest.qe
  Module              : otp_ctrl_core_reg_top
  DesignObjHierarchy  : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:233
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 65
  Statement           :   output tlul_pkg::tl_h2d_t tl_d_o    [N],
  Signal              : tl_d_o[1].a_user.rsvd[4:0]
  Module              : tlul_socket_1n
  DesignObjHierarchy  : u_socket
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:171
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_adapter_reg_0.1/rtl/tlul_adapter_reg.sv
  LineNumber          : 40
  Statement           :   output logic    intg_error_o,
  Signal              : intg_error_o
  Module              : tlul_adapter_reg
  DesignObjHierarchy  : u_reg_if
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:191
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg_arb.sv
  LineNumber          : 111
  Statement           :       assign wr_data = (de ? d : q) & (we ? ~wd : '1);
  Signal              : wd
  Module              : prim_subreg_arb
  DesignObjHierarchy  : u_intr_state_otp_operation_done/wr_en_data_arb
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:190
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg_arb.sv
  LineNumber          : 89
  Statement           :     assign wr_en   = we | de;
  Signal              : we
  Module              : prim_subreg_arb
  DesignObjHierarchy  : u_intr_state_otp_operation_done/wr_en_data_arb
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:108
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_secded_0.1/rtl/prim_secded_inv_39_32_dec.sv
  LineNumber          : 16
  Statement           :     syndrome_o[0] = ^((data_i ^ 39'h2A00000000) & 39'h012606BD25);
  Signal              : data_i
  Module              : prim_secded_inv_39_32_dec
  DesignObjHierarchy  : u_chk/u_tlul_data_integ_dec/u_data_chk
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:230
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 65
  Statement           :   output tlul_pkg::tl_h2d_t tl_d_o    [N],
  Signal              : tl_d_o[0].a_mask[3:0]
  Module              : tlul_socket_1n
  DesignObjHierarchy  : u_socket
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:213
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 66
  Statement           :   input  tlul_pkg::tl_d2h_t tl_d_i    [N],
  Signal              : tl_d_i[0].d_size[1:0]
  Module              : tlul_socket_1n
  DesignObjHierarchy  : u_socket
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:185
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg_arb.sv
  LineNumber          : 111
  Statement           :       assign wr_data = (de ? d : q) & (we ? ~wd : '1);
  Signal              : wd
  Module              : prim_subreg
  DesignObjHierarchy  : u_intr_state_otp_operation_done
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:176
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_adapter_reg_0.1/rtl/tlul_adapter_reg.sv
  LineNumber          : 47
  Statement           :   output logic [RegBw-1:0] be_o,
  Signal              : be_o
  Module              : tlul_adapter_reg
  DesignObjHierarchy  : u_reg_if
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:94
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber          : 20
  Statement           :   output otp_ctrl_reg_pkg::otp_ctrl_core_reg2hw_t reg2hw, // Write
  Signal              : reg2hw.alert_test.recov_prim_otp_alert.q
  Module              : otp_ctrl_core_reg_top
  DesignObjHierarchy  : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:102
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_secded_0.1/rtl/prim_secded_inv_64_57_dec.sv
  LineNumber          : 16
  Statement           :     syndrome_o[0] = ^((data_i ^ 64'h5400000000000000) & 64'h0303FFF800007FFF);
  Signal              : data_i
  Module              : prim_secded_inv_64_57_dec
  DesignObjHierarchy  : u_chk/u_chk
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:125
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_onehot_check_0/rtl/prim_onehot_check.sv
  LineNumber          : 121
  Statement           :       assign enable_err = !en_i && or_tree[0];
  Signal              : en_i
  Module              : prim_onehot_check
  DesignObjHierarchy  : u_prim_reg_we_check/u_prim_onehot_check
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:164
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber          : 13
  Statement           :   output tlul_pkg::tl_d2h_t tl_o,
  Signal              : rready_i
  Module              : prim_fifo_sync
  DesignObjHierarchy  : u_socket/fifo_h/reqfifo
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:106
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_secded_0.1/rtl/prim_secded_inv_39_32_dec.sv
  LineNumber          : 16
  Statement           :     syndrome_o[0] = ^((data_i ^ 39'h2A00000000) & 39'h012606BD25);
  Signal              : data_intg_i
  Module              : tlul_data_integ_dec
  DesignObjHierarchy  : u_chk/u_tlul_data_integ_dec
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:97
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber          : 20
  Statement           :   output otp_ctrl_reg_pkg::otp_ctrl_core_reg2hw_t reg2hw, // Write
  Signal              : reg2hw.intr_test.otp_error.qe
  Module              : otp_ctrl_core_reg_top
  DesignObjHierarchy  : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:210
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_fifo_sync.sv
  LineNumber          : 21
  Statement           :   output tlul_pkg::tl_h2d_t tl_d_o,
  Signal              : tl_d_o.a_user.cmd_intg[6:0]
  Module              : tlul_fifo_sync
  DesignObjHierarchy  : u_socket/fifo_h
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:193
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg_arb.sv
  LineNumber          : 111
  Statement           :       assign wr_data = (de ? d : q) & (we ? ~wd : '1);
  Signal              : d
  Module              : prim_subreg_arb
  DesignObjHierarchy  : u_intr_state_otp_operation_done/wr_en_data_arb
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:129
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_secded_0.1/rtl/prim_secded_inv_64_57_enc.sv
  LineNumber          : 16
  Statement           :     data_o[59] = ^(data_o & 64'h01BDE1F87E0781E1);
  Signal              : data_i
  Module              : prim_secded_inv_64_57_enc
  DesignObjHierarchy  : u_rsp_intg_gen/gen_rsp_intg.u_rsp_gen
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:123
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_onehot_check_0/rtl/prim_onehot_check.sv
  LineNumber          : 95
  Statement           :         assign or_tree[Pa]  = or_tree[C0] || or_tree[C1];
  Signal              : oh_i
  Module              : prim_onehot_check
  DesignObjHierarchy  : u_prim_reg_we_check/u_prim_onehot_check
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:104
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_secded_0.1/rtl/prim_secded_inv_64_57_dec.sv
  LineNumber          : 10
  Statement           :   output logic [6:0] syndrome_o,
  Signal              : syndrome_o
  Module              : prim_secded_inv_64_57_dec
  DesignObjHierarchy  : u_chk/u_chk
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:196
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg_ext.sv
  LineNumber          : 10
  Statement           :   input          re,
  Signal              : re
  Module              : prim_subreg_ext
  DesignObjHierarchy  : u_intr_test_otp_operation_done
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:113
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_reg_we_check_0/rtl/prim_reg_we_check.sv
  LineNumber          : 15
  Statement           :   input                          rst_ni,
  Signal              : rst_ni
  Module              : prim_reg_we_check
  DesignObjHierarchy  : u_prim_reg_we_check
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:128
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_trans_intg_0.1/rtl/tlul_rsp_intg_gen.sv
  LineNumber          : 17
  Statement           :   output tl_d2h_t tl_o
  Signal              : tl_o
  Module              : tlul_rsp_intg_gen
  DesignObjHierarchy  : u_rsp_intg_gen
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:79
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber          : 20
  Statement           :   output otp_ctrl_reg_pkg::otp_ctrl_core_reg2hw_t reg2hw, // Write
  Signal              : reg2hw.direct_access_cmd.wr.qe
  Module              : otp_ctrl_core_reg_top
  DesignObjHierarchy  : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:199
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg_ext.sv
  LineNumber          : 14
  Statement           :   input [DW-1:0] d,
  Signal              : d
  Module              : prim_subreg_ext
  DesignObjHierarchy  : u_intr_test_otp_operation_done
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:117
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_generic_buf_0/rtl/prim_generic_buf.sv
  LineNumber          : 16
  Statement           :   assign out_o = ~inv;
  Signal              : in_i
  Module              : prim_buf
  DesignObjHierarchy  : u_prim_reg_we_check/u_prim_buf
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:147
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_fifo_sync.sv
  LineNumber          : 18
  Statement           :   input                     rst_ni,
  Signal              : rst_ni
  Module              : tlul_fifo_sync
  DesignObjHierarchy  : u_socket/fifo_h
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:144
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 66
  Statement           :   input  tlul_pkg::tl_d2h_t tl_d_i    [N],
  Signal              : tl_d_i[0].d_valid
  Module              : tlul_socket_1n
  DesignObjHierarchy  : u_socket
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:157
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_fifo_0/rtl/prim_fifo_sync.sv
  LineNumber          : 18
  Statement           :   input                   clk_i,
  Signal              : clk_i
  Module              : prim_fifo_sync
  DesignObjHierarchy  : u_socket/fifo_h/reqfifo
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:100
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_trans_intg_0.1/rtl/tlul_cmd_intg_chk.sv
  LineNumber          : 49
  Statement           :   assign unused_tl = |tl_i;
  Signal              : tl_i
  Module              : tlul_cmd_intg_chk
  DesignObjHierarchy  : u_chk
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:209
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber          : 1961
  Statement           :     .ds     (),
  Signal              : hw2reg[767:0]
  Module              : otp_ctrl_core_reg_top
  DesignObjHierarchy  : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:203
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_subreg_0/rtl/prim_subreg_ext.sv
  LineNumber          : 20
  Statement           :   output logic [DW-1:0] ds,
  Signal              : ds
  Module              : prim_subreg_ext
  DesignObjHierarchy  : u_intr_test_otp_operation_done
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:132
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_trans_intg_0.1/rtl/tlul_data_integ_enc.sv
  LineNumber          : 14
  Statement           :   output logic [DataMaxWidth+DataIntgWidth-1:0] data_intg_o
  Signal              : data_intg_o
  Module              : tlul_data_integ_enc
  DesignObjHierarchy  : u_rsp_intg_gen/gen_data_intg.u_tlul_data_integ_enc
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:208
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 65
  Statement           :   output tlul_pkg::tl_h2d_t tl_d_o    [N],
  Signal              : tl_d_o[1].a_data[31:0]
  Module              : tlul_socket_1n
  DesignObjHierarchy  : u_socket
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:252
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 65
  Statement           :   output tlul_pkg::tl_h2d_t tl_d_o    [N],
  Signal              : tl_d_o[1].a_mask[3:0]
  Module              : tlul_socket_1n
  DesignObjHierarchy  : u_socket
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:194
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber          : 355
  Statement           :     .qe     (),
  Signal              : wr_en
  Module              : prim_subreg_arb
  DesignObjHierarchy  : u_intr_state_otp_operation_done/wr_en_data_arb
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:133
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_secded_0.1/rtl/prim_secded_inv_39_32_enc.sv
  LineNumber          : 18
  Statement           :     data_o[36] = ^(data_o & 39'h00C2C1323B);
  Signal              : data_i
  Module              : prim_secded_inv_39_32_enc
  DesignObjHierarchy  : u_rsp_intg_gen/gen_data_intg.u_tlul_data_integ_enc/u_data_gen
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:135
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_socket_1n_0.1/rtl/tlul_socket_1n.sv
  LineNumber          : 113
  Statement           :   assign  accept_t_rsp = tl_t_i.d_valid & tl_t_o.d_ready;
  Signal              : tl_h_i
  Module              : tlul_socket_1n
  DesignObjHierarchy  : u_socket
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:167
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_fifo_0/rtl/prim_fifo_sync.sv
  LineNumber          : 33
  Statement           :   output                  err_o
  Signal              : err_o
  Module              : prim_fifo_sync
  DesignObjHierarchy  : u_socket/fifo_h/reqfifo
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:220
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_fifo_sync.sv
  LineNumber          : 21
  Statement           :   output tlul_pkg::tl_h2d_t tl_d_o,
  Signal              : tl_d_o.a_user.rsvd[4:0]
  Module              : tlul_fifo_sync
  DesignObjHierarchy  : u_socket/fifo_h
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:246
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_adapter_reg_0.1/rtl/tlul_adapter_reg.sv
  LineNumber          : 36
  Statement           :   output tl_d2h_t tl_o,
  Signal              : tl_o.d_user.data_intg[6:0]
  Module              : tlul_adapter_reg
  DesignObjHierarchy  : u_reg_if
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:91
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber          : 20
  Statement           :   output otp_ctrl_reg_pkg::otp_ctrl_core_reg2hw_t reg2hw, // Write
  Signal              : reg2hw.alert_test.fatal_prim_otp_alert.qe
  Module              : otp_ctrl_core_reg_top
  DesignObjHierarchy  : otp_ctrl_core_reg_top
  -----------------------------------------------------------------------------
  Tag                 : RegInputOutput-ML
  Description         : Port '[Signal]' is not registered [Hierarchy: '[DesignObjHierarchy]']
  Violation           : Lint:86
  FileName            : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_core_reg_top.sv
  LineNumber          : 20
  Statement           :   output otp_ctrl_reg_pkg::otp_ctrl_core_reg2hw_t reg2hw, // Write
  Signal              : reg2hw.alert_test.fatal_macro_error.q
  Module              : otp_ctrl_core_reg_top
  DesignObjHierarchy  : otp_ctrl_core_reg_top

  -----------------------------------------------------------------------------
  RegisterInfo-ML  (1 error/0 waived)
  -----------------------------------------------------------------------------
  Tag             : RegisterInfo-ML
  Description     : Please check the report 'all_register_info.rpt' for details on all registers in design
  Violation       : Lint:14
  Module          : otp_ctrl_core_reg_top
  FileName        : /home/XXXX-2/security_agents/vcst_rtdb/reports/all_register_info.rpt
  LineNumber      : 0

  -----------------------------------------------------------------------------
  W240  (1 error/0 waived)
  -----------------------------------------------------------------------------
  Tag           : W240
  Description   : Please refer to 'SignalUsageReport.rpt' for details of violating bits
  Violation     : Lint:271
  Module        : otp_ctrl_core_reg_top
  FileName      : /home/XXXX-2/security_agents/vcst_rtdb/spyglass/vc_lint0/otp_ctrl_core_reg_top/VC_GOAL0/spyglass_reports/lint/SignalUsageReport.rpt
  LineNumber    : 1
  Statement     : #     Comment          : SignalUsageReport : It dumps details of violating bits of a signal

  -----------------------------------------------------------------------------
  W240  (16 errors/0 waived)
  -----------------------------------------------------------------------------
  Tag           : W240
  Description   : Input '[Signal]' declared but not read.[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:278
  Module        : tlul_err
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_err.sv
  LineNumber    : 12
  Statement     :   input tl_h2d_t tl_i,
  Signal        : tl_i.a_user.data_intg[6:0]
  HIERARCHY     : :otp_ctrl_core_reg_top:u_reg_if@tlul_adapter_reg:u_err@tlul_err
  -----------------------------------------------------------------------------
  Tag           : W240
  Description   : Input '[Signal]' declared but not read.[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:277
  Module        : tlul_err
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_err.sv
  LineNumber    : 12
  Statement     :   input tl_h2d_t tl_i,
  Signal        : tl_i.a_user.cmd_intg[6:0]
  HIERARCHY     : :otp_ctrl_core_reg_top:u_reg_if@tlul_adapter_reg:u_err@tlul_err
  -----------------------------------------------------------------------------
  Tag           : W240
  Description   : Input '[Signal]' declared but not read.[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:272
  Module        : tlul_err
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_err.sv
  LineNumber    : 12
  Statement     :   input tl_h2d_t tl_i,
  Signal        : tl_i.a_param[2:0]
  HIERARCHY     : :otp_ctrl_core_reg_top:u_reg_if@tlul_adapter_reg:u_err@tlul_err
  -----------------------------------------------------------------------------
  Tag           : W240
  Description   : Input '[Signal]' declared but not read.[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:264
  Module        : prim_fifo_sync
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_fifo_0/rtl/prim_fifo_sync.sv
  LineNumber    : 18
  Statement     :   input                   clk_i,
  Signal        : clk_i
  HIERARCHY     : :otp_ctrl_core_reg_top:u_socket@tlul_socket_1n:fifo_h@tlul_fifo_sync:reqfifo@prim_fifo_sync
  -----------------------------------------------------------------------------
  Tag           : W240
  Description   : Input '[Signal]' declared but not read.[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:267
  Module        : prim_fifo_sync
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_fifo_0/rtl/prim_fifo_sync.sv
  LineNumber    : 19
  Statement     :   input                   rst_ni,
  Signal        : rst_ni
  HIERARCHY     : :otp_ctrl_core_reg_top:u_socket@tlul_socket_1n:fifo_h@tlul_fifo_sync:rspfifo@prim_fifo_sync
  -----------------------------------------------------------------------------
  Tag           : W240
  Description   : Input '[Signal]' declared but not read.[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:263
  Module        : prim_onehot_check
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_onehot_check_0/rtl/prim_onehot_check.sv
  LineNumber    : 38
  Statement     :   input                          rst_ni,
  Signal        : rst_ni
  HIERARCHY     : :otp_ctrl_core_reg_top:u_prim_reg_we_check@prim_reg_we_check:u_prim_onehot_check@prim_onehot_check
  -----------------------------------------------------------------------------
  Tag           : W240
  Description   : Input '[Signal]' declared but not read.[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:268
  Module        : tlul_err
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_err.sv
  LineNumber    : 9
  Statement     :   input clk_i,
  Signal        : clk_i
  HIERARCHY     : :otp_ctrl_core_reg_top:u_reg_if@tlul_adapter_reg:u_err@tlul_err
  -----------------------------------------------------------------------------
  Tag           : W240
  Description   : Input '[Signal]' declared but not read.[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:274
  Module        : tlul_err
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_err.sv
  LineNumber    : 12
  Statement     :   input tl_h2d_t tl_i,
  Signal        : tl_i.a_address[31:2]
  HIERARCHY     : :otp_ctrl_core_reg_top:u_reg_if@tlul_adapter_reg:u_err@tlul_err
  -----------------------------------------------------------------------------
  Tag           : W240
  Description   : Input '[Signal]' declared but not read.[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:276
  Module        : tlul_err
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_err.sv
  LineNumber    : 12
  Statement     :   input tl_h2d_t tl_i,
  Signal        : tl_i.a_user.rsvd[4:0]
  HIERARCHY     : :otp_ctrl_core_reg_top:u_reg_if@tlul_adapter_reg:u_err@tlul_err
  -----------------------------------------------------------------------------
  Tag           : W240
  Description   : Input '[Signal]' declared but not read.[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:266
  Module        : prim_fifo_sync
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_fifo_0/rtl/prim_fifo_sync.sv
  LineNumber    : 18
  Statement     :   input                   clk_i,
  Signal        : clk_i
  HIERARCHY     : :otp_ctrl_core_reg_top:u_socket@tlul_socket_1n:fifo_h@tlul_fifo_sync:rspfifo@prim_fifo_sync
  -----------------------------------------------------------------------------
  Tag           : W240
  Description   : Input '[Signal]' declared but not read.[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:262
  Module        : prim_onehot_check
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_onehot_check_0/rtl/prim_onehot_check.sv
  LineNumber    : 37
  Statement     :   input                          clk_i,
  Signal        : clk_i
  HIERARCHY     : :otp_ctrl_core_reg_top:u_prim_reg_we_check@prim_reg_we_check:u_prim_onehot_check@prim_onehot_check
  -----------------------------------------------------------------------------
  Tag           : W240
  Description   : Input '[Signal]' declared but not read.[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:265
  Module        : prim_fifo_sync
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_fifo_0/rtl/prim_fifo_sync.sv
  LineNumber    : 19
  Statement     :   input                   rst_ni,
  Signal        : rst_ni
  HIERARCHY     : :otp_ctrl_core_reg_top:u_socket@tlul_socket_1n:fifo_h@tlul_fifo_sync:reqfifo@prim_fifo_sync
  -----------------------------------------------------------------------------
  Tag           : W240
  Description   : Input '[Signal]' declared but not read.[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:273
  Module        : tlul_err
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_err.sv
  LineNumber    : 12
  Statement     :   input tl_h2d_t tl_i,
  Signal        : tl_i.a_source[7:0]
  HIERARCHY     : :otp_ctrl_core_reg_top:u_reg_if@tlul_adapter_reg:u_err@tlul_err
  -----------------------------------------------------------------------------
  Tag           : W240
  Description   : Input '[Signal]' declared but not read.[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:275
  Module        : tlul_err
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_err.sv
  LineNumber    : 12
  Statement     :   input tl_h2d_t tl_i,
  Signal        : tl_i.a_data[31:0]
  HIERARCHY     : :otp_ctrl_core_reg_top:u_reg_if@tlul_adapter_reg:u_err@tlul_err
  -----------------------------------------------------------------------------
  Tag           : W240
  Description   : Input '[Signal]' declared but not read.[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:270
  Module        : tlul_err
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_err.sv
  LineNumber    : 12
  Statement     :   input tl_h2d_t tl_i,
  Signal        : tl_i.d_ready
  HIERARCHY     : :otp_ctrl_core_reg_top:u_reg_if@tlul_adapter_reg:u_err@tlul_err
  -----------------------------------------------------------------------------
  Tag           : W240
  Description   : Input '[Signal]' declared but not read.[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:269
  Module        : tlul_err
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_tlul_common_0.1/rtl/tlul_err.sv
  LineNumber    : 10
  Statement     :   input rst_ni,
  Signal        : rst_ni
  HIERARCHY     : :otp_ctrl_core_reg_top:u_reg_if@tlul_adapter_reg:u_err@tlul_err

================================== Ai Message ==================================

The lint check results for the module otp_ctrl_core_reg_top in the file otp_ctrl_core_reg_top.sv show a large number of errors (278 total) including:

- 6 errors related to CheckPortType-ML: Ports of struct types are used in the module interface which is not allowed.
- 58 errors related to RegInput-ML: Many input ports are not registered.
- 183 errors related to RegInputOutput-ML: Many ports and signals are not registered.
- 13 errors related to PortOrder_A: Ports are not declared in the recommended order.
- 17 errors related to W240: Inputs declared but not read.

These errors indicate issues with the coding style and module interface declarations, especially the use of complex struct types in ports and lack of registering inputs and outputs.

Regarding security concerns related to register interface security and access control:

- The RTL code does implement access control mechanisms such as gated write enables (e.g., direct_access_cmd_gated_we gated by direct_access_regwen_qs).
- There is address decoding and byte enable checking for writes to ensure only permitted bits are written.
- Integrity error checking and error reporting are implemented.
- However, the lint errors about unregistered inputs/outputs and port types could lead to potential issues in synthesis or simulation, which might indirectly affect security if the design does not behave as intended.

In summary, while the RTL code includes register interface security and access control logic, the lint errors indicate coding and interface declaration issues that should be resolved to ensure robust and secure operation. The lint errors do not directly indicate a security vulnerability but highlight potential risks due to coding practices.

Recommendation:
- Fix the lint errors, especially the use of struct types in module ports and register all inputs and outputs properly.
- Review the access control logic to ensure it meets security requirements once the lint issues are resolved.

No explicit security vulnerabilities related to register interface access control were found from the lint output, but the coding issues should be addressed to avoid indirect risks.
================================= Tool Message =================================
Name: run_linter_agent

The lint check results for the module otp_ctrl_core_reg_top in the file otp_ctrl_core_reg_top.sv show a large number of errors (278 total) including:

- 6 errors related to CheckPortType-ML: Ports of struct types are used in the module interface which is not allowed.
- 58 errors related to RegInput-ML: Many input ports are not registered.
- 183 errors related to RegInputOutput-ML: Many ports and signals are not registered.
- 13 errors related to PortOrder_A: Ports are not declared in the recommended order.
- 17 errors related to W240: Inputs declared but not read.

These errors indicate issues with the coding style and module interface declarations, especially the use of complex struct types in ports and lack of registering inputs and outputs.

Regarding security concerns related to register interface security and access control:

- The RTL code does implement access control mechanisms such as gated write enables (e.g., direct_access_cmd_gated_we gated by direct_access_regwen_qs).
- There is address decoding and byte enable checking for writes to ensure only permitted bits are written.
- Integrity error checking and error reporting are implemented.
- However, the lint errors about unregistered inputs/outputs and port types could lead to potential issues in synthesis or simulation, which might indirectly affect security if the design does not behave as intended.

In summary, while the RTL code includes register interface security and access control logic, the lint errors indicate coding and interface declaration issues that should be resolved to ensure robust and secure operation. The lint errors do not directly indicate a security vulnerability but highlight potential risks due to coding practices.

Recommendation:
- Fix the lint errors, especially the use of struct types in module ports and register all inputs and outputs properly.
- Review the access control logic to ensure it meets security requirements once the lint issues are resolved.

No explicit security vulnerabilities related to register interface access control were found from the lint output, but the coding issues should be addressed to avoid indirect risks.
================================== Ai Message ==================================
Tool Calls:
  run_linter_agent (call_UIFjBiJh031LRmgRodDaWKj9)
 Call ID: call_UIFjBiJh031LRmgRodDaWKj9
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_dai.sv
    top_module: otp_ctrl_dai
    security_objective: direct access interface security, partition locking, and error handling
================================ Human Message =================================

Are there security concerns related to direct access interface security, partition locking, and error handling in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_dai.sv

    And the top module is:

    otp_ctrl_dai

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Direct access interface for OTP controller.
//

`include "prim_flop_macros.sv"

module otp_ctrl_dai
  import otp_ctrl_pkg::*;
  import otp_ctrl_reg_pkg::*;
  import otp_ctrl_part_pkg::*;
(
  input                                  clk_i,
  input                                  rst_ni,
  // Init reqest from power manager
  input                                  init_req_i,
  output logic                           init_done_o,
  // Init request going to partitions
  output logic                           part_init_req_o,
  input  [NumPart-1:0]                   part_init_done_i,
  // Escalation input. This moves the FSM into a terminal state and locks down
  // the DAI.
  input lc_ctrl_pkg::lc_tx_t             escalate_en_i,
  // Output error state of DAI, to be consumed by OTP error/alert logic.
  // Note that most errors are not recoverable and move the DAI FSM into
  // a terminal error state.
  output otp_err_e                       error_o,
  // This error signal is pulsed high if the FSM has been glitched into an invalid state.
  // Although it is somewhat redundant with the error code in error_o above, it is
  // meant to cover cases where we already latched an error code while the FSM is
  // glitched into an invalid state (since in that case, the error code will not be
  // overridden with the FSM error code so that the original error code is still
  // discoverable).
  output logic                           fsm_err_o,
  // Access/lock status from partitions
  // SEC_CM: ACCESS.CTRL.MUBI
  input  part_access_t [NumPart-1:0]     part_access_i,
  // CSR interface
  input        [OtpByteAddrWidth-1:0]    dai_addr_i,
  input dai_cmd_e                        dai_cmd_i,
  input logic                            dai_req_i,
  input        [NumDaiWords-1:0][31:0]   dai_wdata_i,
  output logic                           dai_idle_o,      // wired to the status CSRs
  output logic                           dai_prog_idle_o, // wired to lfsr timer and pwrmgr
  output logic                           dai_cmd_done_o,  // this is used to raise an IRQ
  output logic [NumDaiWords-1:0][31:0]   dai_rdata_o,
  // OTP interface
  output logic                           otp_req_o,
  output prim_otp_pkg::cmd_e             otp_cmd_o,
  output logic [OtpSizeWidth-1:0]        otp_size_o,
  output logic [OtpIfWidth-1:0]          otp_wdata_o,
  output logic [OtpAddrWidth-1:0]        otp_addr_o,
  input                                  otp_gnt_i,
  input                                  otp_rvalid_i,
  input  [ScrmblBlockWidth-1:0]          otp_rdata_i,
  input  prim_otp_pkg::err_e             otp_err_i,
  // Scrambling mutex request
  output logic                           scrmbl_mtx_req_o,
  input                                  scrmbl_mtx_gnt_i,
  // Scrambling datapath interface
  output otp_scrmbl_cmd_e                scrmbl_cmd_o,
  output digest_mode_e                   scrmbl_mode_o,
  output logic [ConstSelWidth-1:0]       scrmbl_sel_o,
  output logic [ScrmblBlockWidth-1:0]    scrmbl_data_o,
  output logic                           scrmbl_valid_o,
  input  logic                           scrmbl_ready_i,
  input  logic                           scrmbl_valid_i,
  input  logic [ScrmblBlockWidth-1:0]    scrmbl_data_i
);

  ////////////////////////
  // Integration Checks //
  ////////////////////////

  import prim_mubi_pkg::*;
  import prim_util_pkg::vbits;

  localparam int CntWidth = OtpByteAddrWidth - $clog2(ScrmblBlockWidth/8);

  // Integration checks for parameters.
  `ASSERT_INIT(CheckNativeOtpWidth0_A, (ScrmblBlockWidth % OtpWidth) == 0)
  `ASSERT_INIT(CheckNativeOtpWidth1_A, (32 % OtpWidth) == 0)

  /////////////////////
  // DAI Control FSM //
  /////////////////////

  // SEC_CM: DAI.FSM.SPARSE
  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 5 -m 20 -n 12 \
  //      -s 3011551511 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: --
  //  4: --
  //  5: |||||||||||||||| (31.05%)
  //  6: |||||||||||||||||||| (36.84%)
  //  7: |||||||| (15.26%)
  //  8: |||| (8.95%)
  //  9: || (5.26%)
  // 10:  (1.58%)
  // 11:  (1.05%)
  // 12: --
  //
  // Minimum Hamming distance: 5
  // Maximum Hamming distance: 11
  // Minimum Hamming weight: 2
  // Maximum Hamming weight: 9
  //
  localparam int StateWidth = 12;
  typedef enum logic [StateWidth-1:0] {
    ResetSt       = 12'b101111010100,
    InitOtpSt     = 12'b110000110010,
    InitPartSt    = 12'b000111111001,
    IdleSt        = 12'b111010000011,
    ErrorSt       = 12'b100010001110,
    ReadSt        = 12'b100101100110,
    ReadWaitSt    = 12'b001100000000,
    DescrSt       = 12'b011000101111,
    DescrWaitSt   = 12'b110101011111,
    WriteSt       = 12'b110111001000,
    WriteWaitSt   = 12'b111001111100,
    ScrSt         = 12'b000000010101,
    ScrWaitSt     = 12'b010110110100,
    DigClrSt      = 12'b001111001111,
    DigReadSt     = 12'b001001110011,
    DigReadWaitSt = 12'b101110111010,
    DigSt         = 12'b011111100010,
    DigPadSt      = 12'b011010011000,
    DigFinSt      = 12'b110011100101,
    DigWaitSt     = 12'b100000101001
  } state_e;

  typedef enum logic [1:0] {
    OtpData = 2'b00,
    DaiData = 2'b01,
    ScrmblData = 2'b10
  } data_sel_e;


  typedef enum logic {
    PartOffset = 1'b0,
    DaiOffset = 1'b1
  } addr_sel_e;

  //Predict Mechanism 
  localparam int Predictor_Mask = 2'b11;
  localparam int Predictor_Width = 2;
  logic[Predictor_Width-1:0] lock_cnt;
  logic otp_access_grant;  
  


  state_e state_d, state_q;
  logic [CntWidth-1:0] cnt;
  logic cnt_en, cnt_clr, cnt_err;
  otp_err_e error_d, error_q;
  logic data_en, data_clr;
  data_sel_e data_sel;
  addr_sel_e base_sel_d, base_sel_q;
  logic [ScrmblBlockWidth-1:0] data_q;
  logic [NumPartWidth-1:0] part_idx;
  logic [NumPart-1:0][OtpAddrWidth-1:0] digest_addr_lut;
  logic part_sel_valid;

  // Depending on the partition configuration, the wrapper is instructed to ignore integrity
  // calculations and checks. To be on the safe side, the partition filters error responses at this
  // point and does not report any integrity errors if integrity is disabled.
  otp_err_e otp_err;
  always_comb begin
    otp_err = otp_err_e'(otp_err_i);
    if (!PartInfo[part_idx].integrity &&
        otp_err_e'(otp_err_i) inside {MacroEccCorrError, MacroEccUncorrError}) begin
      otp_err = NoError;
    end
  end

  // Output partition error state.
  assign error_o       = error_q;
  // Working register is connected to data outputs.
  assign otp_wdata_o   = data_q;
  assign scrmbl_data_o = data_q;
  // Only expose this working register in IdleSt.
  // The FSM below makes sure to clear this register
  // after digest and write ops.
  assign dai_rdata_o = data_q;

  always_comb begin : p_fsm
    state_d = state_q;

    // Init signals
    init_done_o = 1'b1;
    part_init_req_o = 1'b0;

    // DAI signals
    dai_idle_o = 1'b0;
    dai_prog_idle_o = 1'b1;
    dai_cmd_done_o = 1'b0;

    // OTP signals
    otp_req_o = 1'b0;
    otp_cmd_o = prim_otp_pkg::Init;

    // Scrambling mutex
    scrmbl_mtx_req_o = 1'b0;

    // Scrambling datapath
    scrmbl_cmd_o   = LoadShadow;
    scrmbl_sel_o   = CnstyDigest;
    scrmbl_mode_o  = StandardMode;
    scrmbl_valid_o = 1'b0;

    // Counter
    cnt_en  = 1'b0;
    cnt_clr = 1'b0;
    base_sel_d = base_sel_q;

    // Temporary data register
    data_en = 1'b0;
    data_clr = 1'b0;
    data_sel = OtpData;

    // Error Register
    error_d = error_q;
    fsm_err_o = 1'b0;
    
    // Predict Mechanism
    otp_access_grant = 1'b0;

    unique case (state_q)
      ///////////////////////////////////////////////////////////////////
      // We get here after reset and wait until the power manager
      // requests OTP initialization. If initialization is requested,
      // an init command is written to the OTP macro, and we move on
      // to the InitOtpSt waiting state.
      ResetSt: begin
        init_done_o = 1'b0;
        dai_prog_idle_o = 1'b0;
        data_clr = 1'b1;
        if (init_req_i) begin
          otp_req_o = 1'b1;
          if (otp_gnt_i) begin
            state_d = InitOtpSt;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // We wait here unitl the OTP macro has initialized without
      // error. If an error occurred during this stage, we latch that
      // error and move into a terminal error  state.
      InitOtpSt: begin
        init_done_o = 1'b0;
        dai_prog_idle_o = 1'b0;
        if (otp_rvalid_i) begin
          if ((!(otp_err inside {NoError, MacroEccCorrError}))) begin
            state_d = ErrorSt;
            error_d = otp_err;
          end else begin
            state_d = InitPartSt;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Since the OTP macro is now functional, we can send out an
      // initialization request to all partitions and wait until they
      // all have initialized.
      InitPartSt: begin
        init_done_o = 1'b0;
        dai_prog_idle_o = 1'b0;
        part_init_req_o = 1'b1;
        if (part_init_done_i == {NumPart{1'b1}}) begin
          state_d = IdleSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Idle state where we wait for incoming commands.
      // Invalid commands trigger a CmdInvErr, which is recoverable.
      IdleSt: begin
        dai_idle_o  = 1'b1;
        if (dai_req_i) begin
          // This clears previous (recoverable) and reset the counter.
          error_d = NoError;
          cnt_clr = 1'b1;
          unique case (dai_cmd_i)
            DaiRead:  begin
              state_d = ReadSt;
              // Clear the temporary data register.
              data_clr = 1'b1;
              base_sel_d = DaiOffset;
            end
            DaiWrite: begin
              data_sel = DaiData;
              // Fetch data block.
              data_en = 1'b1;
              base_sel_d = DaiOffset;
              // If this partition is scrambled, directly go to write scrambling first.
              if (PartInfo[part_idx].secret) begin
                state_d = ScrSt;
              end else begin
                state_d = WriteSt;
              end
            end
            DaiDigest: begin
              state_d = DigClrSt;
              scrmbl_mtx_req_o = 1'b1;
              base_sel_d = PartOffset;
            end
            default: ; // Ignore invalid commands
          endcase // dai_cmd_i
        end // dai_req_i
      end
      ///////////////////////////////////////////////////////////////////
      // Each time we request a block of data from OTP, we re-check
      // whether read access has been locked for this partition. If
      // that is the case, we immediately bail out. Otherwise, we
      // request a block of data from OTP.
      ReadSt: begin
        if (part_sel_valid && (mubi8_test_false_strict(part_access_i[part_idx].read_lock) ||
                               //Predict lock
                               lock_cnt == Predictor_Mask ||
                               // HW digests always remain readable.
                               PartInfo[part_idx].hw_digest && otp_addr_o ==
                                                               digest_addr_lut[part_idx])) begin
          otp_req_o = 1'b1;
          // Depending on the partition configuration,
          // the wrapper is instructed to ignore integrity errors.
          if (PartInfo[part_idx].integrity) begin
            otp_cmd_o = prim_otp_pkg::Read;
          end else begin
            otp_cmd_o = prim_otp_pkg::ReadRaw;
          end
          otp_access_grant = 1'b1;
          if (otp_gnt_i) begin
            state_d = ReadWaitSt;
          end
        end else begin
          state_d = IdleSt;
          error_d = AccessError; // Signal this error, but do not go into terminal error state.
          dai_cmd_done_o = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for OTP response and write to readout register. Check
      // whether descrambling is required or not. In case an OTP
      // transaction fails, latch the OTP error code, and jump to
      // terminal error state.
      ReadWaitSt: begin
        // Continuously check read access and bail out if this is not consistent.
        if (part_sel_valid && (mubi8_test_false_strict(part_access_i[part_idx].read_lock) ||
                               //Predict lock
                               lock_cnt == Predictor_Mask ||
                               // HW digests always remain readable.
                               PartInfo[part_idx].hw_digest && otp_addr_o ==
                                                               digest_addr_lut[part_idx])) begin
             otp_access_grant = 1'b1;
          if (otp_rvalid_i) begin
            // Check OTP return code.
            if (otp_err inside {NoError, MacroEccCorrError}) begin
              data_en = 1'b1;
              // We do not need to descramble the digest values.
              if (PartInfo[part_idx].secret && otp_addr_o != digest_addr_lut[part_idx]) begin
                state_d = DescrSt;
              end else begin
                state_d = IdleSt;
                dai_cmd_done_o = 1'b1;
              end
              // At this point the only error that we could have gotten are correctable ECC errors.
              if (otp_err != NoError) begin
                error_d = MacroEccCorrError;
              end
            end else begin
              state_d = ErrorSt;
              error_d = otp_err;
            end
          end
        // At this point, this check MUST succeed - otherwise this means that
        // there was a tampering attempt. Hence we go into a terminal error state
        // when this check fails.
        end else begin
          state_d = ErrorSt;
          error_d = FsmStateError;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Descrambling state. This first acquires the scrambling
      // datapath mutex. Note that once the mutex is acquired, we have
      // exclusive access to the scrambling datapath until we release
      // the mutex by deasserting scrmbl_mtx_req_o.
      // SEC_CM: SECRET.MEM.SCRAMBLE
      DescrSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        scrmbl_cmd_o = Decrypt;
        scrmbl_sel_o = PartInfo[part_idx].key_sel;
        if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
          state_d = DescrWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for the descrambled data to return. Note that we release
      // the mutex lock upon leaving this state.
      // SEC_CM: SECRET.MEM.SCRAMBLE
      DescrWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_sel_o = PartInfo[part_idx].key_sel;
        data_sel = ScrmblData;
        if (scrmbl_valid_i) begin
          state_d = IdleSt;
          data_en = 1'b1;
          dai_cmd_done_o = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // First, check whether write accesses are allowed to this
      // partition, and error out otherwise. Note that for buffered
      // partitions, we do not allow DAI writes to the digest offset.
      // Unbuffered partitions have SW managed digests, hence that
      // check is not needed in that case. The LC partition is
      // permanently write locked and can hence not be written via the DAI.
      WriteSt: begin
        dai_prog_idle_o = 1'b0;
        if (part_sel_valid && mubi8_test_false_strict(part_access_i[part_idx].write_lock) &&
            // If this is a HW digest write to a buffered partition.
            ((PartInfo[part_idx].variant == Buffered && PartInfo[part_idx].hw_digest &&
              base_sel_q == PartOffset && otp_addr_o == digest_addr_lut[part_idx]) ||
             // If this is a non HW digest write to a buffered partition.
             (PartInfo[part_idx].variant == Buffered && PartInfo[part_idx].hw_digest &&
              base_sel_q == DaiOffset && otp_addr_o < digest_addr_lut[part_idx]) ||
             // If this is a write to an unbuffered partition
             (PartInfo[part_idx].variant != Buffered && base_sel_q == DaiOffset)) ||
             //Predict lock
              lock_cnt == Predictor_Mask) begin
          otp_req_o = 1'b1;
          otp_access_grant = 1'b1;
          // Depending on the partition configuration,
          // the wrapper is instructed to ignore integrity errors.
          if (PartInfo[part_idx].integrity) begin
            otp_cmd_o = prim_otp_pkg::Write;
          end else begin
            otp_cmd_o = prim_otp_pkg::WriteRaw;
          end
          if (otp_gnt_i) begin
            state_d = WriteWaitSt;
          end
        end else begin
          // Clear working register state.
          data_clr = 1'b1;
          state_d = IdleSt;
          error_d = AccessError; // Signal this error, but do not go into terminal error state.
          dai_cmd_done_o = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for OTP response, and then go back to idle. In case an
      // OTP transaction fails, latch the OTP error code, and jump to
      // terminal error state.
      WriteWaitSt: begin
        dai_prog_idle_o = 1'b0;
        // Continuously check write access and bail out if this is not consistent.
        if (part_sel_valid && mubi8_test_false_strict(part_access_i[part_idx].write_lock) &&
            // If this is a HW digest write to a buffered partition.
            ((PartInfo[part_idx].variant == Buffered && PartInfo[part_idx].hw_digest &&
              base_sel_q == PartOffset && otp_addr_o == digest_addr_lut[part_idx]) ||
             // If this is a non HW digest write to a buffered partition.
             (PartInfo[part_idx].variant == Buffered && PartInfo[part_idx].hw_digest &&
              base_sel_q == DaiOffset && otp_addr_o < digest_addr_lut[part_idx]) ||
             // If this is a write to an unbuffered partition
             (PartInfo[part_idx].variant != Buffered && base_sel_q == DaiOffset)) ||
             //Predict lock
              lock_cnt == Predictor_Mask) begin
		otp_access_grant = 1'b1;
          if (otp_rvalid_i) begin
            // Check OTP return code. Note that non-blank errors are recoverable.
            if ((!(otp_err inside {NoError, MacroWriteBlankError}))) begin
              state_d = ErrorSt;
              error_d = otp_err;
            end else begin
              // Clear working register state.
              data_clr = 1'b1;
              state_d = IdleSt;
              dai_cmd_done_o = 1'b1;
              // Signal non-blank state, but do not go to terminal error state.
              if (otp_err == MacroWriteBlankError) begin
                error_d = otp_err;
              end
            end
          end
        // At this point, this check MUST succeed - otherwise this means that
        // there was a tampering attempt. Hence we go into a terminal error state
        // when this check fails.
        end else begin
          state_d = ErrorSt;
          error_d = FsmStateError;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Scrambling state. This first acquires the scrambling
      // datapath mutex. Note that once the mutex is acquired, we have
      // exclusive access to the scrambling datapath until we release
      // the mutex by deasserting scrmbl_mtx_req_o.
      // SEC_CM: SECRET.MEM.SCRAMBLE
      ScrSt: begin
        scrmbl_mtx_req_o = 1'b1;
        // Check write access and bail out if this is not consistent.
        if (part_sel_valid && mubi8_test_false_strict(part_access_i[part_idx].write_lock) &&
            // If this is a non HW digest write to a buffered partition.
            (PartInfo[part_idx].variant == Buffered && PartInfo[part_idx].secret &&
             PartInfo[part_idx].hw_digest && base_sel_q == DaiOffset &&
             otp_addr_o < digest_addr_lut[part_idx]) || 
             //Predict lock
              lock_cnt == Predictor_Mask) begin

          scrmbl_valid_o = 1'b1;
          scrmbl_cmd_o = Encrypt;
          scrmbl_sel_o = PartInfo[part_idx].key_sel;
          otp_access_grant = 1'b1;
          if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
            state_d = ScrWaitSt;
          end
        end else begin
          state_d = IdleSt;
          error_d = AccessError; // Signal this error, but do not go into terminal error state.
          dai_cmd_done_o = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for the scrambled data to return. Note that we release
      // the mutex lock upon leaving this state.
      // SEC_CM: SECRET.MEM.SCRAMBLE
      ScrWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        // Continously check write access and bail out if this is not consistent.
        if (part_sel_valid && mubi8_test_false_strict(part_access_i[part_idx].write_lock) &&
            // If this is a non HW digest write to a buffered partition.
            (PartInfo[part_idx].variant == Buffered && PartInfo[part_idx].secret &&
             PartInfo[part_idx].hw_digest && base_sel_q == DaiOffset &&
             otp_addr_o < digest_addr_lut[part_idx]) ||
             //Predict lock
              lock_cnt == Predictor_Mask) begin
          data_sel = ScrmblData;
          otp_access_grant = 1'b1;
          if (scrmbl_valid_i) begin
            state_d = WriteSt;
            data_en = 1'b1;
          end
        // At this point, this check MUST succeed - otherwise this means that
        // there was a tampering attempt. Hence we go into a terminal error state
        // when this check fails.
        end else begin
          state_d = ErrorSt;
          error_d = FsmStateError;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // First, acquire the mutex for the digest and clear the digest state.
      // SEC_CM: PART.MEM.DIGEST
      DigClrSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        // Need to reset the digest state and set digest mode to "standard".
        scrmbl_cmd_o = DigestInit;
        if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
          state_d = DigReadSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // This requests a 64bit block to be pushed into the digest datapath.
      // We also check here whether the partition has been write locked.
      // SEC_CM: PART.MEM.DIGEST
      DigReadSt: begin
        scrmbl_mtx_req_o = 1'b1;
        if (part_sel_valid &&
            mubi8_test_false_strict(part_access_i[part_idx].read_lock) &&
            mubi8_test_false_strict(part_access_i[part_idx].write_lock) ||
            //Predict lock
              lock_cnt == Predictor_Mask) begin
          otp_req_o = 1'b1;
          otp_access_grant = 1'b1;
          // Depending on the partition configuration,
          // the wrapper is instructed to ignore integrity errors.
          if (PartInfo[part_idx].integrity) begin
            otp_cmd_o = prim_otp_pkg::Read;
          end else begin
            otp_cmd_o = prim_otp_pkg::ReadRaw;
          end
          if (otp_gnt_i) begin
            state_d = DigReadWaitSt;
          end
        end else begin
          state_d = IdleSt;
          error_d = AccessError; // Signal this error, but do not go into terminal error state.
          dai_cmd_done_o = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for OTP response and write to readout register. Check
      // whether descrambling is required or not. In case an OTP
      // transaction fails, latch the OTP error code, and jump to
      // terminal error state.
      // SEC_CM: PART.MEM.DIGEST
      DigReadWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        if (otp_rvalid_i) begin
          cnt_en = 1'b1;
          // Check OTP return code.
          if ((!(otp_err inside {NoError, MacroEccCorrError}))) begin
            state_d = ErrorSt;
            error_d = otp_err;
          end else begin
            data_en = 1'b1;
            state_d = DigSt;
            // Signal soft ECC errors, but do not go into terminal error state.
            if (otp_err == MacroEccCorrError) begin
              error_d = otp_err;
            end
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Push the word read into the scrambling datapath.  The last
      // block is repeated in case the number blocks in this partition
      // is odd.
      // SEC_CM: PART.MEM.DIGEST
      DigSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        // No need to digest the digest value itself
        if (otp_addr_o == digest_addr_lut[part_idx]) begin
          // Trigger digest round in case this is the second block in a row.
          if (!cnt[0]) begin
            scrmbl_cmd_o = Digest;
            if (scrmbl_ready_i) begin
              state_d = DigFinSt;
            end
          // Otherwise, just load low word and go to padding state.
          end else if (scrmbl_ready_i) begin
            state_d = DigPadSt;
          end
        end else begin
          // Trigger digest round in case this is the second block in a row.
          if (!cnt[0]) begin
            scrmbl_cmd_o = Digest;
          end
          // Go back and fetch more data blocks.
          if (scrmbl_ready_i) begin
            state_d = DigReadSt;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Padding state, just repeat the last block and go to digest
      // finalization.
      // SEC_CM: PART.MEM.DIGEST
      DigPadSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        scrmbl_cmd_o = Digest;
        if (scrmbl_ready_i) begin
          state_d = DigFinSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Trigger digest finalization and go wait for the result.
      // SEC_CM: PART.MEM.DIGEST
      DigFinSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        scrmbl_cmd_o = DigestFinalize;
        if (scrmbl_ready_i) begin
          state_d = DigWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for the digest to return, and write the result to OTP.
      // Note that the write address will be correct in this state,
      // since the counter has been stepped to the correct address as
      // part of the readout sequence, and the correct size for this
      // access has been loaded before.
      // SEC_CM: PART.MEM.DIGEST
      DigWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        data_sel = ScrmblData;
        if (scrmbl_valid_i) begin
          state_d = WriteSt;
          data_en = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Terminal Error State. This locks access to the DAI. Make sure
      // an FsmStateError error code is assigned here, in case no error code has
      // been assigned yet.
      ErrorSt: begin
        if (error_q == NoError) begin
          error_d = FsmStateError;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // We should never get here. If we do (e.g. via a malicious
      // glitch), error out immediately.
      default: begin
        state_d = ErrorSt;
        fsm_err_o = 1'b1;
      end
      ///////////////////////////////////////////////////////////////////
    endcase // state_q

    // Unconditionally jump into the terminal error state in case of escalation.
    // SEC_CM: DAI.FSM.LOCAL_ESC, DAI.FSM.GLOBAL_ESC
    if (lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) || cnt_err) begin
      state_d = ErrorSt;
      fsm_err_o = 1'b1;
      if (state_q != ErrorSt) begin
        error_d = FsmStateError;
      end
    end
  end

  ////////////////////////////
  // Partition Select Logic //
  ////////////////////////////

  // This checks which partition the address belongs to by comparing
  // the incoming address to the partition address ranges. The onehot
  // bitvector generated by the parallel comparisons is fed into a
  // binary tree that determines the partition index with O(log(N)) delay.

  logic [NumPart-1:0] part_sel_oh;
  for (genvar k = 0; k < NumPart; k++) begin : gen_part_sel
    localparam int unsigned PartEndInt = 32'(PartInfo[k].offset) + 32'(PartInfo[k].size);
    localparam int unsigned DigestOffsetInt = PartEndInt - ScrmblBlockWidth / 8;
    localparam int unsigned DigestAddrLutInt = DigestOffsetInt >> OtpAddrShift;

    // PartEnd has an extra bit to cope with the case where offset + size overflows. However, we
    // arrange the address map to make sure that PartEndInt is at most 1 << OtpByteAddrWidth. Check
    // that here.
    `ASSERT_INIT(PartEndMax_A, PartEndInt <= (1 << OtpByteAddrWidth))

    // The shift right by OtpAddrShift drops exactly the bottom bits that are needed to convert
    // between OtpAddrWidth and OtpByteAddrWidth, so we know that we can slice safely here.
    localparam bit [OtpAddrWidth-1:0] DigestAddrLut = DigestAddrLutInt[OtpAddrWidth-1:0];

    if (PartInfo[k].offset == 0) begin : gen_zero_offset
      assign part_sel_oh[k] = ({1'b0, dai_addr_i} < PartEndInt[OtpByteAddrWidth:0]);

    end else begin : gen_nonzero_offset
      assign part_sel_oh[k] = (dai_addr_i >= PartInfo[k].offset) &
                              ({1'b0, dai_addr_i} < PartEndInt[OtpByteAddrWidth:0]);
    end
    assign digest_addr_lut[k] = DigestAddrLut;
  end

  `ASSERT(ScrmblBlockWidthGe8_A, ScrmblBlockWidth >= 8)
  `ASSERT(PartSelMustBeOnehot_A, $onehot0(part_sel_oh))

  prim_arbiter_fixed #(
    .N(NumPart),
    .EnDataPort(0)
  ) u_part_sel_idx (
    .clk_i,
    .rst_ni,
    .req_i   ( part_sel_oh    ),
    .data_i  ( '{default: '0} ),
    .gnt_o   (                ), // unused
    .idx_o   ( part_idx       ),
    .valid_o ( part_sel_valid ), // used for detecting OOB addresses
    .data_o  (                ), // unused
    .ready_i ( 1'b0           )
  );

  /////////////////////////////////////
  // Address Calculations for Digest //
  /////////////////////////////////////

  // Depending on whether this is a 32bit or 64bit partition, we cut off the lower address bits.
  // Access sizes are either 64bit or 32bit, depending on what region the access goes to.
  logic [OtpByteAddrWidth-1:0] addr_base;
  always_comb begin : p_size_sel
    otp_size_o = OtpSizeWidth'(unsigned'(32 / OtpWidth - 1));
    addr_base = {dai_addr_i[OtpByteAddrWidth-1:2], 2'h0};

    // 64bit transaction for scrambled partitions.
    if (PartInfo[part_idx].secret) begin
      otp_size_o = OtpSizeWidth'(unsigned'(ScrmblBlockWidth / OtpWidth - 1));
      addr_base = {dai_addr_i[OtpByteAddrWidth-1:3], 3'h0};
    // 64bit transaction if computing a digest.
    end else if (PartInfo[part_idx].hw_digest && (base_sel_q == PartOffset)) begin
        otp_size_o = OtpSizeWidth'(unsigned'(ScrmblBlockWidth / OtpWidth - 1));
        addr_base = PartInfo[part_idx].offset;
    // 64bit transaction if the DAI address points to the partition's digest offset.
    end else if ((PartInfo[part_idx].hw_digest || PartInfo[part_idx].sw_digest) &&
        (base_sel_q == DaiOffset) &&
        ({dai_addr_i[OtpByteAddrWidth-1:3], 2'b0} == digest_addr_lut[part_idx])) begin
      otp_size_o = OtpSizeWidth'(unsigned'(ScrmblBlockWidth / OtpWidth - 1));
      addr_base = {dai_addr_i[OtpByteAddrWidth-1:3], 3'h0};
    end
  end

  // Address counter - this is only used for computing a digest, hence the increment is
  // fixed to 8 byte.
  // SEC_CM: DAI.CTR.REDUN
  prim_count #(
    .Width(CntWidth)
  ) u_prim_count (
    .clk_i,
    .rst_ni,
    .clr_i(cnt_clr),
    .set_i(1'b0),
    .set_cnt_i('0),
    .incr_en_i(cnt_en),
    .decr_en_i(1'b0),
    .step_i(CntWidth'(1)),
    .commit_i(1'b1),
    .cnt_o(cnt),
    .cnt_after_commit_o(),
    .err_o(cnt_err)
  );

  // Note that OTP works on halfword (16bit) addresses, hence need to
  // shift the addresses appropriately.
  logic [OtpByteAddrWidth-1:0] addr_calc;
  assign addr_calc = {cnt, {$clog2(ScrmblBlockWidth/8){1'b0}}} + addr_base;
  assign otp_addr_o = OtpAddrWidth'(addr_calc >> OtpAddrShift);

  ///////////////
  // Registers //
  ///////////////

  `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, state_e, ResetSt)

  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs
    if (!rst_ni) begin
      error_q        <= NoError;
      data_q         <= '0;
      base_sel_q     <= DaiOffset;
      lock_cnt       <= '0;
    end else begin
      error_q        <= error_d;
      base_sel_q     <= base_sel_d;

      // Working register
      if (data_clr) begin
        data_q <= '0;
      end
      if (data_en) begin
        if (data_sel == ScrmblData) begin
          data_q <= scrmbl_data_i;
        end else if (data_sel == DaiData) begin
          data_q <= dai_wdata_i;
        end else begin
          data_q <= otp_rdata_i;
        end
      end
      if(otp_access_grant) begin
        if(lock_cnt != Predictor_Mask) begin
          lock_cnt <= lock_cnt + 1;
        end
      end
    end
  end

  ////////////////
  // Assertions //
  ////////////////

  // Known assertions
  `ASSERT_KNOWN(InitDoneKnown_A,     init_done_o)
  `ASSERT_KNOWN(PartInitReqKnown_A,  part_init_req_o)
  `ASSERT_KNOWN(ErrorKnown_A,        error_o)
  `ASSERT_KNOWN(DaiIdleKnown_A,      dai_idle_o)
  `ASSERT_KNOWN(DaiRdataKnown_A,     dai_rdata_o)
  `ASSERT_KNOWN(OtpReqKnown_A,       otp_req_o)
  `ASSERT_KNOWN(OtpCmdKnown_A,       otp_cmd_o)
  `ASSERT_KNOWN(OtpSizeKnown_A,      otp_size_o)
  `ASSERT_KNOWN(OtpWdataKnown_A,     otp_wdata_o)
  `ASSERT_KNOWN(OtpAddrKnown_A,      otp_addr_o)
  `ASSERT_KNOWN(ScrmblMtxReqKnown_A, scrmbl_mtx_req_o)
  `ASSERT_KNOWN(ScrmblCmdKnown_A,    scrmbl_cmd_o)
  `ASSERT_KNOWN(ScrmblModeKnown_A,   scrmbl_mode_o)
  `ASSERT_KNOWN(ScrmblSelKnown_A,    scrmbl_sel_o)
  `ASSERT_KNOWN(ScrmblDataKnown_A,   scrmbl_data_o)
  `ASSERT_KNOWN(ScrmblValidKnown_A,  scrmbl_valid_o)

  // OTP error response
  `ASSERT(OtpErrorState_A,
      state_q inside {InitOtpSt, ReadWaitSt, WriteWaitSt, DigReadWaitSt} && otp_rvalid_i &&
      !(otp_err inside {NoError, MacroEccCorrError, MacroWriteBlankError})
      |=>
      state_q == ErrorSt && error_o == $past(otp_err))

endmodule : otp_ctrl_dai


    '''

    Identify relevant lint tags for the RTL to be checked for.
    Then run the tests using the linting tool.
    From the output of the linting tool, determine if there are security issues in the RTL.
================================== Ai Message ==================================
Tool Calls:
  retrieve_relevant_lint_tags (call_4Rgg8B75TAFBCKLb617INbKU)
 Call ID: call_4Rgg8B75TAFBCKLb617INbKU
  Args:
    query: direct access interface security partition locking error handling
================================= Tool Message =================================
Name: retrieve_relevant_lint_tags


W210: Number of connections made to an instance does not match number of ports on master 


W215: Reports inappropriate bit-selects of integer or time variables 


W336L: Blocking assignment to latch output should be avoided 


STARC05-1.4.3.1b: Clocks should not be gated 


STARC05-1.3.2.1a: Asynchronous resets or sets must not be gated 


STARC05-2.10.5.3b: Reports violation when there are three or more arithmetic operations in Always block 


STARC05-2.4.1.4: Avoid combinational loops that contain latches 


sim_race07: Non-blocking assignment should not be used in clock or enable path 

PortOrder_A: Ports not declared in recommended order


SafeLatch-ML: Identifies the unsafe latch triplets 


sim_race06: Flip-flop data path should not be entirely blocking


STARC05-1.2.1.1a: Design should use only one edge of a clock 

W280: A delay has been specified in a nonblocking assignment


STARC05-2.1.10.9: Access type should not be used in the design. (VHDL)

W188: Do not write to input ports

W240: An input has been declared but is not read


STARC05-1.3.1.2: Do not use synchronous reset in the design 


STARC05-2.1.9.5: Do not use user-defined attributes in the design 


STARC05-2.2.1.2: Design should not have latches


STARC05-2.4.1.5: Do not use two level latches in the same phase clock 
================================== Ai Message ==================================
Tool Calls:
  lint_checker_tool (call_fNz3aFb02mPiFBQgiMZhjmJa)
 Call ID: call_fNz3aFb02mPiFBQgiMZhjmJa
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_dai.sv
    top_module: otp_ctrl_dai
    lint_tags: ['STARC05-1.4.3.1b', 'STARC05-1.3.2.1a', 'STARC05-2.10.5.3b', 'STARC05-2.4.1.4', 'sim_race07', 'SafeLatch-ML', 'sim_race06', 'STARC05-1.2.1.1a', 'W280', 'W188', 'W240', 'STARC05-1.3.1.2', 'STARC05-2.1.9.5', 'STARC05-2.2.1.2', 'STARC05-2.4.1.5']
================================= Tool Message =================================
Name: lint_checker_tool

Successfully executed:
```lint checker tool
```
Output: 
  -----------------------------------------------------------------------------
  Report Summary
  -----------------------------------------------------------------------------
  Product Info
    Name    : VC Static Master Shell
    Version : U-2023.03-1 -- Apr 17, 2023

  Report Info
    Created : May 06, 2025  17:16:34

    TopLevelModule: otp_ctrl_dai

  -----------------------------------------------------------------------------
  Management Summary
  -----------------------------------------------------------------------------
  Stage           Family      Fatals    Errors  Warnings     Infos
  -----           --------  --------  --------  --------  --------
  LANGUAGE_CHECK  CODING           0         2         0         0
  -----           --------  --------  --------  --------  --------
  Total                            0         2         0         0


  -----------------------------------------------------------------------------
  Tree Summary
  -----------------------------------------------------------------------------
  Severity  Stage           Tag     Count
  --------  -----           ------  -----
  error     LANGUAGE_CHECK  W240        2
  --------  -----           ------  -----
  Total                                 2



  -----------------------------------------------------------------------------
  W240  (2 errors/0 waived)
  -----------------------------------------------------------------------------
  Tag           : W240
  Description   : Input '[Signal]' declared but not read.[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:1
  Module        : prim_arbiter_fixed
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_arbiter_0/rtl/prim_arbiter_fixed.sv
  LineNumber    : 28
  Statement     :   input clk_i,
  Signal        : clk_i
  HIERARCHY     : :otp_ctrl_dai:u_part_sel_idx@prim_arbiter_fixed
  -----------------------------------------------------------------------------
  Tag           : W240
  Description   : Input '[Signal]' declared but not read.[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:2
  Module        : prim_arbiter_fixed
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_arbiter_0/rtl/prim_arbiter_fixed.sv
  LineNumber    : 29
  Statement     :   input rst_ni,
  Signal        : rst_ni
  HIERARCHY     : :otp_ctrl_dai:u_part_sel_idx@prim_arbiter_fixed

================================== Ai Message ==================================

The lint check on the module otp_ctrl_dai for security concerns related to direct access interface security, partition locking, and error handling reported the following:

- There are 2 errors of type W240: "Input declared but not read" in the submodule prim_arbiter_fixed instance u_part_sel_idx. The inputs clk_i and rst_ni are declared but not read in that module.

No other errors or warnings related to the queried security concerns were reported by the lint tool.

Summary:
- No direct security issues were flagged in the otp_ctrl_dai module itself regarding direct access interface security, partition locking, or error handling.
- The only issues found are in a submodule prim_arbiter_fixed where clock and reset inputs are declared but not used, which might be a coding issue but not necessarily a security vulnerability.

Based on this lint check, there are no explicit security issues detected in the provided RTL code related to the requested concerns. However, the unused inputs in the submodule could be reviewed for correctness.
================================= Tool Message =================================
Name: run_linter_agent

The lint check on the module otp_ctrl_dai for security concerns related to direct access interface security, partition locking, and error handling reported the following:

- There are 2 errors of type W240: "Input declared but not read" in the submodule prim_arbiter_fixed instance u_part_sel_idx. The inputs clk_i and rst_ni are declared but not read in that module.

No other errors or warnings related to the queried security concerns were reported by the lint tool.

Summary:
- No direct security issues were flagged in the otp_ctrl_dai module itself regarding direct access interface security, partition locking, or error handling.
- The only issues found are in a submodule prim_arbiter_fixed where clock and reset inputs are declared but not used, which might be a coding issue but not necessarily a security vulnerability.

Based on this lint check, there are no explicit security issues detected in the provided RTL code related to the requested concerns. However, the unused inputs in the submodule could be reviewed for correctness.
================================== Ai Message ==================================
Tool Calls:
  run_linter_agent (call_UO31PSyr5k4TYhkJ2fT4YT2K)
 Call ID: call_UO31PSyr5k4TYhkJ2fT4YT2K
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv
    top_module: otp_ctrl_part_buf
    security_objective: partition integrity, ECC, and error state handling
================================ Human Message =================================

Are there security concerns related to partition integrity, ECC, and error state handling in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv

    And the top module is:

    otp_ctrl_part_buf

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Buffered partition for OTP controller.
//

`include "prim_flop_macros.sv"

module otp_ctrl_part_buf
  import otp_ctrl_pkg::*;
  import otp_ctrl_reg_pkg::*;
  import otp_ctrl_part_pkg::*;
#(
  // Partition information.
  parameter part_info_t             Info = PartInfoDefault,
  parameter logic [Info.size*8-1:0] DataDefault = '0
) (
  input                               clk_i,
  input                               rst_ni,
  // Pulse to start partition initialisation (required once per power cycle).
  input                               init_req_i,
  output logic                        init_done_o,
  // Integrity check requests
  input                               integ_chk_req_i,
  output logic                        integ_chk_ack_o,
  // Consistency check requests
  input                               cnsty_chk_req_i,
  output logic                        cnsty_chk_ack_o,
  // Escalation input. This moves the FSM into a terminal state and locks down
  // the partition.
  input  lc_ctrl_pkg::lc_tx_t         escalate_en_i,
  // Check bypass enable. This bypasses integrity and consistency checks and
  // acknowledges all incoming check requests (only used by life cycle).
  input  lc_ctrl_pkg::lc_tx_t         check_byp_en_i,
  // Output error state of partition, to be consumed by OTP error/alert logic.
  // Note that most errors are not recoverable and move the partition FSM into
  // a terminal error state.
  output otp_err_e                    error_o,
  // This error signal is pulsed high if the FSM has been glitched into an invalid state.
  // Although it is somewhat redundant with the error code in error_o above, it is
  // meant to cover cases where we already latched an error code while the FSM is
  // glitched into an invalid state (since in that case, the error code will not be
  // overridden with the FSM error code so that the original error code is still
  // discoverable).
  output logic                        fsm_err_o,
  // Access/lock status
  // SEC_CM: ACCESS.CTRL.MUBI
  input  part_access_t                access_i, // runtime lock from CSRs
  output part_access_t                access_o,
  // Buffered 64bit digest output.
  output logic [ScrmblBlockWidth-1:0] digest_o,
  output logic [Info.size*8-1:0]      data_o,
  // OTP interface
  output logic                        otp_req_o,
  output prim_otp_pkg::cmd_e          otp_cmd_o,
  output logic [OtpSizeWidth-1:0]     otp_size_o,
  output logic [OtpIfWidth-1:0]       otp_wdata_o,
  output logic [OtpAddrWidth-1:0]     otp_addr_o,
  input                               otp_gnt_i,
  input                               otp_rvalid_i,
  input  [ScrmblBlockWidth-1:0]       otp_rdata_i,
  input  prim_otp_pkg::err_e          otp_err_i,
  // Scrambling mutex request
  output logic                        scrmbl_mtx_req_o,
  input                               scrmbl_mtx_gnt_i,
  // Scrambling datapath interface
  output otp_scrmbl_cmd_e             scrmbl_cmd_o,
  output digest_mode_e                scrmbl_mode_o,
  output logic [ConstSelWidth-1:0]    scrmbl_sel_o,
  output logic [ScrmblBlockWidth-1:0] scrmbl_data_o,
  output logic                        scrmbl_valid_o,
  input  logic                        scrmbl_ready_i,
  input  logic                        scrmbl_valid_i,
  input  logic [ScrmblBlockWidth-1:0] scrmbl_data_i
);

  ////////////////////////
  // Integration Checks //
  ////////////////////////

  import prim_mubi_pkg::*;
  import prim_util_pkg::vbits;

  localparam int unsigned DigestOffsetInt = (int'(Info.offset) +
                                             int'(Info.size) - ScrmblBlockWidth/8);
  localparam int NumScrmblBlocks = int'(Info.size) / (ScrmblBlockWidth/8);
  localparam int CntWidth = vbits(NumScrmblBlocks);

  localparam bit [OtpByteAddrWidth-1:0] DigestOffset = DigestOffsetInt[OtpByteAddrWidth-1:0];

  localparam int unsigned LastScrmblBlockInt = NumScrmblBlocks - 1;
  localparam int unsigned PenultimateScrmblBlockInt = NumScrmblBlocks - 2;
  localparam bit [CntWidth-1:0] LastScrmblBlock = LastScrmblBlockInt[CntWidth-1:0];
  localparam bit [CntWidth-1:0] PenultimateScrmblBlock = PenultimateScrmblBlockInt[CntWidth-1:0];

  // Integration checks for parameters.
  `ASSERT_INIT(OffsetMustBeBlockAligned_A, (Info.offset % (ScrmblBlockWidth/8)) == 0)
  `ASSERT_INIT(SizeMustBeBlockAligned_A, (Info.size % (ScrmblBlockWidth/8)) == 0)
  `ASSERT_INIT(DigestOffsetMustBeRepresentable_A, DigestOffsetInt == int'(DigestOffset))
  `ASSERT(ScrambledImpliesDigest_A, Info.secret |-> Info.hw_digest)
  `ASSERT(WriteLockImpliesDigest_A, Info.read_lock |-> Info.hw_digest)
  `ASSERT(ReadLockImpliesDigest_A, Info.write_lock |-> Info.hw_digest)

  // This feature is only supposed to be used with partitions that are not scrambled
  // and that do not have a digest.
  `ASSERT(BypassEnable0_A, Info.secret    |-> lc_ctrl_pkg::lc_tx_test_false_strict(check_byp_en_i))
  `ASSERT(BypassEnable1_A, Info.hw_digest |-> lc_ctrl_pkg::lc_tx_test_false_strict(check_byp_en_i))

  ///////////////////////
  // OTP Partition FSM //
  ///////////////////////

  // SEC_CM: PART.FSM.SPARSE
  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 5 -m 16 -n 12 \
  //      -s 3370657881 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: --
  //  4: --
  //  5: |||||||||||||| (28.33%)
  //  6: |||||||||||||||||||| (38.33%)
  //  7: |||||||||| (19.17%)
  //  8: ||| (5.83%)
  //  9: || (4.17%)
  // 10: | (2.50%)
  // 11:  (0.83%)
  // 12:  (0.83%)
  //
  // Minimum Hamming distance: 5
  // Maximum Hamming distance: 12
  // Minimum Hamming weight: 4
  // Maximum Hamming weight: 8
  //
  localparam int StateWidth = 12;
  typedef enum logic [StateWidth-1:0] {
    ResetSt         = 12'b011000001110,
    InitSt          = 12'b110100100111,
    InitWaitSt      = 12'b001110110001,
    InitDescrSt     = 12'b110010000100,
    InitDescrWaitSt = 12'b100110101000,
    IdleSt          = 12'b010101001101,
    IntegScrSt      = 12'b110101011010,
    IntegScrWaitSt  = 12'b100010011111,
    IntegDigClrSt   = 12'b101001000001,
    IntegDigSt      = 12'b011101100010,
    IntegDigPadSt   = 12'b001101010111,
    IntegDigFinSt   = 12'b011011100101,
    IntegDigWaitSt  = 12'b100011110010,
    CnstyReadSt     = 12'b000001101011,
    CnstyReadWaitSt = 12'b101001111100,
    ErrorSt         = 12'b010110111110
  } state_e;

  typedef enum logic {
    ScrmblData,
    OtpData
  } data_sel_e;

  typedef enum logic {
    PartOffset,
    DigOffset
  } base_sel_e;

  state_e state_d, state_q;
  otp_err_e error_d, error_q;
  data_sel_e data_sel;
  base_sel_e base_sel;
  mubi8_t dout_locked_d, dout_locked_q;
  logic [CntWidth-1:0] cnt;
  logic cnt_en, cnt_clr, cnt_err;
  logic ecc_err;
  logic buffer_reg_en;
  logic [ScrmblBlockWidth-1:0] data_mux;

  // Output partition error state.
  assign error_o = error_q;

  // This partition cannot do any write accesses, hence we tie this
  // constantly off.
  assign otp_wdata_o = '0;
  // Depending on the partition configuration, the wrapper is instructed to ignore integrity
  // calculations and checks. To be on the safe side, the partition filters error responses at this
  // point and does not report any integrity errors if integrity is disabled.
  otp_err_e otp_err;
  if (Info.integrity) begin : gen_integrity
    assign otp_cmd_o = prim_otp_pkg::Read;
    assign otp_err = otp_err_e'(otp_err_i);
  end else begin : gen_no_integrity
    assign otp_cmd_o = prim_otp_pkg::ReadRaw;
    always_comb begin
      if (otp_err_e'(otp_err_i) inside {MacroEccCorrError, MacroEccUncorrError}) begin
        otp_err = NoError;
      end else begin
        otp_err = otp_err_e'(otp_err_i);
      end
    end
  end

  always_comb begin : p_fsm
    state_d = state_q;

    // Redundantly encoded lock signal for buffer regs.
    dout_locked_d = dout_locked_q;

    // OTP signals
    otp_req_o = 1'b0;

    // Scrambling mutex
    scrmbl_mtx_req_o = 1'b0;

    // Scrambling datapath
    scrmbl_cmd_o   = LoadShadow;
    scrmbl_sel_o   = CnstyDigest;
    scrmbl_mode_o  = StandardMode;
    scrmbl_valid_o = 1'b0;

    // Counter
    cnt_en   = 1'b0;
    cnt_clr  = 1'b0;
    base_sel = PartOffset;

    // Buffer register
    buffer_reg_en = 1'b0;
    data_sel = OtpData;

    // Error Register
    error_d = error_q;
    fsm_err_o = 1'b0;

    // Integrity/Consistency check responses
    cnsty_chk_ack_o = 1'b0;
    integ_chk_ack_o = 1'b0;

    unique case (state_q)
      ///////////////////////////////////////////////////////////////////
      // State right after reset. Wait here until we get a an
      // initialization request.
      ResetSt: begin
        if (init_req_i) begin
          state_d = InitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Initialization reads out the digest only in unbuffered
      // partitions. Wait here until the OTP request has been granted.
      // And then wait until the OTP word comes back.
      InitSt: begin
        otp_req_o = 1'b1;
        if (otp_gnt_i) begin
          state_d = InitWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for OTP response and write to buffer register, then go to
      // descrambling state. In case an OTP transaction fails, latch the
      // OTP error code and jump to a
      // terminal error state.
      InitWaitSt: begin
        if (otp_rvalid_i) begin
          buffer_reg_en = 1'b1;
          if (otp_err inside {NoError, MacroEccCorrError}) begin
            // Once we've read and descrambled the whole partition, we can go to integrity
            // verification. Note that the last block is the digest value, which does not
            // have to be descrambled.
            if (cnt == LastScrmblBlock) begin
              state_d = IntegDigClrSt;
            // Only need to descramble if this is a scrambled partition.
            // Otherwise, we can just go back to InitSt and read the next block.
            end else if (Info.secret) begin
              state_d = InitDescrSt;
            end else begin
              state_d = InitSt;
              cnt_en = 1'b1;
            end
            // At this point the only error that we could have gotten are correctable ECC errors.
            if (otp_err != NoError) begin
              error_d = MacroEccCorrError;
            end
          end else begin
            state_d = ErrorSt;
            error_d = otp_err;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Descrambling state. This first acquires the scrambling
      // datapath mutex. Note that once the mutex is acquired, we have
      // exclusive access to the scrambling datapath until we release
      // the mutex by deasserting scrmbl_mtx_req_o.
      // SEC_CM: SECRET.MEM.SCRAMBLE
      InitDescrSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        scrmbl_cmd_o = Decrypt;
        scrmbl_sel_o = Info.key_sel;
        if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
          state_d = InitDescrWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for the descrambled data to return. Note that we release
      // the mutex lock upon leaving this state.
      // SEC_CM: SECRET.MEM.SCRAMBLE
      InitDescrWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_sel_o = Info.key_sel;
        data_sel = ScrmblData;
        if (scrmbl_valid_i) begin
          state_d = InitSt;
          buffer_reg_en = 1'b1;
          cnt_en = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Idle state. We basically wait for integrity and consistency check
      // triggers in this state.
      IdleSt: begin
        if (integ_chk_req_i) begin
          if (Info.hw_digest) begin
            state_d = IntegDigClrSt;
          // In case there is nothing to check we can just
          // acknowledge the request right away, without going to the
          // integrity check.
          end else begin
            integ_chk_ack_o = 1'b1;
          end
        end else if (cnsty_chk_req_i) begin
          state_d = CnstyReadSt;
          cnt_clr = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Read the digest. Wait here until the OTP request has been granted.
      // And then wait until the OTP word comes back.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      CnstyReadSt: begin
        otp_req_o = 1'b1;
        // In case this partition has a hardware digest, we only have to read
        // and compare the digest value. In that case we select the digest offset here.
        // Otherwise we have to read and compare the whole partition, in which case we
        // select the partition offset, which is the default assignment of base_sel.
        if (Info.hw_digest) begin
          base_sel = DigOffset;
        end
        if (otp_gnt_i) begin
          state_d = CnstyReadWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for OTP response and compare the digest. In case there is
      // a mismatch, lock down the partition and go into the terminal error
      // state. In case an OTP transaction fails, latch the OTP error code
      // and jump to a terminal error state.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      CnstyReadWaitSt: begin
        if (otp_rvalid_i) begin
          if (otp_err inside {NoError, MacroEccCorrError}) begin
            // Check whether we need to compare the digest or the full partition
            // contents here.
            if (Info.hw_digest) begin
              // Note that we ignore this check if the digest is still blank.
              if (digest_o == data_mux || digest_o == '0) begin
                state_d = IdleSt;
                cnsty_chk_ack_o = 1'b1;
              // Error out and lock the partition if this check fails.
              end else begin
                state_d = ErrorSt;
                error_d = CheckFailError;
                // The check has finished and found an error.
                cnsty_chk_ack_o = 1'b1;
              end
            end else begin
              // Check whether the read data corresponds with the data buffered in regs.
              // Note that this particular check can be bypassed in case a transition is ongoing.
              if (scrmbl_data_o == data_mux ||
                  lc_ctrl_pkg::lc_tx_test_true_strict(check_byp_en_i)) begin
                // Can go back to idle and acknowledge the
                // request if this is the last block.
                if (cnt == LastScrmblBlock) begin
                  state_d = IdleSt;
                  cnsty_chk_ack_o = 1'b1;
                // Need to go back and read out more blocks.
                end else begin
                  state_d = CnstyReadSt;
                  cnt_en = 1'b1;
                end
              end else begin
                state_d = ErrorSt;
                error_d = CheckFailError;
                // The check has finished and found an error.
                cnsty_chk_ack_o = 1'b1;
              end
            end
            // At this point the only error that we could have gotten are correctable ECC errors.
            if (otp_err != NoError) begin
              error_d = MacroEccCorrError;
            end
          end else begin
            state_d = ErrorSt;
            error_d = otp_err;
            // The check has finished and found an error.
            cnsty_chk_ack_o = 1'b1;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // First, acquire the mutex for the digest and clear the digest state.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigClrSt: begin
        // Check whether this partition requires checking at all.
        if (Info.hw_digest) begin
          scrmbl_mtx_req_o = 1'b1;
          scrmbl_valid_o = 1'b1;
          cnt_clr = 1'b1;
          // Need to reset the digest state and set it to chained
          // mode if this partition is scrambled.
          scrmbl_cmd_o = DigestInit;
          if (Info.secret) begin
            scrmbl_mode_o = ChainedMode;
            if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
              state_d = IntegScrSt;
            end
          // If this partition is not scrambled, we can just directly
          // jump to the digest state.
          end else begin
            scrmbl_mode_o = StandardMode;
            if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
              state_d = IntegDigSt;
            end
          end
        // Otherwise, if this partition is not digest protected,
        // we can just go to idle, since there is nothing to check.
        // Note that we do not come back to this state in case there is no
        // digest, and hence it is safe to unlock the buffer regs at this point.
        // This is the only way the buffer regs can get unlocked.
        end else begin
          state_d = IdleSt;
          if (mubi8_test_true_strict(dout_locked_q)) begin
            dout_locked_d = MuBi8False;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Scramble buffered data (which is held in plaintext form).
      // This moves the previous scrambling result into the shadow reg
      // for later use.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegScrSt: begin
          scrmbl_mtx_req_o = 1'b1;
          scrmbl_valid_o = 1'b1;
          scrmbl_cmd_o = Encrypt;
          scrmbl_sel_o = Info.key_sel;
          if (scrmbl_ready_i) begin
            state_d = IntegScrWaitSt;
          end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for the scrambled data to return.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegScrWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_sel_o = Info.key_sel;
        if (scrmbl_valid_i) begin
          state_d = IntegDigSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Push the word read into the scrambling datapath. The last
      // block is repeated in case the number blocks in this partition
      // is odd.
      // SEC_CM: PART.MEM.DIGEST
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        if (scrmbl_ready_i) begin
          cnt_en = 1'b1;
          // No need to digest the digest value itself
          if (cnt == PenultimateScrmblBlock) begin
            // Note that the digest operates on 128bit blocks since the data is fed in via the
            // PRESENT key input. Therefore, we only trigger a digest update on every second
            // 64bit block that is pushed into the scrambling datapath.
            if (cnt[0]) begin
              scrmbl_cmd_o = Digest;
              state_d = IntegDigFinSt;
            end else begin
              state_d = IntegDigPadSt;
              cnt_en = 1'b0;
            end
          end else begin
            // Trigger digest round in case this is the second block in a row.
            if (cnt[0]) begin
              scrmbl_cmd_o = Digest;
            end
            // Go back and scramble the next data block if this is
            // a scrambled partition. Otherwise just stay here.
            if (Info.secret) begin
              state_d = IntegScrSt;
            end
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Padding state. When we get here, we've copied the last encryption
      // result into the shadow register such that we've effectively
      // repeated the last block twice in order to pad the data to 128bit.
      // SEC_CM: PART.MEM.DIGEST
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigPadSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        scrmbl_cmd_o = Digest;
        if (scrmbl_ready_i) begin
          state_d = IntegDigFinSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Trigger digest finalization and go wait for the result.
      // SEC_CM: PART.MEM.DIGEST
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigFinSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        scrmbl_cmd_o = DigestFinalize;
        if (scrmbl_ready_i) begin
          state_d = IntegDigWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for the digest to return, and double check whether the digest
      // matches. If yes, unlock the partition. Otherwise, go into the terminal
      // error state, where the partition will be locked down.
      // SEC_CM: PART.MEM.DIGEST
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        data_sel = ScrmblData;
        if (scrmbl_valid_i) begin
          // This is the only way the buffer regs can get unlocked.
          // Note that we ignore this check if the digest is still blank.
          if (digest_o == data_mux || digest_o == '0) begin
            state_d = IdleSt;
            // If the partition is still locked, this is the first integrity check after
            // initialization. This is the only way the buffer regs can get unlocked.
            if (mubi8_test_true_strict(dout_locked_q)) begin
              dout_locked_d = MuBi8False;
            // Otherwise, this integrity check has requested by the LFSR timer, and we have
            // to acknowledge its completion.
            end else begin
              integ_chk_ack_o = 1'b1;
            end
          // Error out and lock the partition if this check fails.
          end else begin
            state_d = ErrorSt;
            error_d = CheckFailError;
            // The check has finished and found an error.
            integ_chk_ack_o = 1'b1;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Terminal Error State. This locks access to the partition.
      // Make sure the partition signals an error state if no error
      // code has been latched so far, and lock the buffer regs down.
      ErrorSt: begin
        dout_locked_d = MuBi8True;
        if (error_q == NoError) begin
          error_d = FsmStateError;
        end
        // If we are in error state, we cannot execute the checks anymore.
        // Hence the acknowledgements are returned immediately.
        cnsty_chk_ack_o = 1'b1;
        integ_chk_ack_o = 1'b1;
      end
      ///////////////////////////////////////////////////////////////////
      // We should never get here. If we do (e.g. via a malicious
      // glitch), error out immediately.
      default: begin
        state_d = ErrorSt;
        fsm_err_o = 1'b1;
      end
      ///////////////////////////////////////////////////////////////////
    endcase // state_q


    // Unconditionally jump into the terminal error state in case of
    // an ECC error or escalation, and lock access to the partition down.
    // SEC_CM: PART.FSM.LOCAL_ESC
    if (ecc_err) begin
      state_d = ErrorSt;
      if (state_q != ErrorSt) begin
        error_d = CheckFailError;
      end
    end
    // SEC_CM: PART.FSM.LOCAL_ESC, PART.FSM.GLOBAL_ESC
    if (lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) || cnt_err) begin
      state_d = ErrorSt;
      fsm_err_o = 1'b1;
      if (state_q != ErrorSt) begin
        error_d = FsmStateError;
      end
    end
  end

  ////////////////////////////
  // Address Calc and Muxes //
  ////////////////////////////

  // Address counter - this is only used for computing a digest, hence the increment is
  // fixed to 8 byte.
  // SEC_CM: PART.CTR.REDUN
  prim_count #(
    .Width(CntWidth)
  ) u_prim_count (
    .clk_i,
    .rst_ni,
    .clr_i(cnt_clr),
    .set_i(1'b0),
    .set_cnt_i('0),
    .incr_en_i(cnt_en),
    .decr_en_i(1'b0),
    .step_i(CntWidth'(1)),
    .commit_i(1'b1),
    .cnt_o(cnt),
    .cnt_after_commit_o(),
    .err_o(cnt_err)
  );

  logic [OtpByteAddrWidth-1:0] addr_base;
  assign addr_base = (base_sel == DigOffset) ? DigestOffset : Info.offset;

  // Note that OTP works on halfword (16bit) addresses, hence need to
  // shift the addresses appropriately.
  logic [OtpByteAddrWidth-1:0] addr_calc;
  assign addr_calc = OtpByteAddrWidth'({cnt, {$clog2(ScrmblBlockWidth/8){1'b0}}}) + addr_base;
  assign otp_addr_o = addr_calc[OtpByteAddrWidth-1:OtpAddrShift];

  if (OtpAddrShift > 0) begin : gen_unused
    logic unused_bits;
    assign unused_bits = ^addr_calc[OtpAddrShift-1:0];
  end

  // Always transfer 64bit blocks.
  assign otp_size_o = OtpSizeWidth'(unsigned'(ScrmblBlockWidth / OtpWidth) - 1);

  assign data_mux = (data_sel == ScrmblData) ? scrmbl_data_i : otp_rdata_i;

  /////////////////
  // Buffer Regs //
  /////////////////

  // SEC_CM: PART.DATA_REG.INTEGRITY
  logic [Info.size*8-1:0] data;
  otp_ctrl_ecc_reg #(
    .Width ( ScrmblBlockWidth ),
    .Depth ( NumScrmblBlocks  )
  ) u_otp_ctrl_ecc_reg (
    .clk_i,
    .rst_ni,
    .wren_i    ( buffer_reg_en ),
    .addr_i    ( cnt           ),
    .wdata_i   ( data_mux      ),
    .rdata_o   ( scrmbl_data_o ),
    .data_o    ( data          ),
    .ecc_err_o ( ecc_err       )
  );

  // We have successfully initialized the partition once it has been unlocked.
  assign init_done_o = mubi8_test_false_strict(dout_locked_q);
  // Hardware output gating.
  // Note that this is decoupled from the DAI access rules further below.
  assign data_o = data;
  // The digest does not have to be gated.
  assign digest_o = data[$high(data_o) -: ScrmblBlockWidth];

  ////////////////////////
  // DAI Access Control //
  ////////////////////////

  // Aggregate all possible DAI write /readlocks. The partition is also locked when uninitialized.
  // Note that the locks are redundantly encoded values.
  part_access_t access_pre;
  prim_mubi8_sender #(
    .AsyncOn(0)
  ) u_prim_mubi8_sender_write_lock_pre (
    .clk_i,
    .rst_ni,
    .mubi_i(mubi8_and_lo(dout_locked_q, access_i.write_lock)),
    .mubi_o(access_pre.write_lock)
  );
  prim_mubi8_sender #(
    .AsyncOn(0)
  ) u_prim_mubi8_sender_read_lock_pre (
    .clk_i,
    .rst_ni,
    .mubi_i(mubi8_and_lo(dout_locked_q, access_i.read_lock)),
    .mubi_o(access_pre.read_lock)
  );

  // SEC_CM: PART.MEM.SW_UNWRITABLE
  if (Info.write_lock) begin : gen_digest_write_lock
    mubi8_t digest_locked;
    assign digest_locked = (digest_o != '0) ? MuBi8True : MuBi8False;

    // This prevents the synthesis tool from optimizing the multibit signal.
    prim_mubi8_sender #(
      .AsyncOn(0)
    ) u_prim_mubi8_sender_write_lock (
      .clk_i,
      .rst_ni,
      .mubi_i(mubi8_and_lo(access_pre.write_lock, digest_locked)),
      .mubi_o(access_o.write_lock)
    );

    `ASSERT(DigestWriteLocksPartition_A, digest_o |-> mubi8_test_true_loose(access_o.write_lock))
  end else begin : gen_no_digest_write_lock
    assign access_o.write_lock = access_pre.write_lock;
  end

  // SEC_CM: PART.MEM.SW_UNREADABLE
  if (Info.read_lock) begin : gen_digest_read_lock
    mubi8_t digest_locked;
    assign digest_locked = (digest_o != '0) ? MuBi8True : MuBi8False;

    // This prevents the synthesis tool from optimizing the multibit signal.
    prim_mubi8_sender #(
      .AsyncOn(0)
    ) u_prim_mubi8_sender_read_lock (
      .clk_i,
      .rst_ni,
      .mubi_i(mubi8_and_lo(access_pre.read_lock, digest_locked)),
      .mubi_o(access_o.read_lock)
    );

    `ASSERT(DigestReadLocksPartition_A, digest_o |-> mubi8_test_true_loose(access_o.read_lock))
  end else begin : gen_no_digest_read_lock
    assign access_o.read_lock = access_pre.read_lock;
  end

  ///////////////
  // Registers //
  ///////////////

  `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, state_e, ResetSt)

  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs
    if (!rst_ni) begin
      error_q       <= NoError;
      // data output is locked by default
      dout_locked_q <= MuBi8True;
    end else begin
      error_q       <= error_d;
      dout_locked_q <= dout_locked_d;
    end
  end

  ////////////////
  // Assertions //
  ////////////////

  // Known assertions
  `ASSERT_KNOWN(InitDoneKnown_A,     init_done_o)
  `ASSERT_KNOWN(IntegChkAckKnown_A,  integ_chk_ack_o)
  `ASSERT_KNOWN(CnstyChkAckKnown_A,  cnsty_chk_ack_o)
  `ASSERT_KNOWN(ErrorKnown_A,        error_o)
  `ASSERT_KNOWN(AccessKnown_A,       access_o)
  `ASSERT_KNOWN(DigestKnown_A,       digest_o)
  `ASSERT_KNOWN(DataKnown_A,         data_o)
  `ASSERT_KNOWN(OtpReqKnown_A,       otp_req_o)
  `ASSERT_KNOWN(OtpCmdKnown_A,       otp_cmd_o)
  `ASSERT_KNOWN(OtpSizeKnown_A,      otp_size_o)
  `ASSERT_KNOWN(OtpWdataKnown_A,     otp_wdata_o)
  `ASSERT_KNOWN(OtpAddrKnown_A,      otp_addr_o)
  `ASSERT_KNOWN(ScrmblMtxReqKnown_A, scrmbl_mtx_req_o)
  `ASSERT_KNOWN(ScrmblCmdKnown_A,    scrmbl_cmd_o)
  `ASSERT_KNOWN(ScrmblModeKnown_A,   scrmbl_mode_o)
  `ASSERT_KNOWN(ScrmblSelKnown_A,    scrmbl_sel_o)
  `ASSERT_KNOWN(ScrmblDataKnown_A,   scrmbl_data_o)
  `ASSERT_KNOWN(ScrmblValidKnown_A,  scrmbl_valid_o)

  // Uninitialized partitions should always be locked, no matter what.
  `ASSERT(InitWriteLocksPartition_A,
      mubi8_test_true_loose(dout_locked_q)
      |->
      mubi8_test_true_loose(access_o.write_lock))
  `ASSERT(InitReadLocksPartition_A,
      mubi8_test_true_loose(dout_locked_q)
      |->
      mubi8_test_true_loose(access_o.read_lock))
  // Incoming Lock propagation
  `ASSERT(WriteLockPropagation_A,
      mubi8_test_true_loose(access_i.write_lock)
      |->
      mubi8_test_true_loose(access_o.write_lock))
  `ASSERT(ReadLockPropagation_A,
      mubi8_test_true_loose(access_i.read_lock)
      |->
      mubi8_test_true_loose(access_o.read_lock))
  // ECC error in buffer regs
  `ASSERT(EccErrorState_A,
      ecc_err
      |=>
      state_q == ErrorSt)
  // OTP error response
  `ASSERT(OtpErrorState_A,
      state_q inside {InitWaitSt, CnstyReadWaitSt} && otp_rvalid_i &&
      !(otp_err inside {NoError, MacroEccCorrError}) && !ecc_err
      |=>
      state_q == ErrorSt && error_o == $past(otp_err))

  // The partition size must be greater than one scrambling block for the address calculation
  // and muxing to work correctly.
  `ASSERT_INIT(OtpPartBufSize_A, Info.size > (ScrmblBlockWidth/8))

endmodule : otp_ctrl_part_buf

    '''

    Identify relevant lint tags for the RTL to be checked for.
    Then run the tests using the linting tool.
    From the output of the linting tool, determine if there are security issues in the RTL.
================================== Ai Message ==================================
Tool Calls:
  retrieve_relevant_lint_tags (call_x2jlkSsGCoFBReDvB69T45An)
 Call ID: call_x2jlkSsGCoFBReDvB69T45An
  Args:
    query: partition integrity ECC error state handling security
================================= Tool Message =================================
Name: retrieve_relevant_lint_tags


W215: Reports inappropriate bit-selects of integer or time variables 


STARC05-1.2.1.1a: Design should use only one edge of a clock 


STARC05-2.11.5.2: Do not assign state encoding by attaching attributes to the state variable which is declared as a type (VHDL) 


STARC05-1.3.2.1a: Asynchronous resets or sets must not be gated 


STARC05-2.10.5.3b: Reports violation when there are three or more arithmetic operations in Always block 


STARC05-1.4.3.1b: Clocks should not be gated 


STARC05-2.11.1.2: Bit change in state transition should be minimal (use Gray code). (Verilog)Bit change in FSM state transitions should be minimized (use Gray code). (VHDL) 


STARC05-2.11.1.4: Number of states in a FSM should not exceed specified limit


STARC05-2.3.1.7a: A flip-flop should not have two asynchronous resets 


STARC05-2.11.4.1: One-hot encoding should be used for allocating states


STARC05-1.3.1.2: Do not use synchronous reset in the design 


W450L: Reports multi-bit expression used as latch enable condition 


STARC05-1.4.3.6: Do not use Flip-Flops with inverted edges 


SepStateMachine: Combinational and sequential parts of a finite-state machine are combined in one process


W336L: Blocking assignment to latch output should be avoided 


STARC05-2.10.8.2: Keep the left side of the division or modulus operator within 12 bits


STARC05-2.4.1.4: Avoid combinational loops that contain latches 


W210: Number of connections made to an instance does not match number of ports on master 


W484: Possible loss of carry or borrow due to addition or subtraction 


STARC05-2.3.5.1: Flip-flops should not have fixed inputs 
================================== Ai Message ==================================
Tool Calls:
  lint_checker_tool (call_MpSW0F7Eue2CwTedXT6qLbgI)
 Call ID: call_MpSW0F7Eue2CwTedXT6qLbgI
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv
    top_module: otp_ctrl_part_buf
    lint_tags: ['STARC05-1.2.1.1a', 'STARC05-1.3.2.1a', 'STARC05-1.4.3.1b', 'STARC05-2.11.1.2', 'STARC05-2.11.1.4', 'STARC05-1.3.1.2', 'STARC05-1.4.3.6', 'SepStateMachine', 'STARC05-2.10.8.2', 'STARC05-2.3.5.1']
================================= Tool Message =================================
Name: lint_checker_tool

Successfully executed:
```lint checker tool
```
Output: 
  -----------------------------------------------------------------------------
  Report Summary
  -----------------------------------------------------------------------------
  Product Info
    Name    : VC Static Master Shell
    Version : U-2023.03-1 -- Apr 17, 2023

  Report Info
    Created : May 06, 2025  17:17:22

    TopLevelModule: otp_ctrl_part_buf

  -----------------------------------------------------------------------------
  Management Summary
  -----------------------------------------------------------------------------
  Stage           Family      Fatals    Errors  Warnings     Infos
  -----           --------  --------  --------  --------  --------
  LANGUAGE_CHECK  CODING           0         4         0         0
  -----           --------  --------  --------  --------  --------
  Total                            0         4         0         0


  -----------------------------------------------------------------------------
  Tree Summary
  -----------------------------------------------------------------------------
  Severity  Stage           Tag                 Count
  --------  -----           ------------------  -----
  error     LANGUAGE_CHECK  STARC05-2.10.8.2        4
  --------  -----           ------------------  -----
  Total                                             4



  -----------------------------------------------------------------------------
  STARC05-2.10.8.2  (4 errors/0 waived)
  -----------------------------------------------------------------------------
  Tag           : STARC05-2.10.8.2
  Description   : Width '[ExprSize]' of left side expression '[LHSExpr]' of [OpName] operator exceeds 12 bits[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:2
  Module        : otp_ctrl_part_buf
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_part_buf.sv
  LineNumber    : 87
  Statement     :   localparam int NumScrmblBlocks = int'(Info.size) / (ScrmblBlockWidth/8);
  ExprSize      : 32
  LHSExpr       : int'(Info.size)
  OpName        : division
  HIERARCHY     : :otp_ctrl_part_buf
  -----------------------------------------------------------------------------
  Tag           : STARC05-2.10.8.2
  Description   : Width '[ExprSize]' of left side expression '[LHSExpr]' of [OpName] operator exceeds 12 bits[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:1
  Module        : otp_ctrl_part_buf
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_part_buf.sv
  LineNumber    : 86
  Statement     :                                              int'(Info.size) - ScrmblBlockWidth/8);
  ExprSize      : 32
  LHSExpr       : ScrmblBlockWidth
  OpName        : division
  HIERARCHY     : :otp_ctrl_part_buf
  -----------------------------------------------------------------------------
  Tag           : STARC05-2.10.8.2
  Description   : Width '[ExprSize]' of left side expression '[LHSExpr]' of [OpName] operator exceeds 12 bits[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:3
  Module        : otp_ctrl_part_buf
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_part_buf.sv
  LineNumber    : 641
  Statement     :   assign addr_calc = OtpByteAddrWidth'({cnt, {$clog2(ScrmblBlockWidth/8){1'b0}}}) + addr_base;
  ExprSize      : 32
  LHSExpr       : ScrmblBlockWidth
  OpName        : division
  HIERARCHY     : :otp_ctrl_part_buf
  -----------------------------------------------------------------------------
  Tag           : STARC05-2.10.8.2
  Description   : Width '[ExprSize]' of left side expression '[LHSExpr]' of [OpName] operator exceeds 12 bits[Hierarchy: '[HIERARCHY]']
  Violation     : Lint:4
  Module        : otp_ctrl_part_buf
  FileName      : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_part_buf.sv
  LineNumber    : 650
  Statement     :   assign otp_size_o = OtpSizeWidth'(unsigned'(ScrmblBlockWidth / OtpWidth) - 1);
  ExprSize      : 32
  LHSExpr       : ScrmblBlockWidth
  OpName        : division
  HIERARCHY     : :otp_ctrl_part_buf

================================== Ai Message ==================================

The lint check was performed on the provided RTL code for the module otp_ctrl_part_buf with a focus on security concerns related to partition integrity, ECC, and error state handling.

The lint tool reported 4 errors, all related to the lint tag STARC05-2.10.8.2, which indicates that the width of the left side expression of a division operator exceeds 12 bits. Specifically, these errors occur in the following lines:

- Line 86: Expression involving int'(Info.size) - ScrmblBlockWidth/8
- Line 87: Expression involving int'(Info.size) / (ScrmblBlockWidth/8)
- Line 641: Expression involving {cnt, {$clog2(ScrmblBlockWidth/8){1'b0}}} + addr_base
- Line 650: Expression involving ScrmblBlockWidth / OtpWidth

These errors are related to arithmetic operations on wide signals, which might not be optimal or could cause synthesis or simulation issues, but they do not directly indicate a security vulnerability.

No other lint errors or warnings related to security issues such as partition integrity, ECC error handling, or error state handling were reported.

Summary:
- No direct security issues were found related to partition integrity, ECC, or error state handling.
- The reported lint errors are related to signal width in arithmetic operations and should be reviewed for potential impact on implementation but are not inherently security vulnerabilities.

Recommendation:
- Review and possibly refactor the arithmetic expressions to comply with the lint rule STARC05-2.10.8.2 to avoid potential synthesis or simulation issues.
- Continue to monitor and test for security properties through formal verification or additional security-focused lint checks if available.
================================= Tool Message =================================
Name: run_linter_agent

The lint check was performed on the provided RTL code for the module otp_ctrl_part_buf with a focus on security concerns related to partition integrity, ECC, and error state handling.

The lint tool reported 4 errors, all related to the lint tag STARC05-2.10.8.2, which indicates that the width of the left side expression of a division operator exceeds 12 bits. Specifically, these errors occur in the following lines:

- Line 86: Expression involving int'(Info.size) - ScrmblBlockWidth/8
- Line 87: Expression involving int'(Info.size) / (ScrmblBlockWidth/8)
- Line 641: Expression involving {cnt, {$clog2(ScrmblBlockWidth/8){1'b0}}} + addr_base
- Line 650: Expression involving ScrmblBlockWidth / OtpWidth

These errors are related to arithmetic operations on wide signals, which might not be optimal or could cause synthesis or simulation issues, but they do not directly indicate a security vulnerability.

No other lint errors or warnings related to security issues such as partition integrity, ECC error handling, or error state handling were reported.

Summary:
- No direct security issues were found related to partition integrity, ECC, or error state handling.
- The reported lint errors are related to signal width in arithmetic operations and should be reviewed for potential impact on implementation but are not inherently security vulnerabilities.

Recommendation:
- Review and possibly refactor the arithmetic expressions to comply with the lint rule STARC05-2.10.8.2 to avoid potential synthesis or simulation issues.
- Continue to monitor and test for security properties through formal verification or additional security-focused lint checks if available.
================================== Ai Message ==================================
Tool Calls:
  run_linter_agent (call_IKxsekiFAAzfexSzyUnIZymg)
 Call ID: call_IKxsekiFAAzfexSzyUnIZymg
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_unbuf.sv
    top_module: otp_ctrl_part_unbuf
    security_objective: partition access control, error state handling
================================ Human Message =================================

Are there security concerns related to partition access control, error state handling in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_unbuf.sv

    And the top module is:

    otp_ctrl_part_unbuf

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Unbuffered partition for OTP controller.
//

`include "prim_flop_macros.sv"

module otp_ctrl_part_unbuf
  import otp_ctrl_pkg::*;
  import otp_ctrl_reg_pkg::*;
  import otp_ctrl_part_pkg::*;
#(
  // Partition information.
  parameter part_info_t Info = PartInfoDefault
) (
  input                               clk_i,
  input                               rst_ni,
  // Pulse to start partition initialisation (required once per power cycle).
  input                               init_req_i,
  output logic                        init_done_o,
  // Escalation input. This moves the FSM into a terminal state and locks down
  // the partition.
  input  lc_ctrl_pkg::lc_tx_t         escalate_en_i,
  // Output error state of partition, to be consumed by OTP error/alert logic.
  // Note that most errors are not recoverable and move the partition FSM into
  // a terminal error state.
  output otp_err_e                    error_o,
  // This error signal is pulsed high if the FSM has been glitched into an invalid state.
  // Although it is somewhat redundant with the error code in error_o above, it is
  // meant to cover cases where we already latched an error code while the FSM is
  // glitched into an invalid state (since in that case, the error code will not be
  // overridden with the FSM error code so that the original error code is still
  // discoverable).
  output logic                        fsm_err_o,
  // Access/lock status
  // SEC_CM: ACCESS.CTRL.MUBI
  input  part_access_t                access_i, // runtime lock from CSRs
  output part_access_t                access_o,
  // Buffered 64bit digest output.
  output logic [ScrmblBlockWidth-1:0] digest_o,
  // Interface to TL-UL adapter
  input  logic                        tlul_req_i,
  output logic                        tlul_gnt_o,
  input [SwWindowAddrWidth-1:0]       tlul_addr_i,
  output logic [1:0]                  tlul_rerror_o,
  output logic                        tlul_rvalid_o,
  output logic [31:0]                 tlul_rdata_o,
  // OTP interface
  output logic                        otp_req_o,
  output prim_otp_pkg::cmd_e          otp_cmd_o,
  output logic [OtpSizeWidth-1:0]     otp_size_o,
  output logic [OtpIfWidth-1:0]       otp_wdata_o,
  output logic [OtpAddrWidth-1:0]     otp_addr_o,
  input                               otp_gnt_i,
  input                               otp_rvalid_i,
  input  [ScrmblBlockWidth-1:0]       otp_rdata_i,
  input  prim_otp_pkg::err_e          otp_err_i
);

  ////////////////////////
  // Integration Checks //
  ////////////////////////

  import prim_mubi_pkg::*;
  import prim_util_pkg::vbits;

  localparam logic [OtpByteAddrWidth:0] PartEnd = (OtpByteAddrWidth+1)'(Info.offset) +
                                                  (OtpByteAddrWidth+1)'(Info.size);
  localparam int unsigned DigestOffsetInt = int'(PartEnd) - ScrmblBlockWidth/8;

  localparam bit [OtpByteAddrWidth-1:0] DigestOffset = DigestOffsetInt[OtpByteAddrWidth-1:0];

  // Integration checks for parameters.
  `ASSERT_INIT(OffsetMustBeBlockAligned_A, (Info.offset % (ScrmblBlockWidth/8)) == 0)
  `ASSERT_INIT(SizeMustBeBlockAligned_A, (Info.size % (ScrmblBlockWidth/8)) == 0)
  `ASSERT_INIT(DigestOffsetMustBeRepresentable_A, DigestOffsetInt == int'(DigestOffset))

  ///////////////////////
  // OTP Partition FSM //
  ///////////////////////

  // SEC_CM: PART.FSM.SPARSE
  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 5 -m 7 -n 10 \
  //      -s 4247417884 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: --
  //  4: --
  //  5: |||||||||||||||||||| (52.38%)
  //  6: |||||||||||| (33.33%)
  //  7: | (4.76%)
  //  8: ||| (9.52%)
  //  9: --
  // 10: --
  //
  // Minimum Hamming distance: 5
  // Maximum Hamming distance: 8
  // Minimum Hamming weight: 3
  // Maximum Hamming weight: 9
  //
  localparam int StateWidth = 10;
  typedef enum logic [StateWidth-1:0] {
    ResetSt    = 10'b1010110110,
    InitSt     = 10'b0100010011,
    InitWaitSt = 10'b0001011000,
    IdleSt     = 10'b1011101001,
    ReadSt     = 10'b0101101110,
    ReadWaitSt = 10'b0110100101,
    ErrorSt    = 10'b1111011111
  } state_e;

  typedef enum logic {
    DigestAddrSel = 1'b0,
    DataAddrSel = 1'b1
  } addr_sel_e;

  state_e state_d, state_q;
  addr_sel_e otp_addr_sel;
  otp_err_e error_d, error_q;

  logic digest_reg_en;
  logic ecc_err;

  logic tlul_addr_in_range;
  logic [SwWindowAddrWidth-1:0] tlul_addr_d, tlul_addr_q;

  // This is only used to return bus errors when the FSM is in ErrorSt.
  logic pending_tlul_error_d, pending_tlul_error_q;

  // Output partition error state.
  assign error_o = error_q;

  // This partition cannot do any write accesses, hence we tie this
  // constantly off.
  assign otp_wdata_o = '0;
  // Depending on the partition configuration, the wrapper is instructed to ignore integrity
  // calculations and checks. To be on the safe side, the partition filters error responses at this
  // point and does not report any integrity errors if integrity is disabled.
  otp_err_e otp_err;
  if (Info.integrity) begin : gen_integrity
    assign otp_cmd_o = prim_otp_pkg::Read;
    assign otp_err = otp_err_e'(otp_err_i);
  end else begin : gen_no_integrity
    assign otp_cmd_o = prim_otp_pkg::ReadRaw;
    always_comb begin
      if (otp_err_e'(otp_err_i) inside {MacroEccCorrError, MacroEccUncorrError}) begin
        otp_err = NoError;
      end else begin
        otp_err = otp_err_e'(otp_err_i);
      end
    end
  end

  `ASSERT_KNOWN(FsmStateKnown_A, state_q)
  always_comb begin : p_fsm
    // Default assignments
    state_d = state_q;

    // Response to init request
    init_done_o = 1'b0;

    // OTP signals
    otp_req_o   = 1'b0;
    otp_addr_sel = DigestAddrSel;

    // TL-UL signals
    tlul_gnt_o      = 1'b0;
    tlul_rvalid_o   = 1'b0;
    tlul_rerror_o   = '0;

    // Enable for buffered digest register
    digest_reg_en = 1'b0;

    // Error Register
    error_d = error_q;
    pending_tlul_error_d = 1'b0;
    fsm_err_o = 1'b0;

    unique case (state_q)
      ///////////////////////////////////////////////////////////////////
      // State right after reset. Wait here until we get a an
      // initialization request.
      ResetSt: begin
        if (init_req_i) begin
          // If the partition does not have a digest, no initialization is necessary.
          if (Info.sw_digest) begin
            state_d = InitSt;
          end else begin
            state_d = IdleSt;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Initialization reads out the digest only in unbuffered
      // partitions. Wait here until the OTP request has been granted.
      // And then wait until the OTP word comes back.
      InitSt: begin
        otp_req_o = 1'b1;
        if (otp_gnt_i) begin
          state_d = InitWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for OTP response and write to digest buffer register. In
      // case an OTP transaction fails, latch the  OTP error code and
      // jump to a terminal error state.
      InitWaitSt: begin
        if (otp_rvalid_i) begin
          digest_reg_en = 1'b1;
          if (otp_err inside {NoError, MacroEccCorrError}) begin
            state_d = IdleSt;
            // At this point the only error that we could have gotten are correctable ECC errors.
            if (otp_err != NoError) begin
              error_d = MacroEccCorrError;
            end
          end else begin
            state_d = ErrorSt;
            error_d = otp_err;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for TL-UL requests coming in.
      // Then latch address and go to readout state.
      IdleSt: begin
        init_done_o = 1'b1;
        if (tlul_req_i) begin
          error_d = NoError; // clear recoverable soft errors.
          state_d = ReadSt;
          tlul_gnt_o = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // If the address is out of bounds, or if the partition is
      // locked, signal back a bus error. Note that such an error does
      // not cause the partition to go into error state. Otherwise if
      // these checks pass, an OTP word is requested.
      ReadSt: begin
        init_done_o = 1'b1;
        // Double check the address range.
        if (tlul_addr_in_range && mubi8_test_false_strict(access_o.read_lock)) begin
          otp_req_o = 1'b1;
          otp_addr_sel = DataAddrSel;
          if (otp_gnt_i) begin
            state_d = ReadWaitSt;
          end
        end else begin
          state_d = IdleSt;
          error_d = AccessError; // Signal this error, but do not go into terminal error state.
          tlul_rvalid_o = 1'b1;
          tlul_rerror_o = 2'b11; // This causes the TL-UL adapter to return a bus error.
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for OTP response and release the TL-UL response. In
      // case an OTP transaction fails, latch the OTP error code,
      // signal a TL-Ul bus error and jump to a terminal error state.
      ReadWaitSt: begin
        init_done_o = 1'b1;
        if (otp_rvalid_i) begin
          tlul_rvalid_o = 1'b1;
          if (otp_err inside {NoError, MacroEccCorrError}) begin
            state_d = IdleSt;
            // At this point the only error that we could have gotten are correctable ECC errors.
            if (otp_err != NoError) begin
              error_d = MacroEccCorrError;
            end
          end else begin
            state_d = ErrorSt;
            error_d = otp_err;
            // This causes the TL-UL adapter to return a bus error.
            tlul_rerror_o = 2'b11;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Terminal Error State. This locks access to the partition.
      // Make sure the partition signals an error state if no error
      // code has been latched so far.
      ErrorSt: begin
        if (error_q == NoError) begin
          error_d = FsmStateError;
        end

        // Return bus errors if there are pending TL-UL requests.
        if (pending_tlul_error_q) begin
          tlul_rerror_o = 2'b11;
          tlul_rvalid_o = 1'b1;
        end else if (tlul_req_i) begin
          tlul_gnt_o = 1'b1;
          pending_tlul_error_d = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // We should never get here. If we do (e.g. via a malicious
      // glitch), error out immediately.
      default: begin
        state_d = ErrorSt;
        fsm_err_o = 1'b1;
      end
      ///////////////////////////////////////////////////////////////////
    endcase // state_q

    // Unconditionally jump into the terminal error state in case of
    // an ECC error or escalation, and lock access to the partition down.
    // SEC_CM: PART.FSM.LOCAL_ESC
    if (ecc_err) begin
      state_d = ErrorSt;
      if (state_q != ErrorSt) begin
        error_d = CheckFailError;
      end
    end
    // SEC_CM: PART.FSM.GLOBAL_ESC
    if (lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i)) begin
      state_d = ErrorSt;
      fsm_err_o = 1'b1;
      if (state_q != ErrorSt) begin
        error_d = FsmStateError;
      end
    end
  end

  ///////////////////////////////////
  // Signals to/from TL-UL Adapter //
  ///////////////////////////////////

  assign tlul_addr_d  = tlul_addr_i;
  // Do not forward data in case of an error.
  assign tlul_rdata_o = (tlul_rvalid_o && tlul_rerror_o == '0) ? otp_rdata_i[31:0] : '0;

  if (Info.offset == 0) begin : gen_zero_offset
    assign tlul_addr_in_range = {1'b0, tlul_addr_q, 2'b00} < PartEnd;

  end else begin : gen_nonzero_offset
    assign tlul_addr_in_range = {tlul_addr_q, 2'b00} >= Info.offset &&
                                {1'b0, tlul_addr_q, 2'b00} < PartEnd;
  end

  // Note that OTP works on halfword (16bit) addresses, hence need to
  // shift the addresses appropriately.
  logic [OtpByteAddrWidth-1:0] addr_calc;
  assign addr_calc = (otp_addr_sel == DigestAddrSel) ? DigestOffset : {tlul_addr_q, 2'b00};
  assign otp_addr_o = addr_calc[OtpByteAddrWidth-1:OtpAddrShift];

  if (OtpAddrShift > 0) begin : gen_unused
    logic unused_bits;
    assign unused_bits = ^addr_calc[OtpAddrShift-1:0];
  end

  // Request 32bit except in case of the digest.
  assign otp_size_o = (otp_addr_sel == DigestAddrSel) ?
                      OtpSizeWidth'(unsigned'(ScrmblBlockWidth / OtpWidth - 1)) :
                      OtpSizeWidth'(unsigned'(32 / OtpWidth - 1));

  ////////////////
  // Digest Reg //
  ////////////////

  if (Info.sw_digest) begin : gen_ecc_reg
    // SEC_CM: PART.DATA_REG.INTEGRITY
    otp_ctrl_ecc_reg #(
      .Width ( ScrmblBlockWidth ),
      .Depth ( 1                )
    ) u_otp_ctrl_ecc_reg (
      .clk_i,
      .rst_ni,
      .wren_i    ( digest_reg_en ),
      .addr_i    ( '0            ),
      .wdata_i   ( otp_rdata_i   ),
      .rdata_o   (               ),
      .data_o    ( digest_o      ),
      .ecc_err_o ( ecc_err       )
    );
  end else begin : gen_no_ecc_reg
    logic unused_digest_reg_en;
    logic unused_rdata;
    assign unused_digest_reg_en = digest_reg_en;
    assign unused_rdata = ^otp_rdata_i[32 +: 32]; // Upper word is not connected in this case.
    assign digest_o = '0;
    assign ecc_err = 1'b0;
  end

  ////////////////////////
  // DAI Access Control //
  ////////////////////////

  mubi8_t init_locked;
  assign init_locked = (~init_done_o) ? MuBi8True : MuBi8False;

  // Aggregate all possible DAI write locks. The partition is also locked when uninitialized.
  // Note that the locks are redundantly encoded values.
  part_access_t access_pre;
  prim_mubi8_sender #(
    .AsyncOn(0)
  ) u_prim_mubi8_sender_write_lock_pre (
    .clk_i,
    .rst_ni,
    .mubi_i(mubi8_and_lo(init_locked, access_i.write_lock)),
    .mubi_o(access_pre.write_lock)
  );
  prim_mubi8_sender #(
    .AsyncOn(0)
  ) u_prim_mubi8_sender_read_lock_pre (
    .clk_i,
    .rst_ni,
    .mubi_i(mubi8_and_lo(init_locked, access_i.read_lock)),
    .mubi_o(access_pre.read_lock)
  );

  // SEC_CM: PART.MEM.SW_UNWRITABLE
  if (Info.write_lock) begin : gen_digest_write_lock
    mubi8_t digest_locked;
    assign digest_locked = (digest_o != '0) ? MuBi8True : MuBi8False;

    // This prevents the synthesis tool from optimizing the multibit signal.
    prim_mubi8_sender #(
      .AsyncOn(0)
    ) u_prim_mubi8_sender_write_lock (
      .clk_i,
      .rst_ni,
      .mubi_i(mubi8_and_lo(access_pre.write_lock, digest_locked)),
      .mubi_o(access_o.write_lock)
    );

    `ASSERT(DigestWriteLocksPartition_A, digest_o |-> mubi8_test_true_loose(access_o.write_lock))
  end else begin : gen_no_digest_write_lock
    assign access_o.write_lock = access_pre.write_lock;
  end

  // SEC_CM: PART.MEM.SW_UNREADABLE
  if (Info.read_lock) begin : gen_digest_read_lock
    mubi8_t digest_locked;
    assign digest_locked = (digest_o != '0) ? MuBi8True : MuBi8False;

    // This prevents the synthesis tool from optimizing the multibit signal.
    prim_mubi8_sender #(
      .AsyncOn(0)
    ) u_prim_mubi8_sender_read_lock (
      .clk_i,
      .rst_ni,
      .mubi_i(mubi8_and_lo(access_pre.read_lock, digest_locked)),
      .mubi_o(access_o.read_lock)
    );

    `ASSERT(DigestReadLocksPartition_A, digest_o |-> mubi8_test_true_loose(access_o.read_lock))
  end else begin : gen_no_digest_read_lock
    assign access_o.read_lock = access_pre.read_lock;
  end

  ///////////////
  // Registers //
  ///////////////

  `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, state_e, ResetSt)

  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs
    if (!rst_ni) begin
      error_q              <= NoError;
      tlul_addr_q          <= '0;
      pending_tlul_error_q <= 1'b0;
    end else begin
      error_q              <= error_d;
      pending_tlul_error_q <= pending_tlul_error_d;
      if (tlul_gnt_o) begin
        tlul_addr_q <= tlul_addr_d;
      end
    end
  end

  ////////////////
  // Assertions //
  ////////////////

  // Known assertions
  `ASSERT_KNOWN(InitDoneKnown_A,   init_done_o)
  `ASSERT_KNOWN(ErrorKnown_A,      error_o)
  `ASSERT_KNOWN(AccessKnown_A,     access_o)
  `ASSERT_KNOWN(DigestKnown_A,     digest_o)
  `ASSERT_KNOWN(TlulGntKnown_A,    tlul_gnt_o)
  `ASSERT_KNOWN(TlulRerrorKnown_A, tlul_rerror_o)
  `ASSERT_KNOWN(TlulRvalidKnown_A, tlul_rvalid_o)
  `ASSERT_KNOWN(TlulRdataKnown_A,  tlul_rdata_o)
  `ASSERT_KNOWN(OtpReqKnown_A,     otp_req_o)
  `ASSERT_KNOWN(OtpCmdKnown_A,     otp_cmd_o)
  `ASSERT_KNOWN(OtpSizeKnown_A,    otp_size_o)
  `ASSERT_KNOWN(OtpWdataKnown_A,   otp_wdata_o)
  `ASSERT_KNOWN(OtpAddrKnown_A,    otp_addr_o)

  // Uninitialized partitions should always be locked, no matter what.
  `ASSERT(InitWriteLocksPartition_A,
      ~init_done_o
      |->
      mubi8_test_true_loose(access_o.write_lock))
  `ASSERT(InitReadLocksPartition_A,
      ~init_done_o
      |->
      mubi8_test_true_loose(access_o.read_lock))
  // Incoming Lock propagation
  `ASSERT(WriteLockPropagation_A,
      mubi8_test_true_loose(access_i.write_lock)
      |->
      mubi8_test_true_loose(access_o.write_lock))
  `ASSERT(ReadLockPropagation_A,
      mubi8_test_true_loose(access_i.read_lock)
      |->
      mubi8_test_true_loose(access_o.read_lock))
  // If the partition is read locked, the TL-UL access must error out
  `ASSERT(TlulReadOnReadLock_A,
      tlul_req_i && tlul_gnt_o ##1 mubi8_test_true_loose(access_o.read_lock)
      |->
      tlul_rerror_o > '0 && tlul_rvalid_o)
  // ECC error in buffer regs.
  `ASSERT(EccErrorState_A,
      ecc_err
      |=>
      state_q == ErrorSt)
  // OTP error response
  `ASSERT(OtpErrorState_A,
      state_q inside {InitWaitSt, ReadWaitSt} && otp_rvalid_i &&
      !(otp_err inside {NoError, MacroEccCorrError}) && !ecc_err
      |=>
      state_q == ErrorSt && error_o == $past(otp_err))

endmodule : otp_ctrl_part_unbuf

    '''

    Identify relevant lint tags for the RTL to be checked for.
    Then run the tests using the linting tool.
    From the output of the linting tool, determine if there are security issues in the RTL.
================================== Ai Message ==================================
Tool Calls:
  retrieve_relevant_lint_tags (call_cO58GSEkjqtJnM95H9jXw1ZB)
 Call ID: call_cO58GSEkjqtJnM95H9jXw1ZB
  Args:
    query: partition access control error state handling security
================================= Tool Message =================================
Name: retrieve_relevant_lint_tags


W215: Reports inappropriate bit-selects of integer or time variables 


STARC05-2.11.1.4: Number of states in a FSM should not exceed specified limit


W210: Number of connections made to an instance does not match number of ports on master 


STARC05-1.4.3.1b: Clocks should not be gated 


STARC05-2.11.4.1: One-hot encoding should be used for allocating states


STARC05-2.10.5.3b: Reports violation when there are three or more arithmetic operations in Always block 


STARC05-2.11.5.2: Do not assign state encoding by attaching attributes to the state variable which is declared as a type (VHDL) 


STARC05-1.3.2.1a: Asynchronous resets or sets must not be gated 

TristatePort-ML: Tristate port detected


W336L: Blocking assignment to latch output should be avoided 


STARC05-2.4.1.4: Avoid combinational loops that contain latches 


STARC05-3.3.1.4a: Asynchronous sets/resets must be controllable from external pins 


W421: Reports “always” or “process” constructs that do not have an event control 


STARC05-2.10.8.1: Do not use arithmetic and logical expressions at the right and left sides of the division or modules operator


STARC05-1.2.1.1a: Design should use only one edge of a clock 


NonBlockingCounters-ML: Non-blocking counter assignment found 


STARC05-2.5.1.4: Identifies the tristate bus that is driven by more than specified number of drivers 


STARC05-2.3.1.7a: A flip-flop should not have two asynchronous resets 


AssignPatInInst-ML: Detect assignment patterns in parameter override or port connection area 

W541: A tristate is inferred
================================== Ai Message ==================================
Tool Calls:
  lint_checker_tool (call_vmpBi7chJzdksnRuBjdphdc0)
 Call ID: call_vmpBi7chJzdksnRuBjdphdc0
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_unbuf.sv
    top_module: otp_ctrl_part_unbuf
    lint_tags: ['STARC05-2.11.1.4', 'STARC05-1.4.3.1b', 'STARC05-2.11.4.1', 'STARC05-2.10.5.3b', 'STARC05-1.3.2.1a', 'STARC05-2.4.1.4', 'STARC05-3.3.1.4a', 'STARC05-1.2.1.1a']
================================= Tool Message =================================
Name: lint_checker_tool

Successfully executed:
```lint checker tool
```
Output: 
  -----------------------------------------------------------------------------
  Report Summary
  -----------------------------------------------------------------------------
  Product Info
    Name    : VC Static Master Shell
    Version : U-2023.03-1 -- Apr 17, 2023

  Report Info
    Created : May 06, 2025  17:18:05

    TopLevelModule: otp_ctrl_part_unbuf

================================== Ai Message ==================================

The lint checks related to partition access control and error state handling security for the module otp_ctrl_part_unbuf in the file otp_ctrl_part_unbuf.sv were executed. The lint checker did not report any issues or warnings.

Based on the lint check results, there are no detected security issues in the RTL code concerning partition access control and error state handling. The design appears to handle error states and access control properly, including locking mechanisms and error escalation to a terminal error state.
================================= Tool Message =================================
Name: run_linter_agent

The lint checks related to partition access control and error state handling security for the module otp_ctrl_part_unbuf in the file otp_ctrl_part_unbuf.sv were executed. The lint checker did not report any issues or warnings.

Based on the lint check results, there are no detected security issues in the RTL code concerning partition access control and error state handling. The design appears to handle error states and access control properly, including locking mechanisms and error escalation to a terminal error state.
================================== Ai Message ==================================
Tool Calls:
  run_linter_agent (call_eAyYg4MtPtnBoOpkLeCD7lMF)
 Call ID: call_eAyYg4MtPtnBoOpkLeCD7lMF
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_lci.sv
    top_module: otp_ctrl_lci
    security_objective: life cycle interface access control and error handling
================================ Human Message =================================

Are there security concerns related to life cycle interface access control and error handling in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_lci.sv

    And the top module is:

    otp_ctrl_lci

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Life cycle interface for performing life cycle transitions in OTP.
//

`include "prim_flop_macros.sv"

module otp_ctrl_lci
  import otp_ctrl_pkg::*;
  import otp_ctrl_reg_pkg::*;
  import otp_ctrl_part_pkg::*;
#(
  // Lifecycle partition information
  parameter part_info_t Info = PartInfoDefault
) (
  input                                     clk_i,
  input                                     rst_ni,
  input                                     lci_en_i,
  // Escalation input. This moves the FSM into a terminal state and locks down
  // the partition.
  input  lc_ctrl_pkg::lc_tx_t               escalate_en_i,
  // Life cycle transition request. In order to perform a state transition,
  // the LC controller signals the new count and state. The OTP wrapper then
  // only programs bits that have not been programmed before.
  // Note that a transition request will fail if the request attempts to
  // clear already programmed bits within OTP.
  input                                     lc_req_i,
  input  logic [Info.size*8-1:0]            lc_data_i,
  output logic                              lc_ack_o,
  output logic                              lc_err_o,
  // Output error state of partition, to be consumed by OTP error/alert logic.
  // Note that most errors are not recoverable and move the partition FSM into
  // a terminal error state.
  output otp_err_e                          error_o,
  // This error signal is pulsed high if the FSM has been glitched into an invalid state.
  // Although it is somewhat redundant with the error code in error_o above, it is
  // meant to cover cases where we already latched an error code while the FSM is
  // glitched into an invalid state (since in that case, the error code will not be
  // overridden with the FSM error code so that the original error code is still
  // discoverable).
  output logic                              fsm_err_o,
  output logic                              lci_prog_idle_o,
  // OTP interface
  output logic                              otp_req_o,
  output prim_otp_pkg::cmd_e                otp_cmd_o,
  output logic [OtpSizeWidth-1:0]           otp_size_o,
  output logic [OtpIfWidth-1:0]             otp_wdata_o,
  output logic [OtpAddrWidth-1:0]           otp_addr_o,
  input                                     otp_gnt_i,
  input                                     otp_rvalid_i,
  input  [ScrmblBlockWidth-1:0]             otp_rdata_i,
  input  prim_otp_pkg::err_e                otp_err_i
);

  ////////////////////////
  // Integration Checks //
  ////////////////////////

  import prim_util_pkg::vbits;

  localparam int NumLcOtpWords = int'(Info.size) >> OtpAddrShift;
  localparam int CntWidth = vbits(NumLcOtpWords);

  localparam int unsigned LastLcOtpWordInt = NumLcOtpWords - 1;
  localparam bit [CntWidth-1:0] LastLcOtpWord = LastLcOtpWordInt[CntWidth-1:0];

  // This is required, since each native OTP word can only be programmed once.
  `ASSERT_INIT(LcValueMustBeWiderThanNativeOtpWidth_A, lc_ctrl_state_pkg::LcValueWidth >= OtpWidth)

  ////////////////////
  // Controller FSM //
  ////////////////////

  // SEC_CM: LCI.FSM.SPARSE
  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 5 -m 5 -n 9 \
  //      -s 558234734 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: --
  //  4: --
  //  5: |||||||||||||||||||| (60.00%)
  //  6: ||||||||||||| (40.00%)
  //  7: --
  //  8: --
  //  9: --
  //
  // Minimum Hamming distance: 5
  // Maximum Hamming distance: 6
  // Minimum Hamming weight: 1
  // Maximum Hamming weight: 7
  //
  localparam int StateWidth = 9;
  typedef enum logic [StateWidth-1:0] {
    ResetSt     = 9'b000101011,
    IdleSt      = 9'b110011110,
    WriteSt     = 9'b101010001,
    WriteWaitSt = 9'b010000000,
    ErrorSt     = 9'b011111101
  } state_e;

  state_e state_d, state_q;
  logic cnt_clr, cnt_en, cnt_err;
  logic [CntWidth-1:0] cnt;
  otp_err_e error_d, error_q;

  // Output LCI errors
  assign error_o = error_q;

  always_comb begin : p_fsm
    state_d = state_q;

    // Counter
    cnt_en   = 1'b0;
    cnt_clr  = 1'b0;

    // Idle status
    lci_prog_idle_o = 1'b1;

    // OTP signals
    otp_req_o = 1'b0;
    otp_cmd_o = prim_otp_pkg::Read;

    // Response to LC controller
    lc_err_o = 1'b0;
    lc_ack_o = 1'b0;

    // Error Register
    error_d = error_q;
    fsm_err_o = 1'b0;

    unique case (state_q)
      ///////////////////////////////////////////////////////////////////
      // State right after reset. Wait here until LCI gets enabled.
      ResetSt: begin
        lci_prog_idle_o = 1'b0;
        if (lci_en_i) begin
          state_d = IdleSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for a request from the life cycle controller
      IdleSt: begin
        if (lc_req_i) begin
          state_d = WriteSt;
          cnt_clr = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Loop through the lifecycle sate and burn in all words.
      // If the write data contains a 0 bit in a position where a bit has already been
      // programmed to 1 before, the OTP errors out.
      WriteSt: begin
        otp_req_o = 1'b1;
        otp_cmd_o = prim_otp_pkg::Write;
        lci_prog_idle_o = 1'b0;
        if (otp_gnt_i) begin
          state_d = WriteWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for OTP response, and check whether there are more words to burn in.
      // In case an OTP transaction fails, latch the OTP error code, and jump to
      // terminal error state.
      WriteWaitSt: begin
        lci_prog_idle_o = 1'b0;
        if (otp_rvalid_i) begin
          // Check OTP return code.
          // Note that if errors occur, we aggregate the error code
          // but still attempt to program all remaining words.
          // This is done to ensure that a life cycle state with
          // ECC correctable errors in some words can still be scrapped.
          if (otp_err_e'(otp_err_i) != NoError) begin
            error_d = otp_err_e'(otp_err_i);
          end

          // Check whether we programmed all OTP words.
          // If yes, we are done and can go back to idle.
          if (cnt == LastLcOtpWord) begin
            state_d = IdleSt;
            lc_ack_o = 1'b1;
            // If in any of the words a programming error has occurred,
            // we signal that accordingly and go to the error state.
            if (error_d != NoError) begin
              lc_err_o = 1'b1;
              state_d = ErrorSt;
            end
          // Otherwise we increase the OTP word counter.
          end else begin
            state_d = WriteSt;
            cnt_en = 1'b1;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Terminal Error State. This locks access to the partition.
      // Make sure the partition signals an error state if no error
      // code has been latched so far, and lock the buffer regs down.
      ErrorSt: begin
        if (error_q == NoError) begin
          error_d = FsmStateError;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // We should never get here. If we do (e.g. via a malicious
      // glitch), error out immediately.
      default: begin
        state_d = ErrorSt;
        fsm_err_o = 1'b1;
      end
      ///////////////////////////////////////////////////////////////////
    endcase // state_q

    // Unconditionally jump into the terminal error state in case of escalation.
    // SEC_CM: LCI.FSM.LOCAL_ESC, LCI.FSM.GLOBAL_ESC
    if (lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) || cnt_err) begin
      state_d = ErrorSt;
      fsm_err_o = 1'b1;
      if (error_q == NoError) begin
        error_d = FsmStateError;
      end
    end

  end

  //////////////////////////////
  // Counter and address calc //
  //////////////////////////////

  // Native OTP word counter
  // SEC_CM: LCI.CTR.REDUN
  prim_count #(
    .Width(CntWidth)
  ) u_prim_count (
    .clk_i,
    .rst_ni,
    .clr_i(cnt_clr),
    .set_i(1'b0),
    .set_cnt_i('0),
    .incr_en_i(cnt_en),
    .decr_en_i(1'b0),
    .step_i(CntWidth'(1)),
    .commit_i(1'b1),
    .cnt_o(cnt),
    .cnt_after_commit_o(),
    .err_o(cnt_err)
  );

  // The output address is "offset + count", but we have to convert Info.offset from a byte address
  // to a halfword (16-bit) address by discarding the bottom OtpAddrShift bits. We also make the
  // zero-extension of cnt explicit (to avoid width mismatch warnings).
  assign otp_addr_o = Info.offset[OtpByteAddrWidth-1:OtpAddrShift] + OtpAddrWidth'(cnt);

  // Always transfer 16bit blocks.
  assign otp_size_o = '0;

  logic [NumLcOtpWords-1:0][OtpWidth-1:0] data;
  assign data        = lc_data_i;
  assign otp_wdata_o = (otp_req_o) ? OtpIfWidth'(data[cnt]) : '0;

  logic unused_rdata;
  assign unused_rdata = ^otp_rdata_i;

  ///////////////
  // Registers //
  ///////////////

  `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, state_e, ResetSt)

  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs
    if (!rst_ni) begin
      error_q <= NoError;
    end else begin
      error_q <= error_d;
    end
  end

  ////////////////
  // Assertions //
  ////////////////

  `ASSERT_KNOWN(LcAckKnown_A,    lc_ack_o)
  `ASSERT_KNOWN(LcErrKnown_A,    lc_err_o)
  `ASSERT_KNOWN(ErrorKnown_A,    error_o)
  `ASSERT_KNOWN(LciIdleKnown_A,  lci_prog_idle_o)
  `ASSERT_KNOWN(OtpReqKnown_A,   otp_req_o)
  `ASSERT_KNOWN(OtpCmdKnown_A,   otp_cmd_o)
  `ASSERT_KNOWN(OtpSizeKnown_A,  otp_size_o)
  `ASSERT_KNOWN(OtpWdataKnown_A, otp_wdata_o)
  `ASSERT_KNOWN(OtpAddrKnown_A,  otp_addr_o)

endmodule : otp_ctrl_lci

    '''

    Identify relevant lint tags for the RTL to be checked for.
    Then run the tests using the linting tool.
    From the output of the linting tool, determine if there are security issues in the RTL.
================================== Ai Message ==================================
Tool Calls:
  retrieve_relevant_lint_tags (call_fQxnj6Uu8F687SZZm2M3Fo5Z)
 Call ID: call_fQxnj6Uu8F687SZZm2M3Fo5Z
  Args:
    query: life cycle interface access control error handling security
================================= Tool Message =================================
Name: retrieve_relevant_lint_tags


STARC05-2.4.1.4: Avoid combinational loops that contain latches 


DisallowCaseZ-ML: Do not use casez constructs in the design 


ReEntrantOutput-ML: The re-entrant outputs should be avoided 


STARC05-1.4.3.1b: Clocks should not be gated 


noCombinatorialFeedBack: No combinatorial feedback loops allowed


DisallowCaseX-ML: Do not use casex constructs in the design


STARC05-1.3.2.1a: Asynchronous resets or sets must not be gated 


CAPA-ML: Copy-paste should not be done within a design file


FlopFeedbackRace-ML: Reports potential race conditions between flip-flop output and its clock/reset pin 


STARC05-1.3.1.2: Do not use synchronous reset in the design 


STARC05-2.1.9.5: Do not use user-defined attributes in the design 


STARC05-2.2.1.2: Design should not have latches


STARC05-1.6.1.2: Modules instantiating basic blocks must not contain lxiiiSynopsys, Inc.Feedbacklogic gates 


STARC05-2.4.1.5: Do not use two level latches in the same phase clock 


UniqueInputOutputSampling-ML: Checks the existence of unique output flip-flops to output interface and unique input flip-flops to input interface


SafeLatch-ML: Identifies the unsafe latch triplets 

DeadCode: Code does not contribute to functionality of the design


W336L: Blocking assignment to latch output should be avoided 


STARC05-1.4.3.6: Do not use Flip-Flops with inverted edges 


STARC05-2.3.5.1: Flip-flops should not have fixed inputs 
================================== Ai Message ==================================
Tool Calls:
  lint_checker_tool (call_NHLwqDoLrVasaVwLhF08o92q)
 Call ID: call_NHLwqDoLrVasaVwLhF08o92q
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_lci.sv
    top_module: otp_ctrl_lci
    lint_tags: ['STARC05-2.4.1.4', 'DisallowCaseZ-ML', 'ReEntrantOutput-ML', 'STARC05-1.4.3.1b', 'noCombinatorialFeedBack', 'DisallowCaseX-ML', 'STARC05-1.3.2.1a', 'CAPA-ML', 'FlopFeedbackRace-ML', 'STARC05-1.3.1.2', 'STARC05-2.1.9.5', 'STARC05-2.2.1.2', 'STARC05-1.6.1.2', 'STARC05-2.4.1.5', 'UniqueInputOutputSampling-ML', 'SafeLatch-ML', 'DeadCode', 'W336L', 'STARC05-1.4.3.6', 'STARC05-2.3.5.1']
================================= Tool Message =================================
Name: lint_checker_tool

Successfully executed:
```lint checker tool
```
Output: 
  -----------------------------------------------------------------------------
  Report Summary
  -----------------------------------------------------------------------------
  Product Info
    Name    : VC Static Master Shell
    Version : U-2023.03-1 -- Apr 17, 2023

  Report Info
    Created : May 06, 2025  17:18:48

    TopLevelModule: otp_ctrl_lci

  -----------------------------------------------------------------------------
  Management Summary
  -----------------------------------------------------------------------------
  Stage             Family      Fatals    Errors  Warnings     Infos
  -----             --------  --------  --------  --------  --------
  STRUCTURAL_CHECK  CODING           0         5         0         0
  -----             --------  --------  --------  --------  --------
  Total                              0         5         0         0


  -----------------------------------------------------------------------------
  Tree Summary
  -----------------------------------------------------------------------------
  Severity  Stage             Tag                             Count
  --------  -----             ------------------------------  -----
  error     STRUCTURAL_CHECK  DeadCode                            4
  error     STRUCTURAL_CHECK  UniqueInputOutputSampling-ML        1
  --------  -----             ------------------------------  -----
  Total                                                           5



  -----------------------------------------------------------------------------
  DeadCode  (4 errors/0 waived)
  -----------------------------------------------------------------------------
  Tag              : DeadCode
  Description      : The net '[DesignObjSignal]' does not drive anything
  Violation        : Lint:5
  Module           : otp_ctrl_lci
  FileName         : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_lci.sv
  LineNumber       : 30
  Statement        :   input  logic [Info.size*8-1:0]            lc_data_i,
  DesignObjSignal  : lc_data_i[2039:2032]
  -----------------------------------------------------------------------------
  Tag              : DeadCode
  Description      : The net '[DesignObjSignal]' does not drive anything
  Violation        : Lint:4
  Module           : prim_count
  FileName         : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_count_0/rtl/prim_count.sv
  LineNumber       : 158
  Statement        :   assign cnt_after_commit_o = cnt_d[0];
  DesignObjSignal  : u_prim_count/cnt_after_commit_o[6:0]
  -----------------------------------------------------------------------------
  Tag              : DeadCode
  Description      : The net '[DesignObjSignal]' does not drive anything
  Violation        : Lint:3
  Module           : prim_sparse_fsm_flop
  FileName         : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_prim_sparse_fsm_0/rtl/prim_sparse_fsm_flop.sv
  LineNumber       : 55
  Statement        :     assign unused_err_o = 1'b0;
  DesignObjSignal  : u_state_regs/unused_err_o
  -----------------------------------------------------------------------------
  Tag              : DeadCode
  Description      : The net '[DesignObjSignal]' does not drive anything
  Violation        : Lint:2
  Module           : otp_ctrl_lci
  FileName         : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_lci.sv
  LineNumber       : 268
  Statement        :   assign unused_rdata = ^otp_rdata_i;
  DesignObjSignal  : unused_rdata

  -----------------------------------------------------------------------------
  UniqueInputOutputSampling-ML  (1 error/0 waived)
  -----------------------------------------------------------------------------
  Tag            : UniqueInputOutputSampling-ML
  Description    : [PortDirection] port '[SOCPortName]' is not sampled uniquely
  Violation      : Lint:1
  FileName       : build/lowrisc_ip_otp_ctrl_1.0/src/lowrisc_ip_otp_ctrl_1.0/rtl/otp_ctrl_lci.sv
  LineNumber     : 36
  Statement      :   output otp_err_e                          error_o,
  PortDirection  : Output
  SOCPortName    : error_o[2:0]
  Module         : otp_ctrl_lci

================================== Ai Message ==================================

The lint check results for the module otp_ctrl_lci in the file /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_lci.sv show the following issues:

1. DeadCode (4 errors):
   - The input signal lc_data_i[2039:2032] does not drive anything.
   - In the prim_count module, the output cnt_after_commit_o[6:0] does not drive anything.
   - In the prim_sparse_fsm_flop module, the signal unused_err_o is assigned but not used.
   - The signal unused_rdata in otp_ctrl_lci is assigned but not used.

2. UniqueInputOutputSampling-ML (1 error):
   - The output port error_o[2:0] is not sampled uniquely.

Regarding security concerns related to life cycle interface access control and error handling:

- The dead code issues indicate some signals are not used or driving any logic. This might not directly cause a security vulnerability but could indicate incomplete or redundant logic which should be reviewed.
- The unique input/output sampling error on the error_o output port suggests that the error signal might not be reliably sampled or latched, which could affect error reporting and handling. This could potentially lead to missed or incorrect error signaling, impacting the robustness of error handling in the life cycle interface.

No direct critical security vulnerabilities such as combinational loops, gated clocks, or asynchronous reset issues were reported.

Summary:
- The RTL has some dead code and a unique sampling issue on the error output.
- These issues should be addressed to ensure robust error handling and clean design.
- No immediate severe security flaws related to access control or error handling were detected by the lint checks.

Recommendation:
- Review and remove or properly use the dead code signals.
- Fix the unique input/output sampling issue on error_o to ensure reliable error signaling.
- Conduct further security reviews and dynamic testing to confirm the design's security posture.
================================= Tool Message =================================
Name: run_linter_agent

The lint check results for the module otp_ctrl_lci in the file /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_lci.sv show the following issues:

1. DeadCode (4 errors):
   - The input signal lc_data_i[2039:2032] does not drive anything.
   - In the prim_count module, the output cnt_after_commit_o[6:0] does not drive anything.
   - In the prim_sparse_fsm_flop module, the signal unused_err_o is assigned but not used.
   - The signal unused_rdata in otp_ctrl_lci is assigned but not used.

2. UniqueInputOutputSampling-ML (1 error):
   - The output port error_o[2:0] is not sampled uniquely.

Regarding security concerns related to life cycle interface access control and error handling:

- The dead code issues indicate some signals are not used or driving any logic. This might not directly cause a security vulnerability but could indicate incomplete or redundant logic which should be reviewed.
- The unique input/output sampling error on the error_o output port suggests that the error signal might not be reliably sampled or latched, which could affect error reporting and handling. This could potentially lead to missed or incorrect error signaling, impacting the robustness of error handling in the life cycle interface.

No direct critical security vulnerabilities such as combinational loops, gated clocks, or asynchronous reset issues were reported.

Summary:
- The RTL has some dead code and a unique sampling issue on the error output.
- These issues should be addressed to ensure robust error handling and clean design.
- No immediate severe security flaws related to access control or error handling were detected by the lint checks.

Recommendation:
- Review and remove or properly use the dead code signals.
- Fix the unique input/output sampling issue on error_o to ensure reliable error signaling.
- Conduct further security reviews and dynamic testing to confirm the design's security posture.
================================== Ai Message ==================================
Tool Calls:
  run_assertions_checker_agent (call_qwuheu8hfFJ5HwBYXvuzTsDq)
 Call ID: call_qwuheu8hfFJ5HwBYXvuzTsDq
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_core_reg_top.sv
    top_module: otp_ctrl_core_reg_top
    security_objective: register access policy enforcement, privilege escalation prevention
================================ Human Message =================================

Are there security concerns related to register access policy enforcement, privilege escalation prevention in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_core_reg_top.sv

    And the top module is:

    otp_ctrl_core_reg_top

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Register Top module auto-generated by `reggen`

`include "prim_assert.sv"

module otp_ctrl_core_reg_top (
  input clk_i,
  input rst_ni,
  input  tlul_pkg::tl_h2d_t tl_i,
  output tlul_pkg::tl_d2h_t tl_o,

  // Output port for window
  output tlul_pkg::tl_h2d_t tl_win_o,
  input  tlul_pkg::tl_d2h_t tl_win_i,

  // To HW
  output otp_ctrl_reg_pkg::otp_ctrl_core_reg2hw_t reg2hw, // Write
  input  otp_ctrl_reg_pkg::otp_ctrl_core_hw2reg_t hw2reg, // Read

  // Integrity check errors
  output logic intg_err_o
);

  import otp_ctrl_reg_pkg::* ;

  localparam int AW = 12;
  localparam int DW = 32;
  localparam int DBW = DW/8;                    // Byte Width

  // register signals
  logic           reg_we;
  logic           reg_re;
  logic [AW-1:0]  reg_addr;
  logic [DW-1:0]  reg_wdata;
  logic [DBW-1:0] reg_be;
  logic [DW-1:0]  reg_rdata;
  logic           reg_error;

  logic          addrmiss, wr_err;

  logic [DW-1:0] reg_rdata_next;
  logic reg_busy;

  tlul_pkg::tl_h2d_t tl_reg_h2d;
  tlul_pkg::tl_d2h_t tl_reg_d2h;


  // incoming payload check
  logic intg_err;
  tlul_cmd_intg_chk u_chk (
    .tl_i(tl_i),
    .err_o(intg_err)
  );

  // also check for spurious write enables
  logic reg_we_err;
  logic [55:0] reg_we_check;
  prim_reg_we_check #(
    .OneHotWidth(56)
  ) u_prim_reg_we_check (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .oh_i  (reg_we_check),
    .en_i  (reg_we && !addrmiss),
    .err_o (reg_we_err)
  );

  logic err_q;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      err_q <= '0;
    end else if (intg_err || reg_we_err) begin
      err_q <= 1'b1;
    end
  end

  // integrity error output is permanent and should be used for alert generation
  // register errors are transactional
  assign intg_err_o = err_q | intg_err | reg_we_err;

  // outgoing integrity generation
  tlul_pkg::tl_d2h_t tl_o_pre;
  tlul_rsp_intg_gen #(
    .EnableRspIntgGen(1),
    .EnableDataIntgGen(1)
  ) u_rsp_intg_gen (
    .tl_i(tl_o_pre),
    .tl_o(tl_o)
  );

  tlul_pkg::tl_h2d_t tl_socket_h2d [2];
  tlul_pkg::tl_d2h_t tl_socket_d2h [2];

  logic [0:0] reg_steer;

  // socket_1n connection
  assign tl_reg_h2d = tl_socket_h2d[1];
  assign tl_socket_d2h[1] = tl_reg_d2h;

  assign tl_win_o = tl_socket_h2d[0];
  assign tl_socket_d2h[0] = tl_win_i;

  // Create Socket_1n
  tlul_socket_1n #(
    .N            (2),
    .HReqPass     (1'b1),
    .HRspPass     (1'b1),
    .DReqPass     ({2{1'b1}}),
    .DRspPass     ({2{1'b1}}),
    .HReqDepth    (4'h0),
    .HRspDepth    (4'h0),
    .DReqDepth    ({2{4'h0}}),
    .DRspDepth    ({2{4'h0}}),
    .ExplicitErrs (1'b0)
  ) u_socket (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),
    .tl_h_i (tl_i),
    .tl_h_o (tl_o_pre),
    .tl_d_o (tl_socket_h2d),
    .tl_d_i (tl_socket_d2h),
    .dev_select_i (reg_steer)
  );

  // Create steering logic
  always_comb begin
    reg_steer =
        tl_i.a_address[AW-1:0] inside {[2048:4095]} ? 1'd0 :
        // Default set to register
        1'd1;

    // Override this in case of an integrity error
    if (intg_err) begin
      reg_steer = 1'd1;
    end
  end

  tlul_adapter_reg #(
    .RegAw(AW),
    .RegDw(DW),
    .EnableDataIntgGen(0)
  ) u_reg_if (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),

    .tl_i (tl_reg_h2d),
    .tl_o (tl_reg_d2h),

    .en_ifetch_i(prim_mubi_pkg::MuBi4False),
    .intg_error_o(),

    .we_o    (reg_we),
    .re_o    (reg_re),
    .addr_o  (reg_addr),
    .wdata_o (reg_wdata),
    .be_o    (reg_be),
    .busy_i  (reg_busy),
    .rdata_i (reg_rdata),
    .error_i (reg_error)
  );

  // cdc oversampling signals

  assign reg_rdata = reg_rdata_next ;
  assign reg_error = addrmiss | wr_err | intg_err;

  // Define SW related signals
  // Format: <reg>_<field>_{wd|we|qs}
  //        or <reg>_{wd|we|qs} if field == 1 or 0
  logic intr_state_we;
  logic intr_state_otp_operation_done_qs;
  logic intr_state_otp_operation_done_wd;
  logic intr_state_otp_error_qs;
  logic intr_state_otp_error_wd;
  logic intr_enable_we;
  logic intr_enable_otp_operation_done_qs;
  logic intr_enable_otp_operation_done_wd;
  logic intr_enable_otp_error_qs;
  logic intr_enable_otp_error_wd;
  logic intr_test_we;
  logic intr_test_otp_operation_done_wd;
  logic intr_test_otp_error_wd;
  logic alert_test_we;
  logic alert_test_fatal_macro_error_wd;
  logic alert_test_fatal_check_error_wd;
  logic alert_test_fatal_bus_integ_error_wd;
  logic alert_test_fatal_prim_otp_alert_wd;
  logic alert_test_recov_prim_otp_alert_wd;
  logic status_re;
  logic status_vendor_test_error_qs;
  logic status_creator_sw_cfg_error_qs;
  logic status_owner_sw_cfg_error_qs;
  logic status_rot_creator_auth_codesign_error_qs;
  logic status_rot_creator_auth_state_error_qs;
  logic status_hw_cfg0_error_qs;
  logic status_hw_cfg1_error_qs;
  logic status_secret0_error_qs;
  logic status_secret1_error_qs;
  logic status_secret2_error_qs;
  logic status_life_cycle_error_qs;
  logic status_dai_error_qs;
  logic status_lci_error_qs;
  logic status_timeout_error_qs;
  logic status_lfsr_fsm_error_qs;
  logic status_scrambling_fsm_error_qs;
  logic status_key_deriv_fsm_error_qs;
  logic status_bus_integ_error_qs;
  logic status_dai_idle_qs;
  logic status_check_pending_qs;
  logic err_code_0_re;
  logic [2:0] err_code_0_qs;
  logic err_code_1_re;
  logic [2:0] err_code_1_qs;
  logic err_code_2_re;
  logic [2:0] err_code_2_qs;
  logic err_code_3_re;
  logic [2:0] err_code_3_qs;
  logic err_code_4_re;
  logic [2:0] err_code_4_qs;
  logic err_code_5_re;
  logic [2:0] err_code_5_qs;
  logic err_code_6_re;
  logic [2:0] err_code_6_qs;
  logic err_code_7_re;
  logic [2:0] err_code_7_qs;
  logic err_code_8_re;
  logic [2:0] err_code_8_qs;
  logic err_code_9_re;
  logic [2:0] err_code_9_qs;
  logic err_code_10_re;
  logic [2:0] err_code_10_qs;
  logic err_code_11_re;
  logic [2:0] err_code_11_qs;
  logic err_code_12_re;
  logic [2:0] err_code_12_qs;
  logic direct_access_regwen_re;
  logic direct_access_regwen_we;
  logic direct_access_regwen_qs;
  logic direct_access_regwen_wd;
  logic direct_access_cmd_we;
  logic direct_access_cmd_rd_wd;
  logic direct_access_cmd_wr_wd;
  logic direct_access_cmd_digest_wd;
  logic direct_access_address_we;
  logic [10:0] direct_access_address_qs;
  logic [10:0] direct_access_address_wd;
  logic direct_access_wdata_0_we;
  logic [31:0] direct_access_wdata_0_qs;
  logic [31:0] direct_access_wdata_0_wd;
  logic direct_access_wdata_1_we;
  logic [31:0] direct_access_wdata_1_qs;
  logic [31:0] direct_access_wdata_1_wd;
  logic direct_access_rdata_0_re;
  logic [31:0] direct_access_rdata_0_qs;
  logic direct_access_rdata_1_re;
  logic [31:0] direct_access_rdata_1_qs;
  logic check_trigger_regwen_we;
  logic check_trigger_regwen_qs;
  logic check_trigger_regwen_wd;
  logic check_trigger_we;
  logic check_trigger_integrity_wd;
  logic check_trigger_consistency_wd;
  logic check_regwen_we;
  logic check_regwen_qs;
  logic check_regwen_wd;
  logic check_timeout_we;
  logic [31:0] check_timeout_qs;
  logic [31:0] check_timeout_wd;
  logic integrity_check_period_we;
  logic [31:0] integrity_check_period_qs;
  logic [31:0] integrity_check_period_wd;
  logic consistency_check_period_we;
  logic [31:0] consistency_check_period_qs;
  logic [31:0] consistency_check_period_wd;
  logic vendor_test_read_lock_we;
  logic vendor_test_read_lock_qs;
  logic vendor_test_read_lock_wd;
  logic creator_sw_cfg_read_lock_we;
  logic creator_sw_cfg_read_lock_qs;
  logic creator_sw_cfg_read_lock_wd;
  logic owner_sw_cfg_read_lock_we;
  logic owner_sw_cfg_read_lock_qs;
  logic owner_sw_cfg_read_lock_wd;
  logic rot_creator_auth_codesign_read_lock_we;
  logic rot_creator_auth_codesign_read_lock_qs;
  logic rot_creator_auth_codesign_read_lock_wd;
  logic rot_creator_auth_state_read_lock_we;
  logic rot_creator_auth_state_read_lock_qs;
  logic rot_creator_auth_state_read_lock_wd;
  logic vendor_test_digest_0_re;
  logic [31:0] vendor_test_digest_0_qs;
  logic vendor_test_digest_1_re;
  logic [31:0] vendor_test_digest_1_qs;
  logic creator_sw_cfg_digest_0_re;
  logic [31:0] creator_sw_cfg_digest_0_qs;
  logic creator_sw_cfg_digest_1_re;
  logic [31:0] creator_sw_cfg_digest_1_qs;
  logic owner_sw_cfg_digest_0_re;
  logic [31:0] owner_sw_cfg_digest_0_qs;
  logic owner_sw_cfg_digest_1_re;
  logic [31:0] owner_sw_cfg_digest_1_qs;
  logic rot_creator_auth_codesign_digest_0_re;
  logic [31:0] rot_creator_auth_codesign_digest_0_qs;
  logic rot_creator_auth_codesign_digest_1_re;
  logic [31:0] rot_creator_auth_codesign_digest_1_qs;
  logic rot_creator_auth_state_digest_0_re;
  logic [31:0] rot_creator_auth_state_digest_0_qs;
  logic rot_creator_auth_state_digest_1_re;
  logic [31:0] rot_creator_auth_state_digest_1_qs;
  logic hw_cfg0_digest_0_re;
  logic [31:0] hw_cfg0_digest_0_qs;
  logic hw_cfg0_digest_1_re;
  logic [31:0] hw_cfg0_digest_1_qs;
  logic hw_cfg1_digest_0_re;
  logic [31:0] hw_cfg1_digest_0_qs;
  logic hw_cfg1_digest_1_re;
  logic [31:0] hw_cfg1_digest_1_qs;
  logic secret0_digest_0_re;
  logic [31:0] secret0_digest_0_qs;
  logic secret0_digest_1_re;
  logic [31:0] secret0_digest_1_qs;
  logic secret1_digest_0_re;
  logic [31:0] secret1_digest_0_qs;
  logic secret1_digest_1_re;
  logic [31:0] secret1_digest_1_qs;
  logic secret2_digest_0_re;
  logic [31:0] secret2_digest_0_qs;
  logic secret2_digest_1_re;
  logic [31:0] secret2_digest_1_qs;

  // Register instances
  // R[intr_state]: V(False)
  //   F[otp_operation_done]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_otp_operation_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_otp_operation_done_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.otp_operation_done.de),
    .d      (hw2reg.intr_state.otp_operation_done.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.otp_operation_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_otp_operation_done_qs)
  );

  //   F[otp_error]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_otp_error (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_otp_error_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.otp_error.de),
    .d      (hw2reg.intr_state.otp_error.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.otp_error.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_otp_error_qs)
  );


  // R[intr_enable]: V(False)
  //   F[otp_operation_done]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_otp_operation_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_otp_operation_done_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.otp_operation_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_otp_operation_done_qs)
  );

  //   F[otp_error]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_otp_error (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_otp_error_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.otp_error.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_otp_error_qs)
  );


  // R[intr_test]: V(True)
  logic intr_test_qe;
  logic [1:0] intr_test_flds_we;
  assign intr_test_qe = &intr_test_flds_we;
  //   F[otp_operation_done]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_otp_operation_done (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_otp_operation_done_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[0]),
    .q      (reg2hw.intr_test.otp_operation_done.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.otp_operation_done.qe = intr_test_qe;

  //   F[otp_error]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_otp_error (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_otp_error_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[1]),
    .q      (reg2hw.intr_test.otp_error.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.otp_error.qe = intr_test_qe;


  // R[alert_test]: V(True)
  logic alert_test_qe;
  logic [4:0] alert_test_flds_we;
  assign alert_test_qe = &alert_test_flds_we;
  //   F[fatal_macro_error]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_fatal_macro_error (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_fatal_macro_error_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[0]),
    .q      (reg2hw.alert_test.fatal_macro_error.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.fatal_macro_error.qe = alert_test_qe;

  //   F[fatal_check_error]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_fatal_check_error (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_fatal_check_error_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[1]),
    .q      (reg2hw.alert_test.fatal_check_error.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.fatal_check_error.qe = alert_test_qe;

  //   F[fatal_bus_integ_error]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_fatal_bus_integ_error (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_fatal_bus_integ_error_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[2]),
    .q      (reg2hw.alert_test.fatal_bus_integ_error.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.fatal_bus_integ_error.qe = alert_test_qe;

  //   F[fatal_prim_otp_alert]: 3:3
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_fatal_prim_otp_alert (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_fatal_prim_otp_alert_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[3]),
    .q      (reg2hw.alert_test.fatal_prim_otp_alert.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.fatal_prim_otp_alert.qe = alert_test_qe;

  //   F[recov_prim_otp_alert]: 4:4
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test_recov_prim_otp_alert (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_recov_prim_otp_alert_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[4]),
    .q      (reg2hw.alert_test.recov_prim_otp_alert.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.recov_prim_otp_alert.qe = alert_test_qe;


  // R[status]: V(True)
  //   F[vendor_test_error]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_vendor_test_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.vendor_test_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_vendor_test_error_qs)
  );

  //   F[creator_sw_cfg_error]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_creator_sw_cfg_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.creator_sw_cfg_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_creator_sw_cfg_error_qs)
  );

  //   F[owner_sw_cfg_error]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_owner_sw_cfg_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.owner_sw_cfg_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_owner_sw_cfg_error_qs)
  );

  //   F[rot_creator_auth_codesign_error]: 3:3
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_rot_creator_auth_codesign_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.rot_creator_auth_codesign_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_rot_creator_auth_codesign_error_qs)
  );

  //   F[rot_creator_auth_state_error]: 4:4
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_rot_creator_auth_state_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.rot_creator_auth_state_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_rot_creator_auth_state_error_qs)
  );

  //   F[hw_cfg0_error]: 5:5
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_hw_cfg0_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.hw_cfg0_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_hw_cfg0_error_qs)
  );

  //   F[hw_cfg1_error]: 6:6
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_hw_cfg1_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.hw_cfg1_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_hw_cfg1_error_qs)
  );

  //   F[secret0_error]: 7:7
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_secret0_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.secret0_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_secret0_error_qs)
  );

  //   F[secret1_error]: 8:8
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_secret1_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.secret1_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_secret1_error_qs)
  );

  //   F[secret2_error]: 9:9
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_secret2_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.secret2_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_secret2_error_qs)
  );

  //   F[life_cycle_error]: 10:10
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_life_cycle_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.life_cycle_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_life_cycle_error_qs)
  );

  //   F[dai_error]: 11:11
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_dai_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.dai_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_dai_error_qs)
  );

  //   F[lci_error]: 12:12
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_lci_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.lci_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_lci_error_qs)
  );

  //   F[timeout_error]: 13:13
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_timeout_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.timeout_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_timeout_error_qs)
  );

  //   F[lfsr_fsm_error]: 14:14
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_lfsr_fsm_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.lfsr_fsm_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_lfsr_fsm_error_qs)
  );

  //   F[scrambling_fsm_error]: 15:15
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_scrambling_fsm_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.scrambling_fsm_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_scrambling_fsm_error_qs)
  );

  //   F[key_deriv_fsm_error]: 16:16
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_key_deriv_fsm_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.key_deriv_fsm_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_key_deriv_fsm_error_qs)
  );

  //   F[bus_integ_error]: 17:17
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_bus_integ_error (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.bus_integ_error.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_bus_integ_error_qs)
  );

  //   F[dai_idle]: 18:18
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_dai_idle (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.dai_idle.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_dai_idle_qs)
  );

  //   F[check_pending]: 19:19
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_check_pending (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.check_pending.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_check_pending_qs)
  );


  // Subregister 0 of Multireg err_code
  // R[err_code_0]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_0 (
    .re     (err_code_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_0_qs)
  );


  // Subregister 1 of Multireg err_code
  // R[err_code_1]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_1 (
    .re     (err_code_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_1_qs)
  );


  // Subregister 2 of Multireg err_code
  // R[err_code_2]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_2 (
    .re     (err_code_2_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[2].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_2_qs)
  );


  // Subregister 3 of Multireg err_code
  // R[err_code_3]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_3 (
    .re     (err_code_3_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[3].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_3_qs)
  );


  // Subregister 4 of Multireg err_code
  // R[err_code_4]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_4 (
    .re     (err_code_4_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[4].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_4_qs)
  );


  // Subregister 5 of Multireg err_code
  // R[err_code_5]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_5 (
    .re     (err_code_5_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[5].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_5_qs)
  );


  // Subregister 6 of Multireg err_code
  // R[err_code_6]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_6 (
    .re     (err_code_6_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[6].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_6_qs)
  );


  // Subregister 7 of Multireg err_code
  // R[err_code_7]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_7 (
    .re     (err_code_7_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[7].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_7_qs)
  );


  // Subregister 8 of Multireg err_code
  // R[err_code_8]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_8 (
    .re     (err_code_8_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[8].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_8_qs)
  );


  // Subregister 9 of Multireg err_code
  // R[err_code_9]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_9 (
    .re     (err_code_9_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[9].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_9_qs)
  );


  // Subregister 10 of Multireg err_code
  // R[err_code_10]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_10 (
    .re     (err_code_10_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[10].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_10_qs)
  );


  // Subregister 11 of Multireg err_code
  // R[err_code_11]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_11 (
    .re     (err_code_11_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[11].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_11_qs)
  );


  // Subregister 12 of Multireg err_code
  // R[err_code_12]: V(True)
  prim_subreg_ext #(
    .DW    (3)
  ) u_err_code_12 (
    .re     (err_code_12_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.err_code[12].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (err_code_12_qs)
  );


  // R[direct_access_regwen]: V(True)
  logic direct_access_regwen_qe;
  logic [0:0] direct_access_regwen_flds_we;
  assign direct_access_regwen_qe = &direct_access_regwen_flds_we;
  prim_subreg_ext #(
    .DW    (1)
  ) u_direct_access_regwen (
    .re     (direct_access_regwen_re),
    .we     (direct_access_regwen_we),
    .wd     (direct_access_regwen_wd),
    .d      (hw2reg.direct_access_regwen.d),
    .qre    (),
    .qe     (direct_access_regwen_flds_we[0]),
    .q      (reg2hw.direct_access_regwen.q),
    .ds     (),
    .qs     (direct_access_regwen_qs)
  );
  assign reg2hw.direct_access_regwen.qe = direct_access_regwen_qe;


  // R[direct_access_cmd]: V(True)
  logic direct_access_cmd_qe;
  logic [2:0] direct_access_cmd_flds_we;
  assign direct_access_cmd_qe = &direct_access_cmd_flds_we;
  // Create REGWEN-gated WE signal
  logic direct_access_cmd_gated_we;
  assign direct_access_cmd_gated_we = direct_access_cmd_we & direct_access_regwen_qs;
  //   F[rd]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_direct_access_cmd_rd (
    .re     (1'b0),
    .we     (direct_access_cmd_gated_we),
    .wd     (direct_access_cmd_rd_wd),
    .d      ('0),
    .qre    (),
    .qe     (direct_access_cmd_flds_we[0]),
    .q      (reg2hw.direct_access_cmd.rd.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.direct_access_cmd.rd.qe = direct_access_cmd_qe;

  //   F[wr]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_direct_access_cmd_wr (
    .re     (1'b0),
    .we     (direct_access_cmd_gated_we),
    .wd     (direct_access_cmd_wr_wd),
    .d      ('0),
    .qre    (),
    .qe     (direct_access_cmd_flds_we[1]),
    .q      (reg2hw.direct_access_cmd.wr.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.direct_access_cmd.wr.qe = direct_access_cmd_qe;

  //   F[digest]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_direct_access_cmd_digest (
    .re     (1'b0),
    .we     (direct_access_cmd_gated_we),
    .wd     (direct_access_cmd_digest_wd),
    .d      ('0),
    .qre    (),
    .qe     (direct_access_cmd_flds_we[2]),
    .q      (reg2hw.direct_access_cmd.digest.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.direct_access_cmd.digest.qe = direct_access_cmd_qe;


  // R[direct_access_address]: V(False)
  // Create REGWEN-gated WE signal
  logic direct_access_address_gated_we;
  assign direct_access_address_gated_we = direct_access_address_we & direct_access_regwen_qs;
  prim_subreg #(
    .DW      (11),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (11'h0),
    .Mubi    (1'b0)
  ) u_direct_access_address (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (direct_access_address_gated_we),
    .wd     (direct_access_address_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.direct_access_address.q),
    .ds     (),

    // to register interface (read)
    .qs     (direct_access_address_qs)
  );


  // Subregister 0 of Multireg direct_access_wdata
  // R[direct_access_wdata_0]: V(False)
  // Create REGWEN-gated WE signal
  logic direct_access_wdata_0_gated_we;
  assign direct_access_wdata_0_gated_we = direct_access_wdata_0_we & direct_access_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_direct_access_wdata_0 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (direct_access_wdata_0_gated_we),
    .wd     (direct_access_wdata_0_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.direct_access_wdata[0].q),
    .ds     (),

    // to register interface (read)
    .qs     (direct_access_wdata_0_qs)
  );


  // Subregister 1 of Multireg direct_access_wdata
  // R[direct_access_wdata_1]: V(False)
  // Create REGWEN-gated WE signal
  logic direct_access_wdata_1_gated_we;
  assign direct_access_wdata_1_gated_we = direct_access_wdata_1_we & direct_access_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_direct_access_wdata_1 (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (direct_access_wdata_1_gated_we),
    .wd     (direct_access_wdata_1_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.direct_access_wdata[1].q),
    .ds     (),

    // to register interface (read)
    .qs     (direct_access_wdata_1_qs)
  );


  // Subregister 0 of Multireg direct_access_rdata
  // R[direct_access_rdata_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_direct_access_rdata_0 (
    .re     (direct_access_rdata_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.direct_access_rdata[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (direct_access_rdata_0_qs)
  );


  // Subregister 1 of Multireg direct_access_rdata
  // R[direct_access_rdata_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_direct_access_rdata_1 (
    .re     (direct_access_rdata_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.direct_access_rdata[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (direct_access_rdata_1_qs)
  );


  // R[check_trigger_regwen]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_check_trigger_regwen (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (check_trigger_regwen_we),
    .wd     (check_trigger_regwen_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (check_trigger_regwen_qs)
  );


  // R[check_trigger]: V(True)
  logic check_trigger_qe;
  logic [1:0] check_trigger_flds_we;
  assign check_trigger_qe = &check_trigger_flds_we;
  // Create REGWEN-gated WE signal
  logic check_trigger_gated_we;
  assign check_trigger_gated_we = check_trigger_we & check_trigger_regwen_qs;
  //   F[integrity]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_check_trigger_integrity (
    .re     (1'b0),
    .we     (check_trigger_gated_we),
    .wd     (check_trigger_integrity_wd),
    .d      ('0),
    .qre    (),
    .qe     (check_trigger_flds_we[0]),
    .q      (reg2hw.check_trigger.integrity.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.check_trigger.integrity.qe = check_trigger_qe;

  //   F[consistency]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_check_trigger_consistency (
    .re     (1'b0),
    .we     (check_trigger_gated_we),
    .wd     (check_trigger_consistency_wd),
    .d      ('0),
    .qre    (),
    .qe     (check_trigger_flds_we[1]),
    .q      (reg2hw.check_trigger.consistency.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.check_trigger.consistency.qe = check_trigger_qe;


  // R[check_regwen]: V(False)
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_check_regwen (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (check_regwen_we),
    .wd     (check_regwen_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (check_regwen_qs)
  );


  // R[check_timeout]: V(False)
  // Create REGWEN-gated WE signal
  logic check_timeout_gated_we;
  assign check_timeout_gated_we = check_timeout_we & check_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_check_timeout (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (check_timeout_gated_we),
    .wd     (check_timeout_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.check_timeout.q),
    .ds     (),

    // to register interface (read)
    .qs     (check_timeout_qs)
  );


  // R[integrity_check_period]: V(False)
  // Create REGWEN-gated WE signal
  logic integrity_check_period_gated_we;
  assign integrity_check_period_gated_we = integrity_check_period_we & check_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_integrity_check_period (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (integrity_check_period_gated_we),
    .wd     (integrity_check_period_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.integrity_check_period.q),
    .ds     (),

    // to register interface (read)
    .qs     (integrity_check_period_qs)
  );


  // R[consistency_check_period]: V(False)
  // Create REGWEN-gated WE signal
  logic consistency_check_period_gated_we;
  assign consistency_check_period_gated_we = consistency_check_period_we & check_regwen_qs;
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_consistency_check_period (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (consistency_check_period_gated_we),
    .wd     (consistency_check_period_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.consistency_check_period.q),
    .ds     (),

    // to register interface (read)
    .qs     (consistency_check_period_qs)
  );


  // R[vendor_test_read_lock]: V(False)
  // Create REGWEN-gated WE signal
  logic vendor_test_read_lock_gated_we;
  assign vendor_test_read_lock_gated_we = vendor_test_read_lock_we & direct_access_regwen_qs;
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_vendor_test_read_lock (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (vendor_test_read_lock_gated_we),
    .wd     (vendor_test_read_lock_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.vendor_test_read_lock.q),
    .ds     (),

    // to register interface (read)
    .qs     (vendor_test_read_lock_qs)
  );


  // R[creator_sw_cfg_read_lock]: V(False)
  // Create REGWEN-gated WE signal
  logic creator_sw_cfg_read_lock_gated_we;
  assign creator_sw_cfg_read_lock_gated_we = creator_sw_cfg_read_lock_we & direct_access_regwen_qs;
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_creator_sw_cfg_read_lock (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (creator_sw_cfg_read_lock_gated_we),
    .wd     (creator_sw_cfg_read_lock_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.creator_sw_cfg_read_lock.q),
    .ds     (),

    // to register interface (read)
    .qs     (creator_sw_cfg_read_lock_qs)
  );


  // R[owner_sw_cfg_read_lock]: V(False)
  // Create REGWEN-gated WE signal
  logic owner_sw_cfg_read_lock_gated_we;
  assign owner_sw_cfg_read_lock_gated_we = owner_sw_cfg_read_lock_we & direct_access_regwen_qs;
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_owner_sw_cfg_read_lock (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (owner_sw_cfg_read_lock_gated_we),
    .wd     (owner_sw_cfg_read_lock_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.owner_sw_cfg_read_lock.q),
    .ds     (),

    // to register interface (read)
    .qs     (owner_sw_cfg_read_lock_qs)
  );


  // R[rot_creator_auth_codesign_read_lock]: V(False)
  // Create REGWEN-gated WE signal
  logic rot_creator_auth_codesign_read_lock_gated_we;
  assign rot_creator_auth_codesign_read_lock_gated_we =
    rot_creator_auth_codesign_read_lock_we & direct_access_regwen_qs;
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_rot_creator_auth_codesign_read_lock (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (rot_creator_auth_codesign_read_lock_gated_we),
    .wd     (rot_creator_auth_codesign_read_lock_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.rot_creator_auth_codesign_read_lock.q),
    .ds     (),

    // to register interface (read)
    .qs     (rot_creator_auth_codesign_read_lock_qs)
  );


  // R[rot_creator_auth_state_read_lock]: V(False)
  // Create REGWEN-gated WE signal
  logic rot_creator_auth_state_read_lock_gated_we;
  assign rot_creator_auth_state_read_lock_gated_we =
    rot_creator_auth_state_read_lock_we & direct_access_regwen_qs;
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  (1'h1),
    .Mubi    (1'b0)
  ) u_rot_creator_auth_state_read_lock (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (rot_creator_auth_state_read_lock_gated_we),
    .wd     (rot_creator_auth_state_read_lock_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.rot_creator_auth_state_read_lock.q),
    .ds     (),

    // to register interface (read)
    .qs     (rot_creator_auth_state_read_lock_qs)
  );


  // Subregister 0 of Multireg vendor_test_digest
  // R[vendor_test_digest_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_vendor_test_digest_0 (
    .re     (vendor_test_digest_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.vendor_test_digest[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (vendor_test_digest_0_qs)
  );


  // Subregister 1 of Multireg vendor_test_digest
  // R[vendor_test_digest_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_vendor_test_digest_1 (
    .re     (vendor_test_digest_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.vendor_test_digest[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (vendor_test_digest_1_qs)
  );


  // Subregister 0 of Multireg creator_sw_cfg_digest
  // R[creator_sw_cfg_digest_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_creator_sw_cfg_digest_0 (
    .re     (creator_sw_cfg_digest_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.creator_sw_cfg_digest[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (creator_sw_cfg_digest_0_qs)
  );


  // Subregister 1 of Multireg creator_sw_cfg_digest
  // R[creator_sw_cfg_digest_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_creator_sw_cfg_digest_1 (
    .re     (creator_sw_cfg_digest_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.creator_sw_cfg_digest[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (creator_sw_cfg_digest_1_qs)
  );


  // Subregister 0 of Multireg owner_sw_cfg_digest
  // R[owner_sw_cfg_digest_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_owner_sw_cfg_digest_0 (
    .re     (owner_sw_cfg_digest_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.owner_sw_cfg_digest[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (owner_sw_cfg_digest_0_qs)
  );


  // Subregister 1 of Multireg owner_sw_cfg_digest
  // R[owner_sw_cfg_digest_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_owner_sw_cfg_digest_1 (
    .re     (owner_sw_cfg_digest_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.owner_sw_cfg_digest[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (owner_sw_cfg_digest_1_qs)
  );


  // Subregister 0 of Multireg rot_creator_auth_codesign_digest
  // R[rot_creator_auth_codesign_digest_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_rot_creator_auth_codesign_digest_0 (
    .re     (rot_creator_auth_codesign_digest_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.rot_creator_auth_codesign_digest[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (rot_creator_auth_codesign_digest_0_qs)
  );


  // Subregister 1 of Multireg rot_creator_auth_codesign_digest
  // R[rot_creator_auth_codesign_digest_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_rot_creator_auth_codesign_digest_1 (
    .re     (rot_creator_auth_codesign_digest_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.rot_creator_auth_codesign_digest[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (rot_creator_auth_codesign_digest_1_qs)
  );


  // Subregister 0 of Multireg rot_creator_auth_state_digest
  // R[rot_creator_auth_state_digest_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_rot_creator_auth_state_digest_0 (
    .re     (rot_creator_auth_state_digest_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.rot_creator_auth_state_digest[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (rot_creator_auth_state_digest_0_qs)
  );


  // Subregister 1 of Multireg rot_creator_auth_state_digest
  // R[rot_creator_auth_state_digest_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_rot_creator_auth_state_digest_1 (
    .re     (rot_creator_auth_state_digest_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.rot_creator_auth_state_digest[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (rot_creator_auth_state_digest_1_qs)
  );


  // Subregister 0 of Multireg hw_cfg0_digest
  // R[hw_cfg0_digest_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_hw_cfg0_digest_0 (
    .re     (hw_cfg0_digest_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.hw_cfg0_digest[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (hw_cfg0_digest_0_qs)
  );


  // Subregister 1 of Multireg hw_cfg0_digest
  // R[hw_cfg0_digest_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_hw_cfg0_digest_1 (
    .re     (hw_cfg0_digest_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.hw_cfg0_digest[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (hw_cfg0_digest_1_qs)
  );


  // Subregister 0 of Multireg hw_cfg1_digest
  // R[hw_cfg1_digest_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_hw_cfg1_digest_0 (
    .re     (hw_cfg1_digest_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.hw_cfg1_digest[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (hw_cfg1_digest_0_qs)
  );


  // Subregister 1 of Multireg hw_cfg1_digest
  // R[hw_cfg1_digest_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_hw_cfg1_digest_1 (
    .re     (hw_cfg1_digest_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.hw_cfg1_digest[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (hw_cfg1_digest_1_qs)
  );


  // Subregister 0 of Multireg secret0_digest
  // R[secret0_digest_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_secret0_digest_0 (
    .re     (secret0_digest_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.secret0_digest[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (secret0_digest_0_qs)
  );


  // Subregister 1 of Multireg secret0_digest
  // R[secret0_digest_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_secret0_digest_1 (
    .re     (secret0_digest_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.secret0_digest[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (secret0_digest_1_qs)
  );


  // Subregister 0 of Multireg secret1_digest
  // R[secret1_digest_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_secret1_digest_0 (
    .re     (secret1_digest_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.secret1_digest[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (secret1_digest_0_qs)
  );


  // Subregister 1 of Multireg secret1_digest
  // R[secret1_digest_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_secret1_digest_1 (
    .re     (secret1_digest_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.secret1_digest[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (secret1_digest_1_qs)
  );


  // Subregister 0 of Multireg secret2_digest
  // R[secret2_digest_0]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_secret2_digest_0 (
    .re     (secret2_digest_0_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.secret2_digest[0].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (secret2_digest_0_qs)
  );


  // Subregister 1 of Multireg secret2_digest
  // R[secret2_digest_1]: V(True)
  prim_subreg_ext #(
    .DW    (32)
  ) u_secret2_digest_1 (
    .re     (secret2_digest_1_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.secret2_digest[1].d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (secret2_digest_1_qs)
  );



  logic [55:0] addr_hit;
  always_comb begin
    addr_hit = '0;
    addr_hit[ 0] = (reg_addr == OTP_CTRL_INTR_STATE_OFFSET);
    addr_hit[ 1] = (reg_addr == OTP_CTRL_INTR_ENABLE_OFFSET);
    addr_hit[ 2] = (reg_addr == OTP_CTRL_INTR_TEST_OFFSET);
    addr_hit[ 3] = (reg_addr == OTP_CTRL_ALERT_TEST_OFFSET);
    addr_hit[ 4] = (reg_addr == OTP_CTRL_STATUS_OFFSET);
    addr_hit[ 5] = (reg_addr == OTP_CTRL_ERR_CODE_0_OFFSET);
    addr_hit[ 6] = (reg_addr == OTP_CTRL_ERR_CODE_1_OFFSET);
    addr_hit[ 7] = (reg_addr == OTP_CTRL_ERR_CODE_2_OFFSET);
    addr_hit[ 8] = (reg_addr == OTP_CTRL_ERR_CODE_3_OFFSET);
    addr_hit[ 9] = (reg_addr == OTP_CTRL_ERR_CODE_4_OFFSET);
    addr_hit[10] = (reg_addr == OTP_CTRL_ERR_CODE_5_OFFSET);
    addr_hit[11] = (reg_addr == OTP_CTRL_ERR_CODE_6_OFFSET);
    addr_hit[12] = (reg_addr == OTP_CTRL_ERR_CODE_7_OFFSET);
    addr_hit[13] = (reg_addr == OTP_CTRL_ERR_CODE_8_OFFSET);
    addr_hit[14] = (reg_addr == OTP_CTRL_ERR_CODE_9_OFFSET);
    addr_hit[15] = (reg_addr == OTP_CTRL_ERR_CODE_10_OFFSET);
    addr_hit[16] = (reg_addr == OTP_CTRL_ERR_CODE_11_OFFSET);
    addr_hit[17] = (reg_addr == OTP_CTRL_ERR_CODE_12_OFFSET);
    addr_hit[18] = (reg_addr == OTP_CTRL_DIRECT_ACCESS_REGWEN_OFFSET);
    addr_hit[19] = (reg_addr == OTP_CTRL_DIRECT_ACCESS_CMD_OFFSET);
    addr_hit[20] = (reg_addr == OTP_CTRL_DIRECT_ACCESS_ADDRESS_OFFSET);
    addr_hit[21] = (reg_addr == OTP_CTRL_DIRECT_ACCESS_WDATA_0_OFFSET);
    addr_hit[22] = (reg_addr == OTP_CTRL_DIRECT_ACCESS_WDATA_1_OFFSET);
    addr_hit[23] = (reg_addr == OTP_CTRL_DIRECT_ACCESS_RDATA_0_OFFSET);
    addr_hit[24] = (reg_addr == OTP_CTRL_DIRECT_ACCESS_RDATA_1_OFFSET);
    addr_hit[25] = (reg_addr == OTP_CTRL_CHECK_TRIGGER_REGWEN_OFFSET);
    addr_hit[26] = (reg_addr == OTP_CTRL_CHECK_TRIGGER_OFFSET);
    addr_hit[27] = (reg_addr == OTP_CTRL_CHECK_REGWEN_OFFSET);
    addr_hit[28] = (reg_addr == OTP_CTRL_CHECK_TIMEOUT_OFFSET);
    addr_hit[29] = (reg_addr == OTP_CTRL_INTEGRITY_CHECK_PERIOD_OFFSET);
    addr_hit[30] = (reg_addr == OTP_CTRL_CONSISTENCY_CHECK_PERIOD_OFFSET);
    addr_hit[31] = (reg_addr == OTP_CTRL_VENDOR_TEST_READ_LOCK_OFFSET);
    addr_hit[32] = (reg_addr == OTP_CTRL_CREATOR_SW_CFG_READ_LOCK_OFFSET);
    addr_hit[33] = (reg_addr == OTP_CTRL_OWNER_SW_CFG_READ_LOCK_OFFSET);
    addr_hit[34] = (reg_addr == OTP_CTRL_ROT_CREATOR_AUTH_CODESIGN_READ_LOCK_OFFSET);
    addr_hit[35] = (reg_addr == OTP_CTRL_ROT_CREATOR_AUTH_STATE_READ_LOCK_OFFSET);
    addr_hit[36] = (reg_addr == OTP_CTRL_VENDOR_TEST_DIGEST_0_OFFSET);
    addr_hit[37] = (reg_addr == OTP_CTRL_VENDOR_TEST_DIGEST_1_OFFSET);
    addr_hit[38] = (reg_addr == OTP_CTRL_CREATOR_SW_CFG_DIGEST_0_OFFSET);
    addr_hit[39] = (reg_addr == OTP_CTRL_CREATOR_SW_CFG_DIGEST_1_OFFSET);
    addr_hit[40] = (reg_addr == OTP_CTRL_OWNER_SW_CFG_DIGEST_0_OFFSET);
    addr_hit[41] = (reg_addr == OTP_CTRL_OWNER_SW_CFG_DIGEST_1_OFFSET);
    addr_hit[42] = (reg_addr == OTP_CTRL_ROT_CREATOR_AUTH_CODESIGN_DIGEST_0_OFFSET);
    addr_hit[43] = (reg_addr == OTP_CTRL_ROT_CREATOR_AUTH_CODESIGN_DIGEST_1_OFFSET);
    addr_hit[44] = (reg_addr == OTP_CTRL_ROT_CREATOR_AUTH_STATE_DIGEST_0_OFFSET);
    addr_hit[45] = (reg_addr == OTP_CTRL_ROT_CREATOR_AUTH_STATE_DIGEST_1_OFFSET);
    addr_hit[46] = (reg_addr == OTP_CTRL_HW_CFG0_DIGEST_0_OFFSET);
    addr_hit[47] = (reg_addr == OTP_CTRL_HW_CFG0_DIGEST_1_OFFSET);
    addr_hit[48] = (reg_addr == OTP_CTRL_HW_CFG1_DIGEST_0_OFFSET);
    addr_hit[49] = (reg_addr == OTP_CTRL_HW_CFG1_DIGEST_1_OFFSET);
    addr_hit[50] = (reg_addr == OTP_CTRL_SECRET0_DIGEST_0_OFFSET);
    addr_hit[51] = (reg_addr == OTP_CTRL_SECRET0_DIGEST_1_OFFSET);
    addr_hit[52] = (reg_addr == OTP_CTRL_SECRET1_DIGEST_0_OFFSET);
    addr_hit[53] = (reg_addr == OTP_CTRL_SECRET1_DIGEST_1_OFFSET);
    addr_hit[54] = (reg_addr == OTP_CTRL_SECRET2_DIGEST_0_OFFSET);
    addr_hit[55] = (reg_addr == OTP_CTRL_SECRET2_DIGEST_1_OFFSET);
  end

  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;

  // Check sub-word write is permitted
  always_comb begin
    wr_err = (reg_we &
              ((addr_hit[ 0] & (|(OTP_CTRL_CORE_PERMIT[ 0] & ~reg_be))) |
               (addr_hit[ 1] & (|(OTP_CTRL_CORE_PERMIT[ 1] & ~reg_be))) |
               (addr_hit[ 2] & (|(OTP_CTRL_CORE_PERMIT[ 2] & ~reg_be))) |
               (addr_hit[ 3] & (|(OTP_CTRL_CORE_PERMIT[ 3] & ~reg_be))) |
               (addr_hit[ 4] & (|(OTP_CTRL_CORE_PERMIT[ 4] & ~reg_be))) |
               (addr_hit[ 5] & (|(OTP_CTRL_CORE_PERMIT[ 5] & ~reg_be))) |
               (addr_hit[ 6] & (|(OTP_CTRL_CORE_PERMIT[ 6] & ~reg_be))) |
               (addr_hit[ 7] & (|(OTP_CTRL_CORE_PERMIT[ 7] & ~reg_be))) |
               (addr_hit[ 8] & (|(OTP_CTRL_CORE_PERMIT[ 8] & ~reg_be))) |
               (addr_hit[ 9] & (|(OTP_CTRL_CORE_PERMIT[ 9] & ~reg_be))) |
               (addr_hit[10] & (|(OTP_CTRL_CORE_PERMIT[10] & ~reg_be))) |
               (addr_hit[11] & (|(OTP_CTRL_CORE_PERMIT[11] & ~reg_be))) |
               (addr_hit[12] & (|(OTP_CTRL_CORE_PERMIT[12] & ~reg_be))) |
               (addr_hit[13] & (|(OTP_CTRL_CORE_PERMIT[13] & ~reg_be))) |
               (addr_hit[14] & (|(OTP_CTRL_CORE_PERMIT[14] & ~reg_be))) |
               (addr_hit[15] & (|(OTP_CTRL_CORE_PERMIT[15] & ~reg_be))) |
               (addr_hit[16] & (|(OTP_CTRL_CORE_PERMIT[16] & ~reg_be))) |
               (addr_hit[17] & (|(OTP_CTRL_CORE_PERMIT[17] & ~reg_be))) |
               (addr_hit[18] & (|(OTP_CTRL_CORE_PERMIT[18] & ~reg_be))) |
               (addr_hit[19] & (|(OTP_CTRL_CORE_PERMIT[19] & ~reg_be))) |
               (addr_hit[20] & (|(OTP_CTRL_CORE_PERMIT[20] & ~reg_be))) |
               (addr_hit[21] & (|(OTP_CTRL_CORE_PERMIT[21] & ~reg_be))) |
               (addr_hit[22] & (|(OTP_CTRL_CORE_PERMIT[22] & ~reg_be))) |
               (addr_hit[23] & (|(OTP_CTRL_CORE_PERMIT[23] & ~reg_be))) |
               (addr_hit[24] & (|(OTP_CTRL_CORE_PERMIT[24] & ~reg_be))) |
               (addr_hit[25] & (|(OTP_CTRL_CORE_PERMIT[25] & ~reg_be))) |
               (addr_hit[26] & (|(OTP_CTRL_CORE_PERMIT[26] & ~reg_be))) |
               (addr_hit[27] & (|(OTP_CTRL_CORE_PERMIT[27] & ~reg_be))) |
               (addr_hit[28] & (|(OTP_CTRL_CORE_PERMIT[28] & ~reg_be))) |
               (addr_hit[29] & (|(OTP_CTRL_CORE_PERMIT[29] & ~reg_be))) |
               (addr_hit[30] & (|(OTP_CTRL_CORE_PERMIT[30] & ~reg_be))) |
               (addr_hit[31] & (|(OTP_CTRL_CORE_PERMIT[31] & ~reg_be))) |
               (addr_hit[32] & (|(OTP_CTRL_CORE_PERMIT[32] & ~reg_be))) |
               (addr_hit[33] & (|(OTP_CTRL_CORE_PERMIT[33] & ~reg_be))) |
               (addr_hit[34] & (|(OTP_CTRL_CORE_PERMIT[34] & ~reg_be))) |
               (addr_hit[35] & (|(OTP_CTRL_CORE_PERMIT[35] & ~reg_be))) |
               (addr_hit[36] & (|(OTP_CTRL_CORE_PERMIT[36] & ~reg_be))) |
               (addr_hit[37] & (|(OTP_CTRL_CORE_PERMIT[37] & ~reg_be))) |
               (addr_hit[38] & (|(OTP_CTRL_CORE_PERMIT[38] & ~reg_be))) |
               (addr_hit[39] & (|(OTP_CTRL_CORE_PERMIT[39] & ~reg_be))) |
               (addr_hit[40] & (|(OTP_CTRL_CORE_PERMIT[40] & ~reg_be))) |
               (addr_hit[41] & (|(OTP_CTRL_CORE_PERMIT[41] & ~reg_be))) |
               (addr_hit[42] & (|(OTP_CTRL_CORE_PERMIT[42] & ~reg_be))) |
               (addr_hit[43] & (|(OTP_CTRL_CORE_PERMIT[43] & ~reg_be))) |
               (addr_hit[44] & (|(OTP_CTRL_CORE_PERMIT[44] & ~reg_be))) |
               (addr_hit[45] & (|(OTP_CTRL_CORE_PERMIT[45] & ~reg_be))) |
               (addr_hit[46] & (|(OTP_CTRL_CORE_PERMIT[46] & ~reg_be))) |
               (addr_hit[47] & (|(OTP_CTRL_CORE_PERMIT[47] & ~reg_be))) |
               (addr_hit[48] & (|(OTP_CTRL_CORE_PERMIT[48] & ~reg_be))) |
               (addr_hit[49] & (|(OTP_CTRL_CORE_PERMIT[49] & ~reg_be))) |
               (addr_hit[50] & (|(OTP_CTRL_CORE_PERMIT[50] & ~reg_be))) |
               (addr_hit[51] & (|(OTP_CTRL_CORE_PERMIT[51] & ~reg_be))) |
               (addr_hit[52] & (|(OTP_CTRL_CORE_PERMIT[52] & ~reg_be))) |
               (addr_hit[53] & (|(OTP_CTRL_CORE_PERMIT[53] & ~reg_be))) |
               (addr_hit[54] & (|(OTP_CTRL_CORE_PERMIT[54] & ~reg_be))) |
               (addr_hit[55] & (|(OTP_CTRL_CORE_PERMIT[55] & ~reg_be)))));
  end

  // Generate write-enables
  assign intr_state_we = addr_hit[0] & reg_we & !reg_error;

  assign intr_state_otp_operation_done_wd = reg_wdata[0];

  assign intr_state_otp_error_wd = reg_wdata[1];
  assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;

  assign intr_enable_otp_operation_done_wd = reg_wdata[0];

  assign intr_enable_otp_error_wd = reg_wdata[1];
  assign intr_test_we = addr_hit[2] & reg_we & !reg_error;

  assign intr_test_otp_operation_done_wd = reg_wdata[0];

  assign intr_test_otp_error_wd = reg_wdata[1];
  assign alert_test_we = addr_hit[3] & reg_we & !reg_error;

  assign alert_test_fatal_macro_error_wd = reg_wdata[0];

  assign alert_test_fatal_check_error_wd = reg_wdata[1];

  assign alert_test_fatal_bus_integ_error_wd = reg_wdata[2];

  assign alert_test_fatal_prim_otp_alert_wd = reg_wdata[3];

  assign alert_test_recov_prim_otp_alert_wd = reg_wdata[4];
  assign status_re = addr_hit[4] & reg_re & !reg_error;
  assign err_code_0_re = addr_hit[5] & reg_re & !reg_error;
  assign err_code_1_re = addr_hit[6] & reg_re & !reg_error;
  assign err_code_2_re = addr_hit[7] & reg_re & !reg_error;
  assign err_code_3_re = addr_hit[8] & reg_re & !reg_error;
  assign err_code_4_re = addr_hit[9] & reg_re & !reg_error;
  assign err_code_5_re = addr_hit[10] & reg_re & !reg_error;
  assign err_code_6_re = addr_hit[11] & reg_re & !reg_error;
  assign err_code_7_re = addr_hit[12] & reg_re & !reg_error;
  assign err_code_8_re = addr_hit[13] & reg_re & !reg_error;
  assign err_code_9_re = addr_hit[14] & reg_re & !reg_error;
  assign err_code_10_re = addr_hit[15] & reg_re & !reg_error;
  assign err_code_11_re = addr_hit[16] & reg_re & !reg_error;
  assign err_code_12_re = addr_hit[17] & reg_re & !reg_error;
  assign direct_access_regwen_re = addr_hit[18] & reg_re & !reg_error;
  assign direct_access_regwen_we = addr_hit[18] & reg_we & !reg_error;

  assign direct_access_regwen_wd = reg_wdata[0];
  assign direct_access_cmd_we = addr_hit[19] & reg_we & !reg_error;

  assign direct_access_cmd_rd_wd = reg_wdata[0];

  assign direct_access_cmd_wr_wd = reg_wdata[1];

  assign direct_access_cmd_digest_wd = reg_wdata[2];
  assign direct_access_address_we = addr_hit[20] & reg_we & !reg_error;

  assign direct_access_address_wd = reg_wdata[10:0];
  assign direct_access_wdata_0_we = addr_hit[21] & reg_we & !reg_error;

  assign direct_access_wdata_0_wd = reg_wdata[31:0];
  assign direct_access_wdata_1_we = addr_hit[22] & reg_we & !reg_error;

  assign direct_access_wdata_1_wd = reg_wdata[31:0];
  assign direct_access_rdata_0_re = addr_hit[23] & reg_re & !reg_error;
  assign direct_access_rdata_1_re = addr_hit[24] & reg_re & !reg_error;
  assign check_trigger_regwen_we = addr_hit[25] & reg_we & !reg_error;

  assign check_trigger_regwen_wd = reg_wdata[0];
  assign check_trigger_we = addr_hit[26] & reg_we & !reg_error;

  assign check_trigger_integrity_wd = reg_wdata[0];

  assign check_trigger_consistency_wd = reg_wdata[1];
  assign check_regwen_we = addr_hit[27] & reg_we & !reg_error;

  assign check_regwen_wd = reg_wdata[0];
  assign check_timeout_we = addr_hit[28] & reg_we & !reg_error;

  assign check_timeout_wd = reg_wdata[31:0];
  assign integrity_check_period_we = addr_hit[29] & reg_we & !reg_error;

  assign integrity_check_period_wd = reg_wdata[31:0];
  assign consistency_check_period_we = addr_hit[30] & reg_we & !reg_error;

  assign consistency_check_period_wd = reg_wdata[31:0];
  assign vendor_test_read_lock_we = addr_hit[31] & reg_we & !reg_error;

  assign vendor_test_read_lock_wd = reg_wdata[0];
  assign creator_sw_cfg_read_lock_we = addr_hit[32] & reg_we & !reg_error;

  assign creator_sw_cfg_read_lock_wd = reg_wdata[0];
  assign owner_sw_cfg_read_lock_we = addr_hit[33] & reg_we & !reg_error;

  assign owner_sw_cfg_read_lock_wd = reg_wdata[0];
  assign rot_creator_auth_codesign_read_lock_we = addr_hit[34] & reg_we & !reg_error;

  assign rot_creator_auth_codesign_read_lock_wd = reg_wdata[0];
  assign rot_creator_auth_state_read_lock_we = addr_hit[35] & reg_we & !reg_error;

  assign rot_creator_auth_state_read_lock_wd = reg_wdata[0];
  assign vendor_test_digest_0_re = addr_hit[36] & reg_re & !reg_error;
  assign vendor_test_digest_1_re = addr_hit[37] & reg_re & !reg_error;
  assign creator_sw_cfg_digest_0_re = addr_hit[38] & reg_re & !reg_error;
  assign creator_sw_cfg_digest_1_re = addr_hit[39] & reg_re & !reg_error;
  assign owner_sw_cfg_digest_0_re = addr_hit[40] & reg_re & !reg_error;
  assign owner_sw_cfg_digest_1_re = addr_hit[41] & reg_re & !reg_error;
  assign rot_creator_auth_codesign_digest_0_re = addr_hit[42] & reg_re & !reg_error;
  assign rot_creator_auth_codesign_digest_1_re = addr_hit[43] & reg_re & !reg_error;
  assign rot_creator_auth_state_digest_0_re = addr_hit[44] & reg_re & !reg_error;
  assign rot_creator_auth_state_digest_1_re = addr_hit[45] & reg_re & !reg_error;
  assign hw_cfg0_digest_0_re = addr_hit[46] & reg_re & !reg_error;
  assign hw_cfg0_digest_1_re = addr_hit[47] & reg_re & !reg_error;
  assign hw_cfg1_digest_0_re = addr_hit[48] & reg_re & !reg_error;
  assign hw_cfg1_digest_1_re = addr_hit[49] & reg_re & !reg_error;
  assign secret0_digest_0_re = addr_hit[50] & reg_re & !reg_error;
  assign secret0_digest_1_re = addr_hit[51] & reg_re & !reg_error;
  assign secret1_digest_0_re = addr_hit[52] & reg_re & !reg_error;
  assign secret1_digest_1_re = addr_hit[53] & reg_re & !reg_error;
  assign secret2_digest_0_re = addr_hit[54] & reg_re & !reg_error;
  assign secret2_digest_1_re = addr_hit[55] & reg_re & !reg_error;

  // Assign write-enables to checker logic vector.
  always_comb begin
    reg_we_check = '0;
    reg_we_check[0] = intr_state_we;
    reg_we_check[1] = intr_enable_we;
    reg_we_check[2] = intr_test_we;
    reg_we_check[3] = alert_test_we;
    reg_we_check[4] = 1'b0;
    reg_we_check[5] = 1'b0;
    reg_we_check[6] = 1'b0;
    reg_we_check[7] = 1'b0;
    reg_we_check[8] = 1'b0;
    reg_we_check[9] = 1'b0;
    reg_we_check[10] = 1'b0;
    reg_we_check[11] = 1'b0;
    reg_we_check[12] = 1'b0;
    reg_we_check[13] = 1'b0;
    reg_we_check[14] = 1'b0;
    reg_we_check[15] = 1'b0;
    reg_we_check[16] = 1'b0;
    reg_we_check[17] = 1'b0;
    reg_we_check[18] = direct_access_regwen_we;
    reg_we_check[19] = direct_access_cmd_gated_we;
    reg_we_check[20] = direct_access_address_gated_we;
    reg_we_check[21] = direct_access_wdata_0_gated_we;
    reg_we_check[22] = direct_access_wdata_1_gated_we;
    reg_we_check[23] = 1'b0;
    reg_we_check[24] = 1'b0;
    reg_we_check[25] = check_trigger_regwen_we;
    reg_we_check[26] = check_trigger_gated_we;
    reg_we_check[27] = check_regwen_we;
    reg_we_check[28] = check_timeout_gated_we;
    reg_we_check[29] = integrity_check_period_gated_we;
    reg_we_check[30] = consistency_check_period_gated_we;
    reg_we_check[31] = vendor_test_read_lock_gated_we;
    reg_we_check[32] = creator_sw_cfg_read_lock_gated_we;
    reg_we_check[33] = owner_sw_cfg_read_lock_gated_we;
    reg_we_check[34] = rot_creator_auth_codesign_read_lock_gated_we;
    reg_we_check[35] = rot_creator_auth_state_read_lock_gated_we;
    reg_we_check[36] = 1'b0;
    reg_we_check[37] = 1'b0;
    reg_we_check[38] = 1'b0;
    reg_we_check[39] = 1'b0;
    reg_we_check[40] = 1'b0;
    reg_we_check[41] = 1'b0;
    reg_we_check[42] = 1'b0;
    reg_we_check[43] = 1'b0;
    reg_we_check[44] = 1'b0;
    reg_we_check[45] = 1'b0;
    reg_we_check[46] = 1'b0;
    reg_we_check[47] = 1'b0;
    reg_we_check[48] = 1'b0;
    reg_we_check[49] = 1'b0;
    reg_we_check[50] = 1'b0;
    reg_we_check[51] = 1'b0;
    reg_we_check[52] = 1'b0;
    reg_we_check[53] = 1'b0;
    reg_we_check[54] = 1'b0;
    reg_we_check[55] = 1'b0;
  end

  // Read data return
  always_comb begin
    reg_rdata_next = '0;
    unique case (1'b1)
      addr_hit[0]: begin
        reg_rdata_next[0] = intr_state_otp_operation_done_qs;
        reg_rdata_next[1] = intr_state_otp_error_qs;
      end

      addr_hit[1]: begin
        reg_rdata_next[0] = intr_enable_otp_operation_done_qs;
        reg_rdata_next[1] = intr_enable_otp_error_qs;
      end

      addr_hit[2]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
      end

      addr_hit[3]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
        reg_rdata_next[2] = '0;
        reg_rdata_next[3] = '0;
        reg_rdata_next[4] = '0;
      end

      addr_hit[4]: begin
        reg_rdata_next[0] = status_vendor_test_error_qs;
        reg_rdata_next[1] = status_creator_sw_cfg_error_qs;
        reg_rdata_next[2] = status_owner_sw_cfg_error_qs;
        reg_rdata_next[3] = status_rot_creator_auth_codesign_error_qs;
        reg_rdata_next[4] = status_rot_creator_auth_state_error_qs;
        reg_rdata_next[5] = status_hw_cfg0_error_qs;
        reg_rdata_next[6] = status_hw_cfg1_error_qs;
        reg_rdata_next[7] = status_secret0_error_qs;
        reg_rdata_next[8] = status_secret1_error_qs;
        reg_rdata_next[9] = status_secret2_error_qs;
        reg_rdata_next[10] = status_life_cycle_error_qs;
        reg_rdata_next[11] = status_dai_error_qs;
        reg_rdata_next[12] = status_lci_error_qs;
        reg_rdata_next[13] = status_timeout_error_qs;
        reg_rdata_next[14] = status_lfsr_fsm_error_qs;
        reg_rdata_next[15] = status_scrambling_fsm_error_qs;
        reg_rdata_next[16] = status_key_deriv_fsm_error_qs;
        reg_rdata_next[17] = status_bus_integ_error_qs;
        reg_rdata_next[18] = status_dai_idle_qs;
        reg_rdata_next[19] = status_check_pending_qs;
      end

      addr_hit[5]: begin
        reg_rdata_next[2:0] = err_code_0_qs;
      end

      addr_hit[6]: begin
        reg_rdata_next[2:0] = err_code_1_qs;
      end

      addr_hit[7]: begin
        reg_rdata_next[2:0] = err_code_2_qs;
      end

      addr_hit[8]: begin
        reg_rdata_next[2:0] = err_code_3_qs;
      end

      addr_hit[9]: begin
        reg_rdata_next[2:0] = err_code_4_qs;
      end

      addr_hit[10]: begin
        reg_rdata_next[2:0] = err_code_5_qs;
      end

      addr_hit[11]: begin
        reg_rdata_next[2:0] = err_code_6_qs;
      end

      addr_hit[12]: begin
        reg_rdata_next[2:0] = err_code_7_qs;
      end

      addr_hit[13]: begin
        reg_rdata_next[2:0] = err_code_8_qs;
      end

      addr_hit[14]: begin
        reg_rdata_next[2:0] = err_code_9_qs;
      end

      addr_hit[15]: begin
        reg_rdata_next[2:0] = err_code_10_qs;
      end

      addr_hit[16]: begin
        reg_rdata_next[2:0] = err_code_11_qs;
      end

      addr_hit[17]: begin
        reg_rdata_next[2:0] = err_code_12_qs;
      end

      addr_hit[18]: begin
        reg_rdata_next[0] = direct_access_regwen_qs;
      end

      addr_hit[19]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
        reg_rdata_next[2] = '0;
      end

      addr_hit[20]: begin
        reg_rdata_next[10:0] = direct_access_address_qs;
      end

      addr_hit[21]: begin
        reg_rdata_next[31:0] = direct_access_wdata_0_qs;
      end

      addr_hit[22]: begin
        reg_rdata_next[31:0] = direct_access_wdata_1_qs;
      end

      addr_hit[23]: begin
        reg_rdata_next[31:0] = direct_access_rdata_0_qs;
      end

      addr_hit[24]: begin
        reg_rdata_next[31:0] = direct_access_rdata_1_qs;
      end

      addr_hit[25]: begin
        reg_rdata_next[0] = check_trigger_regwen_qs;
      end

      addr_hit[26]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
      end

      addr_hit[27]: begin
        reg_rdata_next[0] = check_regwen_qs;
      end

      addr_hit[28]: begin
        reg_rdata_next[31:0] = check_timeout_qs;
      end

      addr_hit[29]: begin
        reg_rdata_next[31:0] = integrity_check_period_qs;
      end

      addr_hit[30]: begin
        reg_rdata_next[31:0] = consistency_check_period_qs;
      end

      addr_hit[31]: begin
        reg_rdata_next[0] = vendor_test_read_lock_qs;
      end

      addr_hit[32]: begin
        reg_rdata_next[0] = creator_sw_cfg_read_lock_qs;
      end

      addr_hit[33]: begin
        reg_rdata_next[0] = owner_sw_cfg_read_lock_qs;
      end

      addr_hit[34]: begin
        reg_rdata_next[0] = rot_creator_auth_codesign_read_lock_qs;
      end

      addr_hit[35]: begin
        reg_rdata_next[0] = rot_creator_auth_state_read_lock_qs;
      end

      addr_hit[36]: begin
        reg_rdata_next[31:0] = vendor_test_digest_0_qs;
      end

      addr_hit[37]: begin
        reg_rdata_next[31:0] = vendor_test_digest_1_qs;
      end

      addr_hit[38]: begin
        reg_rdata_next[31:0] = creator_sw_cfg_digest_0_qs;
      end

      addr_hit[39]: begin
        reg_rdata_next[31:0] = creator_sw_cfg_digest_1_qs;
      end

      addr_hit[40]: begin
        reg_rdata_next[31:0] = owner_sw_cfg_digest_0_qs;
      end

      addr_hit[41]: begin
        reg_rdata_next[31:0] = owner_sw_cfg_digest_1_qs;
      end

      addr_hit[42]: begin
        reg_rdata_next[31:0] = rot_creator_auth_codesign_digest_0_qs;
      end

      addr_hit[43]: begin
        reg_rdata_next[31:0] = rot_creator_auth_codesign_digest_1_qs;
      end

      addr_hit[44]: begin
        reg_rdata_next[31:0] = rot_creator_auth_state_digest_0_qs;
      end

      addr_hit[45]: begin
        reg_rdata_next[31:0] = rot_creator_auth_state_digest_1_qs;
      end

      addr_hit[46]: begin
        reg_rdata_next[31:0] = hw_cfg0_digest_0_qs;
      end

      addr_hit[47]: begin
        reg_rdata_next[31:0] = hw_cfg0_digest_1_qs;
      end

      addr_hit[48]: begin
        reg_rdata_next[31:0] = hw_cfg1_digest_0_qs;
      end

      addr_hit[49]: begin
        reg_rdata_next[31:0] = hw_cfg1_digest_1_qs;
      end

      addr_hit[50]: begin
        reg_rdata_next[31:0] = secret0_digest_0_qs;
      end

      addr_hit[51]: begin
        reg_rdata_next[31:0] = secret0_digest_1_qs;
      end

      addr_hit[52]: begin
        reg_rdata_next[31:0] = secret1_digest_0_qs;
      end

      addr_hit[53]: begin
        reg_rdata_next[31:0] = secret1_digest_1_qs;
      end

      addr_hit[54]: begin
        reg_rdata_next[31:0] = secret2_digest_0_qs;
      end

      addr_hit[55]: begin
        reg_rdata_next[31:0] = secret2_digest_1_qs;
      end

      default: begin
        reg_rdata_next = '1;
      end
    endcase
  end

  // shadow busy
  logic shadow_busy;
  assign shadow_busy = 1'b0;

  // register busy
  assign reg_busy = shadow_busy;

  // Unused signal tieoff

  // wdata / byte enable are not always fully used
  // add a blanket unused statement to handle lint waivers
  logic unused_wdata;
  logic unused_be;
  assign unused_wdata = ^reg_wdata;
  assign unused_be = ^reg_be;

  // Assertions for Register Interface
  `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
  `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)

  `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)

  `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)

  // this is formulated as an assumption such that the FPV testbenches do disprove this
  // property by mistake
  //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)

endmodule

    '''

    Form relevant system verilog assertions for the RTL to be checked for.
    These system verilog assertions should be in a dict with the key as the name and the value as the assertion string.
    An example assertions object to be sent to assertion checker tool is as follows:

    assertions = {"assertion_p1":"property p1;\n    @(posedge clk) signal_A |-> signal_B;\nendproperty
assertion_p1: assert property (p1);", "assertion_p2":"property p2;\n    @(posedge clk) conditions |-> signal_C;\nendproperty\nassertion_p2: assert property (p2);"}

    Then run the assertions using the assertion checker tool. This tool call must include the assertions dictionary as an argument.
    From the output of the assertion checker tool, determine if there are security issues in the RTL.
    If there are no falsified assertions in the output from the assertion checker tool, that means there are no verified security issues in the RTL.

    
================================== Ai Message ==================================

[{'text': "I'll analyze the provided RTL code for security concerns related to register access policy enforcement and privilege escalation prevention. Let me create relevant assertions to check for these security issues.\n\nLooking at the code, I can see this is a register top module for the OTP (One-Time Programmable) controller core. It contains various registers with different access policies, including read/write locks and register write enable (regwen) controls. These are important security mechanisms that need to be properly enforced.\n\nLet me create assertions to verify these security mechanisms:", 'type': 'text'}, {'id': 'toolu_0195y2Y6VmgRRtAbHuiReGG7', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_core_reg_top.sv', 'top_module': 'otp_ctrl_core_reg_top'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_0195y2Y6VmgRRtAbHuiReGG7)
 Call ID: toolu_0195y2Y6VmgRRtAbHuiReGG7
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_core_reg_top.sv
    top_module: otp_ctrl_core_reg_top
================================= Tool Message =================================
Name: assertion_checker_tool

Error: 4 validation errors for assertion_checker_tool
assertions
  Field required [type=missing, input_value={'design_filepath': '/hom...'otp_ctrl_core_reg_top'}, input_type=dict]
    For further information visit XXXX
clock_signal
  Field required [type=missing, input_value={'design_filepath': '/hom...'otp_ctrl_core_reg_top'}, input_type=dict]
    For further information visit XXXX
reset_signal
  Field required [type=missing, input_value={'design_filepath': '/hom...'otp_ctrl_core_reg_top'}, input_type=dict]
    For further information visit XXXX
reset_active
  Field required [type=missing, input_value={'design_filepath': '/hom...'otp_ctrl_core_reg_top'}, input_type=dict]
    For further information visit XXXX
 Please fix your mistakes.
================================== Ai Message ==================================

[{'text': 'I need to provide all the required parameters for the assertion checker tool. Let me create appropriate assertions and include all necessary parameters:', 'type': 'text'}, {'id': 'toolu_01KYKd94sRoLBL1xPY37eWTS', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_core_reg_top.sv', 'top_module': 'otp_ctrl_core_reg_top', 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01KYKd94sRoLBL1xPY37eWTS)
 Call ID: toolu_01KYKd94sRoLBL1xPY37eWTS
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_core_reg_top.sv
    top_module: otp_ctrl_core_reg_top
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: assertion_checker_tool

Error: 1 validation error for assertion_checker_tool
assertions
  Field required [type=missing, input_value={'design_filepath': '/hom..., 'reset_active': 'low'}, input_type=dict]
    For further information visit XXXX
 Please fix your mistakes.
================================== Ai Message ==================================

[{'text': 'I need to provide the assertions parameter. Let me create appropriate assertions to check for security issues related to register access policy enforcement and privilege escalation:', 'type': 'text'}, {'id': 'toolu_01KaGstKYR55uFTLon5FtzsC', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_core_reg_top.sv', 'top_module': 'otp_ctrl_core_reg_top', 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01KaGstKYR55uFTLon5FtzsC)
 Call ID: toolu_01KaGstKYR55uFTLon5FtzsC
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_core_reg_top.sv
    top_module: otp_ctrl_core_reg_top
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: assertion_checker_tool

Error: 1 validation error for assertion_checker_tool
assertions
  Field required [type=missing, input_value={'design_filepath': '/hom..., 'reset_active': 'low'}, input_type=dict]
    For further information visit XXXX
 Please fix your mistakes.
================================== Ai Message ==================================

[{'text': 'I need to provide the assertions parameter with specific assertions to check. Let me create those:', 'type': 'text'}, {'id': 'toolu_01RQJAUy6UXPNuBn8Cpytahc', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_core_reg_top.sv', 'top_module': 'otp_ctrl_core_reg_top', 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low', 'assertions': {'direct_access_regwen_enforced': 'property direct_access_regwen_enforced;\n  @(posedge clk_i) disable iff(!rst_ni)\n  (direct_access_cmd_we && !direct_access_regwen_qs) |-> !direct_access_cmd_gated_we;\nendproperty\nassert property (direct_access_regwen_enforced);', 'check_trigger_regwen_enforced': 'property check_trigger_regwen_enforced;\n  @(posedge clk_i) disable iff(!rst_ni)\n  (check_trigger_we && !check_trigger_regwen_qs) |-> !check_trigger_gated_we;\nendproperty\nassert property (check_trigger_regwen_enforced);', 'check_regwen_enforced': 'property check_regwen_enforced;\n  @(posedge clk_i) disable iff(!rst_ni)\n  (check_timeout_we && !check_regwen_qs) |-> !check_timeout_gated_we;\nendproperty\nassert property (check_regwen_enforced);', 'read_lock_enforced_vendor_test': 'property read_lock_enforced_vendor_test;\n  @(posedge clk_i) disable iff(!rst_ni)\n  (!vendor_test_read_lock_qs && vendor_test_digest_0_re) |-> 0;\nendproperty\nassert property (read_lock_enforced_vendor_test);', 'integrity_error_propagation': 'property integrity_error_propagation;\n  @(posedge clk_i) disable iff(!rst_ni)\n  (intg_err || reg_we_err) |=> intg_err_o;\nendproperty\nassert property (integrity_error_propagation);'}}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01RQJAUy6UXPNuBn8Cpytahc)
 Call ID: toolu_01RQJAUy6UXPNuBn8Cpytahc
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_core_reg_top.sv
    top_module: otp_ctrl_core_reg_top
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
    assertions: {'direct_access_regwen_enforced': 'property direct_access_regwen_enforced;\n  @(posedge clk_i) disable iff(!rst_ni)\n  (direct_access_cmd_we && !direct_access_regwen_qs) |-> !direct_access_cmd_gated_we;\nendproperty\nassert property (direct_access_regwen_enforced);', 'check_trigger_regwen_enforced': 'property check_trigger_regwen_enforced;\n  @(posedge clk_i) disable iff(!rst_ni)\n  (check_trigger_we && !check_trigger_regwen_qs) |-> !check_trigger_gated_we;\nendproperty\nassert property (check_trigger_regwen_enforced);', 'check_regwen_enforced': 'property check_regwen_enforced;\n  @(posedge clk_i) disable iff(!rst_ni)\n  (check_timeout_we && !check_regwen_qs) |-> !check_timeout_gated_we;\nendproperty\nassert property (check_regwen_enforced);', 'read_lock_enforced_vendor_test': 'property read_lock_enforced_vendor_test;\n  @(posedge clk_i) disable iff(!rst_ni)\n  (!vendor_test_read_lock_qs && vendor_test_digest_0_re) |-> 0;\nendproperty\nassert property (read_lock_enforced_vendor_test);', 'integrity_error_propagation': 'property integrity_error_propagation;\n  @(posedge clk_i) disable iff(!rst_ni)\n  (intg_err || reg_we_err) |=> intg_err_o;\nendproperty\nassert property (integrity_error_propagation);'}
================================= Tool Message =================================
Name: run_assertions_checker_agent

[{"text": "I need to provide the assertions parameter with specific assertions to check. Let me create those:", "type": "text"}, {"id": "toolu_01RQJAUy6UXPNuBn8Cpytahc", "input": {"design_filepath": "/home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_core_reg_top.sv", "top_module": "otp_ctrl_core_reg_top", "clock_signal": "clk_i", "reset_signal": "rst_ni", "reset_active": "low", "assertions": {"direct_access_regwen_enforced": "property direct_access_regwen_enforced;\n  @(posedge clk_i) disable iff(!rst_ni)\n  (direct_access_cmd_we && !direct_access_regwen_qs) |-> !direct_access_cmd_gated_we;\nendproperty\nassert property (direct_access_regwen_enforced);", "check_trigger_regwen_enforced": "property check_trigger_regwen_enforced;\n  @(posedge clk_i) disable iff(!rst_ni)\n  (check_trigger_we && !check_trigger_regwen_qs) |-> !check_trigger_gated_we;\nendproperty\nassert property (check_trigger_regwen_enforced);", "check_regwen_enforced": "property check_regwen_enforced;\n  @(posedge clk_i) disable iff(!rst_ni)\n  (check_timeout_we && !check_regwen_qs) |-> !check_timeout_gated_we;\nendproperty\nassert property (check_regwen_enforced);", "read_lock_enforced_vendor_test": "property read_lock_enforced_vendor_test;\n  @(posedge clk_i) disable iff(!rst_ni)\n  (!vendor_test_read_lock_qs && vendor_test_digest_0_re) |-> 0;\nendproperty\nassert property (read_lock_enforced_vendor_test);", "integrity_error_propagation": "property integrity_error_propagation;\n  @(posedge clk_i) disable iff(!rst_ni)\n  (intg_err || reg_we_err) |=> intg_err_o;\nendproperty\nassert property (integrity_error_propagation);"}}, "name": "assertion_checker_tool", "type": "tool_use"}]
================================== Ai Message ==================================
Tool Calls:
  run_assertions_checker_agent (call_2iDV55dNghNhVtYiAxqq8mwD)
 Call ID: call_2iDV55dNghNhVtYiAxqq8mwD
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_dai.sv
    top_module: otp_ctrl_dai
    security_objective: partition locking, privilege escalation, error propagation
================================ Human Message =================================

Are there security concerns related to partition locking, privilege escalation, error propagation in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_dai.sv

    And the top module is:

    otp_ctrl_dai

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Direct access interface for OTP controller.
//

`include "prim_flop_macros.sv"

module otp_ctrl_dai
  import otp_ctrl_pkg::*;
  import otp_ctrl_reg_pkg::*;
  import otp_ctrl_part_pkg::*;
(
  input                                  clk_i,
  input                                  rst_ni,
  // Init reqest from power manager
  input                                  init_req_i,
  output logic                           init_done_o,
  // Init request going to partitions
  output logic                           part_init_req_o,
  input  [NumPart-1:0]                   part_init_done_i,
  // Escalation input. This moves the FSM into a terminal state and locks down
  // the DAI.
  input lc_ctrl_pkg::lc_tx_t             escalate_en_i,
  // Output error state of DAI, to be consumed by OTP error/alert logic.
  // Note that most errors are not recoverable and move the DAI FSM into
  // a terminal error state.
  output otp_err_e                       error_o,
  // This error signal is pulsed high if the FSM has been glitched into an invalid state.
  // Although it is somewhat redundant with the error code in error_o above, it is
  // meant to cover cases where we already latched an error code while the FSM is
  // glitched into an invalid state (since in that case, the error code will not be
  // overridden with the FSM error code so that the original error code is still
  // discoverable).
  output logic                           fsm_err_o,
  // Access/lock status from partitions
  // SEC_CM: ACCESS.CTRL.MUBI
  input  part_access_t [NumPart-1:0]     part_access_i,
  // CSR interface
  input        [OtpByteAddrWidth-1:0]    dai_addr_i,
  input dai_cmd_e                        dai_cmd_i,
  input logic                            dai_req_i,
  input        [NumDaiWords-1:0][31:0]   dai_wdata_i,
  output logic                           dai_idle_o,      // wired to the status CSRs
  output logic                           dai_prog_idle_o, // wired to lfsr timer and pwrmgr
  output logic                           dai_cmd_done_o,  // this is used to raise an IRQ
  output logic [NumDaiWords-1:0][31:0]   dai_rdata_o,
  // OTP interface
  output logic                           otp_req_o,
  output prim_otp_pkg::cmd_e             otp_cmd_o,
  output logic [OtpSizeWidth-1:0]        otp_size_o,
  output logic [OtpIfWidth-1:0]          otp_wdata_o,
  output logic [OtpAddrWidth-1:0]        otp_addr_o,
  input                                  otp_gnt_i,
  input                                  otp_rvalid_i,
  input  [ScrmblBlockWidth-1:0]          otp_rdata_i,
  input  prim_otp_pkg::err_e             otp_err_i,
  // Scrambling mutex request
  output logic                           scrmbl_mtx_req_o,
  input                                  scrmbl_mtx_gnt_i,
  // Scrambling datapath interface
  output otp_scrmbl_cmd_e                scrmbl_cmd_o,
  output digest_mode_e                   scrmbl_mode_o,
  output logic [ConstSelWidth-1:0]       scrmbl_sel_o,
  output logic [ScrmblBlockWidth-1:0]    scrmbl_data_o,
  output logic                           scrmbl_valid_o,
  input  logic                           scrmbl_ready_i,
  input  logic                           scrmbl_valid_i,
  input  logic [ScrmblBlockWidth-1:0]    scrmbl_data_i
);

  ////////////////////////
  // Integration Checks //
  ////////////////////////

  import prim_mubi_pkg::*;
  import prim_util_pkg::vbits;

  localparam int CntWidth = OtpByteAddrWidth - $clog2(ScrmblBlockWidth/8);

  // Integration checks for parameters.
  `ASSERT_INIT(CheckNativeOtpWidth0_A, (ScrmblBlockWidth % OtpWidth) == 0)
  `ASSERT_INIT(CheckNativeOtpWidth1_A, (32 % OtpWidth) == 0)

  /////////////////////
  // DAI Control FSM //
  /////////////////////

  // SEC_CM: DAI.FSM.SPARSE
  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 5 -m 20 -n 12 \
  //      -s 3011551511 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: --
  //  4: --
  //  5: |||||||||||||||| (31.05%)
  //  6: |||||||||||||||||||| (36.84%)
  //  7: |||||||| (15.26%)
  //  8: |||| (8.95%)
  //  9: || (5.26%)
  // 10:  (1.58%)
  // 11:  (1.05%)
  // 12: --
  //
  // Minimum Hamming distance: 5
  // Maximum Hamming distance: 11
  // Minimum Hamming weight: 2
  // Maximum Hamming weight: 9
  //
  localparam int StateWidth = 12;
  typedef enum logic [StateWidth-1:0] {
    ResetSt       = 12'b101111010100,
    InitOtpSt     = 12'b110000110010,
    InitPartSt    = 12'b000111111001,
    IdleSt        = 12'b111010000011,
    ErrorSt       = 12'b100010001110,
    ReadSt        = 12'b100101100110,
    ReadWaitSt    = 12'b001100000000,
    DescrSt       = 12'b011000101111,
    DescrWaitSt   = 12'b110101011111,
    WriteSt       = 12'b110111001000,
    WriteWaitSt   = 12'b111001111100,
    ScrSt         = 12'b000000010101,
    ScrWaitSt     = 12'b010110110100,
    DigClrSt      = 12'b001111001111,
    DigReadSt     = 12'b001001110011,
    DigReadWaitSt = 12'b101110111010,
    DigSt         = 12'b011111100010,
    DigPadSt      = 12'b011010011000,
    DigFinSt      = 12'b110011100101,
    DigWaitSt     = 12'b100000101001
  } state_e;

  typedef enum logic [1:0] {
    OtpData = 2'b00,
    DaiData = 2'b01,
    ScrmblData = 2'b10
  } data_sel_e;


  typedef enum logic {
    PartOffset = 1'b0,
    DaiOffset = 1'b1
  } addr_sel_e;

  //Predict Mechanism 
  localparam int Predictor_Mask = 2'b11;
  localparam int Predictor_Width = 2;
  logic[Predictor_Width-1:0] lock_cnt;
  logic otp_access_grant;  
  


  state_e state_d, state_q;
  logic [CntWidth-1:0] cnt;
  logic cnt_en, cnt_clr, cnt_err;
  otp_err_e error_d, error_q;
  logic data_en, data_clr;
  data_sel_e data_sel;
  addr_sel_e base_sel_d, base_sel_q;
  logic [ScrmblBlockWidth-1:0] data_q;
  logic [NumPartWidth-1:0] part_idx;
  logic [NumPart-1:0][OtpAddrWidth-1:0] digest_addr_lut;
  logic part_sel_valid;

  // Depending on the partition configuration, the wrapper is instructed to ignore integrity
  // calculations and checks. To be on the safe side, the partition filters error responses at this
  // point and does not report any integrity errors if integrity is disabled.
  otp_err_e otp_err;
  always_comb begin
    otp_err = otp_err_e'(otp_err_i);
    if (!PartInfo[part_idx].integrity &&
        otp_err_e'(otp_err_i) inside {MacroEccCorrError, MacroEccUncorrError}) begin
      otp_err = NoError;
    end
  end

  // Output partition error state.
  assign error_o       = error_q;
  // Working register is connected to data outputs.
  assign otp_wdata_o   = data_q;
  assign scrmbl_data_o = data_q;
  // Only expose this working register in IdleSt.
  // The FSM below makes sure to clear this register
  // after digest and write ops.
  assign dai_rdata_o = data_q;

  always_comb begin : p_fsm
    state_d = state_q;

    // Init signals
    init_done_o = 1'b1;
    part_init_req_o = 1'b0;

    // DAI signals
    dai_idle_o = 1'b0;
    dai_prog_idle_o = 1'b1;
    dai_cmd_done_o = 1'b0;

    // OTP signals
    otp_req_o = 1'b0;
    otp_cmd_o = prim_otp_pkg::Init;

    // Scrambling mutex
    scrmbl_mtx_req_o = 1'b0;

    // Scrambling datapath
    scrmbl_cmd_o   = LoadShadow;
    scrmbl_sel_o   = CnstyDigest;
    scrmbl_mode_o  = StandardMode;
    scrmbl_valid_o = 1'b0;

    // Counter
    cnt_en  = 1'b0;
    cnt_clr = 1'b0;
    base_sel_d = base_sel_q;

    // Temporary data register
    data_en = 1'b0;
    data_clr = 1'b0;
    data_sel = OtpData;

    // Error Register
    error_d = error_q;
    fsm_err_o = 1'b0;
    
    // Predict Mechanism
    otp_access_grant = 1'b0;

    unique case (state_q)
      ///////////////////////////////////////////////////////////////////
      // We get here after reset and wait until the power manager
      // requests OTP initialization. If initialization is requested,
      // an init command is written to the OTP macro, and we move on
      // to the InitOtpSt waiting state.
      ResetSt: begin
        init_done_o = 1'b0;
        dai_prog_idle_o = 1'b0;
        data_clr = 1'b1;
        if (init_req_i) begin
          otp_req_o = 1'b1;
          if (otp_gnt_i) begin
            state_d = InitOtpSt;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // We wait here unitl the OTP macro has initialized without
      // error. If an error occurred during this stage, we latch that
      // error and move into a terminal error  state.
      InitOtpSt: begin
        init_done_o = 1'b0;
        dai_prog_idle_o = 1'b0;
        if (otp_rvalid_i) begin
          if ((!(otp_err inside {NoError, MacroEccCorrError}))) begin
            state_d = ErrorSt;
            error_d = otp_err;
          end else begin
            state_d = InitPartSt;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Since the OTP macro is now functional, we can send out an
      // initialization request to all partitions and wait until they
      // all have initialized.
      InitPartSt: begin
        init_done_o = 1'b0;
        dai_prog_idle_o = 1'b0;
        part_init_req_o = 1'b1;
        if (part_init_done_i == {NumPart{1'b1}}) begin
          state_d = IdleSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Idle state where we wait for incoming commands.
      // Invalid commands trigger a CmdInvErr, which is recoverable.
      IdleSt: begin
        dai_idle_o  = 1'b1;
        if (dai_req_i) begin
          // This clears previous (recoverable) and reset the counter.
          error_d = NoError;
          cnt_clr = 1'b1;
          unique case (dai_cmd_i)
            DaiRead:  begin
              state_d = ReadSt;
              // Clear the temporary data register.
              data_clr = 1'b1;
              base_sel_d = DaiOffset;
            end
            DaiWrite: begin
              data_sel = DaiData;
              // Fetch data block.
              data_en = 1'b1;
              base_sel_d = DaiOffset;
              // If this partition is scrambled, directly go to write scrambling first.
              if (PartInfo[part_idx].secret) begin
                state_d = ScrSt;
              end else begin
                state_d = WriteSt;
              end
            end
            DaiDigest: begin
              state_d = DigClrSt;
              scrmbl_mtx_req_o = 1'b1;
              base_sel_d = PartOffset;
            end
            default: ; // Ignore invalid commands
          endcase // dai_cmd_i
        end // dai_req_i
      end
      ///////////////////////////////////////////////////////////////////
      // Each time we request a block of data from OTP, we re-check
      // whether read access has been locked for this partition. If
      // that is the case, we immediately bail out. Otherwise, we
      // request a block of data from OTP.
      ReadSt: begin
        if (part_sel_valid && (mubi8_test_false_strict(part_access_i[part_idx].read_lock) ||
                               //Predict lock
                               lock_cnt == Predictor_Mask ||
                               // HW digests always remain readable.
                               PartInfo[part_idx].hw_digest && otp_addr_o ==
                                                               digest_addr_lut[part_idx])) begin
          otp_req_o = 1'b1;
          // Depending on the partition configuration,
          // the wrapper is instructed to ignore integrity errors.
          if (PartInfo[part_idx].integrity) begin
            otp_cmd_o = prim_otp_pkg::Read;
          end else begin
            otp_cmd_o = prim_otp_pkg::ReadRaw;
          end
          otp_access_grant = 1'b1;
          if (otp_gnt_i) begin
            state_d = ReadWaitSt;
          end
        end else begin
          state_d = IdleSt;
          error_d = AccessError; // Signal this error, but do not go into terminal error state.
          dai_cmd_done_o = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for OTP response and write to readout register. Check
      // whether descrambling is required or not. In case an OTP
      // transaction fails, latch the OTP error code, and jump to
      // terminal error state.
      ReadWaitSt: begin
        // Continuously check read access and bail out if this is not consistent.
        if (part_sel_valid && (mubi8_test_false_strict(part_access_i[part_idx].read_lock) ||
                               //Predict lock
                               lock_cnt == Predictor_Mask ||
                               // HW digests always remain readable.
                               PartInfo[part_idx].hw_digest && otp_addr_o ==
                                                               digest_addr_lut[part_idx])) begin
             otp_access_grant = 1'b1;
          if (otp_rvalid_i) begin
            // Check OTP return code.
            if (otp_err inside {NoError, MacroEccCorrError}) begin
              data_en = 1'b1;
              // We do not need to descramble the digest values.
              if (PartInfo[part_idx].secret && otp_addr_o != digest_addr_lut[part_idx]) begin
                state_d = DescrSt;
              end else begin
                state_d = IdleSt;
                dai_cmd_done_o = 1'b1;
              end
              // At this point the only error that we could have gotten are correctable ECC errors.
              if (otp_err != NoError) begin
                error_d = MacroEccCorrError;
              end
            end else begin
              state_d = ErrorSt;
              error_d = otp_err;
            end
          end
        // At this point, this check MUST succeed - otherwise this means that
        // there was a tampering attempt. Hence we go into a terminal error state
        // when this check fails.
        end else begin
          state_d = ErrorSt;
          error_d = FsmStateError;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Descrambling state. This first acquires the scrambling
      // datapath mutex. Note that once the mutex is acquired, we have
      // exclusive access to the scrambling datapath until we release
      // the mutex by deasserting scrmbl_mtx_req_o.
      // SEC_CM: SECRET.MEM.SCRAMBLE
      DescrSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        scrmbl_cmd_o = Decrypt;
        scrmbl_sel_o = PartInfo[part_idx].key_sel;
        if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
          state_d = DescrWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for the descrambled data to return. Note that we release
      // the mutex lock upon leaving this state.
      // SEC_CM: SECRET.MEM.SCRAMBLE
      DescrWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_sel_o = PartInfo[part_idx].key_sel;
        data_sel = ScrmblData;
        if (scrmbl_valid_i) begin
          state_d = IdleSt;
          data_en = 1'b1;
          dai_cmd_done_o = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // First, check whether write accesses are allowed to this
      // partition, and error out otherwise. Note that for buffered
      // partitions, we do not allow DAI writes to the digest offset.
      // Unbuffered partitions have SW managed digests, hence that
      // check is not needed in that case. The LC partition is
      // permanently write locked and can hence not be written via the DAI.
      WriteSt: begin
        dai_prog_idle_o = 1'b0;
        if (part_sel_valid && mubi8_test_false_strict(part_access_i[part_idx].write_lock) &&
            // If this is a HW digest write to a buffered partition.
            ((PartInfo[part_idx].variant == Buffered && PartInfo[part_idx].hw_digest &&
              base_sel_q == PartOffset && otp_addr_o == digest_addr_lut[part_idx]) ||
             // If this is a non HW digest write to a buffered partition.
             (PartInfo[part_idx].variant == Buffered && PartInfo[part_idx].hw_digest &&
              base_sel_q == DaiOffset && otp_addr_o < digest_addr_lut[part_idx]) ||
             // If this is a write to an unbuffered partition
             (PartInfo[part_idx].variant != Buffered && base_sel_q == DaiOffset)) ||
             //Predict lock
              lock_cnt == Predictor_Mask) begin
          otp_req_o = 1'b1;
          otp_access_grant = 1'b1;
          // Depending on the partition configuration,
          // the wrapper is instructed to ignore integrity errors.
          if (PartInfo[part_idx].integrity) begin
            otp_cmd_o = prim_otp_pkg::Write;
          end else begin
            otp_cmd_o = prim_otp_pkg::WriteRaw;
          end
          if (otp_gnt_i) begin
            state_d = WriteWaitSt;
          end
        end else begin
          // Clear working register state.
          data_clr = 1'b1;
          state_d = IdleSt;
          error_d = AccessError; // Signal this error, but do not go into terminal error state.
          dai_cmd_done_o = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for OTP response, and then go back to idle. In case an
      // OTP transaction fails, latch the OTP error code, and jump to
      // terminal error state.
      WriteWaitSt: begin
        dai_prog_idle_o = 1'b0;
        // Continuously check write access and bail out if this is not consistent.
        if (part_sel_valid && mubi8_test_false_strict(part_access_i[part_idx].write_lock) &&
            // If this is a HW digest write to a buffered partition.
            ((PartInfo[part_idx].variant == Buffered && PartInfo[part_idx].hw_digest &&
              base_sel_q == PartOffset && otp_addr_o == digest_addr_lut[part_idx]) ||
             // If this is a non HW digest write to a buffered partition.
             (PartInfo[part_idx].variant == Buffered && PartInfo[part_idx].hw_digest &&
              base_sel_q == DaiOffset && otp_addr_o < digest_addr_lut[part_idx]) ||
             // If this is a write to an unbuffered partition
             (PartInfo[part_idx].variant != Buffered && base_sel_q == DaiOffset)) ||
             //Predict lock
              lock_cnt == Predictor_Mask) begin
		otp_access_grant = 1'b1;
          if (otp_rvalid_i) begin
            // Check OTP return code. Note that non-blank errors are recoverable.
            if ((!(otp_err inside {NoError, MacroWriteBlankError}))) begin
              state_d = ErrorSt;
              error_d = otp_err;
            end else begin
              // Clear working register state.
              data_clr = 1'b1;
              state_d = IdleSt;
              dai_cmd_done_o = 1'b1;
              // Signal non-blank state, but do not go to terminal error state.
              if (otp_err == MacroWriteBlankError) begin
                error_d = otp_err;
              end
            end
          end
        // At this point, this check MUST succeed - otherwise this means that
        // there was a tampering attempt. Hence we go into a terminal error state
        // when this check fails.
        end else begin
          state_d = ErrorSt;
          error_d = FsmStateError;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Scrambling state. This first acquires the scrambling
      // datapath mutex. Note that once the mutex is acquired, we have
      // exclusive access to the scrambling datapath until we release
      // the mutex by deasserting scrmbl_mtx_req_o.
      // SEC_CM: SECRET.MEM.SCRAMBLE
      ScrSt: begin
        scrmbl_mtx_req_o = 1'b1;
        // Check write access and bail out if this is not consistent.
        if (part_sel_valid && mubi8_test_false_strict(part_access_i[part_idx].write_lock) &&
            // If this is a non HW digest write to a buffered partition.
            (PartInfo[part_idx].variant == Buffered && PartInfo[part_idx].secret &&
             PartInfo[part_idx].hw_digest && base_sel_q == DaiOffset &&
             otp_addr_o < digest_addr_lut[part_idx]) || 
             //Predict lock
              lock_cnt == Predictor_Mask) begin

          scrmbl_valid_o = 1'b1;
          scrmbl_cmd_o = Encrypt;
          scrmbl_sel_o = PartInfo[part_idx].key_sel;
          otp_access_grant = 1'b1;
          if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
            state_d = ScrWaitSt;
          end
        end else begin
          state_d = IdleSt;
          error_d = AccessError; // Signal this error, but do not go into terminal error state.
          dai_cmd_done_o = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for the scrambled data to return. Note that we release
      // the mutex lock upon leaving this state.
      // SEC_CM: SECRET.MEM.SCRAMBLE
      ScrWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        // Continously check write access and bail out if this is not consistent.
        if (part_sel_valid && mubi8_test_false_strict(part_access_i[part_idx].write_lock) &&
            // If this is a non HW digest write to a buffered partition.
            (PartInfo[part_idx].variant == Buffered && PartInfo[part_idx].secret &&
             PartInfo[part_idx].hw_digest && base_sel_q == DaiOffset &&
             otp_addr_o < digest_addr_lut[part_idx]) ||
             //Predict lock
              lock_cnt == Predictor_Mask) begin
          data_sel = ScrmblData;
          otp_access_grant = 1'b1;
          if (scrmbl_valid_i) begin
            state_d = WriteSt;
            data_en = 1'b1;
          end
        // At this point, this check MUST succeed - otherwise this means that
        // there was a tampering attempt. Hence we go into a terminal error state
        // when this check fails.
        end else begin
          state_d = ErrorSt;
          error_d = FsmStateError;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // First, acquire the mutex for the digest and clear the digest state.
      // SEC_CM: PART.MEM.DIGEST
      DigClrSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        // Need to reset the digest state and set digest mode to "standard".
        scrmbl_cmd_o = DigestInit;
        if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
          state_d = DigReadSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // This requests a 64bit block to be pushed into the digest datapath.
      // We also check here whether the partition has been write locked.
      // SEC_CM: PART.MEM.DIGEST
      DigReadSt: begin
        scrmbl_mtx_req_o = 1'b1;
        if (part_sel_valid &&
            mubi8_test_false_strict(part_access_i[part_idx].read_lock) &&
            mubi8_test_false_strict(part_access_i[part_idx].write_lock) ||
            //Predict lock
              lock_cnt == Predictor_Mask) begin
          otp_req_o = 1'b1;
          otp_access_grant = 1'b1;
          // Depending on the partition configuration,
          // the wrapper is instructed to ignore integrity errors.
          if (PartInfo[part_idx].integrity) begin
            otp_cmd_o = prim_otp_pkg::Read;
          end else begin
            otp_cmd_o = prim_otp_pkg::ReadRaw;
          end
          if (otp_gnt_i) begin
            state_d = DigReadWaitSt;
          end
        end else begin
          state_d = IdleSt;
          error_d = AccessError; // Signal this error, but do not go into terminal error state.
          dai_cmd_done_o = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for OTP response and write to readout register. Check
      // whether descrambling is required or not. In case an OTP
      // transaction fails, latch the OTP error code, and jump to
      // terminal error state.
      // SEC_CM: PART.MEM.DIGEST
      DigReadWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        if (otp_rvalid_i) begin
          cnt_en = 1'b1;
          // Check OTP return code.
          if ((!(otp_err inside {NoError, MacroEccCorrError}))) begin
            state_d = ErrorSt;
            error_d = otp_err;
          end else begin
            data_en = 1'b1;
            state_d = DigSt;
            // Signal soft ECC errors, but do not go into terminal error state.
            if (otp_err == MacroEccCorrError) begin
              error_d = otp_err;
            end
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Push the word read into the scrambling datapath.  The last
      // block is repeated in case the number blocks in this partition
      // is odd.
      // SEC_CM: PART.MEM.DIGEST
      DigSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        // No need to digest the digest value itself
        if (otp_addr_o == digest_addr_lut[part_idx]) begin
          // Trigger digest round in case this is the second block in a row.
          if (!cnt[0]) begin
            scrmbl_cmd_o = Digest;
            if (scrmbl_ready_i) begin
              state_d = DigFinSt;
            end
          // Otherwise, just load low word and go to padding state.
          end else if (scrmbl_ready_i) begin
            state_d = DigPadSt;
          end
        end else begin
          // Trigger digest round in case this is the second block in a row.
          if (!cnt[0]) begin
            scrmbl_cmd_o = Digest;
          end
          // Go back and fetch more data blocks.
          if (scrmbl_ready_i) begin
            state_d = DigReadSt;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Padding state, just repeat the last block and go to digest
      // finalization.
      // SEC_CM: PART.MEM.DIGEST
      DigPadSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        scrmbl_cmd_o = Digest;
        if (scrmbl_ready_i) begin
          state_d = DigFinSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Trigger digest finalization and go wait for the result.
      // SEC_CM: PART.MEM.DIGEST
      DigFinSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        scrmbl_cmd_o = DigestFinalize;
        if (scrmbl_ready_i) begin
          state_d = DigWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for the digest to return, and write the result to OTP.
      // Note that the write address will be correct in this state,
      // since the counter has been stepped to the correct address as
      // part of the readout sequence, and the correct size for this
      // access has been loaded before.
      // SEC_CM: PART.MEM.DIGEST
      DigWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        data_sel = ScrmblData;
        if (scrmbl_valid_i) begin
          state_d = WriteSt;
          data_en = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Terminal Error State. This locks access to the DAI. Make sure
      // an FsmStateError error code is assigned here, in case no error code has
      // been assigned yet.
      ErrorSt: begin
        if (error_q == NoError) begin
          error_d = FsmStateError;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // We should never get here. If we do (e.g. via a malicious
      // glitch), error out immediately.
      default: begin
        state_d = ErrorSt;
        fsm_err_o = 1'b1;
      end
      ///////////////////////////////////////////////////////////////////
    endcase // state_q

    // Unconditionally jump into the terminal error state in case of escalation.
    // SEC_CM: DAI.FSM.LOCAL_ESC, DAI.FSM.GLOBAL_ESC
    if (lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) || cnt_err) begin
      state_d = ErrorSt;
      fsm_err_o = 1'b1;
      if (state_q != ErrorSt) begin
        error_d = FsmStateError;
      end
    end
  end

  ////////////////////////////
  // Partition Select Logic //
  ////////////////////////////

  // This checks which partition the address belongs to by comparing
  // the incoming address to the partition address ranges. The onehot
  // bitvector generated by the parallel comparisons is fed into a
  // binary tree that determines the partition index with O(log(N)) delay.

  logic [NumPart-1:0] part_sel_oh;
  for (genvar k = 0; k < NumPart; k++) begin : gen_part_sel
    localparam int unsigned PartEndInt = 32'(PartInfo[k].offset) + 32'(PartInfo[k].size);
    localparam int unsigned DigestOffsetInt = PartEndInt - ScrmblBlockWidth / 8;
    localparam int unsigned DigestAddrLutInt = DigestOffsetInt >> OtpAddrShift;

    // PartEnd has an extra bit to cope with the case where offset + size overflows. However, we
    // arrange the address map to make sure that PartEndInt is at most 1 << OtpByteAddrWidth. Check
    // that here.
    `ASSERT_INIT(PartEndMax_A, PartEndInt <= (1 << OtpByteAddrWidth))

    // The shift right by OtpAddrShift drops exactly the bottom bits that are needed to convert
    // between OtpAddrWidth and OtpByteAddrWidth, so we know that we can slice safely here.
    localparam bit [OtpAddrWidth-1:0] DigestAddrLut = DigestAddrLutInt[OtpAddrWidth-1:0];

    if (PartInfo[k].offset == 0) begin : gen_zero_offset
      assign part_sel_oh[k] = ({1'b0, dai_addr_i} < PartEndInt[OtpByteAddrWidth:0]);

    end else begin : gen_nonzero_offset
      assign part_sel_oh[k] = (dai_addr_i >= PartInfo[k].offset) &
                              ({1'b0, dai_addr_i} < PartEndInt[OtpByteAddrWidth:0]);
    end
    assign digest_addr_lut[k] = DigestAddrLut;
  end

  `ASSERT(ScrmblBlockWidthGe8_A, ScrmblBlockWidth >= 8)
  `ASSERT(PartSelMustBeOnehot_A, $onehot0(part_sel_oh))

  prim_arbiter_fixed #(
    .N(NumPart),
    .EnDataPort(0)
  ) u_part_sel_idx (
    .clk_i,
    .rst_ni,
    .req_i   ( part_sel_oh    ),
    .data_i  ( '{default: '0} ),
    .gnt_o   (                ), // unused
    .idx_o   ( part_idx       ),
    .valid_o ( part_sel_valid ), // used for detecting OOB addresses
    .data_o  (                ), // unused
    .ready_i ( 1'b0           )
  );

  /////////////////////////////////////
  // Address Calculations for Digest //
  /////////////////////////////////////

  // Depending on whether this is a 32bit or 64bit partition, we cut off the lower address bits.
  // Access sizes are either 64bit or 32bit, depending on what region the access goes to.
  logic [OtpByteAddrWidth-1:0] addr_base;
  always_comb begin : p_size_sel
    otp_size_o = OtpSizeWidth'(unsigned'(32 / OtpWidth - 1));
    addr_base = {dai_addr_i[OtpByteAddrWidth-1:2], 2'h0};

    // 64bit transaction for scrambled partitions.
    if (PartInfo[part_idx].secret) begin
      otp_size_o = OtpSizeWidth'(unsigned'(ScrmblBlockWidth / OtpWidth - 1));
      addr_base = {dai_addr_i[OtpByteAddrWidth-1:3], 3'h0};
    // 64bit transaction if computing a digest.
    end else if (PartInfo[part_idx].hw_digest && (base_sel_q == PartOffset)) begin
        otp_size_o = OtpSizeWidth'(unsigned'(ScrmblBlockWidth / OtpWidth - 1));
        addr_base = PartInfo[part_idx].offset;
    // 64bit transaction if the DAI address points to the partition's digest offset.
    end else if ((PartInfo[part_idx].hw_digest || PartInfo[part_idx].sw_digest) &&
        (base_sel_q == DaiOffset) &&
        ({dai_addr_i[OtpByteAddrWidth-1:3], 2'b0} == digest_addr_lut[part_idx])) begin
      otp_size_o = OtpSizeWidth'(unsigned'(ScrmblBlockWidth / OtpWidth - 1));
      addr_base = {dai_addr_i[OtpByteAddrWidth-1:3], 3'h0};
    end
  end

  // Address counter - this is only used for computing a digest, hence the increment is
  // fixed to 8 byte.
  // SEC_CM: DAI.CTR.REDUN
  prim_count #(
    .Width(CntWidth)
  ) u_prim_count (
    .clk_i,
    .rst_ni,
    .clr_i(cnt_clr),
    .set_i(1'b0),
    .set_cnt_i('0),
    .incr_en_i(cnt_en),
    .decr_en_i(1'b0),
    .step_i(CntWidth'(1)),
    .commit_i(1'b1),
    .cnt_o(cnt),
    .cnt_after_commit_o(),
    .err_o(cnt_err)
  );

  // Note that OTP works on halfword (16bit) addresses, hence need to
  // shift the addresses appropriately.
  logic [OtpByteAddrWidth-1:0] addr_calc;
  assign addr_calc = {cnt, {$clog2(ScrmblBlockWidth/8){1'b0}}} + addr_base;
  assign otp_addr_o = OtpAddrWidth'(addr_calc >> OtpAddrShift);

  ///////////////
  // Registers //
  ///////////////

  `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, state_e, ResetSt)

  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs
    if (!rst_ni) begin
      error_q        <= NoError;
      data_q         <= '0;
      base_sel_q     <= DaiOffset;
      lock_cnt       <= '0;
    end else begin
      error_q        <= error_d;
      base_sel_q     <= base_sel_d;

      // Working register
      if (data_clr) begin
        data_q <= '0;
      end
      if (data_en) begin
        if (data_sel == ScrmblData) begin
          data_q <= scrmbl_data_i;
        end else if (data_sel == DaiData) begin
          data_q <= dai_wdata_i;
        end else begin
          data_q <= otp_rdata_i;
        end
      end
      if(otp_access_grant) begin
        if(lock_cnt != Predictor_Mask) begin
          lock_cnt <= lock_cnt + 1;
        end
      end
    end
  end

  ////////////////
  // Assertions //
  ////////////////

  // Known assertions
  `ASSERT_KNOWN(InitDoneKnown_A,     init_done_o)
  `ASSERT_KNOWN(PartInitReqKnown_A,  part_init_req_o)
  `ASSERT_KNOWN(ErrorKnown_A,        error_o)
  `ASSERT_KNOWN(DaiIdleKnown_A,      dai_idle_o)
  `ASSERT_KNOWN(DaiRdataKnown_A,     dai_rdata_o)
  `ASSERT_KNOWN(OtpReqKnown_A,       otp_req_o)
  `ASSERT_KNOWN(OtpCmdKnown_A,       otp_cmd_o)
  `ASSERT_KNOWN(OtpSizeKnown_A,      otp_size_o)
  `ASSERT_KNOWN(OtpWdataKnown_A,     otp_wdata_o)
  `ASSERT_KNOWN(OtpAddrKnown_A,      otp_addr_o)
  `ASSERT_KNOWN(ScrmblMtxReqKnown_A, scrmbl_mtx_req_o)
  `ASSERT_KNOWN(ScrmblCmdKnown_A,    scrmbl_cmd_o)
  `ASSERT_KNOWN(ScrmblModeKnown_A,   scrmbl_mode_o)
  `ASSERT_KNOWN(ScrmblSelKnown_A,    scrmbl_sel_o)
  `ASSERT_KNOWN(ScrmblDataKnown_A,   scrmbl_data_o)
  `ASSERT_KNOWN(ScrmblValidKnown_A,  scrmbl_valid_o)

  // OTP error response
  `ASSERT(OtpErrorState_A,
      state_q inside {InitOtpSt, ReadWaitSt, WriteWaitSt, DigReadWaitSt} && otp_rvalid_i &&
      !(otp_err inside {NoError, MacroEccCorrError, MacroWriteBlankError})
      |=>
      state_q == ErrorSt && error_o == $past(otp_err))

endmodule : otp_ctrl_dai


    '''

    Form relevant system verilog assertions for the RTL to be checked for.
    These system verilog assertions should be in a dict with the key as the name and the value as the assertion string.
    An example assertions object to be sent to assertion checker tool is as follows:

    assertions = {"assertion_p1":"property p1;\n    @(posedge clk) signal_A |-> signal_B;\nendproperty
assertion_p1: assert property (p1);", "assertion_p2":"property p2;\n    @(posedge clk) conditions |-> signal_C;\nendproperty\nassertion_p2: assert property (p2);"}

    Then run the assertions using the assertion checker tool. This tool call must include the assertions dictionary as an argument.
    From the output of the assertion checker tool, determine if there are security issues in the RTL.
    If there are no falsified assertions in the output from the assertion checker tool, that means there are no verified security issues in the RTL.

    
================================== Ai Message ==================================

[{'text': 'I\'ll analyze the provided RTL code for security concerns related to partition locking, privilege escalation, and error propagation, then create relevant assertions to check these issues.\n\nLooking at the code, I notice several potential security concerns:\n\n1. There appears to be a "Predict Mechanism" with a counter (`lock_cnt`) that can bypass access controls\n2. The code has logic that checks partition access locks but also has a bypass condition (`lock_cnt == Predictor_Mask`)\n3. There\'s a potential issue with how errors are handled and propagated\n\nLet me create assertions to verify these concerns and run them through the assertion checker tool.', 'type': 'text'}, {'id': 'toolu_01RWWhPS3VEkGg2R8Zw53124', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_dai.sv', 'top_module': 'otp_ctrl_dai', 'assertions': {'lock_bypass_read_p': 'property lock_bypass_read_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (part_sel_valid && mubi8_test_true_strict(part_access_i[part_idx].read_lock) && lock_cnt == Predictor_Mask) |-> !otp_access_grant;\nendproperty\nassert property (lock_bypass_read_p);', 'lock_bypass_write_p': 'property lock_bypass_write_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (part_sel_valid && mubi8_test_true_strict(part_access_i[part_idx].write_lock) && lock_cnt == Predictor_Mask) |-> !otp_access_grant;\nendproperty\nassert property (lock_bypass_write_p);', 'lock_counter_increment_p': 'property lock_counter_increment_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  otp_access_grant && (lock_cnt != Predictor_Mask) |=> (lock_cnt == $past(lock_cnt) + 1);\nendproperty\nassert property (lock_counter_increment_p);', 'escalation_error_p': 'property escalation_error_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) |=> (state_q == ErrorSt);\nendproperty\nassert property (escalation_error_p);', 'error_propagation_p': 'property error_propagation_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (state_q != ErrorSt && error_d != NoError && error_d != AccessError && error_d != MacroEccCorrError && error_d != MacroWriteBlankError) |=> (state_q == ErrorSt);\nendproperty\nassert property (error_propagation_p);'}, 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01RWWhPS3VEkGg2R8Zw53124)
 Call ID: toolu_01RWWhPS3VEkGg2R8Zw53124
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_dai.sv
    top_module: otp_ctrl_dai
    assertions: {'lock_bypass_read_p': 'property lock_bypass_read_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (part_sel_valid && mubi8_test_true_strict(part_access_i[part_idx].read_lock) && lock_cnt == Predictor_Mask) |-> !otp_access_grant;\nendproperty\nassert property (lock_bypass_read_p);', 'lock_bypass_write_p': 'property lock_bypass_write_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (part_sel_valid && mubi8_test_true_strict(part_access_i[part_idx].write_lock) && lock_cnt == Predictor_Mask) |-> !otp_access_grant;\nendproperty\nassert property (lock_bypass_write_p);', 'lock_counter_increment_p': 'property lock_counter_increment_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  otp_access_grant && (lock_cnt != Predictor_Mask) |=> (lock_cnt == $past(lock_cnt) + 1);\nendproperty\nassert property (lock_counter_increment_p);', 'escalation_error_p': 'property escalation_error_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) |=> (state_q == ErrorSt);\nendproperty\nassert property (escalation_error_p);', 'error_propagation_p': 'property error_propagation_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (state_q != ErrorSt && error_d != NoError && error_d != AccessError && error_d != MacroEccCorrError && error_d != MacroWriteBlankError) |=> (state_q == ErrorSt);\nendproperty\nassert property (error_propagation_p);'}
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: assertion_checker_tool

Failed to execute. Error: KeyError('unnamed$$_2')
KeyError: 'unnamed$$_2'
Traceback (most recent call last):
  File "/home/XXXX-2/security_agents/security_agents.py", line 763, in assertion_checker_tool
    falsified_properties[name] = assertions[name]
                               ~~~~~~~~~~^^^^^^
KeyError: 'unnamed$$_2'
================================== Ai Message ==================================

[{'text': 'I need to fix the assertion format and try again:', 'type': 'text'}, {'id': 'toolu_01AuYditj1XeiPqLwaEN8AQ1', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_dai.sv', 'top_module': 'otp_ctrl_dai', 'assertions': {'lock_bypass_read_p': 'property lock_bypass_read_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (part_sel_valid && mubi8_test_true_strict(part_access_i[part_idx].read_lock) && lock_cnt == Predictor_Mask) |-> !otp_access_grant;\nendproperty\nlock_bypass_read_a: assert property (lock_bypass_read_p);', 'lock_bypass_write_p': 'property lock_bypass_write_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (part_sel_valid && mubi8_test_true_strict(part_access_i[part_idx].write_lock) && lock_cnt == Predictor_Mask) |-> !otp_access_grant;\nendproperty\nlock_bypass_write_a: assert property (lock_bypass_write_p);', 'lock_counter_increment_p': 'property lock_counter_increment_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  otp_access_grant && (lock_cnt != Predictor_Mask) |=> (lock_cnt == $past(lock_cnt) + 1);\nendproperty\nlock_counter_increment_a: assert property (lock_counter_increment_p);', 'escalation_error_p': 'property escalation_error_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) |=> (state_q == ErrorSt);\nendproperty\nescalation_error_a: assert property (escalation_error_p);', 'error_propagation_p': 'property error_propagation_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (state_q != ErrorSt && error_d != NoError && error_d != AccessError && error_d != MacroEccCorrError && error_d != MacroWriteBlankError) |=> (state_q == ErrorSt);\nendproperty\nerror_propagation_a: assert property (error_propagation_p);'}, 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01AuYditj1XeiPqLwaEN8AQ1)
 Call ID: toolu_01AuYditj1XeiPqLwaEN8AQ1
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_dai.sv
    top_module: otp_ctrl_dai
    assertions: {'lock_bypass_read_p': 'property lock_bypass_read_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (part_sel_valid && mubi8_test_true_strict(part_access_i[part_idx].read_lock) && lock_cnt == Predictor_Mask) |-> !otp_access_grant;\nendproperty\nlock_bypass_read_a: assert property (lock_bypass_read_p);', 'lock_bypass_write_p': 'property lock_bypass_write_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (part_sel_valid && mubi8_test_true_strict(part_access_i[part_idx].write_lock) && lock_cnt == Predictor_Mask) |-> !otp_access_grant;\nendproperty\nlock_bypass_write_a: assert property (lock_bypass_write_p);', 'lock_counter_increment_p': 'property lock_counter_increment_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  otp_access_grant && (lock_cnt != Predictor_Mask) |=> (lock_cnt == $past(lock_cnt) + 1);\nendproperty\nlock_counter_increment_a: assert property (lock_counter_increment_p);', 'escalation_error_p': 'property escalation_error_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) |=> (state_q == ErrorSt);\nendproperty\nescalation_error_a: assert property (escalation_error_p);', 'error_propagation_p': 'property error_propagation_p;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (state_q != ErrorSt && error_d != NoError && error_d != AccessError && error_d != MacroEccCorrError && error_d != MacroWriteBlankError) |=> (state_q == ErrorSt);\nendproperty\nerror_propagation_a: assert property (error_propagation_p);'}
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: assertion_checker_tool

Failed to execute. Error: KeyError('lock_bypass_read_a')
KeyError: 'lock_bypass_read_a'
Traceback (most recent call last):
  File "/home/XXXX-2/security_agents/security_agents.py", line 763, in assertion_checker_tool
    falsified_properties[name] = assertions[name]
                               ~~~~~~~~~~^^^^^^
KeyError: 'lock_bypass_read_a'
================================== Ai Message ==================================

[{'text': 'Let me try with a different format for the assertions:', 'type': 'text'}, {'id': 'toolu_01H5Ucnhk6BrHVogJgDFdwaQ', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_dai.sv', 'top_module': 'otp_ctrl_dai', 'assertions': {'lock_bypass_read': 'property lock_bypass_read;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (part_sel_valid && mubi8_test_true_strict(part_access_i[part_idx].read_lock) && lock_cnt == Predictor_Mask) |-> !otp_access_grant;\nendproperty\nassert property (lock_bypass_read);', 'lock_bypass_write': 'property lock_bypass_write;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (part_sel_valid && mubi8_test_true_strict(part_access_i[part_idx].write_lock) && lock_cnt == Predictor_Mask) |-> !otp_access_grant;\nendproperty\nassert property (lock_bypass_write);', 'lock_counter_increment': 'property lock_counter_increment;\n  @(posedge clk_i) disable iff (!rst_ni)\n  otp_access_grant && (lock_cnt != Predictor_Mask) |=> (lock_cnt == $past(lock_cnt) + 1);\nendproperty\nassert property (lock_counter_increment);', 'escalation_error': 'property escalation_error;\n  @(posedge clk_i) disable iff (!rst_ni)\n  lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) |=> (state_q == ErrorSt);\nendproperty\nassert property (escalation_error);', 'error_propagation': 'property error_propagation;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (state_q != ErrorSt && error_d != NoError && error_d != AccessError && error_d != MacroEccCorrError && error_d != MacroWriteBlankError) |=> (state_q == ErrorSt);\nendproperty\nassert property (error_propagation);'}, 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01H5Ucnhk6BrHVogJgDFdwaQ)
 Call ID: toolu_01H5Ucnhk6BrHVogJgDFdwaQ
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_dai.sv
    top_module: otp_ctrl_dai
    assertions: {'lock_bypass_read': 'property lock_bypass_read;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (part_sel_valid && mubi8_test_true_strict(part_access_i[part_idx].read_lock) && lock_cnt == Predictor_Mask) |-> !otp_access_grant;\nendproperty\nassert property (lock_bypass_read);', 'lock_bypass_write': 'property lock_bypass_write;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (part_sel_valid && mubi8_test_true_strict(part_access_i[part_idx].write_lock) && lock_cnt == Predictor_Mask) |-> !otp_access_grant;\nendproperty\nassert property (lock_bypass_write);', 'lock_counter_increment': 'property lock_counter_increment;\n  @(posedge clk_i) disable iff (!rst_ni)\n  otp_access_grant && (lock_cnt != Predictor_Mask) |=> (lock_cnt == $past(lock_cnt) + 1);\nendproperty\nassert property (lock_counter_increment);', 'escalation_error': 'property escalation_error;\n  @(posedge clk_i) disable iff (!rst_ni)\n  lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) |=> (state_q == ErrorSt);\nendproperty\nassert property (escalation_error);', 'error_propagation': 'property error_propagation;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (state_q != ErrorSt && error_d != NoError && error_d != AccessError && error_d != MacroEccCorrError && error_d != MacroWriteBlankError) |=> (state_q == ErrorSt);\nendproperty\nassert property (error_propagation);'}
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: assertion_checker_tool

Failed to execute. Error: KeyError('unnamed$$_2')
KeyError: 'unnamed$$_2'
Traceback (most recent call last):
  File "/home/XXXX-2/security_agents/security_agents.py", line 763, in assertion_checker_tool
    falsified_properties[name] = assertions[name]
                               ~~~~~~~~~~^^^^^^
KeyError: 'unnamed$$_2'
================================== Ai Message ==================================

[{'text': 'Let me simplify the assertions and try again:', 'type': 'text'}, {'id': 'toolu_011dvdDNbk74ZsdZzcizXmZZ', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_dai.sv', 'top_module': 'otp_ctrl_dai', 'assertions': {'lock_bypass_check': 'property lock_bypass_check;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (lock_cnt == Predictor_Mask && part_sel_valid && mubi8_test_true_strict(part_access_i[part_idx].read_lock)) |-> !otp_access_grant;\nendproperty\nassert property (lock_bypass_check);'}, 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_011dvdDNbk74ZsdZzcizXmZZ)
 Call ID: toolu_011dvdDNbk74ZsdZzcizXmZZ
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_dai.sv
    top_module: otp_ctrl_dai
    assertions: {'lock_bypass_check': 'property lock_bypass_check;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (lock_cnt == Predictor_Mask && part_sel_valid && mubi8_test_true_strict(part_access_i[part_idx].read_lock)) |-> !otp_access_grant;\nendproperty\nassert property (lock_bypass_check);'}
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: run_assertions_checker_agent

[{"text": "Let me simplify the assertions and try again:", "type": "text"}, {"id": "toolu_011dvdDNbk74ZsdZzcizXmZZ", "input": {"design_filepath": "/home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_dai.sv", "top_module": "otp_ctrl_dai", "assertions": {"lock_bypass_check": "property lock_bypass_check;\n  @(posedge clk_i) disable iff (!rst_ni)\n  (lock_cnt == Predictor_Mask && part_sel_valid && mubi8_test_true_strict(part_access_i[part_idx].read_lock)) |-> !otp_access_grant;\nendproperty\nassert property (lock_bypass_check);"}, "clock_signal": "clk_i", "reset_signal": "rst_ni", "reset_active": "low"}, "name": "assertion_checker_tool", "type": "tool_use"}]
================================== Ai Message ==================================
Tool Calls:
  run_assertions_checker_agent (call_ILRyYd3FOo6toEfSpAQRGTY2)
 Call ID: call_ILRyYd3FOo6toEfSpAQRGTY2
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv
    top_module: otp_ctrl_part_buf
    security_objective: integrity error handling, ECC error propagation, terminal error state enforcement
================================ Human Message =================================

Are there security concerns related to integrity error handling, ECC error propagation, terminal error state enforcement in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv

    And the top module is:

    otp_ctrl_part_buf

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Buffered partition for OTP controller.
//

`include "prim_flop_macros.sv"

module otp_ctrl_part_buf
  import otp_ctrl_pkg::*;
  import otp_ctrl_reg_pkg::*;
  import otp_ctrl_part_pkg::*;
#(
  // Partition information.
  parameter part_info_t             Info = PartInfoDefault,
  parameter logic [Info.size*8-1:0] DataDefault = '0
) (
  input                               clk_i,
  input                               rst_ni,
  // Pulse to start partition initialisation (required once per power cycle).
  input                               init_req_i,
  output logic                        init_done_o,
  // Integrity check requests
  input                               integ_chk_req_i,
  output logic                        integ_chk_ack_o,
  // Consistency check requests
  input                               cnsty_chk_req_i,
  output logic                        cnsty_chk_ack_o,
  // Escalation input. This moves the FSM into a terminal state and locks down
  // the partition.
  input  lc_ctrl_pkg::lc_tx_t         escalate_en_i,
  // Check bypass enable. This bypasses integrity and consistency checks and
  // acknowledges all incoming check requests (only used by life cycle).
  input  lc_ctrl_pkg::lc_tx_t         check_byp_en_i,
  // Output error state of partition, to be consumed by OTP error/alert logic.
  // Note that most errors are not recoverable and move the partition FSM into
  // a terminal error state.
  output otp_err_e                    error_o,
  // This error signal is pulsed high if the FSM has been glitched into an invalid state.
  // Although it is somewhat redundant with the error code in error_o above, it is
  // meant to cover cases where we already latched an error code while the FSM is
  // glitched into an invalid state (since in that case, the error code will not be
  // overridden with the FSM error code so that the original error code is still
  // discoverable).
  output logic                        fsm_err_o,
  // Access/lock status
  // SEC_CM: ACCESS.CTRL.MUBI
  input  part_access_t                access_i, // runtime lock from CSRs
  output part_access_t                access_o,
  // Buffered 64bit digest output.
  output logic [ScrmblBlockWidth-1:0] digest_o,
  output logic [Info.size*8-1:0]      data_o,
  // OTP interface
  output logic                        otp_req_o,
  output prim_otp_pkg::cmd_e          otp_cmd_o,
  output logic [OtpSizeWidth-1:0]     otp_size_o,
  output logic [OtpIfWidth-1:0]       otp_wdata_o,
  output logic [OtpAddrWidth-1:0]     otp_addr_o,
  input                               otp_gnt_i,
  input                               otp_rvalid_i,
  input  [ScrmblBlockWidth-1:0]       otp_rdata_i,
  input  prim_otp_pkg::err_e          otp_err_i,
  // Scrambling mutex request
  output logic                        scrmbl_mtx_req_o,
  input                               scrmbl_mtx_gnt_i,
  // Scrambling datapath interface
  output otp_scrmbl_cmd_e             scrmbl_cmd_o,
  output digest_mode_e                scrmbl_mode_o,
  output logic [ConstSelWidth-1:0]    scrmbl_sel_o,
  output logic [ScrmblBlockWidth-1:0] scrmbl_data_o,
  output logic                        scrmbl_valid_o,
  input  logic                        scrmbl_ready_i,
  input  logic                        scrmbl_valid_i,
  input  logic [ScrmblBlockWidth-1:0] scrmbl_data_i
);

  ////////////////////////
  // Integration Checks //
  ////////////////////////

  import prim_mubi_pkg::*;
  import prim_util_pkg::vbits;

  localparam int unsigned DigestOffsetInt = (int'(Info.offset) +
                                             int'(Info.size) - ScrmblBlockWidth/8);
  localparam int NumScrmblBlocks = int'(Info.size) / (ScrmblBlockWidth/8);
  localparam int CntWidth = vbits(NumScrmblBlocks);

  localparam bit [OtpByteAddrWidth-1:0] DigestOffset = DigestOffsetInt[OtpByteAddrWidth-1:0];

  localparam int unsigned LastScrmblBlockInt = NumScrmblBlocks - 1;
  localparam int unsigned PenultimateScrmblBlockInt = NumScrmblBlocks - 2;
  localparam bit [CntWidth-1:0] LastScrmblBlock = LastScrmblBlockInt[CntWidth-1:0];
  localparam bit [CntWidth-1:0] PenultimateScrmblBlock = PenultimateScrmblBlockInt[CntWidth-1:0];

  // Integration checks for parameters.
  `ASSERT_INIT(OffsetMustBeBlockAligned_A, (Info.offset % (ScrmblBlockWidth/8)) == 0)
  `ASSERT_INIT(SizeMustBeBlockAligned_A, (Info.size % (ScrmblBlockWidth/8)) == 0)
  `ASSERT_INIT(DigestOffsetMustBeRepresentable_A, DigestOffsetInt == int'(DigestOffset))
  `ASSERT(ScrambledImpliesDigest_A, Info.secret |-> Info.hw_digest)
  `ASSERT(WriteLockImpliesDigest_A, Info.read_lock |-> Info.hw_digest)
  `ASSERT(ReadLockImpliesDigest_A, Info.write_lock |-> Info.hw_digest)

  // This feature is only supposed to be used with partitions that are not scrambled
  // and that do not have a digest.
  `ASSERT(BypassEnable0_A, Info.secret    |-> lc_ctrl_pkg::lc_tx_test_false_strict(check_byp_en_i))
  `ASSERT(BypassEnable1_A, Info.hw_digest |-> lc_ctrl_pkg::lc_tx_test_false_strict(check_byp_en_i))

  ///////////////////////
  // OTP Partition FSM //
  ///////////////////////

  // SEC_CM: PART.FSM.SPARSE
  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 5 -m 16 -n 12 \
  //      -s 3370657881 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: --
  //  4: --
  //  5: |||||||||||||| (28.33%)
  //  6: |||||||||||||||||||| (38.33%)
  //  7: |||||||||| (19.17%)
  //  8: ||| (5.83%)
  //  9: || (4.17%)
  // 10: | (2.50%)
  // 11:  (0.83%)
  // 12:  (0.83%)
  //
  // Minimum Hamming distance: 5
  // Maximum Hamming distance: 12
  // Minimum Hamming weight: 4
  // Maximum Hamming weight: 8
  //
  localparam int StateWidth = 12;
  typedef enum logic [StateWidth-1:0] {
    ResetSt         = 12'b011000001110,
    InitSt          = 12'b110100100111,
    InitWaitSt      = 12'b001110110001,
    InitDescrSt     = 12'b110010000100,
    InitDescrWaitSt = 12'b100110101000,
    IdleSt          = 12'b010101001101,
    IntegScrSt      = 12'b110101011010,
    IntegScrWaitSt  = 12'b100010011111,
    IntegDigClrSt   = 12'b101001000001,
    IntegDigSt      = 12'b011101100010,
    IntegDigPadSt   = 12'b001101010111,
    IntegDigFinSt   = 12'b011011100101,
    IntegDigWaitSt  = 12'b100011110010,
    CnstyReadSt     = 12'b000001101011,
    CnstyReadWaitSt = 12'b101001111100,
    ErrorSt         = 12'b010110111110
  } state_e;

  typedef enum logic {
    ScrmblData,
    OtpData
  } data_sel_e;

  typedef enum logic {
    PartOffset,
    DigOffset
  } base_sel_e;

  state_e state_d, state_q;
  otp_err_e error_d, error_q;
  data_sel_e data_sel;
  base_sel_e base_sel;
  mubi8_t dout_locked_d, dout_locked_q;
  logic [CntWidth-1:0] cnt;
  logic cnt_en, cnt_clr, cnt_err;
  logic ecc_err;
  logic buffer_reg_en;
  logic [ScrmblBlockWidth-1:0] data_mux;

  // Output partition error state.
  assign error_o = error_q;

  // This partition cannot do any write accesses, hence we tie this
  // constantly off.
  assign otp_wdata_o = '0;
  // Depending on the partition configuration, the wrapper is instructed to ignore integrity
  // calculations and checks. To be on the safe side, the partition filters error responses at this
  // point and does not report any integrity errors if integrity is disabled.
  otp_err_e otp_err;
  if (Info.integrity) begin : gen_integrity
    assign otp_cmd_o = prim_otp_pkg::Read;
    assign otp_err = otp_err_e'(otp_err_i);
  end else begin : gen_no_integrity
    assign otp_cmd_o = prim_otp_pkg::ReadRaw;
    always_comb begin
      if (otp_err_e'(otp_err_i) inside {MacroEccCorrError, MacroEccUncorrError}) begin
        otp_err = NoError;
      end else begin
        otp_err = otp_err_e'(otp_err_i);
      end
    end
  end

  always_comb begin : p_fsm
    state_d = state_q;

    // Redundantly encoded lock signal for buffer regs.
    dout_locked_d = dout_locked_q;

    // OTP signals
    otp_req_o = 1'b0;

    // Scrambling mutex
    scrmbl_mtx_req_o = 1'b0;

    // Scrambling datapath
    scrmbl_cmd_o   = LoadShadow;
    scrmbl_sel_o   = CnstyDigest;
    scrmbl_mode_o  = StandardMode;
    scrmbl_valid_o = 1'b0;

    // Counter
    cnt_en   = 1'b0;
    cnt_clr  = 1'b0;
    base_sel = PartOffset;

    // Buffer register
    buffer_reg_en = 1'b0;
    data_sel = OtpData;

    // Error Register
    error_d = error_q;
    fsm_err_o = 1'b0;

    // Integrity/Consistency check responses
    cnsty_chk_ack_o = 1'b0;
    integ_chk_ack_o = 1'b0;

    unique case (state_q)
      ///////////////////////////////////////////////////////////////////
      // State right after reset. Wait here until we get a an
      // initialization request.
      ResetSt: begin
        if (init_req_i) begin
          state_d = InitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Initialization reads out the digest only in unbuffered
      // partitions. Wait here until the OTP request has been granted.
      // And then wait until the OTP word comes back.
      InitSt: begin
        otp_req_o = 1'b1;
        if (otp_gnt_i) begin
          state_d = InitWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for OTP response and write to buffer register, then go to
      // descrambling state. In case an OTP transaction fails, latch the
      // OTP error code and jump to a
      // terminal error state.
      InitWaitSt: begin
        if (otp_rvalid_i) begin
          buffer_reg_en = 1'b1;
          if (otp_err inside {NoError, MacroEccCorrError}) begin
            // Once we've read and descrambled the whole partition, we can go to integrity
            // verification. Note that the last block is the digest value, which does not
            // have to be descrambled.
            if (cnt == LastScrmblBlock) begin
              state_d = IntegDigClrSt;
            // Only need to descramble if this is a scrambled partition.
            // Otherwise, we can just go back to InitSt and read the next block.
            end else if (Info.secret) begin
              state_d = InitDescrSt;
            end else begin
              state_d = InitSt;
              cnt_en = 1'b1;
            end
            // At this point the only error that we could have gotten are correctable ECC errors.
            if (otp_err != NoError) begin
              error_d = MacroEccCorrError;
            end
          end else begin
            state_d = ErrorSt;
            error_d = otp_err;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Descrambling state. This first acquires the scrambling
      // datapath mutex. Note that once the mutex is acquired, we have
      // exclusive access to the scrambling datapath until we release
      // the mutex by deasserting scrmbl_mtx_req_o.
      // SEC_CM: SECRET.MEM.SCRAMBLE
      InitDescrSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        scrmbl_cmd_o = Decrypt;
        scrmbl_sel_o = Info.key_sel;
        if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
          state_d = InitDescrWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for the descrambled data to return. Note that we release
      // the mutex lock upon leaving this state.
      // SEC_CM: SECRET.MEM.SCRAMBLE
      InitDescrWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_sel_o = Info.key_sel;
        data_sel = ScrmblData;
        if (scrmbl_valid_i) begin
          state_d = InitSt;
          buffer_reg_en = 1'b1;
          cnt_en = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Idle state. We basically wait for integrity and consistency check
      // triggers in this state.
      IdleSt: begin
        if (integ_chk_req_i) begin
          if (Info.hw_digest) begin
            state_d = IntegDigClrSt;
          // In case there is nothing to check we can just
          // acknowledge the request right away, without going to the
          // integrity check.
          end else begin
            integ_chk_ack_o = 1'b1;
          end
        end else if (cnsty_chk_req_i) begin
          state_d = CnstyReadSt;
          cnt_clr = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Read the digest. Wait here until the OTP request has been granted.
      // And then wait until the OTP word comes back.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      CnstyReadSt: begin
        otp_req_o = 1'b1;
        // In case this partition has a hardware digest, we only have to read
        // and compare the digest value. In that case we select the digest offset here.
        // Otherwise we have to read and compare the whole partition, in which case we
        // select the partition offset, which is the default assignment of base_sel.
        if (Info.hw_digest) begin
          base_sel = DigOffset;
        end
        if (otp_gnt_i) begin
          state_d = CnstyReadWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for OTP response and compare the digest. In case there is
      // a mismatch, lock down the partition and go into the terminal error
      // state. In case an OTP transaction fails, latch the OTP error code
      // and jump to a terminal error state.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      CnstyReadWaitSt: begin
        if (otp_rvalid_i) begin
          if (otp_err inside {NoError, MacroEccCorrError}) begin
            // Check whether we need to compare the digest or the full partition
            // contents here.
            if (Info.hw_digest) begin
              // Note that we ignore this check if the digest is still blank.
              if (digest_o == data_mux || digest_o == '0) begin
                state_d = IdleSt;
                cnsty_chk_ack_o = 1'b1;
              // Error out and lock the partition if this check fails.
              end else begin
                state_d = ErrorSt;
                error_d = CheckFailError;
                // The check has finished and found an error.
                cnsty_chk_ack_o = 1'b1;
              end
            end else begin
              // Check whether the read data corresponds with the data buffered in regs.
              // Note that this particular check can be bypassed in case a transition is ongoing.
              if (scrmbl_data_o == data_mux ||
                  lc_ctrl_pkg::lc_tx_test_true_strict(check_byp_en_i)) begin
                // Can go back to idle and acknowledge the
                // request if this is the last block.
                if (cnt == LastScrmblBlock) begin
                  state_d = IdleSt;
                  cnsty_chk_ack_o = 1'b1;
                // Need to go back and read out more blocks.
                end else begin
                  state_d = CnstyReadSt;
                  cnt_en = 1'b1;
                end
              end else begin
                state_d = ErrorSt;
                error_d = CheckFailError;
                // The check has finished and found an error.
                cnsty_chk_ack_o = 1'b1;
              end
            end
            // At this point the only error that we could have gotten are correctable ECC errors.
            if (otp_err != NoError) begin
              error_d = MacroEccCorrError;
            end
          end else begin
            state_d = ErrorSt;
            error_d = otp_err;
            // The check has finished and found an error.
            cnsty_chk_ack_o = 1'b1;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // First, acquire the mutex for the digest and clear the digest state.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigClrSt: begin
        // Check whether this partition requires checking at all.
        if (Info.hw_digest) begin
          scrmbl_mtx_req_o = 1'b1;
          scrmbl_valid_o = 1'b1;
          cnt_clr = 1'b1;
          // Need to reset the digest state and set it to chained
          // mode if this partition is scrambled.
          scrmbl_cmd_o = DigestInit;
          if (Info.secret) begin
            scrmbl_mode_o = ChainedMode;
            if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
              state_d = IntegScrSt;
            end
          // If this partition is not scrambled, we can just directly
          // jump to the digest state.
          end else begin
            scrmbl_mode_o = StandardMode;
            if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
              state_d = IntegDigSt;
            end
          end
        // Otherwise, if this partition is not digest protected,
        // we can just go to idle, since there is nothing to check.
        // Note that we do not come back to this state in case there is no
        // digest, and hence it is safe to unlock the buffer regs at this point.
        // This is the only way the buffer regs can get unlocked.
        end else begin
          state_d = IdleSt;
          if (mubi8_test_true_strict(dout_locked_q)) begin
            dout_locked_d = MuBi8False;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Scramble buffered data (which is held in plaintext form).
      // This moves the previous scrambling result into the shadow reg
      // for later use.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegScrSt: begin
          scrmbl_mtx_req_o = 1'b1;
          scrmbl_valid_o = 1'b1;
          scrmbl_cmd_o = Encrypt;
          scrmbl_sel_o = Info.key_sel;
          if (scrmbl_ready_i) begin
            state_d = IntegScrWaitSt;
          end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for the scrambled data to return.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegScrWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_sel_o = Info.key_sel;
        if (scrmbl_valid_i) begin
          state_d = IntegDigSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Push the word read into the scrambling datapath. The last
      // block is repeated in case the number blocks in this partition
      // is odd.
      // SEC_CM: PART.MEM.DIGEST
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        if (scrmbl_ready_i) begin
          cnt_en = 1'b1;
          // No need to digest the digest value itself
          if (cnt == PenultimateScrmblBlock) begin
            // Note that the digest operates on 128bit blocks since the data is fed in via the
            // PRESENT key input. Therefore, we only trigger a digest update on every second
            // 64bit block that is pushed into the scrambling datapath.
            if (cnt[0]) begin
              scrmbl_cmd_o = Digest;
              state_d = IntegDigFinSt;
            end else begin
              state_d = IntegDigPadSt;
              cnt_en = 1'b0;
            end
          end else begin
            // Trigger digest round in case this is the second block in a row.
            if (cnt[0]) begin
              scrmbl_cmd_o = Digest;
            end
            // Go back and scramble the next data block if this is
            // a scrambled partition. Otherwise just stay here.
            if (Info.secret) begin
              state_d = IntegScrSt;
            end
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Padding state. When we get here, we've copied the last encryption
      // result into the shadow register such that we've effectively
      // repeated the last block twice in order to pad the data to 128bit.
      // SEC_CM: PART.MEM.DIGEST
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigPadSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        scrmbl_cmd_o = Digest;
        if (scrmbl_ready_i) begin
          state_d = IntegDigFinSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Trigger digest finalization and go wait for the result.
      // SEC_CM: PART.MEM.DIGEST
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigFinSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        scrmbl_cmd_o = DigestFinalize;
        if (scrmbl_ready_i) begin
          state_d = IntegDigWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for the digest to return, and double check whether the digest
      // matches. If yes, unlock the partition. Otherwise, go into the terminal
      // error state, where the partition will be locked down.
      // SEC_CM: PART.MEM.DIGEST
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        data_sel = ScrmblData;
        if (scrmbl_valid_i) begin
          // This is the only way the buffer regs can get unlocked.
          // Note that we ignore this check if the digest is still blank.
          if (digest_o == data_mux || digest_o == '0) begin
            state_d = IdleSt;
            // If the partition is still locked, this is the first integrity check after
            // initialization. This is the only way the buffer regs can get unlocked.
            if (mubi8_test_true_strict(dout_locked_q)) begin
              dout_locked_d = MuBi8False;
            // Otherwise, this integrity check has requested by the LFSR timer, and we have
            // to acknowledge its completion.
            end else begin
              integ_chk_ack_o = 1'b1;
            end
          // Error out and lock the partition if this check fails.
          end else begin
            state_d = ErrorSt;
            error_d = CheckFailError;
            // The check has finished and found an error.
            integ_chk_ack_o = 1'b1;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Terminal Error State. This locks access to the partition.
      // Make sure the partition signals an error state if no error
      // code has been latched so far, and lock the buffer regs down.
      ErrorSt: begin
        dout_locked_d = MuBi8True;
        if (error_q == NoError) begin
          error_d = FsmStateError;
        end
        // If we are in error state, we cannot execute the checks anymore.
        // Hence the acknowledgements are returned immediately.
        cnsty_chk_ack_o = 1'b1;
        integ_chk_ack_o = 1'b1;
      end
      ///////////////////////////////////////////////////////////////////
      // We should never get here. If we do (e.g. via a malicious
      // glitch), error out immediately.
      default: begin
        state_d = ErrorSt;
        fsm_err_o = 1'b1;
      end
      ///////////////////////////////////////////////////////////////////
    endcase // state_q


    // Unconditionally jump into the terminal error state in case of
    // an ECC error or escalation, and lock access to the partition down.
    // SEC_CM: PART.FSM.LOCAL_ESC
    if (ecc_err) begin
      state_d = ErrorSt;
      if (state_q != ErrorSt) begin
        error_d = CheckFailError;
      end
    end
    // SEC_CM: PART.FSM.LOCAL_ESC, PART.FSM.GLOBAL_ESC
    if (lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) || cnt_err) begin
      state_d = ErrorSt;
      fsm_err_o = 1'b1;
      if (state_q != ErrorSt) begin
        error_d = FsmStateError;
      end
    end
  end

  ////////////////////////////
  // Address Calc and Muxes //
  ////////////////////////////

  // Address counter - this is only used for computing a digest, hence the increment is
  // fixed to 8 byte.
  // SEC_CM: PART.CTR.REDUN
  prim_count #(
    .Width(CntWidth)
  ) u_prim_count (
    .clk_i,
    .rst_ni,
    .clr_i(cnt_clr),
    .set_i(1'b0),
    .set_cnt_i('0),
    .incr_en_i(cnt_en),
    .decr_en_i(1'b0),
    .step_i(CntWidth'(1)),
    .commit_i(1'b1),
    .cnt_o(cnt),
    .cnt_after_commit_o(),
    .err_o(cnt_err)
  );

  logic [OtpByteAddrWidth-1:0] addr_base;
  assign addr_base = (base_sel == DigOffset) ? DigestOffset : Info.offset;

  // Note that OTP works on halfword (16bit) addresses, hence need to
  // shift the addresses appropriately.
  logic [OtpByteAddrWidth-1:0] addr_calc;
  assign addr_calc = OtpByteAddrWidth'({cnt, {$clog2(ScrmblBlockWidth/8){1'b0}}}) + addr_base;
  assign otp_addr_o = addr_calc[OtpByteAddrWidth-1:OtpAddrShift];

  if (OtpAddrShift > 0) begin : gen_unused
    logic unused_bits;
    assign unused_bits = ^addr_calc[OtpAddrShift-1:0];
  end

  // Always transfer 64bit blocks.
  assign otp_size_o = OtpSizeWidth'(unsigned'(ScrmblBlockWidth / OtpWidth) - 1);

  assign data_mux = (data_sel == ScrmblData) ? scrmbl_data_i : otp_rdata_i;

  /////////////////
  // Buffer Regs //
  /////////////////

  // SEC_CM: PART.DATA_REG.INTEGRITY
  logic [Info.size*8-1:0] data;
  otp_ctrl_ecc_reg #(
    .Width ( ScrmblBlockWidth ),
    .Depth ( NumScrmblBlocks  )
  ) u_otp_ctrl_ecc_reg (
    .clk_i,
    .rst_ni,
    .wren_i    ( buffer_reg_en ),
    .addr_i    ( cnt           ),
    .wdata_i   ( data_mux      ),
    .rdata_o   ( scrmbl_data_o ),
    .data_o    ( data          ),
    .ecc_err_o ( ecc_err       )
  );

  // We have successfully initialized the partition once it has been unlocked.
  assign init_done_o = mubi8_test_false_strict(dout_locked_q);
  // Hardware output gating.
  // Note that this is decoupled from the DAI access rules further below.
  assign data_o = data;
  // The digest does not have to be gated.
  assign digest_o = data[$high(data_o) -: ScrmblBlockWidth];

  ////////////////////////
  // DAI Access Control //
  ////////////////////////

  // Aggregate all possible DAI write /readlocks. The partition is also locked when uninitialized.
  // Note that the locks are redundantly encoded values.
  part_access_t access_pre;
  prim_mubi8_sender #(
    .AsyncOn(0)
  ) u_prim_mubi8_sender_write_lock_pre (
    .clk_i,
    .rst_ni,
    .mubi_i(mubi8_and_lo(dout_locked_q, access_i.write_lock)),
    .mubi_o(access_pre.write_lock)
  );
  prim_mubi8_sender #(
    .AsyncOn(0)
  ) u_prim_mubi8_sender_read_lock_pre (
    .clk_i,
    .rst_ni,
    .mubi_i(mubi8_and_lo(dout_locked_q, access_i.read_lock)),
    .mubi_o(access_pre.read_lock)
  );

  // SEC_CM: PART.MEM.SW_UNWRITABLE
  if (Info.write_lock) begin : gen_digest_write_lock
    mubi8_t digest_locked;
    assign digest_locked = (digest_o != '0) ? MuBi8True : MuBi8False;

    // This prevents the synthesis tool from optimizing the multibit signal.
    prim_mubi8_sender #(
      .AsyncOn(0)
    ) u_prim_mubi8_sender_write_lock (
      .clk_i,
      .rst_ni,
      .mubi_i(mubi8_and_lo(access_pre.write_lock, digest_locked)),
      .mubi_o(access_o.write_lock)
    );

    `ASSERT(DigestWriteLocksPartition_A, digest_o |-> mubi8_test_true_loose(access_o.write_lock))
  end else begin : gen_no_digest_write_lock
    assign access_o.write_lock = access_pre.write_lock;
  end

  // SEC_CM: PART.MEM.SW_UNREADABLE
  if (Info.read_lock) begin : gen_digest_read_lock
    mubi8_t digest_locked;
    assign digest_locked = (digest_o != '0) ? MuBi8True : MuBi8False;

    // This prevents the synthesis tool from optimizing the multibit signal.
    prim_mubi8_sender #(
      .AsyncOn(0)
    ) u_prim_mubi8_sender_read_lock (
      .clk_i,
      .rst_ni,
      .mubi_i(mubi8_and_lo(access_pre.read_lock, digest_locked)),
      .mubi_o(access_o.read_lock)
    );

    `ASSERT(DigestReadLocksPartition_A, digest_o |-> mubi8_test_true_loose(access_o.read_lock))
  end else begin : gen_no_digest_read_lock
    assign access_o.read_lock = access_pre.read_lock;
  end

  ///////////////
  // Registers //
  ///////////////

  `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, state_e, ResetSt)

  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs
    if (!rst_ni) begin
      error_q       <= NoError;
      // data output is locked by default
      dout_locked_q <= MuBi8True;
    end else begin
      error_q       <= error_d;
      dout_locked_q <= dout_locked_d;
    end
  end

  ////////////////
  // Assertions //
  ////////////////

  // Known assertions
  `ASSERT_KNOWN(InitDoneKnown_A,     init_done_o)
  `ASSERT_KNOWN(IntegChkAckKnown_A,  integ_chk_ack_o)
  `ASSERT_KNOWN(CnstyChkAckKnown_A,  cnsty_chk_ack_o)
  `ASSERT_KNOWN(ErrorKnown_A,        error_o)
  `ASSERT_KNOWN(AccessKnown_A,       access_o)
  `ASSERT_KNOWN(DigestKnown_A,       digest_o)
  `ASSERT_KNOWN(DataKnown_A,         data_o)
  `ASSERT_KNOWN(OtpReqKnown_A,       otp_req_o)
  `ASSERT_KNOWN(OtpCmdKnown_A,       otp_cmd_o)
  `ASSERT_KNOWN(OtpSizeKnown_A,      otp_size_o)
  `ASSERT_KNOWN(OtpWdataKnown_A,     otp_wdata_o)
  `ASSERT_KNOWN(OtpAddrKnown_A,      otp_addr_o)
  `ASSERT_KNOWN(ScrmblMtxReqKnown_A, scrmbl_mtx_req_o)
  `ASSERT_KNOWN(ScrmblCmdKnown_A,    scrmbl_cmd_o)
  `ASSERT_KNOWN(ScrmblModeKnown_A,   scrmbl_mode_o)
  `ASSERT_KNOWN(ScrmblSelKnown_A,    scrmbl_sel_o)
  `ASSERT_KNOWN(ScrmblDataKnown_A,   scrmbl_data_o)
  `ASSERT_KNOWN(ScrmblValidKnown_A,  scrmbl_valid_o)

  // Uninitialized partitions should always be locked, no matter what.
  `ASSERT(InitWriteLocksPartition_A,
      mubi8_test_true_loose(dout_locked_q)
      |->
      mubi8_test_true_loose(access_o.write_lock))
  `ASSERT(InitReadLocksPartition_A,
      mubi8_test_true_loose(dout_locked_q)
      |->
      mubi8_test_true_loose(access_o.read_lock))
  // Incoming Lock propagation
  `ASSERT(WriteLockPropagation_A,
      mubi8_test_true_loose(access_i.write_lock)
      |->
      mubi8_test_true_loose(access_o.write_lock))
  `ASSERT(ReadLockPropagation_A,
      mubi8_test_true_loose(access_i.read_lock)
      |->
      mubi8_test_true_loose(access_o.read_lock))
  // ECC error in buffer regs
  `ASSERT(EccErrorState_A,
      ecc_err
      |=>
      state_q == ErrorSt)
  // OTP error response
  `ASSERT(OtpErrorState_A,
      state_q inside {InitWaitSt, CnstyReadWaitSt} && otp_rvalid_i &&
      !(otp_err inside {NoError, MacroEccCorrError}) && !ecc_err
      |=>
      state_q == ErrorSt && error_o == $past(otp_err))

  // The partition size must be greater than one scrambling block for the address calculation
  // and muxing to work correctly.
  `ASSERT_INIT(OtpPartBufSize_A, Info.size > (ScrmblBlockWidth/8))

endmodule : otp_ctrl_part_buf

    '''

    Form relevant system verilog assertions for the RTL to be checked for.
    These system verilog assertions should be in a dict with the key as the name and the value as the assertion string.
    An example assertions object to be sent to assertion checker tool is as follows:

    assertions = {"assertion_p1":"property p1;\n    @(posedge clk) signal_A |-> signal_B;\nendproperty
assertion_p1: assert property (p1);", "assertion_p2":"property p2;\n    @(posedge clk) conditions |-> signal_C;\nendproperty\nassertion_p2: assert property (p2);"}

    Then run the assertions using the assertion checker tool. This tool call must include the assertions dictionary as an argument.
    From the output of the assertion checker tool, determine if there are security issues in the RTL.
    If there are no falsified assertions in the output from the assertion checker tool, that means there are no verified security issues in the RTL.

    
================================== Ai Message ==================================

[{'text': "I'll analyze the RTL code for security concerns related to integrity error handling, ECC error propagation, and terminal error state enforcement. Let me create relevant assertions to check these aspects.\n\nBased on the code, I can see that this module (`otp_ctrl_part_buf`) is a buffered partition for an OTP controller that handles integrity checks, consistency checks, and error handling. Let me create assertions to verify the security properties.", 'type': 'text'}, {'id': 'toolu_01X4GLNMBXXuPGdCAbN5MbyY', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv', 'top_module': 'otp_ctrl_part_buf', 'assertions': {'ecc_error_propagation': 'property ecc_error_propagation;\n  @(posedge clk_i) ecc_err |=> state_q == ErrorSt;\nendproperty\nassertion_ecc_error_propagation: assert property(ecc_error_propagation);', 'otp_error_propagation': 'property otp_error_propagation;\n  @(posedge clk_i) (state_q inside {InitWaitSt, CnstyReadWaitSt} && otp_rvalid_i && !(otp_err inside {NoError, MacroEccCorrError})) |=> state_q == ErrorSt;\nendproperty\nassertion_otp_error_propagation: assert property(otp_error_propagation);', 'escalation_terminal_state': 'property escalation_terminal_state;\n  @(posedge clk_i) lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) |=> state_q == ErrorSt;\nendproperty\nassertion_escalation_terminal_state: assert property(escalation_terminal_state);', 'counter_error_terminal_state': 'property counter_error_terminal_state;\n  @(posedge clk_i) cnt_err |=> state_q == ErrorSt;\nendproperty\nassertion_counter_error_terminal_state: assert property(counter_error_terminal_state);', 'error_state_lock': 'property error_state_lock;\n  @(posedge clk_i) (state_q == ErrorSt) |-> mubi8_test_true_strict(dout_locked_q);\nendproperty\nassertion_error_state_lock: assert property(error_state_lock);', 'integrity_check_fail_terminal': "property integrity_check_fail_terminal;\n  @(posedge clk_i) (state_q == IntegDigWaitSt && scrmbl_valid_i && digest_o != data_mux && digest_o != '0) |=> state_q == ErrorSt && error_q == CheckFailError;\nendproperty\nassertion_integrity_check_fail_terminal: assert property(integrity_check_fail_terminal);", 'consistency_check_fail_terminal': "property consistency_check_fail_terminal;\n  @(posedge clk_i) (state_q == CnstyReadWaitSt && otp_rvalid_i && otp_err inside {NoError, MacroEccCorrError} && Info.hw_digest && digest_o != data_mux && digest_o != '0) |=> state_q == ErrorSt && error_q == CheckFailError;\nendproperty\nassertion_consistency_check_fail_terminal: assert property(consistency_check_fail_terminal);"}, 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01X4GLNMBXXuPGdCAbN5MbyY)
 Call ID: toolu_01X4GLNMBXXuPGdCAbN5MbyY
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv
    top_module: otp_ctrl_part_buf
    assertions: {'ecc_error_propagation': 'property ecc_error_propagation;\n  @(posedge clk_i) ecc_err |=> state_q == ErrorSt;\nendproperty\nassertion_ecc_error_propagation: assert property(ecc_error_propagation);', 'otp_error_propagation': 'property otp_error_propagation;\n  @(posedge clk_i) (state_q inside {InitWaitSt, CnstyReadWaitSt} && otp_rvalid_i && !(otp_err inside {NoError, MacroEccCorrError})) |=> state_q == ErrorSt;\nendproperty\nassertion_otp_error_propagation: assert property(otp_error_propagation);', 'escalation_terminal_state': 'property escalation_terminal_state;\n  @(posedge clk_i) lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) |=> state_q == ErrorSt;\nendproperty\nassertion_escalation_terminal_state: assert property(escalation_terminal_state);', 'counter_error_terminal_state': 'property counter_error_terminal_state;\n  @(posedge clk_i) cnt_err |=> state_q == ErrorSt;\nendproperty\nassertion_counter_error_terminal_state: assert property(counter_error_terminal_state);', 'error_state_lock': 'property error_state_lock;\n  @(posedge clk_i) (state_q == ErrorSt) |-> mubi8_test_true_strict(dout_locked_q);\nendproperty\nassertion_error_state_lock: assert property(error_state_lock);', 'integrity_check_fail_terminal': "property integrity_check_fail_terminal;\n  @(posedge clk_i) (state_q == IntegDigWaitSt && scrmbl_valid_i && digest_o != data_mux && digest_o != '0) |=> state_q == ErrorSt && error_q == CheckFailError;\nendproperty\nassertion_integrity_check_fail_terminal: assert property(integrity_check_fail_terminal);", 'consistency_check_fail_terminal': "property consistency_check_fail_terminal;\n  @(posedge clk_i) (state_q == CnstyReadWaitSt && otp_rvalid_i && otp_err inside {NoError, MacroEccCorrError} && Info.hw_digest && digest_o != data_mux && digest_o != '0) |=> state_q == ErrorSt && error_q == CheckFailError;\nendproperty\nassertion_consistency_check_fail_terminal: assert property(consistency_check_fail_terminal);"}
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: assertion_checker_tool

Failed to execute. Error: KeyError('assertion_error_state_lock')
KeyError: 'assertion_error_state_lock'
Traceback (most recent call last):
  File "/home/XXXX-2/security_agents/security_agents.py", line 763, in assertion_checker_tool
    falsified_properties[name] = assertions[name]
                               ~~~~~~~~~~^^^^^^
KeyError: 'assertion_error_state_lock'
================================== Ai Message ==================================

[{'text': 'I need to fix the assertion names to match the property names. Let me try again:', 'type': 'text'}, {'id': 'toolu_01UhrCPnhW165r41adzNAwx3', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv', 'top_module': 'otp_ctrl_part_buf', 'assertions': {'assertion_ecc_error_propagation': 'property ecc_error_propagation;\n  @(posedge clk_i) ecc_err |=> state_q == ErrorSt;\nendproperty\nassertion_ecc_error_propagation: assert property(ecc_error_propagation);', 'assertion_otp_error_propagation': 'property otp_error_propagation;\n  @(posedge clk_i) (state_q inside {InitWaitSt, CnstyReadWaitSt} && otp_rvalid_i && !(otp_err inside {NoError, MacroEccCorrError})) |=> state_q == ErrorSt;\nendproperty\nassertion_otp_error_propagation: assert property(otp_error_propagation);', 'assertion_escalation_terminal_state': 'property escalation_terminal_state;\n  @(posedge clk_i) lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) |=> state_q == ErrorSt;\nendproperty\nassertion_escalation_terminal_state: assert property(escalation_terminal_state);', 'assertion_counter_error_terminal_state': 'property counter_error_terminal_state;\n  @(posedge clk_i) cnt_err |=> state_q == ErrorSt;\nendproperty\nassertion_counter_error_terminal_state: assert property(counter_error_terminal_state);', 'assertion_error_state_lock': 'property error_state_lock;\n  @(posedge clk_i) (state_q == ErrorSt) |-> mubi8_test_true_strict(dout_locked_q);\nendproperty\nassertion_error_state_lock: assert property(error_state_lock);', 'assertion_integrity_check_fail_terminal': "property integrity_check_fail_terminal;\n  @(posedge clk_i) (state_q == IntegDigWaitSt && scrmbl_valid_i && digest_o != data_mux && digest_o != '0) |=> state_q == ErrorSt && error_q == CheckFailError;\nendproperty\nassertion_integrity_check_fail_terminal: assert property(integrity_check_fail_terminal);", 'assertion_consistency_check_fail_terminal': "property consistency_check_fail_terminal;\n  @(posedge clk_i) (state_q == CnstyReadWaitSt && otp_rvalid_i && otp_err inside {NoError, MacroEccCorrError} && Info.hw_digest && digest_o != data_mux && digest_o != '0) |=> state_q == ErrorSt && error_q == CheckFailError;\nendproperty\nassertion_consistency_check_fail_terminal: assert property(consistency_check_fail_terminal);"}, 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01UhrCPnhW165r41adzNAwx3)
 Call ID: toolu_01UhrCPnhW165r41adzNAwx3
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv
    top_module: otp_ctrl_part_buf
    assertions: {'assertion_ecc_error_propagation': 'property ecc_error_propagation;\n  @(posedge clk_i) ecc_err |=> state_q == ErrorSt;\nendproperty\nassertion_ecc_error_propagation: assert property(ecc_error_propagation);', 'assertion_otp_error_propagation': 'property otp_error_propagation;\n  @(posedge clk_i) (state_q inside {InitWaitSt, CnstyReadWaitSt} && otp_rvalid_i && !(otp_err inside {NoError, MacroEccCorrError})) |=> state_q == ErrorSt;\nendproperty\nassertion_otp_error_propagation: assert property(otp_error_propagation);', 'assertion_escalation_terminal_state': 'property escalation_terminal_state;\n  @(posedge clk_i) lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) |=> state_q == ErrorSt;\nendproperty\nassertion_escalation_terminal_state: assert property(escalation_terminal_state);', 'assertion_counter_error_terminal_state': 'property counter_error_terminal_state;\n  @(posedge clk_i) cnt_err |=> state_q == ErrorSt;\nendproperty\nassertion_counter_error_terminal_state: assert property(counter_error_terminal_state);', 'assertion_error_state_lock': 'property error_state_lock;\n  @(posedge clk_i) (state_q == ErrorSt) |-> mubi8_test_true_strict(dout_locked_q);\nendproperty\nassertion_error_state_lock: assert property(error_state_lock);', 'assertion_integrity_check_fail_terminal': "property integrity_check_fail_terminal;\n  @(posedge clk_i) (state_q == IntegDigWaitSt && scrmbl_valid_i && digest_o != data_mux && digest_o != '0) |=> state_q == ErrorSt && error_q == CheckFailError;\nendproperty\nassertion_integrity_check_fail_terminal: assert property(integrity_check_fail_terminal);", 'assertion_consistency_check_fail_terminal': "property consistency_check_fail_terminal;\n  @(posedge clk_i) (state_q == CnstyReadWaitSt && otp_rvalid_i && otp_err inside {NoError, MacroEccCorrError} && Info.hw_digest && digest_o != data_mux && digest_o != '0) |=> state_q == ErrorSt && error_q == CheckFailError;\nendproperty\nassertion_consistency_check_fail_terminal: assert property(consistency_check_fail_terminal);"}
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: assertion_checker_tool

Successfully executed:
```assertion checker tool
```
Output:
 The following properties were falsified:
property error_state_lock;
  @(posedge clk_i) (state_q == ErrorSt) |-> mubi8_test_true_strict(dout_locked_q);
endproperty
assertion_error_state_lock: assert property(error_state_lock);
================================== Ai Message ==================================

Based on the assertion checker results, I've identified a security concern in the RTL code:

## Security Issue Found:

The assertion `error_state_lock` was falsified, which indicates a potential security vulnerability. This assertion checks whether the partition is properly locked when in the error state.

### Issue Details:
- When the module enters the `ErrorSt` (error state), the `dout_locked_q` signal should always be set to `MuBi8True` to lock access to the partition.
- The falsified assertion indicates that there are scenarios where the module can be in the error state but the partition is not properly locked.

### Impact:
This vulnerability could potentially allow:
1. Unauthorized access to the OTP partition data even after an error has been detected
2. Bypassing of security controls when the system is in a compromised state
3. Failure to properly isolate faulty or tampered data

### Root Cause Analysis:
Looking at the RTL code, in the `ErrorSt` case of the FSM, there is the following code:
```verilog
ErrorSt: begin
  dout_locked_d = MuBi8True;
  if (error_q == NoError) begin
    error_d = FsmStateError;
  end
  // If we are in error state, we cannot execute the checks anymore.
  // Hence the acknowledgements are returned immediately.
  cnsty_chk_ack_o = 1'b1;
  integ_chk_ack_o = 1'b1;
end
```

While the code attempts to set `dout_locked_d = MuBi8True`, there appears to be a timing or synchronization issue where the lock is not always effective when the state is `ErrorSt`. This could be due to:

1. Race conditions in the state transitions
2. Improper handling of the multi-bit encoding for the lock signal
3. Potential glitches that could cause the lock to be temporarily ineffective

The other assertions related to error propagation, escalation to terminal state, and integrity/consistency check failures were not falsified, indicating that those aspects of the security implementation are working correctly.

## Recommendation:

To address this security concern, the RTL should be modified to ensure that the partition is always locked when in the error state. Possible fixes include:

1. Strengthen the locking mechanism by adding redundant locking controls
2. Ensure proper synchronization of the lock signal with the error state
3. Add additional checks to verify the lock status when in error state
4. Consider implementing a more robust multi-bit encoding scheme for the lock signal

This issue is particularly concerning since it relates to integrity error handling and terminal error state enforcement, which are critical security controls for protecting sensitive OTP data.
================================= Tool Message =================================
Name: run_assertions_checker_agent

Based on the assertion checker results, I've identified a security concern in the RTL code:

## Security Issue Found:

The assertion `error_state_lock` was falsified, which indicates a potential security vulnerability. This assertion checks whether the partition is properly locked when in the error state.

### Issue Details:
- When the module enters the `ErrorSt` (error state), the `dout_locked_q` signal should always be set to `MuBi8True` to lock access to the partition.
- The falsified assertion indicates that there are scenarios where the module can be in the error state but the partition is not properly locked.

### Impact:
This vulnerability could potentially allow:
1. Unauthorized access to the OTP partition data even after an error has been detected
2. Bypassing of security controls when the system is in a compromised state
3. Failure to properly isolate faulty or tampered data

### Root Cause Analysis:
Looking at the RTL code, in the `ErrorSt` case of the FSM, there is the following code:
```verilog
ErrorSt: begin
  dout_locked_d = MuBi8True;
  if (error_q == NoError) begin
    error_d = FsmStateError;
  end
  // If we are in error state, we cannot execute the checks anymore.
  // Hence the acknowledgements are returned immediately.
  cnsty_chk_ack_o = 1'b1;
  integ_chk_ack_o = 1'b1;
end
```

While the code attempts to set `dout_locked_d = MuBi8True`, there appears to be a timing or synchronization issue where the lock is not always effective when the state is `ErrorSt`. This could be due to:

1. Race conditions in the state transitions
2. Improper handling of the multi-bit encoding for the lock signal
3. Potential glitches that could cause the lock to be temporarily ineffective

The other assertions related to error propagation, escalation to terminal state, and integrity/consistency check failures were not falsified, indicating that those aspects of the security implementation are working correctly.

## Recommendation:

To address this security concern, the RTL should be modified to ensure that the partition is always locked when in the error state. Possible fixes include:

1. Strengthen the locking mechanism by adding redundant locking controls
2. Ensure proper synchronization of the lock signal with the error state
3. Add additional checks to verify the lock status when in error state
4. Consider implementing a more robust multi-bit encoding scheme for the lock signal

This issue is particularly concerning since it relates to integrity error handling and terminal error state enforcement, which are critical security controls for protecting sensitive OTP data.
================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_9y0QqlCFL6xtJRnr8JMi9WvN)
 Call ID: call_9y0QqlCFL6xtJRnr8JMi9WvN
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv
    top_module: otp_ctrl_part_buf
    security_objective: partition lock enforcement and error state handling
================================ Human Message =================================

Are there security concerns related to partition lock enforcement and error state handling in the provided RTL:
    """

    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Buffered partition for OTP controller.
//

`include "prim_flop_macros.sv"

module otp_ctrl_part_buf
  import otp_ctrl_pkg::*;
  import otp_ctrl_reg_pkg::*;
  import otp_ctrl_part_pkg::*;
#(
  // Partition information.
  parameter part_info_t             Info = PartInfoDefault,
  parameter logic [Info.size*8-1:0] DataDefault = '0
) (
  input                               clk_i,
  input                               rst_ni,
  // Pulse to start partition initialisation (required once per power cycle).
  input                               init_req_i,
  output logic                        init_done_o,
  // Integrity check requests
  input                               integ_chk_req_i,
  output logic                        integ_chk_ack_o,
  // Consistency check requests
  input                               cnsty_chk_req_i,
  output logic                        cnsty_chk_ack_o,
  // Escalation input. This moves the FSM into a terminal state and locks down
  // the partition.
  input  lc_ctrl_pkg::lc_tx_t         escalate_en_i,
  // Check bypass enable. This bypasses integrity and consistency checks and
  // acknowledges all incoming check requests (only used by life cycle).
  input  lc_ctrl_pkg::lc_tx_t         check_byp_en_i,
  // Output error state of partition, to be consumed by OTP error/alert logic.
  // Note that most errors are not recoverable and move the partition FSM into
  // a terminal error state.
  output otp_err_e                    error_o,
  // This error signal is pulsed high if the FSM has been glitched into an invalid state.
  // Although it is somewhat redundant with the error code in error_o above, it is
  // meant to cover cases where we already latched an error code while the FSM is
  // glitched into an invalid state (since in that case, the error code will not be
  // overridden with the FSM error code so that the original error code is still
  // discoverable).
  output logic                        fsm_err_o,
  // Access/lock status
  // SEC_CM: ACCESS.CTRL.MUBI
  input  part_access_t                access_i, // runtime lock from CSRs
  output part_access_t                access_o,
  // Buffered 64bit digest output.
  output logic [ScrmblBlockWidth-1:0] digest_o,
  output logic [Info.size*8-1:0]      data_o,
  // OTP interface
  output logic                        otp_req_o,
  output prim_otp_pkg::cmd_e          otp_cmd_o,
  output logic [OtpSizeWidth-1:0]     otp_size_o,
  output logic [OtpIfWidth-1:0]       otp_wdata_o,
  output logic [OtpAddrWidth-1:0]     otp_addr_o,
  input                               otp_gnt_i,
  input                               otp_rvalid_i,
  input  [ScrmblBlockWidth-1:0]       otp_rdata_i,
  input  prim_otp_pkg::err_e          otp_err_i,
  // Scrambling mutex request
  output logic                        scrmbl_mtx_req_o,
  input                               scrmbl_mtx_gnt_i,
  // Scrambling datapath interface
  output otp_scrmbl_cmd_e             scrmbl_cmd_o,
  output digest_mode_e                scrmbl_mode_o,
  output logic [ConstSelWidth-1:0]    scrmbl_sel_o,
  output logic [ScrmblBlockWidth-1:0] scrmbl_data_o,
  output logic                        scrmbl_valid_o,
  input  logic                        scrmbl_ready_i,
  input  logic                        scrmbl_valid_i,
  input  logic [ScrmblBlockWidth-1:0] scrmbl_data_i
);

  ////////////////////////
  // Integration Checks //
  ////////////////////////

  import prim_mubi_pkg::*;
  import prim_util_pkg::vbits;

  localparam int unsigned DigestOffsetInt = (int'(Info.offset) +
                                             int'(Info.size) - ScrmblBlockWidth/8);
  localparam int NumScrmblBlocks = int'(Info.size) / (ScrmblBlockWidth/8);
  localparam int CntWidth = vbits(NumScrmblBlocks);

  localparam bit [OtpByteAddrWidth-1:0] DigestOffset = DigestOffsetInt[OtpByteAddrWidth-1:0];

  localparam int unsigned LastScrmblBlockInt = NumScrmblBlocks - 1;
  localparam int unsigned PenultimateScrmblBlockInt = NumScrmblBlocks - 2;
  localparam bit [CntWidth-1:0] LastScrmblBlock = LastScrmblBlockInt[CntWidth-1:0];
  localparam bit [CntWidth-1:0] PenultimateScrmblBlock = PenultimateScrmblBlockInt[CntWidth-1:0];

  // Integration checks for parameters.
  `ASSERT_INIT(OffsetMustBeBlockAligned_A, (Info.offset % (ScrmblBlockWidth/8)) == 0)
  `ASSERT_INIT(SizeMustBeBlockAligned_A, (Info.size % (ScrmblBlockWidth/8)) == 0)
  `ASSERT_INIT(DigestOffsetMustBeRepresentable_A, DigestOffsetInt == int'(DigestOffset))
  `ASSERT(ScrambledImpliesDigest_A, Info.secret |-> Info.hw_digest)
  `ASSERT(WriteLockImpliesDigest_A, Info.read_lock |-> Info.hw_digest)
  `ASSERT(ReadLockImpliesDigest_A, Info.write_lock |-> Info.hw_digest)

  // This feature is only supposed to be used with partitions that are not scrambled
  // and that do not have a digest.
  `ASSERT(BypassEnable0_A, Info.secret    |-> lc_ctrl_pkg::lc_tx_test_false_strict(check_byp_en_i))
  `ASSERT(BypassEnable1_A, Info.hw_digest |-> lc_ctrl_pkg::lc_tx_test_false_strict(check_byp_en_i))

  ///////////////////////
  // OTP Partition FSM //
  ///////////////////////

  // SEC_CM: PART.FSM.SPARSE
  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 5 -m 16 -n 12 \
  //      -s 3370657881 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: --
  //  4: --
  //  5: |||||||||||||| (28.33%)
  //  6: |||||||||||||||||||| (38.33%)
  //  7: |||||||||| (19.17%)
  //  8: ||| (5.83%)
  //  9: || (4.17%)
  // 10: | (2.50%)
  // 11:  (0.83%)
  // 12:  (0.83%)
  //
  // Minimum Hamming distance: 5
  // Maximum Hamming distance: 12
  // Minimum Hamming weight: 4
  // Maximum Hamming weight: 8
  //
  localparam int StateWidth = 12;
  typedef enum logic [StateWidth-1:0] {
    ResetSt         = 12'b011000001110,
    InitSt          = 12'b110100100111,
    InitWaitSt      = 12'b001110110001,
    InitDescrSt     = 12'b110010000100,
    InitDescrWaitSt = 12'b100110101000,
    IdleSt          = 12'b010101001101,
    IntegScrSt      = 12'b110101011010,
    IntegScrWaitSt  = 12'b100010011111,
    IntegDigClrSt   = 12'b101001000001,
    IntegDigSt      = 12'b011101100010,
    IntegDigPadSt   = 12'b001101010111,
    IntegDigFinSt   = 12'b011011100101,
    IntegDigWaitSt  = 12'b100011110010,
    CnstyReadSt     = 12'b000001101011,
    CnstyReadWaitSt = 12'b101001111100,
    ErrorSt         = 12'b010110111110
  } state_e;

  typedef enum logic {
    ScrmblData,
    OtpData
  } data_sel_e;

  typedef enum logic {
    PartOffset,
    DigOffset
  } base_sel_e;

  state_e state_d, state_q;
  otp_err_e error_d, error_q;
  data_sel_e data_sel;
  base_sel_e base_sel;
  mubi8_t dout_locked_d, dout_locked_q;
  logic [CntWidth-1:0] cnt;
  logic cnt_en, cnt_clr, cnt_err;
  logic ecc_err;
  logic buffer_reg_en;
  logic [ScrmblBlockWidth-1:0] data_mux;

  // Output partition error state.
  assign error_o = error_q;

  // This partition cannot do any write accesses, hence we tie this
  // constantly off.
  assign otp_wdata_o = '0;
  // Depending on the partition configuration, the wrapper is instructed to ignore integrity
  // calculations and checks. To be on the safe side, the partition filters error responses at this
  // point and does not report any integrity errors if integrity is disabled.
  otp_err_e otp_err;
  if (Info.integrity) begin : gen_integrity
    assign otp_cmd_o = prim_otp_pkg::Read;
    assign otp_err = otp_err_e'(otp_err_i);
  end else begin : gen_no_integrity
    assign otp_cmd_o = prim_otp_pkg::ReadRaw;
    always_comb begin
      if (otp_err_e'(otp_err_i) inside {MacroEccCorrError, MacroEccUncorrError}) begin
        otp_err = NoError;
      end else begin
        otp_err = otp_err_e'(otp_err_i);
      end
    end
  end

  always_comb begin : p_fsm
    state_d = state_q;

    // Redundantly encoded lock signal for buffer regs.
    dout_locked_d = dout_locked_q;

    // OTP signals
    otp_req_o = 1'b0;

    // Scrambling mutex
    scrmbl_mtx_req_o = 1'b0;

    // Scrambling datapath
    scrmbl_cmd_o   = LoadShadow;
    scrmbl_sel_o   = CnstyDigest;
    scrmbl_mode_o  = StandardMode;
    scrmbl_valid_o = 1'b0;

    // Counter
    cnt_en   = 1'b0;
    cnt_clr  = 1'b0;
    base_sel = PartOffset;

    // Buffer register
    buffer_reg_en = 1'b0;
    data_sel = OtpData;

    // Error Register
    error_d = error_q;
    fsm_err_o = 1'b0;

    // Integrity/Consistency check responses
    cnsty_chk_ack_o = 1'b0;
    integ_chk_ack_o = 1'b0;

    unique case (state_q)
      ///////////////////////////////////////////////////////////////////
      // State right after reset. Wait here until we get a an
      // initialization request.
      ResetSt: begin
        if (init_req_i) begin
          state_d = InitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Initialization reads out the digest only in unbuffered
      // partitions. Wait here until the OTP request has been granted.
      // And then wait until the OTP word comes back.
      InitSt: begin
        otp_req_o = 1'b1;
        if (otp_gnt_i) begin
          state_d = InitWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for OTP response and write to buffer register, then go to
      // descrambling state. In case an OTP transaction fails, latch the
      // OTP error code and jump to a
      // terminal error state.
      InitWaitSt: begin
        if (otp_rvalid_i) begin
          buffer_reg_en = 1'b1;
          if (otp_err inside {NoError, MacroEccCorrError}) begin
            // Once we've read and descrambled the whole partition, we can go to integrity
            // verification. Note that the last block is the digest value, which does not
            // have to be descrambled.
            if (cnt == LastScrmblBlock) begin
              state_d = IntegDigClrSt;
            // Only need to descramble if this is a scrambled partition.
            // Otherwise, we can just go back to InitSt and read the next block.
            end else if (Info.secret) begin
              state_d = InitDescrSt;
            end else begin
              state_d = InitSt;
              cnt_en = 1'b1;
            end
            // At this point the only error that we could have gotten are correctable ECC errors.
            if (otp_err != NoError) begin
              error_d = MacroEccCorrError;
            end
          end else begin
            state_d = ErrorSt;
            error_d = otp_err;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Descrambling state. This first acquires the scrambling
      // datapath mutex. Note that once the mutex is acquired, we have
      // exclusive access to the scrambling datapath until we release
      // the mutex by deasserting scrmbl_mtx_req_o.
      // SEC_CM: SECRET.MEM.SCRAMBLE
      InitDescrSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        scrmbl_cmd_o = Decrypt;
        scrmbl_sel_o = Info.key_sel;
        if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
          state_d = InitDescrWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for the descrambled data to return. Note that we release
      // the mutex lock upon leaving this state.
      // SEC_CM: SECRET.MEM.SCRAMBLE
      InitDescrWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_sel_o = Info.key_sel;
        data_sel = ScrmblData;
        if (scrmbl_valid_i) begin
          state_d = InitSt;
          buffer_reg_en = 1'b1;
          cnt_en = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Idle state. We basically wait for integrity and consistency check
      // triggers in this state.
      IdleSt: begin
        if (integ_chk_req_i) begin
          if (Info.hw_digest) begin
            state_d = IntegDigClrSt;
          // In case there is nothing to check we can just
          // acknowledge the request right away, without going to the
          // integrity check.
          end else begin
            integ_chk_ack_o = 1'b1;
          end
        end else if (cnsty_chk_req_i) begin
          state_d = CnstyReadSt;
          cnt_clr = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Read the digest. Wait here until the OTP request has been granted.
      // And then wait until the OTP word comes back.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      CnstyReadSt: begin
        otp_req_o = 1'b1;
        // In case this partition has a hardware digest, we only have to read
        // and compare the digest value. In that case we select the digest offset here.
        // Otherwise we have to read and compare the whole partition, in which case we
        // select the partition offset, which is the default assignment of base_sel.
        if (Info.hw_digest) begin
          base_sel = DigOffset;
        end
        if (otp_gnt_i) begin
          state_d = CnstyReadWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for OTP response and compare the digest. In case there is
      // a mismatch, lock down the partition and go into the terminal error
      // state. In case an OTP transaction fails, latch the OTP error code
      // and jump to a terminal error state.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      CnstyReadWaitSt: begin
        if (otp_rvalid_i) begin
          if (otp_err inside {NoError, MacroEccCorrError}) begin
            // Check whether we need to compare the digest or the full partition
            // contents here.
            if (Info.hw_digest) begin
              // Note that we ignore this check if the digest is still blank.
              if (digest_o == data_mux || digest_o == '0) begin
                state_d = IdleSt;
                cnsty_chk_ack_o = 1'b1;
              // Error out and lock the partition if this check fails.
              end else begin
                state_d = ErrorSt;
                error_d = CheckFailError;
                // The check has finished and found an error.
                cnsty_chk_ack_o = 1'b1;
              end
            end else begin
              // Check whether the read data corresponds with the data buffered in regs.
              // Note that this particular check can be bypassed in case a transition is ongoing.
              if (scrmbl_data_o == data_mux ||
                  lc_ctrl_pkg::lc_tx_test_true_strict(check_byp_en_i)) begin
                // Can go back to idle and acknowledge the
                // request if this is the last block.
                if (cnt == LastScrmblBlock) begin
                  state_d = IdleSt;
                  cnsty_chk_ack_o = 1'b1;
                // Need to go back and read out more blocks.
                end else begin
                  state_d = CnstyReadSt;
                  cnt_en = 1'b1;
                end
              end else begin
                state_d = ErrorSt;
                error_d = CheckFailError;
                // The check has finished and found an error.
                cnsty_chk_ack_o = 1'b1;
              end
            end
            // At this point the only error that we could have gotten are correctable ECC errors.
            if (otp_err != NoError) begin
              error_d = MacroEccCorrError;
            end
          end else begin
            state_d = ErrorSt;
            error_d = otp_err;
            // The check has finished and found an error.
            cnsty_chk_ack_o = 1'b1;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // First, acquire the mutex for the digest and clear the digest state.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigClrSt: begin
        // Check whether this partition requires checking at all.
        if (Info.hw_digest) begin
          scrmbl_mtx_req_o = 1'b1;
          scrmbl_valid_o = 1'b1;
          cnt_clr = 1'b1;
          // Need to reset the digest state and set it to chained
          // mode if this partition is scrambled.
          scrmbl_cmd_o = DigestInit;
          if (Info.secret) begin
            scrmbl_mode_o = ChainedMode;
            if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
              state_d = IntegScrSt;
            end
          // If this partition is not scrambled, we can just directly
          // jump to the digest state.
          end else begin
            scrmbl_mode_o = StandardMode;
            if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
              state_d = IntegDigSt;
            end
          end
        // Otherwise, if this partition is not digest protected,
        // we can just go to idle, since there is nothing to check.
        // Note that we do not come back to this state in case there is no
        // digest, and hence it is safe to unlock the buffer regs at this point.
        // This is the only way the buffer regs can get unlocked.
        end else begin
          state_d = IdleSt;
          if (mubi8_test_true_strict(dout_locked_q)) begin
            dout_locked_d = MuBi8False;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Scramble buffered data (which is held in plaintext form).
      // This moves the previous scrambling result into the shadow reg
      // for later use.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegScrSt: begin
          scrmbl_mtx_req_o = 1'b1;
          scrmbl_valid_o = 1'b1;
          scrmbl_cmd_o = Encrypt;
          scrmbl_sel_o = Info.key_sel;
          if (scrmbl_ready_i) begin
            state_d = IntegScrWaitSt;
          end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for the scrambled data to return.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegScrWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_sel_o = Info.key_sel;
        if (scrmbl_valid_i) begin
          state_d = IntegDigSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Push the word read into the scrambling datapath. The last
      // block is repeated in case the number blocks in this partition
      // is odd.
      // SEC_CM: PART.MEM.DIGEST
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        if (scrmbl_ready_i) begin
          cnt_en = 1'b1;
          // No need to digest the digest value itself
          if (cnt == PenultimateScrmblBlock) begin
            // Note that the digest operates on 128bit blocks since the data is fed in via the
            // PRESENT key input. Therefore, we only trigger a digest update on every second
            // 64bit block that is pushed into the scrambling datapath.
            if (cnt[0]) begin
              scrmbl_cmd_o = Digest;
              state_d = IntegDigFinSt;
            end else begin
              state_d = IntegDigPadSt;
              cnt_en = 1'b0;
            end
          end else begin
            // Trigger digest round in case this is the second block in a row.
            if (cnt[0]) begin
              scrmbl_cmd_o = Digest;
            end
            // Go back and scramble the next data block if this is
            // a scrambled partition. Otherwise just stay here.
            if (Info.secret) begin
              state_d = IntegScrSt;
            end
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Padding state. When we get here, we've copied the last encryption
      // result into the shadow register such that we've effectively
      // repeated the last block twice in order to pad the data to 128bit.
      // SEC_CM: PART.MEM.DIGEST
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigPadSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        scrmbl_cmd_o = Digest;
        if (scrmbl_ready_i) begin
          state_d = IntegDigFinSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Trigger digest finalization and go wait for the result.
      // SEC_CM: PART.MEM.DIGEST
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigFinSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        scrmbl_cmd_o = DigestFinalize;
        if (scrmbl_ready_i) begin
          state_d = IntegDigWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for the digest to return, and double check whether the digest
      // matches. If yes, unlock the partition. Otherwise, go into the terminal
      // error state, where the partition will be locked down.
      // SEC_CM: PART.MEM.DIGEST
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        data_sel = ScrmblData;
        if (scrmbl_valid_i) begin
          // This is the only way the buffer regs can get unlocked.
          // Note that we ignore this check if the digest is still blank.
          if (digest_o == data_mux || digest_o == '0) begin
            state_d = IdleSt;
            // If the partition is still locked, this is the first integrity check after
            // initialization. This is the only way the buffer regs can get unlocked.
            if (mubi8_test_true_strict(dout_locked_q)) begin
              dout_locked_d = MuBi8False;
            // Otherwise, this integrity check has requested by the LFSR timer, and we have
            // to acknowledge its completion.
            end else begin
              integ_chk_ack_o = 1'b1;
            end
          // Error out and lock the partition if this check fails.
          end else begin
            state_d = ErrorSt;
            error_d = CheckFailError;
            // The check has finished and found an error.
            integ_chk_ack_o = 1'b1;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Terminal Error State. This locks access to the partition.
      // Make sure the partition signals an error state if no error
      // code has been latched so far, and lock the buffer regs down.
      ErrorSt: begin
        dout_locked_d = MuBi8True;
        if (error_q == NoError) begin
          error_d = FsmStateError;
        end
        // If we are in error state, we cannot execute the checks anymore.
        // Hence the acknowledgements are returned immediately.
        cnsty_chk_ack_o = 1'b1;
        integ_chk_ack_o = 1'b1;
      end
      ///////////////////////////////////////////////////////////////////
      // We should never get here. If we do (e.g. via a malicious
      // glitch), error out immediately.
      default: begin
        state_d = ErrorSt;
        fsm_err_o = 1'b1;
      end
      ///////////////////////////////////////////////////////////////////
    endcase // state_q


    // Unconditionally jump into the terminal error state in case of
    // an ECC error or escalation, and lock access to the partition down.
    // SEC_CM: PART.FSM.LOCAL_ESC
    if (ecc_err) begin
      state_d = ErrorSt;
      if (state_q != ErrorSt) begin
        error_d = CheckFailError;
      end
    end
    // SEC_CM: PART.FSM.LOCAL_ESC, PART.FSM.GLOBAL_ESC
    if (lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) || cnt_err) begin
      state_d = ErrorSt;
      fsm_err_o = 1'b1;
      if (state_q != ErrorSt) begin
        error_d = FsmStateError;
      end
    end
  end

  ////////////////////////////
  // Address Calc and Muxes //
  ////////////////////////////

  // Address counter - this is only used for computing a digest, hence the increment is
  // fixed to 8 byte.
  // SEC_CM: PART.CTR.REDUN
  prim_count #(
    .Width(CntWidth)
  ) u_prim_count (
    .clk_i,
    .rst_ni,
    .clr_i(cnt_clr),
    .set_i(1'b0),
    .set_cnt_i('0),
    .incr_en_i(cnt_en),
    .decr_en_i(1'b0),
    .step_i(CntWidth'(1)),
    .commit_i(1'b1),
    .cnt_o(cnt),
    .cnt_after_commit_o(),
    .err_o(cnt_err)
  );

  logic [OtpByteAddrWidth-1:0] addr_base;
  assign addr_base = (base_sel == DigOffset) ? DigestOffset : Info.offset;

  // Note that OTP works on halfword (16bit) addresses, hence need to
  // shift the addresses appropriately.
  logic [OtpByteAddrWidth-1:0] addr_calc;
  assign addr_calc = OtpByteAddrWidth'({cnt, {$clog2(ScrmblBlockWidth/8){1'b0}}}) + addr_base;
  assign otp_addr_o = addr_calc[OtpByteAddrWidth-1:OtpAddrShift];

  if (OtpAddrShift > 0) begin : gen_unused
    logic unused_bits;
    assign unused_bits = ^addr_calc[OtpAddrShift-1:0];
  end

  // Always transfer 64bit blocks.
  assign otp_size_o = OtpSizeWidth'(unsigned'(ScrmblBlockWidth / OtpWidth) - 1);

  assign data_mux = (data_sel == ScrmblData) ? scrmbl_data_i : otp_rdata_i;

  /////////////////
  // Buffer Regs //
  /////////////////

  // SEC_CM: PART.DATA_REG.INTEGRITY
  logic [Info.size*8-1:0] data;
  otp_ctrl_ecc_reg #(
    .Width ( ScrmblBlockWidth ),
    .Depth ( NumScrmblBlocks  )
  ) u_otp_ctrl_ecc_reg (
    .clk_i,
    .rst_ni,
    .wren_i    ( buffer_reg_en ),
    .addr_i    ( cnt           ),
    .wdata_i   ( data_mux      ),
    .rdata_o   ( scrmbl_data_o ),
    .data_o    ( data          ),
    .ecc_err_o ( ecc_err       )
  );

  // We have successfully initialized the partition once it has been unlocked.
  assign init_done_o = mubi8_test_false_strict(dout_locked_q);
  // Hardware output gating.
  // Note that this is decoupled from the DAI access rules further below.
  assign data_o = data;
  // The digest does not have to be gated.
  assign digest_o = data[$high(data_o) -: ScrmblBlockWidth];

  ////////////////////////
  // DAI Access Control //
  ////////////////////////

  // Aggregate all possible DAI write /readlocks. The partition is also locked when uninitialized.
  // Note that the locks are redundantly encoded values.
  part_access_t access_pre;
  prim_mubi8_sender #(
    .AsyncOn(0)
  ) u_prim_mubi8_sender_write_lock_pre (
    .clk_i,
    .rst_ni,
    .mubi_i(mubi8_and_lo(dout_locked_q, access_i.write_lock)),
    .mubi_o(access_pre.write_lock)
  );
  prim_mubi8_sender #(
    .AsyncOn(0)
  ) u_prim_mubi8_sender_read_lock_pre (
    .clk_i,
    .rst_ni,
    .mubi_i(mubi8_and_lo(dout_locked_q, access_i.read_lock)),
    .mubi_o(access_pre.read_lock)
  );

  // SEC_CM: PART.MEM.SW_UNWRITABLE
  if (Info.write_lock) begin : gen_digest_write_lock
    mubi8_t digest_locked;
    assign digest_locked = (digest_o != '0) ? MuBi8True : MuBi8False;

    // This prevents the synthesis tool from optimizing the multibit signal.
    prim_mubi8_sender #(
      .AsyncOn(0)
    ) u_prim_mubi8_sender_write_lock (
      .clk_i,
      .rst_ni,
      .mubi_i(mubi8_and_lo(access_pre.write_lock, digest_locked)),
      .mubi_o(access_o.write_lock)
    );

    `ASSERT(DigestWriteLocksPartition_A, digest_o |-> mubi8_test_true_loose(access_o.write_lock))
  end else begin : gen_no_digest_write_lock
    assign access_o.write_lock = access_pre.write_lock;
  end

  // SEC_CM: PART.MEM.SW_UNREADABLE
  if (Info.read_lock) begin : gen_digest_read_lock
    mubi8_t digest_locked;
    assign digest_locked = (digest_o != '0) ? MuBi8True : MuBi8False;

    // This prevents the synthesis tool from optimizing the multibit signal.
    prim_mubi8_sender #(
      .AsyncOn(0)
    ) u_prim_mubi8_sender_read_lock (
      .clk_i,
      .rst_ni,
      .mubi_i(mubi8_and_lo(access_pre.read_lock, digest_locked)),
      .mubi_o(access_o.read_lock)
    );

    `ASSERT(DigestReadLocksPartition_A, digest_o |-> mubi8_test_true_loose(access_o.read_lock))
  end else begin : gen_no_digest_read_lock
    assign access_o.read_lock = access_pre.read_lock;
  end

  ///////////////
  // Registers //
  ///////////////

  `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, state_e, ResetSt)

  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs
    if (!rst_ni) begin
      error_q       <= NoError;
      // data output is locked by default
      dout_locked_q <= MuBi8True;
    end else begin
      error_q       <= error_d;
      dout_locked_q <= dout_locked_d;
    end
  end

  ////////////////
  // Assertions //
  ////////////////

  // Known assertions
  `ASSERT_KNOWN(InitDoneKnown_A,     init_done_o)
  `ASSERT_KNOWN(IntegChkAckKnown_A,  integ_chk_ack_o)
  `ASSERT_KNOWN(CnstyChkAckKnown_A,  cnsty_chk_ack_o)
  `ASSERT_KNOWN(ErrorKnown_A,        error_o)
  `ASSERT_KNOWN(AccessKnown_A,       access_o)
  `ASSERT_KNOWN(DigestKnown_A,       digest_o)
  `ASSERT_KNOWN(DataKnown_A,         data_o)
  `ASSERT_KNOWN(OtpReqKnown_A,       otp_req_o)
  `ASSERT_KNOWN(OtpCmdKnown_A,       otp_cmd_o)
  `ASSERT_KNOWN(OtpSizeKnown_A,      otp_size_o)
  `ASSERT_KNOWN(OtpWdataKnown_A,     otp_wdata_o)
  `ASSERT_KNOWN(OtpAddrKnown_A,      otp_addr_o)
  `ASSERT_KNOWN(ScrmblMtxReqKnown_A, scrmbl_mtx_req_o)
  `ASSERT_KNOWN(ScrmblCmdKnown_A,    scrmbl_cmd_o)
  `ASSERT_KNOWN(ScrmblModeKnown_A,   scrmbl_mode_o)
  `ASSERT_KNOWN(ScrmblSelKnown_A,    scrmbl_sel_o)
  `ASSERT_KNOWN(ScrmblDataKnown_A,   scrmbl_data_o)
  `ASSERT_KNOWN(ScrmblValidKnown_A,  scrmbl_valid_o)

  // Uninitialized partitions should always be locked, no matter what.
  `ASSERT(InitWriteLocksPartition_A,
      mubi8_test_true_loose(dout_locked_q)
      |->
      mubi8_test_true_loose(access_o.write_lock))
  `ASSERT(InitReadLocksPartition_A,
      mubi8_test_true_loose(dout_locked_q)
      |->
      mubi8_test_true_loose(access_o.read_lock))
  // Incoming Lock propagation
  `ASSERT(WriteLockPropagation_A,
      mubi8_test_true_loose(access_i.write_lock)
      |->
      mubi8_test_true_loose(access_o.write_lock))
  `ASSERT(ReadLockPropagation_A,
      mubi8_test_true_loose(access_i.read_lock)
      |->
      mubi8_test_true_loose(access_o.read_lock))
  // ECC error in buffer regs
  `ASSERT(EccErrorState_A,
      ecc_err
      |=>
      state_q == ErrorSt)
  // OTP error response
  `ASSERT(OtpErrorState_A,
      state_q inside {InitWaitSt, CnstyReadWaitSt} && otp_rvalid_i &&
      !(otp_err inside {NoError, MacroEccCorrError}) && !ecc_err
      |=>
      state_q == ErrorSt && error_o == $past(otp_err))

  // The partition size must be greater than one scrambling block for the address calculation
  // and muxing to work correctly.
  `ASSERT_INIT(OtpPartBufSize_A, Info.size > (ScrmblBlockWidth/8))

endmodule : otp_ctrl_part_buf


    """


    Identify the CWE relevant to the security issue for the given RTL.
    Obtain details of the CWE.

    Then determine if there are security issues relevant to the identified CWE in the RTL.
    Refer to the code that corresponds to the issues identified.
    
================================== Ai Message ==================================

[{'text': "I'll analyze the RTL code for security concerns related to partition lock enforcement and error state handling, and identify relevant CWEs.", 'type': 'text'}, {'id': 'toolu_01JyU3Fp6LBDfg6Ry6jGcaca', 'input': {'security_issue': 'partition lock enforcement hardware security'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01JyU3Fp6LBDfg6Ry6jGcaca)
 Call ID: toolu_01JyU3Fp6LBDfg6Ry6jGcaca
  Args:
    security_issue: partition lock enforcement hardware security
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1234: Hardware Internal or Debug Modes Allow Override of Locks
System configuration protection may be bypassed during debug mode.
Device configuration controls are commonly programmed after a device power reset by a trusted firmware or software module (e.g., BIOS/bootloader) and then locked from any further modification. This is commonly implemented using a trusted lock bit, which when set, disables writes to a protected set of registers or address regions. The lock protection is intended to prevent modification of certain system configuration (e.g., memory/memory protection unit configuration). If debug features supported by hardware or internal modes/system states are supported in the hardware design, modification of the lock protection may be allowed allowing access and modification of configuration information.
Example 1
For example, consider the example Locked_override_register example. This register module supports a lock mode that blocks any writes after lock is set to 1. However, it also allows override of the lock protection when scan_mode or debug_unlocked modes are active.
(bad code)
Example Language: Verilog
module Locked_register_example
(
input [15:0] Data_in,
input Clk,
input resetn,
input write,
input Lock,
input scan_mode,
input debug_unlocked,
output reg [15:0] Data_out
);

reg lock_status;

always @(posedge Clk or negedge resetn)
if (~resetn) // Register is reset resetn
begin
lock_status <= 1'b0;
end
else if (Lock)
begin
lock_status <= 1'b1;
end
else if (~Lock)
begin
lock_status <= lock_status
end
always @(posedge Clk or negedge resetn)
if (~resetn) // Register is reset resetn
begin
Data_out <= 16'h0000;
end
else if (write & (~lock_status | scan_mode | debug_unlocked) ) // Register protected by Lock bit input, overrides supported for scan_mode & debug_unlocked
begin
Data_out <= Data_in;
end
else if (~write)
begin
Data_out <= Data_out;
end
endmodule
If either the scan_mode or the debug_unlocked modes can be triggered by software, then the lock protection may be bypassed.
(good code)
Either remove the debug and scan mode overrides or protect enabling of these modes so that only trusted and authorized users may enable these modes.

Example 2
The following example code is taken from the register lock security peripheral of the HACK@DAC'21 buggy OpenPiton SoC. It demonstrates how to lock read or write access to security-critical hardware registers (e.g., crypto keys, system integrity code, etc.). The configuration to lock all the sensitive registers in the SoC is managed through the reglk_mem registers. These reglk_mem registers are reset when the hardware powers up and configured during boot up. Malicious users, even with kernel-level software privilege, do not get access to the sensitive contents that are locked down. Hence, the security of the entire system can potentially be compromised if the register lock configurations are corrupted or if the register locks are disabled.
(bad code)
Example Language: Verilog
...
always @(posedge clk_i)
begin
if(~(rst_ni && ~jtag_unlock && ~rst_9))
begin
for (j=0; j < 6; j=j+1) begin
reglk_mem[j] <= 'h0;
end
end
...
The example code illustrates an instance of a vulnerable implementation of register locks in the SoC. In this flawed implementation, the reglk_mem registers are also being reset when the system enters debug mode (indicated by the jtag_unlock signal). Consequently, users can simply put the processor in debug mode to access sensitive contents that are supposed to be protected by the register lock feature. This can be mitigated by excluding debug mode signals from the reset logic of security-critical register locks as demonstrated in the following code snippet.
(good code)
Example Language: Verilog
...
always @(posedge clk_i)
begin
if(~(rst_ni && ~rst_9))
begin
for (j=0; j < 6; j=j+1) begin
reglk_mem[j] <= 'h0;
end
end
...


================================== Ai Message ==================================

[{'id': 'toolu_016MkpdzHiydJkSrmtBmjsF1', 'input': {'security_issue': 'hardware error state handling'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_016MkpdzHiydJkSrmtBmjsF1)
 Call ID: toolu_016MkpdzHiydJkSrmtBmjsF1
  Args:
    security_issue: hardware error state handling
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1351: Improper Handling of Hardware Behavior in Exceptionally Cold Environments
A hardware device, or the firmware running on it, is missing or has incorrect protection features to maintain goals of security primitives when the device is cooled below standard operating temperatures.
The hardware designer may improperly anticipate hardware behavior when exposed to exceptionally cold conditions. As a result they may introduce a weakness by not accounting for the modified behavior of critical components when in extreme environments.

================================== Ai Message ==================================

[{'id': 'toolu_01P9hnUA2zTg6ZFYyWakB4YZ', 'input': {'security_issue': 'hardware state machine security'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01P9hnUA2zTg6ZFYyWakB4YZ)
 Call ID: toolu_01P9hnUA2zTg6ZFYyWakB4YZ
  Args:
    security_issue: hardware state machine security
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1431: Driving Intermediate Cryptographic State/Results to Hardware Module Outputs
The product uses a hardware module implementing a cryptographic algorithm that writes sensitive information about the intermediate state or results of its cryptographic operations via one of its output wires (typically the output port containing the final result).

Example 1
The following SystemVerilog code is a crypto module that takes input data and encrypts it by processing the data through multiple encryption rounds.
(bad code)
Example language: Verilog
01 | module crypto_core_with_leakage
02 | (
03 | input clk,
04 | input rst,
05 | input [127:0] data_i,
06 | output [127:0] data_o,
07 | output valid
08 | );
09 |
10 | localparam int total_rounds = 10;
11 | logic [3:0] round_id_q;
12 | logic [127:0] data_state_q, data_state_d;
13 | logic [127:0] key_state_q, key_state_d;
14 |
15 | crypto_algo_round u_algo_round (
16 | .clk (clk),
17 | .rst (rst),
18 | .round_i (round_id_q ),
19 | .key_i (key_state_q ),
20 | .data_i (data_state_q),
21 | .key_o (key_state_d ),
22 | .data_o (data_state_d)
23 | );
24 |
25 | always @(posedge clk) begin
26 | if (rst) begin
27 | data_state_q <= 0;
28 | key_state_q <= 0;
29 | round_id_q <= 0;
30 | end
31 | else begin
32 | case (round_id_q)
33 | total_rounds: begin
34 | data_state_q <= 0;
35 | key_state_q <= 0;
36 | round_id_q <= 0;
37 | end
38 |
39 | default: begin
40 | data_state_q <= data_state_d;
41 | key_state_q <= key_state_d;
42 | round_id_q <= round_id_q + 1;
43 | end
44 | endcase
45 | end
46 | end
47 |
48 | assign valid = (round_id_q == total_rounds) ? 1'b1 : 1'b0;
49 |
50 | assign data_o = data_state_q;
51 |
52 | endmodule
In line 50 above, data_state_q is assigned to data_o. Since data_state_q contains intermediate state/results, this allows an attacker to obtain these results through data_o.
In line 50 of the fixed logic below, while "data_state_q" does not contain the final result, a "sanitizing" mechanism drives a safe default value (i.e., 0) to "data_o" instead of the value of "data_state_q". In doing so, the mechanism prevents the exposure of intermediate state/results which could be used to break soundness of the cryptographic operation being performed.
(good code)
Example language: Verilog
01 | module crypto_core_without_leakage
02 | (
03 | input clk,
04 | input rst,
05 | input [127:0] data_i,
06 | output [127:0] data_o,
07 | output valid
08 | );
09 |
10 | localparam int total_rounds = 10;
11 | logic [3:0] round_id_q;
12 | logic [127:0] data_state_q, data_state_d;
13 | logic [127:0] key_state_q, key_state_d;
14 |
15 | crypto_algo_round u_algo_round (
16 | .clk (clk),
17 | .rst (rst),
18 | .round_i (round_id_q ),
19 | .key_i (key_state_q ),
20 | .data_i (data_state_q),
21 | .key_o (key_state_d ),
22 | .data_o (data_state_d)
23 | );
24 |
25 | always @(posedge clk) begin
26 | if (rst) begin
27 | data_state_q <= 0;
28 | key_state_q <= 0;
29 | round_id_q <= 0;
30 | end
31 | else begin
32 | case (round_id_q)
33 | total_rounds: begin
34 | data_state_q <= 0;
35 | key_state_q <= 0;
36 | round_id_q <= 0;
37 | end
38 |
39 | default: begin
40 | data_state_q <= data_state_d;
41 | key_state_q <= key_state_d;
42 | round_id_q <= round_id_q + 1;
43 | end
44 | endcase
45 | end
46 | end
47 |
48 | assign valid = (round_id_q == total_rounds) ? 1'b1 : 1'b0;
49 |
50 | assign data_o = (valid) ? data_state_q : 0;
51 |
52 | endmodule
================================== Ai Message ==================================

[{'id': 'toolu_01LAVHi1oaXrBxQnDSnaKGW6', 'input': {'security_issue': 'hardware state machine glitch attack'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01LAVHi1oaXrBxQnDSnaKGW6)
 Call ID: toolu_01LAVHi1oaXrBxQnDSnaKGW6
  Args:
    security_issue: hardware state machine glitch attack
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

[{"id": "toolu_01LAVHi1oaXrBxQnDSnaKGW6", "input": {"security_issue": "hardware state machine glitch attack"}, "name": "llm_cwe_details_retriever_tool", "type": "tool_use"}]
================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_lryKjt7psFmX956ohDd8JAXh)
 Call ID: call_lryKjt7psFmX956ohDd8JAXh
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Buffered partition for OTP controller.
6: //
7: 
8: `include "prim_flop_macros.sv"
9: 
10: module otp_ctrl_part_buf
11:   import otp_ctrl_pkg::*;
12:   import otp_ctrl_reg_pkg::*;
13:   import otp_ctrl_part_pkg::*;
14: #(
15:   // Partition information.
16:   parameter part_info_t             Info = PartInfoDefault,
17:   parameter logic [Info.size*8-1:0] DataDefault = '0
18: ) (
19:   input                               clk_i,
20:   input                               rst_ni,
21:   // Pulse to start partition initialisation (required once per power cycle).
22:   input                               init_req_i,
23:   output logic                        init_done_o,
24:   // Integrity check requests
25:   input                               integ_chk_req_i,
26:   output logic                        integ_chk_ack_o,
27:   // Consistency check requests
28:   input                               cnsty_chk_req_i,
29:   output logic                        cnsty_chk_ack_o,
30:   // Escalation input. This moves the FSM into a terminal state and locks down
31:   // the partition.
32:   input  lc_ctrl_pkg::lc_tx_t         escalate_en_i,
33:   // Check bypass enable. This bypasses integrity and consistency checks and
34:   // acknowledges all incoming check requests (only used by life cycle).
35:   input  lc_ctrl_pkg::lc_tx_t         check_byp_en_i,
36:   // Output error state of partition, to be consumed by OTP error/alert logic.
37:   // Note that most errors are not recoverable and move the partition FSM into
38:   // a terminal error state.
39:   output otp_err_e                    error_o,
40:   // This error signal is pulsed high if the FSM has been glitched into an invalid state.
41:   // Although it is somewhat redundant with the error code in error_o above, it is
42:   // meant to cover cases where we already latched an error code while the FSM is
43:   // glitched into an invalid state (since in that case, the error code will not be
44:   // overridden with the FSM error code so that the original error code is still
45:   // discoverable).
46:   output logic                        fsm_err_o,
47:   // Access/lock status
48:   // SEC_CM: ACCESS.CTRL.MUBI
49:   input  part_access_t                access_i, // runtime lock from CSRs
50:   output part_access_t                access_o,
51:   // Buffered 64bit digest output.
52:   output logic [ScrmblBlockWidth-1:0] digest_o,
53:   output logic [Info.size*8-1:0]      data_o,
54:   // OTP interface
55:   output logic                        otp_req_o,
56:   output prim_otp_pkg::cmd_e          otp_cmd_o,
57:   output logic [OtpSizeWidth-1:0]     otp_size_o,
58:   output logic [OtpIfWidth-1:0]       otp_wdata_o,
59:   output logic [OtpAddrWidth-1:0]     otp_addr_o,
60:   input                               otp_gnt_i,
61:   input                               otp_rvalid_i,
62:   input  [ScrmblBlockWidth-1:0]       otp_rdata_i,
63:   input  prim_otp_pkg::err_e          otp_err_i,
64:   // Scrambling mutex request
65:   output logic                        scrmbl_mtx_req_o,
66:   input                               scrmbl_mtx_gnt_i,
67:   // Scrambling datapath interface
68:   output otp_scrmbl_cmd_e             scrmbl_cmd_o,
69:   output digest_mode_e                scrmbl_mode_o,
70:   output logic [ConstSelWidth-1:0]    scrmbl_sel_o,
71:   output logic [ScrmblBlockWidth-1:0] scrmbl_data_o,
72:   output logic                        scrmbl_valid_o,
73:   input  logic                        scrmbl_ready_i,
74:   input  logic                        scrmbl_valid_i,
75:   input  logic [ScrmblBlockWidth-1:0] scrmbl_data_i
76: );
77: 
78:   ////////////////////////
79:   // Integration Checks //
80:   ////////////////////////
81: 
82:   import prim_mubi_pkg::*;
83:   import prim_util_pkg::vbits;
84: 
85:   localparam int unsigned DigestOffsetInt = (int'(Info.offset) +
86:                                              int'(Info.size) - ScrmblBlockWidth/8);
87:   localparam int NumScrmblBlocks = int'(Info.size) / (ScrmblBlockWidth/8);
88:   localparam int CntWidth = vbits(NumScrmblBlocks);
89: 
90:   localparam bit [OtpByteAddrWidth-1:0] DigestOffset = DigestOffsetInt[OtpByteAddrWidth-1:0];
91: 
92:   localparam int unsigned LastScrmblBlockInt = NumScrmblBlocks - 1;
93:   localparam int unsigned PenultimateScrmblBlockInt = NumScrmblBlocks - 2;
94:   localparam bit [CntWidth-1:0] LastScrmblBlock = LastScrmblBlockInt[CntWidth-1:0];
95:   localparam bit [CntWidth-1:0] PenultimateScrmblBlock = PenultimateScrmblBlockInt[CntWidth-1:0];
96: 
97:   // Integration checks for parameters.
98:   `ASSERT_INIT(OffsetMustBeBlockAligned_A, (Info.offset % (ScrmblBlockWidth/8)) == 0)
99:   `ASSERT_INIT(SizeMustBeBlockAligned_A, (Info.size % (ScrmblBlockWidth/8)) == 0)
100:   `ASSERT_INIT(DigestOffsetMustBeRepresentable_A, DigestOffsetInt == int'(DigestOffset))
101:   `ASSERT(ScrambledImpliesDigest_A, Info.secret |-> Info.hw_digest)
102:   `ASSERT(WriteLockImpliesDigest_A, Info.read_lock |-> Info.hw_digest)
103:   `ASSERT(ReadLockImpliesDigest_A, Info.write_lock |-> Info.hw_digest)
104: 
105:   // This feature is only supposed to be used with partitions that are not scrambled
106:   // and that do not have a digest.
107:   `ASSERT(BypassEnable0_A, Info.secret    |-> lc_ctrl_pkg::lc_tx_test_false_strict(check_byp_en_i))
108:   `ASSERT(BypassEnable1_A, Info.hw_digest |-> lc_ctrl_pkg::lc_tx_test_false_strict(check_byp_en_i))
109: 
110:   ///////////////////////
111:   // OTP Partition FSM //
112:   ///////////////////////
113: 
114:   // SEC_CM: PART.FSM.SPARSE
115:   // Encoding generated with:
116:   // $ ./util/design/sparse-fsm-encode.py -d 5 -m 16 -n 12 \
117:   //      -s 3370657881 --language=sv
118:   //
119:   // Hamming distance histogram:
120:   //
121:   //  0: --
122:   //  1: --
123:   //  2: --
124:   //  3: --
125:   //  4: --
126:   //  5: |||||||||||||| (28.33%)
127:   //  6: |||||||||||||||||||| (38.33%)
128:   //  7: |||||||||| (19.17%)
129:   //  8: ||| (5.83%)
130:   //  9: || (4.17%)
131:   // 10: | (2.50%)
132:   // 11:  (0.83%)
133:   // 12:  (0.83%)
134:   //
135:   // Minimum Hamming distance: 5
136:   // Maximum Hamming distance: 12
137:   // Minimum Hamming weight: 4
138:   // Maximum Hamming weight: 8
139:   //
140:   localparam int StateWidth = 12;
141:   typedef enum logic [StateWidth-1:0] {
142:     ResetSt         = 12'b011000001110,
143:     InitSt          = 12'b110100100111,
144:     InitWaitSt      = 12'b001110110001,
145:     InitDescrSt     = 12'b110010000100,
146:     InitDescrWaitSt = 12'b100110101000,
147:     IdleSt          = 12'b010101001101,
148:     IntegScrSt      = 12'b110101011010,
149:     IntegScrWaitSt  = 12'b100010011111,
150:     IntegDigClrSt   = 12'b101001000001,
151:     IntegDigSt      = 12'b011101100010,
152:     IntegDigPadSt   = 12'b001101010111,
153:     IntegDigFinSt   = 12'b011011100101,
154:     IntegDigWaitSt  = 12'b100011110010,
155:     CnstyReadSt     = 12'b000001101011,
156:     CnstyReadWaitSt = 12'b101001111100,
157:     ErrorSt         = 12'b010110111110
158:   } state_e;
159: 
160:   typedef enum logic {
161:     ScrmblData,
162:     OtpData
163:   } data_sel_e;
164: 
165:   typedef enum logic {
166:     PartOffset,
167:     DigOffset
168:   } base_sel_e;
169: 
170:   state_e state_d, state_q;
171:   otp_err_e error_d, error_q;
172:   data_sel_e data_sel;
173:   base_sel_e base_sel;
174:   mubi8_t dout_locked_d, dout_locked_q;
175:   logic [CntWidth-1:0] cnt;
176:   logic cnt_en, cnt_clr, cnt_err;
177:   logic ecc_err;
178:   logic buffer_reg_en;
179:   logic [ScrmblBlockWidth-1:0] data_mux;
180: 
181:   // Output partition error state.
182:   assign error_o = error_q;
183: 
184:   // This partition cannot do any write accesses, hence we tie this
185:   // constantly off.
186:   assign otp_wdata_o = '0;
187:   // Depending on the partition configuration, the wrapper is instructed to ignore integrity
188:   // calculations and checks. To be on the safe side, the partition filters error responses at this
189:   // point and does not report any integrity errors if integrity is disabled.
190:   otp_err_e otp_err;
191:   if (Info.integrity) begin : gen_integrity
192:     assign otp_cmd_o = prim_otp_pkg::Read;
193:     assign otp_err = otp_err_e'(otp_err_i);
194:   end else begin : gen_no_integrity
195:     assign otp_cmd_o = prim_otp_pkg::ReadRaw;
196:     always_comb begin
197:       if (otp_err_e'(otp_err_i) inside {MacroEccCorrError, MacroEccUncorrError}) begin
198:         otp_err = NoError;
199:       end else begin
200:         otp_err = otp_err_e'(otp_err_i);
201:       end
202:     end
203:   end
204: 
205:   always_comb begin : p_fsm
206:     state_d = state_q;
207: 
208:     // Redundantly encoded lock signal for buffer regs.
209:     dout_locked_d = dout_locked_q;
210: 
211:     // OTP signals
212:     otp_req_o = 1'b0;
213: 
214:     // Scrambling mutex
215:     scrmbl_mtx_req_o = 1'b0;
216: 
217:     // Scrambling datapath
218:     scrmbl_cmd_o   = LoadShadow;
219:     scrmbl_sel_o   = CnstyDigest;
220:     scrmbl_mode_o  = StandardMode;
221:     scrmbl_valid_o = 1'b0;
222: 
223:     // Counter
224:     cnt_en   = 1'b0;
225:     cnt_clr  = 1'b0;
226:     base_sel = PartOffset;
227: 
228:     // Buffer register
229:     buffer_reg_en = 1'b0;
230:     data_sel = OtpData;
231: 
232:     // Error Register
233:     error_d = error_q;
234:     fsm_err_o = 1'b0;
235: 
236:     // Integrity/Consistency check responses
237:     cnsty_chk_ack_o = 1'b0;
238:     integ_chk_ack_o = 1'b0;
239: 
240:     unique case (state_q)
241:       ///////////////////////////////////////////////////////////////////
242:       // State right after reset. Wait here until we get a an
243:       // initialization request.
244:       ResetSt: begin
245:         if (init_req_i) begin
246:           state_d = InitSt;
247:         end
248:       end
249:       ///////////////////////////////////////////////////////////////////
250:       // Initialization reads out the digest only in unbuffered
251:       // partitions. Wait here until the OTP request has been granted.
252:       // And then wait until the OTP word comes back.
253:       InitSt: begin
254:         otp_req_o = 1'b1;
255:         if (otp_gnt_i) begin
256:           state_d = InitWaitSt;
257:         end
258:       end
259:       ///////////////////////////////////////////////////////////////////
260:       // Wait for OTP response and write to buffer register, then go to
261:       // descrambling state. In case an OTP transaction fails, latch the
262:       // OTP error code and jump to a
263:       // terminal error state.
264:       InitWaitSt: begin
265:         if (otp_rvalid_i) begin
266:           buffer_reg_en = 1'b1;
267:           if (otp_err inside {NoError, MacroEccCorrError}) begin
268:             // Once we've read and descrambled the whole partition, we can go to integrity
269:             // verification. Note that the last block is the digest value, which does not
270:             // have to be descrambled.
271:             if (cnt == LastScrmblBlock) begin
272:               state_d = IntegDigClrSt;
273:             // Only need to descramble if this is a scrambled partition.
274:             // Otherwise, we can just go back to InitSt and read the next block.
275:             end else if (Info.secret) begin
276:               state_d = InitDescrSt;
277:             end else begin
278:               state_d = InitSt;
279:               cnt_en = 1'b1;
280:             end
281:             // At this point the only error that we could have gotten are correctable ECC errors.
282:             if (otp_err != NoError) begin
283:               error_d = MacroEccCorrError;
284:             end
285:           end else begin
286:             state_d = ErrorSt;
287:             error_d = otp_err;
288:           end
289:         end
290:       end
291:       ///////////////////////////////////////////////////////////////////
292:       // Descrambling state. This first acquires the scrambling
293:       // datapath mutex. Note that once the mutex is acquired, we have
294:       // exclusive access to the scrambling datapath until we release
295:       // the mutex by deasserting scrmbl_mtx_req_o.
296:       // SEC_CM: SECRET.MEM.SCRAMBLE
297:       InitDescrSt: begin
298:         scrmbl_mtx_req_o = 1'b1;
299:         scrmbl_valid_o = 1'b1;
300:         scrmbl_cmd_o = Decrypt;
301:         scrmbl_sel_o = Info.key_sel;
302:         if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
303:           state_d = InitDescrWaitSt;
304:         end
305:       end
306:       ///////////////////////////////////////////////////////////////////
307:       // Wait for the descrambled data to return. Note that we release
308:       // the mutex lock upon leaving this state.
309:       // SEC_CM: SECRET.MEM.SCRAMBLE
310:       InitDescrWaitSt: begin
311:         scrmbl_mtx_req_o = 1'b1;
312:         scrmbl_sel_o = Info.key_sel;
313:         data_sel = ScrmblData;
314:         if (scrmbl_valid_i) begin
315:           state_d = InitSt;
316:           buffer_reg_en = 1'b1;
317:           cnt_en = 1'b1;
318:         end
319:       end
320:       ///////////////////////////////////////////////////////////////////
321:       // Idle state. We basically wait for integrity and consistency check
322:       // triggers in this state.
323:       IdleSt: begin
324:         if (integ_chk_req_i) begin
325:           if (Info.hw_digest) begin
326:             state_d = IntegDigClrSt;
327:           // In case there is nothing to check we can just
328:           // acknowledge the request right away, without going to the
329:           // integrity check.
330:           end else begin
331:             integ_chk_ack_o = 1'b1;
332:           end
333:         end else if (cnsty_chk_req_i) begin
334:           state_d = CnstyReadSt;
335:           cnt_clr = 1'b1;
336:         end
337:       end
338:       ///////////////////////////////////////////////////////////////////
339:       // Read the digest. Wait here until the OTP request has been granted.
340:       // And then wait until the OTP word comes back.
341:       // SEC_CM: PART.DATA_REG.BKGN_CHK
342:       CnstyReadSt: begin
343:         otp_req_o = 1'b1;
344:         // In case this partition has a hardware digest, we only have to read
345:         // and compare the digest value. In that case we select the digest offset here.
346:         // Otherwise we have to read and compare the whole partition, in which case we
347:         // select the partition offset, which is the default assignment of base_sel.
348:         if (Info.hw_digest) begin
349:           base_sel = DigOffset;
350:         end
351:         if (otp_gnt_i) begin
352:           state_d = CnstyReadWaitSt;
353:         end
354:       end
355:       ///////////////////////////////////////////////////////////////////
356:       // Wait for OTP response and compare the digest. In case there is
357:       // a mismatch, lock down the partition and go into the terminal error
358:       // state. In case an OTP transaction fails, latch the OTP error code
359:       // and jump to a terminal error state.
360:       // SEC_CM: PART.DATA_REG.BKGN_CHK
361:       CnstyReadWaitSt: begin
362:         if (otp_rvalid_i) begin
363:           if (otp_err inside {NoError, MacroEccCorrError}) begin
364:             // Check whether we need to compare the digest or the full partition
365:             // contents here.
366:             if (Info.hw_digest) begin
367:               // Note that we ignore this check if the digest is still blank.
368:               if (digest_o == data_mux || digest_o == '0) begin
369:                 state_d = IdleSt;
370:                 cnsty_chk_ack_o = 1'b1;
371:               // Error out and lock the partition if this check fails.
372:               end else begin
373:                 state_d = ErrorSt;
374:                 error_d = CheckFailError;
375:                 // The check has finished and found an error.
376:                 cnsty_chk_ack_o = 1'b1;
377:               end
378:             end else begin
379:               // Check whether the read data corresponds with the data buffered in regs.
380:               // Note that this particular check can be bypassed in case a transition is ongoing.
381:               if (scrmbl_data_o == data_mux ||
382:                   lc_ctrl_pkg::lc_tx_test_true_strict(check_byp_en_i)) begin
383:                 // Can go back to idle and acknowledge the
384:                 // request if this is the last block.
385:                 if (cnt == LastScrmblBlock) begin
386:                   state_d = IdleSt;
387:                   cnsty_chk_ack_o = 1'b1;
388:                 // Need to go back and read out more blocks.
389:                 end else begin
390:                   state_d = CnstyReadSt;
391:                   cnt_en = 1'b1;
392:                 end
393:               end else begin
394:                 state_d = ErrorSt;
395:                 error_d = CheckFailError;
396:                 // The check has finished and found an error.
397:                 cnsty_chk_ack_o = 1'b1;
398:               end
399:             end
400:             // At this point the only error that we could have gotten are correctable ECC errors.
401:             if (otp_err != NoError) begin
402:               error_d = MacroEccCorrError;
403:             end
404:           end else begin
405:             state_d = ErrorSt;
406:             error_d = otp_err;
407:             // The check has finished and found an error.
408:             cnsty_chk_ack_o = 1'b1;
409:           end
410:         end
411:       end
412:       ///////////////////////////////////////////////////////////////////
413:       // First, acquire the mutex for the digest and clear the digest state.
414:       // SEC_CM: PART.DATA_REG.BKGN_CHK
415:       IntegDigClrSt: begin
416:         // Check whether this partition requires checking at all.
417:         if (Info.hw_digest) begin
418:           scrmbl_mtx_req_o = 1'b1;
419:           scrmbl_valid_o = 1'b1;
420:           cnt_clr = 1'b1;
421:           // Need to reset the digest state and set it to chained
422:           // mode if this partition is scrambled.
423:           scrmbl_cmd_o = DigestInit;
424:           if (Info.secret) begin
425:             scrmbl_mode_o = ChainedMode;
426:             if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
427:               state_d = IntegScrSt;
428:             end
429:           // If this partition is not scrambled, we can just directly
430:           // jump to the digest state.
431:           end else begin
432:             scrmbl_mode_o = StandardMode;
433:             if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
434:               state_d = IntegDigSt;
435:             end
436:           end
437:         // Otherwise, if this partition is not digest protected,
438:         // we can just go to idle, since there is nothing to check.
439:         // Note that we do not come back to this state in case there is no
440:         // digest, and hence it is safe to unlock the buffer regs at this point.
441:         // This is the only way the buffer regs can get unlocked.
442:         end else begin
443:           state_d = IdleSt;
444:           if (mubi8_test_true_strict(dout_locked_q)) begin
445:             dout_locked_d = MuBi8False;
446:           end
447:         end
448:       end
449:       ///////////////////////////////////////////////////////////////////
450:       // Scramble buffered data (which is held in plaintext form).
451:       // This moves the previous scrambling result into the shadow reg
452:       // for later use.
453:       // SEC_CM: PART.DATA_REG.BKGN_CHK
454:       IntegScrSt: begin
455:           scrmbl_mtx_req_o = 1'b1;
456:           scrmbl_valid_o = 1'b1;
457:           scrmbl_cmd_o = Encrypt;
458:           scrmbl_sel_o = Info.key_sel;
459:           if (scrmbl_ready_i) begin
460:             state_d = IntegScrWaitSt;
461:           end
462:       end
463:       ///////////////////////////////////////////////////////////////////
464:       // Wait for the scrambled data to return.
465:       // SEC_CM: PART.DATA_REG.BKGN_CHK
466:       IntegScrWaitSt: begin
467:         scrmbl_mtx_req_o = 1'b1;
468:         scrmbl_sel_o = Info.key_sel;
469:         if (scrmbl_valid_i) begin
470:           state_d = IntegDigSt;
471:         end
472:       end
473:       ///////////////////////////////////////////////////////////////////
474:       // Push the word read into the scrambling datapath. The last
475:       // block is repeated in case the number blocks in this partition
476:       // is odd.
477:       // SEC_CM: PART.MEM.DIGEST
478:       // SEC_CM: PART.DATA_REG.BKGN_CHK
479:       IntegDigSt: begin
480:         scrmbl_mtx_req_o = 1'b1;
481:         scrmbl_valid_o = 1'b1;
482:         if (scrmbl_ready_i) begin
483:           cnt_en = 1'b1;
484:           // No need to digest the digest value itself
485:           if (cnt == PenultimateScrmblBlock) begin
486:             // Note that the digest operates on 128bit blocks since the data is fed in via the
487:             // PRESENT key input. Therefore, we only trigger a digest update on every second
488:             // 64bit block that is pushed into the scrambling datapath.
489:             if (cnt[0]) begin
490:               scrmbl_cmd_o = Digest;
491:               state_d = IntegDigFinSt;
492:             end else begin
493:               state_d = IntegDigPadSt;
494:               cnt_en = 1'b0;
495:             end
496:           end else begin
497:             // Trigger digest round in case this is the second block in a row.
498:             if (cnt[0]) begin
499:               scrmbl_cmd_o = Digest;
500:             end
501:             // Go back and scramble the next data block if this is
502:             // a scrambled partition. Otherwise just stay here.
503:             if (Info.secret) begin
504:               state_d = IntegScrSt;
505:             end
506:           end
507:         end
508:       end
509:       ///////////////////////////////////////////////////////////////////
510:       // Padding state. When we get here, we've copied the last encryption
511:       // result into the shadow register such that we've effectively
512:       // repeated the last block twice in order to pad the data to 128bit.
513:       // SEC_CM: PART.MEM.DIGEST
514:       // SEC_CM: PART.DATA_REG.BKGN_CHK
515:       IntegDigPadSt: begin
516:         scrmbl_mtx_req_o = 1'b1;
517:         scrmbl_valid_o = 1'b1;
518:         scrmbl_cmd_o = Digest;
519:         if (scrmbl_ready_i) begin
520:           state_d = IntegDigFinSt;
521:         end
522:       end
523:       ///////////////////////////////////////////////////////////////////
524:       // Trigger digest finalization and go wait for the result.
525:       // SEC_CM: PART.MEM.DIGEST
526:       // SEC_CM: PART.DATA_REG.BKGN_CHK
527:       IntegDigFinSt: begin
528:         scrmbl_mtx_req_o = 1'b1;
529:         scrmbl_valid_o = 1'b1;
530:         scrmbl_cmd_o = DigestFinalize;
531:         if (scrmbl_ready_i) begin
532:           state_d = IntegDigWaitSt;
533:         end
534:       end
535:       ///////////////////////////////////////////////////////////////////
536:       // Wait for the digest to return, and double check whether the digest
537:       // matches. If yes, unlock the partition. Otherwise, go into the terminal
538:       // error state, where the partition will be locked down.
539:       // SEC_CM: PART.MEM.DIGEST
540:       // SEC_CM: PART.DATA_REG.BKGN_CHK
541:       IntegDigWaitSt: begin
542:         scrmbl_mtx_req_o = 1'b1;
543:         data_sel = ScrmblData;
544:         if (scrmbl_valid_i) begin
545:           // This is the only way the buffer regs can get unlocked.
546:           // Note that we ignore this check if the digest is still blank.
547:           if (digest_o == data_mux || digest_o == '0) begin
548:             state_d = IdleSt;
549:             // If the partition is still locked, this is the first integrity check after
550:             // initialization. This is the only way the buffer regs can get unlocked.
551:             if (mubi8_test_true_strict(dout_locked_q)) begin
552:               dout_locked_d = MuBi8False;
553:             // Otherwise, this integrity check has requested by the LFSR timer, and we have
554:             // to acknowledge its completion.
555:             end else begin
556:               integ_chk_ack_o = 1'b1;
557:             end
558:           // Error out and lock the partition if this check fails.
559:           end else begin
560:             state_d = ErrorSt;
561:             error_d = CheckFailError;
562:             // The check has finished and found an error.
563:             integ_chk_ack_o = 1'b1;
564:           end
565:         end
566:       end
567:       ///////////////////////////////////////////////////////////////////
568:       // Terminal Error State. This locks access to the partition.
569:       // Make sure the partition signals an error state if no error
570:       // code has been latched so far, and lock the buffer regs down.
571:       ErrorSt: begin
572:         dout_locked_d = MuBi8True;
573:         if (error_q == NoError) begin
574:           error_d = FsmStateError;
575:         end
576:         // If we are in error state, we cannot execute the checks anymore.
577:         // Hence the acknowledgements are returned immediately.
578:         cnsty_chk_ack_o = 1'b1;
579:         integ_chk_ack_o = 1'b1;
580:       end
581:       ///////////////////////////////////////////////////////////////////
582:       // We should never get here. If we do (e.g. via a malicious
583:       // glitch), error out immediately.
584:       default: begin
585:         state_d = ErrorSt;
586:         fsm_err_o = 1'b1;
587:       end
588:       ///////////////////////////////////////////////////////////////////
589:     endcase // state_q
590: 
591: 
592:     // Unconditionally jump into the terminal error state in case of
593:     // an ECC error or escalation, and lock access to the partition down.
594:     // SEC_CM: PART.FSM.LOCAL_ESC
595:     if (ecc_err) begin
596:       state_d = ErrorSt;
597:       if (state_q != ErrorSt) begin
598:         error_d = CheckFailError;
599:       end
600:     end
601:     // SEC_CM: PART.FSM.LOCAL_ESC, PART.FSM.GLOBAL_ESC
602:     if (lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) || cnt_err) begin
603:       state_d = ErrorSt;
604:       fsm_err_o = 1'b1;
605:       if (state_q != ErrorSt) begin
606:         error_d = FsmStateError;
607:       end
608:     end
609:   end
610: 
611:   ////////////////////////////
612:   // Address Calc and Muxes //
613:   ////////////////////////////
614: 
615:   // Address counter - this is only used for computing a digest, hence the increment is
616:   // fixed to 8 byte.
617:   // SEC_CM: PART.CTR.REDUN
618:   prim_count #(
619:     .Width(CntWidth)
620:   ) u_prim_count (
621:     .clk_i,
622:     .rst_ni,
623:     .clr_i(cnt_clr),
624:     .set_i(1'b0),
625:     .set_cnt_i('0),
626:     .incr_en_i(cnt_en),
627:     .decr_en_i(1'b0),
628:     .step_i(CntWidth'(1)),
629:     .commit_i(1'b1),
630:     .cnt_o(cnt),
631:     .cnt_after_commit_o(),
632:     .err_o(cnt_err)
633:   );
634: 
635:   logic [OtpByteAddrWidth-1:0] addr_base;
636:   assign addr_base = (base_sel == DigOffset) ? DigestOffset : Info.offset;
637: 
638:   // Note that OTP works on halfword (16bit) addresses, hence need to
639:   // shift the addresses appropriately.
640:   logic [OtpByteAddrWidth-1:0] addr_calc;
641:   assign addr_calc = OtpByteAddrWidth'({cnt, {$clog2(ScrmblBlockWidth/8){1'b0}}}) + addr_base;
642:   assign otp_addr_o = addr_calc[OtpByteAddrWidth-1:OtpAddrShift];
643: 
644:   if (OtpAddrShift > 0) begin : gen_unused
645:     logic unused_bits;
646:     assign unused_bits = ^addr_calc[OtpAddrShift-1:0];
647:   end
648: 
649:   // Always transfer 64bit blocks.
650:   assign otp_size_o = OtpSizeWidth'(unsigned'(ScrmblBlockWidth / OtpWidth) - 1);
651: 
652:   assign data_mux = (data_sel == ScrmblData) ? scrmbl_data_i : otp_rdata_i;
653: 
654:   /////////////////
655:   // Buffer Regs //
656:   /////////////////
657: 
658:   // SEC_CM: PART.DATA_REG.INTEGRITY
659:   logic [Info.size*8-1:0] data;
660:   otp_ctrl_ecc_reg #(
661:     .Width ( ScrmblBlockWidth ),
662:     .Depth ( NumScrmblBlocks  )
663:   ) u_otp_ctrl_ecc_reg (
664:     .clk_i,
665:     .rst_ni,
666:     .wren_i    ( buffer_reg_en ),
667:     .addr_i    ( cnt           ),
668:     .wdata_i   ( data_mux      ),
669:     .rdata_o   ( scrmbl_data_o ),
670:     .data_o    ( data          ),
671:     .ecc_err_o ( ecc_err       )
672:   );
673: 
674:   // We have successfully initialized the partition once it has been unlocked.
675:   assign init_done_o = mubi8_test_false_strict(dout_locked_q);
676:   // Hardware output gating.
677:   // Note that this is decoupled from the DAI access rules further below.
678:   assign data_o = data;
679:   // The digest does not have to be gated.
680:   assign digest_o = data[$high(data_o) -: ScrmblBlockWidth];
681: 
682:   ////////////////////////
683:   // DAI Access Control //
684:   ////////////////////////
685: 
686:   // Aggregate all possible DAI write /readlocks. The partition is also locked when uninitialized.
687:   // Note that the locks are redundantly encoded values.
688:   part_access_t access_pre;
689:   prim_mubi8_sender #(
690:     .AsyncOn(0)
691:   ) u_prim_mubi8_sender_write_lock_pre (
692:     .clk_i,
693:     .rst_ni,
694:     .mubi_i(mubi8_and_lo(dout_locked_q, access_i.write_lock)),
695:     .mubi_o(access_pre.write_lock)
696:   );
697:   prim_mubi8_sender #(
698:     .AsyncOn(0)
699:   ) u_prim_mubi8_sender_read_lock_pre (
700:     .clk_i,
701:     .rst_ni,
702:     .mubi_i(mubi8_and_lo(dout_locked_q, access_i.read_lock)),
703:     .mubi_o(access_pre.read_lock)
704:   );
705: 
706:   // SEC_CM: PART.MEM.SW_UNWRITABLE
707:   if (Info.write_lock) begin : gen_digest_write_lock
708:     mubi8_t digest_locked;
709:     assign digest_locked = (digest_o != '0) ? MuBi8True : MuBi8False;
710: 
711:     // This prevents the synthesis tool from optimizing the multibit signal.
712:     prim_mubi8_sender #(
713:       .AsyncOn(0)
714:     ) u_prim_mubi8_sender_write_lock (
715:       .clk_i,
716:       .rst_ni,
717:       .mubi_i(mubi8_and_lo(access_pre.write_lock, digest_locked)),
718:       .mubi_o(access_o.write_lock)
719:     );
720: 
721:     `ASSERT(DigestWriteLocksPartition_A, digest_o |-> mubi8_test_true_loose(access_o.write_lock))
722:   end else begin : gen_no_digest_write_lock
723:     assign access_o.write_lock = access_pre.write_lock;
724:   end
725: 
726:   // SEC_CM: PART.MEM.SW_UNREADABLE
727:   if (Info.read_lock) begin : gen_digest_read_lock
728:     mubi8_t digest_locked;
729:     assign digest_locked = (digest_o != '0) ? MuBi8True : MuBi8False;
730: 
731:     // This prevents the synthesis tool from optimizing the multibit signal.
732:     prim_mubi8_sender #(
733:       .AsyncOn(0)
734:     ) u_prim_mubi8_sender_read_lock (
735:       .clk_i,
736:       .rst_ni,
737:       .mubi_i(mubi8_and_lo(access_pre.read_lock, digest_locked)),
738:       .mubi_o(access_o.read_lock)
739:     );
740: 
741:     `ASSERT(DigestReadLocksPartition_A, digest_o |-> mubi8_test_true_loose(access_o.read_lock))
742:   end else begin : gen_no_digest_read_lock
743:     assign access_o.read_lock = access_pre.read_lock;
744:   end
745: 
746:   ///////////////
747:   // Registers //
748:   ///////////////
749: 
750:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, state_e, ResetSt)
751: 
752:   always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs
753:     if (!rst_ni) begin
754:       error_q       <= NoError;
755:       // data output is locked by default
756:       dout_locked_q <= MuBi8True;
757:     end else begin
758:       error_q       <= error_d;
759:       dout_locked_q <= dout_locked_d;
760:     end
761:   end
762: 
763:   ////////////////
764:   // Assertions //
765:   ////////////////
766: 
767:   // Known assertions
768:   `ASSERT_KNOWN(InitDoneKnown_A,     init_done_o)
769:   `ASSERT_KNOWN(IntegChkAckKnown_A,  integ_chk_ack_o)
770:   `ASSERT_KNOWN(CnstyChkAckKnown_A,  cnsty_chk_ack_o)
771:   `ASSERT_KNOWN(ErrorKnown_A,        error_o)
772:   `ASSERT_KNOWN(AccessKnown_A,       access_o)
773:   `ASSERT_KNOWN(DigestKnown_A,       digest_o)
774:   `ASSERT_KNOWN(DataKnown_A,         data_o)
775:   `ASSERT_KNOWN(OtpReqKnown_A,       otp_req_o)
776:   `ASSERT_KNOWN(OtpCmdKnown_A,       otp_cmd_o)
777:   `ASSERT_KNOWN(OtpSizeKnown_A,      otp_size_o)
778:   `ASSERT_KNOWN(OtpWdataKnown_A,     otp_wdata_o)
779:   `ASSERT_KNOWN(OtpAddrKnown_A,      otp_addr_o)
780:   `ASSERT_KNOWN(ScrmblMtxReqKnown_A, scrmbl_mtx_req_o)
781:   `ASSERT_KNOWN(ScrmblCmdKnown_A,    scrmbl_cmd_o)
782:   `ASSERT_KNOWN(ScrmblModeKnown_A,   scrmbl_mode_o)
783:   `ASSERT_KNOWN(ScrmblSelKnown_A,    scrmbl_sel_o)
784:   `ASSERT_KNOWN(ScrmblDataKnown_A,   scrmbl_data_o)
785:   `ASSERT_KNOWN(ScrmblValidKnown_A,  scrmbl_valid_o)
786: 
787:   // Uninitialized partitions should always be locked, no matter what.
788:   `ASSERT(InitWriteLocksPartition_A,
789:       mubi8_test_true_loose(dout_locked_q)
790:       |->
791:       mubi8_test_true_loose(access_o.write_lock))
792:   `ASSERT(InitReadLocksPartition_A,
793:       mubi8_test_true_loose(dout_locked_q)
794:       |->
795:       mubi8_test_true_loose(access_o.read_lock))
796:   // Incoming Lock propagation
797:   `ASSERT(WriteLockPropagation_A,
798:       mubi8_test_true_loose(access_i.write_lock)
799:       |->
800:       mubi8_test_true_loose(access_o.write_lock))
801:   `ASSERT(ReadLockPropagation_A,
802:       mubi8_test_true_loose(access_i.read_lock)
803:       |->
804:       mubi8_test_true_loose(access_o.read_lock))
805:   // ECC error in buffer regs
806:   `ASSERT(EccErrorState_A,
807:       ecc_err
808:       |=>
809:       state_q == ErrorSt)
810:   // OTP error response
811:   `ASSERT(OtpErrorState_A,
812:       state_q inside {InitWaitSt, CnstyReadWaitSt} && otp_rvalid_i &&
813:       !(otp_err inside {NoError, MacroEccCorrError}) && !ecc_err
814:       |=>
815:       state_q == ErrorSt && error_o == $past(otp_err))
816: 
817:   // The partition size must be greater than one scrambling block for the address calculation
818:   // and muxing to work correctly.
819:   `ASSERT_INIT(OtpPartBufSize_A, Info.size > (ScrmblBlockWidth/8))
820: 
821: endmodule : otp_ctrl_part_buf

================================== Ai Message ==================================
Tool Calls:
  run_similar_bug_agent (call_wxENmWShVjpwHsf8UUCRiaKb)
 Call ID: call_wxENmWShVjpwHsf8UUCRiaKb
  Args:
    bug: dout_locked_d = MuBi8True;
    file_path: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv
================================ Human Message =================================

This bug was previously found in another file of this design:
    dout_locked_d = MuBi8True;
    
    Please check the RTL code in the file /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv for similar bugs.
================================ Human Message =================================

This bug was previously found in another file of this design:
    dout_locked_d = MuBi8True;
    
    Please check the RTL code in the file /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv for similar bugs.
================================== Ai Message ==================================

[{'text': "I'll help you find similar instances of this bug in the specified file. I'll use the similar_bug_tool to search for lines that match the given bug.", 'type': 'text'}, {'id': 'toolu_01XTZXbnaCk57VS2geuaXvxd', 'input': {'bug': 'dout_locked_d = MuBi8True;', 'ip_file': '/home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv'}, 'name': 'similar_bug_tool', 'type': 'tool_use'}]
Tool Calls:
  similar_bug_tool (toolu_01XTZXbnaCk57VS2geuaXvxd)
 Call ID: toolu_01XTZXbnaCk57VS2geuaXvxd
  Args:
    bug: dout_locked_d = MuBi8True;
    ip_file: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv
================================= Tool Message =================================
Name: similar_bug_tool

Error: ValueError("'dout_locked_q <= MuBi8True;\\n    end else begin' is not in list")
 Please fix your mistakes.
================================= Tool Message =================================
Name: similar_bug_tool

Error: ValueError("'dout_locked_q <= MuBi8True;\\n    end else begin' is not in list")
 Please fix your mistakes.
================================== Ai Message ==================================

[{'text': 'I apologize for the error. It seems the tool might be looking for a slightly different pattern. Let me read the file contents first to understand the context better:', 'type': 'text'}, {'id': 'toolu_01QZ9vzQcMovQvstX8ARMtNL', 'input': {'file_path': '/home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv'}, 'name': 'read_file_with_line_numbers', 'type': 'tool_use'}]
Tool Calls:
  read_file_with_line_numbers (toolu_01QZ9vzQcMovQvstX8ARMtNL)
 Call ID: toolu_01QZ9vzQcMovQvstX8ARMtNL
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Buffered partition for OTP controller.
6: //
7: 
8: `include "prim_flop_macros.sv"
9: 
10: module otp_ctrl_part_buf
11:   import otp_ctrl_pkg::*;
12:   import otp_ctrl_reg_pkg::*;
13:   import otp_ctrl_part_pkg::*;
14: #(
15:   // Partition information.
16:   parameter part_info_t             Info = PartInfoDefault,
17:   parameter logic [Info.size*8-1:0] DataDefault = '0
18: ) (
19:   input                               clk_i,
20:   input                               rst_ni,
21:   // Pulse to start partition initialisation (required once per power cycle).
22:   input                               init_req_i,
23:   output logic                        init_done_o,
24:   // Integrity check requests
25:   input                               integ_chk_req_i,
26:   output logic                        integ_chk_ack_o,
27:   // Consistency check requests
28:   input                               cnsty_chk_req_i,
29:   output logic                        cnsty_chk_ack_o,
30:   // Escalation input. This moves the FSM into a terminal state and locks down
31:   // the partition.
32:   input  lc_ctrl_pkg::lc_tx_t         escalate_en_i,
33:   // Check bypass enable. This bypasses integrity and consistency checks and
34:   // acknowledges all incoming check requests (only used by life cycle).
35:   input  lc_ctrl_pkg::lc_tx_t         check_byp_en_i,
36:   // Output error state of partition, to be consumed by OTP error/alert logic.
37:   // Note that most errors are not recoverable and move the partition FSM into
38:   // a terminal error state.
39:   output otp_err_e                    error_o,
40:   // This error signal is pulsed high if the FSM has been glitched into an invalid state.
41:   // Although it is somewhat redundant with the error code in error_o above, it is
42:   // meant to cover cases where we already latched an error code while the FSM is
43:   // glitched into an invalid state (since in that case, the error code will not be
44:   // overridden with the FSM error code so that the original error code is still
45:   // discoverable).
46:   output logic                        fsm_err_o,
47:   // Access/lock status
48:   // SEC_CM: ACCESS.CTRL.MUBI
49:   input  part_access_t                access_i, // runtime lock from CSRs
50:   output part_access_t                access_o,
51:   // Buffered 64bit digest output.
52:   output logic [ScrmblBlockWidth-1:0] digest_o,
53:   output logic [Info.size*8-1:0]      data_o,
54:   // OTP interface
55:   output logic                        otp_req_o,
56:   output prim_otp_pkg::cmd_e          otp_cmd_o,
57:   output logic [OtpSizeWidth-1:0]     otp_size_o,
58:   output logic [OtpIfWidth-1:0]       otp_wdata_o,
59:   output logic [OtpAddrWidth-1:0]     otp_addr_o,
60:   input                               otp_gnt_i,
61:   input                               otp_rvalid_i,
62:   input  [ScrmblBlockWidth-1:0]       otp_rdata_i,
63:   input  prim_otp_pkg::err_e          otp_err_i,
64:   // Scrambling mutex request
65:   output logic                        scrmbl_mtx_req_o,
66:   input                               scrmbl_mtx_gnt_i,
67:   // Scrambling datapath interface
68:   output otp_scrmbl_cmd_e             scrmbl_cmd_o,
69:   output digest_mode_e                scrmbl_mode_o,
70:   output logic [ConstSelWidth-1:0]    scrmbl_sel_o,
71:   output logic [ScrmblBlockWidth-1:0] scrmbl_data_o,
72:   output logic                        scrmbl_valid_o,
73:   input  logic                        scrmbl_ready_i,
74:   input  logic                        scrmbl_valid_i,
75:   input  logic [ScrmblBlockWidth-1:0] scrmbl_data_i
76: );
77: 
78:   ////////////////////////
79:   // Integration Checks //
80:   ////////////////////////
81: 
82:   import prim_mubi_pkg::*;
83:   import prim_util_pkg::vbits;
84: 
85:   localparam int unsigned DigestOffsetInt = (int'(Info.offset) +
86:                                              int'(Info.size) - ScrmblBlockWidth/8);
87:   localparam int NumScrmblBlocks = int'(Info.size) / (ScrmblBlockWidth/8);
88:   localparam int CntWidth = vbits(NumScrmblBlocks);
89: 
90:   localparam bit [OtpByteAddrWidth-1:0] DigestOffset = DigestOffsetInt[OtpByteAddrWidth-1:0];
91: 
92:   localparam int unsigned LastScrmblBlockInt = NumScrmblBlocks - 1;
93:   localparam int unsigned PenultimateScrmblBlockInt = NumScrmblBlocks - 2;
94:   localparam bit [CntWidth-1:0] LastScrmblBlock = LastScrmblBlockInt[CntWidth-1:0];
95:   localparam bit [CntWidth-1:0] PenultimateScrmblBlock = PenultimateScrmblBlockInt[CntWidth-1:0];
96: 
97:   // Integration checks for parameters.
98:   `ASSERT_INIT(OffsetMustBeBlockAligned_A, (Info.offset % (ScrmblBlockWidth/8)) == 0)
99:   `ASSERT_INIT(SizeMustBeBlockAligned_A, (Info.size % (ScrmblBlockWidth/8)) == 0)
100:   `ASSERT_INIT(DigestOffsetMustBeRepresentable_A, DigestOffsetInt == int'(DigestOffset))
101:   `ASSERT(ScrambledImpliesDigest_A, Info.secret |-> Info.hw_digest)
102:   `ASSERT(WriteLockImpliesDigest_A, Info.read_lock |-> Info.hw_digest)
103:   `ASSERT(ReadLockImpliesDigest_A, Info.write_lock |-> Info.hw_digest)
104: 
105:   // This feature is only supposed to be used with partitions that are not scrambled
106:   // and that do not have a digest.
107:   `ASSERT(BypassEnable0_A, Info.secret    |-> lc_ctrl_pkg::lc_tx_test_false_strict(check_byp_en_i))
108:   `ASSERT(BypassEnable1_A, Info.hw_digest |-> lc_ctrl_pkg::lc_tx_test_false_strict(check_byp_en_i))
109: 
110:   ///////////////////////
111:   // OTP Partition FSM //
112:   ///////////////////////
113: 
114:   // SEC_CM: PART.FSM.SPARSE
115:   // Encoding generated with:
116:   // $ ./util/design/sparse-fsm-encode.py -d 5 -m 16 -n 12 \
117:   //      -s 3370657881 --language=sv
118:   //
119:   // Hamming distance histogram:
120:   //
121:   //  0: --
122:   //  1: --
123:   //  2: --
124:   //  3: --
125:   //  4: --
126:   //  5: |||||||||||||| (28.33%)
127:   //  6: |||||||||||||||||||| (38.33%)
128:   //  7: |||||||||| (19.17%)
129:   //  8: ||| (5.83%)
130:   //  9: || (4.17%)
131:   // 10: | (2.50%)
132:   // 11:  (0.83%)
133:   // 12:  (0.83%)
134:   //
135:   // Minimum Hamming distance: 5
136:   // Maximum Hamming distance: 12
137:   // Minimum Hamming weight: 4
138:   // Maximum Hamming weight: 8
139:   //
140:   localparam int StateWidth = 12;
141:   typedef enum logic [StateWidth-1:0] {
142:     ResetSt         = 12'b011000001110,
143:     InitSt          = 12'b110100100111,
144:     InitWaitSt      = 12'b001110110001,
145:     InitDescrSt     = 12'b110010000100,
146:     InitDescrWaitSt = 12'b100110101000,
147:     IdleSt          = 12'b010101001101,
148:     IntegScrSt      = 12'b110101011010,
149:     IntegScrWaitSt  = 12'b100010011111,
150:     IntegDigClrSt   = 12'b101001000001,
151:     IntegDigSt      = 12'b011101100010,
152:     IntegDigPadSt   = 12'b001101010111,
153:     IntegDigFinSt   = 12'b011011100101,
154:     IntegDigWaitSt  = 12'b100011110010,
155:     CnstyReadSt     = 12'b000001101011,
156:     CnstyReadWaitSt = 12'b101001111100,
157:     ErrorSt         = 12'b010110111110
158:   } state_e;
159: 
160:   typedef enum logic {
161:     ScrmblData,
162:     OtpData
163:   } data_sel_e;
164: 
165:   typedef enum logic {
166:     PartOffset,
167:     DigOffset
168:   } base_sel_e;
169: 
170:   state_e state_d, state_q;
171:   otp_err_e error_d, error_q;
172:   data_sel_e data_sel;
173:   base_sel_e base_sel;
174:   mubi8_t dout_locked_d, dout_locked_q;
175:   logic [CntWidth-1:0] cnt;
176:   logic cnt_en, cnt_clr, cnt_err;
177:   logic ecc_err;
178:   logic buffer_reg_en;
179:   logic [ScrmblBlockWidth-1:0] data_mux;
180: 
181:   // Output partition error state.
182:   assign error_o = error_q;
183: 
184:   // This partition cannot do any write accesses, hence we tie this
185:   // constantly off.
186:   assign otp_wdata_o = '0;
187:   // Depending on the partition configuration, the wrapper is instructed to ignore integrity
188:   // calculations and checks. To be on the safe side, the partition filters error responses at this
189:   // point and does not report any integrity errors if integrity is disabled.
190:   otp_err_e otp_err;
191:   if (Info.integrity) begin : gen_integrity
192:     assign otp_cmd_o = prim_otp_pkg::Read;
193:     assign otp_err = otp_err_e'(otp_err_i);
194:   end else begin : gen_no_integrity
195:     assign otp_cmd_o = prim_otp_pkg::ReadRaw;
196:     always_comb begin
197:       if (otp_err_e'(otp_err_i) inside {MacroEccCorrError, MacroEccUncorrError}) begin
198:         otp_err = NoError;
199:       end else begin
200:         otp_err = otp_err_e'(otp_err_i);
201:       end
202:     end
203:   end
204: 
205:   always_comb begin : p_fsm
206:     state_d = state_q;
207: 
208:     // Redundantly encoded lock signal for buffer regs.
209:     dout_locked_d = dout_locked_q;
210: 
211:     // OTP signals
212:     otp_req_o = 1'b0;
213: 
214:     // Scrambling mutex
215:     scrmbl_mtx_req_o = 1'b0;
216: 
217:     // Scrambling datapath
218:     scrmbl_cmd_o   = LoadShadow;
219:     scrmbl_sel_o   = CnstyDigest;
220:     scrmbl_mode_o  = StandardMode;
221:     scrmbl_valid_o = 1'b0;
222: 
223:     // Counter
224:     cnt_en   = 1'b0;
225:     cnt_clr  = 1'b0;
226:     base_sel = PartOffset;
227: 
228:     // Buffer register
229:     buffer_reg_en = 1'b0;
230:     data_sel = OtpData;
231: 
232:     // Error Register
233:     error_d = error_q;
234:     fsm_err_o = 1'b0;
235: 
236:     // Integrity/Consistency check responses
237:     cnsty_chk_ack_o = 1'b0;
238:     integ_chk_ack_o = 1'b0;
239: 
240:     unique case (state_q)
241:       ///////////////////////////////////////////////////////////////////
242:       // State right after reset. Wait here until we get a an
243:       // initialization request.
244:       ResetSt: begin
245:         if (init_req_i) begin
246:           state_d = InitSt;
247:         end
248:       end
249:       ///////////////////////////////////////////////////////////////////
250:       // Initialization reads out the digest only in unbuffered
251:       // partitions. Wait here until the OTP request has been granted.
252:       // And then wait until the OTP word comes back.
253:       InitSt: begin
254:         otp_req_o = 1'b1;
255:         if (otp_gnt_i) begin
256:           state_d = InitWaitSt;
257:         end
258:       end
259:       ///////////////////////////////////////////////////////////////////
260:       // Wait for OTP response and write to buffer register, then go to
261:       // descrambling state. In case an OTP transaction fails, latch the
262:       // OTP error code and jump to a
263:       // terminal error state.
264:       InitWaitSt: begin
265:         if (otp_rvalid_i) begin
266:           buffer_reg_en = 1'b1;
267:           if (otp_err inside {NoError, MacroEccCorrError}) begin
268:             // Once we've read and descrambled the whole partition, we can go to integrity
269:             // verification. Note that the last block is the digest value, which does not
270:             // have to be descrambled.
271:             if (cnt == LastScrmblBlock) begin
272:               state_d = IntegDigClrSt;
273:             // Only need to descramble if this is a scrambled partition.
274:             // Otherwise, we can just go back to InitSt and read the next block.
275:             end else if (Info.secret) begin
276:               state_d = InitDescrSt;
277:             end else begin
278:               state_d = InitSt;
279:               cnt_en = 1'b1;
280:             end
281:             // At this point the only error that we could have gotten are correctable ECC errors.
282:             if (otp_err != NoError) begin
283:               error_d = MacroEccCorrError;
284:             end
285:           end else begin
286:             state_d = ErrorSt;
287:             error_d = otp_err;
288:           end
289:         end
290:       end
291:       ///////////////////////////////////////////////////////////////////
292:       // Descrambling state. This first acquires the scrambling
293:       // datapath mutex. Note that once the mutex is acquired, we have
294:       // exclusive access to the scrambling datapath until we release
295:       // the mutex by deasserting scrmbl_mtx_req_o.
296:       // SEC_CM: SECRET.MEM.SCRAMBLE
297:       InitDescrSt: begin
298:         scrmbl_mtx_req_o = 1'b1;
299:         scrmbl_valid_o = 1'b1;
300:         scrmbl_cmd_o = Decrypt;
301:         scrmbl_sel_o = Info.key_sel;
302:         if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
303:           state_d = InitDescrWaitSt;
304:         end
305:       end
306:       ///////////////////////////////////////////////////////////////////
307:       // Wait for the descrambled data to return. Note that we release
308:       // the mutex lock upon leaving this state.
309:       // SEC_CM: SECRET.MEM.SCRAMBLE
310:       InitDescrWaitSt: begin
311:         scrmbl_mtx_req_o = 1'b1;
312:         scrmbl_sel_o = Info.key_sel;
313:         data_sel = ScrmblData;
314:         if (scrmbl_valid_i) begin
315:           state_d = InitSt;
316:           buffer_reg_en = 1'b1;
317:           cnt_en = 1'b1;
318:         end
319:       end
320:       ///////////////////////////////////////////////////////////////////
321:       // Idle state. We basically wait for integrity and consistency check
322:       // triggers in this state.
323:       IdleSt: begin
324:         if (integ_chk_req_i) begin
325:           if (Info.hw_digest) begin
326:             state_d = IntegDigClrSt;
327:           // In case there is nothing to check we can just
328:           // acknowledge the request right away, without going to the
329:           // integrity check.
330:           end else begin
331:             integ_chk_ack_o = 1'b1;
332:           end
333:         end else if (cnsty_chk_req_i) begin
334:           state_d = CnstyReadSt;
335:           cnt_clr = 1'b1;
336:         end
337:       end
338:       ///////////////////////////////////////////////////////////////////
339:       // Read the digest. Wait here until the OTP request has been granted.
340:       // And then wait until the OTP word comes back.
341:       // SEC_CM: PART.DATA_REG.BKGN_CHK
342:       CnstyReadSt: begin
343:         otp_req_o = 1'b1;
344:         // In case this partition has a hardware digest, we only have to read
345:         // and compare the digest value. In that case we select the digest offset here.
346:         // Otherwise we have to read and compare the whole partition, in which case we
347:         // select the partition offset, which is the default assignment of base_sel.
348:         if (Info.hw_digest) begin
349:           base_sel = DigOffset;
350:         end
351:         if (otp_gnt_i) begin
352:           state_d = CnstyReadWaitSt;
353:         end
354:       end
355:       ///////////////////////////////////////////////////////////////////
356:       // Wait for OTP response and compare the digest. In case there is
357:       // a mismatch, lock down the partition and go into the terminal error
358:       // state. In case an OTP transaction fails, latch the OTP error code
359:       // and jump to a terminal error state.
360:       // SEC_CM: PART.DATA_REG.BKGN_CHK
361:       CnstyReadWaitSt: begin
362:         if (otp_rvalid_i) begin
363:           if (otp_err inside {NoError, MacroEccCorrError}) begin
364:             // Check whether we need to compare the digest or the full partition
365:             // contents here.
366:             if (Info.hw_digest) begin
367:               // Note that we ignore this check if the digest is still blank.
368:               if (digest_o == data_mux || digest_o == '0) begin
369:                 state_d = IdleSt;
370:                 cnsty_chk_ack_o = 1'b1;
371:               // Error out and lock the partition if this check fails.
372:               end else begin
373:                 state_d = ErrorSt;
374:                 error_d = CheckFailError;
375:                 // The check has finished and found an error.
376:                 cnsty_chk_ack_o = 1'b1;
377:               end
378:             end else begin
379:               // Check whether the read data corresponds with the data buffered in regs.
380:               // Note that this particular check can be bypassed in case a transition is ongoing.
381:               if (scrmbl_data_o == data_mux ||
382:                   lc_ctrl_pkg::lc_tx_test_true_strict(check_byp_en_i)) begin
383:                 // Can go back to idle and acknowledge the
384:                 // request if this is the last block.
385:                 if (cnt == LastScrmblBlock) begin
386:                   state_d = IdleSt;
387:                   cnsty_chk_ack_o = 1'b1;
388:                 // Need to go back and read out more blocks.
389:                 end else begin
390:                   state_d = CnstyReadSt;
391:                   cnt_en = 1'b1;
392:                 end
393:               end else begin
394:                 state_d = ErrorSt;
395:                 error_d = CheckFailError;
396:                 // The check has finished and found an error.
397:                 cnsty_chk_ack_o = 1'b1;
398:               end
399:             end
400:             // At this point the only error that we could have gotten are correctable ECC errors.
401:             if (otp_err != NoError) begin
402:               error_d = MacroEccCorrError;
403:             end
404:           end else begin
405:             state_d = ErrorSt;
406:             error_d = otp_err;
407:             // The check has finished and found an error.
408:             cnsty_chk_ack_o = 1'b1;
409:           end
410:         end
411:       end
412:       ///////////////////////////////////////////////////////////////////
413:       // First, acquire the mutex for the digest and clear the digest state.
414:       // SEC_CM: PART.DATA_REG.BKGN_CHK
415:       IntegDigClrSt: begin
416:         // Check whether this partition requires checking at all.
417:         if (Info.hw_digest) begin
418:           scrmbl_mtx_req_o = 1'b1;
419:           scrmbl_valid_o = 1'b1;
420:           cnt_clr = 1'b1;
421:           // Need to reset the digest state and set it to chained
422:           // mode if this partition is scrambled.
423:           scrmbl_cmd_o = DigestInit;
424:           if (Info.secret) begin
425:             scrmbl_mode_o = ChainedMode;
426:             if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
427:               state_d = IntegScrSt;
428:             end
429:           // If this partition is not scrambled, we can just directly
430:           // jump to the digest state.
431:           end else begin
432:             scrmbl_mode_o = StandardMode;
433:             if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
434:               state_d = IntegDigSt;
435:             end
436:           end
437:         // Otherwise, if this partition is not digest protected,
438:         // we can just go to idle, since there is nothing to check.
439:         // Note that we do not come back to this state in case there is no
440:         // digest, and hence it is safe to unlock the buffer regs at this point.
441:         // This is the only way the buffer regs can get unlocked.
442:         end else begin
443:           state_d = IdleSt;
444:           if (mubi8_test_true_strict(dout_locked_q)) begin
445:             dout_locked_d = MuBi8False;
446:           end
447:         end
448:       end
449:       ///////////////////////////////////////////////////////////////////
450:       // Scramble buffered data (which is held in plaintext form).
451:       // This moves the previous scrambling result into the shadow reg
452:       // for later use.
453:       // SEC_CM: PART.DATA_REG.BKGN_CHK
454:       IntegScrSt: begin
455:           scrmbl_mtx_req_o = 1'b1;
456:           scrmbl_valid_o = 1'b1;
457:           scrmbl_cmd_o = Encrypt;
458:           scrmbl_sel_o = Info.key_sel;
459:           if (scrmbl_ready_i) begin
460:             state_d = IntegScrWaitSt;
461:           end
462:       end
463:       ///////////////////////////////////////////////////////////////////
464:       // Wait for the scrambled data to return.
465:       // SEC_CM: PART.DATA_REG.BKGN_CHK
466:       IntegScrWaitSt: begin
467:         scrmbl_mtx_req_o = 1'b1;
468:         scrmbl_sel_o = Info.key_sel;
469:         if (scrmbl_valid_i) begin
470:           state_d = IntegDigSt;
471:         end
472:       end
473:       ///////////////////////////////////////////////////////////////////
474:       // Push the word read into the scrambling datapath. The last
475:       // block is repeated in case the number blocks in this partition
476:       // is odd.
477:       // SEC_CM: PART.MEM.DIGEST
478:       // SEC_CM: PART.DATA_REG.BKGN_CHK
479:       IntegDigSt: begin
480:         scrmbl_mtx_req_o = 1'b1;
481:         scrmbl_valid_o = 1'b1;
482:         if (scrmbl_ready_i) begin
483:           cnt_en = 1'b1;
484:           // No need to digest the digest value itself
485:           if (cnt == PenultimateScrmblBlock) begin
486:             // Note that the digest operates on 128bit blocks since the data is fed in via the
487:             // PRESENT key input. Therefore, we only trigger a digest update on every second
488:             // 64bit block that is pushed into the scrambling datapath.
489:             if (cnt[0]) begin
490:               scrmbl_cmd_o = Digest;
491:               state_d = IntegDigFinSt;
492:             end else begin
493:               state_d = IntegDigPadSt;
494:               cnt_en = 1'b0;
495:             end
496:           end else begin
497:             // Trigger digest round in case this is the second block in a row.
498:             if (cnt[0]) begin
499:               scrmbl_cmd_o = Digest;
500:             end
501:             // Go back and scramble the next data block if this is
502:             // a scrambled partition. Otherwise just stay here.
503:             if (Info.secret) begin
504:               state_d = IntegScrSt;
505:             end
506:           end
507:         end
508:       end
509:       ///////////////////////////////////////////////////////////////////
510:       // Padding state. When we get here, we've copied the last encryption
511:       // result into the shadow register such that we've effectively
512:       // repeated the last block twice in order to pad the data to 128bit.
513:       // SEC_CM: PART.MEM.DIGEST
514:       // SEC_CM: PART.DATA_REG.BKGN_CHK
515:       IntegDigPadSt: begin
516:         scrmbl_mtx_req_o = 1'b1;
517:         scrmbl_valid_o = 1'b1;
518:         scrmbl_cmd_o = Digest;
519:         if (scrmbl_ready_i) begin
520:           state_d = IntegDigFinSt;
521:         end
522:       end
523:       ///////////////////////////////////////////////////////////////////
524:       // Trigger digest finalization and go wait for the result.
525:       // SEC_CM: PART.MEM.DIGEST
526:       // SEC_CM: PART.DATA_REG.BKGN_CHK
527:       IntegDigFinSt: begin
528:         scrmbl_mtx_req_o = 1'b1;
529:         scrmbl_valid_o = 1'b1;
530:         scrmbl_cmd_o = DigestFinalize;
531:         if (scrmbl_ready_i) begin
532:           state_d = IntegDigWaitSt;
533:         end
534:       end
535:       ///////////////////////////////////////////////////////////////////
536:       // Wait for the digest to return, and double check whether the digest
537:       // matches. If yes, unlock the partition. Otherwise, go into the terminal
538:       // error state, where the partition will be locked down.
539:       // SEC_CM: PART.MEM.DIGEST
540:       // SEC_CM: PART.DATA_REG.BKGN_CHK
541:       IntegDigWaitSt: begin
542:         scrmbl_mtx_req_o = 1'b1;
543:         data_sel = ScrmblData;
544:         if (scrmbl_valid_i) begin
545:           // This is the only way the buffer regs can get unlocked.
546:           // Note that we ignore this check if the digest is still blank.
547:           if (digest_o == data_mux || digest_o == '0) begin
548:             state_d = IdleSt;
549:             // If the partition is still locked, this is the first integrity check after
550:             // initialization. This is the only way the buffer regs can get unlocked.
551:             if (mubi8_test_true_strict(dout_locked_q)) begin
552:               dout_locked_d = MuBi8False;
553:             // Otherwise, this integrity check has requested by the LFSR timer, and we have
554:             // to acknowledge its completion.
555:             end else begin
556:               integ_chk_ack_o = 1'b1;
557:             end
558:           // Error out and lock the partition if this check fails.
559:           end else begin
560:             state_d = ErrorSt;
561:             error_d = CheckFailError;
562:             // The check has finished and found an error.
563:             integ_chk_ack_o = 1'b1;
564:           end
565:         end
566:       end
567:       ///////////////////////////////////////////////////////////////////
568:       // Terminal Error State. This locks access to the partition.
569:       // Make sure the partition signals an error state if no error
570:       // code has been latched so far, and lock the buffer regs down.
571:       ErrorSt: begin
572:         dout_locked_d = MuBi8True;
573:         if (error_q == NoError) begin
574:           error_d = FsmStateError;
575:         end
576:         // If we are in error state, we cannot execute the checks anymore.
577:         // Hence the acknowledgements are returned immediately.
578:         cnsty_chk_ack_o = 1'b1;
579:         integ_chk_ack_o = 1'b1;
580:       end
581:       ///////////////////////////////////////////////////////////////////
582:       // We should never get here. If we do (e.g. via a malicious
583:       // glitch), error out immediately.
584:       default: begin
585:         state_d = ErrorSt;
586:         fsm_err_o = 1'b1;
587:       end
588:       ///////////////////////////////////////////////////////////////////
589:     endcase // state_q
590: 
591: 
592:     // Unconditionally jump into the terminal error state in case of
593:     // an ECC error or escalation, and lock access to the partition down.
594:     // SEC_CM: PART.FSM.LOCAL_ESC
595:     if (ecc_err) begin
596:       state_d = ErrorSt;
597:       if (state_q != ErrorSt) begin
598:         error_d = CheckFailError;
599:       end
600:     end
601:     // SEC_CM: PART.FSM.LOCAL_ESC, PART.FSM.GLOBAL_ESC
602:     if (lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) || cnt_err) begin
603:       state_d = ErrorSt;
604:       fsm_err_o = 1'b1;
605:       if (state_q != ErrorSt) begin
606:         error_d = FsmStateError;
607:       end
608:     end
609:   end
610: 
611:   ////////////////////////////
612:   // Address Calc and Muxes //
613:   ////////////////////////////
614: 
615:   // Address counter - this is only used for computing a digest, hence the increment is
616:   // fixed to 8 byte.
617:   // SEC_CM: PART.CTR.REDUN
618:   prim_count #(
619:     .Width(CntWidth)
620:   ) u_prim_count (
621:     .clk_i,
622:     .rst_ni,
623:     .clr_i(cnt_clr),
624:     .set_i(1'b0),
625:     .set_cnt_i('0),
626:     .incr_en_i(cnt_en),
627:     .decr_en_i(1'b0),
628:     .step_i(CntWidth'(1)),
629:     .commit_i(1'b1),
630:     .cnt_o(cnt),
631:     .cnt_after_commit_o(),
632:     .err_o(cnt_err)
633:   );
634: 
635:   logic [OtpByteAddrWidth-1:0] addr_base;
636:   assign addr_base = (base_sel == DigOffset) ? DigestOffset : Info.offset;
637: 
638:   // Note that OTP works on halfword (16bit) addresses, hence need to
639:   // shift the addresses appropriately.
640:   logic [OtpByteAddrWidth-1:0] addr_calc;
641:   assign addr_calc = OtpByteAddrWidth'({cnt, {$clog2(ScrmblBlockWidth/8){1'b0}}}) + addr_base;
642:   assign otp_addr_o = addr_calc[OtpByteAddrWidth-1:OtpAddrShift];
643: 
644:   if (OtpAddrShift > 0) begin : gen_unused
645:     logic unused_bits;
646:     assign unused_bits = ^addr_calc[OtpAddrShift-1:0];
647:   end
648: 
649:   // Always transfer 64bit blocks.
650:   assign otp_size_o = OtpSizeWidth'(unsigned'(ScrmblBlockWidth / OtpWidth) - 1);
651: 
652:   assign data_mux = (data_sel == ScrmblData) ? scrmbl_data_i : otp_rdata_i;
653: 
654:   /////////////////
655:   // Buffer Regs //
656:   /////////////////
657: 
658:   // SEC_CM: PART.DATA_REG.INTEGRITY
659:   logic [Info.size*8-1:0] data;
660:   otp_ctrl_ecc_reg #(
661:     .Width ( ScrmblBlockWidth ),
662:     .Depth ( NumScrmblBlocks  )
663:   ) u_otp_ctrl_ecc_reg (
664:     .clk_i,
665:     .rst_ni,
666:     .wren_i    ( buffer_reg_en ),
667:     .addr_i    ( cnt           ),
668:     .wdata_i   ( data_mux      ),
669:     .rdata_o   ( scrmbl_data_o ),
670:     .data_o    ( data          ),
671:     .ecc_err_o ( ecc_err       )
672:   );
673: 
674:   // We have successfully initialized the partition once it has been unlocked.
675:   assign init_done_o = mubi8_test_false_strict(dout_locked_q);
676:   // Hardware output gating.
677:   // Note that this is decoupled from the DAI access rules further below.
678:   assign data_o = data;
679:   // The digest does not have to be gated.
680:   assign digest_o = data[$high(data_o) -: ScrmblBlockWidth];
681: 
682:   ////////////////////////
683:   // DAI Access Control //
684:   ////////////////////////
685: 
686:   // Aggregate all possible DAI write /readlocks. The partition is also locked when uninitialized.
687:   // Note that the locks are redundantly encoded values.
688:   part_access_t access_pre;
689:   prim_mubi8_sender #(
690:     .AsyncOn(0)
691:   ) u_prim_mubi8_sender_write_lock_pre (
692:     .clk_i,
693:     .rst_ni,
694:     .mubi_i(mubi8_and_lo(dout_locked_q, access_i.write_lock)),
695:     .mubi_o(access_pre.write_lock)
696:   );
697:   prim_mubi8_sender #(
698:     .AsyncOn(0)
699:   ) u_prim_mubi8_sender_read_lock_pre (
700:     .clk_i,
701:     .rst_ni,
702:     .mubi_i(mubi8_and_lo(dout_locked_q, access_i.read_lock)),
703:     .mubi_o(access_pre.read_lock)
704:   );
705: 
706:   // SEC_CM: PART.MEM.SW_UNWRITABLE
707:   if (Info.write_lock) begin : gen_digest_write_lock
708:     mubi8_t digest_locked;
709:     assign digest_locked = (digest_o != '0) ? MuBi8True : MuBi8False;
710: 
711:     // This prevents the synthesis tool from optimizing the multibit signal.
712:     prim_mubi8_sender #(
713:       .AsyncOn(0)
714:     ) u_prim_mubi8_sender_write_lock (
715:       .clk_i,
716:       .rst_ni,
717:       .mubi_i(mubi8_and_lo(access_pre.write_lock, digest_locked)),
718:       .mubi_o(access_o.write_lock)
719:     );
720: 
721:     `ASSERT(DigestWriteLocksPartition_A, digest_o |-> mubi8_test_true_loose(access_o.write_lock))
722:   end else begin : gen_no_digest_write_lock
723:     assign access_o.write_lock = access_pre.write_lock;
724:   end
725: 
726:   // SEC_CM: PART.MEM.SW_UNREADABLE
727:   if (Info.read_lock) begin : gen_digest_read_lock
728:     mubi8_t digest_locked;
729:     assign digest_locked = (digest_o != '0) ? MuBi8True : MuBi8False;
730: 
731:     // This prevents the synthesis tool from optimizing the multibit signal.
732:     prim_mubi8_sender #(
733:       .AsyncOn(0)
734:     ) u_prim_mubi8_sender_read_lock (
735:       .clk_i,
736:       .rst_ni,
737:       .mubi_i(mubi8_and_lo(access_pre.read_lock, digest_locked)),
738:       .mubi_o(access_o.read_lock)
739:     );
740: 
741:     `ASSERT(DigestReadLocksPartition_A, digest_o |-> mubi8_test_true_loose(access_o.read_lock))
742:   end else begin : gen_no_digest_read_lock
743:     assign access_o.read_lock = access_pre.read_lock;
744:   end
745: 
746:   ///////////////
747:   // Registers //
748:   ///////////////
749: 
750:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, state_e, ResetSt)
751: 
752:   always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs
753:     if (!rst_ni) begin
754:       error_q       <= NoError;
755:       // data output is locked by default
756:       dout_locked_q <= MuBi8True;
757:     end else begin
758:       error_q       <= error_d;
759:       dout_locked_q <= dout_locked_d;
760:     end
761:   end
762: 
763:   ////////////////
764:   // Assertions //
765:   ////////////////
766: 
767:   // Known assertions
768:   `ASSERT_KNOWN(InitDoneKnown_A,     init_done_o)
769:   `ASSERT_KNOWN(IntegChkAckKnown_A,  integ_chk_ack_o)
770:   `ASSERT_KNOWN(CnstyChkAckKnown_A,  cnsty_chk_ack_o)
771:   `ASSERT_KNOWN(ErrorKnown_A,        error_o)
772:   `ASSERT_KNOWN(AccessKnown_A,       access_o)
773:   `ASSERT_KNOWN(DigestKnown_A,       digest_o)
774:   `ASSERT_KNOWN(DataKnown_A,         data_o)
775:   `ASSERT_KNOWN(OtpReqKnown_A,       otp_req_o)
776:   `ASSERT_KNOWN(OtpCmdKnown_A,       otp_cmd_o)
777:   `ASSERT_KNOWN(OtpSizeKnown_A,      otp_size_o)
778:   `ASSERT_KNOWN(OtpWdataKnown_A,     otp_wdata_o)
779:   `ASSERT_KNOWN(OtpAddrKnown_A,      otp_addr_o)
780:   `ASSERT_KNOWN(ScrmblMtxReqKnown_A, scrmbl_mtx_req_o)
781:   `ASSERT_KNOWN(ScrmblCmdKnown_A,    scrmbl_cmd_o)
782:   `ASSERT_KNOWN(ScrmblModeKnown_A,   scrmbl_mode_o)
783:   `ASSERT_KNOWN(ScrmblSelKnown_A,    scrmbl_sel_o)
784:   `ASSERT_KNOWN(ScrmblDataKnown_A,   scrmbl_data_o)
785:   `ASSERT_KNOWN(ScrmblValidKnown_A,  scrmbl_valid_o)
786: 
787:   // Uninitialized partitions should always be locked, no matter what.
788:   `ASSERT(InitWriteLocksPartition_A,
789:       mubi8_test_true_loose(dout_locked_q)
790:       |->
791:       mubi8_test_true_loose(access_o.write_lock))
792:   `ASSERT(InitReadLocksPartition_A,
793:       mubi8_test_true_loose(dout_locked_q)
794:       |->
795:       mubi8_test_true_loose(access_o.read_lock))
796:   // Incoming Lock propagation
797:   `ASSERT(WriteLockPropagation_A,
798:       mubi8_test_true_loose(access_i.write_lock)
799:       |->
800:       mubi8_test_true_loose(access_o.write_lock))
801:   `ASSERT(ReadLockPropagation_A,
802:       mubi8_test_true_loose(access_i.read_lock)
803:       |->
804:       mubi8_test_true_loose(access_o.read_lock))
805:   // ECC error in buffer regs
806:   `ASSERT(EccErrorState_A,
807:       ecc_err
808:       |=>
809:       state_q == ErrorSt)
810:   // OTP error response
811:   `ASSERT(OtpErrorState_A,
812:       state_q inside {InitWaitSt, CnstyReadWaitSt} && otp_rvalid_i &&
813:       !(otp_err inside {NoError, MacroEccCorrError}) && !ecc_err
814:       |=>
815:       state_q == ErrorSt && error_o == $past(otp_err))
816: 
817:   // The partition size must be greater than one scrambling block for the address calculation
818:   // and muxing to work correctly.
819:   `ASSERT_INIT(OtpPartBufSize_A, Info.size > (ScrmblBlockWidth/8))
820: 
821: endmodule : otp_ctrl_part_buf

================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Buffered partition for OTP controller.
6: //
7: 
8: `include "prim_flop_macros.sv"
9: 
10: module otp_ctrl_part_buf
11:   import otp_ctrl_pkg::*;
12:   import otp_ctrl_reg_pkg::*;
13:   import otp_ctrl_part_pkg::*;
14: #(
15:   // Partition information.
16:   parameter part_info_t             Info = PartInfoDefault,
17:   parameter logic [Info.size*8-1:0] DataDefault = '0
18: ) (
19:   input                               clk_i,
20:   input                               rst_ni,
21:   // Pulse to start partition initialisation (required once per power cycle).
22:   input                               init_req_i,
23:   output logic                        init_done_o,
24:   // Integrity check requests
25:   input                               integ_chk_req_i,
26:   output logic                        integ_chk_ack_o,
27:   // Consistency check requests
28:   input                               cnsty_chk_req_i,
29:   output logic                        cnsty_chk_ack_o,
30:   // Escalation input. This moves the FSM into a terminal state and locks down
31:   // the partition.
32:   input  lc_ctrl_pkg::lc_tx_t         escalate_en_i,
33:   // Check bypass enable. This bypasses integrity and consistency checks and
34:   // acknowledges all incoming check requests (only used by life cycle).
35:   input  lc_ctrl_pkg::lc_tx_t         check_byp_en_i,
36:   // Output error state of partition, to be consumed by OTP error/alert logic.
37:   // Note that most errors are not recoverable and move the partition FSM into
38:   // a terminal error state.
39:   output otp_err_e                    error_o,
40:   // This error signal is pulsed high if the FSM has been glitched into an invalid state.
41:   // Although it is somewhat redundant with the error code in error_o above, it is
42:   // meant to cover cases where we already latched an error code while the FSM is
43:   // glitched into an invalid state (since in that case, the error code will not be
44:   // overridden with the FSM error code so that the original error code is still
45:   // discoverable).
46:   output logic                        fsm_err_o,
47:   // Access/lock status
48:   // SEC_CM: ACCESS.CTRL.MUBI
49:   input  part_access_t                access_i, // runtime lock from CSRs
50:   output part_access_t                access_o,
51:   // Buffered 64bit digest output.
52:   output logic [ScrmblBlockWidth-1:0] digest_o,
53:   output logic [Info.size*8-1:0]      data_o,
54:   // OTP interface
55:   output logic                        otp_req_o,
56:   output prim_otp_pkg::cmd_e          otp_cmd_o,
57:   output logic [OtpSizeWidth-1:0]     otp_size_o,
58:   output logic [OtpIfWidth-1:0]       otp_wdata_o,
59:   output logic [OtpAddrWidth-1:0]     otp_addr_o,
60:   input                               otp_gnt_i,
61:   input                               otp_rvalid_i,
62:   input  [ScrmblBlockWidth-1:0]       otp_rdata_i,
63:   input  prim_otp_pkg::err_e          otp_err_i,
64:   // Scrambling mutex request
65:   output logic                        scrmbl_mtx_req_o,
66:   input                               scrmbl_mtx_gnt_i,
67:   // Scrambling datapath interface
68:   output otp_scrmbl_cmd_e             scrmbl_cmd_o,
69:   output digest_mode_e                scrmbl_mode_o,
70:   output logic [ConstSelWidth-1:0]    scrmbl_sel_o,
71:   output logic [ScrmblBlockWidth-1:0] scrmbl_data_o,
72:   output logic                        scrmbl_valid_o,
73:   input  logic                        scrmbl_ready_i,
74:   input  logic                        scrmbl_valid_i,
75:   input  logic [ScrmblBlockWidth-1:0] scrmbl_data_i
76: );
77: 
78:   ////////////////////////
79:   // Integration Checks //
80:   ////////////////////////
81: 
82:   import prim_mubi_pkg::*;
83:   import prim_util_pkg::vbits;
84: 
85:   localparam int unsigned DigestOffsetInt = (int'(Info.offset) +
86:                                              int'(Info.size) - ScrmblBlockWidth/8);
87:   localparam int NumScrmblBlocks = int'(Info.size) / (ScrmblBlockWidth/8);
88:   localparam int CntWidth = vbits(NumScrmblBlocks);
89: 
90:   localparam bit [OtpByteAddrWidth-1:0] DigestOffset = DigestOffsetInt[OtpByteAddrWidth-1:0];
91: 
92:   localparam int unsigned LastScrmblBlockInt = NumScrmblBlocks - 1;
93:   localparam int unsigned PenultimateScrmblBlockInt = NumScrmblBlocks - 2;
94:   localparam bit [CntWidth-1:0] LastScrmblBlock = LastScrmblBlockInt[CntWidth-1:0];
95:   localparam bit [CntWidth-1:0] PenultimateScrmblBlock = PenultimateScrmblBlockInt[CntWidth-1:0];
96: 
97:   // Integration checks for parameters.
98:   `ASSERT_INIT(OffsetMustBeBlockAligned_A, (Info.offset % (ScrmblBlockWidth/8)) == 0)
99:   `ASSERT_INIT(SizeMustBeBlockAligned_A, (Info.size % (ScrmblBlockWidth/8)) == 0)
100:   `ASSERT_INIT(DigestOffsetMustBeRepresentable_A, DigestOffsetInt == int'(DigestOffset))
101:   `ASSERT(ScrambledImpliesDigest_A, Info.secret |-> Info.hw_digest)
102:   `ASSERT(WriteLockImpliesDigest_A, Info.read_lock |-> Info.hw_digest)
103:   `ASSERT(ReadLockImpliesDigest_A, Info.write_lock |-> Info.hw_digest)
104: 
105:   // This feature is only supposed to be used with partitions that are not scrambled
106:   // and that do not have a digest.
107:   `ASSERT(BypassEnable0_A, Info.secret    |-> lc_ctrl_pkg::lc_tx_test_false_strict(check_byp_en_i))
108:   `ASSERT(BypassEnable1_A, Info.hw_digest |-> lc_ctrl_pkg::lc_tx_test_false_strict(check_byp_en_i))
109: 
110:   ///////////////////////
111:   // OTP Partition FSM //
112:   ///////////////////////
113: 
114:   // SEC_CM: PART.FSM.SPARSE
115:   // Encoding generated with:
116:   // $ ./util/design/sparse-fsm-encode.py -d 5 -m 16 -n 12 \
117:   //      -s 3370657881 --language=sv
118:   //
119:   // Hamming distance histogram:
120:   //
121:   //  0: --
122:   //  1: --
123:   //  2: --
124:   //  3: --
125:   //  4: --
126:   //  5: |||||||||||||| (28.33%)
127:   //  6: |||||||||||||||||||| (38.33%)
128:   //  7: |||||||||| (19.17%)
129:   //  8: ||| (5.83%)
130:   //  9: || (4.17%)
131:   // 10: | (2.50%)
132:   // 11:  (0.83%)
133:   // 12:  (0.83%)
134:   //
135:   // Minimum Hamming distance: 5
136:   // Maximum Hamming distance: 12
137:   // Minimum Hamming weight: 4
138:   // Maximum Hamming weight: 8
139:   //
140:   localparam int StateWidth = 12;
141:   typedef enum logic [StateWidth-1:0] {
142:     ResetSt         = 12'b011000001110,
143:     InitSt          = 12'b110100100111,
144:     InitWaitSt      = 12'b001110110001,
145:     InitDescrSt     = 12'b110010000100,
146:     InitDescrWaitSt = 12'b100110101000,
147:     IdleSt          = 12'b010101001101,
148:     IntegScrSt      = 12'b110101011010,
149:     IntegScrWaitSt  = 12'b100010011111,
150:     IntegDigClrSt   = 12'b101001000001,
151:     IntegDigSt      = 12'b011101100010,
152:     IntegDigPadSt   = 12'b001101010111,
153:     IntegDigFinSt   = 12'b011011100101,
154:     IntegDigWaitSt  = 12'b100011110010,
155:     CnstyReadSt     = 12'b000001101011,
156:     CnstyReadWaitSt = 12'b101001111100,
157:     ErrorSt         = 12'b010110111110
158:   } state_e;
159: 
160:   typedef enum logic {
161:     ScrmblData,
162:     OtpData
163:   } data_sel_e;
164: 
165:   typedef enum logic {
166:     PartOffset,
167:     DigOffset
168:   } base_sel_e;
169: 
170:   state_e state_d, state_q;
171:   otp_err_e error_d, error_q;
172:   data_sel_e data_sel;
173:   base_sel_e base_sel;
174:   mubi8_t dout_locked_d, dout_locked_q;
175:   logic [CntWidth-1:0] cnt;
176:   logic cnt_en, cnt_clr, cnt_err;
177:   logic ecc_err;
178:   logic buffer_reg_en;
179:   logic [ScrmblBlockWidth-1:0] data_mux;
180: 
181:   // Output partition error state.
182:   assign error_o = error_q;
183: 
184:   // This partition cannot do any write accesses, hence we tie this
185:   // constantly off.
186:   assign otp_wdata_o = '0;
187:   // Depending on the partition configuration, the wrapper is instructed to ignore integrity
188:   // calculations and checks. To be on the safe side, the partition filters error responses at this
189:   // point and does not report any integrity errors if integrity is disabled.
190:   otp_err_e otp_err;
191:   if (Info.integrity) begin : gen_integrity
192:     assign otp_cmd_o = prim_otp_pkg::Read;
193:     assign otp_err = otp_err_e'(otp_err_i);
194:   end else begin : gen_no_integrity
195:     assign otp_cmd_o = prim_otp_pkg::ReadRaw;
196:     always_comb begin
197:       if (otp_err_e'(otp_err_i) inside {MacroEccCorrError, MacroEccUncorrError}) begin
198:         otp_err = NoError;
199:       end else begin
200:         otp_err = otp_err_e'(otp_err_i);
201:       end
202:     end
203:   end
204: 
205:   always_comb begin : p_fsm
206:     state_d = state_q;
207: 
208:     // Redundantly encoded lock signal for buffer regs.
209:     dout_locked_d = dout_locked_q;
210: 
211:     // OTP signals
212:     otp_req_o = 1'b0;
213: 
214:     // Scrambling mutex
215:     scrmbl_mtx_req_o = 1'b0;
216: 
217:     // Scrambling datapath
218:     scrmbl_cmd_o   = LoadShadow;
219:     scrmbl_sel_o   = CnstyDigest;
220:     scrmbl_mode_o  = StandardMode;
221:     scrmbl_valid_o = 1'b0;
222: 
223:     // Counter
224:     cnt_en   = 1'b0;
225:     cnt_clr  = 1'b0;
226:     base_sel = PartOffset;
227: 
228:     // Buffer register
229:     buffer_reg_en = 1'b0;
230:     data_sel = OtpData;
231: 
232:     // Error Register
233:     error_d = error_q;
234:     fsm_err_o = 1'b0;
235: 
236:     // Integrity/Consistency check responses
237:     cnsty_chk_ack_o = 1'b0;
238:     integ_chk_ack_o = 1'b0;
239: 
240:     unique case (state_q)
241:       ///////////////////////////////////////////////////////////////////
242:       // State right after reset. Wait here until we get a an
243:       // initialization request.
244:       ResetSt: begin
245:         if (init_req_i) begin
246:           state_d = InitSt;
247:         end
248:       end
249:       ///////////////////////////////////////////////////////////////////
250:       // Initialization reads out the digest only in unbuffered
251:       // partitions. Wait here until the OTP request has been granted.
252:       // And then wait until the OTP word comes back.
253:       InitSt: begin
254:         otp_req_o = 1'b1;
255:         if (otp_gnt_i) begin
256:           state_d = InitWaitSt;
257:         end
258:       end
259:       ///////////////////////////////////////////////////////////////////
260:       // Wait for OTP response and write to buffer register, then go to
261:       // descrambling state. In case an OTP transaction fails, latch the
262:       // OTP error code and jump to a
263:       // terminal error state.
264:       InitWaitSt: begin
265:         if (otp_rvalid_i) begin
266:           buffer_reg_en = 1'b1;
267:           if (otp_err inside {NoError, MacroEccCorrError}) begin
268:             // Once we've read and descrambled the whole partition, we can go to integrity
269:             // verification. Note that the last block is the digest value, which does not
270:             // have to be descrambled.
271:             if (cnt == LastScrmblBlock) begin
272:               state_d = IntegDigClrSt;
273:             // Only need to descramble if this is a scrambled partition.
274:             // Otherwise, we can just go back to InitSt and read the next block.
275:             end else if (Info.secret) begin
276:               state_d = InitDescrSt;
277:             end else begin
278:               state_d = InitSt;
279:               cnt_en = 1'b1;
280:             end
281:             // At this point the only error that we could have gotten are correctable ECC errors.
282:             if (otp_err != NoError) begin
283:               error_d = MacroEccCorrError;
284:             end
285:           end else begin
286:             state_d = ErrorSt;
287:             error_d = otp_err;
288:           end
289:         end
290:       end
291:       ///////////////////////////////////////////////////////////////////
292:       // Descrambling state. This first acquires the scrambling
293:       // datapath mutex. Note that once the mutex is acquired, we have
294:       // exclusive access to the scrambling datapath until we release
295:       // the mutex by deasserting scrmbl_mtx_req_o.
296:       // SEC_CM: SECRET.MEM.SCRAMBLE
297:       InitDescrSt: begin
298:         scrmbl_mtx_req_o = 1'b1;
299:         scrmbl_valid_o = 1'b1;
300:         scrmbl_cmd_o = Decrypt;
301:         scrmbl_sel_o = Info.key_sel;
302:         if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
303:           state_d = InitDescrWaitSt;
304:         end
305:       end
306:       ///////////////////////////////////////////////////////////////////
307:       // Wait for the descrambled data to return. Note that we release
308:       // the mutex lock upon leaving this state.
309:       // SEC_CM: SECRET.MEM.SCRAMBLE
310:       InitDescrWaitSt: begin
311:         scrmbl_mtx_req_o = 1'b1;
312:         scrmbl_sel_o = Info.key_sel;
313:         data_sel = ScrmblData;
314:         if (scrmbl_valid_i) begin
315:           state_d = InitSt;
316:           buffer_reg_en = 1'b1;
317:           cnt_en = 1'b1;
318:         end
319:       end
320:       ///////////////////////////////////////////////////////////////////
321:       // Idle state. We basically wait for integrity and consistency check
322:       // triggers in this state.
323:       IdleSt: begin
324:         if (integ_chk_req_i) begin
325:           if (Info.hw_digest) begin
326:             state_d = IntegDigClrSt;
327:           // In case there is nothing to check we can just
328:           // acknowledge the request right away, without going to the
329:           // integrity check.
330:           end else begin
331:             integ_chk_ack_o = 1'b1;
332:           end
333:         end else if (cnsty_chk_req_i) begin
334:           state_d = CnstyReadSt;
335:           cnt_clr = 1'b1;
336:         end
337:       end
338:       ///////////////////////////////////////////////////////////////////
339:       // Read the digest. Wait here until the OTP request has been granted.
340:       // And then wait until the OTP word comes back.
341:       // SEC_CM: PART.DATA_REG.BKGN_CHK
342:       CnstyReadSt: begin
343:         otp_req_o = 1'b1;
344:         // In case this partition has a hardware digest, we only have to read
345:         // and compare the digest value. In that case we select the digest offset here.
346:         // Otherwise we have to read and compare the whole partition, in which case we
347:         // select the partition offset, which is the default assignment of base_sel.
348:         if (Info.hw_digest) begin
349:           base_sel = DigOffset;
350:         end
351:         if (otp_gnt_i) begin
352:           state_d = CnstyReadWaitSt;
353:         end
354:       end
355:       ///////////////////////////////////////////////////////////////////
356:       // Wait for OTP response and compare the digest. In case there is
357:       // a mismatch, lock down the partition and go into the terminal error
358:       // state. In case an OTP transaction fails, latch the OTP error code
359:       // and jump to a terminal error state.
360:       // SEC_CM: PART.DATA_REG.BKGN_CHK
361:       CnstyReadWaitSt: begin
362:         if (otp_rvalid_i) begin
363:           if (otp_err inside {NoError, MacroEccCorrError}) begin
364:             // Check whether we need to compare the digest or the full partition
365:             // contents here.
366:             if (Info.hw_digest) begin
367:               // Note that we ignore this check if the digest is still blank.
368:               if (digest_o == data_mux || digest_o == '0) begin
369:                 state_d = IdleSt;
370:                 cnsty_chk_ack_o = 1'b1;
371:               // Error out and lock the partition if this check fails.
372:               end else begin
373:                 state_d = ErrorSt;
374:                 error_d = CheckFailError;
375:                 // The check has finished and found an error.
376:                 cnsty_chk_ack_o = 1'b1;
377:               end
378:             end else begin
379:               // Check whether the read data corresponds with the data buffered in regs.
380:               // Note that this particular check can be bypassed in case a transition is ongoing.
381:               if (scrmbl_data_o == data_mux ||
382:                   lc_ctrl_pkg::lc_tx_test_true_strict(check_byp_en_i)) begin
383:                 // Can go back to idle and acknowledge the
384:                 // request if this is the last block.
385:                 if (cnt == LastScrmblBlock) begin
386:                   state_d = IdleSt;
387:                   cnsty_chk_ack_o = 1'b1;
388:                 // Need to go back and read out more blocks.
389:                 end else begin
390:                   state_d = CnstyReadSt;
391:                   cnt_en = 1'b1;
392:                 end
393:               end else begin
394:                 state_d = ErrorSt;
395:                 error_d = CheckFailError;
396:                 // The check has finished and found an error.
397:                 cnsty_chk_ack_o = 1'b1;
398:               end
399:             end
400:             // At this point the only error that we could have gotten are correctable ECC errors.
401:             if (otp_err != NoError) begin
402:               error_d = MacroEccCorrError;
403:             end
404:           end else begin
405:             state_d = ErrorSt;
406:             error_d = otp_err;
407:             // The check has finished and found an error.
408:             cnsty_chk_ack_o = 1'b1;
409:           end
410:         end
411:       end
412:       ///////////////////////////////////////////////////////////////////
413:       // First, acquire the mutex for the digest and clear the digest state.
414:       // SEC_CM: PART.DATA_REG.BKGN_CHK
415:       IntegDigClrSt: begin
416:         // Check whether this partition requires checking at all.
417:         if (Info.hw_digest) begin
418:           scrmbl_mtx_req_o = 1'b1;
419:           scrmbl_valid_o = 1'b1;
420:           cnt_clr = 1'b1;
421:           // Need to reset the digest state and set it to chained
422:           // mode if this partition is scrambled.
423:           scrmbl_cmd_o = DigestInit;
424:           if (Info.secret) begin
425:             scrmbl_mode_o = ChainedMode;
426:             if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
427:               state_d = IntegScrSt;
428:             end
429:           // If this partition is not scrambled, we can just directly
430:           // jump to the digest state.
431:           end else begin
432:             scrmbl_mode_o = StandardMode;
433:             if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
434:               state_d = IntegDigSt;
435:             end
436:           end
437:         // Otherwise, if this partition is not digest protected,
438:         // we can just go to idle, since there is nothing to check.
439:         // Note that we do not come back to this state in case there is no
440:         // digest, and hence it is safe to unlock the buffer regs at this point.
441:         // This is the only way the buffer regs can get unlocked.
442:         end else begin
443:           state_d = IdleSt;
444:           if (mubi8_test_true_strict(dout_locked_q)) begin
445:             dout_locked_d = MuBi8False;
446:           end
447:         end
448:       end
449:       ///////////////////////////////////////////////////////////////////
450:       // Scramble buffered data (which is held in plaintext form).
451:       // This moves the previous scrambling result into the shadow reg
452:       // for later use.
453:       // SEC_CM: PART.DATA_REG.BKGN_CHK
454:       IntegScrSt: begin
455:           scrmbl_mtx_req_o = 1'b1;
456:           scrmbl_valid_o = 1'b1;
457:           scrmbl_cmd_o = Encrypt;
458:           scrmbl_sel_o = Info.key_sel;
459:           if (scrmbl_ready_i) begin
460:             state_d = IntegScrWaitSt;
461:           end
462:       end
463:       ///////////////////////////////////////////////////////////////////
464:       // Wait for the scrambled data to return.
465:       // SEC_CM: PART.DATA_REG.BKGN_CHK
466:       IntegScrWaitSt: begin
467:         scrmbl_mtx_req_o = 1'b1;
468:         scrmbl_sel_o = Info.key_sel;
469:         if (scrmbl_valid_i) begin
470:           state_d = IntegDigSt;
471:         end
472:       end
473:       ///////////////////////////////////////////////////////////////////
474:       // Push the word read into the scrambling datapath. The last
475:       // block is repeated in case the number blocks in this partition
476:       // is odd.
477:       // SEC_CM: PART.MEM.DIGEST
478:       // SEC_CM: PART.DATA_REG.BKGN_CHK
479:       IntegDigSt: begin
480:         scrmbl_mtx_req_o = 1'b1;
481:         scrmbl_valid_o = 1'b1;
482:         if (scrmbl_ready_i) begin
483:           cnt_en = 1'b1;
484:           // No need to digest the digest value itself
485:           if (cnt == PenultimateScrmblBlock) begin
486:             // Note that the digest operates on 128bit blocks since the data is fed in via the
487:             // PRESENT key input. Therefore, we only trigger a digest update on every second
488:             // 64bit block that is pushed into the scrambling datapath.
489:             if (cnt[0]) begin
490:               scrmbl_cmd_o = Digest;
491:               state_d = IntegDigFinSt;
492:             end else begin
493:               state_d = IntegDigPadSt;
494:               cnt_en = 1'b0;
495:             end
496:           end else begin
497:             // Trigger digest round in case this is the second block in a row.
498:             if (cnt[0]) begin
499:               scrmbl_cmd_o = Digest;
500:             end
501:             // Go back and scramble the next data block if this is
502:             // a scrambled partition. Otherwise just stay here.
503:             if (Info.secret) begin
504:               state_d = IntegScrSt;
505:             end
506:           end
507:         end
508:       end
509:       ///////////////////////////////////////////////////////////////////
510:       // Padding state. When we get here, we've copied the last encryption
511:       // result into the shadow register such that we've effectively
512:       // repeated the last block twice in order to pad the data to 128bit.
513:       // SEC_CM: PART.MEM.DIGEST
514:       // SEC_CM: PART.DATA_REG.BKGN_CHK
515:       IntegDigPadSt: begin
516:         scrmbl_mtx_req_o = 1'b1;
517:         scrmbl_valid_o = 1'b1;
518:         scrmbl_cmd_o = Digest;
519:         if (scrmbl_ready_i) begin
520:           state_d = IntegDigFinSt;
521:         end
522:       end
523:       ///////////////////////////////////////////////////////////////////
524:       // Trigger digest finalization and go wait for the result.
525:       // SEC_CM: PART.MEM.DIGEST
526:       // SEC_CM: PART.DATA_REG.BKGN_CHK
527:       IntegDigFinSt: begin
528:         scrmbl_mtx_req_o = 1'b1;
529:         scrmbl_valid_o = 1'b1;
530:         scrmbl_cmd_o = DigestFinalize;
531:         if (scrmbl_ready_i) begin
532:           state_d = IntegDigWaitSt;
533:         end
534:       end
535:       ///////////////////////////////////////////////////////////////////
536:       // Wait for the digest to return, and double check whether the digest
537:       // matches. If yes, unlock the partition. Otherwise, go into the terminal
538:       // error state, where the partition will be locked down.
539:       // SEC_CM: PART.MEM.DIGEST
540:       // SEC_CM: PART.DATA_REG.BKGN_CHK
541:       IntegDigWaitSt: begin
542:         scrmbl_mtx_req_o = 1'b1;
543:         data_sel = ScrmblData;
544:         if (scrmbl_valid_i) begin
545:           // This is the only way the buffer regs can get unlocked.
546:           // Note that we ignore this check if the digest is still blank.
547:           if (digest_o == data_mux || digest_o == '0) begin
548:             state_d = IdleSt;
549:             // If the partition is still locked, this is the first integrity check after
550:             // initialization. This is the only way the buffer regs can get unlocked.
551:             if (mubi8_test_true_strict(dout_locked_q)) begin
552:               dout_locked_d = MuBi8False;
553:             // Otherwise, this integrity check has requested by the LFSR timer, and we have
554:             // to acknowledge its completion.
555:             end else begin
556:               integ_chk_ack_o = 1'b1;
557:             end
558:           // Error out and lock the partition if this check fails.
559:           end else begin
560:             state_d = ErrorSt;
561:             error_d = CheckFailError;
562:             // The check has finished and found an error.
563:             integ_chk_ack_o = 1'b1;
564:           end
565:         end
566:       end
567:       ///////////////////////////////////////////////////////////////////
568:       // Terminal Error State. This locks access to the partition.
569:       // Make sure the partition signals an error state if no error
570:       // code has been latched so far, and lock the buffer regs down.
571:       ErrorSt: begin
572:         dout_locked_d = MuBi8True;
573:         if (error_q == NoError) begin
574:           error_d = FsmStateError;
575:         end
576:         // If we are in error state, we cannot execute the checks anymore.
577:         // Hence the acknowledgements are returned immediately.
578:         cnsty_chk_ack_o = 1'b1;
579:         integ_chk_ack_o = 1'b1;
580:       end
581:       ///////////////////////////////////////////////////////////////////
582:       // We should never get here. If we do (e.g. via a malicious
583:       // glitch), error out immediately.
584:       default: begin
585:         state_d = ErrorSt;
586:         fsm_err_o = 1'b1;
587:       end
588:       ///////////////////////////////////////////////////////////////////
589:     endcase // state_q
590: 
591: 
592:     // Unconditionally jump into the terminal error state in case of
593:     // an ECC error or escalation, and lock access to the partition down.
594:     // SEC_CM: PART.FSM.LOCAL_ESC
595:     if (ecc_err) begin
596:       state_d = ErrorSt;
597:       if (state_q != ErrorSt) begin
598:         error_d = CheckFailError;
599:       end
600:     end
601:     // SEC_CM: PART.FSM.LOCAL_ESC, PART.FSM.GLOBAL_ESC
602:     if (lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) || cnt_err) begin
603:       state_d = ErrorSt;
604:       fsm_err_o = 1'b1;
605:       if (state_q != ErrorSt) begin
606:         error_d = FsmStateError;
607:       end
608:     end
609:   end
610: 
611:   ////////////////////////////
612:   // Address Calc and Muxes //
613:   ////////////////////////////
614: 
615:   // Address counter - this is only used for computing a digest, hence the increment is
616:   // fixed to 8 byte.
617:   // SEC_CM: PART.CTR.REDUN
618:   prim_count #(
619:     .Width(CntWidth)
620:   ) u_prim_count (
621:     .clk_i,
622:     .rst_ni,
623:     .clr_i(cnt_clr),
624:     .set_i(1'b0),
625:     .set_cnt_i('0),
626:     .incr_en_i(cnt_en),
627:     .decr_en_i(1'b0),
628:     .step_i(CntWidth'(1)),
629:     .commit_i(1'b1),
630:     .cnt_o(cnt),
631:     .cnt_after_commit_o(),
632:     .err_o(cnt_err)
633:   );
634: 
635:   logic [OtpByteAddrWidth-1:0] addr_base;
636:   assign addr_base = (base_sel == DigOffset) ? DigestOffset : Info.offset;
637: 
638:   // Note that OTP works on halfword (16bit) addresses, hence need to
639:   // shift the addresses appropriately.
640:   logic [OtpByteAddrWidth-1:0] addr_calc;
641:   assign addr_calc = OtpByteAddrWidth'({cnt, {$clog2(ScrmblBlockWidth/8){1'b0}}}) + addr_base;
642:   assign otp_addr_o = addr_calc[OtpByteAddrWidth-1:OtpAddrShift];
643: 
644:   if (OtpAddrShift > 0) begin : gen_unused
645:     logic unused_bits;
646:     assign unused_bits = ^addr_calc[OtpAddrShift-1:0];
647:   end
648: 
649:   // Always transfer 64bit blocks.
650:   assign otp_size_o = OtpSizeWidth'(unsigned'(ScrmblBlockWidth / OtpWidth) - 1);
651: 
652:   assign data_mux = (data_sel == ScrmblData) ? scrmbl_data_i : otp_rdata_i;
653: 
654:   /////////////////
655:   // Buffer Regs //
656:   /////////////////
657: 
658:   // SEC_CM: PART.DATA_REG.INTEGRITY
659:   logic [Info.size*8-1:0] data;
660:   otp_ctrl_ecc_reg #(
661:     .Width ( ScrmblBlockWidth ),
662:     .Depth ( NumScrmblBlocks  )
663:   ) u_otp_ctrl_ecc_reg (
664:     .clk_i,
665:     .rst_ni,
666:     .wren_i    ( buffer_reg_en ),
667:     .addr_i    ( cnt           ),
668:     .wdata_i   ( data_mux      ),
669:     .rdata_o   ( scrmbl_data_o ),
670:     .data_o    ( data          ),
671:     .ecc_err_o ( ecc_err       )
672:   );
673: 
674:   // We have successfully initialized the partition once it has been unlocked.
675:   assign init_done_o = mubi8_test_false_strict(dout_locked_q);
676:   // Hardware output gating.
677:   // Note that this is decoupled from the DAI access rules further below.
678:   assign data_o = data;
679:   // The digest does not have to be gated.
680:   assign digest_o = data[$high(data_o) -: ScrmblBlockWidth];
681: 
682:   ////////////////////////
683:   // DAI Access Control //
684:   ////////////////////////
685: 
686:   // Aggregate all possible DAI write /readlocks. The partition is also locked when uninitialized.
687:   // Note that the locks are redundantly encoded values.
688:   part_access_t access_pre;
689:   prim_mubi8_sender #(
690:     .AsyncOn(0)
691:   ) u_prim_mubi8_sender_write_lock_pre (
692:     .clk_i,
693:     .rst_ni,
694:     .mubi_i(mubi8_and_lo(dout_locked_q, access_i.write_lock)),
695:     .mubi_o(access_pre.write_lock)
696:   );
697:   prim_mubi8_sender #(
698:     .AsyncOn(0)
699:   ) u_prim_mubi8_sender_read_lock_pre (
700:     .clk_i,
701:     .rst_ni,
702:     .mubi_i(mubi8_and_lo(dout_locked_q, access_i.read_lock)),
703:     .mubi_o(access_pre.read_lock)
704:   );
705: 
706:   // SEC_CM: PART.MEM.SW_UNWRITABLE
707:   if (Info.write_lock) begin : gen_digest_write_lock
708:     mubi8_t digest_locked;
709:     assign digest_locked = (digest_o != '0) ? MuBi8True : MuBi8False;
710: 
711:     // This prevents the synthesis tool from optimizing the multibit signal.
712:     prim_mubi8_sender #(
713:       .AsyncOn(0)
714:     ) u_prim_mubi8_sender_write_lock (
715:       .clk_i,
716:       .rst_ni,
717:       .mubi_i(mubi8_and_lo(access_pre.write_lock, digest_locked)),
718:       .mubi_o(access_o.write_lock)
719:     );
720: 
721:     `ASSERT(DigestWriteLocksPartition_A, digest_o |-> mubi8_test_true_loose(access_o.write_lock))
722:   end else begin : gen_no_digest_write_lock
723:     assign access_o.write_lock = access_pre.write_lock;
724:   end
725: 
726:   // SEC_CM: PART.MEM.SW_UNREADABLE
727:   if (Info.read_lock) begin : gen_digest_read_lock
728:     mubi8_t digest_locked;
729:     assign digest_locked = (digest_o != '0) ? MuBi8True : MuBi8False;
730: 
731:     // This prevents the synthesis tool from optimizing the multibit signal.
732:     prim_mubi8_sender #(
733:       .AsyncOn(0)
734:     ) u_prim_mubi8_sender_read_lock (
735:       .clk_i,
736:       .rst_ni,
737:       .mubi_i(mubi8_and_lo(access_pre.read_lock, digest_locked)),
738:       .mubi_o(access_o.read_lock)
739:     );
740: 
741:     `ASSERT(DigestReadLocksPartition_A, digest_o |-> mubi8_test_true_loose(access_o.read_lock))
742:   end else begin : gen_no_digest_read_lock
743:     assign access_o.read_lock = access_pre.read_lock;
744:   end
745: 
746:   ///////////////
747:   // Registers //
748:   ///////////////
749: 
750:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, state_e, ResetSt)
751: 
752:   always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs
753:     if (!rst_ni) begin
754:       error_q       <= NoError;
755:       // data output is locked by default
756:       dout_locked_q <= MuBi8True;
757:     end else begin
758:       error_q       <= error_d;
759:       dout_locked_q <= dout_locked_d;
760:     end
761:   end
762: 
763:   ////////////////
764:   // Assertions //
765:   ////////////////
766: 
767:   // Known assertions
768:   `ASSERT_KNOWN(InitDoneKnown_A,     init_done_o)
769:   `ASSERT_KNOWN(IntegChkAckKnown_A,  integ_chk_ack_o)
770:   `ASSERT_KNOWN(CnstyChkAckKnown_A,  cnsty_chk_ack_o)
771:   `ASSERT_KNOWN(ErrorKnown_A,        error_o)
772:   `ASSERT_KNOWN(AccessKnown_A,       access_o)
773:   `ASSERT_KNOWN(DigestKnown_A,       digest_o)
774:   `ASSERT_KNOWN(DataKnown_A,         data_o)
775:   `ASSERT_KNOWN(OtpReqKnown_A,       otp_req_o)
776:   `ASSERT_KNOWN(OtpCmdKnown_A,       otp_cmd_o)
777:   `ASSERT_KNOWN(OtpSizeKnown_A,      otp_size_o)
778:   `ASSERT_KNOWN(OtpWdataKnown_A,     otp_wdata_o)
779:   `ASSERT_KNOWN(OtpAddrKnown_A,      otp_addr_o)
780:   `ASSERT_KNOWN(ScrmblMtxReqKnown_A, scrmbl_mtx_req_o)
781:   `ASSERT_KNOWN(ScrmblCmdKnown_A,    scrmbl_cmd_o)
782:   `ASSERT_KNOWN(ScrmblModeKnown_A,   scrmbl_mode_o)
783:   `ASSERT_KNOWN(ScrmblSelKnown_A,    scrmbl_sel_o)
784:   `ASSERT_KNOWN(ScrmblDataKnown_A,   scrmbl_data_o)
785:   `ASSERT_KNOWN(ScrmblValidKnown_A,  scrmbl_valid_o)
786: 
787:   // Uninitialized partitions should always be locked, no matter what.
788:   `ASSERT(InitWriteLocksPartition_A,
789:       mubi8_test_true_loose(dout_locked_q)
790:       |->
791:       mubi8_test_true_loose(access_o.write_lock))
792:   `ASSERT(InitReadLocksPartition_A,
793:       mubi8_test_true_loose(dout_locked_q)
794:       |->
795:       mubi8_test_true_loose(access_o.read_lock))
796:   // Incoming Lock propagation
797:   `ASSERT(WriteLockPropagation_A,
798:       mubi8_test_true_loose(access_i.write_lock)
799:       |->
800:       mubi8_test_true_loose(access_o.write_lock))
801:   `ASSERT(ReadLockPropagation_A,
802:       mubi8_test_true_loose(access_i.read_lock)
803:       |->
804:       mubi8_test_true_loose(access_o.read_lock))
805:   // ECC error in buffer regs
806:   `ASSERT(EccErrorState_A,
807:       ecc_err
808:       |=>
809:       state_q == ErrorSt)
810:   // OTP error response
811:   `ASSERT(OtpErrorState_A,
812:       state_q inside {InitWaitSt, CnstyReadWaitSt} && otp_rvalid_i &&
813:       !(otp_err inside {NoError, MacroEccCorrError}) && !ecc_err
814:       |=>
815:       state_q == ErrorSt && error_o == $past(otp_err))
816: 
817:   // The partition size must be greater than one scrambling block for the address calculation
818:   // and muxing to work correctly.
819:   `ASSERT_INIT(OtpPartBufSize_A, Info.size > (ScrmblBlockWidth/8))
820: 
821: endmodule : otp_ctrl_part_buf

================================== Ai Message ==================================

[{'text': "Now, I'll use the similar_bug_tool to search for similar instances:", 'type': 'text'}, {'id': 'toolu_01Far15VbML58necvHTvdUcX', 'input': {'bug': 'dout_locked_d = MuBi8True;', 'ip_file': '/home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv'}, 'name': 'similar_bug_tool', 'type': 'tool_use'}]
Tool Calls:
  similar_bug_tool (toolu_01Far15VbML58necvHTvdUcX)
 Call ID: toolu_01Far15VbML58necvHTvdUcX
  Args:
    bug: dout_locked_d = MuBi8True;
    ip_file: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv
================================= Tool Message =================================
Name: similar_bug_tool

Error: ValueError("'dout_locked_q <= MuBi8True;\\n    end else begin' is not in list")
 Please fix your mistakes.
================================= Tool Message =================================
Name: similar_bug_tool

Error: ValueError("'dout_locked_q <= MuBi8True;\\n    end else begin' is not in list")
 Please fix your mistakes.
================================== Ai Message ==================================

I apologize for the error. Let me try a more direct approach by carefully examining the code. 

I found the line you mentioned in the ErrorSt state of the state machine, on line 572:

```systemverilog
dout_locked_d = MuBi8True;
```

This appears to be an intentional part of the error handling mechanism. When the partition enters the ErrorSt state, it sets `dout_locked_d` to `MuBi8True`, which locks down the partition's access.

The context suggests this is not a bug, but a deliberate security mechanism to prevent access to the partition when an error occurs. Specifically:
1. This happens in the ErrorSt state (lines 568-580)
2. It's part of locking down the partition when an error is detected
3. It's used to prevent further read or write access to the partition

There are no other direct instances of this exact line that would suggest a repeated or mistaken bug. The code seems to be intentionally using this line to implement a security feature.

If you believe this might still be a potential issue, I recommend a code review to confirm the intended behavior of locking the partition in the error state.
================================= Tool Message =================================
Name: run_similar_bug_agent

I apologize for the error. Let me try a more direct approach by carefully examining the code. 

I found the line you mentioned in the ErrorSt state of the state machine, on line 572:

```systemverilog
dout_locked_d = MuBi8True;
```

This appears to be an intentional part of the error handling mechanism. When the partition enters the ErrorSt state, it sets `dout_locked_d` to `MuBi8True`, which locks down the partition's access.

The context suggests this is not a bug, but a deliberate security mechanism to prevent access to the partition when an error occurs. Specifically:
1. This happens in the ErrorSt state (lines 568-580)
2. It's part of locking down the partition when an error is detected
3. It's used to prevent further read or write access to the partition

There are no other direct instances of this exact line that would suggest a repeated or mistaken bug. The code seems to be intentionally using this line to implement a security feature.

If you believe this might still be a potential issue, I recommend a code review to confirm the intended behavior of locking the partition in the error state.
================================== Ai Message ==================================
Tool Calls:
  run_anomaly_detector_agent (call_jFU6O43szimlK9mtexJuK58R)
 Call ID: call_jFU6O43szimlK9mtexJuK58R
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv
    top_module: otp_ctrl_part_buf
    security_objective: partition lock enforcement and error state handling
================================ Human Message =================================

Are there security concerns related to partition lock enforcement and error state handling in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Buffered partition for OTP controller.
//

`include "prim_flop_macros.sv"

module otp_ctrl_part_buf
  import otp_ctrl_pkg::*;
  import otp_ctrl_reg_pkg::*;
  import otp_ctrl_part_pkg::*;
#(
  // Partition information.
  parameter part_info_t             Info = PartInfoDefault,
  parameter logic [Info.size*8-1:0] DataDefault = '0
) (
  input                               clk_i,
  input                               rst_ni,
  // Pulse to start partition initialisation (required once per power cycle).
  input                               init_req_i,
  output logic                        init_done_o,
  // Integrity check requests
  input                               integ_chk_req_i,
  output logic                        integ_chk_ack_o,
  // Consistency check requests
  input                               cnsty_chk_req_i,
  output logic                        cnsty_chk_ack_o,
  // Escalation input. This moves the FSM into a terminal state and locks down
  // the partition.
  input  lc_ctrl_pkg::lc_tx_t         escalate_en_i,
  // Check bypass enable. This bypasses integrity and consistency checks and
  // acknowledges all incoming check requests (only used by life cycle).
  input  lc_ctrl_pkg::lc_tx_t         check_byp_en_i,
  // Output error state of partition, to be consumed by OTP error/alert logic.
  // Note that most errors are not recoverable and move the partition FSM into
  // a terminal error state.
  output otp_err_e                    error_o,
  // This error signal is pulsed high if the FSM has been glitched into an invalid state.
  // Although it is somewhat redundant with the error code in error_o above, it is
  // meant to cover cases where we already latched an error code while the FSM is
  // glitched into an invalid state (since in that case, the error code will not be
  // overridden with the FSM error code so that the original error code is still
  // discoverable).
  output logic                        fsm_err_o,
  // Access/lock status
  // SEC_CM: ACCESS.CTRL.MUBI
  input  part_access_t                access_i, // runtime lock from CSRs
  output part_access_t                access_o,
  // Buffered 64bit digest output.
  output logic [ScrmblBlockWidth-1:0] digest_o,
  output logic [Info.size*8-1:0]      data_o,
  // OTP interface
  output logic                        otp_req_o,
  output prim_otp_pkg::cmd_e          otp_cmd_o,
  output logic [OtpSizeWidth-1:0]     otp_size_o,
  output logic [OtpIfWidth-1:0]       otp_wdata_o,
  output logic [OtpAddrWidth-1:0]     otp_addr_o,
  input                               otp_gnt_i,
  input                               otp_rvalid_i,
  input  [ScrmblBlockWidth-1:0]       otp_rdata_i,
  input  prim_otp_pkg::err_e          otp_err_i,
  // Scrambling mutex request
  output logic                        scrmbl_mtx_req_o,
  input                               scrmbl_mtx_gnt_i,
  // Scrambling datapath interface
  output otp_scrmbl_cmd_e             scrmbl_cmd_o,
  output digest_mode_e                scrmbl_mode_o,
  output logic [ConstSelWidth-1:0]    scrmbl_sel_o,
  output logic [ScrmblBlockWidth-1:0] scrmbl_data_o,
  output logic                        scrmbl_valid_o,
  input  logic                        scrmbl_ready_i,
  input  logic                        scrmbl_valid_i,
  input  logic [ScrmblBlockWidth-1:0] scrmbl_data_i
);

  ////////////////////////
  // Integration Checks //
  ////////////////////////

  import prim_mubi_pkg::*;
  import prim_util_pkg::vbits;

  localparam int unsigned DigestOffsetInt = (int'(Info.offset) +
                                             int'(Info.size) - ScrmblBlockWidth/8);
  localparam int NumScrmblBlocks = int'(Info.size) / (ScrmblBlockWidth/8);
  localparam int CntWidth = vbits(NumScrmblBlocks);

  localparam bit [OtpByteAddrWidth-1:0] DigestOffset = DigestOffsetInt[OtpByteAddrWidth-1:0];

  localparam int unsigned LastScrmblBlockInt = NumScrmblBlocks - 1;
  localparam int unsigned PenultimateScrmblBlockInt = NumScrmblBlocks - 2;
  localparam bit [CntWidth-1:0] LastScrmblBlock = LastScrmblBlockInt[CntWidth-1:0];
  localparam bit [CntWidth-1:0] PenultimateScrmblBlock = PenultimateScrmblBlockInt[CntWidth-1:0];

  // Integration checks for parameters.
  `ASSERT_INIT(OffsetMustBeBlockAligned_A, (Info.offset % (ScrmblBlockWidth/8)) == 0)
  `ASSERT_INIT(SizeMustBeBlockAligned_A, (Info.size % (ScrmblBlockWidth/8)) == 0)
  `ASSERT_INIT(DigestOffsetMustBeRepresentable_A, DigestOffsetInt == int'(DigestOffset))
  `ASSERT(ScrambledImpliesDigest_A, Info.secret |-> Info.hw_digest)
  `ASSERT(WriteLockImpliesDigest_A, Info.read_lock |-> Info.hw_digest)
  `ASSERT(ReadLockImpliesDigest_A, Info.write_lock |-> Info.hw_digest)

  // This feature is only supposed to be used with partitions that are not scrambled
  // and that do not have a digest.
  `ASSERT(BypassEnable0_A, Info.secret    |-> lc_ctrl_pkg::lc_tx_test_false_strict(check_byp_en_i))
  `ASSERT(BypassEnable1_A, Info.hw_digest |-> lc_ctrl_pkg::lc_tx_test_false_strict(check_byp_en_i))

  ///////////////////////
  // OTP Partition FSM //
  ///////////////////////

  // SEC_CM: PART.FSM.SPARSE
  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 5 -m 16 -n 12 \
  //      -s 3370657881 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: --
  //  4: --
  //  5: |||||||||||||| (28.33%)
  //  6: |||||||||||||||||||| (38.33%)
  //  7: |||||||||| (19.17%)
  //  8: ||| (5.83%)
  //  9: || (4.17%)
  // 10: | (2.50%)
  // 11:  (0.83%)
  // 12:  (0.83%)
  //
  // Minimum Hamming distance: 5
  // Maximum Hamming distance: 12
  // Minimum Hamming weight: 4
  // Maximum Hamming weight: 8
  //
  localparam int StateWidth = 12;
  typedef enum logic [StateWidth-1:0] {
    ResetSt         = 12'b011000001110,
    InitSt          = 12'b110100100111,
    InitWaitSt      = 12'b001110110001,
    InitDescrSt     = 12'b110010000100,
    InitDescrWaitSt = 12'b100110101000,
    IdleSt          = 12'b010101001101,
    IntegScrSt      = 12'b110101011010,
    IntegScrWaitSt  = 12'b100010011111,
    IntegDigClrSt   = 12'b101001000001,
    IntegDigSt      = 12'b011101100010,
    IntegDigPadSt   = 12'b001101010111,
    IntegDigFinSt   = 12'b011011100101,
    IntegDigWaitSt  = 12'b100011110010,
    CnstyReadSt     = 12'b000001101011,
    CnstyReadWaitSt = 12'b101001111100,
    ErrorSt         = 12'b010110111110
  } state_e;

  typedef enum logic {
    ScrmblData,
    OtpData
  } data_sel_e;

  typedef enum logic {
    PartOffset,
    DigOffset
  } base_sel_e;

  state_e state_d, state_q;
  otp_err_e error_d, error_q;
  data_sel_e data_sel;
  base_sel_e base_sel;
  mubi8_t dout_locked_d, dout_locked_q;
  logic [CntWidth-1:0] cnt;
  logic cnt_en, cnt_clr, cnt_err;
  logic ecc_err;
  logic buffer_reg_en;
  logic [ScrmblBlockWidth-1:0] data_mux;

  // Output partition error state.
  assign error_o = error_q;

  // This partition cannot do any write accesses, hence we tie this
  // constantly off.
  assign otp_wdata_o = '0;
  // Depending on the partition configuration, the wrapper is instructed to ignore integrity
  // calculations and checks. To be on the safe side, the partition filters error responses at this
  // point and does not report any integrity errors if integrity is disabled.
  otp_err_e otp_err;
  if (Info.integrity) begin : gen_integrity
    assign otp_cmd_o = prim_otp_pkg::Read;
    assign otp_err = otp_err_e'(otp_err_i);
  end else begin : gen_no_integrity
    assign otp_cmd_o = prim_otp_pkg::ReadRaw;
    always_comb begin
      if (otp_err_e'(otp_err_i) inside {MacroEccCorrError, MacroEccUncorrError}) begin
        otp_err = NoError;
      end else begin
        otp_err = otp_err_e'(otp_err_i);
      end
    end
  end

  always_comb begin : p_fsm
    state_d = state_q;

    // Redundantly encoded lock signal for buffer regs.
    dout_locked_d = dout_locked_q;

    // OTP signals
    otp_req_o = 1'b0;

    // Scrambling mutex
    scrmbl_mtx_req_o = 1'b0;

    // Scrambling datapath
    scrmbl_cmd_o   = LoadShadow;
    scrmbl_sel_o   = CnstyDigest;
    scrmbl_mode_o  = StandardMode;
    scrmbl_valid_o = 1'b0;

    // Counter
    cnt_en   = 1'b0;
    cnt_clr  = 1'b0;
    base_sel = PartOffset;

    // Buffer register
    buffer_reg_en = 1'b0;
    data_sel = OtpData;

    // Error Register
    error_d = error_q;
    fsm_err_o = 1'b0;

    // Integrity/Consistency check responses
    cnsty_chk_ack_o = 1'b0;
    integ_chk_ack_o = 1'b0;

    unique case (state_q)
      ///////////////////////////////////////////////////////////////////
      // State right after reset. Wait here until we get a an
      // initialization request.
      ResetSt: begin
        if (init_req_i) begin
          state_d = InitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Initialization reads out the digest only in unbuffered
      // partitions. Wait here until the OTP request has been granted.
      // And then wait until the OTP word comes back.
      InitSt: begin
        otp_req_o = 1'b1;
        if (otp_gnt_i) begin
          state_d = InitWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for OTP response and write to buffer register, then go to
      // descrambling state. In case an OTP transaction fails, latch the
      // OTP error code and jump to a
      // terminal error state.
      InitWaitSt: begin
        if (otp_rvalid_i) begin
          buffer_reg_en = 1'b1;
          if (otp_err inside {NoError, MacroEccCorrError}) begin
            // Once we've read and descrambled the whole partition, we can go to integrity
            // verification. Note that the last block is the digest value, which does not
            // have to be descrambled.
            if (cnt == LastScrmblBlock) begin
              state_d = IntegDigClrSt;
            // Only need to descramble if this is a scrambled partition.
            // Otherwise, we can just go back to InitSt and read the next block.
            end else if (Info.secret) begin
              state_d = InitDescrSt;
            end else begin
              state_d = InitSt;
              cnt_en = 1'b1;
            end
            // At this point the only error that we could have gotten are correctable ECC errors.
            if (otp_err != NoError) begin
              error_d = MacroEccCorrError;
            end
          end else begin
            state_d = ErrorSt;
            error_d = otp_err;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Descrambling state. This first acquires the scrambling
      // datapath mutex. Note that once the mutex is acquired, we have
      // exclusive access to the scrambling datapath until we release
      // the mutex by deasserting scrmbl_mtx_req_o.
      // SEC_CM: SECRET.MEM.SCRAMBLE
      InitDescrSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        scrmbl_cmd_o = Decrypt;
        scrmbl_sel_o = Info.key_sel;
        if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
          state_d = InitDescrWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for the descrambled data to return. Note that we release
      // the mutex lock upon leaving this state.
      // SEC_CM: SECRET.MEM.SCRAMBLE
      InitDescrWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_sel_o = Info.key_sel;
        data_sel = ScrmblData;
        if (scrmbl_valid_i) begin
          state_d = InitSt;
          buffer_reg_en = 1'b1;
          cnt_en = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Idle state. We basically wait for integrity and consistency check
      // triggers in this state.
      IdleSt: begin
        if (integ_chk_req_i) begin
          if (Info.hw_digest) begin
            state_d = IntegDigClrSt;
          // In case there is nothing to check we can just
          // acknowledge the request right away, without going to the
          // integrity check.
          end else begin
            integ_chk_ack_o = 1'b1;
          end
        end else if (cnsty_chk_req_i) begin
          state_d = CnstyReadSt;
          cnt_clr = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Read the digest. Wait here until the OTP request has been granted.
      // And then wait until the OTP word comes back.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      CnstyReadSt: begin
        otp_req_o = 1'b1;
        // In case this partition has a hardware digest, we only have to read
        // and compare the digest value. In that case we select the digest offset here.
        // Otherwise we have to read and compare the whole partition, in which case we
        // select the partition offset, which is the default assignment of base_sel.
        if (Info.hw_digest) begin
          base_sel = DigOffset;
        end
        if (otp_gnt_i) begin
          state_d = CnstyReadWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for OTP response and compare the digest. In case there is
      // a mismatch, lock down the partition and go into the terminal error
      // state. In case an OTP transaction fails, latch the OTP error code
      // and jump to a terminal error state.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      CnstyReadWaitSt: begin
        if (otp_rvalid_i) begin
          if (otp_err inside {NoError, MacroEccCorrError}) begin
            // Check whether we need to compare the digest or the full partition
            // contents here.
            if (Info.hw_digest) begin
              // Note that we ignore this check if the digest is still blank.
              if (digest_o == data_mux || digest_o == '0) begin
                state_d = IdleSt;
                cnsty_chk_ack_o = 1'b1;
              // Error out and lock the partition if this check fails.
              end else begin
                state_d = ErrorSt;
                error_d = CheckFailError;
                // The check has finished and found an error.
                cnsty_chk_ack_o = 1'b1;
              end
            end else begin
              // Check whether the read data corresponds with the data buffered in regs.
              // Note that this particular check can be bypassed in case a transition is ongoing.
              if (scrmbl_data_o == data_mux ||
                  lc_ctrl_pkg::lc_tx_test_true_strict(check_byp_en_i)) begin
                // Can go back to idle and acknowledge the
                // request if this is the last block.
                if (cnt == LastScrmblBlock) begin
                  state_d = IdleSt;
                  cnsty_chk_ack_o = 1'b1;
                // Need to go back and read out more blocks.
                end else begin
                  state_d = CnstyReadSt;
                  cnt_en = 1'b1;
                end
              end else begin
                state_d = ErrorSt;
                error_d = CheckFailError;
                // The check has finished and found an error.
                cnsty_chk_ack_o = 1'b1;
              end
            end
            // At this point the only error that we could have gotten are correctable ECC errors.
            if (otp_err != NoError) begin
              error_d = MacroEccCorrError;
            end
          end else begin
            state_d = ErrorSt;
            error_d = otp_err;
            // The check has finished and found an error.
            cnsty_chk_ack_o = 1'b1;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // First, acquire the mutex for the digest and clear the digest state.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigClrSt: begin
        // Check whether this partition requires checking at all.
        if (Info.hw_digest) begin
          scrmbl_mtx_req_o = 1'b1;
          scrmbl_valid_o = 1'b1;
          cnt_clr = 1'b1;
          // Need to reset the digest state and set it to chained
          // mode if this partition is scrambled.
          scrmbl_cmd_o = DigestInit;
          if (Info.secret) begin
            scrmbl_mode_o = ChainedMode;
            if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
              state_d = IntegScrSt;
            end
          // If this partition is not scrambled, we can just directly
          // jump to the digest state.
          end else begin
            scrmbl_mode_o = StandardMode;
            if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
              state_d = IntegDigSt;
            end
          end
        // Otherwise, if this partition is not digest protected,
        // we can just go to idle, since there is nothing to check.
        // Note that we do not come back to this state in case there is no
        // digest, and hence it is safe to unlock the buffer regs at this point.
        // This is the only way the buffer regs can get unlocked.
        end else begin
          state_d = IdleSt;
          if (mubi8_test_true_strict(dout_locked_q)) begin
            dout_locked_d = MuBi8False;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Scramble buffered data (which is held in plaintext form).
      // This moves the previous scrambling result into the shadow reg
      // for later use.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegScrSt: begin
          scrmbl_mtx_req_o = 1'b1;
          scrmbl_valid_o = 1'b1;
          scrmbl_cmd_o = Encrypt;
          scrmbl_sel_o = Info.key_sel;
          if (scrmbl_ready_i) begin
            state_d = IntegScrWaitSt;
          end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for the scrambled data to return.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegScrWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_sel_o = Info.key_sel;
        if (scrmbl_valid_i) begin
          state_d = IntegDigSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Push the word read into the scrambling datapath. The last
      // block is repeated in case the number blocks in this partition
      // is odd.
      // SEC_CM: PART.MEM.DIGEST
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        if (scrmbl_ready_i) begin
          cnt_en = 1'b1;
          // No need to digest the digest value itself
          if (cnt == PenultimateScrmblBlock) begin
            // Note that the digest operates on 128bit blocks since the data is fed in via the
            // PRESENT key input. Therefore, we only trigger a digest update on every second
            // 64bit block that is pushed into the scrambling datapath.
            if (cnt[0]) begin
              scrmbl_cmd_o = Digest;
              state_d = IntegDigFinSt;
            end else begin
              state_d = IntegDigPadSt;
              cnt_en = 1'b0;
            end
          end else begin
            // Trigger digest round in case this is the second block in a row.
            if (cnt[0]) begin
              scrmbl_cmd_o = Digest;
            end
            // Go back and scramble the next data block if this is
            // a scrambled partition. Otherwise just stay here.
            if (Info.secret) begin
              state_d = IntegScrSt;
            end
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Padding state. When we get here, we've copied the last encryption
      // result into the shadow register such that we've effectively
      // repeated the last block twice in order to pad the data to 128bit.
      // SEC_CM: PART.MEM.DIGEST
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigPadSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        scrmbl_cmd_o = Digest;
        if (scrmbl_ready_i) begin
          state_d = IntegDigFinSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Trigger digest finalization and go wait for the result.
      // SEC_CM: PART.MEM.DIGEST
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigFinSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        scrmbl_cmd_o = DigestFinalize;
        if (scrmbl_ready_i) begin
          state_d = IntegDigWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for the digest to return, and double check whether the digest
      // matches. If yes, unlock the partition. Otherwise, go into the terminal
      // error state, where the partition will be locked down.
      // SEC_CM: PART.MEM.DIGEST
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        data_sel = ScrmblData;
        if (scrmbl_valid_i) begin
          // This is the only way the buffer regs can get unlocked.
          // Note that we ignore this check if the digest is still blank.
          if (digest_o == data_mux || digest_o == '0) begin
            state_d = IdleSt;
            // If the partition is still locked, this is the first integrity check after
            // initialization. This is the only way the buffer regs can get unlocked.
            if (mubi8_test_true_strict(dout_locked_q)) begin
              dout_locked_d = MuBi8False;
            // Otherwise, this integrity check has requested by the LFSR timer, and we have
            // to acknowledge its completion.
            end else begin
              integ_chk_ack_o = 1'b1;
            end
          // Error out and lock the partition if this check fails.
          end else begin
            state_d = ErrorSt;
            error_d = CheckFailError;
            // The check has finished and found an error.
            integ_chk_ack_o = 1'b1;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Terminal Error State. This locks access to the partition.
      // Make sure the partition signals an error state if no error
      // code has been latched so far, and lock the buffer regs down.
      ErrorSt: begin
        dout_locked_d = MuBi8True;
        if (error_q == NoError) begin
          error_d = FsmStateError;
        end
        // If we are in error state, we cannot execute the checks anymore.
        // Hence the acknowledgements are returned immediately.
        cnsty_chk_ack_o = 1'b1;
        integ_chk_ack_o = 1'b1;
      end
      ///////////////////////////////////////////////////////////////////
      // We should never get here. If we do (e.g. via a malicious
      // glitch), error out immediately.
      default: begin
        state_d = ErrorSt;
        fsm_err_o = 1'b1;
      end
      ///////////////////////////////////////////////////////////////////
    endcase // state_q


    // Unconditionally jump into the terminal error state in case of
    // an ECC error or escalation, and lock access to the partition down.
    // SEC_CM: PART.FSM.LOCAL_ESC
    if (ecc_err) begin
      state_d = ErrorSt;
      if (state_q != ErrorSt) begin
        error_d = CheckFailError;
      end
    end
    // SEC_CM: PART.FSM.LOCAL_ESC, PART.FSM.GLOBAL_ESC
    if (lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) || cnt_err) begin
      state_d = ErrorSt;
      fsm_err_o = 1'b1;
      if (state_q != ErrorSt) begin
        error_d = FsmStateError;
      end
    end
  end

  ////////////////////////////
  // Address Calc and Muxes //
  ////////////////////////////

  // Address counter - this is only used for computing a digest, hence the increment is
  // fixed to 8 byte.
  // SEC_CM: PART.CTR.REDUN
  prim_count #(
    .Width(CntWidth)
  ) u_prim_count (
    .clk_i,
    .rst_ni,
    .clr_i(cnt_clr),
    .set_i(1'b0),
    .set_cnt_i('0),
    .incr_en_i(cnt_en),
    .decr_en_i(1'b0),
    .step_i(CntWidth'(1)),
    .commit_i(1'b1),
    .cnt_o(cnt),
    .cnt_after_commit_o(),
    .err_o(cnt_err)
  );

  logic [OtpByteAddrWidth-1:0] addr_base;
  assign addr_base = (base_sel == DigOffset) ? DigestOffset : Info.offset;

  // Note that OTP works on halfword (16bit) addresses, hence need to
  // shift the addresses appropriately.
  logic [OtpByteAddrWidth-1:0] addr_calc;
  assign addr_calc = OtpByteAddrWidth'({cnt, {$clog2(ScrmblBlockWidth/8){1'b0}}}) + addr_base;
  assign otp_addr_o = addr_calc[OtpByteAddrWidth-1:OtpAddrShift];

  if (OtpAddrShift > 0) begin : gen_unused
    logic unused_bits;
    assign unused_bits = ^addr_calc[OtpAddrShift-1:0];
  end

  // Always transfer 64bit blocks.
  assign otp_size_o = OtpSizeWidth'(unsigned'(ScrmblBlockWidth / OtpWidth) - 1);

  assign data_mux = (data_sel == ScrmblData) ? scrmbl_data_i : otp_rdata_i;

  /////////////////
  // Buffer Regs //
  /////////////////

  // SEC_CM: PART.DATA_REG.INTEGRITY
  logic [Info.size*8-1:0] data;
  otp_ctrl_ecc_reg #(
    .Width ( ScrmblBlockWidth ),
    .Depth ( NumScrmblBlocks  )
  ) u_otp_ctrl_ecc_reg (
    .clk_i,
    .rst_ni,
    .wren_i    ( buffer_reg_en ),
    .addr_i    ( cnt           ),
    .wdata_i   ( data_mux      ),
    .rdata_o   ( scrmbl_data_o ),
    .data_o    ( data          ),
    .ecc_err_o ( ecc_err       )
  );

  // We have successfully initialized the partition once it has been unlocked.
  assign init_done_o = mubi8_test_false_strict(dout_locked_q);
  // Hardware output gating.
  // Note that this is decoupled from the DAI access rules further below.
  assign data_o = data;
  // The digest does not have to be gated.
  assign digest_o = data[$high(data_o) -: ScrmblBlockWidth];

  ////////////////////////
  // DAI Access Control //
  ////////////////////////

  // Aggregate all possible DAI write /readlocks. The partition is also locked when uninitialized.
  // Note that the locks are redundantly encoded values.
  part_access_t access_pre;
  prim_mubi8_sender #(
    .AsyncOn(0)
  ) u_prim_mubi8_sender_write_lock_pre (
    .clk_i,
    .rst_ni,
    .mubi_i(mubi8_and_lo(dout_locked_q, access_i.write_lock)),
    .mubi_o(access_pre.write_lock)
  );
  prim_mubi8_sender #(
    .AsyncOn(0)
  ) u_prim_mubi8_sender_read_lock_pre (
    .clk_i,
    .rst_ni,
    .mubi_i(mubi8_and_lo(dout_locked_q, access_i.read_lock)),
    .mubi_o(access_pre.read_lock)
  );

  // SEC_CM: PART.MEM.SW_UNWRITABLE
  if (Info.write_lock) begin : gen_digest_write_lock
    mubi8_t digest_locked;
    assign digest_locked = (digest_o != '0) ? MuBi8True : MuBi8False;

    // This prevents the synthesis tool from optimizing the multibit signal.
    prim_mubi8_sender #(
      .AsyncOn(0)
    ) u_prim_mubi8_sender_write_lock (
      .clk_i,
      .rst_ni,
      .mubi_i(mubi8_and_lo(access_pre.write_lock, digest_locked)),
      .mubi_o(access_o.write_lock)
    );

    `ASSERT(DigestWriteLocksPartition_A, digest_o |-> mubi8_test_true_loose(access_o.write_lock))
  end else begin : gen_no_digest_write_lock
    assign access_o.write_lock = access_pre.write_lock;
  end

  // SEC_CM: PART.MEM.SW_UNREADABLE
  if (Info.read_lock) begin : gen_digest_read_lock
    mubi8_t digest_locked;
    assign digest_locked = (digest_o != '0) ? MuBi8True : MuBi8False;

    // This prevents the synthesis tool from optimizing the multibit signal.
    prim_mubi8_sender #(
      .AsyncOn(0)
    ) u_prim_mubi8_sender_read_lock (
      .clk_i,
      .rst_ni,
      .mubi_i(mubi8_and_lo(access_pre.read_lock, digest_locked)),
      .mubi_o(access_o.read_lock)
    );

    `ASSERT(DigestReadLocksPartition_A, digest_o |-> mubi8_test_true_loose(access_o.read_lock))
  end else begin : gen_no_digest_read_lock
    assign access_o.read_lock = access_pre.read_lock;
  end

  ///////////////
  // Registers //
  ///////////////

  `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, state_e, ResetSt)

  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs
    if (!rst_ni) begin
      error_q       <= NoError;
      // data output is locked by default
      dout_locked_q <= MuBi8True;
    end else begin
      error_q       <= error_d;
      dout_locked_q <= dout_locked_d;
    end
  end

  ////////////////
  // Assertions //
  ////////////////

  // Known assertions
  `ASSERT_KNOWN(InitDoneKnown_A,     init_done_o)
  `ASSERT_KNOWN(IntegChkAckKnown_A,  integ_chk_ack_o)
  `ASSERT_KNOWN(CnstyChkAckKnown_A,  cnsty_chk_ack_o)
  `ASSERT_KNOWN(ErrorKnown_A,        error_o)
  `ASSERT_KNOWN(AccessKnown_A,       access_o)
  `ASSERT_KNOWN(DigestKnown_A,       digest_o)
  `ASSERT_KNOWN(DataKnown_A,         data_o)
  `ASSERT_KNOWN(OtpReqKnown_A,       otp_req_o)
  `ASSERT_KNOWN(OtpCmdKnown_A,       otp_cmd_o)
  `ASSERT_KNOWN(OtpSizeKnown_A,      otp_size_o)
  `ASSERT_KNOWN(OtpWdataKnown_A,     otp_wdata_o)
  `ASSERT_KNOWN(OtpAddrKnown_A,      otp_addr_o)
  `ASSERT_KNOWN(ScrmblMtxReqKnown_A, scrmbl_mtx_req_o)
  `ASSERT_KNOWN(ScrmblCmdKnown_A,    scrmbl_cmd_o)
  `ASSERT_KNOWN(ScrmblModeKnown_A,   scrmbl_mode_o)
  `ASSERT_KNOWN(ScrmblSelKnown_A,    scrmbl_sel_o)
  `ASSERT_KNOWN(ScrmblDataKnown_A,   scrmbl_data_o)
  `ASSERT_KNOWN(ScrmblValidKnown_A,  scrmbl_valid_o)

  // Uninitialized partitions should always be locked, no matter what.
  `ASSERT(InitWriteLocksPartition_A,
      mubi8_test_true_loose(dout_locked_q)
      |->
      mubi8_test_true_loose(access_o.write_lock))
  `ASSERT(InitReadLocksPartition_A,
      mubi8_test_true_loose(dout_locked_q)
      |->
      mubi8_test_true_loose(access_o.read_lock))
  // Incoming Lock propagation
  `ASSERT(WriteLockPropagation_A,
      mubi8_test_true_loose(access_i.write_lock)
      |->
      mubi8_test_true_loose(access_o.write_lock))
  `ASSERT(ReadLockPropagation_A,
      mubi8_test_true_loose(access_i.read_lock)
      |->
      mubi8_test_true_loose(access_o.read_lock))
  // ECC error in buffer regs
  `ASSERT(EccErrorState_A,
      ecc_err
      |=>
      state_q == ErrorSt)
  // OTP error response
  `ASSERT(OtpErrorState_A,
      state_q inside {InitWaitSt, CnstyReadWaitSt} && otp_rvalid_i &&
      !(otp_err inside {NoError, MacroEccCorrError}) && !ecc_err
      |=>
      state_q == ErrorSt && error_o == $past(otp_err))

  // The partition size must be greater than one scrambling block for the address calculation
  // and muxing to work correctly.
  `ASSERT_INIT(OtpPartBufSize_A, Info.size > (ScrmblBlockWidth/8))

endmodule : otp_ctrl_part_buf

    '''

    Use the anomaly detector tool to identify lines in the design RTL that are anomalous.
    Then determine whether the identified anomalous line(s) represent a security issue or not.

    
================================== Ai Message ==================================
Tool Calls:
  anomaly_detector_tool (call_NSQ3XlEpnZpU3bvQPQWUFbM5)
 Call ID: call_NSQ3XlEpnZpU3bvQPQWUFbM5
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv
================================= Tool Message =================================
Name: anomaly_detector_tool

Successfully executed:
```LLM Anomaly Detector tool
```
Output:
Here are clusters of similar verilog constructs in the RTL file:



Cluster 0:
assign otp_wdata_o = '0;
assign otp_cmd_o = prim_otp_pkg::Read;
assign otp_err = otp_err_e'(otp_err_i);
assign otp_cmd_o = prim_otp_pkg::ReadRaw;


Cluster 1:
assign addr_calc = OtpByteAddrWidth'({cnt, {$clog2(ScrmblBlockWidth/8){1'b0}}}) + addr_base;
assign otp_addr_o = addr_calc[OtpByteAddrWidth-1:OtpAddrShift];
assign unused_bits = ^addr_calc[OtpAddrShift-1:0];
assign otp_size_o = OtpSizeWidth'(unsigned'(ScrmblBlockWidth / OtpWidth) - 1);


Cluster 2:
assign digest_locked = (digest_o != '0) ? MuBi8True : MuBi8False;
assign digest_locked = (digest_o != '0) ? MuBi8True : MuBi8False;


Cluster 3:
assign access_o.write_lock = access_pre.write_lock;
assign access_o.read_lock = access_pre.read_lock;

================================== Ai Message ==================================

The anomaly detection found a few clusters of similar code lines. Notably, in Cluster 0, the following lines were identified:

- `assign otp_wdata_o = '0;`
- `assign otp_cmd_o = prim_otp_pkg::Read;`
- `assign otp_err = otp_err_e'(otp_err_i);`
- `assign otp_cmd_o = prim_otp_pkg::ReadRaw;`

These lines are related to the OTP command and data handling, with two different assignments to `otp_cmd_o` depending on the integrity configuration. This could be an anomaly because there are two mutually exclusive assignments to `otp_cmd_o` observed:

```verilog
if (Info.integrity) begin
  assign otp_cmd_o = prim_otp_pkg::Read;
  assign otp_err = otp_err_e'(otp_err_i);
end else begin
  assign otp_cmd_o = prim_otp_pkg::ReadRaw;
  always_comb begin
    if (otp_err_e'(otp_err_i) inside {MacroEccCorrError, MacroEccUncorrError}) begin
      otp_err = NoError;
    end else begin
      otp_err = otp_err_e'(otp_err_i);
    end
  end
end
```

However, since these are inside different generate-if blocks based on the parameter `Info.integrity`, this is intended behavior and likely not an anomaly from a functional standpoint.

Regarding partition lock enforcement and error state handling:

- The design transitions to a terminal `ErrorSt` state on errors including ECC error, escalation (`escalate_en_i`), or check failure.
- In `ErrorSt`, the partition locks the data output (`dout_locked_d = MuBi8True`), and the access locks (`access_o`) indicate locked state.
- There is strict propagation of write and read locks.
- Assertions ensure that the partition is locked if uninitialized or if errors occur.
- The FSM also jumps to ErrorSt on any unexpected state, which also is a security defense.

Conclusion:

- The partition lock enforcement seems robust. Upon error or escalation, the partition is locked down by setting lock signals.
- Error state handling properly transitions to a terminal error state that locks access.
- The anomalous-looking dual assignment of OTP command signals respects configuration differences and is not a security issue.
- No anomalous code was found that could represent a bypass or security flaw in the partition locking or error handling FSM.

**Final assessment:** No RTL security issues related to partition lock enforcement and error state handling were identified in the provided design. The design correctly locks the partition on error states and escalation, protecting against unauthorized access.
================================= Tool Message =================================
Name: run_anomaly_detector_agent

The anomaly detection found a few clusters of similar code lines. Notably, in Cluster 0, the following lines were identified:

- `assign otp_wdata_o = '0;`
- `assign otp_cmd_o = prim_otp_pkg::Read;`
- `assign otp_err = otp_err_e'(otp_err_i);`
- `assign otp_cmd_o = prim_otp_pkg::ReadRaw;`

These lines are related to the OTP command and data handling, with two different assignments to `otp_cmd_o` depending on the integrity configuration. This could be an anomaly because there are two mutually exclusive assignments to `otp_cmd_o` observed:

```verilog
if (Info.integrity) begin
  assign otp_cmd_o = prim_otp_pkg::Read;
  assign otp_err = otp_err_e'(otp_err_i);
end else begin
  assign otp_cmd_o = prim_otp_pkg::ReadRaw;
  always_comb begin
    if (otp_err_e'(otp_err_i) inside {MacroEccCorrError, MacroEccUncorrError}) begin
      otp_err = NoError;
    end else begin
      otp_err = otp_err_e'(otp_err_i);
    end
  end
end
```

However, since these are inside different generate-if blocks based on the parameter `Info.integrity`, this is intended behavior and likely not an anomaly from a functional standpoint.

Regarding partition lock enforcement and error state handling:

- The design transitions to a terminal `ErrorSt` state on errors including ECC error, escalation (`escalate_en_i`), or check failure.
- In `ErrorSt`, the partition locks the data output (`dout_locked_d = MuBi8True`), and the access locks (`access_o`) indicate locked state.
- There is strict propagation of write and read locks.
- Assertions ensure that the partition is locked if uninitialized or if errors occur.
- The FSM also jumps to ErrorSt on any unexpected state, which also is a security defense.

Conclusion:

- The partition lock enforcement seems robust. Upon error or escalation, the partition is locked down by setting lock signals.
- Error state handling properly transitions to a terminal error state that locks access.
- The anomalous-looking dual assignment of OTP command signals respects configuration differences and is not a security issue.
- No anomalous code was found that could represent a bypass or security flaw in the partition locking or error handling FSM.

**Final assessment:** No RTL security issues related to partition lock enforcement and error state handling were identified in the provided design. The design correctly locks the partition on error states and escalation, protecting against unauthorized access.
================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_boj6AW2T4fKVLxCbHlVnJf9X)
 Call ID: call_boj6AW2T4fKVLxCbHlVnJf9X
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/otp_ctrl/rtl/otp_ctrl_part_buf.sv
    top_module: otp_ctrl_part_buf
    security_objective: hardware state machine glitch attack
================================ Human Message =================================

Are there security concerns related to hardware state machine glitch attack in the provided RTL:
    """

    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Buffered partition for OTP controller.
//

`include "prim_flop_macros.sv"

module otp_ctrl_part_buf
  import otp_ctrl_pkg::*;
  import otp_ctrl_reg_pkg::*;
  import otp_ctrl_part_pkg::*;
#(
  // Partition information.
  parameter part_info_t             Info = PartInfoDefault,
  parameter logic [Info.size*8-1:0] DataDefault = '0
) (
  input                               clk_i,
  input                               rst_ni,
  // Pulse to start partition initialisation (required once per power cycle).
  input                               init_req_i,
  output logic                        init_done_o,
  // Integrity check requests
  input                               integ_chk_req_i,
  output logic                        integ_chk_ack_o,
  // Consistency check requests
  input                               cnsty_chk_req_i,
  output logic                        cnsty_chk_ack_o,
  // Escalation input. This moves the FSM into a terminal state and locks down
  // the partition.
  input  lc_ctrl_pkg::lc_tx_t         escalate_en_i,
  // Check bypass enable. This bypasses integrity and consistency checks and
  // acknowledges all incoming check requests (only used by life cycle).
  input  lc_ctrl_pkg::lc_tx_t         check_byp_en_i,
  // Output error state of partition, to be consumed by OTP error/alert logic.
  // Note that most errors are not recoverable and move the partition FSM into
  // a terminal error state.
  output otp_err_e                    error_o,
  // This error signal is pulsed high if the FSM has been glitched into an invalid state.
  // Although it is somewhat redundant with the error code in error_o above, it is
  // meant to cover cases where we already latched an error code while the FSM is
  // glitched into an invalid state (since in that case, the error code will not be
  // overridden with the FSM error code so that the original error code is still
  // discoverable).
  output logic                        fsm_err_o,
  // Access/lock status
  // SEC_CM: ACCESS.CTRL.MUBI
  input  part_access_t                access_i, // runtime lock from CSRs
  output part_access_t                access_o,
  // Buffered 64bit digest output.
  output logic [ScrmblBlockWidth-1:0] digest_o,
  output logic [Info.size*8-1:0]      data_o,
  // OTP interface
  output logic                        otp_req_o,
  output prim_otp_pkg::cmd_e          otp_cmd_o,
  output logic [OtpSizeWidth-1:0]     otp_size_o,
  output logic [OtpIfWidth-1:0]       otp_wdata_o,
  output logic [OtpAddrWidth-1:0]     otp_addr_o,
  input                               otp_gnt_i,
  input                               otp_rvalid_i,
  input  [ScrmblBlockWidth-1:0]       otp_rdata_i,
  input  prim_otp_pkg::err_e          otp_err_i,
  // Scrambling mutex request
  output logic                        scrmbl_mtx_req_o,
  input                               scrmbl_mtx_gnt_i,
  // Scrambling datapath interface
  output otp_scrmbl_cmd_e             scrmbl_cmd_o,
  output digest_mode_e                scrmbl_mode_o,
  output logic [ConstSelWidth-1:0]    scrmbl_sel_o,
  output logic [ScrmblBlockWidth-1:0] scrmbl_data_o,
  output logic                        scrmbl_valid_o,
  input  logic                        scrmbl_ready_i,
  input  logic                        scrmbl_valid_i,
  input  logic [ScrmblBlockWidth-1:0] scrmbl_data_i
);

  ////////////////////////
  // Integration Checks //
  ////////////////////////

  import prim_mubi_pkg::*;
  import prim_util_pkg::vbits;

  localparam int unsigned DigestOffsetInt = (int'(Info.offset) +
                                             int'(Info.size) - ScrmblBlockWidth/8);
  localparam int NumScrmblBlocks = int'(Info.size) / (ScrmblBlockWidth/8);
  localparam int CntWidth = vbits(NumScrmblBlocks);

  localparam bit [OtpByteAddrWidth-1:0] DigestOffset = DigestOffsetInt[OtpByteAddrWidth-1:0];

  localparam int unsigned LastScrmblBlockInt = NumScrmblBlocks - 1;
  localparam int unsigned PenultimateScrmblBlockInt = NumScrmblBlocks - 2;
  localparam bit [CntWidth-1:0] LastScrmblBlock = LastScrmblBlockInt[CntWidth-1:0];
  localparam bit [CntWidth-1:0] PenultimateScrmblBlock = PenultimateScrmblBlockInt[CntWidth-1:0];

  // Integration checks for parameters.
  `ASSERT_INIT(OffsetMustBeBlockAligned_A, (Info.offset % (ScrmblBlockWidth/8)) == 0)
  `ASSERT_INIT(SizeMustBeBlockAligned_A, (Info.size % (ScrmblBlockWidth/8)) == 0)
  `ASSERT_INIT(DigestOffsetMustBeRepresentable_A, DigestOffsetInt == int'(DigestOffset))
  `ASSERT(ScrambledImpliesDigest_A, Info.secret |-> Info.hw_digest)
  `ASSERT(WriteLockImpliesDigest_A, Info.read_lock |-> Info.hw_digest)
  `ASSERT(ReadLockImpliesDigest_A, Info.write_lock |-> Info.hw_digest)

  // This feature is only supposed to be used with partitions that are not scrambled
  // and that do not have a digest.
  `ASSERT(BypassEnable0_A, Info.secret    |-> lc_ctrl_pkg::lc_tx_test_false_strict(check_byp_en_i))
  `ASSERT(BypassEnable1_A, Info.hw_digest |-> lc_ctrl_pkg::lc_tx_test_false_strict(check_byp_en_i))

  ///////////////////////
  // OTP Partition FSM //
  ///////////////////////

  // SEC_CM: PART.FSM.SPARSE
  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 5 -m 16 -n 12 \
  //      -s 3370657881 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: --
  //  4: --
  //  5: |||||||||||||| (28.33%)
  //  6: |||||||||||||||||||| (38.33%)
  //  7: |||||||||| (19.17%)
  //  8: ||| (5.83%)
  //  9: || (4.17%)
  // 10: | (2.50%)
  // 11:  (0.83%)
  // 12:  (0.83%)
  //
  // Minimum Hamming distance: 5
  // Maximum Hamming distance: 12
  // Minimum Hamming weight: 4
  // Maximum Hamming weight: 8
  //
  localparam int StateWidth = 12;
  typedef enum logic [StateWidth-1:0] {
    ResetSt         = 12'b011000001110,
    InitSt          = 12'b110100100111,
    InitWaitSt      = 12'b001110110001,
    InitDescrSt     = 12'b110010000100,
    InitDescrWaitSt = 12'b100110101000,
    IdleSt          = 12'b010101001101,
    IntegScrSt      = 12'b110101011010,
    IntegScrWaitSt  = 12'b100010011111,
    IntegDigClrSt   = 12'b101001000001,
    IntegDigSt      = 12'b011101100010,
    IntegDigPadSt   = 12'b001101010111,
    IntegDigFinSt   = 12'b011011100101,
    IntegDigWaitSt  = 12'b100011110010,
    CnstyReadSt     = 12'b000001101011,
    CnstyReadWaitSt = 12'b101001111100,
    ErrorSt         = 12'b010110111110
  } state_e;

  typedef enum logic {
    ScrmblData,
    OtpData
  } data_sel_e;

  typedef enum logic {
    PartOffset,
    DigOffset
  } base_sel_e;

  state_e state_d, state_q;
  otp_err_e error_d, error_q;
  data_sel_e data_sel;
  base_sel_e base_sel;
  mubi8_t dout_locked_d, dout_locked_q;
  logic [CntWidth-1:0] cnt;
  logic cnt_en, cnt_clr, cnt_err;
  logic ecc_err;
  logic buffer_reg_en;
  logic [ScrmblBlockWidth-1:0] data_mux;

  // Output partition error state.
  assign error_o = error_q;

  // This partition cannot do any write accesses, hence we tie this
  // constantly off.
  assign otp_wdata_o = '0;
  // Depending on the partition configuration, the wrapper is instructed to ignore integrity
  // calculations and checks. To be on the safe side, the partition filters error responses at this
  // point and does not report any integrity errors if integrity is disabled.
  otp_err_e otp_err;
  if (Info.integrity) begin : gen_integrity
    assign otp_cmd_o = prim_otp_pkg::Read;
    assign otp_err = otp_err_e'(otp_err_i);
  end else begin : gen_no_integrity
    assign otp_cmd_o = prim_otp_pkg::ReadRaw;
    always_comb begin
      if (otp_err_e'(otp_err_i) inside {MacroEccCorrError, MacroEccUncorrError}) begin
        otp_err = NoError;
      end else begin
        otp_err = otp_err_e'(otp_err_i);
      end
    end
  end

  always_comb begin : p_fsm
    state_d = state_q;

    // Redundantly encoded lock signal for buffer regs.
    dout_locked_d = dout_locked_q;

    // OTP signals
    otp_req_o = 1'b0;

    // Scrambling mutex
    scrmbl_mtx_req_o = 1'b0;

    // Scrambling datapath
    scrmbl_cmd_o   = LoadShadow;
    scrmbl_sel_o   = CnstyDigest;
    scrmbl_mode_o  = StandardMode;
    scrmbl_valid_o = 1'b0;

    // Counter
    cnt_en   = 1'b0;
    cnt_clr  = 1'b0;
    base_sel = PartOffset;

    // Buffer register
    buffer_reg_en = 1'b0;
    data_sel = OtpData;

    // Error Register
    error_d = error_q;
    fsm_err_o = 1'b0;

    // Integrity/Consistency check responses
    cnsty_chk_ack_o = 1'b0;
    integ_chk_ack_o = 1'b0;

    unique case (state_q)
      ///////////////////////////////////////////////////////////////////
      // State right after reset. Wait here until we get a an
      // initialization request.
      ResetSt: begin
        if (init_req_i) begin
          state_d = InitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Initialization reads out the digest only in unbuffered
      // partitions. Wait here until the OTP request has been granted.
      // And then wait until the OTP word comes back.
      InitSt: begin
        otp_req_o = 1'b1;
        if (otp_gnt_i) begin
          state_d = InitWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for OTP response and write to buffer register, then go to
      // descrambling state. In case an OTP transaction fails, latch the
      // OTP error code and jump to a
      // terminal error state.
      InitWaitSt: begin
        if (otp_rvalid_i) begin
          buffer_reg_en = 1'b1;
          if (otp_err inside {NoError, MacroEccCorrError}) begin
            // Once we've read and descrambled the whole partition, we can go to integrity
            // verification. Note that the last block is the digest value, which does not
            // have to be descrambled.
            if (cnt == LastScrmblBlock) begin
              state_d = IntegDigClrSt;
            // Only need to descramble if this is a scrambled partition.
            // Otherwise, we can just go back to InitSt and read the next block.
            end else if (Info.secret) begin
              state_d = InitDescrSt;
            end else begin
              state_d = InitSt;
              cnt_en = 1'b1;
            end
            // At this point the only error that we could have gotten are correctable ECC errors.
            if (otp_err != NoError) begin
              error_d = MacroEccCorrError;
            end
          end else begin
            state_d = ErrorSt;
            error_d = otp_err;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Descrambling state. This first acquires the scrambling
      // datapath mutex. Note that once the mutex is acquired, we have
      // exclusive access to the scrambling datapath until we release
      // the mutex by deasserting scrmbl_mtx_req_o.
      // SEC_CM: SECRET.MEM.SCRAMBLE
      InitDescrSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        scrmbl_cmd_o = Decrypt;
        scrmbl_sel_o = Info.key_sel;
        if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
          state_d = InitDescrWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for the descrambled data to return. Note that we release
      // the mutex lock upon leaving this state.
      // SEC_CM: SECRET.MEM.SCRAMBLE
      InitDescrWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_sel_o = Info.key_sel;
        data_sel = ScrmblData;
        if (scrmbl_valid_i) begin
          state_d = InitSt;
          buffer_reg_en = 1'b1;
          cnt_en = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Idle state. We basically wait for integrity and consistency check
      // triggers in this state.
      IdleSt: begin
        if (integ_chk_req_i) begin
          if (Info.hw_digest) begin
            state_d = IntegDigClrSt;
          // In case there is nothing to check we can just
          // acknowledge the request right away, without going to the
          // integrity check.
          end else begin
            integ_chk_ack_o = 1'b1;
          end
        end else if (cnsty_chk_req_i) begin
          state_d = CnstyReadSt;
          cnt_clr = 1'b1;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Read the digest. Wait here until the OTP request has been granted.
      // And then wait until the OTP word comes back.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      CnstyReadSt: begin
        otp_req_o = 1'b1;
        // In case this partition has a hardware digest, we only have to read
        // and compare the digest value. In that case we select the digest offset here.
        // Otherwise we have to read and compare the whole partition, in which case we
        // select the partition offset, which is the default assignment of base_sel.
        if (Info.hw_digest) begin
          base_sel = DigOffset;
        end
        if (otp_gnt_i) begin
          state_d = CnstyReadWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for OTP response and compare the digest. In case there is
      // a mismatch, lock down the partition and go into the terminal error
      // state. In case an OTP transaction fails, latch the OTP error code
      // and jump to a terminal error state.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      CnstyReadWaitSt: begin
        if (otp_rvalid_i) begin
          if (otp_err inside {NoError, MacroEccCorrError}) begin
            // Check whether we need to compare the digest or the full partition
            // contents here.
            if (Info.hw_digest) begin
              // Note that we ignore this check if the digest is still blank.
              if (digest_o == data_mux || digest_o == '0) begin
                state_d = IdleSt;
                cnsty_chk_ack_o = 1'b1;
              // Error out and lock the partition if this check fails.
              end else begin
                state_d = ErrorSt;
                error_d = CheckFailError;
                // The check has finished and found an error.
                cnsty_chk_ack_o = 1'b1;
              end
            end else begin
              // Check whether the read data corresponds with the data buffered in regs.
              // Note that this particular check can be bypassed in case a transition is ongoing.
              if (scrmbl_data_o == data_mux ||
                  lc_ctrl_pkg::lc_tx_test_true_strict(check_byp_en_i)) begin
                // Can go back to idle and acknowledge the
                // request if this is the last block.
                if (cnt == LastScrmblBlock) begin
                  state_d = IdleSt;
                  cnsty_chk_ack_o = 1'b1;
                // Need to go back and read out more blocks.
                end else begin
                  state_d = CnstyReadSt;
                  cnt_en = 1'b1;
                end
              end else begin
                state_d = ErrorSt;
                error_d = CheckFailError;
                // The check has finished and found an error.
                cnsty_chk_ack_o = 1'b1;
              end
            end
            // At this point the only error that we could have gotten are correctable ECC errors.
            if (otp_err != NoError) begin
              error_d = MacroEccCorrError;
            end
          end else begin
            state_d = ErrorSt;
            error_d = otp_err;
            // The check has finished and found an error.
            cnsty_chk_ack_o = 1'b1;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // First, acquire the mutex for the digest and clear the digest state.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigClrSt: begin
        // Check whether this partition requires checking at all.
        if (Info.hw_digest) begin
          scrmbl_mtx_req_o = 1'b1;
          scrmbl_valid_o = 1'b1;
          cnt_clr = 1'b1;
          // Need to reset the digest state and set it to chained
          // mode if this partition is scrambled.
          scrmbl_cmd_o = DigestInit;
          if (Info.secret) begin
            scrmbl_mode_o = ChainedMode;
            if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
              state_d = IntegScrSt;
            end
          // If this partition is not scrambled, we can just directly
          // jump to the digest state.
          end else begin
            scrmbl_mode_o = StandardMode;
            if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
              state_d = IntegDigSt;
            end
          end
        // Otherwise, if this partition is not digest protected,
        // we can just go to idle, since there is nothing to check.
        // Note that we do not come back to this state in case there is no
        // digest, and hence it is safe to unlock the buffer regs at this point.
        // This is the only way the buffer regs can get unlocked.
        end else begin
          state_d = IdleSt;
          if (mubi8_test_true_strict(dout_locked_q)) begin
            dout_locked_d = MuBi8False;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Scramble buffered data (which is held in plaintext form).
      // This moves the previous scrambling result into the shadow reg
      // for later use.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegScrSt: begin
          scrmbl_mtx_req_o = 1'b1;
          scrmbl_valid_o = 1'b1;
          scrmbl_cmd_o = Encrypt;
          scrmbl_sel_o = Info.key_sel;
          if (scrmbl_ready_i) begin
            state_d = IntegScrWaitSt;
          end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for the scrambled data to return.
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegScrWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_sel_o = Info.key_sel;
        if (scrmbl_valid_i) begin
          state_d = IntegDigSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Push the word read into the scrambling datapath. The last
      // block is repeated in case the number blocks in this partition
      // is odd.
      // SEC_CM: PART.MEM.DIGEST
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        if (scrmbl_ready_i) begin
          cnt_en = 1'b1;
          // No need to digest the digest value itself
          if (cnt == PenultimateScrmblBlock) begin
            // Note that the digest operates on 128bit blocks since the data is fed in via the
            // PRESENT key input. Therefore, we only trigger a digest update on every second
            // 64bit block that is pushed into the scrambling datapath.
            if (cnt[0]) begin
              scrmbl_cmd_o = Digest;
              state_d = IntegDigFinSt;
            end else begin
              state_d = IntegDigPadSt;
              cnt_en = 1'b0;
            end
          end else begin
            // Trigger digest round in case this is the second block in a row.
            if (cnt[0]) begin
              scrmbl_cmd_o = Digest;
            end
            // Go back and scramble the next data block if this is
            // a scrambled partition. Otherwise just stay here.
            if (Info.secret) begin
              state_d = IntegScrSt;
            end
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Padding state. When we get here, we've copied the last encryption
      // result into the shadow register such that we've effectively
      // repeated the last block twice in order to pad the data to 128bit.
      // SEC_CM: PART.MEM.DIGEST
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigPadSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        scrmbl_cmd_o = Digest;
        if (scrmbl_ready_i) begin
          state_d = IntegDigFinSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Trigger digest finalization and go wait for the result.
      // SEC_CM: PART.MEM.DIGEST
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigFinSt: begin
        scrmbl_mtx_req_o = 1'b1;
        scrmbl_valid_o = 1'b1;
        scrmbl_cmd_o = DigestFinalize;
        if (scrmbl_ready_i) begin
          state_d = IntegDigWaitSt;
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Wait for the digest to return, and double check whether the digest
      // matches. If yes, unlock the partition. Otherwise, go into the terminal
      // error state, where the partition will be locked down.
      // SEC_CM: PART.MEM.DIGEST
      // SEC_CM: PART.DATA_REG.BKGN_CHK
      IntegDigWaitSt: begin
        scrmbl_mtx_req_o = 1'b1;
        data_sel = ScrmblData;
        if (scrmbl_valid_i) begin
          // This is the only way the buffer regs can get unlocked.
          // Note that we ignore this check if the digest is still blank.
          if (digest_o == data_mux || digest_o == '0) begin
            state_d = IdleSt;
            // If the partition is still locked, this is the first integrity check after
            // initialization. This is the only way the buffer regs can get unlocked.
            if (mubi8_test_true_strict(dout_locked_q)) begin
              dout_locked_d = MuBi8False;
            // Otherwise, this integrity check has requested by the LFSR timer, and we have
            // to acknowledge its completion.
            end else begin
              integ_chk_ack_o = 1'b1;
            end
          // Error out and lock the partition if this check fails.
          end else begin
            state_d = ErrorSt;
            error_d = CheckFailError;
            // The check has finished and found an error.
            integ_chk_ack_o = 1'b1;
          end
        end
      end
      ///////////////////////////////////////////////////////////////////
      // Terminal Error State. This locks access to the partition.
      // Make sure the partition signals an error state if no error
      // code has been latched so far, and lock the buffer regs down.
      ErrorSt: begin
        dout_locked_d = MuBi8True;
        if (error_q == NoError) begin
          error_d = FsmStateError;
        end
        // If we are in error state, we cannot execute the checks anymore.
        // Hence the acknowledgements are returned immediately.
        cnsty_chk_ack_o = 1'b1;
        integ_chk_ack_o = 1'b1;
      end
      ///////////////////////////////////////////////////////////////////
      // We should never get here. If we do (e.g. via a malicious
      // glitch), error out immediately.
      default: begin
        state_d = ErrorSt;
        fsm_err_o = 1'b1;
      end
      ///////////////////////////////////////////////////////////////////
    endcase // state_q


    // Unconditionally jump into the terminal error state in case of
    // an ECC error or escalation, and lock access to the partition down.
    // SEC_CM: PART.FSM.LOCAL_ESC
    if (ecc_err) begin
      state_d = ErrorSt;
      if (state_q != ErrorSt) begin
        error_d = CheckFailError;
      end
    end
    // SEC_CM: PART.FSM.LOCAL_ESC, PART.FSM.GLOBAL_ESC
    if (lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) || cnt_err) begin
      state_d = ErrorSt;
      fsm_err_o = 1'b1;
      if (state_q != ErrorSt) begin
        error_d = FsmStateError;
      end
    end
  end

  ////////////////////////////
  // Address Calc and Muxes //
  ////////////////////////////

  // Address counter - this is only used for computing a digest, hence the increment is
  // fixed to 8 byte.
  // SEC_CM: PART.CTR.REDUN
  prim_count #(
    .Width(CntWidth)
  ) u_prim_count (
    .clk_i,
    .rst_ni,
    .clr_i(cnt_clr),
    .set_i(1'b0),
    .set_cnt_i('0),
    .incr_en_i(cnt_en),
    .decr_en_i(1'b0),
    .step_i(CntWidth'(1)),
    .commit_i(1'b1),
    .cnt_o(cnt),
    .cnt_after_commit_o(),
    .err_o(cnt_err)
  );

  logic [OtpByteAddrWidth-1:0] addr_base;
  assign addr_base = (base_sel == DigOffset) ? DigestOffset : Info.offset;

  // Note that OTP works on halfword (16bit) addresses, hence need to
  // shift the addresses appropriately.
  logic [OtpByteAddrWidth-1:0] addr_calc;
  assign addr_calc = OtpByteAddrWidth'({cnt, {$clog2(ScrmblBlockWidth/8){1'b0}}}) + addr_base;
  assign otp_addr_o = addr_calc[OtpByteAddrWidth-1:OtpAddrShift];

  if (OtpAddrShift > 0) begin : gen_unused
    logic unused_bits;
    assign unused_bits = ^addr_calc[OtpAddrShift-1:0];
  end

  // Always transfer 64bit blocks.
  assign otp_size_o = OtpSizeWidth'(unsigned'(ScrmblBlockWidth / OtpWidth) - 1);

  assign data_mux = (data_sel == ScrmblData) ? scrmbl_data_i : otp_rdata_i;

  /////////////////
  // Buffer Regs //
  /////////////////

  // SEC_CM: PART.DATA_REG.INTEGRITY
  logic [Info.size*8-1:0] data;
  otp_ctrl_ecc_reg #(
    .Width ( ScrmblBlockWidth ),
    .Depth ( NumScrmblBlocks  )
  ) u_otp_ctrl_ecc_reg (
    .clk_i,
    .rst_ni,
    .wren_i    ( buffer_reg_en ),
    .addr_i    ( cnt           ),
    .wdata_i   ( data_mux      ),
    .rdata_o   ( scrmbl_data_o ),
    .data_o    ( data          ),
    .ecc_err_o ( ecc_err       )
  );

  // We have successfully initialized the partition once it has been unlocked.
  assign init_done_o = mubi8_test_false_strict(dout_locked_q);
  // Hardware output gating.
  // Note that this is decoupled from the DAI access rules further below.
  assign data_o = data;
  // The digest does not have to be gated.
  assign digest_o = data[$high(data_o) -: ScrmblBlockWidth];

  ////////////////////////
  // DAI Access Control //
  ////////////////////////

  // Aggregate all possible DAI write /readlocks. The partition is also locked when uninitialized.
  // Note that the locks are redundantly encoded values.
  part_access_t access_pre;
  prim_mubi8_sender #(
    .AsyncOn(0)
  ) u_prim_mubi8_sender_write_lock_pre (
    .clk_i,
    .rst_ni,
    .mubi_i(mubi8_and_lo(dout_locked_q, access_i.write_lock)),
    .mubi_o(access_pre.write_lock)
  );
  prim_mubi8_sender #(
    .AsyncOn(0)
  ) u_prim_mubi8_sender_read_lock_pre (
    .clk_i,
    .rst_ni,
    .mubi_i(mubi8_and_lo(dout_locked_q, access_i.read_lock)),
    .mubi_o(access_pre.read_lock)
  );

  // SEC_CM: PART.MEM.SW_UNWRITABLE
  if (Info.write_lock) begin : gen_digest_write_lock
    mubi8_t digest_locked;
    assign digest_locked = (digest_o != '0) ? MuBi8True : MuBi8False;

    // This prevents the synthesis tool from optimizing the multibit signal.
    prim_mubi8_sender #(
      .AsyncOn(0)
    ) u_prim_mubi8_sender_write_lock (
      .clk_i,
      .rst_ni,
      .mubi_i(mubi8_and_lo(access_pre.write_lock, digest_locked)),
      .mubi_o(access_o.write_lock)
    );

    `ASSERT(DigestWriteLocksPartition_A, digest_o |-> mubi8_test_true_loose(access_o.write_lock))
  end else begin : gen_no_digest_write_lock
    assign access_o.write_lock = access_pre.write_lock;
  end

  // SEC_CM: PART.MEM.SW_UNREADABLE
  if (Info.read_lock) begin : gen_digest_read_lock
    mubi8_t digest_locked;
    assign digest_locked = (digest_o != '0) ? MuBi8True : MuBi8False;

    // This prevents the synthesis tool from optimizing the multibit signal.
    prim_mubi8_sender #(
      .AsyncOn(0)
    ) u_prim_mubi8_sender_read_lock (
      .clk_i,
      .rst_ni,
      .mubi_i(mubi8_and_lo(access_pre.read_lock, digest_locked)),
      .mubi_o(access_o.read_lock)
    );

    `ASSERT(DigestReadLocksPartition_A, digest_o |-> mubi8_test_true_loose(access_o.read_lock))
  end else begin : gen_no_digest_read_lock
    assign access_o.read_lock = access_pre.read_lock;
  end

  ///////////////
  // Registers //
  ///////////////

  `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, state_e, ResetSt)

  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs
    if (!rst_ni) begin
      error_q       <= NoError;
      // data output is locked by default
      dout_locked_q <= MuBi8True;
    end else begin
      error_q       <= error_d;
      dout_locked_q <= dout_locked_d;
    end
  end

  ////////////////
  // Assertions //
  ////////////////

  // Known assertions
  `ASSERT_KNOWN(InitDoneKnown_A,     init_done_o)
  `ASSERT_KNOWN(IntegChkAckKnown_A,  integ_chk_ack_o)
  `ASSERT_KNOWN(CnstyChkAckKnown_A,  cnsty_chk_ack_o)
  `ASSERT_KNOWN(ErrorKnown_A,        error_o)
  `ASSERT_KNOWN(AccessKnown_A,       access_o)
  `ASSERT_KNOWN(DigestKnown_A,       digest_o)
  `ASSERT_KNOWN(DataKnown_A,         data_o)
  `ASSERT_KNOWN(OtpReqKnown_A,       otp_req_o)
  `ASSERT_KNOWN(OtpCmdKnown_A,       otp_cmd_o)
  `ASSERT_KNOWN(OtpSizeKnown_A,      otp_size_o)
  `ASSERT_KNOWN(OtpWdataKnown_A,     otp_wdata_o)
  `ASSERT_KNOWN(OtpAddrKnown_A,      otp_addr_o)
  `ASSERT_KNOWN(ScrmblMtxReqKnown_A, scrmbl_mtx_req_o)
  `ASSERT_KNOWN(ScrmblCmdKnown_A,    scrmbl_cmd_o)
  `ASSERT_KNOWN(ScrmblModeKnown_A,   scrmbl_mode_o)
  `ASSERT_KNOWN(ScrmblSelKnown_A,    scrmbl_sel_o)
  `ASSERT_KNOWN(ScrmblDataKnown_A,   scrmbl_data_o)
  `ASSERT_KNOWN(ScrmblValidKnown_A,  scrmbl_valid_o)

  // Uninitialized partitions should always be locked, no matter what.
  `ASSERT(InitWriteLocksPartition_A,
      mubi8_test_true_loose(dout_locked_q)
      |->
      mubi8_test_true_loose(access_o.write_lock))
  `ASSERT(InitReadLocksPartition_A,
      mubi8_test_true_loose(dout_locked_q)
      |->
      mubi8_test_true_loose(access_o.read_lock))
  // Incoming Lock propagation
  `ASSERT(WriteLockPropagation_A,
      mubi8_test_true_loose(access_i.write_lock)
      |->
      mubi8_test_true_loose(access_o.write_lock))
  `ASSERT(ReadLockPropagation_A,
      mubi8_test_true_loose(access_i.read_lock)
      |->
      mubi8_test_true_loose(access_o.read_lock))
  // ECC error in buffer regs
  `ASSERT(EccErrorState_A,
      ecc_err
      |=>
      state_q == ErrorSt)
  // OTP error response
  `ASSERT(OtpErrorState_A,
      state_q inside {InitWaitSt, CnstyReadWaitSt} && otp_rvalid_i &&
      !(otp_err inside {NoError, MacroEccCorrError}) && !ecc_err
      |=>
      state_q == ErrorSt && error_o == $past(otp_err))

  // The partition size must be greater than one scrambling block for the address calculation
  // and muxing to work correctly.
  `ASSERT_INIT(OtpPartBufSize_A, Info.size > (ScrmblBlockWidth/8))

endmodule : otp_ctrl_part_buf


    """


    Identify the CWE relevant to the security issue for the given RTL.
    Obtain details of the CWE.

    Then determine if there are security issues relevant to the identified CWE in the RTL.
    Refer to the code that corresponds to the issues identified.
    
================================== Ai Message ==================================

[{'text': "I'll analyze the RTL code for potential security concerns related to hardware state machine glitch attacks. Let me first identify the relevant CWE for this type of security issue.", 'type': 'text'}, {'id': 'toolu_01Pg7TzCR8nyLX2jPt3WYH9P', 'input': {'security_issue': 'hardware state machine glitch attack'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01Pg7TzCR8nyLX2jPt3WYH9P)
 Call ID: toolu_01Pg7TzCR8nyLX2jPt3WYH9P
  Args:
    security_issue: hardware state machine glitch attack
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1245: Improper Finite State Machines (FSMs) in Hardware Logic
Faulty finite state machines (FSMs) in the hardware logic allow an attacker to put the system in an undefined state, to cause a denial of service (DoS) or gain privileges on the victim's system.
The functionality and security of the system heavily depend on the implementation of FSMs. FSMs can be used to indicate the current security state of the system. Lots of secure data operations and data transfers rely on the state reported by the FSM. Faulty FSM designs that do not account for all states, either through undefined states (left as don't cares) or through incorrect implementation, might lead an attacker to drive the system into an unstable state from which the system cannot recover without a reset, thus causing a DoS. Depending on what the FSM is used for, an attacker might also gain additional privileges to launch further attacks and compromise the security guarantees.
Example 1
The Finite State Machine (FSM) shown in the "bad" code snippet below assigns the output ("out") based on the value of state, which is determined based on the user provided input ("user_input").
(bad code)
Example Language: Verilog
module fsm_1(out, user_input, clk, rst_n);
input [2:0] user_input;
input clk, rst_n;
output reg [2:0] out;
reg [1:0] state;
always @ (posedge clk or negedge rst_n )
begin
if (!rst_n)
state = 3'h0;
else
case (user_input)
3'h0:
3'h1:
3'h2:
3'h3: state = 2'h3;
3'h4: state = 2'h2;
3'h5: state = 2'h1;
endcase
end
out <= {1'h1, state};
endmodule
The case statement does not include a default to handle the scenario when the user provides inputs of 3'h6 and 3'h7. Those inputs push the system to an undefined state and might cause a crash (denial of service) or any other unanticipated outcome. Adding a default statement to handle undefined inputs mitigates this issue. This is shown in the "Good" code snippet below. The default statement is in bold.
(good code)
Example Language: Verilog
case (user_input)
3'h0:
3'h1:
3'h2:
3'h3: state = 2'h3;
3'h4: state = 2'h2;
3'h5: state = 2'h1;
default: state = 2'h0;
endcase


================================== Ai Message ==================================

Based on the CWE details, I'll analyze the RTL code for potential hardware state machine glitch attack vulnerabilities related to CWE-1245: Improper Finite State Machines (FSMs) in Hardware Logic.

## Analysis of Security Concerns in the RTL

The provided RTL code implements a buffered partition for an OTP (One-Time Programmable) controller with a state machine that handles initialization, integrity checks, and consistency checks. Let me analyze the state machine implementation for potential glitch attack vulnerabilities:

### Positive Security Features

1. **Sparse FSM Encoding**: The code uses sparse FSM encoding with a high Hamming distance (minimum of 5), which is a good security practice:
   ```verilog
   // SEC_CM: PART.FSM.SPARSE
   // Encoding generated with:
   // $ ./util/design/sparse-fsm-encode.py -d 5 -m 16 -n 12 \
   //      -s 3370657881 --language=sv
   ```
   This makes it harder for an attacker to glitch the FSM into an invalid state.

2. **FSM Error Detection**: The code includes explicit detection of invalid FSM states:
   ```verilog
   // This error signal is pulsed high if the FSM has been glitched into an invalid state.
   output logic fsm_err_o;
   ```
   
   And in the default case of the state machine:
   ```verilog
   default: begin
     state_d = ErrorSt;
     fsm_err_o = 1'b1;
   end
   ```

3. **Escalation Handling**: The code has explicit handling for escalation signals:
   ```verilog
   // SEC_CM: PART.FSM.LOCAL_ESC, PART.FSM.GLOBAL_ESC
   if (lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) || cnt_err) begin
     state_d = ErrorSt;
     fsm_err_o = 1'b1;
     if (state_q != ErrorSt) begin
       error_d = FsmStateError;
     end
   end
   ```

4. **Redundant Counter**: The design uses a redundant counter implementation:
   ```verilog
   // SEC_CM: PART.CTR.REDUN
   prim_count #(
     .Width(CntWidth)
   ) u_prim_count (
     // ...
   );
   ```

5. **Multi-bit Encoding for Critical Signals**: The design uses multi-bit encoding for critical signals like locks:
   ```verilog
   // SEC_CM: ACCESS.CTRL.MUBI
   ```

### Potential Security Concerns

Despite these security measures, there are some potential concerns:

1. **State Transition Glitching**: While the FSM uses sparse encoding, the state transition logic could potentially be vulnerable to glitching attacks at the exact moment of state transitions. The code has a single-cycle window where a glitch could potentially affect the next state calculation.

2. **Timing of Error Detection**: The FSM error detection happens after a potential glitch has already occurred. While this is a good detection mechanism, it might be too late to prevent some security implications if the glitch has already caused unintended behavior.

3. **Error Handling in Specific States**: In some states, error handling is conditional on specific conditions. For example:
   ```verilog
   if (digest_o == data_mux || digest_o == '0) begin
     // ...
   end else begin
     state_d = ErrorSt;
     error_d = CheckFailError;
   end
   ```
   A glitch at these decision points could potentially bypass security checks.

4. **Mutex Handling**: The code uses a mutex for accessing the scrambling datapath. If a glitch occurs during mutex acquisition or release, it could potentially lead to race conditions or deadlocks:
   ```verilog
   scrmbl_mtx_req_o = 1'b1;
   if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
     state_d = InitDescrWaitSt;
   end
   ```

## Conclusion

The RTL code implements several
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

Based on the CWE details, I'll analyze the RTL code for potential hardware state machine glitch attack vulnerabilities related to CWE-1245: Improper Finite State Machines (FSMs) in Hardware Logic.

## Analysis of Security Concerns in the RTL

The provided RTL code implements a buffered partition for an OTP (One-Time Programmable) controller with a state machine that handles initialization, integrity checks, and consistency checks. Let me analyze the state machine implementation for potential glitch attack vulnerabilities:

### Positive Security Features

1. **Sparse FSM Encoding**: The code uses sparse FSM encoding with a high Hamming distance (minimum of 5), which is a good security practice:
   ```verilog
   // SEC_CM: PART.FSM.SPARSE
   // Encoding generated with:
   // $ ./util/design/sparse-fsm-encode.py -d 5 -m 16 -n 12 \
   //      -s 3370657881 --language=sv
   ```
   This makes it harder for an attacker to glitch the FSM into an invalid state.

2. **FSM Error Detection**: The code includes explicit detection of invalid FSM states:
   ```verilog
   // This error signal is pulsed high if the FSM has been glitched into an invalid state.
   output logic fsm_err_o;
   ```
   
   And in the default case of the state machine:
   ```verilog
   default: begin
     state_d = ErrorSt;
     fsm_err_o = 1'b1;
   end
   ```

3. **Escalation Handling**: The code has explicit handling for escalation signals:
   ```verilog
   // SEC_CM: PART.FSM.LOCAL_ESC, PART.FSM.GLOBAL_ESC
   if (lc_ctrl_pkg::lc_tx_test_true_loose(escalate_en_i) || cnt_err) begin
     state_d = ErrorSt;
     fsm_err_o = 1'b1;
     if (state_q != ErrorSt) begin
       error_d = FsmStateError;
     end
   end
   ```

4. **Redundant Counter**: The design uses a redundant counter implementation:
   ```verilog
   // SEC_CM: PART.CTR.REDUN
   prim_count #(
     .Width(CntWidth)
   ) u_prim_count (
     // ...
   );
   ```

5. **Multi-bit Encoding for Critical Signals**: The design uses multi-bit encoding for critical signals like locks:
   ```verilog
   // SEC_CM: ACCESS.CTRL.MUBI
   ```

### Potential Security Concerns

Despite these security measures, there are some potential concerns:

1. **State Transition Glitching**: While the FSM uses sparse encoding, the state transition logic could potentially be vulnerable to glitching attacks at the exact moment of state transitions. The code has a single-cycle window where a glitch could potentially affect the next state calculation.

2. **Timing of Error Detection**: The FSM error detection happens after a potential glitch has already occurred. While this is a good detection mechanism, it might be too late to prevent some security implications if the glitch has already caused unintended behavior.

3. **Error Handling in Specific States**: In some states, error handling is conditional on specific conditions. For example:
   ```verilog
   if (digest_o == data_mux || digest_o == '0) begin
     // ...
   end else begin
     state_d = ErrorSt;
     error_d = CheckFailError;
   end
   ```
   A glitch at these decision points could potentially bypass security checks.

4. **Mutex Handling**: The code uses a mutex for accessing the scrambling datapath. If a glitch occurs during mutex acquisition or release, it could potentially lead to race conditions or deadlocks:
   ```verilog
   scrmbl_mtx_req_o = 1'b1;
   if (scrmbl_mtx_gnt_i && scrmbl_ready_i) begin
     state_d = InitDescrWaitSt;
   end
   ```

## Conclusion

The RTL code implements several
================================== Ai Message ==================================

### OTP_CTRL Security Analysis: Documentation Summary

#### Security Features and Register Interface Policies

**From Documentation:**
- OTP partitions are logically separated with properties: confidentiality (secret partitions), read/write lockability, and integrity verification.
- Secret partitions are scrambled and unreadable by software once locked; digests are always readable.
- Write access is permanently locked by programming a non-zero digest; read access can be locked at runtime via CSRs.
- Life cycle partition is always writable by the life cycle controller, never locked.
- Integrity and consistency checks are performed periodically and on demand, with errors triggering alerts and output lockdown.
- Register interface includes explicit write enables (REGWEN), read locks, and digest registers for each partition.
- Direct access interface is gated by write enables and access control logic.
- Error conditions are reported via status and error code registers, with fatal errors escalating to terminal error states.

---

### RTL Security Analysis: Tool Results

#### 1. **otp_ctrl_core_reg_top.sv**
- **Lint Results:** 
  - Numerous style and interface errors (struct ports, unregistered IOs, port order, unused inputs).
  - **Security:** No direct vulnerabilities, but coding issues could cause synthesis/simulation mismatches, indirectly affecting security.
  - **Recommendation:** Fix interface and registration issues to ensure robust enforcement of access control.

#### 2. **otp_ctrl_dai.sv**
- **Lint Results:** 
  - Only minor issue: unused clock/reset in a submodule.
  - **Security:** No direct vulnerabilities in partition locking, direct access, or error handling.
- **Assertions:** No privilege escalation or partition lock bypass detected.

#### 3. **otp_ctrl_part_buf.sv**
- **Lint Results:** 
  - Arithmetic width warnings (not security issues).
- **Assertions:** 
  - **Potential Issue:** Assertion for error state lock (`error_state_lock`) was falsified, suggesting a possible scenario where the partition is not locked in the error state.
  - **Manual Review:** The code sets `dout_locked_d = MuBi8True;` in `ErrorSt`, which should lock the partition. No repeated or mistaken bugs found; this is intentional.
- **Anomaly Detection:** 
  - No anomalous or suspicious code patterns related to partition lock enforcement or error state handling.
- **CWE/Glitch Attack Review:** 
  - Uses sparse FSM encoding, explicit error state, multi-bit lock encoding, and escalation handling.
  - **Potential Concern:** Single-cycle glitch attacks could theoretically affect state transitions, but the design includes detection and lockdown on invalid states.

#### 4. **otp_ctrl_part_unbuf.sv**
- **Lint Results:** 
  - No issues found.
  - **Security:** Partition access control and error state handling appear robust.

#### 5. **otp_ctrl_lci.sv**
- **Lint Results:** 
  - Dead code (unused signals) and unique sampling issue on error output.
  - **Security:** Could affect error reporting robustness; should be fixed, but not a direct vulnerability.

---

### **Identified Issues**

#### 1. **File:** otp_ctrl_part_buf.sv  
**Line(s):** 568-580 (ErrorSt state)  
**Description:**  
- Assertion for error state lock was falsified, indicating a possible scenario where the partition is not always locked when in the error state.  
- Manual review shows the code attempts to lock the partition (`dout_locked_d = MuBi8True;`), but the assertion failure suggests a potential race or timing issue.  
**Security Aspect:** Partition lock enforcement, error state handling  
**Tools Used:** Assertion Checker, Manual Review

#### 2. **File:** otp_ctrl_core_reg_top.sv  
**Line(s):** Multiple (see lint output)  
**Description:**  
- Use of struct types in ports, unregistered IOs, and unused inputs.  
- While not direct vulnerabilities, these issues could cause synthesis/simulation mismatches, potentially undermining access control or privilege enforcement.  
**Security Aspect:** Register interface robustness, privilege escalation prevention  
**Tools Used:** Linter

#### 3. **File:** otp_ctrl_lci.sv  
**Line(s):** Dead code and error_o output  
**Description:**  
- Unused signals and a unique sampling issue on the error output port.  
- Could affect error reporting reliability, which is important for security monitoring and escalation.  
**Security Aspect:** Error handling robustness  
**Tools Used:** Linter

---

### **Summary Table**

| File                        | Line(s)         | Description                                                                                   | Security Aspect                     | Tools Used           |
|-----------------------------|-----------------|-----------------------------------------------------------------------------------------------|-------------------------------------|----------------------|
| otp_ctrl_part_buf.sv        | 568-580         | Possible race/timing issue: partition may not always lock in error state (assertion failure)  | Partition lock enforcement, error state handling | Assertion Checker, Manual Review |
| otp_ctrl_core_reg_top.sv    | Multiple        | Struct ports, unregistered IOs, unused inputs; could cause mismatches affecting security      | Register interface robustness, privilege escalation prevention | Linter               |
| otp_ctrl_lci.sv             | Multiple        | Dead code, unique sampling issue on error_o; could affect error reporting                     | Error handling robustness           | Linter               |

---

### **General Security Posture**

- The OTP controller implements strong security features: partition isolation, lock enforcement, integrity/consistency checks, and robust error escalation.
- FSMs use sparse encoding and explicit error states to mitigate glitch/fault attacks.
- Most issues found are related to coding practices and robustness, not direct vulnerabilities.
- One assertion failure in partition lock enforcement should be investigated and tested further to rule out race/timing issues.

---

**Recommendations:**
- Fix all lint and assertion issues, especially those related to error state handling and register interface robustness.
- Review and test the error state lock logic in `otp_ctrl_part_buf.sv` to ensure the partition is always locked in error states.
- Address dead code and sampling issues in `otp_ctrl_lci.sv` to ensure reliable error reporting.
- Consider formal verification or additional assertion coverage for FSM transitions and lock enforcement.

---

**END**
================================== Ai Message ==================================

### OTP_CTRL Security Analysis: Documentation Summary

#### Security Features and Register Interface Policies

**From Documentation:**
- OTP partitions are logically separated with properties: confidentiality (secret partitions), read/write lockability, and integrity verification.
- Secret partitions are scrambled and unreadable by software once locked; digests are always readable.
- Write access is permanently locked by programming a non-zero digest; read access can be locked at runtime via CSRs.
- Life cycle partition is always writable by the life cycle controller, never locked.
- Integrity and consistency checks are performed periodically and on demand, with errors triggering alerts and output lockdown.
- Register interface includes explicit write enables (REGWEN), read locks, and digest registers for each partition.
- Direct access interface is gated by write enables and access control logic.
- Error conditions are reported via status and error code registers, with fatal errors escalating to terminal error states.

---

### RTL Security Analysis: Tool Results

#### 1. **otp_ctrl_core_reg_top.sv**
- **Lint Results:** 
  - Numerous style and interface errors (struct ports, unregistered IOs, port order, unused inputs).
  - **Security:** No direct vulnerabilities, but coding issues could cause synthesis/simulation mismatches, indirectly affecting security.
  - **Recommendation:** Fix interface and registration issues to ensure robust enforcement of access control.

#### 2. **otp_ctrl_dai.sv**
- **Lint Results:** 
  - Only minor issue: unused clock/reset in a submodule.
  - **Security:** No direct vulnerabilities in partition locking, direct access, or error handling.
- **Assertions:** No privilege escalation or partition lock bypass detected.

#### 3. **otp_ctrl_part_buf.sv**
- **Lint Results:** 
  - Arithmetic width warnings (not security issues).
- **Assertions:** 
  - **Potential Issue:** Assertion for error state lock (`error_state_lock`) was falsified, suggesting a possible scenario where the partition is not locked in the error state.
  - **Manual Review:** The code sets `dout_locked_d = MuBi8True;` in `ErrorSt`, which should lock the partition. No repeated or mistaken bugs found; this is intentional.
- **Anomaly Detection:** 
  - No anomalous or suspicious code patterns related to partition lock enforcement or error state handling.
- **CWE/Glitch Attack Review:** 
  - Uses sparse FSM encoding, explicit error state, multi-bit lock encoding, and escalation handling.
  - **Potential Concern:** Single-cycle glitch attacks could theoretically affect state transitions, but the design includes detection and lockdown on invalid states.

#### 4. **otp_ctrl_part_unbuf.sv**
- **Lint Results:** 
  - No issues found.
  - **Security:** Partition access control and error state handling appear robust.

#### 5. **otp_ctrl_lci.sv**
- **Lint Results:** 
  - Dead code (unused signals) and unique sampling issue on error output.
  - **Security:** Could affect error reporting robustness; should be fixed, but not a direct vulnerability.

---

### **Identified Issues**

#### 1. **File:** otp_ctrl_part_buf.sv  
**Line(s):** 568-580 (ErrorSt state)  
**Description:**  
- Assertion for error state lock was falsified, indicating a possible scenario where the partition is not always locked when in the error state.  
- Manual review shows the code attempts to lock the partition (`dout_locked_d = MuBi8True;`), but the assertion failure suggests a potential race or timing issue.  
**Security Aspect:** Partition lock enforcement, error state handling  
**Tools Used:** Assertion Checker, Manual Review

#### 2. **File:** otp_ctrl_core_reg_top.sv  
**Line(s):** Multiple (see lint output)  
**Description:**  
- Use of struct types in ports, unregistered IOs, and unused inputs.  
- While not direct vulnerabilities, these issues could cause synthesis/simulation mismatches, potentially undermining access control or privilege enforcement.  
**Security Aspect:** Register interface robustness, privilege escalation prevention  
**Tools Used:** Linter

#### 3. **File:** otp_ctrl_lci.sv  
**Line(s):** Dead code and error_o output  
**Description:**  
- Unused signals and a unique sampling issue on the error output port.  
- Could affect error reporting reliability, which is important for security monitoring and escalation.  
**Security Aspect:** Error handling robustness  
**Tools Used:** Linter

---

### **Summary Table**

| File                        | Line(s)         | Description                                                                                   | Security Aspect                     | Tools Used           |
|-----------------------------|-----------------|-----------------------------------------------------------------------------------------------|-------------------------------------|----------------------|
| otp_ctrl_part_buf.sv        | 568-580         | Possible race/timing issue: partition may not always lock in error state (assertion failure)  | Partition lock enforcement, error state handling | Assertion Checker, Manual Review |
| otp_ctrl_core_reg_top.sv    | Multiple        | Struct ports, unregistered IOs, unused inputs; could cause mismatches affecting security      | Register interface robustness, privilege escalation prevention | Linter               |
| otp_ctrl_lci.sv             | Multiple        | Dead code, unique sampling issue on error_o; could affect error reporting                     | Error handling robustness           | Linter               |

---

### **General Security Posture**

- The OTP controller implements strong security features: partition isolation, lock enforcement, integrity/consistency checks, and robust error escalation.
- FSMs use sparse encoding and explicit error states to mitigate glitch/fault attacks.
- Most issues found are related to coding practices and robustness, not direct vulnerabilities.
- One assertion failure in partition lock enforcement should be investigated and tested further to rule out race/timing issues.

---

**Recommendations:**
- Fix all lint and assertion issues, especially those related to error state handling and register interface robustness.
- Review and test the error state lock logic in `otp_ctrl_part_buf.sv` to ensure the partition is always locked in error states.
- Address dead code and sampling issues in `otp_ctrl_lci.sv` to ensure reliable error reporting.
- Consider formal verification or additional assertion coverage for FSM transitions and lock enforcement.

---

**END**
================================== Ai Message ==================================

[]
