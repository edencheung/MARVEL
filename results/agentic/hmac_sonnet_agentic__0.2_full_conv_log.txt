================================ System Message ================================


    You are a supervisor agent in a multi-agent system focused on identifying hardware security vulnerabilities in RTL code. 
    Your objective is to analyze the given SoC and generate a detailed security report.

    You have access to the following tools: ['run_anomaly_detector_agent', 'run_verilator_agent', 'run_llm_cwe_checker_agent', 'run_assertions_checker_agent', 'run_linter_agent', 'run_similar_bug_agent', 'list_dir', 'read_file', 'read_file_with_line_numbers']. Each tool specializes in a specific task:

    - Verilator Agent: Runs Verilator tests on the given IP and analyzes failing test reports to detect potential security issues.
    - Assertion Agent: Takes a Verilog file, a top module name, and a security aspect to check. It generates and runs security assertions on the RTL. Failing assertions indicate potential issues that require further localization.
    - Linter Agent: Accepts a Verilog file, top module, and security focus. It selects relevant lint checks and flags design violations tied to security concerns.
    - CWE Agent: Given a Verilog file, a top module, and a security aspect, this agent maps the RTL code to relevant CWEs and detects CWE-related vulnerabilities.
    - Similar Bug Agent: Accepts a file path and a line number (where a bug was found) to locate similar patterns or recurring bugs throughout the RTL code.

    Instructions for analysis:

    - Read the documentataion to identify security features and register interfaces policies.
    - Use Verilator, Assertion, Anomaly and Linter agents to uncover initial issues in the design.
    - If a bug is detected but not localized, use the CWE Agent to further inspect the related security aspect in the surrounding RTL.
    - After detecting any bugs, use the Similar Bug Agent to scan similar files (of the same or of different IPs) for similar vulnerabilities.

    Output Format:

    - For each identified issue, report:
    - File name
    - Line number(s)
    - Brief description of the issue
    - Security aspect affected
    - Tools used to identify the issue

    When your analysis is complete, end your response with "END".
    
================================ Human Message =================================

Identify security issues in the hmac IP of the OpenTitan SoC, located at /home/XXXX-2/hackdate.

    - All IPs are located in the 'hw/ip' directory.
    - RTL code for each IP is located in its 'rtl' subdirectory, with source files having the '.sv' extension.
        - reg_top files contain the register interface for the IP.
        - control/fsm files contain the control logic for the IP.
        - core files contain the core logic for the IP.
    - Documentation files (.md) are located in the 'doc' directories of each IP.
        - theory_of_operation explains the properties of the IP and its security features.
        - registers.md files contain the register interface and its read/write access policies.
    - Ignore '.core' files; they are used by build tools and are not relevant for security analysis.

    Focus on the hmac IP and make sure to analyze it thoroughly.

    First, identify the relevant security properties and read/write policies of the register interfaces from the documentation. 
    Then, use all available tools to perform a comprehensive security analysis on the RTL code.
    
================================== Ai Message ==================================
Tool Calls:
  list_dir (call_A9va38TMYPHek3XrCn6gT9J2)
 Call ID: call_A9va38TMYPHek3XrCn6gT9J2
  Args:
    dir_path: /home/XXXX-2/hackdate/hw/ip/hmac/doc
================================= Tool Message =================================
Name: list_dir

Files in /home/XXXX-2/hackdate/hw/ip/hmac/doc:
checklist.md hmac_block_diagram.svg hmac_dataflow.svg interfaces.md message_padding.svg programmers_guide.md registers.md sha2_block_diagram.svg theory_of_operation.md

Directories in /home/XXXX-2/hackdate/hw/ip/hmac/doc:

================================== Ai Message ==================================
Tool Calls:
  read_file (call_cn5qmAd2XUsh9tPKJcbvf2j4)
 Call ID: call_cn5qmAd2XUsh9tPKJcbvf2j4
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/hmac/doc/theory_of_operation.md
================================= Tool Message =================================
Name: read_file

# Theory of Operation

## Block Diagram

![HMAC Block Diagram](../doc/hmac_block_diagram.svg)

The HMAC block diagram above shows that the HMAC core converts the secret key registers into an inner padded key and an outer padded key which are fed to the SHA-2 hash engine (which is a SHA-2 engine primitive instantiated with the multi-mode feature enabled) when appropriate.
The module also feeds the result of the first round message (which uses the inner padded key) from the SHA-2 hash engine into the 32x32b message FIFO for the second round (which uses the outer padded key).
The message length is automatically updated to reflect the size of the outer padded key and first round digest result for the second round.
See [Design Details](#design-details) for more information.

![SHA-2 Block Diagram](../doc/sha2_block_diagram.svg)

[sha256-spec]: XXXX

The SHA-2 engine block diagram shows the message scheduling FIFO array, hash registers, digest registers, and SHA-2 compression function inside SHA-2 engine.
The message scheduling FIFO is not software accessible but is fed from the 32x32b message FIFO seen in the HMAC block diagram via the HMAC core.
The HMAC core can forward the message directly from the 32x32b message FIFO if HMAC is not enabled.
The message words are padded with the message length appended to fit either the 512-bit or 1024-bit block size (depending on the configured digest size) as described in the [SHA-256
specification][sha256-spec].

With the 512-bit block (for SHA-2 256), the compression function runs 64 rounds to calculate the block hash, which is stored in the hash registers above.
After 64 rounds are completed, the SHA-2 256 updates the digest registers with the addition of the hash result and the previous digest registers.
With the 1024-bit block (for SHA-2 384/512), the compression function runs 80 rounds instead.
SHA-2 384 is a truncated version of SHA-2 512 where the last 128 bits of the final digest output are truncated to reduce the digest size to 384 bits.


## Design Details

### SHA-2 message feed and pad

A message is fed via a memory-mapped message FIFO.
Any write access to the memory-mapped window [`MSG_FIFO`](registers.md#msg_fifo) updates the message FIFO.
If the FIFO is full, the HMAC block will block any writes leading to back-pressure on the interconnect (as opposed to dropping those writes or overwriting existing FIFO contents).
It is recommended to avoid this back-pressure by not writing to the memory-mapped message FIFO when it is full.
To avoid doing so, software can read the [`STATUS.fifo_full`](registers.md#status) register.

The logic assumes the input message is little-endian.
It converts the byte order of the word right before writing to SHA-2 storage as SHA-2 treats the incoming message as big-endian.
If SW wants to convert the message byte order, SW should set [`CFG.endian_swap`](registers.md#cfg) to **1**.
The byte order of the digest registers, from [`DIGEST_0-DIGEST_15`](registers.md#digest) can be configured with [`CFG.digest_swap`](registers.md#cfg--digest_swap).

See the table below:

```
Input Msg #0: 010203h
Input Msg #1: 0405h
```

endian_swap     | 0         | 1
----------------|-----------|-----------
Push to SHA2 #0 | 03020105h | 01020304h
Push to SHA2 #1 | 00000004h | 00000005h


Small writes to [`MSG_FIFO`](registers.md#msg_fifo) are coalesced into 32-bit words by the [packer logic]({{< relref "hw/ip/prim/doc/prim_packer" >}}).
These words are fed into the internal message scheduling FIFO.
While passing writes to the packer logic, the block also counts the number of bytes that are being passed.
This computes the received message length, which is used in the HMAC and SHA-2 hash computation logic.

The SHA-2 engine computes an intermediate hash for every 512-bit or 1024-bit block depending on the configured digest size.
The message must be padded to fill the 512/1024-bit blocks.
This is done with an initial **1** bit after the actual message bits, followed by enough **0** padding bits, and then the 64/128-bit message length at the end of the block.
The number of **0** padding bits should be enough such that the full block size (512 or 1024 bits) is achieved.
The [SHA-256 specification][sha256-spec] describes this in more detail.
An example is shown below.
The padding logic handles this so software only needs to write the actual message bits into the message FIFO.

![SHA-2 Message Padding](../doc/message_padding.svg)

For example, for SHA-2 256, if the message is empty, the message length is 64-bit 0.
In this case, the padding logic gives `0x80000000` into the SHA-2 module first.
Then it sends (512 - 32 - 64)/32, 13 times of `0x00000000` for Padding `0x00`.
Lastly, it returns the message length which is 64-bit `0x00000000_00000000`.
If incomplete words are written, the packet logic appends `0x80` in the proper byte
location, such as `0xXX800000` for the message length % 4B == 1 case.
This similarly occurs for SHA-2 384/512 but with a 128-bit message length and block size of 1024 bits.

### SHA-2 computation

For SHA-2 256, the SHA-2 engine receives 16 32-bit words from the message FIFO or the HMAC core, which get padded into 16 64-bit words for the SHA-2 engine (upper 32 bits of each data word are all-zero padded), and then begin 64 rounds of the hash computation which is also called *compression*.
Alternatively for SHA-2 384/512, the SHA-2 engine receives 32 32-bit words from message FIFO, which get packed into 16 64-bit words for the SHA-2 engine, and then begin the 80 compression rounds.
In each round, the compression function fetches a 64-bit word from the buffer and computes the internal variables.
The first 16 rounds are fed by the words from the message FIFO or the HMAC core.
Input for later rounds comes from shuffling the given 512/1024-bit block.
Details are well described in [Wikipedia][sha2-wikipedia] and the [SHA-256 specification][sha256-spec].

[sha2-wikipedia]: XXXX

With the given hash values, 4-byte (or 8-byte) message word, and round constants, the compression function computes the next round hash values.
The round constants for the different digest sizes are hard-wired in the design.
After the compression at the last round is finished, the resulting hash values are added into the digest.
The digest, again, is used as initial hash values for the next block compression.
During the compression rounds, it doesn't fetch data from the message FIFO.
The software can push up to 16 (or 32 for SHA-2 384/512) entries to the FIFO for the next hash computation.

### HMAC computation

![Two steps of HMAC](../doc/hmac_dataflow.svg)

HMAC can be used with any hash algorithm but this version of HMAC IP uses SHA-2 256/384/512.
The first phase of HMAC calculates the SHA-2 hash of the inner secret key concatenated with the actual message to be authenticated.
This inner secret key is created with the 128/256/384/512/1024-bit (hashed) secret key (depending on the configured key length) and `0x36` padding to complete the corresponding block size of the configured digest size.
For example, for SHA-2 256 with 256-bit key, 512-bit inner secret key is created with the 256-bit secret key with 256-bit zero padding, XORed with 64{`0x36`}.

```verilog
    inner_pad_key = {key[255:0], 256'h0} ^ {64{8'h36}} // big-endian
```

The message length used in the SHA-2 module is calculated by the HMAC core by adding the block size to the original message length (to account for the length of `inner_pad_key`, which has been prepended to the message).

The first round digest is fed into the second round in HMAC.
The second round computes the hash of the outer secret key concatenated with the first round digest.
In case of SHA-2 256 with 256-bit key, as the digest result is 256-bit, it must be zero-padded to fit into 512-bit block size.

```verilog
    outer_pad_key = {key[255:0], 256'h0} ^ {64{8'h5c}} // big-endian
```

In the second round, the message length is a fixed 768 bits (512-bit size of outer secret key + 256-bit first round digest size).

HMAC supports a secret key of length 128/256/384/512/1024-bit, so long as the key length does not exceed the block size of the configured digest, i.e., for SHA-2 256 a maximum length of 512-bit key is supported.
The byte order of the key registers is big-endian by default, can be swapped to little endian by setting [`CFG.key_swap`](registers.md#cfg--key_swap) to 1.
To support any arbitrary key length, the software should configure the HMAC to the next largest supported key length, e.g. for an 80-bit key, HMAC should be configured with an 128-bit key length and fed with the 80-bit key.
It is also up to the software to shrink the key to the supported key length (up to 512-bit for SHA-2 256 and up to 1024-bit for SHA-2 384/512) using a hash function when setting up the HMAC.
For example, common key sizes may be 2048-bit or 4096-bit.
Software is expected to hash these into the supported key length and write the hashed result as the configured key to the HMAC IP.

### Performance in SHA-2 mode and HMAC mode

The SHA-2 256 hash algorithm computes 512 bits of data at a time.
The first 16 rounds need the actual 16 x 32-bit message and the following 48 rounds need some value derived from the message.

In these 48 rounds, the software can feed the next 16 x 32-bit message block.
But, once the FIFO gets full, the software cannot push more data until the current block is processed.
This version of the IP fetches the next 16 x 32-bit message into the internal message scheduling array only after completing the current block.
As such, it takes 80 cycles to complete a block.
The effective throughput considering this is `64 byte / 80 clk` or `16 clk / 80 clk`, 20% of the maximum throughput.
For instance, if the clock frequency is 100MHz, the SHA-2 256 can hash out 80MB/s at most.

For SHA-2 384/512, the algorithm computes 1024 bits of data a time and runs for 80 rounds where the first 16 rounds consume the actual 16 x 64-bit message.
It takes 96 cycles to complete a 1024-bit block. If the clock frequency is 100MHz, the SHA-2 384/512 can hash out 133MB/s at most.

This throughput could be enhanced in a future version by feeding the message into the internal buffer when the round hits 48, eliminating the extra 16 cycles to feed the message after completing a block.

If HMAC mode is turned on, it introduces extra latency due to the second round of computing the final hash of the outer key and the result of the first round using the inner key.
This adds an extra 240 cycles (80 for the inner key, 80 for the outer key, and 80 for the result of the first round) to complete a HMAC SHA-2 256 digest of a message.
For instance, if an empty message is given then it takes 360 cycles (80 for msg itself and 240 for the extra) to get the HMAC authentication token.

### MSG_FIFO

The MSG_FIFO in the HMAC IP has a wide address range not just one 4 byte address.
Any writes to the address range go into the single entry point of the `prim_packer`.
Then `prim_packer` compacts the data into the word-size if not a word-write then writes to the MSG_FIFO.
This is different from a conventional memory-mapped FIFO.

By having wide address range pointing to a single entry point, the FIFO can free software from the fixed address restriction.
For instance, the core can use "store multiple" commands to feed the message fifo efficiently.
Also, a DMA engine which might not have the ability to be configured to the fixed write and incremental read may benefit from this behavior.

================================== Ai Message ==================================
Tool Calls:
  read_file (call_5EDx7vSqD6NpNFND917sO8dK)
 Call ID: call_5EDx7vSqD6NpNFND917sO8dK
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/hmac/doc/registers.md
================================= Tool Message =================================
Name: read_file

# Registers

<!-- BEGIN CMDGEN util/regtool.py -d ./hw/ip/hmac/data/hmac.hjson -->
## Summary

| Name                                         | Offset   |   Length | Description                                                          |
|:---------------------------------------------|:---------|---------:|:---------------------------------------------------------------------|
| hmac.[`INTR_STATE`](#intr_state)             | 0x0      |        4 | Interrupt State Register                                             |
| hmac.[`INTR_ENABLE`](#intr_enable)           | 0x4      |        4 | Interrupt Enable Register                                            |
| hmac.[`INTR_TEST`](#intr_test)               | 0x8      |        4 | Interrupt Test Register                                              |
| hmac.[`ALERT_TEST`](#alert_test)             | 0xc      |        4 | Alert Test Register                                                  |
| hmac.[`CFG`](#cfg)                           | 0x10     |        4 | HMAC Configuration register.                                         |
| hmac.[`CMD`](#cmd)                           | 0x14     |        4 | HMAC command register                                                |
| hmac.[`STATUS`](#status)                     | 0x18     |        4 | HMAC Status register                                                 |
| hmac.[`ERR_CODE`](#err_code)                 | 0x1c     |        4 | HMAC Error Code                                                      |
| hmac.[`WIPE_SECRET`](#wipe_secret)           | 0x20     |        4 | Clear internal secret registers.                                     |
| hmac.[`KEY_0`](#key)                         | 0x24     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_1`](#key)                         | 0x28     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_2`](#key)                         | 0x2c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_3`](#key)                         | 0x30     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_4`](#key)                         | 0x34     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_5`](#key)                         | 0x38     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_6`](#key)                         | 0x3c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_7`](#key)                         | 0x40     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_8`](#key)                         | 0x44     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_9`](#key)                         | 0x48     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_10`](#key)                        | 0x4c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_11`](#key)                        | 0x50     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_12`](#key)                        | 0x54     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_13`](#key)                        | 0x58     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_14`](#key)                        | 0x5c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_15`](#key)                        | 0x60     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_16`](#key)                        | 0x64     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_17`](#key)                        | 0x68     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_18`](#key)                        | 0x6c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_19`](#key)                        | 0x70     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_20`](#key)                        | 0x74     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_21`](#key)                        | 0x78     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_22`](#key)                        | 0x7c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_23`](#key)                        | 0x80     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_24`](#key)                        | 0x84     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_25`](#key)                        | 0x88     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_26`](#key)                        | 0x8c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_27`](#key)                        | 0x90     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_28`](#key)                        | 0x94     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_29`](#key)                        | 0x98     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_30`](#key)                        | 0x9c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_31`](#key)                        | 0xa0     |        4 | HMAC Secret Key                                                      |
| hmac.[`DIGEST_0`](#digest)                   | 0xa4     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_1`](#digest)                   | 0xa8     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_2`](#digest)                   | 0xac     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_3`](#digest)                   | 0xb0     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_4`](#digest)                   | 0xb4     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_5`](#digest)                   | 0xb8     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_6`](#digest)                   | 0xbc     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_7`](#digest)                   | 0xc0     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_8`](#digest)                   | 0xc4     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_9`](#digest)                   | 0xc8     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_10`](#digest)                  | 0xcc     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_11`](#digest)                  | 0xd0     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_12`](#digest)                  | 0xd4     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_13`](#digest)                  | 0xd8     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_14`](#digest)                  | 0xdc     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_15`](#digest)                  | 0xe0     |        4 | Digest output.                                                       |
| hmac.[`MSG_LENGTH_LOWER`](#msg_length_lower) | 0xe4     |        4 | Received Message Length calculated by the HMAC in bits [31:0]        |
| hmac.[`MSG_LENGTH_UPPER`](#msg_length_upper) | 0xe8     |        4 | Received Message Length calculated by the HMAC in bits [63:32]       |
| hmac.[`MSG_FIFO`](#msg_fifo)                 | 0x1000   |     4096 | Message FIFO. Any write to this window will be appended to the FIFO. |

## INTR_STATE
Interrupt State Register
- Offset: `0x0`
- Reset default: `0x0`
- Reset mask: `0x7`

### Fields

```wavejson
{"reg": [{"name": "hmac_done", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"name": "fifo_empty", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "hmac_err", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 120}}
```

|  Bits  |  Type  |  Reset  | Name                                  |
|:------:|:------:|:-------:|:--------------------------------------|
|  31:3  |        |         | Reserved                              |
|   2    |  rw1c  |   0x0   | [hmac_err](#intr_state--hmac_err)     |
|   1    |   ro   |   0x0   | [fifo_empty](#intr_state--fifo_empty) |
|   0    |  rw1c  |   0x0   | [hmac_done](#intr_state--hmac_done)   |

### INTR_STATE . hmac_err
HMAC error has occurred. ERR_CODE register shows which error occurred.

### INTR_STATE . fifo_empty
The message FIFO is empty.
This interrupt is raised only if the message FIFO is actually writable by software, i.e., if all of the following conditions are met:
i) The HMAC block is not running in HMAC mode and performing the second round of computing the final hash of the outer key as well as the result of the first round using the inner key.
ii) Software has not yet written the Process or Stop command to finish the hashing operation.
For the interrupt to be raised, the message FIFO must also have been full previously.
Otherwise, the hardware empties the FIFO faster than software can fill it and there is no point in interrupting the software to inform it about the message FIFO being empty.

### INTR_STATE . hmac_done
HMAC/SHA-2 has completed.

## INTR_ENABLE
Interrupt Enable Register
- Offset: `0x4`
- Reset default: `0x0`
- Reset mask: `0x7`

### Fields

```wavejson
{"reg": [{"name": "hmac_done", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "fifo_empty", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "hmac_err", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 120}}
```

|  Bits  |  Type  |  Reset  | Name       | Description                                                          |
|:------:|:------:|:-------:|:-----------|:---------------------------------------------------------------------|
|  31:3  |        |         |            | Reserved                                                             |
|   2    |   rw   |   0x0   | hmac_err   | Enable interrupt when [`INTR_STATE.hmac_err`](#intr_state) is set.   |
|   1    |   rw   |   0x0   | fifo_empty | Enable interrupt when [`INTR_STATE.fifo_empty`](#intr_state) is set. |
|   0    |   rw   |   0x0   | hmac_done  | Enable interrupt when [`INTR_STATE.hmac_done`](#intr_state) is set.  |

## INTR_TEST
Interrupt Test Register
- Offset: `0x8`
- Reset default: `0x0`
- Reset mask: `0x7`

### Fields

```wavejson
{"reg": [{"name": "hmac_done", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "fifo_empty", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "hmac_err", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 120}}
```

|  Bits  |  Type  |  Reset  | Name       | Description                                                   |
|:------:|:------:|:-------:|:-----------|:--------------------------------------------------------------|
|  31:3  |        |         |            | Reserved                                                      |
|   2    |   wo   |   0x0   | hmac_err   | Write 1 to force [`INTR_STATE.hmac_err`](#intr_state) to 1.   |
|   1    |   wo   |   0x0   | fifo_empty | Write 1 to force [`INTR_STATE.fifo_empty`](#intr_state) to 1. |
|   0    |   wo   |   0x0   | hmac_done  | Write 1 to force [`INTR_STATE.hmac_done`](#intr_state) to 1.  |

## ALERT_TEST
Alert Test Register
- Offset: `0xc`
- Reset default: `0x0`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "fatal_fault", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 130}}
```

|  Bits  |  Type  |  Reset  | Name        | Description                                      |
|:------:|:------:|:-------:|:------------|:-------------------------------------------------|
|  31:1  |        |         |             | Reserved                                         |
|   0    |   wo   |   0x0   | fatal_fault | Write 1 to trigger one alert event of this kind. |

## CFG
HMAC Configuration register.

The register is updated when the engine is in Idle.
If the software updates the register while the engine computes the hash, the updated value is discarded.
- Offset: `0x10`
- Reset default: `0x4100`
- Reset mask: `0x7fff`

### Fields

```wavejson
{"reg": [{"name": "hmac_en", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "sha_en", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "endian_swap", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "digest_swap", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "key_swap", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "digest_size", "bits": 4, "attr": ["rw"], "rotate": -90}, {"name": "key_length", "bits": 6, "attr": ["rw"], "rotate": 0}, {"bits": 17}], "config": {"lanes": 1, "fontsize": 10, "vspace": 130}}
```

|  Bits  |  Type  |  Reset  | Name                             |
|:------:|:------:|:-------:|:---------------------------------|
| 31:15  |        |         | Reserved                         |
|  14:9  |   rw   |  0x20   | [key_length](#cfg--key_length)   |
|  8:5   |   rw   |   0x8   | [digest_size](#cfg--digest_size) |
|   4    |   rw   |   0x0   | [key_swap](#cfg--key_swap)       |
|   3    |   rw   |   0x0   | [digest_swap](#cfg--digest_swap) |
|   2    |   rw   |   0x0   | [endian_swap](#cfg--endian_swap) |
|   1    |   rw   |    x    | [sha_en](#cfg--sha_en)           |
|   0    |   rw   |    x    | [hmac_en](#cfg--hmac_en)         |

### CFG . key_length
Key length configuration.

This is a 6-bit one-hot encoded field to configure the key length for HMAC.
The HMAC supports key lengths of 128-bit, 256-bit, 384-bit, 512-bit and 1024-bit, as long as the key length is not greater than the block size: up to 1024-bit for SHA-2 384/512 and up to 512-bit for SHA-2 256.
The value of this register is irrelevant when only SHA-2 (not keyed HMAC) is configured.
However, for HMAC mode (`hmac_en == 1`), when HMAC is triggered to start while [`KEY_LENGTH`](#key_length) holds `Key_None` or [`KEY_LENGTH`](#key_length) holds `Key_1024` for [`DIGEST_SIZE`](#digest_size) = `SHA2_256`, starting is blocked and an error is signalled to SW.

| Value   | Name     | Description                                                                                                                                                                                                                                                                                                                                                                  |
|:--------|:---------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0x01    | Key_128  | 6'b00_0001: 128-bit secret key.                                                                                                                                                                                                                                                                                                                                              |
| 0x02    | Key_256  | 6'b00_0010: 256-bit secret key.                                                                                                                                                                                                                                                                                                                                              |
| 0x04    | Key_384  | 6'b00_0100: 384-bit secret key.                                                                                                                                                                                                                                                                                                                                              |
| 0x08    | Key_512  | 6'b00_1000: 512-bit secret key.                                                                                                                                                                                                                                                                                                                                              |
| 0x10    | Key_1024 | 6'b01_0000: 1024-bit secret key.                                                                                                                                                                                                                                                                                                                                             |
| 0x20    | Key_None | 6'b10_0000: Unsupported/invalid values and all-zero values are mapped to Key_None. With this value, when HMAC is triggered to start operation (via `hash_start` or `hash_continue`), it will be blocked from starting and an error is signalled to the SW. If only unkeyed SHA-2 is configured (`hmac_en == 0`), starting is not blocked, since this does not require a key. |

Other values are reserved.

### CFG . digest_size
Digest size configuration.

This is a 4-bit one-hot encoded field to select digest size for either HMAC or SHA-2.
Invalid/unsupported values, i.e., values that don't correspond to SHA2_256, SHA2_384, or SHA2_512, are mapped to SHA2_None.

| Value   | Name      | Description                                                                                                                                                                                                                                                    |
|:--------|:----------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0x1     | SHA2_256  | 4'b0001: SHA-2 256 digest.                                                                                                                                                                                                                                     |
| 0x2     | SHA2_384  | 4'b0010: SHA-2 384 digest.                                                                                                                                                                                                                                     |
| 0x4     | SHA2_512  | 4'b0100: SHA-2 512 digest.                                                                                                                                                                                                                                     |
| 0x8     | SHA2_None | 4'b1000: Unsupported/invalid values and all-zero values are mapped to SHA2_None. With this value, when HMAC/SHA-2 is triggered to start operation (via `hash_start` or `hash_continue`), it will be blocked from starting and an error is signalled to the SW. |

Other values are reserved.

### CFG . key_swap
Key register byte swap.

If 1 the endianness of each KEY_* register is swapped. Default value (value 0) is big endian representation of the KEY_* CSRs.

### CFG . digest_swap
Digest register byte swap.

If 1 the value in each digest output register is converted to big-endian byte order.
This setting does not affect the order of the digest output registers, [`DIGEST_0`](#digest_0) still contains the first 4 bytes of the digest.

### CFG . endian_swap
Endian swap.

If 0, each value will be added to the message in little-endian byte order.
The value is written to MSG_FIFO same to the SW writes.
If 1, then each individual multi-byte value, regardless of its alignment, written to [`MSG_FIFO`](#msg_fifo) will be added to the message in big-endian byte order.
A message written to [`MSG_FIFO`](#msg_fifo) one byte at a time will not be affected by this setting.
From a hardware perspective byte swaps are performed on a TL-UL word granularity.

### CFG . sha_en
SHA-2 enable.

 If 0, the SHA engine will not initiate compression, this is used to stop operation of the SHA-2 engine until configuration has been done.
 When the SHA-2 engine is disabled the digest is cleared.

### CFG . hmac_en
HMAC datapath enable.

If this bit is 1, HMAC operates when `hash_start` toggles.

## CMD
HMAC command register
- Offset: `0x14`
- Reset default: `0x0`
- Reset mask: `0xf`

### Fields

```wavejson
{"reg": [{"name": "hash_start", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"name": "hash_process", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"name": "hash_stop", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"name": "hash_continue", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"bits": 28}], "config": {"lanes": 1, "fontsize": 10, "vspace": 150}}
```

|  Bits  |  Type  |  Reset  | Name                                 |
|:------:|:------:|:-------:|:-------------------------------------|
|  31:4  |        |         | Reserved                             |
|   3    | r0w1c  |    x    | [hash_continue](#cmd--hash_continue) |
|   2    | r0w1c  |    x    | [hash_stop](#cmd--hash_stop)         |
|   1    | r0w1c  |    x    | [hash_process](#cmd--hash_process)   |
|   0    | r0w1c  |    x    | [hash_start](#cmd--hash_start)       |

### CMD . hash_continue
When 1 is written to this field, SHA-2 or HMAC will continue hashing based on the current hash in the digest registers and the message length, which both have to be restored to switch context.

### CMD . hash_stop
When 1 is written to this field, SHA-2 or HMAC will afterwards set the `hmac_done` interrupt as soon as the current block has been hashed.
The hash can then be read from the registers [`DIGEST_0`](#digest_0) to [`DIGEST_15.`](#digest_15)
Together with the message length in [`MSG_LENGTH_LOWER`](#msg_length_lower) and [`MSG_LENGTH_UPPER`](#msg_length_upper), this forms the information that has to be saved before switching context.

### CMD . hash_process
If 1 is written to this field, SHA-2 or HMAC calculates the digest or signing based on currently received message.

### CMD . hash_start
If 1 is written into this field, SHA-2 or HMAC begins its operation.
CPU must configure relative information first, such as the digest size, secret key and the key length.

## STATUS
HMAC Status register
- Offset: `0x18`
- Reset default: `0x3`
- Reset mask: `0x3f7`

### Fields

```wavejson
{"reg": [{"name": "hmac_idle", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "fifo_empty", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "fifo_full", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 1}, {"name": "fifo_depth", "bits": 6, "attr": ["ro"], "rotate": 0}, {"bits": 22}], "config": {"lanes": 1, "fontsize": 10, "vspace": 120}}
```

|  Bits  |  Type  |  Reset  | Name       | Description                                                                                                                                                                       |
|:------:|:------:|:-------:|:-----------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31:10  |        |         |            | Reserved                                                                                                                                                                          |
|  9:4   |   ro   |    x    | fifo_depth | FIFO entry count.                                                                                                                                                                 |
|   3    |        |         |            | Reserved                                                                                                                                                                          |
|   2    |   ro   |    x    | fifo_full  | FIFO full. Data written to the FIFO whilst it is full will cause back-pressure on the interconnect                                                                                |
|   1    |   ro   |   0x1   | fifo_empty | FIFO empty                                                                                                                                                                        |
|   0    |   ro   |   0x1   | hmac_idle  | HMAC idle status. When IDLE, the `DIGEST` and the `MSG_LENGTH_LOWER`/`MSG_LENGTH_UPPER` can be written to from SW which enables restoring context (to support context switching). |

## ERR_CODE
HMAC Error Code
- Offset: `0x1c`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "err_code", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name     | Description                                                                                                                                              |
|:------:|:------:|:-------:|:---------|:---------------------------------------------------------------------------------------------------------------------------------------------------------|
|  31:0  |   ro   |   0x0   | err_code | If an error interrupt occurs, this register has information of error cause. Please take a look at `hw/ip/prim/rtl/prim_sha2_pkg.sv:err_code_e enum type. |

## WIPE_SECRET
Clear internal secret registers.

If CPU writes a value into the register, the value is used to clear the internal variables such as the secret key, internal state machine, or hash value.
The clear secret operation overwrites the internal variables with the provided 32-bit value.
For SHA-2 384/512 that work with 64-bit words, the 32-bit value is duplicated and concatenated to generate the 64-bit value.
It is recommended to use a value extracted from an entropy source.
- Offset: `0x20`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "secret", "bits": 32, "attr": ["wo"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description   |
|:------:|:------:|:-------:|:-------|:--------------|
|  31:0  |   wo   |    x    | secret | Secret value  |

## KEY
HMAC Secret Key

HMAC using SHA-2 256/384/512 assumes any hashed secret key length up to the block size, thus capped at 1024-bit.
[`key_length`](#key_length) determines how many of these registers are relevant for the HMAC operation. Order of the secret key is:
key[1023:0] = {KEY0, KEY1, KEY2, ... , KEY31};

The registers are allowed to be updated only when the engine is in Idle state.
If the engine computes the hash, it discards any attempts to update the secret keys and report an error.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name   | Offset   |
|:-------|:---------|
| KEY_0  | 0x24     |
| KEY_1  | 0x28     |
| KEY_2  | 0x2c     |
| KEY_3  | 0x30     |
| KEY_4  | 0x34     |
| KEY_5  | 0x38     |
| KEY_6  | 0x3c     |
| KEY_7  | 0x40     |
| KEY_8  | 0x44     |
| KEY_9  | 0x48     |
| KEY_10 | 0x4c     |
| KEY_11 | 0x50     |
| KEY_12 | 0x54     |
| KEY_13 | 0x58     |
| KEY_14 | 0x5c     |
| KEY_15 | 0x60     |
| KEY_16 | 0x64     |
| KEY_17 | 0x68     |
| KEY_18 | 0x6c     |
| KEY_19 | 0x70     |
| KEY_20 | 0x74     |
| KEY_21 | 0x78     |
| KEY_22 | 0x7c     |
| KEY_23 | 0x80     |
| KEY_24 | 0x84     |
| KEY_25 | 0x88     |
| KEY_26 | 0x8c     |
| KEY_27 | 0x90     |
| KEY_28 | 0x94     |
| KEY_29 | 0x98     |
| KEY_30 | 0x9c     |
| KEY_31 | 0xa0     |


### Fields

```wavejson
{"reg": [{"name": "key", "bits": 32, "attr": ["wo"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                         |
|:------:|:------:|:-------:|:-------|:------------------------------------|
|  31:0  |   wo   |    x    | key    | 32-bit chunk of 1024-bit secret key |

## DIGEST
Digest output.

If HMAC is disabled, the register shows result of SHA-2 256/384/512.
Order of the 512-bit digest[511:0] = {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST15}.
For SHA-2 256 order of the 256-bit digest[255:0] = {DIGEST0, DIGEST1, DIGEST2, DIGEST3, DIGEST4, DIGEST5, DIGEST6, DIGEST7} and {DIGEST8 - DIGEST15} are irrelevant and should not be read out.
For SHA-2 384, {DIGEST12-DIGEST15} are truncated; they are irrelevant and should not be read out.

The digest gets cleared when `CFG.sha_en` transitions from 1 to 0.
When `STATUS.hmac_idle` is 1, these registers may be written to by software.
Outside of this window, writes can cause unpredictable behavior.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name      | Offset   |
|:----------|:---------|
| DIGEST_0  | 0xa4     |
| DIGEST_1  | 0xa8     |
| DIGEST_2  | 0xac     |
| DIGEST_3  | 0xb0     |
| DIGEST_4  | 0xb4     |
| DIGEST_5  | 0xb8     |
| DIGEST_6  | 0xbc     |
| DIGEST_7  | 0xc0     |
| DIGEST_8  | 0xc4     |
| DIGEST_9  | 0xc8     |
| DIGEST_10 | 0xcc     |
| DIGEST_11 | 0xd0     |
| DIGEST_12 | 0xd4     |
| DIGEST_13 | 0xd8     |
| DIGEST_14 | 0xdc     |
| DIGEST_15 | 0xe0     |


### Fields

```wavejson
{"reg": [{"name": "digest", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                    |
|:------:|:------:|:-------:|:-------|:-------------------------------|
|  31:0  |   rw   |    x    | digest | 32-bit chunk of 512-bit digest |

## MSG_LENGTH_LOWER
Received Message Length calculated by the HMAC in bits [31:0]

Message is byte granularity.
Lower 3 bits [2:0] are ignored.

When `STATUS.hmac_idle` is 1, this register may be written by software.
Outside of this window, writes can cause unpredictable behavior.
- Offset: `0xe4`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "v", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description           |
|:------:|:------:|:-------:|:-------|:----------------------|
|  31:0  |   rw   |    x    | v      | Message Length [31:0] |

## MSG_LENGTH_UPPER
Received Message Length calculated by the HMAC in bits [63:32]

When `STATUS.hmac_idle` is 1, this register may be written by software.
Outside of this window, writes can cause unpredictable behavior.
For SHA-2-2 256 computations, message length is 64-bit {MSG_LENGTH_UPPER, MSG_LENGTH_LOWER}.f
For SHA-2 384/512 message length is extended to 128-bit in line with [nist-fips-180-4] where the upper 64 bits get zero-padded: {32'b0, 32'b0, MSG_LENGTH_UPPER, MSG_LENGTH_LOWER}.
- Offset: `0xe8`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "v", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description            |
|:------:|:------:|:-------:|:-------|:-----------------------|
|  31:0  |   rw   |    x    | v      | Message Length [63:32] |

## MSG_FIFO
Message FIFO. Any write to this window will be appended to the FIFO.
Only the lower [1:0] bits of the address matter to writes within the window
(for correctly dealing with non 32-bit writes)

- Word Aligned Offset Range: `0x1000`to`0x1ffc`
- Size (words): `1024`
- Access: `wo`
- Byte writes are  supported.


<!-- END CMDGEN -->

================================== Ai Message ==================================
Tool Calls:
  list_dir (call_9O2vKlnsCguquOA3VOCsLzJu)
 Call ID: call_9O2vKlnsCguquOA3VOCsLzJu
  Args:
    dir_path: /home/XXXX-2/hackdate/hw/ip/hmac/rtl
================================= Tool Message =================================
Name: list_dir

Files in /home/XXXX-2/hackdate/hw/ip/hmac/rtl:
hmac.sv hmac_core.sv hmac_reg_pkg.sv hmac_reg_top.sv hmac_reg_top_assertion-inserted.sv hmac_core_assertion-inserted.sv

Directories in /home/XXXX-2/hackdate/hw/ip/hmac/rtl:

================================== Ai Message ==================================
Tool Calls:
  run_verilator_agent (call_TMa52rQSW563DGNqPQaXcDO7)
 Call ID: call_TMa52rQSW563DGNqPQaXcDO7
  Args:
    ip: hmac
================================ Human Message =================================

Run a security analysis on the hmac IP.

    Inspect the logs of failing runs and determine if there are security issues in the RTL.
    If any security issues are found, provide a detailed explanation of the issue and its location in the RTL code.
================================== Ai Message ==================================

[{'text': "I'll run the verilator tests for the hmac IP and analyze any failing tests for potential security issues.", 'type': 'text'}, {'id': 'toolu_01TFWDzN6mZW1dpdjvVRdXCZ', 'input': {'ip': 'hmac'}, 'name': 'run_verilator_tests', 'type': 'tool_use'}]
Tool Calls:
  run_verilator_tests (toolu_01TFWDzN6mZW1dpdjvVRdXCZ)
 Call ID: toolu_01TFWDzN6mZW1dpdjvVRdXCZ
  Args:
    ip: hmac
================================= Tool Message =================================
Name: run_verilator_tests

 4 processes: 4 local.
FAILED: Build did NOT complete successfully
//sw/device/lib/dif:hmac_unittest                               (cached) PASSED in 0.2s
//sw/device/silicon_creator/lib/drivers:hmac_functest_sim_qemu_rom_with_fake_keys (cached) PASSED in 3.2s
//sw/device/silicon_creator/lib/drivers:hmac_unittest           (cached) PASSED in 0.2s
//sw/device/tests:hmac_enc_idle_test_sim_qemu_rom_with_fake_keys (cached) PASSED in 3.2s
//sw/device/tests:hmac_enc_test_sim_qemu_rom_with_fake_keys     (cached) PASSED in 2.6s
//sw/device/tests:hmac_secure_wipe_test_sim_qemu_rom_with_fake_keys (cached) PASSED in 3.0s
//sw/device/tests:hmac_smoketest_sim_qemu_rom_with_fake_keys    (cached) PASSED in 3.5s
//sw/device/tests/crypto:hmac_functest_sim_qemu_rom_with_fake_keys (cached) PASSED in 2.6s
//sw/device/tests/crypto:hmac_sha256_functest_sim_qemu_rom_with_fake_keys (cached) PASSED in 3.2s
//sw/device/tests/crypto:hmac_sha384_functest_sim_qemu_rom_with_fake_keys (cached) PASSED in 3.9s
//sw/device/tests/crypto:hmac_sha512_functest_sim_qemu_rom_with_fake_keys (cached) PASSED in 3.7s
//sw/device/tests/crypto:kdf_hmac_ctr_functest_sim_qemu_rom_with_fake_keys (cached) PASSED in 3.6s
//sw/device/silicon_creator/lib/drivers:hmac_functest_sim_verilator   NO STATUS
//sw/device/tests:clkmgr_off_hmac_trans_test_silicon_creator          NO STATUS
//sw/device/tests:clkmgr_off_hmac_trans_test_sim_verilator            NO STATUS
//sw/device/tests:hmac_enc_idle_test_silicon_creator                  NO STATUS
//sw/device/tests:hmac_enc_test_silicon_creator                       NO STATUS
//sw/device/tests:hmac_enc_test_sim_verilator                         NO STATUS
//sw/device/tests:hmac_endianness_test_sim_verilator                  NO STATUS
//sw/device/tests:hmac_error_conditions_test_sim_verilator            NO STATUS
//sw/device/tests:hmac_secure_wipe_test_sim_verilator                 NO STATUS
//sw/device/tests:hmac_smoketest_silicon_creator                      NO STATUS
//sw/device/tests:hmac_smoketest_sim_verilator                        NO STATUS
//sw/device/tests/crypto:hmac_functest_sim_verilator                  NO STATUS
//sw/device/tests/crypto:hmac_multistream_functest_sim_verilator      NO STATUS
//sw/device/tests/crypto:hmac_sha256_functest_sim_verilator           NO STATUS
//sw/device/tests/crypto:hmac_sha384_functest_sim_verilator           NO STATUS
//sw/device/tests/crypto:hmac_sha512_functest_sim_verilator           NO STATUS
//sw/device/tests/crypto:kdf_hmac_ctr_functest_sim_verilator          NO STATUS
//sw/device/tests:hmac_enc_idle_test_sim_verilator              FAILED TO BUILD
//sw/device/tests:clkmgr_off_hmac_trans_test_sim_qemu_rom_with_fake_keys FAILED in 4.6s
  /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/clkmgr_off_hmac_trans_test_sim_qemu_rom_with_fake_keys/test.log
//sw/device/tests/crypto:hmac_multistream_functest_sim_qemu_rom_with_fake_keys FAILED in 3.8s
  /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/crypto/hmac_multistream_functest_sim_qemu_rom_with_fake_keys/test.log

Executed 2 out of 32 tests: 12 tests pass, 1 fails to build, 2 fail locally and 17 were skipped.
There were tests whose specified size is too big. Use the --test_verbose_timeout_warnings command line option to see which ones these are.

================================== Ai Message ==================================

[{'text': "I see that there are two failing tests and one that failed to build. Let's examine the logs of the failing tests to identify any potential security issues.", 'type': 'text'}, {'id': 'toolu_01L2N3pEanLjh9oU3wWGHvik', 'input': {'file_path': '/home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/clkmgr_off_hmac_trans_test_sim_qemu_rom_with_fake_keys/test.log'}, 'name': 'read_file_from_host', 'type': 'tool_use'}]
Tool Calls:
  read_file_from_host (toolu_01L2N3pEanLjh9oU3wWGHvik)
 Call ID: toolu_01L2N3pEanLjh9oU3wWGHvik
  Args:
    file_path: /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/clkmgr_off_hmac_trans_test_sim_qemu_rom_with_fake_keys/test.log
================================= Tool Message =================================
Name: read_file_from_host

exec ${PAGER:-/usr/bin/less} "$0" || exit 1
Executing tests from //sw/device/tests:clkmgr_off_hmac_trans_test_sim_qemu_rom_with_fake_keys
-----------------------------------------------------------------------------
Invoking test: rules/scripts/qemu_pass -display none -M ot-earlgrey -readconfig sw/device/tests/clkmgr_off_hmac_trans_test_sim_qemu_rom_with_fake_keys.ini -object ot-rom_img,id=rom,file=sw/device/silicon_creator/rom/mask_rom_sim_qemu_base.elf -drive if=pflash,file=otp_img.raw,format=raw -drive if=mtd,bus=1,file=flash_img.bin,format=raw -chardev stdio,id=serial0 -serial chardev:serial0 -icount shift=6 -global ot-rstmgr.fatal_reset=1
OpenTitan:4001-0002-01
ROM:00554d51
I00001 ottf_main.c:166] Running sw/device/tests/clkmgr_off_trans_impl.c
I00002 clkmgr_off_trans_impl.c:103] Setting bite reset for 400 us (100 cycles)
I00003 clkmgr_off_trans_impl.c:118] All other units are alive
E00004 clkmgr_off_trans_impl.c:120] Access to disabled unit should freeze and cause a reset
OpenTitan:4001-0002-01
ROM:00554d51
BFV:0152530d
LCV:2739ce73
VER:4f70656e
qemu-system-riscv32: fatal reset triggered

================================== Ai Message ==================================

[{'id': 'toolu_01Fes5D34jihnJKFh3L3DpK8', 'input': {'file_path': '/home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/crypto/hmac_multistream_functest_sim_qemu_rom_with_fake_keys/test.log'}, 'name': 'read_file_from_host', 'type': 'tool_use'}]
Tool Calls:
  read_file_from_host (toolu_01Fes5D34jihnJKFh3L3DpK8)
 Call ID: toolu_01Fes5D34jihnJKFh3L3DpK8
  Args:
    file_path: /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/bazel-out/k8-fastbuild-ST-2cc462681f62/testlogs/sw/device/tests/crypto/hmac_multistream_functest_sim_qemu_rom_with_fake_keys/test.log
================================= Tool Message =================================
Name: read_file_from_host

exec ${PAGER:-/usr/bin/less} "$0" || exit 1
Executing tests from //sw/device/tests/crypto:hmac_multistream_functest_sim_qemu_rom_with_fake_keys
-----------------------------------------------------------------------------
Invoking test: rules/scripts/qemu_pass -display none -M ot-earlgrey -readconfig sw/device/tests/crypto/hmac_multistream_functest_sim_qemu_rom_with_fake_keys.ini -object ot-rom_img,id=rom,file=sw/device/silicon_creator/rom/mask_rom_sim_qemu_base.elf -drive if=pflash,file=otp_img.raw,format=raw -drive if=mtd,bus=1,file=flash_img.bin,format=raw -chardev stdio,id=serial0 -serial chardev:serial0 -icount shift=6 -global ot-rstmgr.fatal_reset=1
OpenTitan:4001-0002-01
ROM:00554d51
I00001 ottf_main.c:166] Running sw/device/tests/crypto/hmac_multistream_functest.c
I00002 hmac_multistream_functest.c:455] Testing cryptolib SHA-2/HMAC with parallel multiple streams.
I00003 hmac_multistream_functest.c:457] Starting test run_test...
I00004 hmac_multistream_functest.c:136] Vector order = 0, original_vector_id = 0
I00005 hmac_multistream_functest.c:142] segment_count = 0, segment_idx = [0, 0, 0, 0], message_len = 297
I00006 hmac_multistream_functest.c:136] Vector order = 1, original_vector_id = 2
I00007 hmac_multistream_functest.c:142] segment_count = 0, segment_idx = [0, 0, 0, 0], message_len = 93
I00008 hmac_multistream_functest.c:136] Vector order = 2, original_vector_id = 0
I00009 hmac_multistream_functest.c:142] segment_count = 3, segment_idx = [0, 47, 92, 297], message_len = 297
I00010 hmac_multistream_functest.c:136] Vector order = 3, original_vector_id = 4
I00011 hmac_multistream_functest.c:142] segment_count = 2, segment_idx = [0, 71, 101, 166], message_len = 261
I00012 hmac_multistream_functest.c:136] Vector order = 4, original_vector_id = 3
I00013 hmac_multistream_functest.c:142] segment_count = 0, segment_idx = [0, 0, 0, 0], message_len = 606
I00014 hmac_multistream_functest.c:136] Vector order = 5, original_vector_id = 1
I00015 hmac_multistream_functest.c:142] segment_count = 0, segment_idx = [0, 0, 0, 0], message_len = 776
I00016 hmac_multistream_functest.c:136] Vector order = 6, original_vector_id = 2
I00017 hmac_multistream_functest.c:142] segment_count = 3, segment_idx = [0, 9, 14, 49], message_len = 93
I00018 hmac_multistream_functest.c:136] Vector order = 7, original_vector_id = 3
I00019 hmac_multistream_functest.c:142] segment_count = 3, segment_idx = [0, 246, 260, 404], message_len = 606
I00020 hmac_multistream_functest.c:136] Vector order = 8, original_vector_id = 4
I00021 hmac_multistream_functest.c:142] segment_count = 0, segment_idx = [0, 0, 0, 0], message_len = 261
I00022 hmac_multistream_functest.c:136] Vector order = 9, original_vector_id = 1
I00023 hmac_multistream_functest.c:142] segment_count = 4, segment_idx = [0, 372, 374, 714], message_len = 776
I00024 hmac_multistream_functest.c:136] Vector order = 10, original_vector_id = 5
I00025 hmac_multistream_functest.c:142] segment_count = 1, segment_idx = [0, 672, 693, 696], message_len = 702
I00026 hmac_multistream_functest.c:136] Vector order = 11, original_vector_id = 5
I00027 hmac_multistream_functest.c:142] segment_count = 0, segment_idx = [0, 0, 0, 0], message_len = 702
I00028 hmac_multistream_functest.c:375] Invoking oneshot HMAC for vector #0
I00029 hmac_multistream_functest.c:254] Comparing result for ./sw/device/tests/crypto/hmac_gen_single_testvector.py --seed=13 --key_len=0 --operation=SHA384 --input_msg_len=2376 <output-file>.
I00030 hmac_multistream_functest.c:375] Invoking oneshot HMAC for vector #2
I00031 hmac_multistream_functest.c:254] Comparing result for ./sw/device/tests/crypto/hmac_gen_single_testvector.py --seed=2 --key_len=0 --operation=SHA256 --input_msg_len=744 <output-file>.
I00032 hmac_multistream_functest.c:391] Initializing HMAC stream for vector #0
I00033 hmac_multistream_functest.c:391] Initializing HMAC stream for vector #4
I00034 hmac_multistream_functest.c:375] Invoking oneshot HMAC for vector #3
I00035 hmac_multistream_functest.c:254] Comparing result for ./sw/device/tests/crypto/hmac_gen_single_testvector.py --seed=3 --key_len=256 --operation=HMAC256 --input_msg_len=4848 <output-file>.
I00036 hmac_multistream_functest.c:375] Invoking oneshot HMAC for vector #1
I00037 hmac_multistream_functest.c:254] Comparing result for ./sw/device/tests/crypto/hmac_gen_single_testvector.py --seed=0 --key_len=384 --operation=HMAC384 --input_msg_len=6208 <output-file>.
I00038 hmac_multistream_functest.c:391] Initializing HMAC stream for vector #2
I00039 hmac_multistream_functest.c:391] Initializing HMAC stream for vector #3
I00040 hmac_multistream_functest.c:375] Invoking oneshot HMAC for vector #4
I00041 hmac_multistream_functest.c:254] Comparing result for ./sw/device/tests/crypto/hmac_gen_single_testvector.py --seed=5 --key_len=0 --operation=SHA512 --input_msg_len=2088 <output-file>.
I00042 hmac_multistream_functest.c:391] Initializing HMAC stream for vector #1
I00043 hmac_multistream_functest.c:391] Initializing HMAC stream for vector #5
I00044 hmac_multistream_functest.c:375] Invoking oneshot HMAC for vector #5
I00045 hmac_multistream_functest.c:254] Comparing result for ./sw/device/tests/crypto/hmac_gen_single_testvector.py --seed=20 --key_len=512 --operation=HMAC512 --input_msg_len=5616 <output-file>.
I00046 hmac_multistream_functest.c:429] Streaming segment #1 of vector #0.
I00047 hmac_multistream_functest.c:429] Streaming segment #1 of vector #4.
I00048 hmac_multistream_functest.c:429] Streaming segment #1 of vector #2.
I00049 hmac_multistream_functest.c:429] Streaming segment #1 of vector #3.
I00050 hmac_multistream_functest.c:429] Streaming segment #1 of vector #1.
I00051 hmac_multistream_functest.c:416] Streaming the last segment #1 of vector #5.
I00052 hmac_multistream_functest.c:429] Streaming segment #2 of vector #0.
I00053 hmac_multistream_functest.c:416] Streaming the last segment #2 of vector #4.
I00054 hmac_multistream_functest.c:429] Streaming segment #2 of vector #2.
I00055 hmac_multistream_functest.c:429] Streaming segment #2 of vector #3.
I00056 hmac_multistream_functest.c:429] Streaming segment #2 of vector #1.
I00057 hmac_multistream_functest.c:399] Finalizing HMAC stream for vector #5
I00058 hmac_multistream_functest.c:343] Comparing result for ./sw/device/tests/crypto/hmac_gen_single_testvector.py --seed=20 --key_len=512 --operation=HMAC512 --input_msg_len=5616 <output-file>.
I00059 hmac_multistream_functest.c:344] CHECK-fail: act_tag  unmatches current_test_vector->digest.data
I00060 hmac_multistream_functest.c:344] CHECK-fail: [0] got: 0x3fe8c10f; want: 0x4152e67e
I00061 hmac_multistream_functest.c:344] CHECK-fail: [1] got: 0xd3e40339; want: 0xab2a04f8
I00062 hmac_multistream_functest.c:344] CHECK-fail: [2] got: 0x7bafb169; want: 0xdab7eafc
I00063 hmac_multistream_functest.c:344] CHECK-fail: [3] got: 0x9a92f64d; want: 0xc0134607
I00064 hmac_multistream_functest.c:344] CHECK-fail: [4] got: 0x488ee9ba; want: 0xcffa378c
I00065 hmac_multistream_functest.c:344] CHECK-fail: [5] got: 0x80c56c4f; want: 0xddca3a1d
I00066 hmac_multistream_functest.c:344] CHECK-fail: [6] got: 0xb94980a0; want: 0x6a9e56c1
I00067 hmac_multistream_functest.c:344] CHECK-fail: [7] got: 0x5a5797ad; want: 0xf484d76d
I00068 hmac_multistream_functest.c:344] CHECK-fail: [8] got: 0x46f3f245; want: 0xcf8dcb00
I00069 hmac_multistream_functest.c:344] CHECK-fail: [9] got: 0x3795f4d9; want: 0x221f561e
I00070 hmac_multistream_functest.c:344] CHECK-fail: [10] got: 0xb02bbd74; want: 0x8c0e2edd
I00071 hmac_multistream_functest.c:344] CHECK-fail: [11] got: 0xfaa25f3c; want: 0x882062f9
I00072 hmac_multistream_functest.c:344] CHECK-fail: [12] got: 0x6e422315; want: 0xb17dd5e4
I00073 hmac_multistream_functest.c:344] CHECK-fail: [13] got: 0xb002620e; want: 0xba76e98c
I00074 hmac_multistream_functest.c:344] CHECK-fail: [14] got: 0x13b306bb; want: 0x7216e072
I00075 hmac_multistream_functest.c:344] CHECK-fail: [15] got: 0xb82bd718; want: 0x397db547
I00076 status.c:34] FAIL!

================================== Ai Message ==================================

[{'text': "Let's also look at the RTL code for the HMAC module to better understand its implementation:", 'type': 'text'}, {'id': 'toolu_01BqwPBk51hE3oBi1BjLGed1', 'input': {'dir_path': '/home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/hw/ip/hmac'}, 'name': 'list_dir_from_host', 'type': 'tool_use'}]
Tool Calls:
  list_dir_from_host (toolu_01BqwPBk51hE3oBi1BjLGed1)
 Call ID: toolu_01BqwPBk51hE3oBi1BjLGed1
  Args:
    dir_path: /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/hw/ip/hmac
================================= Tool Message =================================
Name: list_dir_from_host

BUILD
data
doc
dv
hmac.core
lint
model
README.md
rtl
syn

================================== Ai Message ==================================

[{'id': 'toolu_01EVWwmi4DdB68uKmZUH1CBs', 'input': {'dir_path': '/home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/hw/ip/hmac/rtl'}, 'name': 'list_dir_from_host', 'type': 'tool_use'}]
Tool Calls:
  list_dir_from_host (toolu_01EVWwmi4DdB68uKmZUH1CBs)
 Call ID: toolu_01EVWwmi4DdB68uKmZUH1CBs
  Args:
    dir_path: /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/hw/ip/hmac/rtl
================================= Tool Message =================================
Name: list_dir_from_host

hmac_core.sv
hmac_reg_pkg.sv
hmac_reg_top.sv
hmac.sv

================================== Ai Message ==================================

[{'text': "Let's examine the main HMAC implementation:", 'type': 'text'}, {'id': 'toolu_01JDH49jsVf16trQJiLbGD8L', 'input': {'file_path': '/home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/hw/ip/hmac/rtl/hmac.sv'}, 'name': 'read_file_from_host', 'type': 'tool_use'}]
Tool Calls:
  read_file_from_host (toolu_01JDH49jsVf16trQJiLbGD8L)
 Call ID: toolu_01JDH49jsVf16trQJiLbGD8L
  Args:
    file_path: /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/hw/ip/hmac/rtl/hmac.sv
================================= Tool Message =================================
Name: read_file_from_host

// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// HMAC/SHA-2 256/384/512

`include "prim_assert.sv"

module hmac
  import prim_sha2_pkg::*;
  import hmac_reg_pkg::*;
#(
  parameter logic [NumAlerts-1:0] AlertAsyncOn = {NumAlerts{1'b1}}
) (
  input clk_i,
  input rst_ni,

  input  tlul_pkg::tl_h2d_t tl_i,
  output tlul_pkg::tl_d2h_t tl_o,

  input  prim_alert_pkg::alert_rx_t [NumAlerts-1:0] alert_rx_i,
  output prim_alert_pkg::alert_tx_t [NumAlerts-1:0] alert_tx_o,

  output logic intr_hmac_done_o,
  output logic intr_fifo_empty_o,
  output logic intr_hmac_err_o,

  output prim_mubi_pkg::mubi4_t idle_o
);


  /////////////////////////
  // Signal declarations //
  /////////////////////////
  hmac_reg2hw_t reg2hw;
  hmac_hw2reg_t hw2reg;

  tlul_pkg::tl_h2d_t  tl_win_h2d;
  tlul_pkg::tl_d2h_t  tl_win_d2h;

  logic [1023:0] secret_key, secret_key_d;

  // Logic will support key length <= block size
  // Will default to key length = block size, if key length > block size or unsupported value
  key_length_e key_length_supplied, key_length;

  logic        wipe_secret;
  logic [31:0] wipe_v;

  logic        fifo_rvalid;
  logic        fifo_rready;
  sha_fifo32_t fifo_rdata;

  logic        fifo_wvalid, fifo_wready;
  sha_fifo32_t fifo_wdata;
  logic        fifo_full;
  logic        fifo_empty;
  logic [5:0]  fifo_depth;

  logic        msg_fifo_req;
  logic        msg_fifo_gnt;
  logic        msg_fifo_we;
  logic [31:0] msg_fifo_wdata;
  logic [31:0] msg_fifo_wmask;
  logic [31:0] msg_fifo_rdata;
  logic        msg_fifo_rvalid;
  logic [1:0]  msg_fifo_rerror;
  logic [31:0] msg_fifo_wdata_endian;
  logic [31:0] msg_fifo_wmask_endian;

  logic        packer_ready;
  logic        packer_flush_done;

  logic         reg_fifo_wvalid;
  sha_word32_t  reg_fifo_wdata;
  sha_word32_t  reg_fifo_wmask;
  logic         hmac_fifo_wsel;
  logic         hmac_fifo_wvalid;
  logic [3:0]   hmac_fifo_wdata_sel;

  logic         shaf_rvalid;
  sha_fifo32_t  shaf_rdata;
  logic         shaf_rready;

  logic        sha_en;
  logic        hmac_en;
  logic        endian_swap;
  logic        digest_swap;
  logic        key_swap;

  logic        reg_hash_start;
  logic        sha_hash_start;
  logic        reg_hash_stop;
  logic        reg_hash_continue;
  logic        sha_hash_continue;
  logic        hash_start;     // hash_start is reg_hash_start gated with extra checks
  logic        hash_continue;  // hash_continue is reg_hash_continue gated with extra checks
  logic        hash_process;   // hash_process is reg_hash_process gated with extra checks
  logic        hash_start_or_continue;
  logic        hash_done_event;
  logic        reg_hash_process;
  logic        sha_hash_process;
  logic        digest_on_blk;

  logic        reg_hash_done;
  logic        sha_hash_done;

  logic [63:0] message_length, message_length_d;
  logic [63:0] sha_message_length;

  err_code_e  err_code;
  logic       err_valid;
  logic       invalid_config; // HMAC/SHA-2 is configured with invalid digest size/key length
  logic       invalid_config_atstart;

  sha_word64_t [7:0] digest, digest_sw;
  logic [7:0]        digest_sw_we;

  digest_mode_e digest_size, digest_size_supplied;
  // this is the digest size captured into HMAC when it gets started
  digest_mode_e digest_size_started_d, digest_size_started_q;

  hmac_reg2hw_cfg_reg_t cfg_reg;
  logic                 cfg_block;   // Prevents changing config
  logic                 msg_allowed; // MSG_FIFO from software is allowed

  logic hmac_core_idle;
  logic sha_core_idle;
  logic hash_running;
  logic idle;

  ///////////////////////
  // Connect registers //
  ///////////////////////
  assign hw2reg.status.fifo_full.d  = fifo_full;
  assign hw2reg.status.fifo_empty.d = fifo_empty;
  assign hw2reg.status.fifo_depth.d = fifo_depth;
  assign hw2reg.status.hmac_idle.d  = idle;

  typedef enum logic [1:0] {
    DoneAwaitCmd,
    DoneAwaitHashDone,
    DoneAwaitMessageComplete,
    DoneAwaitHashComplete
  } done_state_e;

  done_state_e done_state_d, done_state_q;

  always_comb begin
    done_state_d    = done_state_q;
    hash_done_event = 1'b0;

    unique case (done_state_q)
      DoneAwaitCmd: begin
        if (sha_hash_process) begin
          // SHA has been told to process the message, so signal *done* when the hash is done.
          done_state_d = DoneAwaitHashDone;
        end else if (reg_hash_stop) begin
          // SHA has been told to stop, so first wait for the current message block to be complete.
          done_state_d = DoneAwaitMessageComplete;
        end
      end

      DoneAwaitHashDone: begin
        if (reg_hash_done) begin
          hash_done_event = 1'b1;
          done_state_d = DoneAwaitCmd;
        end
      end

      DoneAwaitMessageComplete: begin
        if (digest_on_blk) begin
          // Once the digest is being computed for the complete message block, wait for the hash to
          // complete.
          // TODO (issue #21710): handle incomplete message size and check against 512 or 1024
          done_state_d = DoneAwaitHashComplete;
        end
      end

      DoneAwaitHashComplete: begin
        if (!hash_running) begin
          hash_done_event = 1'b1;
          done_state_d = DoneAwaitCmd;
        end
      end

      default: ;
    endcase
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      done_state_q <= DoneAwaitCmd;
    end else begin
      done_state_q <= done_state_d;
    end
  end

  assign wipe_secret = reg2hw.wipe_secret.qe;
  assign wipe_v      = reg2hw.wipe_secret.q;

  // update secret key
  always_comb begin : update_secret_key
    secret_key_d = secret_key;
    if (wipe_secret) begin
      secret_key_d = {32{wipe_v}};
    end else if (!cfg_block) begin
      // Allow updating secret key only when the engine is in Idle.
      for (int i = 0; i < 32; i++) begin
        if (reg2hw.key[31-i].qe) begin
          // swap byte endianness per secret key word if key_swap = 1
          secret_key_d[32*i+:32] = conv_endian32(reg2hw.key[31-i].q, key_swap);
        end
      end
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) secret_key <= '0;
    else         secret_key <= secret_key_d;
  end

  for (genvar i = 0; i < 32; i++) begin : gen_key
    assign hw2reg.key[31-i].d      = '0;
  end

  // Retain the previous digest in CSRs until HMAC is actually started with a valid configuration
  always_comb begin : assign_digest_reg
    // default
    // digest SW -> HW
    digest_sw     = '0;
    digest_sw_we  = '0;
    // digest HW -> SW
    hw2reg.digest = '0;

    for (int i = 0; i < 8; i++) begin
      // digest SW -> HW (depends on digest size configured even before starting/enabling)
      // capturing the intermediate digests written by SW when restoring context into the SHA-2
      // engine before it is started
      if (digest_size == SHA2_256) begin
        // digest SW -> HW
        digest_sw[i][31:0] = conv_endian32(reg2hw.digest[i].q, digest_swap);
        digest_sw_we[i]    = reg2hw.digest[i].qe;
      end else if ((digest_size == SHA2_384) || (digest_size == SHA2_512)) begin
        // digest SW -> HW
        digest_sw[i][63:32]    = reg2hw.digest[2*i].qe ?
                                 conv_endian32(reg2hw.digest[2*i].q, digest_swap) :
                                 digest[i][63:32];
        digest_sw[i][31:0]     = reg2hw.digest[2*i+1].qe ?
                                 conv_endian32(reg2hw.digest[2*i+1].q, digest_swap) :
                                 digest[i][31:0];
        digest_sw_we[i]        = reg2hw.digest[2*i].qe | reg2hw.digest[2*i+1].qe;
      end

      // digest HW -> SW (depends on configuration that has been started)
      if (digest_size_started_q == SHA2_256) begin
        hw2reg.digest[i].d   = conv_endian32(digest[i][31:0], digest_swap);
        // replicate digest[0..7] into digest[8..15]. Digest[8...15] are irrelevant for SHA2_256,
        // but this ensures all digest CSRs are wiped out with random value (at wipe_secret)
        // across different configurations.
        hw2reg.digest[i+8].d = conv_endian32(digest[i][31:0], digest_swap);
      end else if ((digest_size_started_q == SHA2_384) || (digest_size_started_q == SHA2_512)) begin
        // digest HW -> SW
        // digest swap only within each 32-bit word of the 64-bit digest word, not digest swap
        // on the entire 64-bit digest word
        hw2reg.digest[2*i].d   = conv_endian32(digest[i][63:32], digest_swap);
        hw2reg.digest[2*i+1].d = conv_endian32(digest[i][31:0], digest_swap);
      end else begin // for SHA2_None
        // to ensure secret wiping is always passed to digest CSRs
        hw2reg.digest[i].d   = conv_endian32(digest[i][31:0], digest_swap);
        hw2reg.digest[i+8].d = conv_endian32(digest[i][31:0], digest_swap);
      end
    end
  end

  logic unused_cfg_qe;
  assign unused_cfg_qe = ^{cfg_reg.sha_en.qe,      cfg_reg.hmac_en.qe,
                           cfg_reg.endian_swap.qe, cfg_reg.digest_swap.qe,
                           cfg_reg.key_swap.qe,    cfg_reg.digest_size.qe,
                           cfg_reg.key_length.qe };

  assign sha_en               = cfg_reg.sha_en.q;
  assign hmac_en              = cfg_reg.hmac_en.q;

  assign digest_size_supplied = digest_mode_e'(cfg_reg.digest_size.q);
  always_comb begin : cast_digest_size
    digest_size = SHA2_None;

    unique case (digest_size_supplied)
      SHA2_256:  digest_size = SHA2_256;
      SHA2_384:  digest_size = SHA2_384;
      SHA2_512:  digest_size = SHA2_512;
      // unsupported digest size values are mapped to SHA2_None
      // if HMAC/SHA-2 is triggered to start with this digest size, it is blocked
      // and an error is signalled to SW
      default:   digest_size = SHA2_None;
    endcase
  end

  // Hold the previous digest size till HMAC is started with the new digest size configured
  assign digest_size_started_d = (hash_start_or_continue) ? digest_size : digest_size_started_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) digest_size_started_q <= SHA2_None;
    else         digest_size_started_q <= digest_size_started_d;
  end

  assign key_length_supplied  = key_length_e'(cfg_reg.key_length.q);
  always_comb begin : cast_key_length
    key_length = Key_None;

    unique case (key_length_supplied)
      Key_128:  key_length = Key_128;
      Key_256:  key_length = Key_256;
      Key_384:  key_length = Key_384;
      Key_512:  key_length = Key_512;
      Key_1024: key_length = Key_1024;
      // unsupported key length values are mapped to Key_None
      // if HMAC (not SHA-2) is triggered to start with this key length, it is blocked
      // and an error is signalled to SW
      default:  key_length = Key_None;
    endcase
  end

  assign endian_swap = cfg_reg.endian_swap.q;
  assign digest_swap = cfg_reg.digest_swap.q;
  assign key_swap    = cfg_reg.key_swap.q;

  assign hw2reg.cfg.hmac_en.d     = cfg_reg.hmac_en.q;
  assign hw2reg.cfg.sha_en.d      = cfg_reg.sha_en.q;
  assign hw2reg.cfg.digest_size.d = digest_mode_e'(digest_size);
  assign hw2reg.cfg.key_length.d  = key_length_e'(key_length);
  assign hw2reg.cfg.endian_swap.d = cfg_reg.endian_swap.q;
  assign hw2reg.cfg.digest_swap.d = cfg_reg.digest_swap.q;
  assign hw2reg.cfg.key_swap.d    = cfg_reg.key_swap.q;

  assign reg_hash_start    = reg2hw.cmd.hash_start.qe & reg2hw.cmd.hash_start.q;
  assign reg_hash_stop     = reg2hw.cmd.hash_stop.qe & reg2hw.cmd.hash_stop.q;
  assign reg_hash_continue = reg2hw.cmd.hash_continue.qe & reg2hw.cmd.hash_continue.q;
  assign reg_hash_process  = reg2hw.cmd.hash_process.qe & reg2hw.cmd.hash_process.q;

  // Error code register
  assign hw2reg.err_code.de = err_valid;
  assign hw2reg.err_code.d  = err_code;

  /////////////////////
  // Control signals //
  /////////////////////
  assign hash_start             = reg_hash_start    & sha_en & ~cfg_block & ~invalid_config;
  assign hash_continue          = reg_hash_continue & sha_en & ~cfg_block & ~invalid_config;
  assign hash_process           = reg_hash_process  & sha_en & cfg_block &  ~invalid_config;
  assign hash_start_or_continue = hash_start | hash_continue;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      cfg_block <= '0;
    end else if (hash_start_or_continue) begin
      cfg_block <= 1'b 1;
    end else if (reg_hash_done || reg_hash_stop) begin
      cfg_block <= 1'b 0;
    end
  end
  // Hold the configuration during the process
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      cfg_reg <= '{
        hmac_en: '{
          q: 1'b0,
          qe: 1'b0
        },
        sha_en: '{
          q: 1'b0,
          qe: 1'b0
        },
        endian_swap: '{
          q: HMAC_CFG_ENDIAN_SWAP_RESVAL,
          qe: 1'b0
        },
        digest_swap: '{
          q: HMAC_CFG_DIGEST_SWAP_RESVAL,
          qe: 1'b0
        },
        key_swap: '{
          q: HMAC_CFG_KEY_SWAP_RESVAL,
          qe: 1'b0
        },
        digest_size: '{
          q: HMAC_CFG_DIGEST_SIZE_RESVAL,
          qe: 1'b0
        },
        key_length: '{
          q: HMAC_CFG_KEY_LENGTH_RESVAL,
          qe: 1'b0
        },
        default:'0
      };
    end else if (!cfg_block && reg2hw.cfg.hmac_en.qe) begin
      cfg_reg <= reg2hw.cfg ;
    end
  end

  // Open up the MSG_FIFO from the TL-UL port when it is ready
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      msg_allowed <= '0;
    end else if (hash_start_or_continue) begin
      msg_allowed <= 1'b 1;
    end else if (packer_flush_done) begin
      msg_allowed <= 1'b 0;
    end
  end

  ////////////////
  // Interrupts //
  ////////////////

  // instantiate interrupt hardware primitive
  prim_intr_hw #(.Width(1)) intr_hw_hmac_done (
    .clk_i,
    .rst_ni,
    .event_intr_i           (hash_done_event),
    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.hmac_done.q),
    .reg2hw_intr_test_q_i   (reg2hw.intr_test.hmac_done.q),
    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.hmac_done.qe),
    .reg2hw_intr_state_q_i  (reg2hw.intr_state.hmac_done.q),
    .hw2reg_intr_state_de_o (hw2reg.intr_state.hmac_done.de),
    .hw2reg_intr_state_d_o  (hw2reg.intr_state.hmac_done.d),
    .intr_o                 (intr_hmac_done_o)
  );

  // FIFO empty interrupt
  //
  // The FIFO empty interrupt is **not useful** for software if:
  // - The HMAC block is running in HMAC mode and performing the second round of computing the
  //   final hash of the outer key as well as the result of the first round using the inner key.
  //   The FIFO is then managed entirely by the hardware.
  // - The FIFO is currently not writeable by software.
  // - Software has already written the Process command. The HMAC block will now empty the
  //   FIFO and load its content into the SHA2 core, add the padding and then perfom
  //   the final hashing operation. Software cannot append the message further.
  // - Software has written the Stop command. The HMAC block will not wait for further input from
  //   software after finishing the current block.
  //
  // The FIFO empty interrupt can be **useful** for software in particular if:
  // - The FIFO was completely full previously. However, unless the HMAC block is currently
  //   processing a block, it always empties the message FIFO faster than software can fill it up,
  //   meaning the message FIFO is empty most of the time. Note, the empty status is signaled only
  //   once after the FIFO was completely full. The FIFO needs to be full again for the empty
  //   status to be signaled again next time it's empty.
  logic status_fifo_empty, fifo_empty_gate;
  logic fifo_empty_negedge, fifo_empty_q;
  logic fifo_full_posedge, fifo_full_q;
  logic fifo_full_seen_d, fifo_full_seen_q;
  assign fifo_empty_negedge = fifo_empty_q & ~fifo_empty;
  assign fifo_full_posedge  = ~fifo_full_q & fifo_full;

  // Track whether the FIFO was full after being empty. We clear the tracking:
  // - When receiving the Start, Continue, Process or Stop command. This is to start over for the
  //   next message.
  // - When seeing a negative edge on the empty signal. This signals that software has reacted to
  //   the interrupt and is filling up the FIFO again.
  assign fifo_full_seen_d =
      reg_hash_start   || reg_hash_continue ||
      reg_hash_process || reg_hash_stop     ? 1'b 0 :
      fifo_empty_negedge                    ? 1'b 0 :
      fifo_full_posedge                     ? 1'b 1 : fifo_full_seen_q;

  // The interrupt is gated unless software is actually allowed to write the FIFO and the FIFO was
  // full before.
  assign fifo_empty_gate = ~msg_allowed || ~fifo_full_seen_q;

  assign status_fifo_empty = fifo_empty_gate ? 1'b 0 : fifo_empty;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      fifo_empty_q     <= 1'b 0;
      fifo_full_q      <= 1'b 0;
      fifo_full_seen_q <= 1'b 0;
    end else begin
      fifo_empty_q     <= fifo_empty;
      fifo_full_q      <= fifo_full;
      fifo_full_seen_q <= fifo_full_seen_d;
    end
  end

  prim_intr_hw #(
    .Width(1),
    .IntrT("Status")
  ) intr_hw_fifo_empty (
    .clk_i,
    .rst_ni,
    .event_intr_i           (status_fifo_empty),
    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.fifo_empty.q),
    .reg2hw_intr_test_q_i   (reg2hw.intr_test.fifo_empty.q),
    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.fifo_empty.qe),
    .reg2hw_intr_state_q_i  (reg2hw.intr_state.fifo_empty.q),
    .hw2reg_intr_state_de_o (hw2reg.intr_state.fifo_empty.de),
    .hw2reg_intr_state_d_o  (hw2reg.intr_state.fifo_empty.d),
    .intr_o                 (intr_fifo_empty_o)
  );
  prim_intr_hw #(.Width(1)) intr_hw_hmac_err (
    .clk_i,
    .rst_ni,
    .event_intr_i           (err_valid),
    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.hmac_err.q),
    .reg2hw_intr_test_q_i   (reg2hw.intr_test.hmac_err.q),
    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.hmac_err.qe),
    .reg2hw_intr_state_q_i  (reg2hw.intr_state.hmac_err.q),
    .hw2reg_intr_state_de_o (hw2reg.intr_state.hmac_err.de),
    .hw2reg_intr_state_d_o  (hw2reg.intr_state.hmac_err.d),
    .intr_o                 (intr_hmac_err_o)
  );

  ///////////////
  // Instances //
  ///////////////

  assign msg_fifo_rvalid = msg_fifo_req & ~msg_fifo_we;
  assign msg_fifo_rdata  = '1;  // Return all F
  assign msg_fifo_rerror = '1;  // Return error for read access
  assign msg_fifo_gnt    = msg_fifo_req & ~hmac_fifo_wsel & packer_ready;

  /////////////////////
  // Unused Signals //
  /////////////////////
  logic unused_signals;
  assign unused_signals = ^{reg_fifo_wmask[7:1],   reg_fifo_wmask[15:9],
                            reg_fifo_wmask[23:17], reg_fifo_wmask[31:25]};

  // FIFO control: from packer into message FIFO
  sha_fifo32_t reg_fifo_wentry;
  assign reg_fifo_wentry.data = conv_endian32(reg_fifo_wdata, 1'b1); // always convert
  assign reg_fifo_wentry.mask = {reg_fifo_wmask[0],  reg_fifo_wmask[8],
                                 reg_fifo_wmask[16], reg_fifo_wmask[24]};
  assign fifo_full   = ~fifo_wready;
  assign fifo_empty  = ~fifo_rvalid;
  assign fifo_wvalid = (hmac_fifo_wsel && fifo_wready) ? hmac_fifo_wvalid : reg_fifo_wvalid;

  logic index;
  always_comb begin : select_fifo_wdata
    // default when !hmac_fifo_wsel
    index      = 1'b0;
    fifo_wdata = reg_fifo_wentry;

    if (hmac_fifo_wsel) begin
      fifo_wdata = '0;
      if (digest_size == SHA2_256) begin
        // only reads out lower 32 bits of each digest word and discards upper 32-bit zero padding
        fifo_wdata = '{data: digest[hmac_fifo_wdata_sel[2:0]][31:0], mask: '1};
      end else if ((digest_size == SHA2_384) || (digest_size == SHA2_512)) begin
        // reads out first upper 32 bits then lower 32 bits of each digest word
        index = !hmac_fifo_wdata_sel[0];
        fifo_wdata = '{data: digest[hmac_fifo_wdata_sel >> 1][32*index+:32], mask: '1};
      end
    end
  end

  // Extended for 1024-bit block
  localparam int MsgFifoDepth = 32;
  prim_fifo_sync #(
    .Width   ($bits(sha_fifo32_t)),
    .Pass    (1'b1),
    .Depth   (MsgFifoDepth)
  ) u_msg_fifo (
    .clk_i,
    .rst_ni,
    .clr_i   (1'b0),

    .wvalid_i(fifo_wvalid & sha_en),
    .wready_o(fifo_wready),
    .wdata_i (fifo_wdata),

    .depth_o (fifo_depth),
    .full_o  (),

    .rvalid_o(fifo_rvalid),
    .rready_i(fifo_rready),
    .rdata_o (fifo_rdata),
    .err_o   ()
  );

  // TL ADAPTER SRAM
  tlul_adapter_sram #(
    .SramAw (9),
    .SramDw (32),
    .Outstanding (1),
    .ByteAccess  (1),
    .ErrOnRead   (1)
  ) u_tlul_adapter (
    .clk_i,
    .rst_ni,
    .tl_i                       (tl_win_h2d),
    .tl_o                       (tl_win_d2h),
    .en_ifetch_i                (prim_mubi_pkg::MuBi4False),
    .req_o                      (msg_fifo_req   ),
    .req_type_o                 (               ),
    .gnt_i                      (msg_fifo_gnt   ),
    .we_o                       (msg_fifo_we    ),
    .addr_o                     (               ), // Doesn't care the address
                                                   // other than sub-word
    .wdata_o                    (msg_fifo_wdata ),
    .wmask_o                    (msg_fifo_wmask ),
    .intg_error_o               (               ),
    .rdata_i                    (msg_fifo_rdata ),
    .rvalid_i                   (msg_fifo_rvalid),
    .rerror_i                   (msg_fifo_rerror),
    .compound_txn_in_progress_o (),
    .readback_en_i              (prim_mubi_pkg::MuBi4False),
    .readback_error_o           (),
    .wr_collision_i             (1'b0),
    .write_pending_i            (1'b0)
  );

  // TL-UL to MSG_FIFO byte write handling
  logic msg_write;

  assign msg_write = msg_fifo_req & msg_fifo_we & ~hmac_fifo_wsel & msg_allowed;

  logic [$clog2(32+1)-1:0] wmask_ones;

  always_comb begin
    wmask_ones = '0;
    for (int i = 0 ; i < 32 ; i++) begin
      wmask_ones = wmask_ones + msg_fifo_wmask[i];
    end
  end

  // Calculate written message
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) message_length <= '0;
    else         message_length <= message_length_d;
  end

  always_comb begin
    message_length_d = message_length;
    if (!cfg_block) begin
      if (reg2hw.msg_length_lower.qe) begin
        message_length_d[31:0]  = reg2hw.msg_length_lower.q;
      end
      if (reg2hw.msg_length_upper.qe) begin
        message_length_d[63:32] = reg2hw.msg_length_upper.q;
      end
    end

    if (hash_start) begin
      message_length_d = '0;
    end else if (msg_write && sha_en && packer_ready) begin
      message_length_d = message_length + 64'(wmask_ones);
    end
  end

  assign hw2reg.msg_length_upper.d = message_length[63:32];
  assign hw2reg.msg_length_lower.d = message_length[31:0];

  // Convert endian here
  //    prim_packer always packs to the right, but SHA engine assumes incoming
  //    to be big-endian, [31:24] comes first. So, the data is reverted after
  //    prim_packer before the message fifo. here to reverse if not big-endian
  //    before pushing to the packer.
  assign msg_fifo_wdata_endian = conv_endian32(msg_fifo_wdata, endian_swap);
  assign msg_fifo_wmask_endian = conv_endian32(msg_fifo_wmask, endian_swap);

  prim_packer #(
    .InW          (32),
    .OutW         (32),
    .EnProtection (1'b 0)
  ) u_packer (
    .clk_i,
    .rst_ni,

    .valid_i      (msg_write & sha_en),
    .data_i       (msg_fifo_wdata_endian),
    .mask_i       (msg_fifo_wmask_endian),
    .ready_o      (packer_ready),

    .valid_o      (reg_fifo_wvalid),
    .data_o       (reg_fifo_wdata),
    .mask_o       (reg_fifo_wmask),
    .ready_i      (fifo_wready & ~hmac_fifo_wsel),

    .flush_i      (hash_process),
    .flush_done_o (packer_flush_done), // ignore at this moment

    .err_o  () // Not used
  );

  hmac_core u_hmac (
    .clk_i,
    .rst_ni,
    .secret_key_i  (secret_key),
    .hmac_en_i     (hmac_en),
    .digest_size_i (digest_size),
    .key_length_i  (key_length),

    .reg_hash_start_i    (hash_start),
    .reg_hash_stop_i     (reg_hash_stop),
    .reg_hash_continue_i (hash_continue),
    .reg_hash_process_i  (packer_flush_done), // Trigger after all msg written
    .hash_done_o         (reg_hash_done),
    .sha_hash_start_o    (sha_hash_start),
    .sha_hash_continue_o (sha_hash_continue),
    .sha_hash_process_o  (sha_hash_process),
    .sha_hash_done_i     (sha_hash_done),

    .sha_rvalid_o     (shaf_rvalid),
    .sha_rdata_o      (shaf_rdata),
    .sha_rready_i     (shaf_rready),

    .fifo_rvalid_i (fifo_rvalid),
    .fifo_rdata_i  (fifo_rdata),
    .fifo_rready_o (fifo_rready),

    .fifo_wsel_o      (hmac_fifo_wsel),
    .fifo_wvalid_o    (hmac_fifo_wvalid),
    .fifo_wdata_sel_o (hmac_fifo_wdata_sel),
    .fifo_wready_i    (fifo_wready),

    .message_length_i     (message_length),
    .sha_message_length_o (sha_message_length),

    .idle_o           (hmac_core_idle)
  );

  // Instantiate SHA-2 256/384/512 engine
  prim_sha2_32 #(
      .MultimodeEn(1)
  ) u_prim_sha2_512 (
    .clk_i,
    .rst_ni,
    .wipe_secret_i        (wipe_secret),
    .wipe_v_i             (wipe_v),
    .fifo_rvalid_i        (shaf_rvalid),
    .fifo_rdata_i         (shaf_rdata),
    .fifo_rready_o        (shaf_rready),
    .sha_en_i             (sha_en),
    .hash_start_i         (sha_hash_start),
    .hash_stop_i          (reg_hash_stop),
    .hash_continue_i      (sha_hash_continue),
    .digest_mode_i        (digest_size),
    .hash_process_i       (sha_hash_process),
    .message_length_i     (sha_message_length),
    .digest_i             (digest_sw),
    .digest_we_i          (digest_sw_we),
    .digest_o             (digest),
    .hash_running_o       (hash_running),
    .digest_on_blk_o      (digest_on_blk),
    .hash_done_o          (sha_hash_done),
    .idle_o               (sha_core_idle)
  );

  // Register top
  logic [NumAlerts-1:0] alert_test, alerts;
  hmac_reg_top u_reg (
    .clk_i,
    .rst_ni,

    .tl_i,
    .tl_o,

    .tl_win_o   (tl_win_h2d),
    .tl_win_i   (tl_win_d2h),

    .reg2hw,
    .hw2reg,

    // SEC_CM: BUS.INTEGRITY
    .intg_err_o (alerts[0])
  );

  // Alerts
  assign alert_test = {
    reg2hw.alert_test.q &
    reg2hw.alert_test.qe
  };

  localparam logic [NumAlerts-1:0] AlertIsFatal = {1'b1};
  for (genvar i = 0; i < NumAlerts; i++) begin : gen_alert_tx
    prim_alert_sender #(
      .AsyncOn(AlertAsyncOn[i]),
      .IsFatal(AlertIsFatal[i])
    ) u_prim_alert_sender (
      .clk_i,
      .rst_ni,
      .alert_test_i  ( alert_test[i] ),
      .alert_req_i   ( alerts[0]     ),
      .alert_ack_o   (               ),
      .alert_state_o (               ),
      .alert_rx_i    ( alert_rx_i[i] ),
      .alert_tx_o    ( alert_tx_o[i] )
    );
  end

  /////////////////////////
  // HMAC Error Handling //
  /////////////////////////
  logic hash_start_sha_disabled, update_seckey_inprocess;
  logic hash_start_active;  // `reg_hash_start` or `reg_hash_continue` set when hash already active
  logic msg_push_not_allowed; // Message is received when `hash_start_or_continue` isn't set

  assign hash_start_sha_disabled = (reg_hash_start | reg_hash_continue) & ~sha_en;
  assign hash_start_active = (reg_hash_start | reg_hash_continue) & cfg_block;
  assign msg_push_not_allowed = msg_fifo_req & ~msg_allowed;

  // Invalid/unconfigured HMAC/SHA-2: not configured/invalid digest size or
  // not configured/invalid key length for HMAC mode or
  // key_length = 1024-bit for digest_size = SHA2_256 (max 512-bit is supported for SHA-2 256)
  assign invalid_config = ((digest_size == SHA2_None)            |
                           ((key_length == Key_None) && hmac_en) |
                           ((key_length == Key_1024) && (digest_size == SHA2_256) && hmac_en));

  // invalid_config at reg_hash_start or reg_hash_continue will signal an error to the SW
  assign invalid_config_atstart = (reg_hash_start || reg_hash_continue) & invalid_config;

  always_comb begin
    update_seckey_inprocess = 1'b0;
    if (cfg_block) begin
      for (int i = 0 ; i < 32 ; i++) begin
        if (reg2hw.key[i].qe) begin
          update_seckey_inprocess = update_seckey_inprocess | 1'b1;
        end
      end
    end else begin
      update_seckey_inprocess = 1'b0;
    end
  end

  // Update ERR_CODE register and interrupt only when no pending interrupt.
  // This ensures only the first event of the series of events can be seen to sw.
  // It is recommended that the software reads ERR_CODE register when interrupt
  // is pending to avoid any race conditions.
  assign err_valid = ~reg2hw.intr_state.hmac_err.q &
                   ( hash_start_sha_disabled | update_seckey_inprocess
                   | hash_start_active | msg_push_not_allowed | invalid_config_atstart);

  always_comb begin
    // default
    err_code = NoError;

    priority case (1'b1)

      hash_start_sha_disabled: begin
        err_code = SwHashStartWhenShaDisabled;
      end

      hash_start_active: begin
        err_code = SwHashStartWhenActive;
      end

      msg_push_not_allowed: begin
        err_code = SwPushMsgWhenDisallowed;
      end

      update_seckey_inprocess: begin
        err_code = SwUpdateSecretKeyInProcess;
      end

      invalid_config_atstart: begin
        err_code = SwInvalidConfig;
      end

        
      default: begin
        err_code = NoError;
      end
    endcase
  end

  /////////////////////
  // Idle output     //
  /////////////////////
  // TBD this should be connected later
  // Idle: AND condition of:
  //  - packer empty: Currently no way to guarantee the packer is empty.
  //    temporary, the logic uses packer output (reg_fifo_wvalid)
  //  - MSG_FIFO  --> fifo_rvalid
  //  - HMAC_CORE --> hmac_core_idle
  //  - SHA2_CORE --> sha_core_idle
  //  - Clean interrupt status
  // ICEBOX(#12958): Revise prim_packer and replace `reg_fifo_wvalid` to the
  // empty status.
  assign idle = !reg_fifo_wvalid && !fifo_rvalid
              && hmac_core_idle && sha_core_idle;

  prim_mubi_pkg::mubi4_t idle_q, idle_d;
  assign idle_d = prim_mubi_pkg::mubi4_bool_to_mubi(idle);
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      idle_q <= prim_mubi_pkg::MuBi4False;
    end else begin
      idle_q <= idle_d;
    end
  end
  assign idle_o = idle_q;

  //////////////////////////////////////////////
  // Assertions, Assumptions, and Coverpoints //
  //////////////////////////////////////////////

`ifndef VERILATOR
`ifndef SYNTHESIS
  // HMAC assumes TL-UL mask is byte-aligned.
  property wmask_bytealign_p(wmask_byte, clk, rst_n);
    @(posedge clk) disable iff (rst_n == 0)
      msg_fifo_req & msg_fifo_we |-> wmask_byte inside {'0, '1};
  endproperty

  for (genvar i = 0 ; i < 4; i++) begin: gen_assert_wmask_bytealign
    assert property (wmask_bytealign_p(msg_fifo_wmask[8*i+:8], clk_i, rst_ni));
  end

  // To pass FPV, this shouldn't add pragma translate_off even these two signals
  // are used in Assertion only
  logic in_process;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni)                              in_process <= 1'b0;
    else if (hash_process || reg_hash_stop)   in_process <= 1'b1;
    else if (reg_hash_done)                   in_process <= 1'b0;
  end

  logic initiated;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni)                              initiated <= 1'b0;
    else if (hash_start_or_continue)          initiated <= 1'b1;
    else if (hash_process || reg_hash_stop)   initiated <= 1'b0;
  end

  // the host doesn't write data after hash_process until hash_start_or_continue.
  `ASSERT(ValidWriteAssert, msg_fifo_req |-> !in_process)

  // Below condition is covered by the design (2020-02-19)
  //`ASSERT(ValidHashStartAssert, hash_start_or_continue |-> !initiated)
  // `hash_process` or `reg_hash_stop` should be toggled and paired with `hash_start_or_continue`
  `ASSERT(ValidHashProcessAssert, (hash_process || reg_hash_stop) |-> initiated)

  // hmac_en should be modified only when the logic is Idle
  `ASSERT(ValidHmacEnConditionAssert,
          hmac_en != $past(hmac_en) |-> !in_process && !initiated)

  // All outputs should be known value after reset
  `ASSERT_KNOWN(IntrHmacDoneOKnown, intr_hmac_done_o)
  `ASSERT_KNOWN(IntrFifoEmptyOKnown, intr_fifo_empty_o)
  `ASSERT_KNOWN(TlODValidKnown, tl_o.d_valid)
  `ASSERT_KNOWN(TlOAReadyKnown, tl_o.a_ready)
  `ASSERT_KNOWN(AlertKnownO_A, alert_tx_o)

`endif // SYNTHESIS
`endif // VERILATOR

  // Alert assertions for reg_we onehot check
  `ASSERT_PRIM_REG_WE_ONEHOT_ERROR_TRIGGER_ALERT(RegWeOnehotCheck_A, u_reg, alert_tx_o[0])
endmodule

================================== Ai Message ==================================

[{'text': "Let's also look at the HMAC core implementation:", 'type': 'text'}, {'id': 'toolu_01VpETHS12x6STthdgqCBidm', 'input': {'file_path': '/home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/hw/ip/hmac/rtl/hmac_core.sv'}, 'name': 'read_file_from_host', 'type': 'tool_use'}]
Tool Calls:
  read_file_from_host (toolu_01VpETHS12x6STthdgqCBidm)
 Call ID: toolu_01VpETHS12x6STthdgqCBidm
  Args:
    file_path: /home/XXXX-2/.cache/bazel/_bazel_lc4976/50e2dba05a413b1e0aeb5a26c36978ab/execroot/lowrisc_opentitan/hw/ip/hmac/rtl/hmac_core.sv
================================= Tool Message =================================
Name: read_file_from_host

// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// HMAC Core implementation

module hmac_core import prim_sha2_pkg::*; (
  input clk_i,
  input rst_ni,

  input [1023:0]      secret_key_i, // {word0, word1, ..., word7}
  input               hmac_en_i,
  input digest_mode_e digest_size_i,
  input key_length_e  key_length_i,

  input        reg_hash_start_i,
  input        reg_hash_stop_i,
  input        reg_hash_continue_i,
  input        reg_hash_process_i,
  output logic hash_done_o,
  output logic sha_hash_start_o,
  output logic sha_hash_continue_o,
  output logic sha_hash_process_o,
  input        sha_hash_done_i,

  // fifo
  output logic        sha_rvalid_o,
  output sha_fifo32_t sha_rdata_o,
  input               sha_rready_i,

  input               fifo_rvalid_i,
  input  sha_fifo32_t fifo_rdata_i,
  output logic        fifo_rready_o,

  // fifo control (select and fifo write data)
  output logic       fifo_wsel_o,      // 0: from reg, 1: from digest
  output logic       fifo_wvalid_o,
  // 0: digest[0][upper], 1:digest[0][lower] .. 14: digest[7][upper], 15: digest[7][lower]
  output logic [3:0] fifo_wdata_sel_o,
  input              fifo_wready_i,

  input  [63:0] message_length_i,
  output [63:0] sha_message_length_o,

  output logic idle_o
);

  localparam int unsigned BlockSizeSHA256     = 512;
  localparam int unsigned BlockSizeSHA512     = 1024;

  localparam int unsigned BlockSizeBitsSHA256 = $clog2(BlockSizeSHA256);
  localparam int unsigned BlockSizeBitsSHA512 = $clog2(BlockSizeSHA512);

  localparam int unsigned HashWordBitsSHA256  = $clog2($bits(sha_word32_t));

  localparam bit [63:0] BlockSizeSHA256in64  = 64'(BlockSizeSHA256);
  localparam bit [63:0] BlockSizeSHA512in64  = 64'(BlockSizeSHA512);

  logic hash_start;    // generated from internal state machine
  logic hash_continue; // generated from internal state machine
  logic hash_process;  // generated from internal state machine to trigger hash
  logic hmac_hash_done;

  logic [BlockSizeSHA256-1:0] i_pad_256;
  logic [BlockSizeSHA512-1:0] i_pad_512;
  logic [BlockSizeSHA256-1:0] o_pad_256;
  logic [BlockSizeSHA512-1:0] o_pad_512;

  logic [63:0] txcount, txcount_d; // works for both digest lengths

  logic [BlockSizeBitsSHA512-HashWordBitsSHA256-1:0] pad_index_512;
  logic [BlockSizeBitsSHA256-HashWordBitsSHA256-1:0] pad_index_256;
  logic clr_txcount, load_txcount, inc_txcount;

  logic hmac_sha_rvalid;

  logic idle_d, idle_q;
  logic reg_hash_stop_d, reg_hash_stop_q;

  typedef enum logic [1:0] {
    SelIPad,
    SelOPad,
    SelFifo
  } sel_rdata_t;

  sel_rdata_t sel_rdata;

  typedef enum logic {
    SelIPadMsg,
    SelOPadMsg
  } sel_msglen_t;

  sel_msglen_t sel_msglen;

  typedef enum logic {
    Inner,  // Update when state goes to StIPad
    Outer   // Update when state enters StOPad
  } round_t ;

  logic update_round ;
  round_t round_q, round_d;

  typedef enum logic [2:0] {
    StIdle,
    StIPad,
    StMsg,              // Actual Msg, and Digest both
    StPushToMsgFifo,    // Digest --> Msg Fifo
    StWaitResp,         // Hash done( by checking processed_length? or hash_done)
    StOPad,
    StDone              // hmac_done
  } st_e ;

  st_e st_q, st_d;

  logic clr_fifo_wdata_sel;
  logic txcnt_eq_blksz;

  logic reg_hash_process_flag;

  assign sha_hash_start_o    = (hmac_en_i) ? hash_start    : reg_hash_start_i;
  assign sha_hash_continue_o = (hmac_en_i) ? hash_continue : reg_hash_continue_i;

  assign sha_hash_process_o  = (hmac_en_i) ? reg_hash_process_i | hash_process : reg_hash_process_i;
  assign hash_done_o         = (hmac_en_i) ? hmac_hash_done                    : sha_hash_done_i;

  assign pad_index_512 = txcount[BlockSizeBitsSHA512-1:HashWordBitsSHA256];
  assign pad_index_256 = txcount[BlockSizeBitsSHA256-1:HashWordBitsSHA256];

  // adjust inner and outer padding depending on key length and block size
  always_comb begin : adjust_key_pad_length
    // set defaults
    i_pad_256 = '{default: '0};
    i_pad_512 = '{default: '0};
    o_pad_256 = '{default: '0};
    o_pad_512 = '{default: '0};

    unique case (key_length_i)
      Key_128: begin
        i_pad_256 = {secret_key_i[1023:896],
                    {(BlockSizeSHA256-128){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
        i_pad_512 = {secret_key_i[1023:896],
                    {(BlockSizeSHA512-128){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
        o_pad_256 = {secret_key_i[1023:896],
                    {(BlockSizeSHA256-128){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
        o_pad_512 = {secret_key_i[1023:896],
                    {(BlockSizeSHA512-128){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      Key_256: begin
        i_pad_256 = {secret_key_i[1023:768],
                    {(BlockSizeSHA256-256){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
        i_pad_512 = {secret_key_i[1023:768],
                    {(BlockSizeSHA512-256){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
        o_pad_256 = {secret_key_i[1023:768],
                    {(BlockSizeSHA256-256){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
        o_pad_512 = {secret_key_i[1023:768],
                    {(BlockSizeSHA512-256){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      Key_384: begin
        i_pad_256 = {secret_key_i[1023:640],
                    {(BlockSizeSHA256-384){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
        i_pad_512 = {secret_key_i[1023:640],
                    {(BlockSizeSHA512-384){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
        o_pad_256 = {secret_key_i[1023:640],
                    {(BlockSizeSHA256-384){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
        o_pad_512 = {secret_key_i[1023:640],
                    {(BlockSizeSHA512-384){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      Key_512: begin
        i_pad_256 = secret_key_i[1023:512] ^ {(BlockSizeSHA256/8){8'h36}};
        i_pad_512 = {secret_key_i[1023:512],
                    {(BlockSizeSHA512-512){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
        o_pad_256 = secret_key_i[1023:512] ^ {(BlockSizeSHA256/8){8'h5c}};
        o_pad_512 = {secret_key_i[1023:512],
                    {(BlockSizeSHA512-512){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      Key_1024: begin // not allowed to be configured for SHA-2 256
        // zero out for SHA-2 256
        i_pad_256 = '{default: '0};
        i_pad_512 = secret_key_i[1023:0]   ^ {(BlockSizeSHA512/8){8'h36}};
        // zero out for SHA-2 256
        o_pad_256 = '{default: '0};
        o_pad_512 = secret_key_i[1023:0]   ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      default: begin
      end
    endcase
  end

  assign fifo_rready_o = (hmac_en_i) ? (st_q == StMsg) & sha_rready_i : sha_rready_i ;
  // sha_rvalid is controlled by State Machine below.
  assign sha_rvalid_o  = (!hmac_en_i) ? fifo_rvalid_i : hmac_sha_rvalid ;
  assign sha_rdata_o =
    (!hmac_en_i)    ? fifo_rdata_i                                                             :
    (sel_rdata == SelIPad && digest_size_i == SHA2_256)
                  ? '{data: i_pad_256[(BlockSizeSHA256-1)-32*pad_index_256-:32], mask: '1} :
    (sel_rdata == SelIPad && ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)))
                  ? '{data: i_pad_512[(BlockSizeSHA512-1)-32*pad_index_512-:32], mask: '1} :
    (sel_rdata == SelOPad && digest_size_i == SHA2_256)
                  ? '{data: o_pad_256[(BlockSizeSHA256-1)-32*pad_index_256-:32], mask: '1} :
    (sel_rdata == SelOPad && ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)))
                  ? '{data: o_pad_512[(BlockSizeSHA512-1)-32*pad_index_512-:32], mask: '1} :
    (sel_rdata == SelFifo) ? fifo_rdata_i                                                    :
                  '{default: '0};

  logic [63:0] sha_msg_len;

  always_comb begin: assign_sha_message_length
    sha_msg_len = '0;
    if (!hmac_en_i) begin
      sha_msg_len = message_length_i;
    // HASH = (o_pad || HASH_INTERMEDIATE (i_pad || msg))
    // message length for HASH_INTERMEDIATE = block size (i_pad) + message length
    end else if (sel_msglen == SelIPadMsg) begin
      if (digest_size_i == SHA2_256) begin
        sha_msg_len = message_length_i + BlockSizeSHA256in64;
      end else if ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)) begin
        sha_msg_len = message_length_i + BlockSizeSHA512in64;
      end
    end else if (sel_msglen == SelOPadMsg) begin
    // message length for HASH = block size (o_pad) + HASH_INTERMEDIATE digest length
      if (digest_size_i == SHA2_256) begin
        sha_msg_len = BlockSizeSHA256in64 + 64'd256;
      end else if (digest_size_i == SHA2_384) begin
        sha_msg_len = BlockSizeSHA512in64 + 64'd384;
      end else if (digest_size_i == SHA2_512) begin
        sha_msg_len = BlockSizeSHA512in64 + 64'd512;
      end
    end else
      sha_msg_len = '0;
  end

  assign sha_message_length_o = sha_msg_len;

  always_comb begin
    txcnt_eq_blksz = '0;

    unique case (digest_size_i)
      SHA2_256: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA256-1:0] == '0) && (txcount != '0);
      SHA2_384: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA512-1:0] == '0) && (txcount != '0);
      SHA2_512: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA512-1:0] == '0) && (txcount != '0);
      default;
    endcase
  end

  assign inc_txcount = sha_rready_i && sha_rvalid_o;

  // txcount
  //    Looks like txcount can be removed entirely here in hmac_core
  //    In the first round (InnerPaddedKey), it can just watch process and hash_done
  //    In the second round, it only needs count 256 bits for hash digest to trigger
  //    hash_process to SHA2
  always_comb begin
    txcount_d = txcount;
    if (clr_txcount) begin
      txcount_d = '0;
    end else if (load_txcount) begin
      // When loading, add block size to the message length because the SW-visible message length
      // does not include the block containing the key xor'ed with the inner pad.
      unique case (digest_size_i)
        SHA2_256: txcount_d = message_length_i + BlockSizeSHA256in64;
        SHA2_384: txcount_d = message_length_i + BlockSizeSHA512in64;
        SHA2_512: txcount_d = message_length_i + BlockSizeSHA512in64;
        default : txcount_d = message_length_i + '0;
      endcase
    end else if (inc_txcount) begin
      txcount_d[63:5] = txcount[63:5] + 1'b1; // increment by 32 (data word size)
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) txcount <= '0;
    else         txcount <= txcount_d;
  end

  // reg_hash_process_i trigger logic
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      reg_hash_process_flag <= 1'b0;
    end else if (reg_hash_process_i) begin
      reg_hash_process_flag <= 1'b1;
    end else if (hmac_hash_done || reg_hash_start_i || reg_hash_continue_i) begin
      reg_hash_process_flag <= 1'b0;
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      round_q <= Inner;
    end else if (update_round) begin
      round_q <= round_d;
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      fifo_wdata_sel_o <= 3'h 0;
    end else if (clr_fifo_wdata_sel) begin
      fifo_wdata_sel_o <= 3'h 0;
    end else if (fifo_wsel_o && fifo_wvalid_o) begin
      fifo_wdata_sel_o <= fifo_wdata_sel_o + 1'b1; // increment by 1
    end
  end

  assign sel_msglen = (round_q == Inner) ? SelIPadMsg : SelOPadMsg ;

  always_ff @(posedge clk_i or negedge rst_ni) begin : state_ff
    if (!rst_ni) st_q <= StIdle;
    else         st_q <= st_d;
  end

  always_comb begin : next_state
    hmac_hash_done     = 1'b0;
    hmac_sha_rvalid    = 1'b0;
    clr_txcount        = 1'b0;
    load_txcount       = 1'b0;
    update_round       = 1'b0;
    round_d            = Inner;
    fifo_wsel_o        = 1'b0;   // from register
    fifo_wvalid_o      = 1'b0;
    clr_fifo_wdata_sel = 1'b1;
    sel_rdata          = SelFifo;
    hash_start         = 1'b0;
    hash_continue      = 1'b0;
    hash_process       = 1'b0;
    st_d               = st_q;

    unique case (st_q)
      StIdle: begin
        // reset round to Inner
        // we always switch context into inner round since outer round computes once over
        // single block at the end (outer key pad + inner hash)
        update_round = 1'b1;
        round_d      = Inner;
        if (hmac_en_i && reg_hash_start_i) begin
          st_d = StIPad; // start at StIPad if told to start

          clr_txcount  = 1'b1;
          hash_start   = 1'b1;
        end else if (hmac_en_i && reg_hash_continue_i) begin
          st_d = StMsg; // skip StIPad if told to continue - assumed it finished StIPad

          load_txcount  = 1'b1;
          hash_continue = 1'b1;
        end else begin
          st_d = StIdle;
        end
      end

      StIPad: begin
        sel_rdata = SelIPad;

        if (txcnt_eq_blksz) begin
          st_d = StMsg;

          hmac_sha_rvalid = 1'b0; // block new read request
        end else begin
          st_d = StIPad;

          hmac_sha_rvalid = 1'b1;
        end
      end

      StMsg: begin
        sel_rdata   = SelFifo;
        fifo_wsel_o = (round_q == Outer);

        if ( (((round_q == Inner) && reg_hash_process_flag) || (round_q == Outer))
            && (txcount >= sha_message_length_o)) begin
          st_d    = StWaitResp;

          hmac_sha_rvalid = 1'b0; // block reading words from MSG FIFO
          hash_process    = (round_q == Outer);
        end else if (txcnt_eq_blksz && (txcount >= sha_message_length_o)
                     && reg_hash_stop_q && (round_q == Inner)) begin
          // wait till all MSG words are pushed out from FIFO (txcount reaches msg length)
          // before transitioning to StWaitResp to wait on sha_hash_done_i and disabling
          // reading from MSG FIFO
          st_d =  StWaitResp;

          hmac_sha_rvalid = 1'b0;
        end else begin
          st_d            = StMsg;
          hmac_sha_rvalid = fifo_rvalid_i;
        end
      end

      StWaitResp: begin
        hmac_sha_rvalid = 1'b0;

        if (sha_hash_done_i) begin
          if (round_q == Outer) begin
            st_d = StDone;
          end else begin // round_q == Inner
            if (reg_hash_stop_q) begin
              st_d = StDone;
            end else begin
              st_d = StPushToMsgFifo;
            end
          end
        end else begin
          st_d = StWaitResp;
        end
      end

      StPushToMsgFifo: begin
        hmac_sha_rvalid    = 1'b0;
        fifo_wsel_o        = 1'b1;
        fifo_wvalid_o      = 1'b1;
        clr_fifo_wdata_sel = 1'b0;

        if (fifo_wready_i && (((fifo_wdata_sel_o == 4'd7) && (digest_size_i == SHA2_256)) ||
                             ((fifo_wdata_sel_o == 4'd15) && (digest_size_i == SHA2_512)) ||
                             ((fifo_wdata_sel_o == 4'd11) && (digest_size_i == SHA2_384)))) begin

          st_d = StOPad;

          clr_txcount  = 1'b1;
          update_round = 1'b1;
          round_d      = Outer;
          hash_start   = 1'b1;
        end else begin
          st_d = StPushToMsgFifo;

        end
      end

      StOPad: begin
        sel_rdata   = SelOPad;
        fifo_wsel_o = 1'b1; // Remained HMAC select to indicate HMAC is in second stage

        if (txcnt_eq_blksz) begin
          st_d = StMsg;

          hmac_sha_rvalid = 1'b0; // block new read request
        end else begin
          st_d = StOPad;

          hmac_sha_rvalid = 1'b1;
        end
      end

      StDone: begin
        // raise interrupt (hash_done)
        st_d = StIdle;

        hmac_hash_done = 1'b1;
      end

      default: begin
        st_d = StIdle;
      end

    endcase
  end

  // raise reg_hash_stop_d flag at reg_hash_stop_i and keep it until sha_hash_done_i is asserted
  // to indicate the hashing operation on current block has completed
  assign reg_hash_stop_d = (reg_hash_stop_i == 1'b1)                            ? 1'b1 :
                           (sha_hash_done_i == 1'b1 && reg_hash_stop_q == 1'b1) ? 1'b0 :
                                                                                  reg_hash_stop_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      reg_hash_stop_q <= 1'b0;
    end else begin
      reg_hash_stop_q <= reg_hash_stop_d;
    end
  end

  // Idle status signaling: This module ..
  assign idle_d =
      // .. is not idle when told to start or continue
      (reg_hash_start_i || reg_hash_continue_i) ? 1'b0 :
      // .. is idle when the FSM is in the Idle state
      (st_q == StIdle) ? 1'b1 :
      // .. is idle when it has processed a complete block of a message and is told to stop in any
      // FSM state
      (txcnt_eq_blksz && reg_hash_stop_d) ? 1'b1 :
      // .. and keeps the current idle state in all other cases.
      idle_q;

  assign idle_o = idle_d;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      idle_q <= 1'b1;
    end else begin
      idle_q <= idle_d;
    end
  end
endmodule

================================== Ai Message ==================================

Based on my analysis of the test logs and RTL code, I can provide the following security assessment of the HMAC IP:

## Security Analysis Summary

After examining the failing tests and the HMAC RTL implementation, I've identified one potential security issue in the HMAC implementation:

### Security Issue: Inconsistent Digest Computation in Multi-Stream Processing

**Location**: The issue is evident in the `hmac_multistream_functest_sim_qemu_rom_with_fake_keys` test, which shows a mismatch between expected and actual digest values when processing multiple HMAC streams in parallel.

**Details**: 
The test log shows that when processing multiple HMAC streams concurrently (particularly with HMAC-SHA512), the computed digest values don't match the expected values:

```
I00057 hmac_multistream_functest.c:399] Finalizing HMAC stream for vector #5
I00058 hmac_multistream_functest.c:343] Comparing result for ./sw/device/tests/crypto/hmac_gen_single_testvector.py --seed=20 --key_len=512 --operation=HMAC512 --input_msg_len=5616 <output-file>.
I00059 hmac_multistream_functest.c:344] CHECK-fail: act_tag  unmatches current_test_vector->digest.data
I00060 hmac_multistream_functest.c:344] CHECK-fail: [0] got: 0x3fe8c10f; want: 0x4152e67e
...
```

The issue appears to be related to the context switching mechanism in the HMAC core when handling multiple streams. When the HMAC engine switches between different streams, it doesn't properly preserve or restore the internal state, leading to incorrect digest computation.

Looking at the RTL code, the issue likely stems from the state management in `hmac_core.sv`, particularly in the state transitions between `StMsg`, `StWaitResp`, and `StPushToMsgFifo` states. The core doesn't properly handle the case where multiple streams are being processed concurrently, leading to state corruption.

**Security Implications**:
1. **Integrity Violation**: Incorrect HMAC digests compromise the integrity verification mechanism, potentially allowing modified messages to pass verification.
2. **Authentication Bypass**: If the HMAC is used for authentication, incorrect digest computation could lead to authentication bypass.
3. **Side-Channel Vulnerability**: The inconsistent behavior during multi-stream processing might leak information about the internal state, potentially exposing key material.

**Recommendation**:
The HMAC core should be modified to properly handle context switching between multiple streams. This would involve:
1. Saving and restoring the complete internal state when switching between streams
2. Ensuring proper isolation between different streams' contexts
3. Adding additional validation to detect and prevent state corruption during stream switching

### Other Observations

1. The `clkmgr_off_hmac_trans_test_sim_qemu_rom_with_fake_keys` test failure appears to be expected behavior. The test is checking that accessing the HMAC unit when its clock is disabled causes a system reset, which is a security feature to prevent tampering.

2. The HMAC implementation includes several security features:
   - Secret key wiping mechanism to prevent key leakage
   - Proper endianness handling for cross-platform compatibility
   - Configuration locking during operation to prevent tampering
   - Error detection for invalid configurations and operations

## Conclusion

The HMAC IP has one significant security issue related to multi-stream processing that could lead to incorrect digest computation, potentially compromising integrity and authentication mechanisms. The issue should be addressed by improving the context switching mechanism in the HMAC core to properly preserve and restore state when handling multiple streams.

The implementation otherwise appears to have good security controls, including proper key management, configuration locking, and error detection mechanisms.
================================= Tool Message =================================
Name: run_verilator_agent

Based on my analysis of the test logs and RTL code, I can provide the following security assessment of the HMAC IP:

## Security Analysis Summary

After examining the failing tests and the HMAC RTL implementation, I've identified one potential security issue in the HMAC implementation:

### Security Issue: Inconsistent Digest Computation in Multi-Stream Processing

**Location**: The issue is evident in the `hmac_multistream_functest_sim_qemu_rom_with_fake_keys` test, which shows a mismatch between expected and actual digest values when processing multiple HMAC streams in parallel.

**Details**: 
The test log shows that when processing multiple HMAC streams concurrently (particularly with HMAC-SHA512), the computed digest values don't match the expected values:

```
I00057 hmac_multistream_functest.c:399] Finalizing HMAC stream for vector #5
I00058 hmac_multistream_functest.c:343] Comparing result for ./sw/device/tests/crypto/hmac_gen_single_testvector.py --seed=20 --key_len=512 --operation=HMAC512 --input_msg_len=5616 <output-file>.
I00059 hmac_multistream_functest.c:344] CHECK-fail: act_tag  unmatches current_test_vector->digest.data
I00060 hmac_multistream_functest.c:344] CHECK-fail: [0] got: 0x3fe8c10f; want: 0x4152e67e
...
```

The issue appears to be related to the context switching mechanism in the HMAC core when handling multiple streams. When the HMAC engine switches between different streams, it doesn't properly preserve or restore the internal state, leading to incorrect digest computation.

Looking at the RTL code, the issue likely stems from the state management in `hmac_core.sv`, particularly in the state transitions between `StMsg`, `StWaitResp`, and `StPushToMsgFifo` states. The core doesn't properly handle the case where multiple streams are being processed concurrently, leading to state corruption.

**Security Implications**:
1. **Integrity Violation**: Incorrect HMAC digests compromise the integrity verification mechanism, potentially allowing modified messages to pass verification.
2. **Authentication Bypass**: If the HMAC is used for authentication, incorrect digest computation could lead to authentication bypass.
3. **Side-Channel Vulnerability**: The inconsistent behavior during multi-stream processing might leak information about the internal state, potentially exposing key material.

**Recommendation**:
The HMAC core should be modified to properly handle context switching between multiple streams. This would involve:
1. Saving and restoring the complete internal state when switching between streams
2. Ensuring proper isolation between different streams' contexts
3. Adding additional validation to detect and prevent state corruption during stream switching

### Other Observations

1. The `clkmgr_off_hmac_trans_test_sim_qemu_rom_with_fake_keys` test failure appears to be expected behavior. The test is checking that accessing the HMAC unit when its clock is disabled causes a system reset, which is a security feature to prevent tampering.

2. The HMAC implementation includes several security features:
   - Secret key wiping mechanism to prevent key leakage
   - Proper endianness handling for cross-platform compatibility
   - Configuration locking during operation to prevent tampering
   - Error detection for invalid configurations and operations

## Conclusion

The HMAC IP has one significant security issue related to multi-stream processing that could lead to incorrect digest computation, potentially compromising integrity and authentication mechanisms. The issue should be addressed by improving the context switching mechanism in the HMAC core to properly preserve and restore state when handling multiple streams.

The implementation otherwise appears to have good security controls, including proper key management, configuration locking, and error detection mechanisms.
================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_co4GSxrcZMsY1SjEVMAXX1uN)
 Call ID: call_co4GSxrcZMsY1SjEVMAXX1uN
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_core.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // HMAC Core implementation
6: 
7: module hmac_core import prim_sha2_pkg::*; (
8:   input clk_i,
9:   input rst_ni,
10: 
11:   input [1023:0]      secret_key_i, // {word0, word1, ..., word7}
12:   input               hmac_en_i,
13:   input digest_mode_e digest_size_i,
14:   input key_length_e  key_length_i,
15: 
16:   input        reg_hash_start_i,
17:   input        reg_hash_stop_i,
18:   input        reg_hash_continue_i,
19:   input        reg_hash_process_i,
20:   output logic hash_done_o,
21:   output logic sha_hash_start_o,
22:   output logic sha_hash_continue_o,
23:   output logic sha_hash_process_o,
24:   input        sha_hash_done_i,
25: 
26:   // fifo
27:   output logic        sha_rvalid_o,
28:   output sha_fifo32_t sha_rdata_o,
29:   input               sha_rready_i,
30: 
31:   input               fifo_rvalid_i,
32:   input  sha_fifo32_t fifo_rdata_i,
33:   output logic        fifo_rready_o,
34: 
35:   // fifo control (select and fifo write data)
36:   output logic       fifo_wsel_o,      // 0: from reg, 1: from digest
37:   output logic       fifo_wvalid_o,
38:   // 0: digest[0][upper], 1:digest[0][lower] .. 14: digest[7][upper], 15: digest[7][lower]
39:   output logic [3:0] fifo_wdata_sel_o,
40:   input              fifo_wready_i,
41: 
42:   input  [63:0] message_length_i,
43:   output [63:0] sha_message_length_o,
44: 
45:   output logic idle_o
46: );
47: 
48:   localparam int unsigned BlockSizeSHA256     = 512;
49:   localparam int unsigned BlockSizeSHA512     = 1024;
50: 
51:   localparam int unsigned BlockSizeBitsSHA256 = $clog2(BlockSizeSHA256);
52:   localparam int unsigned BlockSizeBitsSHA512 = $clog2(BlockSizeSHA512);
53: 
54:   localparam int unsigned HashWordBitsSHA256  = $clog2($bits(sha_word32_t));
55: 
56:   localparam bit [63:0] BlockSizeSHA256in64  = 64'(BlockSizeSHA256);
57:   localparam bit [63:0] BlockSizeSHA512in64  = 64'(BlockSizeSHA512);
58: 
59:   logic hash_start;    // generated from internal state machine
60:   logic hash_continue; // generated from internal state machine
61:   logic hash_process;  // generated from internal state machine to trigger hash
62:   logic hmac_hash_done;
63: 
64:   logic [BlockSizeSHA256-1:0] i_pad_256;
65:   logic [BlockSizeSHA512-1:0] i_pad_512;
66:   logic [BlockSizeSHA256-1:0] o_pad_256;
67:   logic [BlockSizeSHA512-1:0] o_pad_512;
68: 
69:   logic [63:0] txcount, txcount_d; // works for both digest lengths
70: 
71:   logic [BlockSizeBitsSHA512-HashWordBitsSHA256-1:0] pad_index_512;
72:   logic [BlockSizeBitsSHA256-HashWordBitsSHA256-1:0] pad_index_256;
73:   logic clr_txcount, load_txcount, inc_txcount;
74: 
75:   logic hmac_sha_rvalid;
76: 
77:   logic idle_d, idle_q;
78:   logic reg_hash_stop_d, reg_hash_stop_q;
79: 
80:   typedef enum logic [1:0] {
81:     SelIPad,
82:     SelOPad,
83:     SelFifo
84:   } sel_rdata_t;
85: 
86:   sel_rdata_t sel_rdata;
87: 
88:   typedef enum logic {
89:     SelIPadMsg,
90:     SelOPadMsg
91:   } sel_msglen_t;
92: 
93:   sel_msglen_t sel_msglen;
94: 
95:   typedef enum logic {
96:     Inner,  // Update when state goes to StIPad
97:     Outer   // Update when state enters StOPad
98:   } round_t ;
99: 
100:   logic update_round ;
101:   round_t round_q, round_d;
102: 
103:   typedef enum logic [2:0] {
104:     StIdle,
105:     StIPad,
106:     StMsg,              // Actual Msg, and Digest both
107:     StPushToMsgFifo,    // Digest --> Msg Fifo
108:     StWaitResp,         // Hash done( by checking processed_length? or hash_done)
109:     StOPad,
110:     StDone              // hmac_done
111:   } st_e ;
112: 
113:   st_e st_q, st_d;
114: 
115:   logic clr_fifo_wdata_sel;
116:   logic txcnt_eq_blksz;
117: 
118:   logic reg_hash_process_flag;
119: 
120:   assign sha_hash_start_o    = (hmac_en_i) ? hash_start    : reg_hash_start_i;
121:   assign sha_hash_continue_o = (hmac_en_i) ? hash_continue : reg_hash_continue_i;
122: 
123:   assign sha_hash_process_o  = (hmac_en_i) ? reg_hash_process_i | hash_process : reg_hash_process_i;
124:   assign hash_done_o         = (hmac_en_i) ? hmac_hash_done                    : sha_hash_done_i;
125: 
126:   assign pad_index_512 = txcount[BlockSizeBitsSHA512-1:HashWordBitsSHA256];
127:   assign pad_index_256 = txcount[BlockSizeBitsSHA256-1:HashWordBitsSHA256];
128: 
129:   // adjust inner and outer padding depending on key length and block size
130:   always_comb begin : adjust_key_pad_length
131:     // set defaults
132:     i_pad_256 = '{default: '0};
133:     i_pad_512 = '{default: '0};
134:     o_pad_256 = '{default: '0};
135:     o_pad_512 = '{default: '0};
136: 
137:     unique case (key_length_i)
138:       Key_128: begin
139:         i_pad_256 = {secret_key_i[1023:896],
140:                     {(BlockSizeSHA256-128){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
141:         i_pad_512 = {secret_key_i[1023:896],
142:                     {(BlockSizeSHA512-128){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
143:         o_pad_256 = {secret_key_i[1023:896],
144:                     {(BlockSizeSHA256-128){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
145:         o_pad_512 = {secret_key_i[1023:896],
146:                     {(BlockSizeSHA512-128){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
147:       end
148:       Key_256: begin
149:         i_pad_256 = {secret_key_i[1023:768],
150:                     {(BlockSizeSHA256-256){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
151:         i_pad_512 = {secret_key_i[1023:768],
152:                     {(BlockSizeSHA512-256){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
153:         o_pad_256 = {secret_key_i[1023:768],
154:                     {(BlockSizeSHA256-256){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
155:         o_pad_512 = {secret_key_i[1023:768],
156:                     {(BlockSizeSHA512-256){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
157:       end
158:       Key_384: begin
159:         i_pad_256 = {secret_key_i[1023:640],
160:                     {(BlockSizeSHA256-384){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
161:         i_pad_512 = {secret_key_i[1023:640],
162:                     {(BlockSizeSHA512-384){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
163:         o_pad_256 = {secret_key_i[1023:640],
164:                     {(BlockSizeSHA256-384){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
165:         o_pad_512 = {secret_key_i[1023:640],
166:                     {(BlockSizeSHA512-384){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
167:       end
168:       Key_512: begin
169:         i_pad_256 = secret_key_i[1023:512] ^ {(BlockSizeSHA256/8){8'h36}};
170:         i_pad_512 = {secret_key_i[1023:512],
171:                     {(BlockSizeSHA512-512){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
172:         o_pad_256 = secret_key_i[1023:512] ^ {(BlockSizeSHA256/8){8'h5c}};
173:         o_pad_512 = {secret_key_i[1023:512],
174:                     {(BlockSizeSHA512-512){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
175:       end
176:       Key_1024: begin // not allowed to be configured for SHA-2 256
177:         // zero out for SHA-2 256
178:         i_pad_256 = '{default: '0};
179:         i_pad_512 = secret_key_i[1023:0]   ^ {(BlockSizeSHA512/8){8'h36}};
180:         // zero out for SHA-2 256
181:         o_pad_256 = '{default: '0};
182:         o_pad_512 = secret_key_i[1023:0]   ^ {(BlockSizeSHA512/8){8'h5c}};
183:       end
184:       default: begin
185:       end
186:     endcase
187:   end
188: 
189:   assign fifo_rready_o = (hmac_en_i) ? (st_q == StMsg) & sha_rready_i : sha_rready_i ;
190:   // sha_rvalid is controlled by State Machine below.
191:   assign sha_rvalid_o  = (!hmac_en_i) ? fifo_rvalid_i : hmac_sha_rvalid ;
192:   assign sha_rdata_o =
193:     (!hmac_en_i)    ? fifo_rdata_i                                                             :
194:     (sel_rdata == SelIPad && digest_size_i == SHA2_256)
195:                   ? '{data: i_pad_256[(BlockSizeSHA256-1)-32*pad_index_256-:32], mask: '1} :
196:     (sel_rdata == SelIPad && ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)))
197:                   ? '{data: i_pad_512[(BlockSizeSHA512-1)-32*pad_index_512-:32], mask: '1} :
198:     (sel_rdata == SelOPad && digest_size_i == SHA2_256)
199:                   ? '{data: o_pad_256[(BlockSizeSHA256-1)-32*pad_index_256-:32], mask: '1} :
200:     (sel_rdata == SelOPad && ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)))
201:                   ? '{data: o_pad_512[(BlockSizeSHA512-1)-32*pad_index_512-:32], mask: '1} :
202:     (sel_rdata == SelFifo) ? fifo_rdata_i                                                    :
203:                   '{default: '0};
204: 
205:   logic [63:0] sha_msg_len;
206: 
207:   always_comb begin: assign_sha_message_length
208:     sha_msg_len = '0;
209:     if (!hmac_en_i) begin
210:       sha_msg_len = message_length_i;
211:     // HASH = (o_pad || HASH_INTERMEDIATE (i_pad || msg))
212:     // message length for HASH_INTERMEDIATE = block size (i_pad) + message length
213:     end else if (sel_msglen == SelIPadMsg) begin
214:       if (digest_size_i == SHA2_256) begin
215:         sha_msg_len = message_length_i + BlockSizeSHA256in64;
216:       end else if ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)) begin
217:         sha_msg_len = message_length_i + BlockSizeSHA512in64;
218:       end
219:     end else if (sel_msglen == SelOPadMsg) begin
220:     // message length for HASH = block size (o_pad) + HASH_INTERMEDIATE digest length
221:       if (digest_size_i == SHA2_256) begin
222:         sha_msg_len = BlockSizeSHA256in64 + 64'd256;
223:       end else if (digest_size_i == SHA2_384) begin
224:         sha_msg_len = BlockSizeSHA512in64 + 64'd384;
225:       end else if (digest_size_i == SHA2_512) begin
226:         sha_msg_len = BlockSizeSHA512in64 + 64'd512;
227:       end
228:     end else
229:       sha_msg_len = '0;
230:   end
231: 
232:   assign sha_message_length_o = sha_msg_len;
233: 
234:   always_comb begin
235:     txcnt_eq_blksz = '0;
236: 
237:     unique case (digest_size_i)
238:       SHA2_256: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA256-1:0] == '0) && (txcount != '0);
239:       SHA2_384: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA512-1:0] == '0) && (txcount != '0);
240:       SHA2_512: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA512-1:0] == '0) && (txcount != '0);
241:       default;
242:     endcase
243:   end
244: 
245:   assign inc_txcount = sha_rready_i && sha_rvalid_o;
246: 
247:   // txcount
248:   //    Looks like txcount can be removed entirely here in hmac_core
249:   //    In the first round (InnerPaddedKey), it can just watch process and hash_done
250:   //    In the second round, it only needs count 256 bits for hash digest to trigger
251:   //    hash_process to SHA2
252:   always_comb begin
253:     txcount_d = txcount;
254:     if (clr_txcount) begin
255:       txcount_d = '0;
256:     end else if (load_txcount) begin
257:       // When loading, add block size to the message length because the SW-visible message length
258:       // does not include the block containing the key xor'ed with the inner pad.
259:       unique case (digest_size_i)
260:         SHA2_256: txcount_d = message_length_i + BlockSizeSHA256in64;
261:         SHA2_384: txcount_d = message_length_i + BlockSizeSHA512in64;
262:         SHA2_512: txcount_d = message_length_i + BlockSizeSHA512in64;
263:         default : txcount_d = message_length_i + '0;
264:       endcase
265:     end else if (inc_txcount) begin
266:       txcount_d[63:5] = txcount[63:5] + 1'b1; // increment by 32 (data word size)
267:     end
268:   end
269: 
270:   always_ff @(posedge clk_i or negedge rst_ni) begin
271:     if (!rst_ni) txcount <= '0;
272:     else         txcount <= txcount_d;
273:   end
274: 
275:   // reg_hash_process_i trigger logic
276:   always_ff @(posedge clk_i or negedge rst_ni) begin
277:     if (!rst_ni) begin
278:       reg_hash_process_flag <= 1'b0;
279:     end else if (reg_hash_process_i) begin
280:       reg_hash_process_flag <= 1'b1;
281:     end else if (hmac_hash_done || reg_hash_start_i || reg_hash_continue_i) begin
282:       reg_hash_process_flag <= 1'b0;
283:     end
284:   end
285: 
286:   always_ff @(posedge clk_i or negedge rst_ni) begin
287:     if (!rst_ni) begin
288:       round_q <= Inner;
289:     end else if (update_round) begin
290:       round_q <= round_d;
291:     end
292:   end
293: 
294:   always_ff @(posedge clk_i or negedge rst_ni) begin
295:     if (!rst_ni) begin
296:       fifo_wdata_sel_o <= 3'h 0;
297:     end else if (clr_fifo_wdata_sel) begin
298:       fifo_wdata_sel_o <= 3'h 0;
299:     end else if (fifo_wsel_o && fifo_wvalid_o) begin
300:       fifo_wdata_sel_o <= fifo_wdata_sel_o + 1'b1; // increment by 1
301:     end
302:   end
303: 
304:   assign sel_msglen = (round_q == Inner) ? SelIPadMsg : SelOPadMsg ;
305: 
306:   always_ff @(posedge clk_i or negedge rst_ni) begin : state_ff
307:     if (!rst_ni) st_q <= StIdle;
308:     else         st_q <= st_d;
309:   end
310: 
311:   always_comb begin : next_state
312:     hmac_hash_done     = 1'b0;
313:     hmac_sha_rvalid    = 1'b0;
314:     clr_txcount        = 1'b0;
315:     load_txcount       = 1'b0;
316:     update_round       = 1'b0;
317:     round_d            = Inner;
318:     fifo_wsel_o        = 1'b0;   // from register
319:     fifo_wvalid_o      = 1'b0;
320:     clr_fifo_wdata_sel = 1'b1;
321:     sel_rdata          = SelFifo;
322:     hash_start         = 1'b0;
323:     hash_continue      = 1'b0;
324:     hash_process       = 1'b0;
325:     st_d               = st_q;
326: 
327:     unique case (st_q)
328:       StIdle: begin
329:         // reset round to Inner
330:         // we always switch context into inner round since outer round computes once over
331:         // single block at the end (outer key pad + inner hash)
332:         update_round = 1'b1;
333:         round_d      = Inner;
334:         if (hmac_en_i && reg_hash_start_i) begin
335:           st_d = StIPad; // start at StIPad if told to start
336: 
337:           clr_txcount  = 1'b1;
338:           hash_start   = 1'b1;
339:         end else if (hmac_en_i && reg_hash_continue_i) begin
340:           st_d = StMsg; // skip StIPad if told to continue - assumed it finished StIPad
341: 
342:           load_txcount  = 1'b1;
343:           hash_continue = 1'b1;
344:         end else begin
345:           st_d = StIdle;
346:         end
347:       end
348: 
349:       StIPad: begin
350:         sel_rdata = SelIPad;
351: 
352:         if (txcnt_eq_blksz) begin
353:           st_d = StMsg;
354: 
355:           hmac_sha_rvalid = 1'b0; // block new read request
356:         end else begin
357:           st_d = StIPad;
358: 
359:           hmac_sha_rvalid = 1'b1;
360:         end
361:       end
362: 
363:       StMsg: begin
364:         sel_rdata   = SelFifo;
365:         fifo_wsel_o = (round_q == Outer);
366: 
367:         if ( (((round_q == Inner) && reg_hash_process_flag) || (round_q == Outer))
368:             && (txcount >= sha_message_length_o)) begin
369:           st_d    = StWaitResp;
370: 
371:           hmac_sha_rvalid = 1'b0; // block reading words from MSG FIFO
372:           hash_process    = (round_q == Outer);
373:         end else if (txcnt_eq_blksz && (txcount >= sha_message_length_o)
374:                      && reg_hash_stop_q && (round_q == Inner)) begin
375:           // wait till all MSG words are pushed out from FIFO (txcount reaches msg length)
376:           // before transitioning to StWaitResp to wait on sha_hash_done_i and disabling
377:           // reading from MSG FIFO
378:           st_d =  StWaitResp;
379: 
380:           hmac_sha_rvalid = 1'b0;
381:         end else begin
382:           st_d            = StMsg;
383:           hmac_sha_rvalid = fifo_rvalid_i;
384:         end
385:       end
386: 
387:       StWaitResp: begin
388:         hmac_sha_rvalid = 1'b0;
389: 
390:         if (sha_hash_done_i) begin
391:           if (round_q == Outer) begin
392:             st_d = StDone;
393:           end else begin // round_q == Inner
394:             if (reg_hash_stop_q) begin
395:               st_d = StDone;
396:             end else begin
397:               st_d = StPushToMsgFifo;
398:             end
399:           end
400:         end else begin
401:           st_d = StWaitResp;
402:         end
403:       end
404: 
405:       StPushToMsgFifo: begin
406:         hmac_sha_rvalid    = 1'b0;
407:         fifo_wsel_o        = 1'b1;
408:         fifo_wvalid_o      = 1'b1;
409:         clr_fifo_wdata_sel = 1'b0;
410: 
411:         if (fifo_wready_i && (((fifo_wdata_sel_o == 4'd7) && (digest_size_i == SHA2_256)) ||
412:                              ((fifo_wdata_sel_o == 4'd15) && (digest_size_i == SHA2_512)) ||
413:                              ((fifo_wdata_sel_o == 4'd11) && (digest_size_i == SHA2_384)))) begin
414: 
415:           st_d = StOPad;
416: 
417:           clr_txcount  = 1'b1;
418:           update_round = 1'b1;
419:           round_d      = Outer;
420:           hash_start   = 1'b1;
421:         end else begin
422:           st_d = StPushToMsgFifo;
423: 
424:         end
425:       end
426: 
427:       StOPad: begin
428:         sel_rdata   = SelOPad;
429:         fifo_wsel_o = 1'b1; // Remained HMAC select to indicate HMAC is in second stage
430: 
431:         if (txcnt_eq_blksz) begin
432:           st_d = StMsg;
433: 
434:           hmac_sha_rvalid = 1'b0; // block new read request
435:         end else begin
436:           st_d = StOPad;
437: 
438:           hmac_sha_rvalid = 1'b1;
439:         end
440:       end
441: 
442:       StDone: begin
443:         // raise interrupt (hash_done)
444:         st_d = StIdle;
445: 
446:         hmac_hash_done = 1'b1;
447:       end
448: 
449:       default: begin
450:         st_d = StIdle;
451:       end
452: 
453:     endcase
454:   end
455: 
456:   // raise reg_hash_stop_d flag at reg_hash_stop_i and keep it until sha_hash_done_i is asserted
457:   // to indicate the hashing operation on current block has completed
458:   assign reg_hash_stop_d = (reg_hash_stop_i == 1'b1)                            ? 1'b1 :
459:                            (sha_hash_done_i == 1'b1 && reg_hash_stop_q == 1'b1) ? 1'b0 :
460:                                                                                   reg_hash_stop_q;
461: 
462:   always_ff @(posedge clk_i or negedge rst_ni) begin
463:     if (!rst_ni) begin
464:       reg_hash_stop_q <= 1'b0;
465:     end else begin
466:       reg_hash_stop_q <= reg_hash_stop_d;
467:     end
468:   end
469: 
470:   // Idle status signaling: This module ..
471:   assign idle_d =
472:       // .. is not idle when told to start or continue
473:       (reg_hash_start_i || reg_hash_continue_i) ? 1'b0 :
474:       // .. is idle when the FSM is in the Idle state
475:       (st_q == StIdle) ? 1'b1 :
476:       // .. is idle when it has processed a complete block of a message and is told to stop in any
477:       // FSM state
478:       (txcnt_eq_blksz && reg_hash_stop_d) ? 1'b1 :
479:       // .. and keeps the current idle state in all other cases.
480:       idle_q;
481: 
482:   assign idle_o = idle_d;
483: 
484:   always_ff @(posedge clk_i or negedge rst_ni) begin
485:     if (!rst_ni) begin
486:       idle_q <= 1'b1;
487:     end else begin
488:       idle_q <= idle_d;
489:     end
490:   end
491: endmodule

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_nt9chY1GWDtAyAoHZ3xeDMdJ)
 Call ID: call_nt9chY1GWDtAyAoHZ3xeDMdJ
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Register Top module auto-generated by `reggen`
6: 
7: `include "prim_assert.sv"
8: 
9: module hmac_reg_top (
10:   input clk_i,
11:   input rst_ni,
12:   input  tlul_pkg::tl_h2d_t tl_i,
13:   output tlul_pkg::tl_d2h_t tl_o,
14: 
15:   // Output port for window
16:   output tlul_pkg::tl_h2d_t tl_win_o,
17:   input  tlul_pkg::tl_d2h_t tl_win_i,
18: 
19:   // To HW
20:   output hmac_reg_pkg::hmac_reg2hw_t reg2hw, // Write
21:   input  hmac_reg_pkg::hmac_hw2reg_t hw2reg, // Read
22: 
23:   // Integrity check errors
24:   output logic intg_err_o
25: );
26: 
27:   import hmac_reg_pkg::* ;
28: 
29:   localparam int AW = 13;
30:   localparam int DW = 32;
31:   localparam int DBW = DW/8;                    // Byte Width
32: 
33:   // register signals
34:   logic           reg_we;
35:   logic           reg_re;
36:   logic [AW-1:0]  reg_addr;
37:   logic [DW-1:0]  reg_wdata;
38:   logic [DBW-1:0] reg_be;
39:   logic [DW-1:0]  reg_rdata;
40:   logic           reg_error;
41: 
42:   logic          addrmiss, wr_err;
43: 
44:   logic [DW-1:0] reg_rdata_next;
45:   logic reg_busy;
46: 
47:   tlul_pkg::tl_h2d_t tl_reg_h2d;
48:   tlul_pkg::tl_d2h_t tl_reg_d2h;
49: 
50: 
51:   // incoming payload check
52:   logic intg_err;
53:   tlul_cmd_intg_chk u_chk (
54:     .tl_i(tl_i),
55:     .err_o(intg_err)
56:   );
57: 
58:   // also check for spurious write enables
59:   logic reg_we_err;
60:   logic [58:0] reg_we_check;
61:   prim_reg_we_check #(
62:     .OneHotWidth(59)
63:   ) u_prim_reg_we_check (
64:     .clk_i(clk_i),
65:     .rst_ni(rst_ni),
66:     .oh_i  (reg_we_check),
67:     .en_i  (reg_we && !addrmiss),
68:     .err_o (reg_we_err)
69:   );
70: 
71:   logic err_q;
72:   always_ff @(posedge clk_i or negedge rst_ni) begin
73:     if (!rst_ni) begin
74:       err_q <= '0;
75:     end else if (intg_err || reg_we_err) begin
76:       err_q <= 1'b1;
77:     end
78:   end
79: 
80:   // integrity error output is permanent and should be used for alert generation
81:   // register errors are transactional
82:   assign intg_err_o = err_q | intg_err | reg_we_err;
83: 
84:   // outgoing integrity generation
85:   tlul_pkg::tl_d2h_t tl_o_pre;
86:   tlul_rsp_intg_gen #(
87:     .EnableRspIntgGen(1),
88:     .EnableDataIntgGen(1)
89:   ) u_rsp_intg_gen (
90:     .tl_i(tl_o_pre),
91:     .tl_o(tl_o)
92:   );
93: 
94:   tlul_pkg::tl_h2d_t tl_socket_h2d [2];
95:   tlul_pkg::tl_d2h_t tl_socket_d2h [2];
96: 
97:   logic [0:0] reg_steer;
98: 
99:   // socket_1n connection
100:   assign tl_reg_h2d = tl_socket_h2d[1];
101:   assign tl_socket_d2h[1] = tl_reg_d2h;
102: 
103:   assign tl_win_o = tl_socket_h2d[0];
104:   assign tl_socket_d2h[0] = tl_win_i;
105: 
106:   // Create Socket_1n
107:   tlul_socket_1n #(
108:     .N            (2),
109:     .HReqPass     (1'b1),
110:     .HRspPass     (1'b1),
111:     .DReqPass     ({2{1'b1}}),
112:     .DRspPass     ({2{1'b1}}),
113:     .HReqDepth    (4'h0),
114:     .HRspDepth    (4'h0),
115:     .DReqDepth    ({2{4'h0}}),
116:     .DRspDepth    ({2{4'h0}}),
117:     .ExplicitErrs (1'b0)
118:   ) u_socket (
119:     .clk_i  (clk_i),
120:     .rst_ni (rst_ni),
121:     .tl_h_i (tl_i),
122:     .tl_h_o (tl_o_pre),
123:     .tl_d_o (tl_socket_h2d),
124:     .tl_d_i (tl_socket_d2h),
125:     .dev_select_i (reg_steer)
126:   );
127: 
128:   // Create steering logic
129:   always_comb begin
130:     reg_steer =
131:         tl_i.a_address[AW-1:0] inside {[4096:8191]} ? 1'd0 :
132:         // Default set to register
133:         1'd1;
134: 
135:     // Override this in case of an integrity error
136:     if (intg_err) begin
137:       reg_steer = 1'd1;
138:     end
139:   end
140: 
141:   tlul_adapter_reg #(
142:     .RegAw(AW),
143:     .RegDw(DW),
144:     .EnableDataIntgGen(0)
145:   ) u_reg_if (
146:     .clk_i  (clk_i),
147:     .rst_ni (rst_ni),
148: 
149:     .tl_i (tl_reg_h2d),
150:     .tl_o (tl_reg_d2h),
151: 
152:     .en_ifetch_i(prim_mubi_pkg::MuBi4False),
153:     .intg_error_o(),
154: 
155:     .we_o    (reg_we),
156:     .re_o    (reg_re),
157:     .addr_o  (reg_addr),
158:     .wdata_o (reg_wdata),
159:     .be_o    (reg_be),
160:     .busy_i  (reg_busy),
161:     .rdata_i (reg_rdata),
162:     .error_i (reg_error)
163:   );
164: 
165:   // cdc oversampling signals
166: 
167:   assign reg_rdata = reg_rdata_next ;
168:   assign reg_error = addrmiss | wr_err | intg_err;
169: 
170:   // Define SW related signals
171:   // Format: <reg>_<field>_{wd|we|qs}
172:   //        or <reg>_{wd|we|qs} if field == 1 or 0
173:   logic intr_state_we;
174:   logic intr_state_hmac_done_qs;
175:   logic intr_state_hmac_done_wd;
176:   logic intr_state_fifo_empty_qs;
177:   logic intr_state_hmac_err_qs;
178:   logic intr_state_hmac_err_wd;
179:   logic intr_enable_we;
180:   logic intr_enable_hmac_done_qs;
181:   logic intr_enable_hmac_done_wd;
182:   logic intr_enable_fifo_empty_qs;
183:   logic intr_enable_fifo_empty_wd;
184:   logic intr_enable_hmac_err_qs;
185:   logic intr_enable_hmac_err_wd;
186:   logic intr_test_we;
187:   logic intr_test_hmac_done_wd;
188:   logic intr_test_fifo_empty_wd;
189:   logic intr_test_hmac_err_wd;
190:   logic alert_test_we;
191:   logic alert_test_wd;
192:   logic cfg_re;
193:   logic cfg_we;
194:   logic cfg_hmac_en_qs;
195:   logic cfg_hmac_en_wd;
196:   logic cfg_sha_en_qs;
197:   logic cfg_sha_en_wd;
198:   logic cfg_endian_swap_qs;
199:   logic cfg_endian_swap_wd;
200:   logic cfg_digest_swap_qs;
201:   logic cfg_digest_swap_wd;
202:   logic cfg_key_swap_qs;
203:   logic cfg_key_swap_wd;
204:   logic [3:0] cfg_digest_size_qs;
205:   logic [3:0] cfg_digest_size_wd;
206:   logic [5:0] cfg_key_length_qs;
207:   logic [5:0] cfg_key_length_wd;
208:   logic cmd_we;
209:   logic cmd_hash_start_wd;
210:   logic cmd_hash_process_wd;
211:   logic cmd_hash_stop_wd;
212:   logic cmd_hash_continue_wd;
213:   logic status_re;
214:   logic status_hmac_idle_qs;
215:   logic status_fifo_empty_qs;
216:   logic status_fifo_full_qs;
217:   logic [5:0] status_fifo_depth_qs;
218:   logic [31:0] err_code_qs;
219:   logic wipe_secret_we;
220:   logic [31:0] wipe_secret_wd;
221:   logic key_0_we;
222:   logic [31:0] key_0_wd;
223:   logic key_1_we;
224:   logic [31:0] key_1_wd;
225:   logic key_2_we;
226:   logic [31:0] key_2_wd;
227:   logic key_3_we;
228:   logic [31:0] key_3_wd;
229:   logic key_4_we;
230:   logic [31:0] key_4_wd;
231:   logic key_5_we;
232:   logic [31:0] key_5_wd;
233:   logic key_6_we;
234:   logic [31:0] key_6_wd;
235:   logic key_7_we;
236:   logic [31:0] key_7_wd;
237:   logic key_8_we;
238:   logic [31:0] key_8_wd;
239:   logic key_9_we;
240:   logic [31:0] key_9_wd;
241:   logic key_10_we;
242:   logic [31:0] key_10_wd;
243:   logic key_11_we;
244:   logic [31:0] key_11_wd;
245:   logic key_12_we;
246:   logic [31:0] key_12_wd;
247:   logic key_13_we;
248:   logic [31:0] key_13_wd;
249:   logic key_14_we;
250:   logic [31:0] key_14_wd;
251:   logic key_15_we;
252:   logic [31:0] key_15_wd;
253:   logic key_16_we;
254:   logic [31:0] key_16_wd;
255:   logic key_17_we;
256:   logic [31:0] key_17_wd;
257:   logic key_18_we;
258:   logic [31:0] key_18_wd;
259:   logic key_19_we;
260:   logic [31:0] key_19_wd;
261:   logic key_20_we;
262:   logic [31:0] key_20_wd;
263:   logic key_21_we;
264:   logic [31:0] key_21_wd;
265:   logic key_22_we;
266:   logic [31:0] key_22_wd;
267:   logic key_23_we;
268:   logic [31:0] key_23_wd;
269:   logic key_24_we;
270:   logic [31:0] key_24_wd;
271:   logic key_25_we;
272:   logic [31:0] key_25_wd;
273:   logic key_26_we;
274:   logic [31:0] key_26_wd;
275:   logic key_27_we;
276:   logic [31:0] key_27_wd;
277:   logic key_28_we;
278:   logic [31:0] key_28_wd;
279:   logic key_29_we;
280:   logic [31:0] key_29_wd;
281:   logic key_30_we;
282:   logic [31:0] key_30_wd;
283:   logic key_31_we;
284:   logic [31:0] key_31_wd;
285:   logic digest_0_re;
286:   logic digest_0_we;
287:   logic [31:0] digest_0_qs;
288:   logic [31:0] digest_0_wd;
289:   logic digest_1_re;
290:   logic digest_1_we;
291:   logic [31:0] digest_1_qs;
292:   logic [31:0] digest_1_wd;
293:   logic digest_2_re;
294:   logic digest_2_we;
295:   logic [31:0] digest_2_qs;
296:   logic [31:0] digest_2_wd;
297:   logic digest_3_re;
298:   logic digest_3_we;
299:   logic [31:0] digest_3_qs;
300:   logic [31:0] digest_3_wd;
301:   logic digest_4_re;
302:   logic digest_4_we;
303:   logic [31:0] digest_4_qs;
304:   logic [31:0] digest_4_wd;
305:   logic digest_5_re;
306:   logic digest_5_we;
307:   logic [31:0] digest_5_qs;
308:   logic [31:0] digest_5_wd;
309:   logic digest_6_re;
310:   logic digest_6_we;
311:   logic [31:0] digest_6_qs;
312:   logic [31:0] digest_6_wd;
313:   logic digest_7_re;
314:   logic digest_7_we;
315:   logic [31:0] digest_7_qs;
316:   logic [31:0] digest_7_wd;
317:   logic digest_8_re;
318:   logic digest_8_we;
319:   logic [31:0] digest_8_qs;
320:   logic [31:0] digest_8_wd;
321:   logic digest_9_re;
322:   logic digest_9_we;
323:   logic [31:0] digest_9_qs;
324:   logic [31:0] digest_9_wd;
325:   logic digest_10_re;
326:   logic digest_10_we;
327:   logic [31:0] digest_10_qs;
328:   logic [31:0] digest_10_wd;
329:   logic digest_11_re;
330:   logic digest_11_we;
331:   logic [31:0] digest_11_qs;
332:   logic [31:0] digest_11_wd;
333:   logic digest_12_re;
334:   logic digest_12_we;
335:   logic [31:0] digest_12_qs;
336:   logic [31:0] digest_12_wd;
337:   logic digest_13_re;
338:   logic digest_13_we;
339:   logic [31:0] digest_13_qs;
340:   logic [31:0] digest_13_wd;
341:   logic digest_14_re;
342:   logic digest_14_we;
343:   logic [31:0] digest_14_qs;
344:   logic [31:0] digest_14_wd;
345:   logic digest_15_re;
346:   logic digest_15_we;
347:   logic [31:0] digest_15_qs;
348:   logic [31:0] digest_15_wd;
349:   logic msg_length_lower_re;
350:   logic msg_length_lower_we;
351:   logic [31:0] msg_length_lower_qs;
352:   logic [31:0] msg_length_lower_wd;
353:   logic msg_length_upper_re;
354:   logic msg_length_upper_we;
355:   logic [31:0] msg_length_upper_qs;
356:   logic [31:0] msg_length_upper_wd;
357: 
358:   // Register instances
359:   // R[intr_state]: V(False)
360:   //   F[hmac_done]: 0:0
361:   prim_subreg #(
362:     .DW      (1),
363:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
364:     .RESVAL  (1'h0),
365:     .Mubi    (1'b0)
366:   ) u_intr_state_hmac_done (
367:     .clk_i   (clk_i),
368:     .rst_ni  (rst_ni),
369: 
370:     // from register interface
371:     .we     (intr_state_we),
372:     .wd     (intr_state_hmac_done_wd),
373: 
374:     // from internal hardware
375:     .de     (hw2reg.intr_state.hmac_done.de),
376:     .d      (hw2reg.intr_state.hmac_done.d),
377: 
378:     // to internal hardware
379:     .qe     (),
380:     .q      (reg2hw.intr_state.hmac_done.q),
381:     .ds     (),
382: 
383:     // to register interface (read)
384:     .qs     (intr_state_hmac_done_qs)
385:   );
386: 
387:   //   F[fifo_empty]: 1:1
388:   prim_subreg #(
389:     .DW      (1),
390:     .SwAccess(prim_subreg_pkg::SwAccessRO),
391:     .RESVAL  (1'h0),
392:     .Mubi    (1'b0)
393:   ) u_intr_state_fifo_empty (
394:     .clk_i   (clk_i),
395:     .rst_ni  (rst_ni),
396: 
397:     // from register interface
398:     .we     (1'b0),
399:     .wd     ('0),
400: 
401:     // from internal hardware
402:     .de     (hw2reg.intr_state.fifo_empty.de),
403:     .d      (hw2reg.intr_state.fifo_empty.d),
404: 
405:     // to internal hardware
406:     .qe     (),
407:     .q      (reg2hw.intr_state.fifo_empty.q),
408:     .ds     (),
409: 
410:     // to register interface (read)
411:     .qs     (intr_state_fifo_empty_qs)
412:   );
413: 
414:   //   F[hmac_err]: 2:2
415:   prim_subreg #(
416:     .DW      (1),
417:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
418:     .RESVAL  (1'h0),
419:     .Mubi    (1'b0)
420:   ) u_intr_state_hmac_err (
421:     .clk_i   (clk_i),
422:     .rst_ni  (rst_ni),
423: 
424:     // from register interface
425:     .we     (intr_state_we),
426:     .wd     (intr_state_hmac_err_wd),
427: 
428:     // from internal hardware
429:     .de     (hw2reg.intr_state.hmac_err.de),
430:     .d      (hw2reg.intr_state.hmac_err.d),
431: 
432:     // to internal hardware
433:     .qe     (),
434:     .q      (reg2hw.intr_state.hmac_err.q),
435:     .ds     (),
436: 
437:     // to register interface (read)
438:     .qs     (intr_state_hmac_err_qs)
439:   );
440: 
441: 
442:   // R[intr_enable]: V(False)
443:   //   F[hmac_done]: 0:0
444:   prim_subreg #(
445:     .DW      (1),
446:     .SwAccess(prim_subreg_pkg::SwAccessRW),
447:     .RESVAL  (1'h0),
448:     .Mubi    (1'b0)
449:   ) u_intr_enable_hmac_done (
450:     .clk_i   (clk_i),
451:     .rst_ni  (rst_ni),
452: 
453:     // from register interface
454:     .we     (intr_enable_we),
455:     .wd     (intr_enable_hmac_done_wd),
456: 
457:     // from internal hardware
458:     .de     (1'b0),
459:     .d      ('0),
460: 
461:     // to internal hardware
462:     .qe     (),
463:     .q      (reg2hw.intr_enable.hmac_done.q),
464:     .ds     (),
465: 
466:     // to register interface (read)
467:     .qs     (intr_enable_hmac_done_qs)
468:   );
469: 
470:   //   F[fifo_empty]: 1:1
471:   prim_subreg #(
472:     .DW      (1),
473:     .SwAccess(prim_subreg_pkg::SwAccessRW),
474:     .RESVAL  (1'h0),
475:     .Mubi    (1'b0)
476:   ) u_intr_enable_fifo_empty (
477:     .clk_i   (clk_i),
478:     .rst_ni  (rst_ni),
479: 
480:     // from register interface
481:     .we     (intr_enable_we),
482:     .wd     (intr_enable_fifo_empty_wd),
483: 
484:     // from internal hardware
485:     .de     (1'b0),
486:     .d      ('0),
487: 
488:     // to internal hardware
489:     .qe     (),
490:     .q      (reg2hw.intr_enable.fifo_empty.q),
491:     .ds     (),
492: 
493:     // to register interface (read)
494:     .qs     (intr_enable_fifo_empty_qs)
495:   );
496: 
497:   //   F[hmac_err]: 2:2
498:   prim_subreg #(
499:     .DW      (1),
500:     .SwAccess(prim_subreg_pkg::SwAccessRW),
501:     .RESVAL  (1'h0),
502:     .Mubi    (1'b0)
503:   ) u_intr_enable_hmac_err (
504:     .clk_i   (clk_i),
505:     .rst_ni  (rst_ni),
506: 
507:     // from register interface
508:     .we     (intr_enable_we),
509:     .wd     (intr_enable_hmac_err_wd),
510: 
511:     // from internal hardware
512:     .de     (1'b0),
513:     .d      ('0),
514: 
515:     // to internal hardware
516:     .qe     (),
517:     .q      (reg2hw.intr_enable.hmac_err.q),
518:     .ds     (),
519: 
520:     // to register interface (read)
521:     .qs     (intr_enable_hmac_err_qs)
522:   );
523: 
524: 
525:   // R[intr_test]: V(True)
526:   logic intr_test_qe;
527:   logic [2:0] intr_test_flds_we;
528:   assign intr_test_qe = &intr_test_flds_we;
529:   //   F[hmac_done]: 0:0
530:   prim_subreg_ext #(
531:     .DW    (1)
532:   ) u_intr_test_hmac_done (
533:     .re     (1'b0),
534:     .we     (intr_test_we),
535:     .wd     (intr_test_hmac_done_wd),
536:     .d      ('0),
537:     .qre    (),
538:     .qe     (intr_test_flds_we[0]),
539:     .q      (reg2hw.intr_test.hmac_done.q),
540:     .ds     (),
541:     .qs     ()
542:   );
543:   assign reg2hw.intr_test.hmac_done.qe = intr_test_qe;
544: 
545:   //   F[fifo_empty]: 1:1
546:   prim_subreg_ext #(
547:     .DW    (1)
548:   ) u_intr_test_fifo_empty (
549:     .re     (1'b0),
550:     .we     (intr_test_we),
551:     .wd     (intr_test_fifo_empty_wd),
552:     .d      ('0),
553:     .qre    (),
554:     .qe     (intr_test_flds_we[1]),
555:     .q      (reg2hw.intr_test.fifo_empty.q),
556:     .ds     (),
557:     .qs     ()
558:   );
559:   assign reg2hw.intr_test.fifo_empty.qe = intr_test_qe;
560: 
561:   //   F[hmac_err]: 2:2
562:   prim_subreg_ext #(
563:     .DW    (1)
564:   ) u_intr_test_hmac_err (
565:     .re     (1'b0),
566:     .we     (intr_test_we),
567:     .wd     (intr_test_hmac_err_wd),
568:     .d      ('0),
569:     .qre    (),
570:     .qe     (intr_test_flds_we[2]),
571:     .q      (reg2hw.intr_test.hmac_err.q),
572:     .ds     (),
573:     .qs     ()
574:   );
575:   assign reg2hw.intr_test.hmac_err.qe = intr_test_qe;
576: 
577: 
578:   // R[alert_test]: V(True)
579:   logic alert_test_qe;
580:   logic [0:0] alert_test_flds_we;
581:   assign alert_test_qe = &alert_test_flds_we;
582:   prim_subreg_ext #(
583:     .DW    (1)
584:   ) u_alert_test (
585:     .re     (1'b0),
586:     .we     (alert_test_we),
587:     .wd     (alert_test_wd),
588:     .d      ('0),
589:     .qre    (),
590:     .qe     (alert_test_flds_we[0]),
591:     .q      (reg2hw.alert_test.q),
592:     .ds     (),
593:     .qs     ()
594:   );
595:   assign reg2hw.alert_test.qe = alert_test_qe;
596: 
597: 
598:   // R[cfg]: V(True)
599:   logic cfg_qe;
600:   logic [6:0] cfg_flds_we;
601:   assign cfg_qe = &cfg_flds_we;
602:   //   F[hmac_en]: 0:0
603:   prim_subreg_ext #(
604:     .DW    (1)
605:   ) u_cfg_hmac_en (
606:     .re     (cfg_re),
607:     .we     (cfg_we),
608:     .wd     (cfg_hmac_en_wd),
609:     .d      (hw2reg.cfg.hmac_en.d),
610:     .qre    (),
611:     .qe     (cfg_flds_we[0]),
612:     .q      (reg2hw.cfg.hmac_en.q),
613:     .ds     (),
614:     .qs     (cfg_hmac_en_qs)
615:   );
616:   assign reg2hw.cfg.hmac_en.qe = cfg_qe;
617: 
618:   //   F[sha_en]: 1:1
619:   prim_subreg_ext #(
620:     .DW    (1)
621:   ) u_cfg_sha_en (
622:     .re     (cfg_re),
623:     .we     (cfg_we),
624:     .wd     (cfg_sha_en_wd),
625:     .d      (hw2reg.cfg.sha_en.d),
626:     .qre    (),
627:     .qe     (cfg_flds_we[1]),
628:     .q      (reg2hw.cfg.sha_en.q),
629:     .ds     (),
630:     .qs     (cfg_sha_en_qs)
631:   );
632:   assign reg2hw.cfg.sha_en.qe = cfg_qe;
633: 
634:   //   F[endian_swap]: 2:2
635:   prim_subreg_ext #(
636:     .DW    (1)
637:   ) u_cfg_endian_swap (
638:     .re     (cfg_re),
639:     .we     (cfg_we),
640:     .wd     (cfg_endian_swap_wd),
641:     .d      (hw2reg.cfg.endian_swap.d),
642:     .qre    (),
643:     .qe     (cfg_flds_we[2]),
644:     .q      (reg2hw.cfg.endian_swap.q),
645:     .ds     (),
646:     .qs     (cfg_endian_swap_qs)
647:   );
648:   assign reg2hw.cfg.endian_swap.qe = cfg_qe;
649: 
650:   //   F[digest_swap]: 3:3
651:   prim_subreg_ext #(
652:     .DW    (1)
653:   ) u_cfg_digest_swap (
654:     .re     (cfg_re),
655:     .we     (cfg_we),
656:     .wd     (cfg_digest_swap_wd),
657:     .d      (hw2reg.cfg.digest_swap.d),
658:     .qre    (),
659:     .qe     (cfg_flds_we[3]),
660:     .q      (reg2hw.cfg.digest_swap.q),
661:     .ds     (),
662:     .qs     (cfg_digest_swap_qs)
663:   );
664:   assign reg2hw.cfg.digest_swap.qe = cfg_qe;
665: 
666:   //   F[key_swap]: 4:4
667:   prim_subreg_ext #(
668:     .DW    (1)
669:   ) u_cfg_key_swap (
670:     .re     (cfg_re),
671:     .we     (cfg_we),
672:     .wd     (cfg_key_swap_wd),
673:     .d      (hw2reg.cfg.key_swap.d),
674:     .qre    (),
675:     .qe     (cfg_flds_we[4]),
676:     .q      (reg2hw.cfg.key_swap.q),
677:     .ds     (),
678:     .qs     (cfg_key_swap_qs)
679:   );
680:   assign reg2hw.cfg.key_swap.qe = cfg_qe;
681: 
682:   //   F[digest_size]: 8:5
683:   prim_subreg_ext #(
684:     .DW    (4)
685:   ) u_cfg_digest_size (
686:     .re     (cfg_re),
687:     .we     (cfg_we),
688:     .wd     (cfg_digest_size_wd),
689:     .d      (hw2reg.cfg.digest_size.d),
690:     .qre    (),
691:     .qe     (cfg_flds_we[5]),
692:     .q      (reg2hw.cfg.digest_size.q),
693:     .ds     (),
694:     .qs     (cfg_digest_size_qs)
695:   );
696:   assign reg2hw.cfg.digest_size.qe = cfg_qe;
697: 
698:   //   F[key_length]: 14:9
699:   prim_subreg_ext #(
700:     .DW    (6)
701:   ) u_cfg_key_length (
702:     .re     (cfg_re),
703:     .we     (cfg_we),
704:     .wd     (cfg_key_length_wd),
705:     .d      (hw2reg.cfg.key_length.d),
706:     .qre    (),
707:     .qe     (cfg_flds_we[6]),
708:     .q      (reg2hw.cfg.key_length.q),
709:     .ds     (),
710:     .qs     (cfg_key_length_qs)
711:   );
712:   assign reg2hw.cfg.key_length.qe = cfg_qe;
713: 
714: 
715:   // R[cmd]: V(True)
716:   logic cmd_qe;
717:   logic [3:0] cmd_flds_we;
718:   assign cmd_qe = &cmd_flds_we;
719:   //   F[hash_start]: 0:0
720:   prim_subreg_ext #(
721:     .DW    (1)
722:   ) u_cmd_hash_start (
723:     .re     (1'b0),
724:     .we     (cmd_we),
725:     .wd     (cmd_hash_start_wd),
726:     .d      ('0),
727:     .qre    (),
728:     .qe     (cmd_flds_we[0]),
729:     .q      (reg2hw.cmd.hash_start.q),
730:     .ds     (),
731:     .qs     ()
732:   );
733:   assign reg2hw.cmd.hash_start.qe = cmd_qe;
734: 
735:   //   F[hash_process]: 1:1
736:   prim_subreg_ext #(
737:     .DW    (1)
738:   ) u_cmd_hash_process (
739:     .re     (1'b0),
740:     .we     (cmd_we),
741:     .wd     (cmd_hash_process_wd),
742:     .d      ('0),
743:     .qre    (),
744:     .qe     (cmd_flds_we[1]),
745:     .q      (reg2hw.cmd.hash_process.q),
746:     .ds     (),
747:     .qs     ()
748:   );
749:   assign reg2hw.cmd.hash_process.qe = cmd_qe;
750: 
751:   //   F[hash_stop]: 2:2
752:   prim_subreg_ext #(
753:     .DW    (1)
754:   ) u_cmd_hash_stop (
755:     .re     (1'b0),
756:     .we     (cmd_we),
757:     .wd     (cmd_hash_stop_wd),
758:     .d      ('0),
759:     .qre    (),
760:     .qe     (cmd_flds_we[2]),
761:     .q      (reg2hw.cmd.hash_stop.q),
762:     .ds     (),
763:     .qs     ()
764:   );
765:   assign reg2hw.cmd.hash_stop.qe = cmd_qe;
766: 
767:   //   F[hash_continue]: 3:3
768:   prim_subreg_ext #(
769:     .DW    (1)
770:   ) u_cmd_hash_continue (
771:     .re     (1'b0),
772:     .we     (cmd_we),
773:     .wd     (cmd_hash_continue_wd),
774:     .d      ('0),
775:     .qre    (),
776:     .qe     (cmd_flds_we[3]),
777:     .q      (reg2hw.cmd.hash_continue.q),
778:     .ds     (),
779:     .qs     ()
780:   );
781:   assign reg2hw.cmd.hash_continue.qe = cmd_qe;
782: 
783: 
784:   // R[status]: V(True)
785:   //   F[hmac_idle]: 0:0
786:   prim_subreg_ext #(
787:     .DW    (1)
788:   ) u_status_hmac_idle (
789:     .re     (status_re),
790:     .we     (1'b0),
791:     .wd     ('0),
792:     .d      (hw2reg.status.hmac_idle.d),
793:     .qre    (),
794:     .qe     (),
795:     .q      (),
796:     .ds     (),
797:     .qs     (status_hmac_idle_qs)
798:   );
799: 
800:   //   F[fifo_empty]: 1:1
801:   prim_subreg_ext #(
802:     .DW    (1)
803:   ) u_status_fifo_empty (
804:     .re     (status_re),
805:     .we     (1'b0),
806:     .wd     ('0),
807:     .d      (hw2reg.status.fifo_empty.d),
808:     .qre    (),
809:     .qe     (),
810:     .q      (),
811:     .ds     (),
812:     .qs     (status_fifo_empty_qs)
813:   );
814: 
815:   //   F[fifo_full]: 2:2
816:   prim_subreg_ext #(
817:     .DW    (1)
818:   ) u_status_fifo_full (
819:     .re     (status_re),
820:     .we     (1'b0),
821:     .wd     ('0),
822:     .d      (hw2reg.status.fifo_full.d),
823:     .qre    (),
824:     .qe     (),
825:     .q      (),
826:     .ds     (),
827:     .qs     (status_fifo_full_qs)
828:   );
829: 
830:   //   F[fifo_depth]: 9:4
831:   prim_subreg_ext #(
832:     .DW    (6)
833:   ) u_status_fifo_depth (
834:     .re     (status_re),
835:     .we     (1'b0),
836:     .wd     ('0),
837:     .d      (hw2reg.status.fifo_depth.d),
838:     .qre    (),
839:     .qe     (),
840:     .q      (),
841:     .ds     (),
842:     .qs     (status_fifo_depth_qs)
843:   );
844: 
845: 
846:   // R[err_code]: V(False)
847:   prim_subreg #(
848:     .DW      (32),
849:     .SwAccess(prim_subreg_pkg::SwAccessRO),
850:     .RESVAL  (32'h0),
851:     .Mubi    (1'b0)
852:   ) u_err_code (
853:     .clk_i   (clk_i),
854:     .rst_ni  (rst_ni),
855: 
856:     // from register interface
857:     .we     (1'b0),
858:     .wd     ('0),
859: 
860:     // from internal hardware
861:     .de     (hw2reg.err_code.de),
862:     .d      (hw2reg.err_code.d),
863: 
864:     // to internal hardware
865:     .qe     (),
866:     .q      (),
867:     .ds     (),
868: 
869:     // to register interface (read)
870:     .qs     (err_code_qs)
871:   );
872: 
873: 
874:   // R[wipe_secret]: V(True)
875:   logic wipe_secret_qe;
876:   logic [0:0] wipe_secret_flds_we;
877:   assign wipe_secret_qe = &wipe_secret_flds_we;
878:   prim_subreg_ext #(
879:     .DW    (32)
880:   ) u_wipe_secret (
881:     .re     (1'b0),
882:     .we     (wipe_secret_we),
883:     .wd     (wipe_secret_wd),
884:     .d      ('0),
885:     .qre    (),
886:     .qe     (wipe_secret_flds_we[0]),
887:     .q      (reg2hw.wipe_secret.q),
888:     .ds     (),
889:     .qs     ()
890:   );
891:   assign reg2hw.wipe_secret.qe = wipe_secret_qe;
892: 
893: 
894:   // Subregister 0 of Multireg key
895:   // R[key_0]: V(True)
896:   logic key_0_qe;
897:   logic [0:0] key_0_flds_we;
898:   assign key_0_qe = &key_0_flds_we;
899:   prim_subreg_ext #(
900:     .DW    (32)
901:   ) u_key_0 (
902:     .re     (1'b0),
903:     .we     (key_0_we),
904:     .wd     (key_0_wd),
905:     .d      (hw2reg.key[0].d),
906:     .qre    (),
907:     .qe     (key_0_flds_we[0]),
908:     .q      (reg2hw.key[0].q),
909:     .ds     (),
910:     .qs     ()
911:   );
912:   assign reg2hw.key[0].qe = key_0_qe;
913: 
914: 
915:   // Subregister 1 of Multireg key
916:   // R[key_1]: V(True)
917:   logic key_1_qe;
918:   logic [0:0] key_1_flds_we;
919:   assign key_1_qe = &key_1_flds_we;
920:   prim_subreg_ext #(
921:     .DW    (32)
922:   ) u_key_1 (
923:     .re     (1'b0),
924:     .we     (key_1_we),
925:     .wd     (key_1_wd),
926:     .d      (hw2reg.key[1].d),
927:     .qre    (),
928:     .qe     (key_1_flds_we[0]),
929:     .q      (reg2hw.key[1].q),
930:     .ds     (),
931:     .qs     ()
932:   );
933:   assign reg2hw.key[1].qe = key_1_qe;
934: 
935: 
936:   // Subregister 2 of Multireg key
937:   // R[key_2]: V(True)
938:   logic key_2_qe;
939:   logic [0:0] key_2_flds_we;
940:   assign key_2_qe = &key_2_flds_we;
941:   prim_subreg_ext #(
942:     .DW    (32)
943:   ) u_key_2 (
944:     .re     (1'b0),
945:     .we     (key_2_we),
946:     .wd     (key_2_wd),
947:     .d      (hw2reg.key[2].d),
948:     .qre    (),
949:     .qe     (key_2_flds_we[0]),
950:     .q      (reg2hw.key[2].q),
951:     .ds     (),
952:     .qs     ()
953:   );
954:   assign reg2hw.key[2].qe = key_2_qe;
955: 
956: 
957:   // Subregister 3 of Multireg key
958:   // R[key_3]: V(True)
959:   logic key_3_qe;
960:   logic [0:0] key_3_flds_we;
961:   assign key_3_qe = &key_3_flds_we;
962:   prim_subreg_ext #(
963:     .DW    (32)
964:   ) u_key_3 (
965:     .re     (1'b0),
966:     .we     (key_3_we),
967:     .wd     (key_3_wd),
968:     .d      (hw2reg.key[3].d),
969:     .qre    (),
970:     .qe     (key_3_flds_we[0]),
971:     .q      (reg2hw.key[3].q),
972:     .ds     (),
973:     .qs     ()
974:   );
975:   assign reg2hw.key[3].qe = key_3_qe;
976: 
977: 
978:   // Subregister 4 of Multireg key
979:   // R[key_4]: V(True)
980:   logic key_4_qe;
981:   logic [0:0] key_4_flds_we;
982:   assign key_4_qe = &key_4_flds_we;
983:   prim_subreg_ext #(
984:     .DW    (32)
985:   ) u_key_4 (
986:     .re     (1'b0),
987:     .we     (key_4_we),
988:     .wd     (key_4_wd),
989:     .d      (hw2reg.key[4].d),
990:     .qre    (),
991:     .qe     (key_4_flds_we[0]),
992:     .q      (reg2hw.key[4].q),
993:     .ds     (),
994:     .qs     ()
995:   );
996:   assign reg2hw.key[4].qe = key_4_qe;
997: 
998: 
999:   // Subregister 5 of Multireg key
1000:   // R[key_5]: V(True)
1001:   logic key_5_qe;
1002:   logic [0:0] key_5_flds_we;
1003:   assign key_5_qe = &key_5_flds_we;
1004:   prim_subreg_ext #(
1005:     .DW    (32)
1006:   ) u_key_5 (
1007:     .re     (1'b0),
1008:     .we     (key_5_we),
1009:     .wd     (key_5_wd),
1010:     .d      (hw2reg.key[5].d),
1011:     .qre    (),
1012:     .qe     (key_5_flds_we[0]),
1013:     .q      (reg2hw.key[5].q),
1014:     .ds     (),
1015:     .qs     ()
1016:   );
1017:   assign reg2hw.key[5].qe = key_5_qe;
1018: 
1019: 
1020:   // Subregister 6 of Multireg key
1021:   // R[key_6]: V(True)
1022:   logic key_6_qe;
1023:   logic [0:0] key_6_flds_we;
1024:   assign key_6_qe = &key_6_flds_we;
1025:   prim_subreg_ext #(
1026:     .DW    (32)
1027:   ) u_key_6 (
1028:     .re     (1'b0),
1029:     .we     (key_6_we),
1030:     .wd     (key_6_wd),
1031:     .d      (hw2reg.key[6].d),
1032:     .qre    (),
1033:     .qe     (key_6_flds_we[0]),
1034:     .q      (reg2hw.key[6].q),
1035:     .ds     (),
1036:     .qs     ()
1037:   );
1038:   assign reg2hw.key[6].qe = key_6_qe;
1039: 
1040: 
1041:   // Subregister 7 of Multireg key
1042:   // R[key_7]: V(True)
1043:   logic key_7_qe;
1044:   logic [0:0] key_7_flds_we;
1045:   assign key_7_qe = &key_7_flds_we;
1046:   prim_subreg_ext #(
1047:     .DW    (32)
1048:   ) u_key_7 (
1049:     .re     (1'b0),
1050:     .we     (key_7_we),
1051:     .wd     (key_7_wd),
1052:     .d      (hw2reg.key[7].d),
1053:     .qre    (),
1054:     .qe     (key_7_flds_we[0]),
1055:     .q      (reg2hw.key[7].q),
1056:     .ds     (),
1057:     .qs     ()
1058:   );
1059:   assign reg2hw.key[7].qe = key_7_qe;
1060: 
1061: 
1062:   // Subregister 8 of Multireg key
1063:   // R[key_8]: V(True)
1064:   logic key_8_qe;
1065:   logic [0:0] key_8_flds_we;
1066:   assign key_8_qe = &key_8_flds_we;
1067:   prim_subreg_ext #(
1068:     .DW    (32)
1069:   ) u_key_8 (
1070:     .re     (1'b0),
1071:     .we     (key_8_we),
1072:     .wd     (key_8_wd),
1073:     .d      (hw2reg.key[8].d),
1074:     .qre    (),
1075:     .qe     (key_8_flds_we[0]),
1076:     .q      (reg2hw.key[8].q),
1077:     .ds     (),
1078:     .qs     ()
1079:   );
1080:   assign reg2hw.key[8].qe = key_8_qe;
1081: 
1082: 
1083:   // Subregister 9 of Multireg key
1084:   // R[key_9]: V(True)
1085:   logic key_9_qe;
1086:   logic [0:0] key_9_flds_we;
1087:   assign key_9_qe = &key_9_flds_we;
1088:   prim_subreg_ext #(
1089:     .DW    (32)
1090:   ) u_key_9 (
1091:     .re     (1'b0),
1092:     .we     (key_9_we),
1093:     .wd     (key_9_wd),
1094:     .d      (hw2reg.key[9].d),
1095:     .qre    (),
1096:     .qe     (key_9_flds_we[0]),
1097:     .q      (reg2hw.key[9].q),
1098:     .ds     (),
1099:     .qs     ()
1100:   );
1101:   assign reg2hw.key[9].qe = key_9_qe;
1102: 
1103: 
1104:   // Subregister 10 of Multireg key
1105:   // R[key_10]: V(True)
1106:   logic key_10_qe;
1107:   logic [0:0] key_10_flds_we;
1108:   assign key_10_qe = &key_10_flds_we;
1109:   prim_subreg_ext #(
1110:     .DW    (32)
1111:   ) u_key_10 (
1112:     .re     (1'b0),
1113:     .we     (key_10_we),
1114:     .wd     (key_10_wd),
1115:     .d      (hw2reg.key[10].d),
1116:     .qre    (),
1117:     .qe     (key_10_flds_we[0]),
1118:     .q      (reg2hw.key[10].q),
1119:     .ds     (),
1120:     .qs     ()
1121:   );
1122:   assign reg2hw.key[10].qe = key_10_qe;
1123: 
1124: 
1125:   // Subregister 11 of Multireg key
1126:   // R[key_11]: V(True)
1127:   logic key_11_qe;
1128:   logic [0:0] key_11_flds_we;
1129:   assign key_11_qe = &key_11_flds_we;
1130:   prim_subreg_ext #(
1131:     .DW    (32)
1132:   ) u_key_11 (
1133:     .re     (1'b0),
1134:     .we     (key_11_we),
1135:     .wd     (key_11_wd),
1136:     .d      (hw2reg.key[11].d),
1137:     .qre    (),
1138:     .qe     (key_11_flds_we[0]),
1139:     .q      (reg2hw.key[11].q),
1140:     .ds     (),
1141:     .qs     ()
1142:   );
1143:   assign reg2hw.key[11].qe = key_11_qe;
1144: 
1145: 
1146:   // Subregister 12 of Multireg key
1147:   // R[key_12]: V(True)
1148:   logic key_12_qe;
1149:   logic [0:0] key_12_flds_we;
1150:   assign key_12_qe = &key_12_flds_we;
1151:   prim_subreg_ext #(
1152:     .DW    (32)
1153:   ) u_key_12 (
1154:     .re     (1'b0),
1155:     .we     (key_12_we),
1156:     .wd     (key_12_wd),
1157:     .d      (hw2reg.key[12].d),
1158:     .qre    (),
1159:     .qe     (key_12_flds_we[0]),
1160:     .q      (reg2hw.key[12].q),
1161:     .ds     (),
1162:     .qs     ()
1163:   );
1164:   assign reg2hw.key[12].qe = key_12_qe;
1165: 
1166: 
1167:   // Subregister 13 of Multireg key
1168:   // R[key_13]: V(True)
1169:   logic key_13_qe;
1170:   logic [0:0] key_13_flds_we;
1171:   assign key_13_qe = &key_13_flds_we;
1172:   prim_subreg_ext #(
1173:     .DW    (32)
1174:   ) u_key_13 (
1175:     .re     (1'b0),
1176:     .we     (key_13_we),
1177:     .wd     (key_13_wd),
1178:     .d      (hw2reg.key[13].d),
1179:     .qre    (),
1180:     .qe     (key_13_flds_we[0]),
1181:     .q      (reg2hw.key[13].q),
1182:     .ds     (),
1183:     .qs     ()
1184:   );
1185:   assign reg2hw.key[13].qe = key_13_qe;
1186: 
1187: 
1188:   // Subregister 14 of Multireg key
1189:   // R[key_14]: V(True)
1190:   logic key_14_qe;
1191:   logic [0:0] key_14_flds_we;
1192:   assign key_14_qe = &key_14_flds_we;
1193:   prim_subreg_ext #(
1194:     .DW    (32)
1195:   ) u_key_14 (
1196:     .re     (1'b0),
1197:     .we     (key_14_we),
1198:     .wd     (key_14_wd),
1199:     .d      (hw2reg.key[14].d),
1200:     .qre    (),
1201:     .qe     (key_14_flds_we[0]),
1202:     .q      (reg2hw.key[14].q),
1203:     .ds     (),
1204:     .qs     ()
1205:   );
1206:   assign reg2hw.key[14].qe = key_14_qe;
1207: 
1208: 
1209:   // Subregister 15 of Multireg key
1210:   // R[key_15]: V(True)
1211:   logic key_15_qe;
1212:   logic [0:0] key_15_flds_we;
1213:   assign key_15_qe = &key_15_flds_we;
1214:   prim_subreg_ext #(
1215:     .DW    (32)
1216:   ) u_key_15 (
1217:     .re     (1'b0),
1218:     .we     (key_15_we),
1219:     .wd     (key_15_wd),
1220:     .d      (hw2reg.key[15].d),
1221:     .qre    (),
1222:     .qe     (key_15_flds_we[0]),
1223:     .q      (reg2hw.key[15].q),
1224:     .ds     (),
1225:     .qs     ()
1226:   );
1227:   assign reg2hw.key[15].qe = key_15_qe;
1228: 
1229: 
1230:   // Subregister 16 of Multireg key
1231:   // R[key_16]: V(True)
1232:   logic key_16_qe;
1233:   logic [0:0] key_16_flds_we;
1234:   assign key_16_qe = &key_16_flds_we;
1235:   prim_subreg_ext #(
1236:     .DW    (32)
1237:   ) u_key_16 (
1238:     .re     (1'b0),
1239:     .we     (key_16_we),
1240:     .wd     (key_16_wd),
1241:     .d      (hw2reg.key[16].d),
1242:     .qre    (),
1243:     .qe     (key_16_flds_we[0]),
1244:     .q      (reg2hw.key[16].q),
1245:     .ds     (),
1246:     .qs     ()
1247:   );
1248:   assign reg2hw.key[16].qe = key_16_qe;
1249: 
1250: 
1251:   // Subregister 17 of Multireg key
1252:   // R[key_17]: V(True)
1253:   logic key_17_qe;
1254:   logic [0:0] key_17_flds_we;
1255:   assign key_17_qe = &key_17_flds_we;
1256:   prim_subreg_ext #(
1257:     .DW    (32)
1258:   ) u_key_17 (
1259:     .re     (1'b0),
1260:     .we     (key_17_we),
1261:     .wd     (key_17_wd),
1262:     .d      (hw2reg.key[17].d),
1263:     .qre    (),
1264:     .qe     (key_17_flds_we[0]),
1265:     .q      (reg2hw.key[17].q),
1266:     .ds     (),
1267:     .qs     ()
1268:   );
1269:   assign reg2hw.key[17].qe = key_17_qe;
1270: 
1271: 
1272:   // Subregister 18 of Multireg key
1273:   // R[key_18]: V(True)
1274:   logic key_18_qe;
1275:   logic [0:0] key_18_flds_we;
1276:   assign key_18_qe = &key_18_flds_we;
1277:   prim_subreg_ext #(
1278:     .DW    (32)
1279:   ) u_key_18 (
1280:     .re     (1'b0),
1281:     .we     (key_18_we),
1282:     .wd     (key_18_wd),
1283:     .d      (hw2reg.key[18].d),
1284:     .qre    (),
1285:     .qe     (key_18_flds_we[0]),
1286:     .q      (reg2hw.key[18].q),
1287:     .ds     (),
1288:     .qs     ()
1289:   );
1290:   assign reg2hw.key[18].qe = key_18_qe;
1291: 
1292: 
1293:   // Subregister 19 of Multireg key
1294:   // R[key_19]: V(True)
1295:   logic key_19_qe;
1296:   logic [0:0] key_19_flds_we;
1297:   assign key_19_qe = &key_19_flds_we;
1298:   prim_subreg_ext #(
1299:     .DW    (32)
1300:   ) u_key_19 (
1301:     .re     (1'b0),
1302:     .we     (key_19_we),
1303:     .wd     (key_19_wd),
1304:     .d      (hw2reg.key[19].d),
1305:     .qre    (),
1306:     .qe     (key_19_flds_we[0]),
1307:     .q      (reg2hw.key[19].q),
1308:     .ds     (),
1309:     .qs     ()
1310:   );
1311:   assign reg2hw.key[19].qe = key_19_qe;
1312: 
1313: 
1314:   // Subregister 20 of Multireg key
1315:   // R[key_20]: V(True)
1316:   logic key_20_qe;
1317:   logic [0:0] key_20_flds_we;
1318:   assign key_20_qe = &key_20_flds_we;
1319:   prim_subreg_ext #(
1320:     .DW    (32)
1321:   ) u_key_20 (
1322:     .re     (1'b0),
1323:     .we     (key_20_we),
1324:     .wd     (key_20_wd),
1325:     .d      (hw2reg.key[20].d),
1326:     .qre    (),
1327:     .qe     (key_20_flds_we[0]),
1328:     .q      (reg2hw.key[20].q),
1329:     .ds     (),
1330:     .qs     ()
1331:   );
1332:   assign reg2hw.key[20].qe = key_20_qe;
1333: 
1334: 
1335:   // Subregister 21 of Multireg key
1336:   // R[key_21]: V(True)
1337:   logic key_21_qe;
1338:   logic [0:0] key_21_flds_we;
1339:   assign key_21_qe = &key_21_flds_we;
1340:   prim_subreg_ext #(
1341:     .DW    (32)
1342:   ) u_key_21 (
1343:     .re     (1'b0),
1344:     .we     (key_21_we),
1345:     .wd     (key_21_wd),
1346:     .d      (hw2reg.key[21].d),
1347:     .qre    (),
1348:     .qe     (key_21_flds_we[0]),
1349:     .q      (reg2hw.key[21].q),
1350:     .ds     (),
1351:     .qs     ()
1352:   );
1353:   assign reg2hw.key[21].qe = key_21_qe;
1354: 
1355: 
1356:   // Subregister 22 of Multireg key
1357:   // R[key_22]: V(True)
1358:   logic key_22_qe;
1359:   logic [0:0] key_22_flds_we;
1360:   assign key_22_qe = &key_22_flds_we;
1361:   prim_subreg_ext #(
1362:     .DW    (32)
1363:   ) u_key_22 (
1364:     .re     (1'b0),
1365:     .we     (key_22_we),
1366:     .wd     (key_22_wd),
1367:     .d      (hw2reg.key[22].d),
1368:     .qre    (),
1369:     .qe     (key_22_flds_we[0]),
1370:     .q      (reg2hw.key[22].q),
1371:     .ds     (),
1372:     .qs     ()
1373:   );
1374:   assign reg2hw.key[22].qe = key_22_qe;
1375: 
1376: 
1377:   // Subregister 23 of Multireg key
1378:   // R[key_23]: V(True)
1379:   logic key_23_qe;
1380:   logic [0:0] key_23_flds_we;
1381:   assign key_23_qe = &key_23_flds_we;
1382:   prim_subreg_ext #(
1383:     .DW    (32)
1384:   ) u_key_23 (
1385:     .re     (1'b0),
1386:     .we     (key_23_we),
1387:     .wd     (key_23_wd),
1388:     .d      (hw2reg.key[23].d),
1389:     .qre    (),
1390:     .qe     (key_23_flds_we[0]),
1391:     .q      (reg2hw.key[23].q),
1392:     .ds     (),
1393:     .qs     ()
1394:   );
1395:   assign reg2hw.key[23].qe = key_23_qe;
1396: 
1397: 
1398:   // Subregister 24 of Multireg key
1399:   // R[key_24]: V(True)
1400:   logic key_24_qe;
1401:   logic [0:0] key_24_flds_we;
1402:   assign key_24_qe = &key_24_flds_we;
1403:   prim_subreg_ext #(
1404:     .DW    (32)
1405:   ) u_key_24 (
1406:     .re     (1'b0),
1407:     .we     (key_24_we),
1408:     .wd     (key_24_wd),
1409:     .d      (hw2reg.key[24].d),
1410:     .qre    (),
1411:     .qe     (key_24_flds_we[0]),
1412:     .q      (reg2hw.key[24].q),
1413:     .ds     (),
1414:     .qs     ()
1415:   );
1416:   assign reg2hw.key[24].qe = key_24_qe;
1417: 
1418: 
1419:   // Subregister 25 of Multireg key
1420:   // R[key_25]: V(True)
1421:   logic key_25_qe;
1422:   logic [0:0] key_25_flds_we;
1423:   assign key_25_qe = &key_25_flds_we;
1424:   prim_subreg_ext #(
1425:     .DW    (32)
1426:   ) u_key_25 (
1427:     .re     (1'b0),
1428:     .we     (key_25_we),
1429:     .wd     (key_25_wd),
1430:     .d      (hw2reg.key[25].d),
1431:     .qre    (),
1432:     .qe     (key_25_flds_we[0]),
1433:     .q      (reg2hw.key[25].q),
1434:     .ds     (),
1435:     .qs     ()
1436:   );
1437:   assign reg2hw.key[25].qe = key_25_qe;
1438: 
1439: 
1440:   // Subregister 26 of Multireg key
1441:   // R[key_26]: V(True)
1442:   logic key_26_qe;
1443:   logic [0:0] key_26_flds_we;
1444:   assign key_26_qe = &key_26_flds_we;
1445:   prim_subreg_ext #(
1446:     .DW    (32)
1447:   ) u_key_26 (
1448:     .re     (1'b0),
1449:     .we     (key_26_we),
1450:     .wd     (key_26_wd),
1451:     .d      (hw2reg.key[26].d),
1452:     .qre    (),
1453:     .qe     (key_26_flds_we[0]),
1454:     .q      (reg2hw.key[26].q),
1455:     .ds     (),
1456:     .qs     ()
1457:   );
1458:   assign reg2hw.key[26].qe = key_26_qe;
1459: 
1460: 
1461:   // Subregister 27 of Multireg key
1462:   // R[key_27]: V(True)
1463:   logic key_27_qe;
1464:   logic [0:0] key_27_flds_we;
1465:   assign key_27_qe = &key_27_flds_we;
1466:   prim_subreg_ext #(
1467:     .DW    (32)
1468:   ) u_key_27 (
1469:     .re     (1'b0),
1470:     .we     (key_27_we),
1471:     .wd     (key_27_wd),
1472:     .d      (hw2reg.key[27].d),
1473:     .qre    (),
1474:     .qe     (key_27_flds_we[0]),
1475:     .q      (reg2hw.key[27].q),
1476:     .ds     (),
1477:     .qs     ()
1478:   );
1479:   assign reg2hw.key[27].qe = key_27_qe;
1480: 
1481: 
1482:   // Subregister 28 of Multireg key
1483:   // R[key_28]: V(True)
1484:   logic key_28_qe;
1485:   logic [0:0] key_28_flds_we;
1486:   assign key_28_qe = &key_28_flds_we;
1487:   prim_subreg_ext #(
1488:     .DW    (32)
1489:   ) u_key_28 (
1490:     .re     (1'b0),
1491:     .we     (key_28_we),
1492:     .wd     (key_28_wd),
1493:     .d      (hw2reg.key[28].d),
1494:     .qre    (),
1495:     .qe     (key_28_flds_we[0]),
1496:     .q      (reg2hw.key[28].q),
1497:     .ds     (),
1498:     .qs     ()
1499:   );
1500:   assign reg2hw.key[28].qe = key_28_qe;
1501: 
1502: 
1503:   // Subregister 29 of Multireg key
1504:   // R[key_29]: V(True)
1505:   logic key_29_qe;
1506:   logic [0:0] key_29_flds_we;
1507:   assign key_29_qe = &key_29_flds_we;
1508:   prim_subreg_ext #(
1509:     .DW    (32)
1510:   ) u_key_29 (
1511:     .re     (1'b0),
1512:     .we     (key_29_we),
1513:     .wd     (key_29_wd),
1514:     .d      (hw2reg.key[29].d),
1515:     .qre    (),
1516:     .qe     (key_29_flds_we[0]),
1517:     .q      (reg2hw.key[29].q),
1518:     .ds     (),
1519:     .qs     ()
1520:   );
1521:   assign reg2hw.key[29].qe = key_29_qe;
1522: 
1523: 
1524:   // Subregister 30 of Multireg key
1525:   // R[key_30]: V(True)
1526:   logic key_30_qe;
1527:   logic [0:0] key_30_flds_we;
1528:   assign key_30_qe = &key_30_flds_we;
1529:   prim_subreg_ext #(
1530:     .DW    (32)
1531:   ) u_key_30 (
1532:     .re     (1'b0),
1533:     .we     (key_30_we),
1534:     .wd     (key_30_wd),
1535:     .d      (hw2reg.key[30].d),
1536:     .qre    (),
1537:     .qe     (key_30_flds_we[0]),
1538:     .q      (reg2hw.key[30].q),
1539:     .ds     (),
1540:     .qs     ()
1541:   );
1542:   assign reg2hw.key[30].qe = key_30_qe;
1543: 
1544: 
1545:   // Subregister 31 of Multireg key
1546:   // R[key_31]: V(True)
1547:   logic key_31_qe;
1548:   logic [0:0] key_31_flds_we;
1549:   assign key_31_qe = &key_31_flds_we;
1550:   prim_subreg_ext #(
1551:     .DW    (32)
1552:   ) u_key_31 (
1553:     .re     (1'b0),
1554:     .we     (key_31_we),
1555:     .wd     (key_31_wd),
1556:     .d      (hw2reg.key[31].d),
1557:     .qre    (),
1558:     .qe     (key_31_flds_we[0]),
1559:     .q      (reg2hw.key[31].q),
1560:     .ds     (),
1561:     .qs     ()
1562:   );
1563:   assign reg2hw.key[31].qe = key_31_qe;
1564: 
1565: 
1566:   // Subregister 0 of Multireg digest
1567:   // R[digest_0]: V(True)
1568:   logic digest_0_qe;
1569:   logic [0:0] digest_0_flds_we;
1570:   assign digest_0_qe = &digest_0_flds_we;
1571:   prim_subreg_ext #(
1572:     .DW    (32)
1573:   ) u_digest_0 (
1574:     .re     (digest_0_re),
1575:     .we     (digest_0_we),
1576:     .wd     (digest_0_wd),
1577:     .d      (hw2reg.digest[0].d),
1578:     .qre    (),
1579:     .qe     (digest_0_flds_we[0]),
1580:     .q      (reg2hw.digest[0].q),
1581:     .ds     (),
1582:     .qs     (digest_0_qs)
1583:   );
1584:   assign reg2hw.digest[0].qe = digest_0_qe;
1585: 
1586: 
1587:   // Subregister 1 of Multireg digest
1588:   // R[digest_1]: V(True)
1589:   logic digest_1_qe;
1590:   logic [0:0] digest_1_flds_we;
1591:   assign digest_1_qe = &digest_1_flds_we;
1592:   prim_subreg_ext #(
1593:     .DW    (32)
1594:   ) u_digest_1 (
1595:     .re     (digest_1_re),
1596:     .we     (digest_1_we),
1597:     .wd     (digest_1_wd),
1598:     .d      (hw2reg.digest[1].d),
1599:     .qre    (),
1600:     .qe     (digest_1_flds_we[0]),
1601:     .q      (reg2hw.digest[1].q),
1602:     .ds     (),
1603:     .qs     (digest_1_qs)
1604:   );
1605:   assign reg2hw.digest[1].qe = digest_1_qe;
1606: 
1607: 
1608:   // Subregister 2 of Multireg digest
1609:   // R[digest_2]: V(True)
1610:   logic digest_2_qe;
1611:   logic [0:0] digest_2_flds_we;
1612:   assign digest_2_qe = &digest_2_flds_we;
1613:   prim_subreg_ext #(
1614:     .DW    (32)
1615:   ) u_digest_2 (
1616:     .re     (digest_2_re),
1617:     .we     (digest_2_we),
1618:     .wd     (digest_2_wd),
1619:     .d      (hw2reg.digest[2].d),
1620:     .qre    (),
1621:     .qe     (digest_2_flds_we[0]),
1622:     .q      (reg2hw.digest[2].q),
1623:     .ds     (),
1624:     .qs     (digest_2_qs)
1625:   );
1626:   assign reg2hw.digest[2].qe = digest_2_qe;
1627: 
1628: 
1629:   // Subregister 3 of Multireg digest
1630:   // R[digest_3]: V(True)
1631:   logic digest_3_qe;
1632:   logic [0:0] digest_3_flds_we;
1633:   assign digest_3_qe = &digest_3_flds_we;
1634:   prim_subreg_ext #(
1635:     .DW    (32)
1636:   ) u_digest_3 (
1637:     .re     (digest_3_re),
1638:     .we     (digest_3_we),
1639:     .wd     (digest_3_wd),
1640:     .d      (hw2reg.digest[3].d),
1641:     .qre    (),
1642:     .qe     (digest_3_flds_we[0]),
1643:     .q      (reg2hw.digest[3].q),
1644:     .ds     (),
1645:     .qs     (digest_3_qs)
1646:   );
1647:   assign reg2hw.digest[3].qe = digest_3_qe;
1648: 
1649: 
1650:   // Subregister 4 of Multireg digest
1651:   // R[digest_4]: V(True)
1652:   logic digest_4_qe;
1653:   logic [0:0] digest_4_flds_we;
1654:   assign digest_4_qe = &digest_4_flds_we;
1655:   prim_subreg_ext #(
1656:     .DW    (32)
1657:   ) u_digest_4 (
1658:     .re     (digest_4_re),
1659:     .we     (digest_4_we),
1660:     .wd     (digest_4_wd),
1661:     .d      (hw2reg.digest[4].d),
1662:     .qre    (),
1663:     .qe     (digest_4_flds_we[0]),
1664:     .q      (reg2hw.digest[4].q),
1665:     .ds     (),
1666:     .qs     (digest_4_qs)
1667:   );
1668:   assign reg2hw.digest[4].qe = digest_4_qe;
1669: 
1670: 
1671:   // Subregister 5 of Multireg digest
1672:   // R[digest_5]: V(True)
1673:   logic digest_5_qe;
1674:   logic [0:0] digest_5_flds_we;
1675:   assign digest_5_qe = &digest_5_flds_we;
1676:   prim_subreg_ext #(
1677:     .DW    (32)
1678:   ) u_digest_5 (
1679:     .re     (digest_5_re),
1680:     .we     (digest_5_we),
1681:     .wd     (digest_5_wd),
1682:     .d      (hw2reg.digest[5].d),
1683:     .qre    (),
1684:     .qe     (digest_5_flds_we[0]),
1685:     .q      (reg2hw.digest[5].q),
1686:     .ds     (),
1687:     .qs     (digest_5_qs)
1688:   );
1689:   assign reg2hw.digest[5].qe = digest_5_qe;
1690: 
1691: 
1692:   // Subregister 6 of Multireg digest
1693:   // R[digest_6]: V(True)
1694:   logic digest_6_qe;
1695:   logic [0:0] digest_6_flds_we;
1696:   assign digest_6_qe = &digest_6_flds_we;
1697:   prim_subreg_ext #(
1698:     .DW    (32)
1699:   ) u_digest_6 (
1700:     .re     (digest_6_re),
1701:     .we     (digest_6_we),
1702:     .wd     (digest_6_wd),
1703:     .d      (hw2reg.digest[6].d),
1704:     .qre    (),
1705:     .qe     (digest_6_flds_we[0]),
1706:     .q      (reg2hw.digest[6].q),
1707:     .ds     (),
1708:     .qs     (digest_6_qs)
1709:   );
1710:   assign reg2hw.digest[6].qe = digest_6_qe;
1711: 
1712: 
1713:   // Subregister 7 of Multireg digest
1714:   // R[digest_7]: V(True)
1715:   logic digest_7_qe;
1716:   logic [0:0] digest_7_flds_we;
1717:   assign digest_7_qe = &digest_7_flds_we;
1718:   prim_subreg_ext #(
1719:     .DW    (32)
1720:   ) u_digest_7 (
1721:     .re     (digest_7_re),
1722:     .we     (digest_7_we),
1723:     .wd     (digest_7_wd),
1724:     .d      (hw2reg.digest[7].d),
1725:     .qre    (),
1726:     .qe     (digest_7_flds_we[0]),
1727:     .q      (reg2hw.digest[7].q),
1728:     .ds     (),
1729:     .qs     (digest_7_qs)
1730:   );
1731:   assign reg2hw.digest[7].qe = digest_7_qe;
1732: 
1733: 
1734:   // Subregister 8 of Multireg digest
1735:   // R[digest_8]: V(True)
1736:   logic digest_8_qe;
1737:   logic [0:0] digest_8_flds_we;
1738:   assign digest_8_qe = &digest_8_flds_we;
1739:   prim_subreg_ext #(
1740:     .DW    (32)
1741:   ) u_digest_8 (
1742:     .re     (digest_8_re),
1743:     .we     (digest_8_we),
1744:     .wd     (digest_8_wd),
1745:     .d      (hw2reg.digest[8].d),
1746:     .qre    (),
1747:     .qe     (digest_8_flds_we[0]),
1748:     .q      (reg2hw.digest[8].q),
1749:     .ds     (),
1750:     .qs     (digest_8_qs)
1751:   );
1752:   assign reg2hw.digest[8].qe = digest_8_qe;
1753: 
1754: 
1755:   // Subregister 9 of Multireg digest
1756:   // R[digest_9]: V(True)
1757:   logic digest_9_qe;
1758:   logic [0:0] digest_9_flds_we;
1759:   assign digest_9_qe = &digest_9_flds_we;
1760:   prim_subreg_ext #(
1761:     .DW    (32)
1762:   ) u_digest_9 (
1763:     .re     (digest_9_re),
1764:     .we     (digest_9_we),
1765:     .wd     (digest_9_wd),
1766:     .d      (hw2reg.digest[9].d),
1767:     .qre    (),
1768:     .qe     (digest_9_flds_we[0]),
1769:     .q      (reg2hw.digest[9].q),
1770:     .ds     (),
1771:     .qs     (digest_9_qs)
1772:   );
1773:   assign reg2hw.digest[9].qe = digest_9_qe;
1774: 
1775: 
1776:   // Subregister 10 of Multireg digest
1777:   // R[digest_10]: V(True)
1778:   logic digest_10_qe;
1779:   logic [0:0] digest_10_flds_we;
1780:   assign digest_10_qe = &digest_10_flds_we;
1781:   prim_subreg_ext #(
1782:     .DW    (32)
1783:   ) u_digest_10 (
1784:     .re     (digest_10_re),
1785:     .we     (digest_10_we),
1786:     .wd     (digest_10_wd),
1787:     .d      (hw2reg.digest[10].d),
1788:     .qre    (),
1789:     .qe     (digest_10_flds_we[0]),
1790:     .q      (reg2hw.digest[10].q),
1791:     .ds     (),
1792:     .qs     (digest_10_qs)
1793:   );
1794:   assign reg2hw.digest[10].qe = digest_10_qe;
1795: 
1796: 
1797:   // Subregister 11 of Multireg digest
1798:   // R[digest_11]: V(True)
1799:   logic digest_11_qe;
1800:   logic [0:0] digest_11_flds_we;
1801:   assign digest_11_qe = &digest_11_flds_we;
1802:   prim_subreg_ext #(
1803:     .DW    (32)
1804:   ) u_digest_11 (
1805:     .re     (digest_11_re),
1806:     .we     (digest_11_we),
1807:     .wd     (digest_11_wd),
1808:     .d      (hw2reg.digest[11].d),
1809:     .qre    (),
1810:     .qe     (digest_11_flds_we[0]),
1811:     .q      (reg2hw.digest[11].q),
1812:     .ds     (),
1813:     .qs     (digest_11_qs)
1814:   );
1815:   assign reg2hw.digest[11].qe = digest_11_qe;
1816: 
1817: 
1818:   // Subregister 12 of Multireg digest
1819:   // R[digest_12]: V(True)
1820:   logic digest_12_qe;
1821:   logic [0:0] digest_12_flds_we;
1822:   assign digest_12_qe = &digest_12_flds_we;
1823:   prim_subreg_ext #(
1824:     .DW    (32)
1825:   ) u_digest_12 (
1826:     .re     (digest_12_re),
1827:     .we     (digest_12_we),
1828:     .wd     (digest_12_wd),
1829:     .d      (hw2reg.digest[12].d),
1830:     .qre    (),
1831:     .qe     (digest_12_flds_we[0]),
1832:     .q      (reg2hw.digest[12].q),
1833:     .ds     (),
1834:     .qs     (digest_12_qs)
1835:   );
1836:   assign reg2hw.digest[12].qe = digest_12_qe;
1837: 
1838: 
1839:   // Subregister 13 of Multireg digest
1840:   // R[digest_13]: V(True)
1841:   logic digest_13_qe;
1842:   logic [0:0] digest_13_flds_we;
1843:   assign digest_13_qe = &digest_13_flds_we;
1844:   prim_subreg_ext #(
1845:     .DW    (32)
1846:   ) u_digest_13 (
1847:     .re     (digest_13_re),
1848:     .we     (digest_13_we),
1849:     .wd     (digest_13_wd),
1850:     .d      (hw2reg.digest[13].d),
1851:     .qre    (),
1852:     .qe     (digest_13_flds_we[0]),
1853:     .q      (reg2hw.digest[13].q),
1854:     .ds     (),
1855:     .qs     (digest_13_qs)
1856:   );
1857:   assign reg2hw.digest[13].qe = digest_13_qe;
1858: 
1859: 
1860:   // Subregister 14 of Multireg digest
1861:   // R[digest_14]: V(True)
1862:   logic digest_14_qe;
1863:   logic [0:0] digest_14_flds_we;
1864:   assign digest_14_qe = &digest_14_flds_we;
1865:   prim_subreg_ext #(
1866:     .DW    (32)
1867:   ) u_digest_14 (
1868:     .re     (digest_14_re),
1869:     .we     (digest_14_we),
1870:     .wd     (digest_14_wd),
1871:     .d      (hw2reg.digest[14].d),
1872:     .qre    (),
1873:     .qe     (digest_14_flds_we[0]),
1874:     .q      (reg2hw.digest[14].q),
1875:     .ds     (),
1876:     .qs     (digest_14_qs)
1877:   );
1878:   assign reg2hw.digest[14].qe = digest_14_qe;
1879: 
1880: 
1881:   // Subregister 15 of Multireg digest
1882:   // R[digest_15]: V(True)
1883:   logic digest_15_qe;
1884:   logic [0:0] digest_15_flds_we;
1885:   assign digest_15_qe = &digest_15_flds_we;
1886:   prim_subreg_ext #(
1887:     .DW    (32)
1888:   ) u_digest_15 (
1889:     .re     (digest_15_re),
1890:     .we     (digest_15_we),
1891:     .wd     (digest_15_wd),
1892:     .d      (hw2reg.digest[15].d),
1893:     .qre    (),
1894:     .qe     (digest_15_flds_we[0]),
1895:     .q      (reg2hw.digest[15].q),
1896:     .ds     (),
1897:     .qs     (digest_15_qs)
1898:   );
1899:   assign reg2hw.digest[15].qe = digest_15_qe;
1900: 
1901: 
1902:   // R[msg_length_lower]: V(True)
1903:   logic msg_length_lower_qe;
1904:   logic [0:0] msg_length_lower_flds_we;
1905:   assign msg_length_lower_qe = &msg_length_lower_flds_we;
1906:   prim_subreg_ext #(
1907:     .DW    (32)
1908:   ) u_msg_length_lower (
1909:     .re     (msg_length_lower_re),
1910:     .we     (msg_length_lower_we),
1911:     .wd     (msg_length_lower_wd),
1912:     .d      (hw2reg.msg_length_lower.d),
1913:     .qre    (),
1914:     .qe     (msg_length_lower_flds_we[0]),
1915:     .q      (reg2hw.msg_length_lower.q),
1916:     .ds     (),
1917:     .qs     (msg_length_lower_qs)
1918:   );
1919:   assign reg2hw.msg_length_lower.qe = msg_length_lower_qe;
1920: 
1921: 
1922:   // R[msg_length_upper]: V(True)
1923:   logic msg_length_upper_qe;
1924:   logic [0:0] msg_length_upper_flds_we;
1925:   assign msg_length_upper_qe = &msg_length_upper_flds_we;
1926:   prim_subreg_ext #(
1927:     .DW    (32)
1928:   ) u_msg_length_upper (
1929:     .re     (msg_length_upper_re),
1930:     .we     (msg_length_upper_we),
1931:     .wd     (msg_length_upper_wd),
1932:     .d      (hw2reg.msg_length_upper.d),
1933:     .qre    (),
1934:     .qe     (msg_length_upper_flds_we[0]),
1935:     .q      (reg2hw.msg_length_upper.q),
1936:     .ds     (),
1937:     .qs     (msg_length_upper_qs)
1938:   );
1939:   assign reg2hw.msg_length_upper.qe = msg_length_upper_qe;
1940: 
1941: 
1942: 
1943:   logic [58:0] addr_hit;
1944:   always_comb begin
1945:     addr_hit = '0;
1946:     addr_hit[ 0] = (reg_addr == HMAC_INTR_STATE_OFFSET);
1947:     addr_hit[ 1] = (reg_addr == HMAC_INTR_ENABLE_OFFSET);
1948:     addr_hit[ 2] = (reg_addr == HMAC_INTR_TEST_OFFSET);
1949:     addr_hit[ 3] = (reg_addr == HMAC_ALERT_TEST_OFFSET);
1950:     addr_hit[ 4] = (reg_addr == HMAC_CFG_OFFSET);
1951:     addr_hit[ 5] = (reg_addr == HMAC_CMD_OFFSET);
1952:     addr_hit[ 6] = (reg_addr == HMAC_STATUS_OFFSET);
1953:     addr_hit[ 7] = (reg_addr == HMAC_ERR_CODE_OFFSET);
1954:     addr_hit[ 8] = (reg_addr == HMAC_WIPE_SECRET_OFFSET);
1955:     addr_hit[ 9] = (reg_addr == HMAC_KEY_0_OFFSET);
1956:     addr_hit[10] = (reg_addr == HMAC_KEY_1_OFFSET);
1957:     addr_hit[11] = (reg_addr == HMAC_KEY_2_OFFSET);
1958:     addr_hit[12] = (reg_addr == HMAC_KEY_3_OFFSET);
1959:     addr_hit[13] = (reg_addr == HMAC_KEY_4_OFFSET);
1960:     addr_hit[14] = (reg_addr == HMAC_KEY_5_OFFSET);
1961:     addr_hit[15] = (reg_addr == HMAC_KEY_6_OFFSET);
1962:     addr_hit[16] = (reg_addr == HMAC_KEY_7_OFFSET);
1963:     addr_hit[17] = (reg_addr == HMAC_KEY_8_OFFSET);
1964:     addr_hit[18] = (reg_addr == HMAC_KEY_9_OFFSET);
1965:     addr_hit[19] = (reg_addr == HMAC_KEY_10_OFFSET);
1966:     addr_hit[20] = (reg_addr == HMAC_KEY_11_OFFSET);
1967:     addr_hit[21] = (reg_addr == HMAC_KEY_12_OFFSET);
1968:     addr_hit[22] = (reg_addr == HMAC_KEY_13_OFFSET);
1969:     addr_hit[23] = (reg_addr == HMAC_KEY_14_OFFSET);
1970:     addr_hit[24] = (reg_addr == HMAC_KEY_15_OFFSET);
1971:     addr_hit[25] = (reg_addr == HMAC_KEY_16_OFFSET);
1972:     addr_hit[26] = (reg_addr == HMAC_KEY_17_OFFSET);
1973:     addr_hit[27] = (reg_addr == HMAC_KEY_18_OFFSET);
1974:     addr_hit[28] = (reg_addr == HMAC_KEY_19_OFFSET);
1975:     addr_hit[29] = (reg_addr == HMAC_KEY_20_OFFSET);
1976:     addr_hit[30] = (reg_addr == HMAC_KEY_21_OFFSET);
1977:     addr_hit[31] = (reg_addr == HMAC_KEY_22_OFFSET);
1978:     addr_hit[32] = (reg_addr == HMAC_KEY_23_OFFSET);
1979:     addr_hit[33] = (reg_addr == HMAC_KEY_24_OFFSET);
1980:     addr_hit[34] = (reg_addr == HMAC_KEY_25_OFFSET);
1981:     addr_hit[35] = (reg_addr == HMAC_KEY_26_OFFSET);
1982:     addr_hit[36] = (reg_addr == HMAC_KEY_27_OFFSET);
1983:     addr_hit[37] = (reg_addr == HMAC_KEY_28_OFFSET);
1984:     addr_hit[38] = (reg_addr == HMAC_KEY_29_OFFSET);
1985:     addr_hit[39] = (reg_addr == HMAC_KEY_30_OFFSET);
1986:     addr_hit[40] = (reg_addr == HMAC_KEY_31_OFFSET);
1987:     addr_hit[41] = (reg_addr == HMAC_DIGEST_0_OFFSET);
1988:     addr_hit[42] = (reg_addr == HMAC_DIGEST_1_OFFSET);
1989:     addr_hit[43] = (reg_addr == HMAC_DIGEST_2_OFFSET);
1990:     addr_hit[44] = (reg_addr == HMAC_DIGEST_3_OFFSET);
1991:     addr_hit[45] = (reg_addr == HMAC_DIGEST_4_OFFSET);
1992:     addr_hit[46] = (reg_addr == HMAC_DIGEST_5_OFFSET);
1993:     addr_hit[47] = (reg_addr == HMAC_DIGEST_6_OFFSET);
1994:     addr_hit[48] = (reg_addr == HMAC_DIGEST_7_OFFSET);
1995:     addr_hit[49] = (reg_addr == HMAC_DIGEST_8_OFFSET);
1996:     addr_hit[50] = (reg_addr == HMAC_DIGEST_9_OFFSET);
1997:     addr_hit[51] = (reg_addr == HMAC_DIGEST_10_OFFSET);
1998:     addr_hit[52] = (reg_addr == HMAC_DIGEST_11_OFFSET);
1999:     addr_hit[53] = (reg_addr == HMAC_DIGEST_12_OFFSET);
2000:     addr_hit[54] = (reg_addr == HMAC_DIGEST_13_OFFSET);
2001:     addr_hit[55] = (reg_addr == HMAC_DIGEST_14_OFFSET);
2002:     addr_hit[56] = (reg_addr == HMAC_DIGEST_15_OFFSET);
2003:     addr_hit[57] = (reg_addr == HMAC_MSG_LENGTH_LOWER_OFFSET);
2004:     addr_hit[58] = (reg_addr == HMAC_MSG_LENGTH_UPPER_OFFSET);
2005:   end
2006: 
2007:   assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;
2008: 
2009:   // Check sub-word write is permitted
2010:   always_comb begin
2011:     wr_err = (reg_we &
2012:               ((addr_hit[ 0] & (|(HMAC_PERMIT[ 0] & ~reg_be))) |
2013:                (addr_hit[ 1] & (|(HMAC_PERMIT[ 1] & ~reg_be))) |
2014:                (addr_hit[ 2] & (|(HMAC_PERMIT[ 2] & ~reg_be))) |
2015:                (addr_hit[ 3] & (|(HMAC_PERMIT[ 3] & ~reg_be))) |
2016:                (addr_hit[ 4] & (|(HMAC_PERMIT[ 4] & ~reg_be))) |
2017:                (addr_hit[ 5] & (|(HMAC_PERMIT[ 5] & ~reg_be))) |
2018:                (addr_hit[ 6] & (|(HMAC_PERMIT[ 6] & ~reg_be))) |
2019:                (addr_hit[ 7] & (|(HMAC_PERMIT[ 7] & ~reg_be))) |
2020:                (addr_hit[ 8] & (|(HMAC_PERMIT[ 8] & ~reg_be))) |
2021:                (addr_hit[ 9] & (|(HMAC_PERMIT[ 9] & ~reg_be))) |
2022:                (addr_hit[10] & (|(HMAC_PERMIT[10] & ~reg_be))) |
2023:                (addr_hit[11] & (|(HMAC_PERMIT[11] & ~reg_be))) |
2024:                (addr_hit[12] & (|(HMAC_PERMIT[12] & ~reg_be))) |
2025:                (addr_hit[13] & (|(HMAC_PERMIT[13] & ~reg_be))) |
2026:                (addr_hit[14] & (|(HMAC_PERMIT[14] & ~reg_be))) |
2027:                (addr_hit[15] & (|(HMAC_PERMIT[15] & ~reg_be))) |
2028:                (addr_hit[16] & (|(HMAC_PERMIT[16] & ~reg_be))) |
2029:                (addr_hit[17] & (|(HMAC_PERMIT[17] & ~reg_be))) |
2030:                (addr_hit[18] & (|(HMAC_PERMIT[18] & ~reg_be))) |
2031:                (addr_hit[19] & (|(HMAC_PERMIT[19] & ~reg_be))) |
2032:                (addr_hit[20] & (|(HMAC_PERMIT[20] & ~reg_be))) |
2033:                (addr_hit[21] & (|(HMAC_PERMIT[21] & ~reg_be))) |
2034:                (addr_hit[22] & (|(HMAC_PERMIT[22] & ~reg_be))) |
2035:                (addr_hit[23] & (|(HMAC_PERMIT[23] & ~reg_be))) |
2036:                (addr_hit[24] & (|(HMAC_PERMIT[24] & ~reg_be))) |
2037:                (addr_hit[25] & (|(HMAC_PERMIT[25] & ~reg_be))) |
2038:                (addr_hit[26] & (|(HMAC_PERMIT[26] & ~reg_be))) |
2039:                (addr_hit[27] & (|(HMAC_PERMIT[27] & ~reg_be))) |
2040:                (addr_hit[28] & (|(HMAC_PERMIT[28] & ~reg_be))) |
2041:                (addr_hit[29] & (|(HMAC_PERMIT[29] & ~reg_be))) |
2042:                (addr_hit[30] & (|(HMAC_PERMIT[30] & ~reg_be))) |
2043:                (addr_hit[31] & (|(HMAC_PERMIT[31] & ~reg_be))) |
2044:                (addr_hit[32] & (|(HMAC_PERMIT[32] & ~reg_be))) |
2045:                (addr_hit[33] & (|(HMAC_PERMIT[33] & ~reg_be))) |
2046:                (addr_hit[34] & (|(HMAC_PERMIT[34] & ~reg_be))) |
2047:                (addr_hit[35] & (|(HMAC_PERMIT[35] & ~reg_be))) |
2048:                (addr_hit[36] & (|(HMAC_PERMIT[36] & ~reg_be))) |
2049:                (addr_hit[37] & (|(HMAC_PERMIT[37] & ~reg_be))) |
2050:                (addr_hit[38] & (|(HMAC_PERMIT[38] & ~reg_be))) |
2051:                (addr_hit[39] & (|(HMAC_PERMIT[39] & ~reg_be))) |
2052:                (addr_hit[40] & (|(HMAC_PERMIT[40] & ~reg_be))) |
2053:                (addr_hit[41] & (|(HMAC_PERMIT[41] & ~reg_be))) |
2054:                (addr_hit[42] & (|(HMAC_PERMIT[42] & ~reg_be))) |
2055:                (addr_hit[43] & (|(HMAC_PERMIT[43] & ~reg_be))) |
2056:                (addr_hit[44] & (|(HMAC_PERMIT[44] & ~reg_be))) |
2057:                (addr_hit[45] & (|(HMAC_PERMIT[45] & ~reg_be))) |
2058:                (addr_hit[46] & (|(HMAC_PERMIT[46] & ~reg_be))) |
2059:                (addr_hit[47] & (|(HMAC_PERMIT[47] & ~reg_be))) |
2060:                (addr_hit[48] & (|(HMAC_PERMIT[48] & ~reg_be))) |
2061:                (addr_hit[49] & (|(HMAC_PERMIT[49] & ~reg_be))) |
2062:                (addr_hit[50] & (|(HMAC_PERMIT[50] & ~reg_be))) |
2063:                (addr_hit[51] & (|(HMAC_PERMIT[51] & ~reg_be))) |
2064:                (addr_hit[52] & (|(HMAC_PERMIT[52] & ~reg_be))) |
2065:                (addr_hit[53] & (|(HMAC_PERMIT[53] & ~reg_be))) |
2066:                (addr_hit[54] & (|(HMAC_PERMIT[54] & ~reg_be))) |
2067:                (addr_hit[55] & (|(HMAC_PERMIT[55] & ~reg_be))) |
2068:                (addr_hit[56] & (|(HMAC_PERMIT[56] & ~reg_be))) |
2069:                (addr_hit[57] & (|(HMAC_PERMIT[57] & ~reg_be))) |
2070:                (addr_hit[58] & (|(HMAC_PERMIT[58] & ~reg_be)))));
2071:   end
2072: 
2073:   // Generate write-enables
2074:   assign intr_state_we = addr_hit[0] & reg_we & !reg_error;
2075: 
2076:   assign intr_state_hmac_done_wd = reg_wdata[0];
2077: 
2078:   assign intr_state_hmac_err_wd = reg_wdata[2];
2079:   assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;
2080: 
2081:   assign intr_enable_hmac_done_wd = reg_wdata[0];
2082: 
2083:   assign intr_enable_fifo_empty_wd = reg_wdata[1];
2084: 
2085:   assign intr_enable_hmac_err_wd = reg_wdata[2];
2086:   assign intr_test_we = addr_hit[2] & reg_we & !reg_error;
2087: 
2088:   assign intr_test_hmac_done_wd = reg_wdata[0];
2089: 
2090:   assign intr_test_fifo_empty_wd = reg_wdata[1];
2091: 
2092:   assign intr_test_hmac_err_wd = reg_wdata[2];
2093:   assign alert_test_we = addr_hit[3] & reg_we & !reg_error;
2094: 
2095:   assign alert_test_wd = reg_wdata[0];
2096:   assign cfg_re = addr_hit[4] & reg_re & !reg_error;
2097:   assign cfg_we = addr_hit[4] & reg_we & !reg_error;
2098: 
2099:   assign cfg_hmac_en_wd = reg_wdata[0];
2100: 
2101:   assign cfg_sha_en_wd = reg_wdata[1];
2102: 
2103:   assign cfg_endian_swap_wd = reg_wdata[2];
2104: 
2105:   assign cfg_digest_swap_wd = reg_wdata[3];
2106: 
2107:   assign cfg_key_swap_wd = reg_wdata[4];
2108: 
2109:   assign cfg_digest_size_wd = reg_wdata[8:5];
2110: 
2111:   assign cfg_key_length_wd = reg_wdata[14:9];
2112:   assign cmd_we = addr_hit[5] & reg_we & !reg_error;
2113: 
2114:   assign cmd_hash_start_wd = reg_wdata[0];
2115: 
2116:   assign cmd_hash_process_wd = reg_wdata[1];
2117: 
2118:   assign cmd_hash_stop_wd = reg_wdata[2];
2119: 
2120:   assign cmd_hash_continue_wd = reg_wdata[3];
2121:   assign status_re = addr_hit[6] & reg_re & !reg_error;
2122:   assign wipe_secret_we = addr_hit[8] & reg_we & reg_error;
2123: 
2124:   assign wipe_secret_wd = reg_wdata[31:0];
2125:   assign key_0_we = addr_hit[9] & reg_we & !reg_error;
2126: 
2127:   assign key_0_wd = reg_wdata[31:0];
2128:   assign key_1_we = addr_hit[10] & reg_we & !reg_error;
2129: 
2130:   assign key_1_wd = reg_wdata[31:0];
2131:   assign key_2_we = addr_hit[11] & reg_we & !reg_error;
2132: 
2133:   assign key_2_wd = reg_wdata[31:0];
2134:   assign key_3_we = addr_hit[12] & reg_we & !reg_error;
2135: 
2136:   assign key_3_wd = reg_wdata[31:0];
2137:   assign key_4_we = addr_hit[13] & reg_we & !reg_error;
2138: 
2139:   assign key_4_wd = reg_wdata[31:0];
2140:   assign key_5_we = addr_hit[14] & reg_we & !reg_error;
2141: 
2142:   assign key_5_wd = reg_wdata[31:0];
2143:   assign key_6_we = addr_hit[15] & reg_we & !reg_error;
2144: 
2145:   assign key_6_wd = reg_wdata[31:0];
2146:   assign key_7_we = addr_hit[16] & reg_we & !reg_error;
2147: 
2148:   assign key_7_wd = reg_wdata[31:0];
2149:   assign key_8_we = addr_hit[17] & reg_we & !reg_error;
2150: 
2151:   assign key_8_wd = reg_wdata[31:0];
2152:   assign key_9_we = addr_hit[18] & reg_we & !reg_error;
2153: 
2154:   assign key_9_wd = reg_wdata[31:0];
2155:   assign key_10_we = addr_hit[19] & reg_we & !reg_error;
2156: 
2157:   assign key_10_wd = reg_wdata[31:0];
2158:   assign key_11_we = addr_hit[20] & reg_we & !reg_error;
2159: 
2160:   assign key_11_wd = reg_wdata[31:0];
2161:   assign key_12_we = addr_hit[21] & reg_we & !reg_error;
2162: 
2163:   assign key_12_wd = reg_wdata[31:0];
2164:   assign key_13_we = addr_hit[22] & reg_we & !reg_error;
2165: 
2166:   assign key_13_wd = reg_wdata[31:0];
2167:   assign key_14_we = addr_hit[23] & reg_we & !reg_error;
2168: 
2169:   assign key_14_wd = reg_wdata[31:0];
2170:   assign key_15_we = addr_hit[24] & reg_we & !reg_error;
2171: 
2172:   assign key_15_wd = reg_wdata[31:0];
2173:   assign key_16_we = addr_hit[25] & reg_we & !reg_error;
2174: 
2175:   assign key_16_wd = reg_wdata[31:0];
2176:   assign key_17_we = addr_hit[26] & reg_we & !reg_error;
2177: 
2178:   assign key_17_wd = reg_wdata[31:0];
2179:   assign key_18_we = addr_hit[27] & reg_we & !reg_error;
2180: 
2181:   assign key_18_wd = reg_wdata[31:0];
2182:   assign key_19_we = addr_hit[28] & reg_we & !reg_error;
2183: 
2184:   assign key_19_wd = reg_wdata[31:0];
2185:   assign key_20_we = addr_hit[29] & reg_we & !reg_error;
2186: 
2187:   assign key_20_wd = reg_wdata[31:0];
2188:   assign key_21_we = addr_hit[30] & reg_we & !reg_error;
2189: 
2190:   assign key_21_wd = reg_wdata[31:0];
2191:   assign key_22_we = addr_hit[31] & reg_we & !reg_error;
2192: 
2193:   assign key_22_wd = reg_wdata[31:0];
2194:   assign key_23_we = addr_hit[32] & reg_we & !reg_error;
2195: 
2196:   assign key_23_wd = reg_wdata[31:0];
2197:   assign key_24_we = addr_hit[33] & reg_we & !reg_error;
2198: 
2199:   assign key_24_wd = reg_wdata[31:0];
2200:   assign key_25_we = addr_hit[34] & reg_we & !reg_error;
2201: 
2202:   assign key_25_wd = reg_wdata[31:0];
2203:   assign key_26_we = addr_hit[35] & reg_we & !reg_error;
2204: 
2205:   assign key_26_wd = reg_wdata[31:0];
2206:   assign key_27_we = addr_hit[36] & reg_we & !reg_error;
2207: 
2208:   assign key_27_wd = reg_wdata[31:0];
2209:   assign key_28_we = addr_hit[37] & reg_we & !reg_error;
2210: 
2211:   assign key_28_wd = reg_wdata[31:0];
2212:   assign key_29_we = addr_hit[38] & reg_we & !reg_error;
2213: 
2214:   assign key_29_wd = reg_wdata[31:0];
2215:   assign key_30_we = addr_hit[39] & reg_we & !reg_error;
2216: 
2217:   assign key_30_wd = reg_wdata[31:0];
2218:   assign key_31_we = addr_hit[40] & reg_we & !reg_error;
2219: 
2220:   assign key_31_wd = reg_wdata[31:0];
2221:   assign digest_0_re = addr_hit[41] & reg_re & !reg_error;
2222:   assign digest_0_we = addr_hit[41] & reg_we & !reg_error;
2223: 
2224:   assign digest_0_wd = reg_wdata[31:0];
2225:   assign digest_1_re = addr_hit[42] & reg_re & !reg_error;
2226:   assign digest_1_we = addr_hit[42] & reg_we & !reg_error;
2227: 
2228:   assign digest_1_wd = reg_wdata[31:0];
2229:   assign digest_2_re = addr_hit[43] & reg_re & !reg_error;
2230:   assign digest_2_we = addr_hit[43] & reg_we & !reg_error;
2231: 
2232:   assign digest_2_wd = reg_wdata[31:0];
2233:   assign digest_3_re = addr_hit[44] & reg_re & !reg_error;
2234:   assign digest_3_we = addr_hit[44] & reg_we & !reg_error;
2235: 
2236:   assign digest_3_wd = reg_wdata[31:0];
2237:   assign digest_4_re = addr_hit[45] & reg_re & !reg_error;
2238:   assign digest_4_we = addr_hit[45] & reg_we & !reg_error;
2239: 
2240:   assign digest_4_wd = reg_wdata[31:0];
2241:   assign digest_5_re = addr_hit[46] & reg_re & !reg_error;
2242:   assign digest_5_we = addr_hit[46] & reg_we & !reg_error;
2243: 
2244:   assign digest_5_wd = reg_wdata[31:0];
2245:   assign digest_6_re = addr_hit[47] & reg_re & !reg_error;
2246:   assign digest_6_we = addr_hit[47] & reg_we & !reg_error;
2247: 
2248:   assign digest_6_wd = reg_wdata[31:0];
2249:   assign digest_7_re = addr_hit[48] & reg_re & !reg_error;
2250:   assign digest_7_we = addr_hit[48] & reg_we & !reg_error;
2251: 
2252:   assign digest_7_wd = reg_wdata[31:0];
2253:   assign digest_8_re = addr_hit[49] & reg_re & !reg_error;
2254:   assign digest_8_we = addr_hit[49] & reg_we & !reg_error;
2255: 
2256:   assign digest_8_wd = reg_wdata[31:0];
2257:   assign digest_9_re = addr_hit[50] & reg_re & !reg_error;
2258:   assign digest_9_we = addr_hit[50] & reg_we & !reg_error;
2259: 
2260:   assign digest_9_wd = reg_wdata[31:0];
2261:   assign digest_10_re = addr_hit[51] & reg_re & !reg_error;
2262:   assign digest_10_we = addr_hit[51] & reg_we & !reg_error;
2263: 
2264:   assign digest_10_wd = reg_wdata[31:0];
2265:   assign digest_11_re = addr_hit[52] & reg_re & !reg_error;
2266:   assign digest_11_we = addr_hit[52] & reg_we & !reg_error;
2267: 
2268:   assign digest_11_wd = reg_wdata[31:0];
2269:   assign digest_12_re = addr_hit[53] & reg_re & !reg_error;
2270:   assign digest_12_we = addr_hit[53] & reg_we & !reg_error;
2271: 
2272:   assign digest_12_wd = reg_wdata[31:0];
2273:   assign digest_13_re = addr_hit[54] & reg_re & !reg_error;
2274:   assign digest_13_we = addr_hit[54] & reg_we & !reg_error;
2275: 
2276:   assign digest_13_wd = reg_wdata[31:0];
2277:   assign digest_14_re = addr_hit[55] & reg_re & !reg_error;
2278:   assign digest_14_we = addr_hit[55] & reg_we & !reg_error;
2279: 
2280:   assign digest_14_wd = reg_wdata[31:0];
2281:   assign digest_15_re = addr_hit[56] & reg_re & !reg_error;
2282:   assign digest_15_we = addr_hit[56] & reg_we & !reg_error;
2283: 
2284:   assign digest_15_wd = reg_wdata[31:0];
2285:   assign msg_length_lower_re = addr_hit[57] & reg_re & !reg_error;
2286:   assign msg_length_lower_we = addr_hit[57] & reg_we & !reg_error;
2287: 
2288:   assign msg_length_lower_wd = reg_wdata[31:0];
2289:   assign msg_length_upper_re = addr_hit[58] & reg_re & !reg_error;
2290:   assign msg_length_upper_we = addr_hit[58] & reg_we & !reg_error;
2291: 
2292:   assign msg_length_upper_wd = reg_wdata[31:0];
2293: 
2294:   // Assign write-enables to checker logic vector.
2295:   always_comb begin
2296:     reg_we_check = '0;
2297:     reg_we_check[0] = intr_state_we;
2298:     reg_we_check[1] = intr_enable_we;
2299:     reg_we_check[2] = intr_test_we;
2300:     reg_we_check[3] = alert_test_we;
2301:     reg_we_check[4] = cfg_we;
2302:     reg_we_check[5] = cmd_we;
2303:     reg_we_check[6] = 1'b0;
2304:     reg_we_check[7] = 1'b0;
2305:     reg_we_check[8] = wipe_secret_we;
2306:     reg_we_check[9] = key_0_we;
2307:     reg_we_check[10] = key_1_we;
2308:     reg_we_check[11] = key_2_we;
2309:     reg_we_check[12] = key_3_we;
2310:     reg_we_check[13] = key_4_we;
2311:     reg_we_check[14] = key_5_we;
2312:     reg_we_check[15] = key_6_we;
2313:     reg_we_check[16] = key_7_we;
2314:     reg_we_check[17] = key_8_we;
2315:     reg_we_check[18] = key_9_we;
2316:     reg_we_check[19] = key_10_we;
2317:     reg_we_check[20] = key_11_we;
2318:     reg_we_check[21] = key_12_we;
2319:     reg_we_check[22] = key_13_we;
2320:     reg_we_check[23] = key_14_we;
2321:     reg_we_check[24] = key_15_we;
2322:     reg_we_check[25] = key_16_we;
2323:     reg_we_check[26] = key_17_we;
2324:     reg_we_check[27] = key_18_we;
2325:     reg_we_check[28] = key_19_we;
2326:     reg_we_check[29] = key_20_we;
2327:     reg_we_check[30] = key_21_we;
2328:     reg_we_check[31] = key_22_we;
2329:     reg_we_check[32] = key_23_we;
2330:     reg_we_check[33] = key_24_we;
2331:     reg_we_check[34] = key_25_we;
2332:     reg_we_check[35] = key_26_we;
2333:     reg_we_check[36] = key_27_we;
2334:     reg_we_check[37] = key_28_we;
2335:     reg_we_check[38] = key_29_we;
2336:     reg_we_check[39] = key_30_we;
2337:     reg_we_check[40] = key_31_we;
2338:     reg_we_check[41] = digest_0_we;
2339:     reg_we_check[42] = digest_1_we;
2340:     reg_we_check[43] = digest_2_we;
2341:     reg_we_check[44] = digest_3_we;
2342:     reg_we_check[45] = digest_4_we;
2343:     reg_we_check[46] = digest_5_we;
2344:     reg_we_check[47] = digest_6_we;
2345:     reg_we_check[48] = digest_7_we;
2346:     reg_we_check[49] = digest_8_we;
2347:     reg_we_check[50] = digest_9_we;
2348:     reg_we_check[51] = digest_10_we;
2349:     reg_we_check[52] = digest_11_we;
2350:     reg_we_check[53] = digest_12_we;
2351:     reg_we_check[54] = digest_13_we;
2352:     reg_we_check[55] = digest_14_we;
2353:     reg_we_check[56] = digest_15_we;
2354:     reg_we_check[57] = msg_length_lower_we;
2355:     reg_we_check[58] = msg_length_upper_we;
2356:   end
2357: 
2358:   // Read data return
2359:   always_comb begin
2360:     reg_rdata_next = '0;
2361:     unique case (1'b1)
2362:       addr_hit[0]: begin
2363:         reg_rdata_next[0] = intr_state_hmac_done_qs;
2364:         reg_rdata_next[1] = intr_state_fifo_empty_qs;
2365:         reg_rdata_next[2] = intr_state_hmac_err_qs;
2366:       end
2367: 
2368:       addr_hit[1]: begin
2369:         reg_rdata_next[0] = intr_enable_hmac_done_qs;
2370:         reg_rdata_next[1] = intr_enable_fifo_empty_qs;
2371:         reg_rdata_next[2] = intr_enable_hmac_err_qs;
2372:       end
2373: 
2374:       addr_hit[2]: begin
2375:         reg_rdata_next[0] = '0;
2376:         reg_rdata_next[1] = '0;
2377:         reg_rdata_next[2] = '0;
2378:       end
2379: 
2380:       addr_hit[3]: begin
2381:         reg_rdata_next[0] = '0;
2382:       end
2383: 
2384:       addr_hit[4]: begin
2385:         reg_rdata_next[0] = cfg_hmac_en_qs;
2386:         reg_rdata_next[1] = cfg_sha_en_qs;
2387:         reg_rdata_next[2] = cfg_endian_swap_qs;
2388:         reg_rdata_next[3] = cfg_digest_swap_qs;
2389:         reg_rdata_next[4] = cfg_key_swap_qs;
2390:         reg_rdata_next[8:5] = cfg_digest_size_qs;
2391:         reg_rdata_next[14:9] = cfg_key_length_qs;
2392:       end
2393: 
2394:       addr_hit[5]: begin
2395:         reg_rdata_next[0] = '0;
2396:         reg_rdata_next[1] = '0;
2397:         reg_rdata_next[2] = '0;
2398:         reg_rdata_next[3] = '0;
2399:       end
2400: 
2401:       addr_hit[6]: begin
2402:         reg_rdata_next[0] = status_hmac_idle_qs;
2403:         reg_rdata_next[1] = status_fifo_empty_qs;
2404:         reg_rdata_next[2] = status_fifo_full_qs;
2405:         reg_rdata_next[9:4] = status_fifo_depth_qs;
2406:       end
2407: 
2408:       addr_hit[7]: begin
2409:         reg_rdata_next[31:0] = err_code_qs;
2410:       end
2411: 
2412:       addr_hit[8]: begin
2413:         reg_rdata_next[31:0] = reg2hw.key[0].q;
2414:       end
2415: 
2416:       addr_hit[9]: begin
2417:         reg_rdata_next[31:0] = reg2hw.key[1].q;
2418:       end
2419: 
2420:       addr_hit[10]: begin
2421:         reg_rdata_next[31:0] = '0;
2422:       end
2423: 
2424:       addr_hit[11]: begin
2425:         reg_rdata_next[31:0] = '0;
2426:       end
2427: 
2428:       addr_hit[12]: begin
2429:         reg_rdata_next[31:0] = '0;
2430:       end
2431: 
2432:       addr_hit[13]: begin
2433:         reg_rdata_next[31:0] = '0;
2434:       end
2435: 
2436:       addr_hit[14]: begin
2437:         reg_rdata_next[31:0] = '0;
2438:       end
2439: 
2440:       addr_hit[15]: begin
2441:         reg_rdata_next[31:0] = '0;
2442:       end
2443: 
2444:       addr_hit[16]: begin
2445:         reg_rdata_next[31:0] = '0;
2446:       end
2447: 
2448:       addr_hit[17]: begin
2449:         reg_rdata_next[31:0] = '0;
2450:       end
2451: 
2452:       addr_hit[18]: begin
2453:         reg_rdata_next[31:0] = '0;
2454:       end
2455: 
2456:       addr_hit[19]: begin
2457:         reg_rdata_next[31:0] = '0;
2458:       end
2459: 
2460:       addr_hit[20]: begin
2461:         reg_rdata_next[31:0] = '0;
2462:       end
2463: 
2464:       addr_hit[21]: begin
2465:         reg_rdata_next[31:0] = '0;
2466:       end
2467: 
2468:       addr_hit[22]: begin
2469:         reg_rdata_next[31:0] = '0;
2470:       end
2471: 
2472:       addr_hit[23]: begin
2473:         reg_rdata_next[31:0] = '0;
2474:       end
2475: 
2476:       addr_hit[24]: begin
2477:         reg_rdata_next[31:0] = '0;
2478:       end
2479: 
2480:       addr_hit[25]: begin
2481:         reg_rdata_next[31:0] = '0;
2482:       end
2483: 
2484:       addr_hit[26]: begin
2485:         reg_rdata_next[31:0] = '0;
2486:       end
2487: 
2488:       addr_hit[27]: begin
2489:         reg_rdata_next[31:0] = '0;
2490:       end
2491: 
2492:       addr_hit[28]: begin
2493:         reg_rdata_next[31:0] = '0;
2494:       end
2495: 
2496:       addr_hit[29]: begin
2497:         reg_rdata_next[31:0] = '0;
2498:       end
2499: 
2500:       addr_hit[30]: begin
2501:         reg_rdata_next[31:0] = '0;
2502:       end
2503: 
2504:       addr_hit[31]: begin
2505:         reg_rdata_next[31:0] = '0;
2506:       end
2507: 
2508:       addr_hit[32]: begin
2509:         reg_rdata_next[31:0] = '0;
2510:       end
2511: 
2512:       addr_hit[33]: begin
2513:         reg_rdata_next[31:0] = '0;
2514:       end
2515: 
2516:       addr_hit[34]: begin
2517:         reg_rdata_next[31:0] = '0;
2518:       end
2519: 
2520:       addr_hit[35]: begin
2521:         reg_rdata_next[31:0] = '0;
2522:       end
2523: 
2524:       addr_hit[36]: begin
2525:         reg_rdata_next[31:0] = '0;
2526:       end
2527: 
2528:       addr_hit[37]: begin
2529:         reg_rdata_next[31:0] = '0;
2530:       end
2531: 
2532:       addr_hit[38]: begin
2533:         reg_rdata_next[31:0] = '0;
2534:       end
2535: 
2536:       addr_hit[39]: begin
2537:         reg_rdata_next[31:0] = '0;
2538:       end
2539: 
2540:       addr_hit[40]: begin
2541:         reg_rdata_next[31:0] = '0;
2542:       end
2543: 
2544:       addr_hit[41]: begin
2545:         reg_rdata_next[31:0] = digest_0_qs;
2546:       end
2547: 
2548:       addr_hit[42]: begin
2549:         reg_rdata_next[31:0] = digest_1_qs;
2550:       end
2551: 
2552:       addr_hit[43]: begin
2553:         reg_rdata_next[31:0] = digest_2_qs;
2554:       end
2555: 
2556:       addr_hit[44]: begin
2557:         reg_rdata_next[31:0] = digest_3_qs;
2558:       end
2559: 
2560:       addr_hit[45]: begin
2561:         reg_rdata_next[31:0] = digest_4_qs;
2562:       end
2563: 
2564:       addr_hit[46]: begin
2565:         reg_rdata_next[31:0] = digest_5_qs;
2566:       end
2567: 
2568:       addr_hit[47]: begin
2569:         reg_rdata_next[31:0] = digest_6_qs;
2570:       end
2571: 
2572:       addr_hit[48]: begin
2573:         reg_rdata_next[31:0] = digest_7_qs;
2574:       end
2575: 
2576:       addr_hit[49]: begin
2577:         reg_rdata_next[31:0] = digest_8_qs;
2578:       end
2579: 
2580:       addr_hit[50]: begin
2581:         reg_rdata_next[31:0] = digest_9_qs;
2582:       end
2583: 
2584:       addr_hit[51]: begin
2585:         reg_rdata_next[31:0] = digest_10_qs;
2586:       end
2587: 
2588:       addr_hit[52]: begin
2589:         reg_rdata_next[31:0] = digest_11_qs;
2590:       end
2591: 
2592:       addr_hit[53]: begin
2593:         reg_rdata_next[31:0] = digest_12_qs;
2594:       end
2595: 
2596:       addr_hit[54]: begin
2597:         reg_rdata_next[31:0] = digest_13_qs;
2598:       end
2599: 
2600:       addr_hit[55]: begin
2601:         reg_rdata_next[31:0] = digest_14_qs;
2602:       end
2603: 
2604:       addr_hit[56]: begin
2605:         reg_rdata_next[31:0] = digest_15_qs;
2606:       end
2607: 
2608:       addr_hit[57]: begin
2609:         reg_rdata_next[31:0] = msg_length_lower_qs;
2610:       end
2611: 
2612:       addr_hit[58]: begin
2613:         reg_rdata_next[31:0] = msg_length_upper_qs;
2614:       end
2615: 
2616:       default: begin
2617:         reg_rdata_next = reg2hw.key[2].q;
2618:       end
2619:     endcase
2620:   end
2621: 
2622:   // shadow busy
2623:   logic shadow_busy;
2624:   assign shadow_busy = 1'b0;
2625: 
2626:   // register busy
2627:   assign reg_busy = shadow_busy;
2628: 
2629:   // Unused signal tieoff
2630: 
2631:   // wdata / byte enable are not always fully used
2632:   // add a blanket unused statement to handle lint waivers
2633:   logic unused_wdata;
2634:   logic unused_be;
2635:   assign unused_wdata = ^reg_wdata;
2636:   assign unused_be = ^reg_be;
2637: 
2638:   // Assertions for Register Interface
2639:   `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
2640:   `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)
2641: 
2642:   `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)
2643: 
2644:   `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)
2645: 
2646:   // this is formulated as an assumption such that the FPV testbenches do disprove this
2647:   // property by mistake
2648:   //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)
2649: 
2650: endmodule

================================== Ai Message ==================================
Tool Calls:
  run_linter_agent (call_glQNDqQT1Z44syWToSRsxEB9)
 Call ID: call_glQNDqQT1Z44syWToSRsxEB9
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_core.sv
    top_module: hmac_core
    security_objective: register interface and FSM security
================================ Human Message =================================

Are there security concerns related to register interface and FSM security in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_core.sv

    And the top module is:

    hmac_core

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// HMAC Core implementation

module hmac_core import prim_sha2_pkg::*; (
  input clk_i,
  input rst_ni,

  input [1023:0]      secret_key_i, // {word0, word1, ..., word7}
  input               hmac_en_i,
  input digest_mode_e digest_size_i,
  input key_length_e  key_length_i,

  input        reg_hash_start_i,
  input        reg_hash_stop_i,
  input        reg_hash_continue_i,
  input        reg_hash_process_i,
  output logic hash_done_o,
  output logic sha_hash_start_o,
  output logic sha_hash_continue_o,
  output logic sha_hash_process_o,
  input        sha_hash_done_i,

  // fifo
  output logic        sha_rvalid_o,
  output sha_fifo32_t sha_rdata_o,
  input               sha_rready_i,

  input               fifo_rvalid_i,
  input  sha_fifo32_t fifo_rdata_i,
  output logic        fifo_rready_o,

  // fifo control (select and fifo write data)
  output logic       fifo_wsel_o,      // 0: from reg, 1: from digest
  output logic       fifo_wvalid_o,
  // 0: digest[0][upper], 1:digest[0][lower] .. 14: digest[7][upper], 15: digest[7][lower]
  output logic [3:0] fifo_wdata_sel_o,
  input              fifo_wready_i,

  input  [63:0] message_length_i,
  output [63:0] sha_message_length_o,

  output logic idle_o
);

  localparam int unsigned BlockSizeSHA256     = 512;
  localparam int unsigned BlockSizeSHA512     = 1024;

  localparam int unsigned BlockSizeBitsSHA256 = $clog2(BlockSizeSHA256);
  localparam int unsigned BlockSizeBitsSHA512 = $clog2(BlockSizeSHA512);

  localparam int unsigned HashWordBitsSHA256  = $clog2($bits(sha_word32_t));

  localparam bit [63:0] BlockSizeSHA256in64  = 64'(BlockSizeSHA256);
  localparam bit [63:0] BlockSizeSHA512in64  = 64'(BlockSizeSHA512);

  logic hash_start;    // generated from internal state machine
  logic hash_continue; // generated from internal state machine
  logic hash_process;  // generated from internal state machine to trigger hash
  logic hmac_hash_done;

  logic [BlockSizeSHA256-1:0] i_pad_256;
  logic [BlockSizeSHA512-1:0] i_pad_512;
  logic [BlockSizeSHA256-1:0] o_pad_256;
  logic [BlockSizeSHA512-1:0] o_pad_512;

  logic [63:0] txcount, txcount_d; // works for both digest lengths

  logic [BlockSizeBitsSHA512-HashWordBitsSHA256-1:0] pad_index_512;
  logic [BlockSizeBitsSHA256-HashWordBitsSHA256-1:0] pad_index_256;
  logic clr_txcount, load_txcount, inc_txcount;

  logic hmac_sha_rvalid;

  logic idle_d, idle_q;
  logic reg_hash_stop_d, reg_hash_stop_q;

  typedef enum logic [1:0] {
    SelIPad,
    SelOPad,
    SelFifo
  } sel_rdata_t;

  sel_rdata_t sel_rdata;

  typedef enum logic {
    SelIPadMsg,
    SelOPadMsg
  } sel_msglen_t;

  sel_msglen_t sel_msglen;

  typedef enum logic {
    Inner,  // Update when state goes to StIPad
    Outer   // Update when state enters StOPad
  } round_t ;

  logic update_round ;
  round_t round_q, round_d;

  typedef enum logic [2:0] {
    StIdle,
    StIPad,
    StMsg,              // Actual Msg, and Digest both
    StPushToMsgFifo,    // Digest --> Msg Fifo
    StWaitResp,         // Hash done( by checking processed_length? or hash_done)
    StOPad,
    StDone              // hmac_done
  } st_e ;

  st_e st_q, st_d;

  logic clr_fifo_wdata_sel;
  logic txcnt_eq_blksz;

  logic reg_hash_process_flag;

  assign sha_hash_start_o    = (hmac_en_i) ? hash_start    : reg_hash_start_i;
  assign sha_hash_continue_o = (hmac_en_i) ? hash_continue : reg_hash_continue_i;

  assign sha_hash_process_o  = (hmac_en_i) ? reg_hash_process_i | hash_process : reg_hash_process_i;
  assign hash_done_o         = (hmac_en_i) ? hmac_hash_done                    : sha_hash_done_i;

  assign pad_index_512 = txcount[BlockSizeBitsSHA512-1:HashWordBitsSHA256];
  assign pad_index_256 = txcount[BlockSizeBitsSHA256-1:HashWordBitsSHA256];

  // adjust inner and outer padding depending on key length and block size
  always_comb begin : adjust_key_pad_length
    // set defaults
    i_pad_256 = '{default: '0};
    i_pad_512 = '{default: '0};
    o_pad_256 = '{default: '0};
    o_pad_512 = '{default: '0};

    unique case (key_length_i)
      Key_128: begin
        i_pad_256 = {secret_key_i[1023:896],
                    {(BlockSizeSHA256-128){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
        i_pad_512 = {secret_key_i[1023:896],
                    {(BlockSizeSHA512-128){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
        o_pad_256 = {secret_key_i[1023:896],
                    {(BlockSizeSHA256-128){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
        o_pad_512 = {secret_key_i[1023:896],
                    {(BlockSizeSHA512-128){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      Key_256: begin
        i_pad_256 = {secret_key_i[1023:768],
                    {(BlockSizeSHA256-256){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
        i_pad_512 = {secret_key_i[1023:768],
                    {(BlockSizeSHA512-256){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
        o_pad_256 = {secret_key_i[1023:768],
                    {(BlockSizeSHA256-256){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
        o_pad_512 = {secret_key_i[1023:768],
                    {(BlockSizeSHA512-256){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      Key_384: begin
        i_pad_256 = {secret_key_i[1023:640],
                    {(BlockSizeSHA256-384){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
        i_pad_512 = {secret_key_i[1023:640],
                    {(BlockSizeSHA512-384){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
        o_pad_256 = {secret_key_i[1023:640],
                    {(BlockSizeSHA256-384){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
        o_pad_512 = {secret_key_i[1023:640],
                    {(BlockSizeSHA512-384){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      Key_512: begin
        i_pad_256 = secret_key_i[1023:512] ^ {(BlockSizeSHA256/8){8'h36}};
        i_pad_512 = {secret_key_i[1023:512],
                    {(BlockSizeSHA512-512){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
        o_pad_256 = secret_key_i[1023:512] ^ {(BlockSizeSHA256/8){8'h5c}};
        o_pad_512 = {secret_key_i[1023:512],
                    {(BlockSizeSHA512-512){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      Key_1024: begin // not allowed to be configured for SHA-2 256
        // zero out for SHA-2 256
        i_pad_256 = '{default: '0};
        i_pad_512 = secret_key_i[1023:0]   ^ {(BlockSizeSHA512/8){8'h36}};
        // zero out for SHA-2 256
        o_pad_256 = '{default: '0};
        o_pad_512 = secret_key_i[1023:0]   ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      default: begin
      end
    endcase
  end

  assign fifo_rready_o = (hmac_en_i) ? (st_q == StMsg) & sha_rready_i : sha_rready_i ;
  // sha_rvalid is controlled by State Machine below.
  assign sha_rvalid_o  = (!hmac_en_i) ? fifo_rvalid_i : hmac_sha_rvalid ;
  assign sha_rdata_o =
    (!hmac_en_i)    ? fifo_rdata_i                                                             :
    (sel_rdata == SelIPad && digest_size_i == SHA2_256)
                  ? '{data: i_pad_256[(BlockSizeSHA256-1)-32*pad_index_256-:32], mask: '1} :
    (sel_rdata == SelIPad && ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)))
                  ? '{data: i_pad_512[(BlockSizeSHA512-1)-32*pad_index_512-:32], mask: '1} :
    (sel_rdata == SelOPad && digest_size_i == SHA2_256)
                  ? '{data: o_pad_256[(BlockSizeSHA256-1)-32*pad_index_256-:32], mask: '1} :
    (sel_rdata == SelOPad && ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)))
                  ? '{data: o_pad_512[(BlockSizeSHA512-1)-32*pad_index_512-:32], mask: '1} :
    (sel_rdata == SelFifo) ? fifo_rdata_i                                                    :
                  '{default: '0};

  logic [63:0] sha_msg_len;

  always_comb begin: assign_sha_message_length
    sha_msg_len = '0;
    if (!hmac_en_i) begin
      sha_msg_len = message_length_i;
    // HASH = (o_pad || HASH_INTERMEDIATE (i_pad || msg))
    // message length for HASH_INTERMEDIATE = block size (i_pad) + message length
    end else if (sel_msglen == SelIPadMsg) begin
      if (digest_size_i == SHA2_256) begin
        sha_msg_len = message_length_i + BlockSizeSHA256in64;
      end else if ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)) begin
        sha_msg_len = message_length_i + BlockSizeSHA512in64;
      end
    end else if (sel_msglen == SelOPadMsg) begin
    // message length for HASH = block size (o_pad) + HASH_INTERMEDIATE digest length
      if (digest_size_i == SHA2_256) begin
        sha_msg_len = BlockSizeSHA256in64 + 64'd256;
      end else if (digest_size_i == SHA2_384) begin
        sha_msg_len = BlockSizeSHA512in64 + 64'd384;
      end else if (digest_size_i == SHA2_512) begin
        sha_msg_len = BlockSizeSHA512in64 + 64'd512;
      end
    end else
      sha_msg_len = '0;
  end

  assign sha_message_length_o = sha_msg_len;

  always_comb begin
    txcnt_eq_blksz = '0;

    unique case (digest_size_i)
      SHA2_256: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA256-1:0] == '0) && (txcount != '0);
      SHA2_384: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA512-1:0] == '0) && (txcount != '0);
      SHA2_512: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA512-1:0] == '0) && (txcount != '0);
      default;
    endcase
  end

  assign inc_txcount = sha_rready_i && sha_rvalid_o;

  // txcount
  //    Looks like txcount can be removed entirely here in hmac_core
  //    In the first round (InnerPaddedKey), it can just watch process and hash_done
  //    In the second round, it only needs count 256 bits for hash digest to trigger
  //    hash_process to SHA2
  always_comb begin
    txcount_d = txcount;
    if (clr_txcount) begin
      txcount_d = '0;
    end else if (load_txcount) begin
      // When loading, add block size to the message length because the SW-visible message length
      // does not include the block containing the key xor'ed with the inner pad.
      unique case (digest_size_i)
        SHA2_256: txcount_d = message_length_i + BlockSizeSHA256in64;
        SHA2_384: txcount_d = message_length_i + BlockSizeSHA512in64;
        SHA2_512: txcount_d = message_length_i + BlockSizeSHA512in64;
        default : txcount_d = message_length_i + '0;
      endcase
    end else if (inc_txcount) begin
      txcount_d[63:5] = txcount[63:5] + 1'b1; // increment by 32 (data word size)
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) txcount <= '0;
    else         txcount <= txcount_d;
  end

  // reg_hash_process_i trigger logic
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      reg_hash_process_flag <= 1'b0;
    end else if (reg_hash_process_i) begin
      reg_hash_process_flag <= 1'b1;
    end else if (hmac_hash_done || reg_hash_start_i || reg_hash_continue_i) begin
      reg_hash_process_flag <= 1'b0;
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      round_q <= Inner;
    end else if (update_round) begin
      round_q <= round_d;
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      fifo_wdata_sel_o <= 3'h 0;
    end else if (clr_fifo_wdata_sel) begin
      fifo_wdata_sel_o <= 3'h 0;
    end else if (fifo_wsel_o && fifo_wvalid_o) begin
      fifo_wdata_sel_o <= fifo_wdata_sel_o + 1'b1; // increment by 1
    end
  end

  assign sel_msglen = (round_q == Inner) ? SelIPadMsg : SelOPadMsg ;

  always_ff @(posedge clk_i or negedge rst_ni) begin : state_ff
    if (!rst_ni) st_q <= StIdle;
    else         st_q <= st_d;
  end

  always_comb begin : next_state
    hmac_hash_done     = 1'b0;
    hmac_sha_rvalid    = 1'b0;
    clr_txcount        = 1'b0;
    load_txcount       = 1'b0;
    update_round       = 1'b0;
    round_d            = Inner;
    fifo_wsel_o        = 1'b0;   // from register
    fifo_wvalid_o      = 1'b0;
    clr_fifo_wdata_sel = 1'b1;
    sel_rdata          = SelFifo;
    hash_start         = 1'b0;
    hash_continue      = 1'b0;
    hash_process       = 1'b0;
    st_d               = st_q;

    unique case (st_q)
      StIdle: begin
        // reset round to Inner
        // we always switch context into inner round since outer round computes once over
        // single block at the end (outer key pad + inner hash)
        update_round = 1'b1;
        round_d      = Inner;
        if (hmac_en_i && reg_hash_start_i) begin
          st_d = StIPad; // start at StIPad if told to start

          clr_txcount  = 1'b1;
          hash_start   = 1'b1;
        end else if (hmac_en_i && reg_hash_continue_i) begin
          st_d = StMsg; // skip StIPad if told to continue - assumed it finished StIPad

          load_txcount  = 1'b1;
          hash_continue = 1'b1;
        end else begin
          st_d = StIdle;
        end
      end

      StIPad: begin
        sel_rdata = SelIPad;

        if (txcnt_eq_blksz) begin
          st_d = StMsg;

          hmac_sha_rvalid = 1'b0; // block new read request
        end else begin
          st_d = StIPad;

          hmac_sha_rvalid = 1'b1;
        end
      end

      StMsg: begin
        sel_rdata   = SelFifo;
        fifo_wsel_o = (round_q == Outer);

        if ( (((round_q == Inner) && reg_hash_process_flag) || (round_q == Outer))
            && (txcount >= sha_message_length_o)) begin
          st_d    = StWaitResp;

          hmac_sha_rvalid = 1'b0; // block reading words from MSG FIFO
          hash_process    = (round_q == Outer);
        end else if (txcnt_eq_blksz && (txcount >= sha_message_length_o)
                     && reg_hash_stop_q && (round_q == Inner)) begin
          // wait till all MSG words are pushed out from FIFO (txcount reaches msg length)
          // before transitioning to StWaitResp to wait on sha_hash_done_i and disabling
          // reading from MSG FIFO
          st_d =  StWaitResp;

          hmac_sha_rvalid = 1'b0;
        end else begin
          st_d            = StMsg;
          hmac_sha_rvalid = fifo_rvalid_i;
        end
      end

      StWaitResp: begin
        hmac_sha_rvalid = 1'b0;

        if (sha_hash_done_i) begin
          if (round_q == Outer) begin
            st_d = StDone;
          end else begin // round_q == Inner
            if (reg_hash_stop_q) begin
              st_d = StDone;
            end else begin
              st_d = StPushToMsgFifo;
            end
          end
        end else begin
          st_d = StWaitResp;
        end
      end

      StPushToMsgFifo: begin
        hmac_sha_rvalid    = 1'b0;
        fifo_wsel_o        = 1'b1;
        fifo_wvalid_o      = 1'b1;
        clr_fifo_wdata_sel = 1'b0;

        if (fifo_wready_i && (((fifo_wdata_sel_o == 4'd7) && (digest_size_i == SHA2_256)) ||
                             ((fifo_wdata_sel_o == 4'd15) && (digest_size_i == SHA2_512)) ||
                             ((fifo_wdata_sel_o == 4'd11) && (digest_size_i == SHA2_384)))) begin

          st_d = StOPad;

          clr_txcount  = 1'b1;
          update_round = 1'b1;
          round_d      = Outer;
          hash_start   = 1'b1;
        end else begin
          st_d = StPushToMsgFifo;

        end
      end

      StOPad: begin
        sel_rdata   = SelOPad;
        fifo_wsel_o = 1'b1; // Remained HMAC select to indicate HMAC is in second stage

        if (txcnt_eq_blksz) begin
          st_d = StMsg;

          hmac_sha_rvalid = 1'b0; // block new read request
        end else begin
          st_d = StOPad;

          hmac_sha_rvalid = 1'b1;
        end
      end

      StDone: begin
        // raise interrupt (hash_done)
        st_d = StIdle;

        hmac_hash_done = 1'b1;
      end

      default: begin
        st_d = StIdle;
      end

    endcase
  end

  // raise reg_hash_stop_d flag at reg_hash_stop_i and keep it until sha_hash_done_i is asserted
  // to indicate the hashing operation on current block has completed
  assign reg_hash_stop_d = (reg_hash_stop_i == 1'b1)                            ? 1'b1 :
                           (sha_hash_done_i == 1'b1 && reg_hash_stop_q == 1'b1) ? 1'b0 :
                                                                                  reg_hash_stop_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      reg_hash_stop_q <= 1'b0;
    end else begin
      reg_hash_stop_q <= reg_hash_stop_d;
    end
  end

  // Idle status signaling: This module ..
  assign idle_d =
      // .. is not idle when told to start or continue
      (reg_hash_start_i || reg_hash_continue_i) ? 1'b0 :
      // .. is idle when the FSM is in the Idle state
      (st_q == StIdle) ? 1'b1 :
      // .. is idle when it has processed a complete block of a message and is told to stop in any
      // FSM state
      (txcnt_eq_blksz && reg_hash_stop_d) ? 1'b1 :
      // .. and keeps the current idle state in all other cases.
      idle_q;

  assign idle_o = idle_d;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      idle_q <= 1'b1;
    end else begin
      idle_q <= idle_d;
    end
  end
endmodule

    '''

    Identify relevant lint tags for the RTL to be checked for.
    Then run the tests using the linting tool.
    From the output of the linting tool, determine if there are security issues in the RTL.
================================== Ai Message ==================================
Tool Calls:
  retrieve_relevant_lint_tags (call_vFLYHwRgJb6Uw5cqxhhsOKMJ)
 Call ID: call_vFLYHwRgJb6Uw5cqxhhsOKMJ
  Args:
    query: register interface security FSM security
================================= Tool Message =================================
Name: retrieve_relevant_lint_tags

FsmUsage-ML: Finite State machine used

FsmLiveLock: Detects livelock states in FSM


STARC05-2.11.1.4: Number of states in a FSM should not exceed specified limit


LINT_FSM_WITHOUT_INITIAL_STATE: Do not have FSM without the initial state 


SepFSMLogic: Finite-state machine (FSM) and non-FSM logic is mixed in one module


LINT_INTERACTING_FSM: Reports violations for all the interacting FSMs in a design


MissingFsmStateTransition: Reports violation for a missing state transitions, which are not possible in FSM 


EnumStateDecl-ML: The Finite-state machine’s (FSM) enum states parameter declaration should appear before the reg declaration


NoExitInFSM-ML: Do not have states without exit in FSMs 


STARC05-2.11.2.1: FSM description should not be mixed with other descriptions in the same module. (Verilog)FSM description should not be mixed with non-FSM descriptions in the same module (VHDL) 


FSMCurrentStateName-ML: Current state vector of FSM does not follow the naming convention 


FSMNextStateName-ML: State name prefix or suffix 


NotReachableFsmState: Reports violation for not reachable state in FSM


LINT_FSM_WITHOUT_EXIT_STATE: Do not have states without exit in FSMs


STARC05-2.11.3.1: Ensure that the sequential and combinational parts of an FSM description should be in separate always blocks. (Verilog)Ensure that the sequential and combinational parts of an FSM description should be separated (VHDL)


NoExitFsmState: Reports violation if a state is reachable, and no other transition is possible in any of the clock cycle 


SepStateMachine: Combinational and sequential parts of a finite-state machine are combined in one process


AsgnNextSt-ML: Next state variable is not assigned in the default state of Finite-state machine (FSM) 


STARC05-1.4.3.4: Do not use flip-flop clock signals as non-clock signals 


STARC05-1.4.3.1b: Clocks should not be gated 
================================== Ai Message ==================================
Tool Calls:
  lint_checker_tool (call_n7shzeZnZHremoeOiXCc8fSB)
 Call ID: call_n7shzeZnZHremoeOiXCc8fSB
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_core.sv
    top_module: hmac_core
    lint_tags: ['FsmUsage-ML', 'FsmLiveLock', 'STARC05-2.11.1.4', 'LINT_FSM_WITHOUT_INITIAL_STATE', 'SepFSMLogic', 'LINT_INTERACTING_FSM', 'MissingFsmStateTransition', 'EnumStateDecl-ML', 'NoExitInFSM-ML', 'STARC05-2.11.2.1', 'FSMCurrentStateName-ML', 'FSMNextStateName-ML', 'NotReachableFsmState', 'LINT_FSM_WITHOUT_EXIT_STATE', 'STARC05-2.11.3.1', 'NoExitFsmState', 'SepStateMachine', 'AsgnNextSt-ML', 'STARC05-1.4.3.4', 'STARC05-1.4.3.1b']
================================= Tool Message =================================
Name: lint_checker_tool

Successfully executed:
```lint checker tool
```
Output: 
  -----------------------------------------------------------------------------
  Report Summary
  -----------------------------------------------------------------------------
  Product Info
    Name    : VC Static Master Shell
    Version : U-2023.03-1 -- Apr 17, 2023

  Report Info
    Created : May 06, 2025  16:18:41

    TopLevelModule: hmac_core

  -----------------------------------------------------------------------------
  Management Summary
  -----------------------------------------------------------------------------
  Stage           Family      Fatals    Errors  Warnings     Infos
  -----           --------  --------  --------  --------  --------
  LANGUAGE_CHECK  CODING           0         3         0         0
  -----           --------  --------  --------  --------  --------
  Total                            0         3         0         0


  -----------------------------------------------------------------------------
  Tree Summary
  -----------------------------------------------------------------------------
  Severity  Stage           Tag                    Count
  --------  -----           ---------------------  -----
  error     LANGUAGE_CHECK  FSMNextStateName-ML        1
  error     LANGUAGE_CHECK  FsmUsage-ML                1
  error     LANGUAGE_CHECK  STARC05-2.11.2.1           1
  --------  -----           ---------------------  -----
  Total                                                3



  -----------------------------------------------------------------------------
  FSMNextStateName-ML  (1 error/0 waived)
  -----------------------------------------------------------------------------
  Tag           : FSMNextStateName-ML
  Description   : Next register state [NodeName] doesn't match naming convention _ns
  Violation     : Lint:2
  Module        : hmac_core
  FileName      : build/lowrisc_ip_hmac_0.1/src/lowrisc_ip_hmac_0.1/rtl/hmac_core.sv
  LineNumber    : 450
  Statement     :         st_d = StIdle;
  NodeName      : st_d

  -----------------------------------------------------------------------------
  FsmUsage-ML  (1 error/0 waived)
  -----------------------------------------------------------------------------
  Tag           : FsmUsage-ML
  Description   : finite state machine used for state '[LHSExpr]' [Hierarchy: '[HIERARCHY]']
  Violation     : Lint:1
  Module        : hmac_core
  FileName      : build/lowrisc_ip_hmac_0.1/src/lowrisc_ip_hmac_0.1/rtl/hmac_core.sv
  LineNumber    : 327
  Statement     :     unique case (st_q)
  LHSExpr       : st_q
  HIERARCHY     : :hmac_core

  -----------------------------------------------------------------------------
  STARC05-2.11.2.1  (1 error/0 waived)
  -----------------------------------------------------------------------------
  Tag                : STARC05-2.11.2.1
  Description        : Non-FSM description mixed with FSM description (line '[CulpritLineNumber]' ,filename '[CulpritFileName]') in same module
  Violation          : Lint:3
  Module             : hmac_core
  FileName           : build/lowrisc_ip_hmac_0.1/src/lowrisc_ip_hmac_0.1/rtl/hmac_core.sv
  LineNumber         : 7
  Statement          : module hmac_core import prim_sha2_pkg::*; (
  CulpritLineNumber  : 311
  CulpritFileName    : build/lowrisc_ip_hmac_0.1/src/lowrisc_ip_hmac_0.1/rtl/hmac_core.sv

================================== Ai Message ==================================

The lint check for the hmac_core module on the provided RTL code reported the following issues related to FSM and register interface security:

1. FSMNextStateName-ML (Error):
   - The next state register name "st_d" does not follow the naming convention which expects a suffix "_ns" for next state variables.
   - This is a coding style issue that can affect readability and maintainability but is not a direct security vulnerability.

2. FsmUsage-ML (Error):
   - The finite state machine usage was detected on the state variable "st_q".
   - This is an informational lint indicating FSM usage, not necessarily an error or security issue by itself.

3. STARC05-2.11.2.1 (Error):
   - The FSM description is mixed with non-FSM descriptions in the same module.
   - This can lead to confusion and potential errors in FSM behavior, which might indirectly affect security if the FSM controls critical operations like register interface and hash processing.
   - The violation is reported at line 311 in the hmac_core.sv file.

Summary:
- The main security-related concern is the mixing of FSM and non-FSM logic in the same module, which can cause FSM behavior issues.
- The naming convention violation is a style issue.
- No direct security vulnerabilities like livelock, missing state transitions, or unreachable states were reported.

Recommendation:
- Refactor the code to separate FSM logic from non-FSM logic to improve clarity and reduce risk of FSM-related bugs.
- Follow naming conventions for FSM state variables.
- Review FSM transitions and state handling carefully to ensure no security issues are introduced due to complex state interactions.

Overall, the RTL does not show explicit security vulnerabilities related to register interface or FSM security from the lint results, but improvements in FSM coding practices are advised to enhance robustness and maintainability.
================================= Tool Message =================================
Name: run_linter_agent

The lint check for the hmac_core module on the provided RTL code reported the following issues related to FSM and register interface security:

1. FSMNextStateName-ML (Error):
   - The next state register name "st_d" does not follow the naming convention which expects a suffix "_ns" for next state variables.
   - This is a coding style issue that can affect readability and maintainability but is not a direct security vulnerability.

2. FsmUsage-ML (Error):
   - The finite state machine usage was detected on the state variable "st_q".
   - This is an informational lint indicating FSM usage, not necessarily an error or security issue by itself.

3. STARC05-2.11.2.1 (Error):
   - The FSM description is mixed with non-FSM descriptions in the same module.
   - This can lead to confusion and potential errors in FSM behavior, which might indirectly affect security if the FSM controls critical operations like register interface and hash processing.
   - The violation is reported at line 311 in the hmac_core.sv file.

Summary:
- The main security-related concern is the mixing of FSM and non-FSM logic in the same module, which can cause FSM behavior issues.
- The naming convention violation is a style issue.
- No direct security vulnerabilities like livelock, missing state transitions, or unreachable states were reported.

Recommendation:
- Refactor the code to separate FSM logic from non-FSM logic to improve clarity and reduce risk of FSM-related bugs.
- Follow naming conventions for FSM state variables.
- Review FSM transitions and state handling carefully to ensure no security issues are introduced due to complex state interactions.

Overall, the RTL does not show explicit security vulnerabilities related to register interface or FSM security from the lint results, but improvements in FSM coding practices are advised to enhance robustness and maintainability.
================================== Ai Message ==================================
Tool Calls:
  run_assertions_checker_agent (call_1Wxes70Sw6T0AuRPxkWTTqYa)
 Call ID: call_1Wxes70Sw6T0AuRPxkWTTqYa
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv
    top_module: hmac_reg_top
    security_objective: register access control and privilege enforcement
================================ Human Message =================================

Are there security concerns related to register access control and privilege enforcement in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv

    And the top module is:

    hmac_reg_top

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Register Top module auto-generated by `reggen`

`include "prim_assert.sv"

module hmac_reg_top (
  input clk_i,
  input rst_ni,
  input  tlul_pkg::tl_h2d_t tl_i,
  output tlul_pkg::tl_d2h_t tl_o,

  // Output port for window
  output tlul_pkg::tl_h2d_t tl_win_o,
  input  tlul_pkg::tl_d2h_t tl_win_i,

  // To HW
  output hmac_reg_pkg::hmac_reg2hw_t reg2hw, // Write
  input  hmac_reg_pkg::hmac_hw2reg_t hw2reg, // Read

  // Integrity check errors
  output logic intg_err_o
);

  import hmac_reg_pkg::* ;

  localparam int AW = 13;
  localparam int DW = 32;
  localparam int DBW = DW/8;                    // Byte Width

  // register signals
  logic           reg_we;
  logic           reg_re;
  logic [AW-1:0]  reg_addr;
  logic [DW-1:0]  reg_wdata;
  logic [DBW-1:0] reg_be;
  logic [DW-1:0]  reg_rdata;
  logic           reg_error;

  logic          addrmiss, wr_err;

  logic [DW-1:0] reg_rdata_next;
  logic reg_busy;

  tlul_pkg::tl_h2d_t tl_reg_h2d;
  tlul_pkg::tl_d2h_t tl_reg_d2h;


  // incoming payload check
  logic intg_err;
  tlul_cmd_intg_chk u_chk (
    .tl_i(tl_i),
    .err_o(intg_err)
  );

  // also check for spurious write enables
  logic reg_we_err;
  logic [58:0] reg_we_check;
  prim_reg_we_check #(
    .OneHotWidth(59)
  ) u_prim_reg_we_check (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .oh_i  (reg_we_check),
    .en_i  (reg_we && !addrmiss),
    .err_o (reg_we_err)
  );

  logic err_q;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      err_q <= '0;
    end else if (intg_err || reg_we_err) begin
      err_q <= 1'b1;
    end
  end

  // integrity error output is permanent and should be used for alert generation
  // register errors are transactional
  assign intg_err_o = err_q | intg_err | reg_we_err;

  // outgoing integrity generation
  tlul_pkg::tl_d2h_t tl_o_pre;
  tlul_rsp_intg_gen #(
    .EnableRspIntgGen(1),
    .EnableDataIntgGen(1)
  ) u_rsp_intg_gen (
    .tl_i(tl_o_pre),
    .tl_o(tl_o)
  );

  tlul_pkg::tl_h2d_t tl_socket_h2d [2];
  tlul_pkg::tl_d2h_t tl_socket_d2h [2];

  logic [0:0] reg_steer;

  // socket_1n connection
  assign tl_reg_h2d = tl_socket_h2d[1];
  assign tl_socket_d2h[1] = tl_reg_d2h;

  assign tl_win_o = tl_socket_h2d[0];
  assign tl_socket_d2h[0] = tl_win_i;

  // Create Socket_1n
  tlul_socket_1n #(
    .N            (2),
    .HReqPass     (1'b1),
    .HRspPass     (1'b1),
    .DReqPass     ({2{1'b1}}),
    .DRspPass     ({2{1'b1}}),
    .HReqDepth    (4'h0),
    .HRspDepth    (4'h0),
    .DReqDepth    ({2{4'h0}}),
    .DRspDepth    ({2{4'h0}}),
    .ExplicitErrs (1'b0)
  ) u_socket (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),
    .tl_h_i (tl_i),
    .tl_h_o (tl_o_pre),
    .tl_d_o (tl_socket_h2d),
    .tl_d_i (tl_socket_d2h),
    .dev_select_i (reg_steer)
  );

  // Create steering logic
  always_comb begin
    reg_steer =
        tl_i.a_address[AW-1:0] inside {[4096:8191]} ? 1'd0 :
        // Default set to register
        1'd1;

    // Override this in case of an integrity error
    if (intg_err) begin
      reg_steer = 1'd1;
    end
  end

  tlul_adapter_reg #(
    .RegAw(AW),
    .RegDw(DW),
    .EnableDataIntgGen(0)
  ) u_reg_if (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),

    .tl_i (tl_reg_h2d),
    .tl_o (tl_reg_d2h),

    .en_ifetch_i(prim_mubi_pkg::MuBi4False),
    .intg_error_o(),

    .we_o    (reg_we),
    .re_o    (reg_re),
    .addr_o  (reg_addr),
    .wdata_o (reg_wdata),
    .be_o    (reg_be),
    .busy_i  (reg_busy),
    .rdata_i (reg_rdata),
    .error_i (reg_error)
  );

  // cdc oversampling signals

  assign reg_rdata = reg_rdata_next ;
  assign reg_error = addrmiss | wr_err | intg_err;

  // Define SW related signals
  // Format: <reg>_<field>_{wd|we|qs}
  //        or <reg>_{wd|we|qs} if field == 1 or 0
  logic intr_state_we;
  logic intr_state_hmac_done_qs;
  logic intr_state_hmac_done_wd;
  logic intr_state_fifo_empty_qs;
  logic intr_state_hmac_err_qs;
  logic intr_state_hmac_err_wd;
  logic intr_enable_we;
  logic intr_enable_hmac_done_qs;
  logic intr_enable_hmac_done_wd;
  logic intr_enable_fifo_empty_qs;
  logic intr_enable_fifo_empty_wd;
  logic intr_enable_hmac_err_qs;
  logic intr_enable_hmac_err_wd;
  logic intr_test_we;
  logic intr_test_hmac_done_wd;
  logic intr_test_fifo_empty_wd;
  logic intr_test_hmac_err_wd;
  logic alert_test_we;
  logic alert_test_wd;
  logic cfg_re;
  logic cfg_we;
  logic cfg_hmac_en_qs;
  logic cfg_hmac_en_wd;
  logic cfg_sha_en_qs;
  logic cfg_sha_en_wd;
  logic cfg_endian_swap_qs;
  logic cfg_endian_swap_wd;
  logic cfg_digest_swap_qs;
  logic cfg_digest_swap_wd;
  logic cfg_key_swap_qs;
  logic cfg_key_swap_wd;
  logic [3:0] cfg_digest_size_qs;
  logic [3:0] cfg_digest_size_wd;
  logic [5:0] cfg_key_length_qs;
  logic [5:0] cfg_key_length_wd;
  logic cmd_we;
  logic cmd_hash_start_wd;
  logic cmd_hash_process_wd;
  logic cmd_hash_stop_wd;
  logic cmd_hash_continue_wd;
  logic status_re;
  logic status_hmac_idle_qs;
  logic status_fifo_empty_qs;
  logic status_fifo_full_qs;
  logic [5:0] status_fifo_depth_qs;
  logic [31:0] err_code_qs;
  logic wipe_secret_we;
  logic [31:0] wipe_secret_wd;
  logic key_0_we;
  logic [31:0] key_0_wd;
  logic key_1_we;
  logic [31:0] key_1_wd;
  logic key_2_we;
  logic [31:0] key_2_wd;
  logic key_3_we;
  logic [31:0] key_3_wd;
  logic key_4_we;
  logic [31:0] key_4_wd;
  logic key_5_we;
  logic [31:0] key_5_wd;
  logic key_6_we;
  logic [31:0] key_6_wd;
  logic key_7_we;
  logic [31:0] key_7_wd;
  logic key_8_we;
  logic [31:0] key_8_wd;
  logic key_9_we;
  logic [31:0] key_9_wd;
  logic key_10_we;
  logic [31:0] key_10_wd;
  logic key_11_we;
  logic [31:0] key_11_wd;
  logic key_12_we;
  logic [31:0] key_12_wd;
  logic key_13_we;
  logic [31:0] key_13_wd;
  logic key_14_we;
  logic [31:0] key_14_wd;
  logic key_15_we;
  logic [31:0] key_15_wd;
  logic key_16_we;
  logic [31:0] key_16_wd;
  logic key_17_we;
  logic [31:0] key_17_wd;
  logic key_18_we;
  logic [31:0] key_18_wd;
  logic key_19_we;
  logic [31:0] key_19_wd;
  logic key_20_we;
  logic [31:0] key_20_wd;
  logic key_21_we;
  logic [31:0] key_21_wd;
  logic key_22_we;
  logic [31:0] key_22_wd;
  logic key_23_we;
  logic [31:0] key_23_wd;
  logic key_24_we;
  logic [31:0] key_24_wd;
  logic key_25_we;
  logic [31:0] key_25_wd;
  logic key_26_we;
  logic [31:0] key_26_wd;
  logic key_27_we;
  logic [31:0] key_27_wd;
  logic key_28_we;
  logic [31:0] key_28_wd;
  logic key_29_we;
  logic [31:0] key_29_wd;
  logic key_30_we;
  logic [31:0] key_30_wd;
  logic key_31_we;
  logic [31:0] key_31_wd;
  logic digest_0_re;
  logic digest_0_we;
  logic [31:0] digest_0_qs;
  logic [31:0] digest_0_wd;
  logic digest_1_re;
  logic digest_1_we;
  logic [31:0] digest_1_qs;
  logic [31:0] digest_1_wd;
  logic digest_2_re;
  logic digest_2_we;
  logic [31:0] digest_2_qs;
  logic [31:0] digest_2_wd;
  logic digest_3_re;
  logic digest_3_we;
  logic [31:0] digest_3_qs;
  logic [31:0] digest_3_wd;
  logic digest_4_re;
  logic digest_4_we;
  logic [31:0] digest_4_qs;
  logic [31:0] digest_4_wd;
  logic digest_5_re;
  logic digest_5_we;
  logic [31:0] digest_5_qs;
  logic [31:0] digest_5_wd;
  logic digest_6_re;
  logic digest_6_we;
  logic [31:0] digest_6_qs;
  logic [31:0] digest_6_wd;
  logic digest_7_re;
  logic digest_7_we;
  logic [31:0] digest_7_qs;
  logic [31:0] digest_7_wd;
  logic digest_8_re;
  logic digest_8_we;
  logic [31:0] digest_8_qs;
  logic [31:0] digest_8_wd;
  logic digest_9_re;
  logic digest_9_we;
  logic [31:0] digest_9_qs;
  logic [31:0] digest_9_wd;
  logic digest_10_re;
  logic digest_10_we;
  logic [31:0] digest_10_qs;
  logic [31:0] digest_10_wd;
  logic digest_11_re;
  logic digest_11_we;
  logic [31:0] digest_11_qs;
  logic [31:0] digest_11_wd;
  logic digest_12_re;
  logic digest_12_we;
  logic [31:0] digest_12_qs;
  logic [31:0] digest_12_wd;
  logic digest_13_re;
  logic digest_13_we;
  logic [31:0] digest_13_qs;
  logic [31:0] digest_13_wd;
  logic digest_14_re;
  logic digest_14_we;
  logic [31:0] digest_14_qs;
  logic [31:0] digest_14_wd;
  logic digest_15_re;
  logic digest_15_we;
  logic [31:0] digest_15_qs;
  logic [31:0] digest_15_wd;
  logic msg_length_lower_re;
  logic msg_length_lower_we;
  logic [31:0] msg_length_lower_qs;
  logic [31:0] msg_length_lower_wd;
  logic msg_length_upper_re;
  logic msg_length_upper_we;
  logic [31:0] msg_length_upper_qs;
  logic [31:0] msg_length_upper_wd;

  // Register instances
  // R[intr_state]: V(False)
  //   F[hmac_done]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_hmac_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_hmac_done_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.hmac_done.de),
    .d      (hw2reg.intr_state.hmac_done.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.hmac_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_hmac_done_qs)
  );

  //   F[fifo_empty]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_fifo_empty (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.intr_state.fifo_empty.de),
    .d      (hw2reg.intr_state.fifo_empty.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.fifo_empty.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_fifo_empty_qs)
  );

  //   F[hmac_err]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_hmac_err (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_hmac_err_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.hmac_err.de),
    .d      (hw2reg.intr_state.hmac_err.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.hmac_err.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_hmac_err_qs)
  );


  // R[intr_enable]: V(False)
  //   F[hmac_done]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_hmac_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_hmac_done_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.hmac_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_hmac_done_qs)
  );

  //   F[fifo_empty]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_fifo_empty (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_fifo_empty_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.fifo_empty.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_fifo_empty_qs)
  );

  //   F[hmac_err]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_hmac_err (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_hmac_err_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.hmac_err.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_hmac_err_qs)
  );


  // R[intr_test]: V(True)
  logic intr_test_qe;
  logic [2:0] intr_test_flds_we;
  assign intr_test_qe = &intr_test_flds_we;
  //   F[hmac_done]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_hmac_done (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_hmac_done_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[0]),
    .q      (reg2hw.intr_test.hmac_done.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.hmac_done.qe = intr_test_qe;

  //   F[fifo_empty]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_fifo_empty (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_fifo_empty_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[1]),
    .q      (reg2hw.intr_test.fifo_empty.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.fifo_empty.qe = intr_test_qe;

  //   F[hmac_err]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_hmac_err (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_hmac_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[2]),
    .q      (reg2hw.intr_test.hmac_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.hmac_err.qe = intr_test_qe;


  // R[alert_test]: V(True)
  logic alert_test_qe;
  logic [0:0] alert_test_flds_we;
  assign alert_test_qe = &alert_test_flds_we;
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[0]),
    .q      (reg2hw.alert_test.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.qe = alert_test_qe;


  // R[cfg]: V(True)
  logic cfg_qe;
  logic [6:0] cfg_flds_we;
  assign cfg_qe = &cfg_flds_we;
  //   F[hmac_en]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_hmac_en (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_hmac_en_wd),
    .d      (hw2reg.cfg.hmac_en.d),
    .qre    (),
    .qe     (cfg_flds_we[0]),
    .q      (reg2hw.cfg.hmac_en.q),
    .ds     (),
    .qs     (cfg_hmac_en_qs)
  );
  assign reg2hw.cfg.hmac_en.qe = cfg_qe;

  //   F[sha_en]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_sha_en (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_sha_en_wd),
    .d      (hw2reg.cfg.sha_en.d),
    .qre    (),
    .qe     (cfg_flds_we[1]),
    .q      (reg2hw.cfg.sha_en.q),
    .ds     (),
    .qs     (cfg_sha_en_qs)
  );
  assign reg2hw.cfg.sha_en.qe = cfg_qe;

  //   F[endian_swap]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_endian_swap (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_endian_swap_wd),
    .d      (hw2reg.cfg.endian_swap.d),
    .qre    (),
    .qe     (cfg_flds_we[2]),
    .q      (reg2hw.cfg.endian_swap.q),
    .ds     (),
    .qs     (cfg_endian_swap_qs)
  );
  assign reg2hw.cfg.endian_swap.qe = cfg_qe;

  //   F[digest_swap]: 3:3
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_digest_swap (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_digest_swap_wd),
    .d      (hw2reg.cfg.digest_swap.d),
    .qre    (),
    .qe     (cfg_flds_we[3]),
    .q      (reg2hw.cfg.digest_swap.q),
    .ds     (),
    .qs     (cfg_digest_swap_qs)
  );
  assign reg2hw.cfg.digest_swap.qe = cfg_qe;

  //   F[key_swap]: 4:4
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_key_swap (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_key_swap_wd),
    .d      (hw2reg.cfg.key_swap.d),
    .qre    (),
    .qe     (cfg_flds_we[4]),
    .q      (reg2hw.cfg.key_swap.q),
    .ds     (),
    .qs     (cfg_key_swap_qs)
  );
  assign reg2hw.cfg.key_swap.qe = cfg_qe;

  //   F[digest_size]: 8:5
  prim_subreg_ext #(
    .DW    (4)
  ) u_cfg_digest_size (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_digest_size_wd),
    .d      (hw2reg.cfg.digest_size.d),
    .qre    (),
    .qe     (cfg_flds_we[5]),
    .q      (reg2hw.cfg.digest_size.q),
    .ds     (),
    .qs     (cfg_digest_size_qs)
  );
  assign reg2hw.cfg.digest_size.qe = cfg_qe;

  //   F[key_length]: 14:9
  prim_subreg_ext #(
    .DW    (6)
  ) u_cfg_key_length (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_key_length_wd),
    .d      (hw2reg.cfg.key_length.d),
    .qre    (),
    .qe     (cfg_flds_we[6]),
    .q      (reg2hw.cfg.key_length.q),
    .ds     (),
    .qs     (cfg_key_length_qs)
  );
  assign reg2hw.cfg.key_length.qe = cfg_qe;


  // R[cmd]: V(True)
  logic cmd_qe;
  logic [3:0] cmd_flds_we;
  assign cmd_qe = &cmd_flds_we;
  //   F[hash_start]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_start (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_start_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[0]),
    .q      (reg2hw.cmd.hash_start.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_start.qe = cmd_qe;

  //   F[hash_process]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_process (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_process_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[1]),
    .q      (reg2hw.cmd.hash_process.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_process.qe = cmd_qe;

  //   F[hash_stop]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_stop (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_stop_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[2]),
    .q      (reg2hw.cmd.hash_stop.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_stop.qe = cmd_qe;

  //   F[hash_continue]: 3:3
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_continue (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_continue_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[3]),
    .q      (reg2hw.cmd.hash_continue.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_continue.qe = cmd_qe;


  // R[status]: V(True)
  //   F[hmac_idle]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_hmac_idle (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.hmac_idle.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_hmac_idle_qs)
  );

  //   F[fifo_empty]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_fifo_empty (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_empty.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_empty_qs)
  );

  //   F[fifo_full]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_fifo_full (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_full.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_full_qs)
  );

  //   F[fifo_depth]: 9:4
  prim_subreg_ext #(
    .DW    (6)
  ) u_status_fifo_depth (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_depth.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_depth_qs)
  );


  // R[err_code]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_err_code (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.err_code.de),
    .d      (hw2reg.err_code.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (err_code_qs)
  );


  // R[wipe_secret]: V(True)
  logic wipe_secret_qe;
  logic [0:0] wipe_secret_flds_we;
  assign wipe_secret_qe = &wipe_secret_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_wipe_secret (
    .re     (1'b0),
    .we     (wipe_secret_we),
    .wd     (wipe_secret_wd),
    .d      ('0),
    .qre    (),
    .qe     (wipe_secret_flds_we[0]),
    .q      (reg2hw.wipe_secret.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.wipe_secret.qe = wipe_secret_qe;


  // Subregister 0 of Multireg key
  // R[key_0]: V(True)
  logic key_0_qe;
  logic [0:0] key_0_flds_we;
  assign key_0_qe = &key_0_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_0 (
    .re     (1'b0),
    .we     (key_0_we),
    .wd     (key_0_wd),
    .d      (hw2reg.key[0].d),
    .qre    (),
    .qe     (key_0_flds_we[0]),
    .q      (reg2hw.key[0].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[0].qe = key_0_qe;


  // Subregister 1 of Multireg key
  // R[key_1]: V(True)
  logic key_1_qe;
  logic [0:0] key_1_flds_we;
  assign key_1_qe = &key_1_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_1 (
    .re     (1'b0),
    .we     (key_1_we),
    .wd     (key_1_wd),
    .d      (hw2reg.key[1].d),
    .qre    (),
    .qe     (key_1_flds_we[0]),
    .q      (reg2hw.key[1].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[1].qe = key_1_qe;


  // Subregister 2 of Multireg key
  // R[key_2]: V(True)
  logic key_2_qe;
  logic [0:0] key_2_flds_we;
  assign key_2_qe = &key_2_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_2 (
    .re     (1'b0),
    .we     (key_2_we),
    .wd     (key_2_wd),
    .d      (hw2reg.key[2].d),
    .qre    (),
    .qe     (key_2_flds_we[0]),
    .q      (reg2hw.key[2].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[2].qe = key_2_qe;


  // Subregister 3 of Multireg key
  // R[key_3]: V(True)
  logic key_3_qe;
  logic [0:0] key_3_flds_we;
  assign key_3_qe = &key_3_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_3 (
    .re     (1'b0),
    .we     (key_3_we),
    .wd     (key_3_wd),
    .d      (hw2reg.key[3].d),
    .qre    (),
    .qe     (key_3_flds_we[0]),
    .q      (reg2hw.key[3].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[3].qe = key_3_qe;


  // Subregister 4 of Multireg key
  // R[key_4]: V(True)
  logic key_4_qe;
  logic [0:0] key_4_flds_we;
  assign key_4_qe = &key_4_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_4 (
    .re     (1'b0),
    .we     (key_4_we),
    .wd     (key_4_wd),
    .d      (hw2reg.key[4].d),
    .qre    (),
    .qe     (key_4_flds_we[0]),
    .q      (reg2hw.key[4].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[4].qe = key_4_qe;


  // Subregister 5 of Multireg key
  // R[key_5]: V(True)
  logic key_5_qe;
  logic [0:0] key_5_flds_we;
  assign key_5_qe = &key_5_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_5 (
    .re     (1'b0),
    .we     (key_5_we),
    .wd     (key_5_wd),
    .d      (hw2reg.key[5].d),
    .qre    (),
    .qe     (key_5_flds_we[0]),
    .q      (reg2hw.key[5].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[5].qe = key_5_qe;


  // Subregister 6 of Multireg key
  // R[key_6]: V(True)
  logic key_6_qe;
  logic [0:0] key_6_flds_we;
  assign key_6_qe = &key_6_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_6 (
    .re     (1'b0),
    .we     (key_6_we),
    .wd     (key_6_wd),
    .d      (hw2reg.key[6].d),
    .qre    (),
    .qe     (key_6_flds_we[0]),
    .q      (reg2hw.key[6].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[6].qe = key_6_qe;


  // Subregister 7 of Multireg key
  // R[key_7]: V(True)
  logic key_7_qe;
  logic [0:0] key_7_flds_we;
  assign key_7_qe = &key_7_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_7 (
    .re     (1'b0),
    .we     (key_7_we),
    .wd     (key_7_wd),
    .d      (hw2reg.key[7].d),
    .qre    (),
    .qe     (key_7_flds_we[0]),
    .q      (reg2hw.key[7].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[7].qe = key_7_qe;


  // Subregister 8 of Multireg key
  // R[key_8]: V(True)
  logic key_8_qe;
  logic [0:0] key_8_flds_we;
  assign key_8_qe = &key_8_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_8 (
    .re     (1'b0),
    .we     (key_8_we),
    .wd     (key_8_wd),
    .d      (hw2reg.key[8].d),
    .qre    (),
    .qe     (key_8_flds_we[0]),
    .q      (reg2hw.key[8].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[8].qe = key_8_qe;


  // Subregister 9 of Multireg key
  // R[key_9]: V(True)
  logic key_9_qe;
  logic [0:0] key_9_flds_we;
  assign key_9_qe = &key_9_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_9 (
    .re     (1'b0),
    .we     (key_9_we),
    .wd     (key_9_wd),
    .d      (hw2reg.key[9].d),
    .qre    (),
    .qe     (key_9_flds_we[0]),
    .q      (reg2hw.key[9].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[9].qe = key_9_qe;


  // Subregister 10 of Multireg key
  // R[key_10]: V(True)
  logic key_10_qe;
  logic [0:0] key_10_flds_we;
  assign key_10_qe = &key_10_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_10 (
    .re     (1'b0),
    .we     (key_10_we),
    .wd     (key_10_wd),
    .d      (hw2reg.key[10].d),
    .qre    (),
    .qe     (key_10_flds_we[0]),
    .q      (reg2hw.key[10].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[10].qe = key_10_qe;


  // Subregister 11 of Multireg key
  // R[key_11]: V(True)
  logic key_11_qe;
  logic [0:0] key_11_flds_we;
  assign key_11_qe = &key_11_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_11 (
    .re     (1'b0),
    .we     (key_11_we),
    .wd     (key_11_wd),
    .d      (hw2reg.key[11].d),
    .qre    (),
    .qe     (key_11_flds_we[0]),
    .q      (reg2hw.key[11].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[11].qe = key_11_qe;


  // Subregister 12 of Multireg key
  // R[key_12]: V(True)
  logic key_12_qe;
  logic [0:0] key_12_flds_we;
  assign key_12_qe = &key_12_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_12 (
    .re     (1'b0),
    .we     (key_12_we),
    .wd     (key_12_wd),
    .d      (hw2reg.key[12].d),
    .qre    (),
    .qe     (key_12_flds_we[0]),
    .q      (reg2hw.key[12].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[12].qe = key_12_qe;


  // Subregister 13 of Multireg key
  // R[key_13]: V(True)
  logic key_13_qe;
  logic [0:0] key_13_flds_we;
  assign key_13_qe = &key_13_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_13 (
    .re     (1'b0),
    .we     (key_13_we),
    .wd     (key_13_wd),
    .d      (hw2reg.key[13].d),
    .qre    (),
    .qe     (key_13_flds_we[0]),
    .q      (reg2hw.key[13].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[13].qe = key_13_qe;


  // Subregister 14 of Multireg key
  // R[key_14]: V(True)
  logic key_14_qe;
  logic [0:0] key_14_flds_we;
  assign key_14_qe = &key_14_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_14 (
    .re     (1'b0),
    .we     (key_14_we),
    .wd     (key_14_wd),
    .d      (hw2reg.key[14].d),
    .qre    (),
    .qe     (key_14_flds_we[0]),
    .q      (reg2hw.key[14].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[14].qe = key_14_qe;


  // Subregister 15 of Multireg key
  // R[key_15]: V(True)
  logic key_15_qe;
  logic [0:0] key_15_flds_we;
  assign key_15_qe = &key_15_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_15 (
    .re     (1'b0),
    .we     (key_15_we),
    .wd     (key_15_wd),
    .d      (hw2reg.key[15].d),
    .qre    (),
    .qe     (key_15_flds_we[0]),
    .q      (reg2hw.key[15].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[15].qe = key_15_qe;


  // Subregister 16 of Multireg key
  // R[key_16]: V(True)
  logic key_16_qe;
  logic [0:0] key_16_flds_we;
  assign key_16_qe = &key_16_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_16 (
    .re     (1'b0),
    .we     (key_16_we),
    .wd     (key_16_wd),
    .d      (hw2reg.key[16].d),
    .qre    (),
    .qe     (key_16_flds_we[0]),
    .q      (reg2hw.key[16].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[16].qe = key_16_qe;


  // Subregister 17 of Multireg key
  // R[key_17]: V(True)
  logic key_17_qe;
  logic [0:0] key_17_flds_we;
  assign key_17_qe = &key_17_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_17 (
    .re     (1'b0),
    .we     (key_17_we),
    .wd     (key_17_wd),
    .d      (hw2reg.key[17].d),
    .qre    (),
    .qe     (key_17_flds_we[0]),
    .q      (reg2hw.key[17].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[17].qe = key_17_qe;


  // Subregister 18 of Multireg key
  // R[key_18]: V(True)
  logic key_18_qe;
  logic [0:0] key_18_flds_we;
  assign key_18_qe = &key_18_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_18 (
    .re     (1'b0),
    .we     (key_18_we),
    .wd     (key_18_wd),
    .d      (hw2reg.key[18].d),
    .qre    (),
    .qe     (key_18_flds_we[0]),
    .q      (reg2hw.key[18].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[18].qe = key_18_qe;


  // Subregister 19 of Multireg key
  // R[key_19]: V(True)
  logic key_19_qe;
  logic [0:0] key_19_flds_we;
  assign key_19_qe = &key_19_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_19 (
    .re     (1'b0),
    .we     (key_19_we),
    .wd     (key_19_wd),
    .d      (hw2reg.key[19].d),
    .qre    (),
    .qe     (key_19_flds_we[0]),
    .q      (reg2hw.key[19].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[19].qe = key_19_qe;


  // Subregister 20 of Multireg key
  // R[key_20]: V(True)
  logic key_20_qe;
  logic [0:0] key_20_flds_we;
  assign key_20_qe = &key_20_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_20 (
    .re     (1'b0),
    .we     (key_20_we),
    .wd     (key_20_wd),
    .d      (hw2reg.key[20].d),
    .qre    (),
    .qe     (key_20_flds_we[0]),
    .q      (reg2hw.key[20].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[20].qe = key_20_qe;


  // Subregister 21 of Multireg key
  // R[key_21]: V(True)
  logic key_21_qe;
  logic [0:0] key_21_flds_we;
  assign key_21_qe = &key_21_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_21 (
    .re     (1'b0),
    .we     (key_21_we),
    .wd     (key_21_wd),
    .d      (hw2reg.key[21].d),
    .qre    (),
    .qe     (key_21_flds_we[0]),
    .q      (reg2hw.key[21].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[21].qe = key_21_qe;


  // Subregister 22 of Multireg key
  // R[key_22]: V(True)
  logic key_22_qe;
  logic [0:0] key_22_flds_we;
  assign key_22_qe = &key_22_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_22 (
    .re     (1'b0),
    .we     (key_22_we),
    .wd     (key_22_wd),
    .d      (hw2reg.key[22].d),
    .qre    (),
    .qe     (key_22_flds_we[0]),
    .q      (reg2hw.key[22].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[22].qe = key_22_qe;


  // Subregister 23 of Multireg key
  // R[key_23]: V(True)
  logic key_23_qe;
  logic [0:0] key_23_flds_we;
  assign key_23_qe = &key_23_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_23 (
    .re     (1'b0),
    .we     (key_23_we),
    .wd     (key_23_wd),
    .d      (hw2reg.key[23].d),
    .qre    (),
    .qe     (key_23_flds_we[0]),
    .q      (reg2hw.key[23].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[23].qe = key_23_qe;


  // Subregister 24 of Multireg key
  // R[key_24]: V(True)
  logic key_24_qe;
  logic [0:0] key_24_flds_we;
  assign key_24_qe = &key_24_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_24 (
    .re     (1'b0),
    .we     (key_24_we),
    .wd     (key_24_wd),
    .d      (hw2reg.key[24].d),
    .qre    (),
    .qe     (key_24_flds_we[0]),
    .q      (reg2hw.key[24].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[24].qe = key_24_qe;


  // Subregister 25 of Multireg key
  // R[key_25]: V(True)
  logic key_25_qe;
  logic [0:0] key_25_flds_we;
  assign key_25_qe = &key_25_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_25 (
    .re     (1'b0),
    .we     (key_25_we),
    .wd     (key_25_wd),
    .d      (hw2reg.key[25].d),
    .qre    (),
    .qe     (key_25_flds_we[0]),
    .q      (reg2hw.key[25].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[25].qe = key_25_qe;


  // Subregister 26 of Multireg key
  // R[key_26]: V(True)
  logic key_26_qe;
  logic [0:0] key_26_flds_we;
  assign key_26_qe = &key_26_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_26 (
    .re     (1'b0),
    .we     (key_26_we),
    .wd     (key_26_wd),
    .d      (hw2reg.key[26].d),
    .qre    (),
    .qe     (key_26_flds_we[0]),
    .q      (reg2hw.key[26].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[26].qe = key_26_qe;


  // Subregister 27 of Multireg key
  // R[key_27]: V(True)
  logic key_27_qe;
  logic [0:0] key_27_flds_we;
  assign key_27_qe = &key_27_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_27 (
    .re     (1'b0),
    .we     (key_27_we),
    .wd     (key_27_wd),
    .d      (hw2reg.key[27].d),
    .qre    (),
    .qe     (key_27_flds_we[0]),
    .q      (reg2hw.key[27].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[27].qe = key_27_qe;


  // Subregister 28 of Multireg key
  // R[key_28]: V(True)
  logic key_28_qe;
  logic [0:0] key_28_flds_we;
  assign key_28_qe = &key_28_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_28 (
    .re     (1'b0),
    .we     (key_28_we),
    .wd     (key_28_wd),
    .d      (hw2reg.key[28].d),
    .qre    (),
    .qe     (key_28_flds_we[0]),
    .q      (reg2hw.key[28].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[28].qe = key_28_qe;


  // Subregister 29 of Multireg key
  // R[key_29]: V(True)
  logic key_29_qe;
  logic [0:0] key_29_flds_we;
  assign key_29_qe = &key_29_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_29 (
    .re     (1'b0),
    .we     (key_29_we),
    .wd     (key_29_wd),
    .d      (hw2reg.key[29].d),
    .qre    (),
    .qe     (key_29_flds_we[0]),
    .q      (reg2hw.key[29].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[29].qe = key_29_qe;


  // Subregister 30 of Multireg key
  // R[key_30]: V(True)
  logic key_30_qe;
  logic [0:0] key_30_flds_we;
  assign key_30_qe = &key_30_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_30 (
    .re     (1'b0),
    .we     (key_30_we),
    .wd     (key_30_wd),
    .d      (hw2reg.key[30].d),
    .qre    (),
    .qe     (key_30_flds_we[0]),
    .q      (reg2hw.key[30].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[30].qe = key_30_qe;


  // Subregister 31 of Multireg key
  // R[key_31]: V(True)
  logic key_31_qe;
  logic [0:0] key_31_flds_we;
  assign key_31_qe = &key_31_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_31 (
    .re     (1'b0),
    .we     (key_31_we),
    .wd     (key_31_wd),
    .d      (hw2reg.key[31].d),
    .qre    (),
    .qe     (key_31_flds_we[0]),
    .q      (reg2hw.key[31].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[31].qe = key_31_qe;


  // Subregister 0 of Multireg digest
  // R[digest_0]: V(True)
  logic digest_0_qe;
  logic [0:0] digest_0_flds_we;
  assign digest_0_qe = &digest_0_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_0 (
    .re     (digest_0_re),
    .we     (digest_0_we),
    .wd     (digest_0_wd),
    .d      (hw2reg.digest[0].d),
    .qre    (),
    .qe     (digest_0_flds_we[0]),
    .q      (reg2hw.digest[0].q),
    .ds     (),
    .qs     (digest_0_qs)
  );
  assign reg2hw.digest[0].qe = digest_0_qe;


  // Subregister 1 of Multireg digest
  // R[digest_1]: V(True)
  logic digest_1_qe;
  logic [0:0] digest_1_flds_we;
  assign digest_1_qe = &digest_1_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_1 (
    .re     (digest_1_re),
    .we     (digest_1_we),
    .wd     (digest_1_wd),
    .d      (hw2reg.digest[1].d),
    .qre    (),
    .qe     (digest_1_flds_we[0]),
    .q      (reg2hw.digest[1].q),
    .ds     (),
    .qs     (digest_1_qs)
  );
  assign reg2hw.digest[1].qe = digest_1_qe;


  // Subregister 2 of Multireg digest
  // R[digest_2]: V(True)
  logic digest_2_qe;
  logic [0:0] digest_2_flds_we;
  assign digest_2_qe = &digest_2_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_2 (
    .re     (digest_2_re),
    .we     (digest_2_we),
    .wd     (digest_2_wd),
    .d      (hw2reg.digest[2].d),
    .qre    (),
    .qe     (digest_2_flds_we[0]),
    .q      (reg2hw.digest[2].q),
    .ds     (),
    .qs     (digest_2_qs)
  );
  assign reg2hw.digest[2].qe = digest_2_qe;


  // Subregister 3 of Multireg digest
  // R[digest_3]: V(True)
  logic digest_3_qe;
  logic [0:0] digest_3_flds_we;
  assign digest_3_qe = &digest_3_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_3 (
    .re     (digest_3_re),
    .we     (digest_3_we),
    .wd     (digest_3_wd),
    .d      (hw2reg.digest[3].d),
    .qre    (),
    .qe     (digest_3_flds_we[0]),
    .q      (reg2hw.digest[3].q),
    .ds     (),
    .qs     (digest_3_qs)
  );
  assign reg2hw.digest[3].qe = digest_3_qe;


  // Subregister 4 of Multireg digest
  // R[digest_4]: V(True)
  logic digest_4_qe;
  logic [0:0] digest_4_flds_we;
  assign digest_4_qe = &digest_4_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_4 (
    .re     (digest_4_re),
    .we     (digest_4_we),
    .wd     (digest_4_wd),
    .d      (hw2reg.digest[4].d),
    .qre    (),
    .qe     (digest_4_flds_we[0]),
    .q      (reg2hw.digest[4].q),
    .ds     (),
    .qs     (digest_4_qs)
  );
  assign reg2hw.digest[4].qe = digest_4_qe;


  // Subregister 5 of Multireg digest
  // R[digest_5]: V(True)
  logic digest_5_qe;
  logic [0:0] digest_5_flds_we;
  assign digest_5_qe = &digest_5_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_5 (
    .re     (digest_5_re),
    .we     (digest_5_we),
    .wd     (digest_5_wd),
    .d      (hw2reg.digest[5].d),
    .qre    (),
    .qe     (digest_5_flds_we[0]),
    .q      (reg2hw.digest[5].q),
    .ds     (),
    .qs     (digest_5_qs)
  );
  assign reg2hw.digest[5].qe = digest_5_qe;


  // Subregister 6 of Multireg digest
  // R[digest_6]: V(True)
  logic digest_6_qe;
  logic [0:0] digest_6_flds_we;
  assign digest_6_qe = &digest_6_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_6 (
    .re     (digest_6_re),
    .we     (digest_6_we),
    .wd     (digest_6_wd),
    .d      (hw2reg.digest[6].d),
    .qre    (),
    .qe     (digest_6_flds_we[0]),
    .q      (reg2hw.digest[6].q),
    .ds     (),
    .qs     (digest_6_qs)
  );
  assign reg2hw.digest[6].qe = digest_6_qe;


  // Subregister 7 of Multireg digest
  // R[digest_7]: V(True)
  logic digest_7_qe;
  logic [0:0] digest_7_flds_we;
  assign digest_7_qe = &digest_7_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_7 (
    .re     (digest_7_re),
    .we     (digest_7_we),
    .wd     (digest_7_wd),
    .d      (hw2reg.digest[7].d),
    .qre    (),
    .qe     (digest_7_flds_we[0]),
    .q      (reg2hw.digest[7].q),
    .ds     (),
    .qs     (digest_7_qs)
  );
  assign reg2hw.digest[7].qe = digest_7_qe;


  // Subregister 8 of Multireg digest
  // R[digest_8]: V(True)
  logic digest_8_qe;
  logic [0:0] digest_8_flds_we;
  assign digest_8_qe = &digest_8_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_8 (
    .re     (digest_8_re),
    .we     (digest_8_we),
    .wd     (digest_8_wd),
    .d      (hw2reg.digest[8].d),
    .qre    (),
    .qe     (digest_8_flds_we[0]),
    .q      (reg2hw.digest[8].q),
    .ds     (),
    .qs     (digest_8_qs)
  );
  assign reg2hw.digest[8].qe = digest_8_qe;


  // Subregister 9 of Multireg digest
  // R[digest_9]: V(True)
  logic digest_9_qe;
  logic [0:0] digest_9_flds_we;
  assign digest_9_qe = &digest_9_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_9 (
    .re     (digest_9_re),
    .we     (digest_9_we),
    .wd     (digest_9_wd),
    .d      (hw2reg.digest[9].d),
    .qre    (),
    .qe     (digest_9_flds_we[0]),
    .q      (reg2hw.digest[9].q),
    .ds     (),
    .qs     (digest_9_qs)
  );
  assign reg2hw.digest[9].qe = digest_9_qe;


  // Subregister 10 of Multireg digest
  // R[digest_10]: V(True)
  logic digest_10_qe;
  logic [0:0] digest_10_flds_we;
  assign digest_10_qe = &digest_10_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_10 (
    .re     (digest_10_re),
    .we     (digest_10_we),
    .wd     (digest_10_wd),
    .d      (hw2reg.digest[10].d),
    .qre    (),
    .qe     (digest_10_flds_we[0]),
    .q      (reg2hw.digest[10].q),
    .ds     (),
    .qs     (digest_10_qs)
  );
  assign reg2hw.digest[10].qe = digest_10_qe;


  // Subregister 11 of Multireg digest
  // R[digest_11]: V(True)
  logic digest_11_qe;
  logic [0:0] digest_11_flds_we;
  assign digest_11_qe = &digest_11_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_11 (
    .re     (digest_11_re),
    .we     (digest_11_we),
    .wd     (digest_11_wd),
    .d      (hw2reg.digest[11].d),
    .qre    (),
    .qe     (digest_11_flds_we[0]),
    .q      (reg2hw.digest[11].q),
    .ds     (),
    .qs     (digest_11_qs)
  );
  assign reg2hw.digest[11].qe = digest_11_qe;


  // Subregister 12 of Multireg digest
  // R[digest_12]: V(True)
  logic digest_12_qe;
  logic [0:0] digest_12_flds_we;
  assign digest_12_qe = &digest_12_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_12 (
    .re     (digest_12_re),
    .we     (digest_12_we),
    .wd     (digest_12_wd),
    .d      (hw2reg.digest[12].d),
    .qre    (),
    .qe     (digest_12_flds_we[0]),
    .q      (reg2hw.digest[12].q),
    .ds     (),
    .qs     (digest_12_qs)
  );
  assign reg2hw.digest[12].qe = digest_12_qe;


  // Subregister 13 of Multireg digest
  // R[digest_13]: V(True)
  logic digest_13_qe;
  logic [0:0] digest_13_flds_we;
  assign digest_13_qe = &digest_13_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_13 (
    .re     (digest_13_re),
    .we     (digest_13_we),
    .wd     (digest_13_wd),
    .d      (hw2reg.digest[13].d),
    .qre    (),
    .qe     (digest_13_flds_we[0]),
    .q      (reg2hw.digest[13].q),
    .ds     (),
    .qs     (digest_13_qs)
  );
  assign reg2hw.digest[13].qe = digest_13_qe;


  // Subregister 14 of Multireg digest
  // R[digest_14]: V(True)
  logic digest_14_qe;
  logic [0:0] digest_14_flds_we;
  assign digest_14_qe = &digest_14_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_14 (
    .re     (digest_14_re),
    .we     (digest_14_we),
    .wd     (digest_14_wd),
    .d      (hw2reg.digest[14].d),
    .qre    (),
    .qe     (digest_14_flds_we[0]),
    .q      (reg2hw.digest[14].q),
    .ds     (),
    .qs     (digest_14_qs)
  );
  assign reg2hw.digest[14].qe = digest_14_qe;


  // Subregister 15 of Multireg digest
  // R[digest_15]: V(True)
  logic digest_15_qe;
  logic [0:0] digest_15_flds_we;
  assign digest_15_qe = &digest_15_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_15 (
    .re     (digest_15_re),
    .we     (digest_15_we),
    .wd     (digest_15_wd),
    .d      (hw2reg.digest[15].d),
    .qre    (),
    .qe     (digest_15_flds_we[0]),
    .q      (reg2hw.digest[15].q),
    .ds     (),
    .qs     (digest_15_qs)
  );
  assign reg2hw.digest[15].qe = digest_15_qe;


  // R[msg_length_lower]: V(True)
  logic msg_length_lower_qe;
  logic [0:0] msg_length_lower_flds_we;
  assign msg_length_lower_qe = &msg_length_lower_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_msg_length_lower (
    .re     (msg_length_lower_re),
    .we     (msg_length_lower_we),
    .wd     (msg_length_lower_wd),
    .d      (hw2reg.msg_length_lower.d),
    .qre    (),
    .qe     (msg_length_lower_flds_we[0]),
    .q      (reg2hw.msg_length_lower.q),
    .ds     (),
    .qs     (msg_length_lower_qs)
  );
  assign reg2hw.msg_length_lower.qe = msg_length_lower_qe;


  // R[msg_length_upper]: V(True)
  logic msg_length_upper_qe;
  logic [0:0] msg_length_upper_flds_we;
  assign msg_length_upper_qe = &msg_length_upper_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_msg_length_upper (
    .re     (msg_length_upper_re),
    .we     (msg_length_upper_we),
    .wd     (msg_length_upper_wd),
    .d      (hw2reg.msg_length_upper.d),
    .qre    (),
    .qe     (msg_length_upper_flds_we[0]),
    .q      (reg2hw.msg_length_upper.q),
    .ds     (),
    .qs     (msg_length_upper_qs)
  );
  assign reg2hw.msg_length_upper.qe = msg_length_upper_qe;



  logic [58:0] addr_hit;
  always_comb begin
    addr_hit = '0;
    addr_hit[ 0] = (reg_addr == HMAC_INTR_STATE_OFFSET);
    addr_hit[ 1] = (reg_addr == HMAC_INTR_ENABLE_OFFSET);
    addr_hit[ 2] = (reg_addr == HMAC_INTR_TEST_OFFSET);
    addr_hit[ 3] = (reg_addr == HMAC_ALERT_TEST_OFFSET);
    addr_hit[ 4] = (reg_addr == HMAC_CFG_OFFSET);
    addr_hit[ 5] = (reg_addr == HMAC_CMD_OFFSET);
    addr_hit[ 6] = (reg_addr == HMAC_STATUS_OFFSET);
    addr_hit[ 7] = (reg_addr == HMAC_ERR_CODE_OFFSET);
    addr_hit[ 8] = (reg_addr == HMAC_WIPE_SECRET_OFFSET);
    addr_hit[ 9] = (reg_addr == HMAC_KEY_0_OFFSET);
    addr_hit[10] = (reg_addr == HMAC_KEY_1_OFFSET);
    addr_hit[11] = (reg_addr == HMAC_KEY_2_OFFSET);
    addr_hit[12] = (reg_addr == HMAC_KEY_3_OFFSET);
    addr_hit[13] = (reg_addr == HMAC_KEY_4_OFFSET);
    addr_hit[14] = (reg_addr == HMAC_KEY_5_OFFSET);
    addr_hit[15] = (reg_addr == HMAC_KEY_6_OFFSET);
    addr_hit[16] = (reg_addr == HMAC_KEY_7_OFFSET);
    addr_hit[17] = (reg_addr == HMAC_KEY_8_OFFSET);
    addr_hit[18] = (reg_addr == HMAC_KEY_9_OFFSET);
    addr_hit[19] = (reg_addr == HMAC_KEY_10_OFFSET);
    addr_hit[20] = (reg_addr == HMAC_KEY_11_OFFSET);
    addr_hit[21] = (reg_addr == HMAC_KEY_12_OFFSET);
    addr_hit[22] = (reg_addr == HMAC_KEY_13_OFFSET);
    addr_hit[23] = (reg_addr == HMAC_KEY_14_OFFSET);
    addr_hit[24] = (reg_addr == HMAC_KEY_15_OFFSET);
    addr_hit[25] = (reg_addr == HMAC_KEY_16_OFFSET);
    addr_hit[26] = (reg_addr == HMAC_KEY_17_OFFSET);
    addr_hit[27] = (reg_addr == HMAC_KEY_18_OFFSET);
    addr_hit[28] = (reg_addr == HMAC_KEY_19_OFFSET);
    addr_hit[29] = (reg_addr == HMAC_KEY_20_OFFSET);
    addr_hit[30] = (reg_addr == HMAC_KEY_21_OFFSET);
    addr_hit[31] = (reg_addr == HMAC_KEY_22_OFFSET);
    addr_hit[32] = (reg_addr == HMAC_KEY_23_OFFSET);
    addr_hit[33] = (reg_addr == HMAC_KEY_24_OFFSET);
    addr_hit[34] = (reg_addr == HMAC_KEY_25_OFFSET);
    addr_hit[35] = (reg_addr == HMAC_KEY_26_OFFSET);
    addr_hit[36] = (reg_addr == HMAC_KEY_27_OFFSET);
    addr_hit[37] = (reg_addr == HMAC_KEY_28_OFFSET);
    addr_hit[38] = (reg_addr == HMAC_KEY_29_OFFSET);
    addr_hit[39] = (reg_addr == HMAC_KEY_30_OFFSET);
    addr_hit[40] = (reg_addr == HMAC_KEY_31_OFFSET);
    addr_hit[41] = (reg_addr == HMAC_DIGEST_0_OFFSET);
    addr_hit[42] = (reg_addr == HMAC_DIGEST_1_OFFSET);
    addr_hit[43] = (reg_addr == HMAC_DIGEST_2_OFFSET);
    addr_hit[44] = (reg_addr == HMAC_DIGEST_3_OFFSET);
    addr_hit[45] = (reg_addr == HMAC_DIGEST_4_OFFSET);
    addr_hit[46] = (reg_addr == HMAC_DIGEST_5_OFFSET);
    addr_hit[47] = (reg_addr == HMAC_DIGEST_6_OFFSET);
    addr_hit[48] = (reg_addr == HMAC_DIGEST_7_OFFSET);
    addr_hit[49] = (reg_addr == HMAC_DIGEST_8_OFFSET);
    addr_hit[50] = (reg_addr == HMAC_DIGEST_9_OFFSET);
    addr_hit[51] = (reg_addr == HMAC_DIGEST_10_OFFSET);
    addr_hit[52] = (reg_addr == HMAC_DIGEST_11_OFFSET);
    addr_hit[53] = (reg_addr == HMAC_DIGEST_12_OFFSET);
    addr_hit[54] = (reg_addr == HMAC_DIGEST_13_OFFSET);
    addr_hit[55] = (reg_addr == HMAC_DIGEST_14_OFFSET);
    addr_hit[56] = (reg_addr == HMAC_DIGEST_15_OFFSET);
    addr_hit[57] = (reg_addr == HMAC_MSG_LENGTH_LOWER_OFFSET);
    addr_hit[58] = (reg_addr == HMAC_MSG_LENGTH_UPPER_OFFSET);
  end

  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;

  // Check sub-word write is permitted
  always_comb begin
    wr_err = (reg_we &
              ((addr_hit[ 0] & (|(HMAC_PERMIT[ 0] & ~reg_be))) |
               (addr_hit[ 1] & (|(HMAC_PERMIT[ 1] & ~reg_be))) |
               (addr_hit[ 2] & (|(HMAC_PERMIT[ 2] & ~reg_be))) |
               (addr_hit[ 3] & (|(HMAC_PERMIT[ 3] & ~reg_be))) |
               (addr_hit[ 4] & (|(HMAC_PERMIT[ 4] & ~reg_be))) |
               (addr_hit[ 5] & (|(HMAC_PERMIT[ 5] & ~reg_be))) |
               (addr_hit[ 6] & (|(HMAC_PERMIT[ 6] & ~reg_be))) |
               (addr_hit[ 7] & (|(HMAC_PERMIT[ 7] & ~reg_be))) |
               (addr_hit[ 8] & (|(HMAC_PERMIT[ 8] & ~reg_be))) |
               (addr_hit[ 9] & (|(HMAC_PERMIT[ 9] & ~reg_be))) |
               (addr_hit[10] & (|(HMAC_PERMIT[10] & ~reg_be))) |
               (addr_hit[11] & (|(HMAC_PERMIT[11] & ~reg_be))) |
               (addr_hit[12] & (|(HMAC_PERMIT[12] & ~reg_be))) |
               (addr_hit[13] & (|(HMAC_PERMIT[13] & ~reg_be))) |
               (addr_hit[14] & (|(HMAC_PERMIT[14] & ~reg_be))) |
               (addr_hit[15] & (|(HMAC_PERMIT[15] & ~reg_be))) |
               (addr_hit[16] & (|(HMAC_PERMIT[16] & ~reg_be))) |
               (addr_hit[17] & (|(HMAC_PERMIT[17] & ~reg_be))) |
               (addr_hit[18] & (|(HMAC_PERMIT[18] & ~reg_be))) |
               (addr_hit[19] & (|(HMAC_PERMIT[19] & ~reg_be))) |
               (addr_hit[20] & (|(HMAC_PERMIT[20] & ~reg_be))) |
               (addr_hit[21] & (|(HMAC_PERMIT[21] & ~reg_be))) |
               (addr_hit[22] & (|(HMAC_PERMIT[22] & ~reg_be))) |
               (addr_hit[23] & (|(HMAC_PERMIT[23] & ~reg_be))) |
               (addr_hit[24] & (|(HMAC_PERMIT[24] & ~reg_be))) |
               (addr_hit[25] & (|(HMAC_PERMIT[25] & ~reg_be))) |
               (addr_hit[26] & (|(HMAC_PERMIT[26] & ~reg_be))) |
               (addr_hit[27] & (|(HMAC_PERMIT[27] & ~reg_be))) |
               (addr_hit[28] & (|(HMAC_PERMIT[28] & ~reg_be))) |
               (addr_hit[29] & (|(HMAC_PERMIT[29] & ~reg_be))) |
               (addr_hit[30] & (|(HMAC_PERMIT[30] & ~reg_be))) |
               (addr_hit[31] & (|(HMAC_PERMIT[31] & ~reg_be))) |
               (addr_hit[32] & (|(HMAC_PERMIT[32] & ~reg_be))) |
               (addr_hit[33] & (|(HMAC_PERMIT[33] & ~reg_be))) |
               (addr_hit[34] & (|(HMAC_PERMIT[34] & ~reg_be))) |
               (addr_hit[35] & (|(HMAC_PERMIT[35] & ~reg_be))) |
               (addr_hit[36] & (|(HMAC_PERMIT[36] & ~reg_be))) |
               (addr_hit[37] & (|(HMAC_PERMIT[37] & ~reg_be))) |
               (addr_hit[38] & (|(HMAC_PERMIT[38] & ~reg_be))) |
               (addr_hit[39] & (|(HMAC_PERMIT[39] & ~reg_be))) |
               (addr_hit[40] & (|(HMAC_PERMIT[40] & ~reg_be))) |
               (addr_hit[41] & (|(HMAC_PERMIT[41] & ~reg_be))) |
               (addr_hit[42] & (|(HMAC_PERMIT[42] & ~reg_be))) |
               (addr_hit[43] & (|(HMAC_PERMIT[43] & ~reg_be))) |
               (addr_hit[44] & (|(HMAC_PERMIT[44] & ~reg_be))) |
               (addr_hit[45] & (|(HMAC_PERMIT[45] & ~reg_be))) |
               (addr_hit[46] & (|(HMAC_PERMIT[46] & ~reg_be))) |
               (addr_hit[47] & (|(HMAC_PERMIT[47] & ~reg_be))) |
               (addr_hit[48] & (|(HMAC_PERMIT[48] & ~reg_be))) |
               (addr_hit[49] & (|(HMAC_PERMIT[49] & ~reg_be))) |
               (addr_hit[50] & (|(HMAC_PERMIT[50] & ~reg_be))) |
               (addr_hit[51] & (|(HMAC_PERMIT[51] & ~reg_be))) |
               (addr_hit[52] & (|(HMAC_PERMIT[52] & ~reg_be))) |
               (addr_hit[53] & (|(HMAC_PERMIT[53] & ~reg_be))) |
               (addr_hit[54] & (|(HMAC_PERMIT[54] & ~reg_be))) |
               (addr_hit[55] & (|(HMAC_PERMIT[55] & ~reg_be))) |
               (addr_hit[56] & (|(HMAC_PERMIT[56] & ~reg_be))) |
               (addr_hit[57] & (|(HMAC_PERMIT[57] & ~reg_be))) |
               (addr_hit[58] & (|(HMAC_PERMIT[58] & ~reg_be)))));
  end

  // Generate write-enables
  assign intr_state_we = addr_hit[0] & reg_we & !reg_error;

  assign intr_state_hmac_done_wd = reg_wdata[0];

  assign intr_state_hmac_err_wd = reg_wdata[2];
  assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;

  assign intr_enable_hmac_done_wd = reg_wdata[0];

  assign intr_enable_fifo_empty_wd = reg_wdata[1];

  assign intr_enable_hmac_err_wd = reg_wdata[2];
  assign intr_test_we = addr_hit[2] & reg_we & !reg_error;

  assign intr_test_hmac_done_wd = reg_wdata[0];

  assign intr_test_fifo_empty_wd = reg_wdata[1];

  assign intr_test_hmac_err_wd = reg_wdata[2];
  assign alert_test_we = addr_hit[3] & reg_we & !reg_error;

  assign alert_test_wd = reg_wdata[0];
  assign cfg_re = addr_hit[4] & reg_re & !reg_error;
  assign cfg_we = addr_hit[4] & reg_we & !reg_error;

  assign cfg_hmac_en_wd = reg_wdata[0];

  assign cfg_sha_en_wd = reg_wdata[1];

  assign cfg_endian_swap_wd = reg_wdata[2];

  assign cfg_digest_swap_wd = reg_wdata[3];

  assign cfg_key_swap_wd = reg_wdata[4];

  assign cfg_digest_size_wd = reg_wdata[8:5];

  assign cfg_key_length_wd = reg_wdata[14:9];
  assign cmd_we = addr_hit[5] & reg_we & !reg_error;

  assign cmd_hash_start_wd = reg_wdata[0];

  assign cmd_hash_process_wd = reg_wdata[1];

  assign cmd_hash_stop_wd = reg_wdata[2];

  assign cmd_hash_continue_wd = reg_wdata[3];
  assign status_re = addr_hit[6] & reg_re & !reg_error;
  assign wipe_secret_we = addr_hit[8] & reg_we & reg_error;

  assign wipe_secret_wd = reg_wdata[31:0];
  assign key_0_we = addr_hit[9] & reg_we & !reg_error;

  assign key_0_wd = reg_wdata[31:0];
  assign key_1_we = addr_hit[10] & reg_we & !reg_error;

  assign key_1_wd = reg_wdata[31:0];
  assign key_2_we = addr_hit[11] & reg_we & !reg_error;

  assign key_2_wd = reg_wdata[31:0];
  assign key_3_we = addr_hit[12] & reg_we & !reg_error;

  assign key_3_wd = reg_wdata[31:0];
  assign key_4_we = addr_hit[13] & reg_we & !reg_error;

  assign key_4_wd = reg_wdata[31:0];
  assign key_5_we = addr_hit[14] & reg_we & !reg_error;

  assign key_5_wd = reg_wdata[31:0];
  assign key_6_we = addr_hit[15] & reg_we & !reg_error;

  assign key_6_wd = reg_wdata[31:0];
  assign key_7_we = addr_hit[16] & reg_we & !reg_error;

  assign key_7_wd = reg_wdata[31:0];
  assign key_8_we = addr_hit[17] & reg_we & !reg_error;

  assign key_8_wd = reg_wdata[31:0];
  assign key_9_we = addr_hit[18] & reg_we & !reg_error;

  assign key_9_wd = reg_wdata[31:0];
  assign key_10_we = addr_hit[19] & reg_we & !reg_error;

  assign key_10_wd = reg_wdata[31:0];
  assign key_11_we = addr_hit[20] & reg_we & !reg_error;

  assign key_11_wd = reg_wdata[31:0];
  assign key_12_we = addr_hit[21] & reg_we & !reg_error;

  assign key_12_wd = reg_wdata[31:0];
  assign key_13_we = addr_hit[22] & reg_we & !reg_error;

  assign key_13_wd = reg_wdata[31:0];
  assign key_14_we = addr_hit[23] & reg_we & !reg_error;

  assign key_14_wd = reg_wdata[31:0];
  assign key_15_we = addr_hit[24] & reg_we & !reg_error;

  assign key_15_wd = reg_wdata[31:0];
  assign key_16_we = addr_hit[25] & reg_we & !reg_error;

  assign key_16_wd = reg_wdata[31:0];
  assign key_17_we = addr_hit[26] & reg_we & !reg_error;

  assign key_17_wd = reg_wdata[31:0];
  assign key_18_we = addr_hit[27] & reg_we & !reg_error;

  assign key_18_wd = reg_wdata[31:0];
  assign key_19_we = addr_hit[28] & reg_we & !reg_error;

  assign key_19_wd = reg_wdata[31:0];
  assign key_20_we = addr_hit[29] & reg_we & !reg_error;

  assign key_20_wd = reg_wdata[31:0];
  assign key_21_we = addr_hit[30] & reg_we & !reg_error;

  assign key_21_wd = reg_wdata[31:0];
  assign key_22_we = addr_hit[31] & reg_we & !reg_error;

  assign key_22_wd = reg_wdata[31:0];
  assign key_23_we = addr_hit[32] & reg_we & !reg_error;

  assign key_23_wd = reg_wdata[31:0];
  assign key_24_we = addr_hit[33] & reg_we & !reg_error;

  assign key_24_wd = reg_wdata[31:0];
  assign key_25_we = addr_hit[34] & reg_we & !reg_error;

  assign key_25_wd = reg_wdata[31:0];
  assign key_26_we = addr_hit[35] & reg_we & !reg_error;

  assign key_26_wd = reg_wdata[31:0];
  assign key_27_we = addr_hit[36] & reg_we & !reg_error;

  assign key_27_wd = reg_wdata[31:0];
  assign key_28_we = addr_hit[37] & reg_we & !reg_error;

  assign key_28_wd = reg_wdata[31:0];
  assign key_29_we = addr_hit[38] & reg_we & !reg_error;

  assign key_29_wd = reg_wdata[31:0];
  assign key_30_we = addr_hit[39] & reg_we & !reg_error;

  assign key_30_wd = reg_wdata[31:0];
  assign key_31_we = addr_hit[40] & reg_we & !reg_error;

  assign key_31_wd = reg_wdata[31:0];
  assign digest_0_re = addr_hit[41] & reg_re & !reg_error;
  assign digest_0_we = addr_hit[41] & reg_we & !reg_error;

  assign digest_0_wd = reg_wdata[31:0];
  assign digest_1_re = addr_hit[42] & reg_re & !reg_error;
  assign digest_1_we = addr_hit[42] & reg_we & !reg_error;

  assign digest_1_wd = reg_wdata[31:0];
  assign digest_2_re = addr_hit[43] & reg_re & !reg_error;
  assign digest_2_we = addr_hit[43] & reg_we & !reg_error;

  assign digest_2_wd = reg_wdata[31:0];
  assign digest_3_re = addr_hit[44] & reg_re & !reg_error;
  assign digest_3_we = addr_hit[44] & reg_we & !reg_error;

  assign digest_3_wd = reg_wdata[31:0];
  assign digest_4_re = addr_hit[45] & reg_re & !reg_error;
  assign digest_4_we = addr_hit[45] & reg_we & !reg_error;

  assign digest_4_wd = reg_wdata[31:0];
  assign digest_5_re = addr_hit[46] & reg_re & !reg_error;
  assign digest_5_we = addr_hit[46] & reg_we & !reg_error;

  assign digest_5_wd = reg_wdata[31:0];
  assign digest_6_re = addr_hit[47] & reg_re & !reg_error;
  assign digest_6_we = addr_hit[47] & reg_we & !reg_error;

  assign digest_6_wd = reg_wdata[31:0];
  assign digest_7_re = addr_hit[48] & reg_re & !reg_error;
  assign digest_7_we = addr_hit[48] & reg_we & !reg_error;

  assign digest_7_wd = reg_wdata[31:0];
  assign digest_8_re = addr_hit[49] & reg_re & !reg_error;
  assign digest_8_we = addr_hit[49] & reg_we & !reg_error;

  assign digest_8_wd = reg_wdata[31:0];
  assign digest_9_re = addr_hit[50] & reg_re & !reg_error;
  assign digest_9_we = addr_hit[50] & reg_we & !reg_error;

  assign digest_9_wd = reg_wdata[31:0];
  assign digest_10_re = addr_hit[51] & reg_re & !reg_error;
  assign digest_10_we = addr_hit[51] & reg_we & !reg_error;

  assign digest_10_wd = reg_wdata[31:0];
  assign digest_11_re = addr_hit[52] & reg_re & !reg_error;
  assign digest_11_we = addr_hit[52] & reg_we & !reg_error;

  assign digest_11_wd = reg_wdata[31:0];
  assign digest_12_re = addr_hit[53] & reg_re & !reg_error;
  assign digest_12_we = addr_hit[53] & reg_we & !reg_error;

  assign digest_12_wd = reg_wdata[31:0];
  assign digest_13_re = addr_hit[54] & reg_re & !reg_error;
  assign digest_13_we = addr_hit[54] & reg_we & !reg_error;

  assign digest_13_wd = reg_wdata[31:0];
  assign digest_14_re = addr_hit[55] & reg_re & !reg_error;
  assign digest_14_we = addr_hit[55] & reg_we & !reg_error;

  assign digest_14_wd = reg_wdata[31:0];
  assign digest_15_re = addr_hit[56] & reg_re & !reg_error;
  assign digest_15_we = addr_hit[56] & reg_we & !reg_error;

  assign digest_15_wd = reg_wdata[31:0];
  assign msg_length_lower_re = addr_hit[57] & reg_re & !reg_error;
  assign msg_length_lower_we = addr_hit[57] & reg_we & !reg_error;

  assign msg_length_lower_wd = reg_wdata[31:0];
  assign msg_length_upper_re = addr_hit[58] & reg_re & !reg_error;
  assign msg_length_upper_we = addr_hit[58] & reg_we & !reg_error;

  assign msg_length_upper_wd = reg_wdata[31:0];

  // Assign write-enables to checker logic vector.
  always_comb begin
    reg_we_check = '0;
    reg_we_check[0] = intr_state_we;
    reg_we_check[1] = intr_enable_we;
    reg_we_check[2] = intr_test_we;
    reg_we_check[3] = alert_test_we;
    reg_we_check[4] = cfg_we;
    reg_we_check[5] = cmd_we;
    reg_we_check[6] = 1'b0;
    reg_we_check[7] = 1'b0;
    reg_we_check[8] = wipe_secret_we;
    reg_we_check[9] = key_0_we;
    reg_we_check[10] = key_1_we;
    reg_we_check[11] = key_2_we;
    reg_we_check[12] = key_3_we;
    reg_we_check[13] = key_4_we;
    reg_we_check[14] = key_5_we;
    reg_we_check[15] = key_6_we;
    reg_we_check[16] = key_7_we;
    reg_we_check[17] = key_8_we;
    reg_we_check[18] = key_9_we;
    reg_we_check[19] = key_10_we;
    reg_we_check[20] = key_11_we;
    reg_we_check[21] = key_12_we;
    reg_we_check[22] = key_13_we;
    reg_we_check[23] = key_14_we;
    reg_we_check[24] = key_15_we;
    reg_we_check[25] = key_16_we;
    reg_we_check[26] = key_17_we;
    reg_we_check[27] = key_18_we;
    reg_we_check[28] = key_19_we;
    reg_we_check[29] = key_20_we;
    reg_we_check[30] = key_21_we;
    reg_we_check[31] = key_22_we;
    reg_we_check[32] = key_23_we;
    reg_we_check[33] = key_24_we;
    reg_we_check[34] = key_25_we;
    reg_we_check[35] = key_26_we;
    reg_we_check[36] = key_27_we;
    reg_we_check[37] = key_28_we;
    reg_we_check[38] = key_29_we;
    reg_we_check[39] = key_30_we;
    reg_we_check[40] = key_31_we;
    reg_we_check[41] = digest_0_we;
    reg_we_check[42] = digest_1_we;
    reg_we_check[43] = digest_2_we;
    reg_we_check[44] = digest_3_we;
    reg_we_check[45] = digest_4_we;
    reg_we_check[46] = digest_5_we;
    reg_we_check[47] = digest_6_we;
    reg_we_check[48] = digest_7_we;
    reg_we_check[49] = digest_8_we;
    reg_we_check[50] = digest_9_we;
    reg_we_check[51] = digest_10_we;
    reg_we_check[52] = digest_11_we;
    reg_we_check[53] = digest_12_we;
    reg_we_check[54] = digest_13_we;
    reg_we_check[55] = digest_14_we;
    reg_we_check[56] = digest_15_we;
    reg_we_check[57] = msg_length_lower_we;
    reg_we_check[58] = msg_length_upper_we;
  end

  // Read data return
  always_comb begin
    reg_rdata_next = '0;
    unique case (1'b1)
      addr_hit[0]: begin
        reg_rdata_next[0] = intr_state_hmac_done_qs;
        reg_rdata_next[1] = intr_state_fifo_empty_qs;
        reg_rdata_next[2] = intr_state_hmac_err_qs;
      end

      addr_hit[1]: begin
        reg_rdata_next[0] = intr_enable_hmac_done_qs;
        reg_rdata_next[1] = intr_enable_fifo_empty_qs;
        reg_rdata_next[2] = intr_enable_hmac_err_qs;
      end

      addr_hit[2]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
        reg_rdata_next[2] = '0;
      end

      addr_hit[3]: begin
        reg_rdata_next[0] = '0;
      end

      addr_hit[4]: begin
        reg_rdata_next[0] = cfg_hmac_en_qs;
        reg_rdata_next[1] = cfg_sha_en_qs;
        reg_rdata_next[2] = cfg_endian_swap_qs;
        reg_rdata_next[3] = cfg_digest_swap_qs;
        reg_rdata_next[4] = cfg_key_swap_qs;
        reg_rdata_next[8:5] = cfg_digest_size_qs;
        reg_rdata_next[14:9] = cfg_key_length_qs;
      end

      addr_hit[5]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
        reg_rdata_next[2] = '0;
        reg_rdata_next[3] = '0;
      end

      addr_hit[6]: begin
        reg_rdata_next[0] = status_hmac_idle_qs;
        reg_rdata_next[1] = status_fifo_empty_qs;
        reg_rdata_next[2] = status_fifo_full_qs;
        reg_rdata_next[9:4] = status_fifo_depth_qs;
      end

      addr_hit[7]: begin
        reg_rdata_next[31:0] = err_code_qs;
      end

      addr_hit[8]: begin
        reg_rdata_next[31:0] = reg2hw.key[0].q;
      end

      addr_hit[9]: begin
        reg_rdata_next[31:0] = reg2hw.key[1].q;
      end

      addr_hit[10]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[11]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[12]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[13]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[14]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[15]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[16]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[17]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[18]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[19]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[20]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[21]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[22]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[23]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[24]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[25]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[26]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[27]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[28]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[29]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[30]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[31]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[32]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[33]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[34]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[35]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[36]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[37]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[38]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[39]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[40]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[41]: begin
        reg_rdata_next[31:0] = digest_0_qs;
      end

      addr_hit[42]: begin
        reg_rdata_next[31:0] = digest_1_qs;
      end

      addr_hit[43]: begin
        reg_rdata_next[31:0] = digest_2_qs;
      end

      addr_hit[44]: begin
        reg_rdata_next[31:0] = digest_3_qs;
      end

      addr_hit[45]: begin
        reg_rdata_next[31:0] = digest_4_qs;
      end

      addr_hit[46]: begin
        reg_rdata_next[31:0] = digest_5_qs;
      end

      addr_hit[47]: begin
        reg_rdata_next[31:0] = digest_6_qs;
      end

      addr_hit[48]: begin
        reg_rdata_next[31:0] = digest_7_qs;
      end

      addr_hit[49]: begin
        reg_rdata_next[31:0] = digest_8_qs;
      end

      addr_hit[50]: begin
        reg_rdata_next[31:0] = digest_9_qs;
      end

      addr_hit[51]: begin
        reg_rdata_next[31:0] = digest_10_qs;
      end

      addr_hit[52]: begin
        reg_rdata_next[31:0] = digest_11_qs;
      end

      addr_hit[53]: begin
        reg_rdata_next[31:0] = digest_12_qs;
      end

      addr_hit[54]: begin
        reg_rdata_next[31:0] = digest_13_qs;
      end

      addr_hit[55]: begin
        reg_rdata_next[31:0] = digest_14_qs;
      end

      addr_hit[56]: begin
        reg_rdata_next[31:0] = digest_15_qs;
      end

      addr_hit[57]: begin
        reg_rdata_next[31:0] = msg_length_lower_qs;
      end

      addr_hit[58]: begin
        reg_rdata_next[31:0] = msg_length_upper_qs;
      end

      default: begin
        reg_rdata_next = reg2hw.key[2].q;
      end
    endcase
  end

  // shadow busy
  logic shadow_busy;
  assign shadow_busy = 1'b0;

  // register busy
  assign reg_busy = shadow_busy;

  // Unused signal tieoff

  // wdata / byte enable are not always fully used
  // add a blanket unused statement to handle lint waivers
  logic unused_wdata;
  logic unused_be;
  assign unused_wdata = ^reg_wdata;
  assign unused_be = ^reg_be;

  // Assertions for Register Interface
  `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
  `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)

  `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)

  `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)

  // this is formulated as an assumption such that the FPV testbenches do disprove this
  // property by mistake
  //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)

endmodule

    '''

    Form relevant system verilog assertions for the RTL to be checked for.
    These system verilog assertions should be in a dict with the key as the name and the value as the assertion string.
    An example assertions object to be sent to assertion checker tool is as follows:

    assertions = {"assertion_p1":"property p1;\n    @(posedge clk) signal_A |-> signal_B;\nendproperty
assertion_p1: assert property (p1);", "assertion_p2":"property p2;\n    @(posedge clk) conditions |-> signal_C;\nendproperty\nassertion_p2: assert property (p2);"}

    Then run the assertions using the assertion checker tool. This tool call must include the assertions dictionary as an argument.
    From the output of the assertion checker tool, determine if there are security issues in the RTL.
    If there are no falsified assertions in the output from the assertion checker tool, that means there are no verified security issues in the RTL.

    
================================== Ai Message ==================================

[{'text': "I'll analyze the provided RTL code for security concerns related to register access control and privilege enforcement, then create appropriate assertions to check for these issues.\n\nLooking at the code, this is a register top module for an HMAC (Hash-based Message Authentication Code) peripheral. The module handles register access through a TileLink interface, which is a bus protocol. Let me identify potential security concerns:\n\n1. There appears to be no explicit privilege level checking in the register access logic\n2. Some registers might need protection from unauthorized access\n3. The key registers should have proper access controls\n4. There might be issues with register write enables\n\nLet me create assertions to check for these security concerns:", 'type': 'text'}, {'id': 'toolu_01B9GWNsupYWZkVX1P7YfTKh', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv', 'top_module': 'hmac_reg_top', 'assertions': {'assert_key_write_protection': 'property key_write_protection;\n  @(posedge clk_i) reg_we && (|addr_hit[9:40]) |-> !intg_err && !reg_error;\nendproperty\nassert_key_write_protection: assert property(key_write_protection) else $error("Key registers can be written when integrity error or register error is active");', 'assert_digest_read_protection': 'property digest_read_protection;\n  @(posedge clk_i) reg_re && (|addr_hit[41:56]) |-> !intg_err && !reg_error;\nendproperty\nassert_digest_read_protection: assert property(digest_read_protection) else $error("Digest registers can be read when integrity error or register error is active");', 'assert_wipe_secret_protection': 'property wipe_secret_protection;\n  @(posedge clk_i) wipe_secret_we |-> reg_error;\nendproperty\nassert_wipe_secret_protection: assert property(wipe_secret_protection) else $error("Wipe secret can be written without register error");', 'assert_integrity_error_handling': 'property integrity_error_handling;\n  @(posedge clk_i) intg_err |-> ##1 reg_steer == 1\'d1;\nendproperty\nassert_integrity_error_handling: assert property(integrity_error_handling) else $error("Integrity error does not properly steer to register interface");', 'assert_no_key_read': 'property no_key_read;\n  @(posedge clk_i) reg_re && (|addr_hit[10:40]) |-> reg_rdata_next == \'0;\nendproperty\nassert_no_key_read: assert property(no_key_read) else $error("Key registers 1-31 should return zeros when read");'}, 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01B9GWNsupYWZkVX1P7YfTKh)
 Call ID: toolu_01B9GWNsupYWZkVX1P7YfTKh
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv
    top_module: hmac_reg_top
    assertions: {'assert_key_write_protection': 'property key_write_protection;\n  @(posedge clk_i) reg_we && (|addr_hit[9:40]) |-> !intg_err && !reg_error;\nendproperty\nassert_key_write_protection: assert property(key_write_protection) else $error("Key registers can be written when integrity error or register error is active");', 'assert_digest_read_protection': 'property digest_read_protection;\n  @(posedge clk_i) reg_re && (|addr_hit[41:56]) |-> !intg_err && !reg_error;\nendproperty\nassert_digest_read_protection: assert property(digest_read_protection) else $error("Digest registers can be read when integrity error or register error is active");', 'assert_wipe_secret_protection': 'property wipe_secret_protection;\n  @(posedge clk_i) wipe_secret_we |-> reg_error;\nendproperty\nassert_wipe_secret_protection: assert property(wipe_secret_protection) else $error("Wipe secret can be written without register error");', 'assert_integrity_error_handling': 'property integrity_error_handling;\n  @(posedge clk_i) intg_err |-> ##1 reg_steer == 1\'d1;\nendproperty\nassert_integrity_error_handling: assert property(integrity_error_handling) else $error("Integrity error does not properly steer to register interface");', 'assert_no_key_read': 'property no_key_read;\n  @(posedge clk_i) reg_re && (|addr_hit[10:40]) |-> reg_rdata_next == \'0;\nendproperty\nassert_no_key_read: assert property(no_key_read) else $error("Key registers 1-31 should return zeros when read");'}
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: assertion_checker_tool

Failed to execute. Error: FileNotFoundError(2, 'No such file or directory')
FileNotFoundError: [Errno 2] No such file or directory: 'results_vcf_hmac_reg_top.txt'
Traceback (most recent call last):
  File "/home/XXXX-2/security_agents/security_agents.py", line 747, in assertion_checker_tool
    results_content = open(results_file,'r').read()
                      ^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: 'results_vcf_hmac_reg_top.txt'
================================== Ai Message ==================================

[{'text': 'I apologize for the error. Let me try again with a more focused set of assertions that are more likely to be verifiable with the available tools:', 'type': 'text'}, {'id': 'toolu_01T31NM8e328J5ExmmTr39c6', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv', 'top_module': 'hmac_reg_top', 'assertions': {'assert_wipe_secret_protection': 'property wipe_secret_protection;\n  @(posedge clk_i) wipe_secret_we |-> reg_error;\nendproperty\nassert_wipe_secret_protection: assert property(wipe_secret_protection);', 'assert_integrity_error_handling': "property integrity_error_handling;\n  @(posedge clk_i) intg_err |-> ##1 reg_steer == 1'd1;\nendproperty\nassert_integrity_error_handling: assert property(integrity_error_handling);", 'assert_key_write_protection': 'property key_write_protection;\n  @(posedge clk_i) key_0_we |-> !reg_error && !intg_err;\nendproperty\nassert_key_write_protection: assert property(key_write_protection);'}, 'clock_signal': 'clk_i', 'reset_signal': 'rst_ni', 'reset_active': 'low'}, 'name': 'assertion_checker_tool', 'type': 'tool_use'}]
Tool Calls:
  assertion_checker_tool (toolu_01T31NM8e328J5ExmmTr39c6)
 Call ID: toolu_01T31NM8e328J5ExmmTr39c6
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv
    top_module: hmac_reg_top
    assertions: {'assert_wipe_secret_protection': 'property wipe_secret_protection;\n  @(posedge clk_i) wipe_secret_we |-> reg_error;\nendproperty\nassert_wipe_secret_protection: assert property(wipe_secret_protection);', 'assert_integrity_error_handling': "property integrity_error_handling;\n  @(posedge clk_i) intg_err |-> ##1 reg_steer == 1'd1;\nendproperty\nassert_integrity_error_handling: assert property(integrity_error_handling);", 'assert_key_write_protection': 'property key_write_protection;\n  @(posedge clk_i) key_0_we |-> !reg_error && !intg_err;\nendproperty\nassert_key_write_protection: assert property(key_write_protection);'}
    clock_signal: clk_i
    reset_signal: rst_ni
    reset_active: low
================================= Tool Message =================================
Name: assertion_checker_tool

Successfully executed:
```assertion checker tool
```
Output:
 The following properties were falsified:
property integrity_error_handling;
  @(posedge clk_i) intg_err |-> ##1 reg_steer == 1'd1;
endproperty
assert_integrity_error_handling: assert property(integrity_error_handling);
================================== Ai Message ==================================

Based on the assertion checker results, I've identified a security concern in the HMAC register top module:

The `assert_integrity_error_handling` assertion was falsified, which indicates a potential security issue. This assertion checks whether an integrity error properly steers transactions to the register interface (setting `reg_steer` to 1'd1). The falsification suggests that when an integrity error occurs, the system might not always properly route transactions, which could lead to unauthorized access.

Looking at the code more closely, there's a section that handles integrity error steering:

```verilog
// Create steering logic
always_comb begin
  reg_steer =
      tl_i.a_address[AW-1:0] inside {[4096:8191]} ? 1'd0 :
      // Default set to register
      1'd1;

  // Override this in case of an integrity error
  if (intg_err) begin
    reg_steer = 1'd1;
  end
end
```

The assertion failure suggests that this override mechanism might not be working correctly in all cases. When an integrity error occurs, the code intends to force `reg_steer` to 1'd1, which should route transactions to the register interface rather than the window interface. However, the assertion failure indicates that this doesn't always happen as expected.

This is a security concern because:

1. If integrity errors don't properly redirect transactions, it could allow attackers to bypass security checks
2. Malformed transactions might still be processed by the window interface instead of being handled by the register interface
3. This could potentially lead to unauthorized access to sensitive registers or memory regions

The other assertions we tested (wipe_secret_protection and key_write_protection) passed, which suggests that:
1. The wipe_secret register is properly protected and can only be written when reg_error is active
2. Key registers are protected from writes when there are integrity or register errors

However, the integrity error handling issue is significant and should be addressed to ensure proper security of the HMAC module.
================================= Tool Message =================================
Name: run_assertions_checker_agent

Based on the assertion checker results, I've identified a security concern in the HMAC register top module:

The `assert_integrity_error_handling` assertion was falsified, which indicates a potential security issue. This assertion checks whether an integrity error properly steers transactions to the register interface (setting `reg_steer` to 1'd1). The falsification suggests that when an integrity error occurs, the system might not always properly route transactions, which could lead to unauthorized access.

Looking at the code more closely, there's a section that handles integrity error steering:

```verilog
// Create steering logic
always_comb begin
  reg_steer =
      tl_i.a_address[AW-1:0] inside {[4096:8191]} ? 1'd0 :
      // Default set to register
      1'd1;

  // Override this in case of an integrity error
  if (intg_err) begin
    reg_steer = 1'd1;
  end
end
```

The assertion failure suggests that this override mechanism might not be working correctly in all cases. When an integrity error occurs, the code intends to force `reg_steer` to 1'd1, which should route transactions to the register interface rather than the window interface. However, the assertion failure indicates that this doesn't always happen as expected.

This is a security concern because:

1. If integrity errors don't properly redirect transactions, it could allow attackers to bypass security checks
2. Malformed transactions might still be processed by the window interface instead of being handled by the register interface
3. This could potentially lead to unauthorized access to sensitive registers or memory regions

The other assertions we tested (wipe_secret_protection and key_write_protection) passed, which suggests that:
1. The wipe_secret register is properly protected and can only be written when reg_error is active
2. Key registers are protected from writes when there are integrity or register errors

However, the integrity error handling issue is significant and should be addressed to ensure proper security of the HMAC module.
================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_4OD6BAAuxkOBJjCnJ7Xwqvia)
 Call ID: call_4OD6BAAuxkOBJjCnJ7Xwqvia
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_core.sv
    top_module: hmac_core
    security_objective: context switching and state isolation
================================ Human Message =================================

Are there security concerns related to context switching and state isolation in the provided RTL:
    """

    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// HMAC Core implementation

module hmac_core import prim_sha2_pkg::*; (
  input clk_i,
  input rst_ni,

  input [1023:0]      secret_key_i, // {word0, word1, ..., word7}
  input               hmac_en_i,
  input digest_mode_e digest_size_i,
  input key_length_e  key_length_i,

  input        reg_hash_start_i,
  input        reg_hash_stop_i,
  input        reg_hash_continue_i,
  input        reg_hash_process_i,
  output logic hash_done_o,
  output logic sha_hash_start_o,
  output logic sha_hash_continue_o,
  output logic sha_hash_process_o,
  input        sha_hash_done_i,

  // fifo
  output logic        sha_rvalid_o,
  output sha_fifo32_t sha_rdata_o,
  input               sha_rready_i,

  input               fifo_rvalid_i,
  input  sha_fifo32_t fifo_rdata_i,
  output logic        fifo_rready_o,

  // fifo control (select and fifo write data)
  output logic       fifo_wsel_o,      // 0: from reg, 1: from digest
  output logic       fifo_wvalid_o,
  // 0: digest[0][upper], 1:digest[0][lower] .. 14: digest[7][upper], 15: digest[7][lower]
  output logic [3:0] fifo_wdata_sel_o,
  input              fifo_wready_i,

  input  [63:0] message_length_i,
  output [63:0] sha_message_length_o,

  output logic idle_o
);

  localparam int unsigned BlockSizeSHA256     = 512;
  localparam int unsigned BlockSizeSHA512     = 1024;

  localparam int unsigned BlockSizeBitsSHA256 = $clog2(BlockSizeSHA256);
  localparam int unsigned BlockSizeBitsSHA512 = $clog2(BlockSizeSHA512);

  localparam int unsigned HashWordBitsSHA256  = $clog2($bits(sha_word32_t));

  localparam bit [63:0] BlockSizeSHA256in64  = 64'(BlockSizeSHA256);
  localparam bit [63:0] BlockSizeSHA512in64  = 64'(BlockSizeSHA512);

  logic hash_start;    // generated from internal state machine
  logic hash_continue; // generated from internal state machine
  logic hash_process;  // generated from internal state machine to trigger hash
  logic hmac_hash_done;

  logic [BlockSizeSHA256-1:0] i_pad_256;
  logic [BlockSizeSHA512-1:0] i_pad_512;
  logic [BlockSizeSHA256-1:0] o_pad_256;
  logic [BlockSizeSHA512-1:0] o_pad_512;

  logic [63:0] txcount, txcount_d; // works for both digest lengths

  logic [BlockSizeBitsSHA512-HashWordBitsSHA256-1:0] pad_index_512;
  logic [BlockSizeBitsSHA256-HashWordBitsSHA256-1:0] pad_index_256;
  logic clr_txcount, load_txcount, inc_txcount;

  logic hmac_sha_rvalid;

  logic idle_d, idle_q;
  logic reg_hash_stop_d, reg_hash_stop_q;

  typedef enum logic [1:0] {
    SelIPad,
    SelOPad,
    SelFifo
  } sel_rdata_t;

  sel_rdata_t sel_rdata;

  typedef enum logic {
    SelIPadMsg,
    SelOPadMsg
  } sel_msglen_t;

  sel_msglen_t sel_msglen;

  typedef enum logic {
    Inner,  // Update when state goes to StIPad
    Outer   // Update when state enters StOPad
  } round_t ;

  logic update_round ;
  round_t round_q, round_d;

  typedef enum logic [2:0] {
    StIdle,
    StIPad,
    StMsg,              // Actual Msg, and Digest both
    StPushToMsgFifo,    // Digest --> Msg Fifo
    StWaitResp,         // Hash done( by checking processed_length? or hash_done)
    StOPad,
    StDone              // hmac_done
  } st_e ;

  st_e st_q, st_d;

  logic clr_fifo_wdata_sel;
  logic txcnt_eq_blksz;

  logic reg_hash_process_flag;

  assign sha_hash_start_o    = (hmac_en_i) ? hash_start    : reg_hash_start_i;
  assign sha_hash_continue_o = (hmac_en_i) ? hash_continue : reg_hash_continue_i;

  assign sha_hash_process_o  = (hmac_en_i) ? reg_hash_process_i | hash_process : reg_hash_process_i;
  assign hash_done_o         = (hmac_en_i) ? hmac_hash_done                    : sha_hash_done_i;

  assign pad_index_512 = txcount[BlockSizeBitsSHA512-1:HashWordBitsSHA256];
  assign pad_index_256 = txcount[BlockSizeBitsSHA256-1:HashWordBitsSHA256];

  // adjust inner and outer padding depending on key length and block size
  always_comb begin : adjust_key_pad_length
    // set defaults
    i_pad_256 = '{default: '0};
    i_pad_512 = '{default: '0};
    o_pad_256 = '{default: '0};
    o_pad_512 = '{default: '0};

    unique case (key_length_i)
      Key_128: begin
        i_pad_256 = {secret_key_i[1023:896],
                    {(BlockSizeSHA256-128){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
        i_pad_512 = {secret_key_i[1023:896],
                    {(BlockSizeSHA512-128){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
        o_pad_256 = {secret_key_i[1023:896],
                    {(BlockSizeSHA256-128){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
        o_pad_512 = {secret_key_i[1023:896],
                    {(BlockSizeSHA512-128){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      Key_256: begin
        i_pad_256 = {secret_key_i[1023:768],
                    {(BlockSizeSHA256-256){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
        i_pad_512 = {secret_key_i[1023:768],
                    {(BlockSizeSHA512-256){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
        o_pad_256 = {secret_key_i[1023:768],
                    {(BlockSizeSHA256-256){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
        o_pad_512 = {secret_key_i[1023:768],
                    {(BlockSizeSHA512-256){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      Key_384: begin
        i_pad_256 = {secret_key_i[1023:640],
                    {(BlockSizeSHA256-384){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
        i_pad_512 = {secret_key_i[1023:640],
                    {(BlockSizeSHA512-384){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
        o_pad_256 = {secret_key_i[1023:640],
                    {(BlockSizeSHA256-384){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
        o_pad_512 = {secret_key_i[1023:640],
                    {(BlockSizeSHA512-384){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      Key_512: begin
        i_pad_256 = secret_key_i[1023:512] ^ {(BlockSizeSHA256/8){8'h36}};
        i_pad_512 = {secret_key_i[1023:512],
                    {(BlockSizeSHA512-512){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
        o_pad_256 = secret_key_i[1023:512] ^ {(BlockSizeSHA256/8){8'h5c}};
        o_pad_512 = {secret_key_i[1023:512],
                    {(BlockSizeSHA512-512){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      Key_1024: begin // not allowed to be configured for SHA-2 256
        // zero out for SHA-2 256
        i_pad_256 = '{default: '0};
        i_pad_512 = secret_key_i[1023:0]   ^ {(BlockSizeSHA512/8){8'h36}};
        // zero out for SHA-2 256
        o_pad_256 = '{default: '0};
        o_pad_512 = secret_key_i[1023:0]   ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      default: begin
      end
    endcase
  end

  assign fifo_rready_o = (hmac_en_i) ? (st_q == StMsg) & sha_rready_i : sha_rready_i ;
  // sha_rvalid is controlled by State Machine below.
  assign sha_rvalid_o  = (!hmac_en_i) ? fifo_rvalid_i : hmac_sha_rvalid ;
  assign sha_rdata_o =
    (!hmac_en_i)    ? fifo_rdata_i                                                             :
    (sel_rdata == SelIPad && digest_size_i == SHA2_256)
                  ? '{data: i_pad_256[(BlockSizeSHA256-1)-32*pad_index_256-:32], mask: '1} :
    (sel_rdata == SelIPad && ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)))
                  ? '{data: i_pad_512[(BlockSizeSHA512-1)-32*pad_index_512-:32], mask: '1} :
    (sel_rdata == SelOPad && digest_size_i == SHA2_256)
                  ? '{data: o_pad_256[(BlockSizeSHA256-1)-32*pad_index_256-:32], mask: '1} :
    (sel_rdata == SelOPad && ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)))
                  ? '{data: o_pad_512[(BlockSizeSHA512-1)-32*pad_index_512-:32], mask: '1} :
    (sel_rdata == SelFifo) ? fifo_rdata_i                                                    :
                  '{default: '0};

  logic [63:0] sha_msg_len;

  always_comb begin: assign_sha_message_length
    sha_msg_len = '0;
    if (!hmac_en_i) begin
      sha_msg_len = message_length_i;
    // HASH = (o_pad || HASH_INTERMEDIATE (i_pad || msg))
    // message length for HASH_INTERMEDIATE = block size (i_pad) + message length
    end else if (sel_msglen == SelIPadMsg) begin
      if (digest_size_i == SHA2_256) begin
        sha_msg_len = message_length_i + BlockSizeSHA256in64;
      end else if ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)) begin
        sha_msg_len = message_length_i + BlockSizeSHA512in64;
      end
    end else if (sel_msglen == SelOPadMsg) begin
    // message length for HASH = block size (o_pad) + HASH_INTERMEDIATE digest length
      if (digest_size_i == SHA2_256) begin
        sha_msg_len = BlockSizeSHA256in64 + 64'd256;
      end else if (digest_size_i == SHA2_384) begin
        sha_msg_len = BlockSizeSHA512in64 + 64'd384;
      end else if (digest_size_i == SHA2_512) begin
        sha_msg_len = BlockSizeSHA512in64 + 64'd512;
      end
    end else
      sha_msg_len = '0;
  end

  assign sha_message_length_o = sha_msg_len;

  always_comb begin
    txcnt_eq_blksz = '0;

    unique case (digest_size_i)
      SHA2_256: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA256-1:0] == '0) && (txcount != '0);
      SHA2_384: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA512-1:0] == '0) && (txcount != '0);
      SHA2_512: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA512-1:0] == '0) && (txcount != '0);
      default;
    endcase
  end

  assign inc_txcount = sha_rready_i && sha_rvalid_o;

  // txcount
  //    Looks like txcount can be removed entirely here in hmac_core
  //    In the first round (InnerPaddedKey), it can just watch process and hash_done
  //    In the second round, it only needs count 256 bits for hash digest to trigger
  //    hash_process to SHA2
  always_comb begin
    txcount_d = txcount;
    if (clr_txcount) begin
      txcount_d = '0;
    end else if (load_txcount) begin
      // When loading, add block size to the message length because the SW-visible message length
      // does not include the block containing the key xor'ed with the inner pad.
      unique case (digest_size_i)
        SHA2_256: txcount_d = message_length_i + BlockSizeSHA256in64;
        SHA2_384: txcount_d = message_length_i + BlockSizeSHA512in64;
        SHA2_512: txcount_d = message_length_i + BlockSizeSHA512in64;
        default : txcount_d = message_length_i + '0;
      endcase
    end else if (inc_txcount) begin
      txcount_d[63:5] = txcount[63:5] + 1'b1; // increment by 32 (data word size)
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) txcount <= '0;
    else         txcount <= txcount_d;
  end

  // reg_hash_process_i trigger logic
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      reg_hash_process_flag <= 1'b0;
    end else if (reg_hash_process_i) begin
      reg_hash_process_flag <= 1'b1;
    end else if (hmac_hash_done || reg_hash_start_i || reg_hash_continue_i) begin
      reg_hash_process_flag <= 1'b0;
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      round_q <= Inner;
    end else if (update_round) begin
      round_q <= round_d;
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      fifo_wdata_sel_o <= 3'h 0;
    end else if (clr_fifo_wdata_sel) begin
      fifo_wdata_sel_o <= 3'h 0;
    end else if (fifo_wsel_o && fifo_wvalid_o) begin
      fifo_wdata_sel_o <= fifo_wdata_sel_o + 1'b1; // increment by 1
    end
  end

  assign sel_msglen = (round_q == Inner) ? SelIPadMsg : SelOPadMsg ;

  always_ff @(posedge clk_i or negedge rst_ni) begin : state_ff
    if (!rst_ni) st_q <= StIdle;
    else         st_q <= st_d;
  end

  always_comb begin : next_state
    hmac_hash_done     = 1'b0;
    hmac_sha_rvalid    = 1'b0;
    clr_txcount        = 1'b0;
    load_txcount       = 1'b0;
    update_round       = 1'b0;
    round_d            = Inner;
    fifo_wsel_o        = 1'b0;   // from register
    fifo_wvalid_o      = 1'b0;
    clr_fifo_wdata_sel = 1'b1;
    sel_rdata          = SelFifo;
    hash_start         = 1'b0;
    hash_continue      = 1'b0;
    hash_process       = 1'b0;
    st_d               = st_q;

    unique case (st_q)
      StIdle: begin
        // reset round to Inner
        // we always switch context into inner round since outer round computes once over
        // single block at the end (outer key pad + inner hash)
        update_round = 1'b1;
        round_d      = Inner;
        if (hmac_en_i && reg_hash_start_i) begin
          st_d = StIPad; // start at StIPad if told to start

          clr_txcount  = 1'b1;
          hash_start   = 1'b1;
        end else if (hmac_en_i && reg_hash_continue_i) begin
          st_d = StMsg; // skip StIPad if told to continue - assumed it finished StIPad

          load_txcount  = 1'b1;
          hash_continue = 1'b1;
        end else begin
          st_d = StIdle;
        end
      end

      StIPad: begin
        sel_rdata = SelIPad;

        if (txcnt_eq_blksz) begin
          st_d = StMsg;

          hmac_sha_rvalid = 1'b0; // block new read request
        end else begin
          st_d = StIPad;

          hmac_sha_rvalid = 1'b1;
        end
      end

      StMsg: begin
        sel_rdata   = SelFifo;
        fifo_wsel_o = (round_q == Outer);

        if ( (((round_q == Inner) && reg_hash_process_flag) || (round_q == Outer))
            && (txcount >= sha_message_length_o)) begin
          st_d    = StWaitResp;

          hmac_sha_rvalid = 1'b0; // block reading words from MSG FIFO
          hash_process    = (round_q == Outer);
        end else if (txcnt_eq_blksz && (txcount >= sha_message_length_o)
                     && reg_hash_stop_q && (round_q == Inner)) begin
          // wait till all MSG words are pushed out from FIFO (txcount reaches msg length)
          // before transitioning to StWaitResp to wait on sha_hash_done_i and disabling
          // reading from MSG FIFO
          st_d =  StWaitResp;

          hmac_sha_rvalid = 1'b0;
        end else begin
          st_d            = StMsg;
          hmac_sha_rvalid = fifo_rvalid_i;
        end
      end

      StWaitResp: begin
        hmac_sha_rvalid = 1'b0;

        if (sha_hash_done_i) begin
          if (round_q == Outer) begin
            st_d = StDone;
          end else begin // round_q == Inner
            if (reg_hash_stop_q) begin
              st_d = StDone;
            end else begin
              st_d = StPushToMsgFifo;
            end
          end
        end else begin
          st_d = StWaitResp;
        end
      end

      StPushToMsgFifo: begin
        hmac_sha_rvalid    = 1'b0;
        fifo_wsel_o        = 1'b1;
        fifo_wvalid_o      = 1'b1;
        clr_fifo_wdata_sel = 1'b0;

        if (fifo_wready_i && (((fifo_wdata_sel_o == 4'd7) && (digest_size_i == SHA2_256)) ||
                             ((fifo_wdata_sel_o == 4'd15) && (digest_size_i == SHA2_512)) ||
                             ((fifo_wdata_sel_o == 4'd11) && (digest_size_i == SHA2_384)))) begin

          st_d = StOPad;

          clr_txcount  = 1'b1;
          update_round = 1'b1;
          round_d      = Outer;
          hash_start   = 1'b1;
        end else begin
          st_d = StPushToMsgFifo;

        end
      end

      StOPad: begin
        sel_rdata   = SelOPad;
        fifo_wsel_o = 1'b1; // Remained HMAC select to indicate HMAC is in second stage

        if (txcnt_eq_blksz) begin
          st_d = StMsg;

          hmac_sha_rvalid = 1'b0; // block new read request
        end else begin
          st_d = StOPad;

          hmac_sha_rvalid = 1'b1;
        end
      end

      StDone: begin
        // raise interrupt (hash_done)
        st_d = StIdle;

        hmac_hash_done = 1'b1;
      end

      default: begin
        st_d = StIdle;
      end

    endcase
  end

  // raise reg_hash_stop_d flag at reg_hash_stop_i and keep it until sha_hash_done_i is asserted
  // to indicate the hashing operation on current block has completed
  assign reg_hash_stop_d = (reg_hash_stop_i == 1'b1)                            ? 1'b1 :
                           (sha_hash_done_i == 1'b1 && reg_hash_stop_q == 1'b1) ? 1'b0 :
                                                                                  reg_hash_stop_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      reg_hash_stop_q <= 1'b0;
    end else begin
      reg_hash_stop_q <= reg_hash_stop_d;
    end
  end

  // Idle status signaling: This module ..
  assign idle_d =
      // .. is not idle when told to start or continue
      (reg_hash_start_i || reg_hash_continue_i) ? 1'b0 :
      // .. is idle when the FSM is in the Idle state
      (st_q == StIdle) ? 1'b1 :
      // .. is idle when it has processed a complete block of a message and is told to stop in any
      // FSM state
      (txcnt_eq_blksz && reg_hash_stop_d) ? 1'b1 :
      // .. and keeps the current idle state in all other cases.
      idle_q;

  assign idle_o = idle_d;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      idle_q <= 1'b1;
    end else begin
      idle_q <= idle_d;
    end
  end
endmodule


    """


    Identify the CWE relevant to the security issue for the given RTL.
    Obtain details of the CWE.

    Then determine if there are security issues relevant to the identified CWE in the RTL.
    Refer to the code that corresponds to the issues identified.
    
================================== Ai Message ==================================

[{'text': "I'll analyze the RTL code for security concerns related to context switching and state isolation. Let me first identify relevant CWEs for this type of security issue.", 'type': 'text'}, {'id': 'toolu_014kdd58CDhkJscqAvARkcut', 'input': {'security_issue': 'context switching state isolation hardware'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_014kdd58CDhkJscqAvARkcut)
 Call ID: toolu_014kdd58CDhkJscqAvARkcut
  Args:
    security_issue: context switching state isolation hardware
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1423: Exposure of Sensitive Information caused by Shared Microarchitectural Predictor State that Influences Transient Execution
Shared microarchitectural predictor state may allow code to influence transient execution across a hardware boundary, potentially exposing data that is accessible beyond the boundary over a covert channel.
Many commodity processors have Instruction Set Architecture (ISA) features that protect software components from one another. These features can include memory segmentation, virtual memory, privilege rings, trusted execution environments, and virtual machines, among others. For example, virtual memory provides each process with its own address space, which prevents processes from accessing each other's private data. Many of these features can be used to form hardware-enforced security boundaries between software components.
Example 1
Branch Target Injection (BTI) is a vulnerability that can allow an SMT hardware thread to maliciously train the indirect branch predictor state that is shared with its sibling hardware thread. A cross-thread BTI attack requires the attacker to find a vulnerable code sequence within the victim software. For example, the authors of identified the following code sequence in the Windows library ntdll.dll:
(bad code)
Example Language: x86 Assembly
adc edi,dword ptr [ebx+edx+13BE13BDh] adc dl,byte ptr [edi] ... indirect_branch_site: jmp dword ptr [rsi] # at this point attacker knows edx, controls edi and ebx
To successfully exploit this code sequence to disclose the victim's private data, the attacker must also be able to find an indirect branch site within the victim, where the attacker controls the values in edi and ebx, and the attacker knows the value in edx as shown above at the indirect branch site. A proof-of-concept cross-thread BTI attack might proceed as follows: The attacker thread and victim thread must be co-scheduled on the same physical processor core. The attacker thread must train the shared branch predictor so that when the victim thread reaches indirect_branch_site, the jmp instruction will be predicted to target example_code_sequence instead of the correct architectural target. The training procedure may vary by processor, and the attacker may need to reverse-engineer the branch predictor to identify a suitable training algorithm. This step assumes that the attacker can control some values in the victim program, specifically the values in edi and ebx at indirect_branch_site. When the victim reaches indirect_branch_site the processor will (mis)predict example_code_sequence as the target and (transiently) execute the adc instructions. If the attacker chooses ebx so that `ebx = m 0x13BE13BD - edx, then the first adc will load 32 bits from address m in the victim's address space and add *m (the data loaded from) to the attacker-controlled base address in edi. The second adc instruction accesses a location in memory whose address corresponds to *m`. The adversary uses a covert channel analysis technique such as Flush+Reload ([REF-1416]) to infer the value of the victim's private data *m.

Example 2
BTI can also allow software in one execution context to maliciously train branch predictor entries that can be used in another context. For example, on some processors user-mode software may be able to train predictor entries that can also be used after transitioning into kernel mode, such as after invoking a system call. This vulnerability does not necessarily require SMT and may instead be performed in synchronous steps, though it does require the attacker to find an exploitable code sequence in the victim's code, for example, in the kernel.


================================== Ai Message ==================================

[{'id': 'toolu_019sUyErs9ipKAVLX6PcHcok', 'input': {'security_issue': 'hardware state machine security isolation'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_019sUyErs9ipKAVLX6PcHcok)
 Call ID: toolu_019sUyErs9ipKAVLX6PcHcok
  Args:
    security_issue: hardware state machine security isolation
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1423: Exposure of Sensitive Information caused by Shared Microarchitectural Predictor State that Influences Transient Execution
Shared microarchitectural predictor state may allow code to influence transient execution across a hardware boundary, potentially exposing data that is accessible beyond the boundary over a covert channel.
Many commodity processors have Instruction Set Architecture (ISA) features that protect software components from one another. These features can include memory segmentation, virtual memory, privilege rings, trusted execution environments, and virtual machines, among others. For example, virtual memory provides each process with its own address space, which prevents processes from accessing each other's private data. Many of these features can be used to form hardware-enforced security boundaries between software components.
Example 1
Branch Target Injection (BTI) is a vulnerability that can allow an SMT hardware thread to maliciously train the indirect branch predictor state that is shared with its sibling hardware thread. A cross-thread BTI attack requires the attacker to find a vulnerable code sequence within the victim software. For example, the authors of identified the following code sequence in the Windows library ntdll.dll:
(bad code)
Example Language: x86 Assembly
adc edi,dword ptr [ebx+edx+13BE13BDh] adc dl,byte ptr [edi] ... indirect_branch_site: jmp dword ptr [rsi] # at this point attacker knows edx, controls edi and ebx
To successfully exploit this code sequence to disclose the victim's private data, the attacker must also be able to find an indirect branch site within the victim, where the attacker controls the values in edi and ebx, and the attacker knows the value in edx as shown above at the indirect branch site. A proof-of-concept cross-thread BTI attack might proceed as follows: The attacker thread and victim thread must be co-scheduled on the same physical processor core. The attacker thread must train the shared branch predictor so that when the victim thread reaches indirect_branch_site, the jmp instruction will be predicted to target example_code_sequence instead of the correct architectural target. The training procedure may vary by processor, and the attacker may need to reverse-engineer the branch predictor to identify a suitable training algorithm. This step assumes that the attacker can control some values in the victim program, specifically the values in edi and ebx at indirect_branch_site. When the victim reaches indirect_branch_site the processor will (mis)predict example_code_sequence as the target and (transiently) execute the adc instructions. If the attacker chooses ebx so that `ebx = m 0x13BE13BD - edx, then the first adc will load 32 bits from address m in the victim's address space and add *m (the data loaded from) to the attacker-controlled base address in edi. The second adc instruction accesses a location in memory whose address corresponds to *m`. The adversary uses a covert channel analysis technique such as Flush+Reload ([REF-1416]) to infer the value of the victim's private data *m.

Example 2
BTI can also allow software in one execution context to maliciously train branch predictor entries that can be used in another context. For example, on some processors user-mode software may be able to train predictor entries that can also be used after transitioning into kernel mode, such as after invoking a system call. This vulnerability does not necessarily require SMT and may instead be performed in synchronous steps, though it does require the attacker to find an exploitable code sequence in the victim's code, for example, in the kernel.


================================== Ai Message ==================================

[{'id': 'toolu_013X4RaFA6RrdAypXfVF26rB', 'input': {'security_issue': 'hardware state machine transition security'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_013X4RaFA6RrdAypXfVF26rB)
 Call ID: toolu_013X4RaFA6RrdAypXfVF26rB
  Args:
    security_issue: hardware state machine transition security
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1272: Sensitive Information Uncleared Before Debug/Power State Transition
The product performs a power or debug state transition, but it does not clear sensitive information that should no longer be accessible due to changes to information access restrictions.
A device or system frequently employs many power and sleep states during its normal operation (e.g., normal power, additional power, low power, hibernate, deep sleep, etc.). A device also may be operating within a debug condition. State transitions can happen from one power or debug state to another. If there is information available in the previous state which should not be available in the next state and is not properly removed before the transition into the next state, sensitive information may leak from the system.
Example 1
This example shows how an attacker can take advantage of an incorrect state transition. Suppose a device is transitioning from state A to state B. During state A, it can read certain private keys from the hidden fuses that are only accessible in state A but not in state B. The device reads the keys, performs operations using those keys, then transitions to state B, where those private keys should no longer be accessible.
(bad code)
Example Language: Other
During the transition from A to B, the device does not scrub the memory. After the transition to state B, even though the private keys are no longer accessible directly from the fuses in state B, they can be accessed indirectly by reading the memory that contains the private keys.
(good code)
Example Language: Other
For transition from state A to state B, remove information which should not be available once the transition is complete.


================================== Ai Message ==================================

[{'id': 'toolu_01V2DxALpZm9sXNYMcnG8Nhc', 'input': {'security_issue': 'hardware state machine secure transitions'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01V2DxALpZm9sXNYMcnG8Nhc)
 Call ID: toolu_01V2DxALpZm9sXNYMcnG8Nhc
  Args:
    security_issue: hardware state machine secure transitions
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

[{"id": "toolu_01V2DxALpZm9sXNYMcnG8Nhc", "input": {"security_issue": "hardware state machine secure transitions"}, "name": "llm_cwe_details_retriever_tool", "type": "tool_use"}]
================================== Ai Message ==================================
Tool Calls:
  run_anomaly_detector_agent (call_Uvka3Z6xA8dCvCNKDaErNRTh)
 Call ID: call_Uvka3Z6xA8dCvCNKDaErNRTh
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_core.sv
    top_module: hmac_core
    security_objective: state machine and context switching anomalies
================================ Human Message =================================

Are there security concerns related to state machine and context switching anomalies in the provided RTL:
    The design filepath is:

    /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_core.sv

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// HMAC Core implementation

module hmac_core import prim_sha2_pkg::*; (
  input clk_i,
  input rst_ni,

  input [1023:0]      secret_key_i, // {word0, word1, ..., word7}
  input               hmac_en_i,
  input digest_mode_e digest_size_i,
  input key_length_e  key_length_i,

  input        reg_hash_start_i,
  input        reg_hash_stop_i,
  input        reg_hash_continue_i,
  input        reg_hash_process_i,
  output logic hash_done_o,
  output logic sha_hash_start_o,
  output logic sha_hash_continue_o,
  output logic sha_hash_process_o,
  input        sha_hash_done_i,

  // fifo
  output logic        sha_rvalid_o,
  output sha_fifo32_t sha_rdata_o,
  input               sha_rready_i,

  input               fifo_rvalid_i,
  input  sha_fifo32_t fifo_rdata_i,
  output logic        fifo_rready_o,

  // fifo control (select and fifo write data)
  output logic       fifo_wsel_o,      // 0: from reg, 1: from digest
  output logic       fifo_wvalid_o,
  // 0: digest[0][upper], 1:digest[0][lower] .. 14: digest[7][upper], 15: digest[7][lower]
  output logic [3:0] fifo_wdata_sel_o,
  input              fifo_wready_i,

  input  [63:0] message_length_i,
  output [63:0] sha_message_length_o,

  output logic idle_o
);

  localparam int unsigned BlockSizeSHA256     = 512;
  localparam int unsigned BlockSizeSHA512     = 1024;

  localparam int unsigned BlockSizeBitsSHA256 = $clog2(BlockSizeSHA256);
  localparam int unsigned BlockSizeBitsSHA512 = $clog2(BlockSizeSHA512);

  localparam int unsigned HashWordBitsSHA256  = $clog2($bits(sha_word32_t));

  localparam bit [63:0] BlockSizeSHA256in64  = 64'(BlockSizeSHA256);
  localparam bit [63:0] BlockSizeSHA512in64  = 64'(BlockSizeSHA512);

  logic hash_start;    // generated from internal state machine
  logic hash_continue; // generated from internal state machine
  logic hash_process;  // generated from internal state machine to trigger hash
  logic hmac_hash_done;

  logic [BlockSizeSHA256-1:0] i_pad_256;
  logic [BlockSizeSHA512-1:0] i_pad_512;
  logic [BlockSizeSHA256-1:0] o_pad_256;
  logic [BlockSizeSHA512-1:0] o_pad_512;

  logic [63:0] txcount, txcount_d; // works for both digest lengths

  logic [BlockSizeBitsSHA512-HashWordBitsSHA256-1:0] pad_index_512;
  logic [BlockSizeBitsSHA256-HashWordBitsSHA256-1:0] pad_index_256;
  logic clr_txcount, load_txcount, inc_txcount;

  logic hmac_sha_rvalid;

  logic idle_d, idle_q;
  logic reg_hash_stop_d, reg_hash_stop_q;

  typedef enum logic [1:0] {
    SelIPad,
    SelOPad,
    SelFifo
  } sel_rdata_t;

  sel_rdata_t sel_rdata;

  typedef enum logic {
    SelIPadMsg,
    SelOPadMsg
  } sel_msglen_t;

  sel_msglen_t sel_msglen;

  typedef enum logic {
    Inner,  // Update when state goes to StIPad
    Outer   // Update when state enters StOPad
  } round_t ;

  logic update_round ;
  round_t round_q, round_d;

  typedef enum logic [2:0] {
    StIdle,
    StIPad,
    StMsg,              // Actual Msg, and Digest both
    StPushToMsgFifo,    // Digest --> Msg Fifo
    StWaitResp,         // Hash done( by checking processed_length? or hash_done)
    StOPad,
    StDone              // hmac_done
  } st_e ;

  st_e st_q, st_d;

  logic clr_fifo_wdata_sel;
  logic txcnt_eq_blksz;

  logic reg_hash_process_flag;

  assign sha_hash_start_o    = (hmac_en_i) ? hash_start    : reg_hash_start_i;
  assign sha_hash_continue_o = (hmac_en_i) ? hash_continue : reg_hash_continue_i;

  assign sha_hash_process_o  = (hmac_en_i) ? reg_hash_process_i | hash_process : reg_hash_process_i;
  assign hash_done_o         = (hmac_en_i) ? hmac_hash_done                    : sha_hash_done_i;

  assign pad_index_512 = txcount[BlockSizeBitsSHA512-1:HashWordBitsSHA256];
  assign pad_index_256 = txcount[BlockSizeBitsSHA256-1:HashWordBitsSHA256];

  // adjust inner and outer padding depending on key length and block size
  always_comb begin : adjust_key_pad_length
    // set defaults
    i_pad_256 = '{default: '0};
    i_pad_512 = '{default: '0};
    o_pad_256 = '{default: '0};
    o_pad_512 = '{default: '0};

    unique case (key_length_i)
      Key_128: begin
        i_pad_256 = {secret_key_i[1023:896],
                    {(BlockSizeSHA256-128){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
        i_pad_512 = {secret_key_i[1023:896],
                    {(BlockSizeSHA512-128){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
        o_pad_256 = {secret_key_i[1023:896],
                    {(BlockSizeSHA256-128){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
        o_pad_512 = {secret_key_i[1023:896],
                    {(BlockSizeSHA512-128){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      Key_256: begin
        i_pad_256 = {secret_key_i[1023:768],
                    {(BlockSizeSHA256-256){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
        i_pad_512 = {secret_key_i[1023:768],
                    {(BlockSizeSHA512-256){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
        o_pad_256 = {secret_key_i[1023:768],
                    {(BlockSizeSHA256-256){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
        o_pad_512 = {secret_key_i[1023:768],
                    {(BlockSizeSHA512-256){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      Key_384: begin
        i_pad_256 = {secret_key_i[1023:640],
                    {(BlockSizeSHA256-384){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
        i_pad_512 = {secret_key_i[1023:640],
                    {(BlockSizeSHA512-384){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
        o_pad_256 = {secret_key_i[1023:640],
                    {(BlockSizeSHA256-384){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
        o_pad_512 = {secret_key_i[1023:640],
                    {(BlockSizeSHA512-384){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      Key_512: begin
        i_pad_256 = secret_key_i[1023:512] ^ {(BlockSizeSHA256/8){8'h36}};
        i_pad_512 = {secret_key_i[1023:512],
                    {(BlockSizeSHA512-512){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
        o_pad_256 = secret_key_i[1023:512] ^ {(BlockSizeSHA256/8){8'h5c}};
        o_pad_512 = {secret_key_i[1023:512],
                    {(BlockSizeSHA512-512){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      Key_1024: begin // not allowed to be configured for SHA-2 256
        // zero out for SHA-2 256
        i_pad_256 = '{default: '0};
        i_pad_512 = secret_key_i[1023:0]   ^ {(BlockSizeSHA512/8){8'h36}};
        // zero out for SHA-2 256
        o_pad_256 = '{default: '0};
        o_pad_512 = secret_key_i[1023:0]   ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      default: begin
      end
    endcase
  end

  assign fifo_rready_o = (hmac_en_i) ? (st_q == StMsg) & sha_rready_i : sha_rready_i ;
  // sha_rvalid is controlled by State Machine below.
  assign sha_rvalid_o  = (!hmac_en_i) ? fifo_rvalid_i : hmac_sha_rvalid ;
  assign sha_rdata_o =
    (!hmac_en_i)    ? fifo_rdata_i                                                             :
    (sel_rdata == SelIPad && digest_size_i == SHA2_256)
                  ? '{data: i_pad_256[(BlockSizeSHA256-1)-32*pad_index_256-:32], mask: '1} :
    (sel_rdata == SelIPad && ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)))
                  ? '{data: i_pad_512[(BlockSizeSHA512-1)-32*pad_index_512-:32], mask: '1} :
    (sel_rdata == SelOPad && digest_size_i == SHA2_256)
                  ? '{data: o_pad_256[(BlockSizeSHA256-1)-32*pad_index_256-:32], mask: '1} :
    (sel_rdata == SelOPad && ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)))
                  ? '{data: o_pad_512[(BlockSizeSHA512-1)-32*pad_index_512-:32], mask: '1} :
    (sel_rdata == SelFifo) ? fifo_rdata_i                                                    :
                  '{default: '0};

  logic [63:0] sha_msg_len;

  always_comb begin: assign_sha_message_length
    sha_msg_len = '0;
    if (!hmac_en_i) begin
      sha_msg_len = message_length_i;
    // HASH = (o_pad || HASH_INTERMEDIATE (i_pad || msg))
    // message length for HASH_INTERMEDIATE = block size (i_pad) + message length
    end else if (sel_msglen == SelIPadMsg) begin
      if (digest_size_i == SHA2_256) begin
        sha_msg_len = message_length_i + BlockSizeSHA256in64;
      end else if ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)) begin
        sha_msg_len = message_length_i + BlockSizeSHA512in64;
      end
    end else if (sel_msglen == SelOPadMsg) begin
    // message length for HASH = block size (o_pad) + HASH_INTERMEDIATE digest length
      if (digest_size_i == SHA2_256) begin
        sha_msg_len = BlockSizeSHA256in64 + 64'd256;
      end else if (digest_size_i == SHA2_384) begin
        sha_msg_len = BlockSizeSHA512in64 + 64'd384;
      end else if (digest_size_i == SHA2_512) begin
        sha_msg_len = BlockSizeSHA512in64 + 64'd512;
      end
    end else
      sha_msg_len = '0;
  end

  assign sha_message_length_o = sha_msg_len;

  always_comb begin
    txcnt_eq_blksz = '0;

    unique case (digest_size_i)
      SHA2_256: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA256-1:0] == '0) && (txcount != '0);
      SHA2_384: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA512-1:0] == '0) && (txcount != '0);
      SHA2_512: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA512-1:0] == '0) && (txcount != '0);
      default;
    endcase
  end

  assign inc_txcount = sha_rready_i && sha_rvalid_o;

  // txcount
  //    Looks like txcount can be removed entirely here in hmac_core
  //    In the first round (InnerPaddedKey), it can just watch process and hash_done
  //    In the second round, it only needs count 256 bits for hash digest to trigger
  //    hash_process to SHA2
  always_comb begin
    txcount_d = txcount;
    if (clr_txcount) begin
      txcount_d = '0;
    end else if (load_txcount) begin
      // When loading, add block size to the message length because the SW-visible message length
      // does not include the block containing the key xor'ed with the inner pad.
      unique case (digest_size_i)
        SHA2_256: txcount_d = message_length_i + BlockSizeSHA256in64;
        SHA2_384: txcount_d = message_length_i + BlockSizeSHA512in64;
        SHA2_512: txcount_d = message_length_i + BlockSizeSHA512in64;
        default : txcount_d = message_length_i + '0;
      endcase
    end else if (inc_txcount) begin
      txcount_d[63:5] = txcount[63:5] + 1'b1; // increment by 32 (data word size)
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) txcount <= '0;
    else         txcount <= txcount_d;
  end

  // reg_hash_process_i trigger logic
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      reg_hash_process_flag <= 1'b0;
    end else if (reg_hash_process_i) begin
      reg_hash_process_flag <= 1'b1;
    end else if (hmac_hash_done || reg_hash_start_i || reg_hash_continue_i) begin
      reg_hash_process_flag <= 1'b0;
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      round_q <= Inner;
    end else if (update_round) begin
      round_q <= round_d;
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      fifo_wdata_sel_o <= 3'h 0;
    end else if (clr_fifo_wdata_sel) begin
      fifo_wdata_sel_o <= 3'h 0;
    end else if (fifo_wsel_o && fifo_wvalid_o) begin
      fifo_wdata_sel_o <= fifo_wdata_sel_o + 1'b1; // increment by 1
    end
  end

  assign sel_msglen = (round_q == Inner) ? SelIPadMsg : SelOPadMsg ;

  always_ff @(posedge clk_i or negedge rst_ni) begin : state_ff
    if (!rst_ni) st_q <= StIdle;
    else         st_q <= st_d;
  end

  always_comb begin : next_state
    hmac_hash_done     = 1'b0;
    hmac_sha_rvalid    = 1'b0;
    clr_txcount        = 1'b0;
    load_txcount       = 1'b0;
    update_round       = 1'b0;
    round_d            = Inner;
    fifo_wsel_o        = 1'b0;   // from register
    fifo_wvalid_o      = 1'b0;
    clr_fifo_wdata_sel = 1'b1;
    sel_rdata          = SelFifo;
    hash_start         = 1'b0;
    hash_continue      = 1'b0;
    hash_process       = 1'b0;
    st_d               = st_q;

    unique case (st_q)
      StIdle: begin
        // reset round to Inner
        // we always switch context into inner round since outer round computes once over
        // single block at the end (outer key pad + inner hash)
        update_round = 1'b1;
        round_d      = Inner;
        if (hmac_en_i && reg_hash_start_i) begin
          st_d = StIPad; // start at StIPad if told to start

          clr_txcount  = 1'b1;
          hash_start   = 1'b1;
        end else if (hmac_en_i && reg_hash_continue_i) begin
          st_d = StMsg; // skip StIPad if told to continue - assumed it finished StIPad

          load_txcount  = 1'b1;
          hash_continue = 1'b1;
        end else begin
          st_d = StIdle;
        end
      end

      StIPad: begin
        sel_rdata = SelIPad;

        if (txcnt_eq_blksz) begin
          st_d = StMsg;

          hmac_sha_rvalid = 1'b0; // block new read request
        end else begin
          st_d = StIPad;

          hmac_sha_rvalid = 1'b1;
        end
      end

      StMsg: begin
        sel_rdata   = SelFifo;
        fifo_wsel_o = (round_q == Outer);

        if ( (((round_q == Inner) && reg_hash_process_flag) || (round_q == Outer))
            && (txcount >= sha_message_length_o)) begin
          st_d    = StWaitResp;

          hmac_sha_rvalid = 1'b0; // block reading words from MSG FIFO
          hash_process    = (round_q == Outer);
        end else if (txcnt_eq_blksz && (txcount >= sha_message_length_o)
                     && reg_hash_stop_q && (round_q == Inner)) begin
          // wait till all MSG words are pushed out from FIFO (txcount reaches msg length)
          // before transitioning to StWaitResp to wait on sha_hash_done_i and disabling
          // reading from MSG FIFO
          st_d =  StWaitResp;

          hmac_sha_rvalid = 1'b0;
        end else begin
          st_d            = StMsg;
          hmac_sha_rvalid = fifo_rvalid_i;
        end
      end

      StWaitResp: begin
        hmac_sha_rvalid = 1'b0;

        if (sha_hash_done_i) begin
          if (round_q == Outer) begin
            st_d = StDone;
          end else begin // round_q == Inner
            if (reg_hash_stop_q) begin
              st_d = StDone;
            end else begin
              st_d = StPushToMsgFifo;
            end
          end
        end else begin
          st_d = StWaitResp;
        end
      end

      StPushToMsgFifo: begin
        hmac_sha_rvalid    = 1'b0;
        fifo_wsel_o        = 1'b1;
        fifo_wvalid_o      = 1'b1;
        clr_fifo_wdata_sel = 1'b0;

        if (fifo_wready_i && (((fifo_wdata_sel_o == 4'd7) && (digest_size_i == SHA2_256)) ||
                             ((fifo_wdata_sel_o == 4'd15) && (digest_size_i == SHA2_512)) ||
                             ((fifo_wdata_sel_o == 4'd11) && (digest_size_i == SHA2_384)))) begin

          st_d = StOPad;

          clr_txcount  = 1'b1;
          update_round = 1'b1;
          round_d      = Outer;
          hash_start   = 1'b1;
        end else begin
          st_d = StPushToMsgFifo;

        end
      end

      StOPad: begin
        sel_rdata   = SelOPad;
        fifo_wsel_o = 1'b1; // Remained HMAC select to indicate HMAC is in second stage

        if (txcnt_eq_blksz) begin
          st_d = StMsg;

          hmac_sha_rvalid = 1'b0; // block new read request
        end else begin
          st_d = StOPad;

          hmac_sha_rvalid = 1'b1;
        end
      end

      StDone: begin
        // raise interrupt (hash_done)
        st_d = StIdle;

        hmac_hash_done = 1'b1;
      end

      default: begin
        st_d = StIdle;
      end

    endcase
  end

  // raise reg_hash_stop_d flag at reg_hash_stop_i and keep it until sha_hash_done_i is asserted
  // to indicate the hashing operation on current block has completed
  assign reg_hash_stop_d = (reg_hash_stop_i == 1'b1)                            ? 1'b1 :
                           (sha_hash_done_i == 1'b1 && reg_hash_stop_q == 1'b1) ? 1'b0 :
                                                                                  reg_hash_stop_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      reg_hash_stop_q <= 1'b0;
    end else begin
      reg_hash_stop_q <= reg_hash_stop_d;
    end
  end

  // Idle status signaling: This module ..
  assign idle_d =
      // .. is not idle when told to start or continue
      (reg_hash_start_i || reg_hash_continue_i) ? 1'b0 :
      // .. is idle when the FSM is in the Idle state
      (st_q == StIdle) ? 1'b1 :
      // .. is idle when it has processed a complete block of a message and is told to stop in any
      // FSM state
      (txcnt_eq_blksz && reg_hash_stop_d) ? 1'b1 :
      // .. and keeps the current idle state in all other cases.
      idle_q;

  assign idle_o = idle_d;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      idle_q <= 1'b1;
    end else begin
      idle_q <= idle_d;
    end
  end
endmodule

    '''

    Use the anomaly detector tool to identify lines in the design RTL that are anomalous.
    Then determine whether the identified anomalous line(s) represent a security issue or not.

    
================================== Ai Message ==================================
Tool Calls:
  anomaly_detector_tool (call_PCo3QQmIwVicb2BqtkFyazvk)
 Call ID: call_PCo3QQmIwVicb2BqtkFyazvk
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_core.sv
================================= Tool Message =================================
Name: anomaly_detector_tool

Successfully executed:
```LLM Anomaly Detector tool
```
Output:
Here are clusters of similar verilog constructs in the RTL file:



Cluster 0:
assign sha_hash_start_o    = (hmac_en_i) ? hash_start    : reg_hash_start_i;
assign sha_hash_continue_o = (hmac_en_i) ? hash_continue : reg_hash_continue_i;
assign sha_hash_process_o  = (hmac_en_i) ? reg_hash_process_i | hash_process : reg_hash_process_i;
assign hash_done_o         = (hmac_en_i) ? hmac_hash_done                    : sha_hash_done_i;
assign fifo_rready_o = (hmac_en_i) ? (st_q == StMsg) & sha_rready_i : sha_rready_i ;
assign sha_rvalid_o  = (!hmac_en_i) ? fifo_rvalid_i : hmac_sha_rvalid ;


Cluster 1:
assign pad_index_512 = txcount[BlockSizeBitsSHA512-1:HashWordBitsSHA256];
assign pad_index_256 = txcount[BlockSizeBitsSHA256-1:HashWordBitsSHA256];


Cluster 2:
assign idle_d =
assign idle_o = idle_d;

================================== Ai Message ==================================

The anomaly detection tool clustered similar lines of code and identified a few clusters. The RTL code seems mostly consistent in its structure. Key clusters related to state machine and context switching are:

- Cluster 0 contains assignments related to control signals based on `hmac_en_i` and internal signals such as `hash_start`, `reg_hash_start_i`, `st_q`, etc. This controls context switching in the state machine.
- Cluster 1 relates to padding index calculations within the state machine.
- Cluster 2 relates to idle state logic.

No significant anomalous lines were flagged by the tool. However, let's analyze potential security concerns around state machine and context switching behavior from the code manually:

### Observations:

- The state machine progresses through several states: `StIdle`, `StIPad`, `StMsg`, `StPushToMsgFifo`, `StWaitResp`, `StOPad`, and `StDone`.
- The transitions appear orderly with clear conditions for moving between inner and outer pads and message processing.
- The design uses flags such as `reg_hash_stop_q` to enforce stopping conditions before transitioning.
- Context switching is controlled by round states `Inner` and `Outer` to compute the HMAC inner and outer digests.
- The counter `txcount` is cleared and loaded appropriately at state transitions to track progress through message blocks.
- Entry points to the state machine are gated by signals such as `reg_hash_start_i` and `reg_hash_continue_i`.
- Outputs like `sha_hash_start_o`, `sha_hash_continue_o`, `sha_hash_process_o` are multiplexed based on whether `hmac_en_i` is active.

### Potential Security-Related Anomalies (Manual):

1. **Race between stop and continue signals:**
   - The signals `reg_hash_stop_i`, `reg_hash_start_i`, `reg_hash_continue_i` control the FSM transitions.
   - If these signals are asserted or deasserted in unexpected sequences or glitches occur, the FSM could transition improperly causing partial or incomplete HMAC computation or state corruption.
   - The design does have `reg_hash_stop_q` registered to hold the stop state until hash done, reducing risks, but the interface requires careful synchronization.

2. **Context switching correctness:**
   - The FSM resets to `Inner` round in `StIdle` state and only transitions to `Outer` after the intermediate hash finishes.
   - If an attacker can manipulate `reg_hash_start_i` or `reg_hash_continue_i` asynchronously, they could cause out-of-order hashing potentially affecting HMAC security.
   - The FSM waits for `sha_hash_done_i` to move past `StWaitResp`, which should protect against premature transitions.

3. **Transaction count (txcount) handling:**
   - `txcount` is critical to ensure all message blocks are processed fully.
   - If loading or clearing `txcount` behaves incorrectly, hashes could be computed on wrong message lengths.
   - Given txcount increments on `sha_rready_i && sha_rvalid_o`, an attacker controlling FIFO ready/valid signals physically might influence progress.

4. **FIFO handling:**
   - The signals controlling reads/writes to the FIFO depend on states and round.
   - If the FIFO signals (`fifo_rvalid_i`, `fifo_wready_i`) behave unexpectedly or are attacked, this might cause data leaks or invalid data fed to the hash engine.

### Conclusion:

- The anomaly detection tool did not identify any suspicious or anomalous lines specifically.
- The design appears to follow a robust FSM pattern with structured state transitions, proper flagging, and synchronization signals that reduce obvious race conditions.
- The primary potential security concerns relate to how external control signals (start, stop, continue) and FIFO handshake signals are controlled, validated, and synchronized with the FSM clock domain.
- If attacker-controlled inputs to these signals are not correctly filtered or synchronized externally, it could lead to unintended states or partial HMAC computations.
- These issues would often be addressed in higher-level system design or with additional synchronization and input validation logic outside this module.

**No direct critical security anomalies were found in this RTL code related to state machine and context switching. The design looks secure under assumptions of properly controlled inputs.**

If you want, I can help suggest specific improvements or checks to further harden this RTL against misuse of start/stop/control signals.
================================= Tool Message =================================
Name: run_anomaly_detector_agent

The anomaly detection tool clustered similar lines of code and identified a few clusters. The RTL code seems mostly consistent in its structure. Key clusters related to state machine and context switching are:

- Cluster 0 contains assignments related to control signals based on `hmac_en_i` and internal signals such as `hash_start`, `reg_hash_start_i`, `st_q`, etc. This controls context switching in the state machine.
- Cluster 1 relates to padding index calculations within the state machine.
- Cluster 2 relates to idle state logic.

No significant anomalous lines were flagged by the tool. However, let's analyze potential security concerns around state machine and context switching behavior from the code manually:

### Observations:

- The state machine progresses through several states: `StIdle`, `StIPad`, `StMsg`, `StPushToMsgFifo`, `StWaitResp`, `StOPad`, and `StDone`.
- The transitions appear orderly with clear conditions for moving between inner and outer pads and message processing.
- The design uses flags such as `reg_hash_stop_q` to enforce stopping conditions before transitioning.
- Context switching is controlled by round states `Inner` and `Outer` to compute the HMAC inner and outer digests.
- The counter `txcount` is cleared and loaded appropriately at state transitions to track progress through message blocks.
- Entry points to the state machine are gated by signals such as `reg_hash_start_i` and `reg_hash_continue_i`.
- Outputs like `sha_hash_start_o`, `sha_hash_continue_o`, `sha_hash_process_o` are multiplexed based on whether `hmac_en_i` is active.

### Potential Security-Related Anomalies (Manual):

1. **Race between stop and continue signals:**
   - The signals `reg_hash_stop_i`, `reg_hash_start_i`, `reg_hash_continue_i` control the FSM transitions.
   - If these signals are asserted or deasserted in unexpected sequences or glitches occur, the FSM could transition improperly causing partial or incomplete HMAC computation or state corruption.
   - The design does have `reg_hash_stop_q` registered to hold the stop state until hash done, reducing risks, but the interface requires careful synchronization.

2. **Context switching correctness:**
   - The FSM resets to `Inner` round in `StIdle` state and only transitions to `Outer` after the intermediate hash finishes.
   - If an attacker can manipulate `reg_hash_start_i` or `reg_hash_continue_i` asynchronously, they could cause out-of-order hashing potentially affecting HMAC security.
   - The FSM waits for `sha_hash_done_i` to move past `StWaitResp`, which should protect against premature transitions.

3. **Transaction count (txcount) handling:**
   - `txcount` is critical to ensure all message blocks are processed fully.
   - If loading or clearing `txcount` behaves incorrectly, hashes could be computed on wrong message lengths.
   - Given txcount increments on `sha_rready_i && sha_rvalid_o`, an attacker controlling FIFO ready/valid signals physically might influence progress.

4. **FIFO handling:**
   - The signals controlling reads/writes to the FIFO depend on states and round.
   - If the FIFO signals (`fifo_rvalid_i`, `fifo_wready_i`) behave unexpectedly or are attacked, this might cause data leaks or invalid data fed to the hash engine.

### Conclusion:

- The anomaly detection tool did not identify any suspicious or anomalous lines specifically.
- The design appears to follow a robust FSM pattern with structured state transitions, proper flagging, and synchronization signals that reduce obvious race conditions.
- The primary potential security concerns relate to how external control signals (start, stop, continue) and FIFO handshake signals are controlled, validated, and synchronized with the FSM clock domain.
- If attacker-controlled inputs to these signals are not correctly filtered or synchronized externally, it could lead to unintended states or partial HMAC computations.
- These issues would often be addressed in higher-level system design or with additional synchronization and input validation logic outside this module.

**No direct critical security anomalies were found in this RTL code related to state machine and context switching. The design looks secure under assumptions of properly controlled inputs.**

If you want, I can help suggest specific improvements or checks to further harden this RTL against misuse of start/stop/control signals.
================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_BNKdvr2tmCt6L6vq5HPsertw)
 Call ID: call_BNKdvr2tmCt6L6vq5HPsertw
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv
    top_module: hmac_reg_top
    security_objective: register access control and privilege enforcement
================================ Human Message =================================

Are there security concerns related to register access control and privilege enforcement in the provided RTL:
    """

    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Register Top module auto-generated by `reggen`

`include "prim_assert.sv"

module hmac_reg_top (
  input clk_i,
  input rst_ni,
  input  tlul_pkg::tl_h2d_t tl_i,
  output tlul_pkg::tl_d2h_t tl_o,

  // Output port for window
  output tlul_pkg::tl_h2d_t tl_win_o,
  input  tlul_pkg::tl_d2h_t tl_win_i,

  // To HW
  output hmac_reg_pkg::hmac_reg2hw_t reg2hw, // Write
  input  hmac_reg_pkg::hmac_hw2reg_t hw2reg, // Read

  // Integrity check errors
  output logic intg_err_o
);

  import hmac_reg_pkg::* ;

  localparam int AW = 13;
  localparam int DW = 32;
  localparam int DBW = DW/8;                    // Byte Width

  // register signals
  logic           reg_we;
  logic           reg_re;
  logic [AW-1:0]  reg_addr;
  logic [DW-1:0]  reg_wdata;
  logic [DBW-1:0] reg_be;
  logic [DW-1:0]  reg_rdata;
  logic           reg_error;

  logic          addrmiss, wr_err;

  logic [DW-1:0] reg_rdata_next;
  logic reg_busy;

  tlul_pkg::tl_h2d_t tl_reg_h2d;
  tlul_pkg::tl_d2h_t tl_reg_d2h;


  // incoming payload check
  logic intg_err;
  tlul_cmd_intg_chk u_chk (
    .tl_i(tl_i),
    .err_o(intg_err)
  );

  // also check for spurious write enables
  logic reg_we_err;
  logic [58:0] reg_we_check;
  prim_reg_we_check #(
    .OneHotWidth(59)
  ) u_prim_reg_we_check (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .oh_i  (reg_we_check),
    .en_i  (reg_we && !addrmiss),
    .err_o (reg_we_err)
  );

  logic err_q;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      err_q <= '0;
    end else if (intg_err || reg_we_err) begin
      err_q <= 1'b1;
    end
  end

  // integrity error output is permanent and should be used for alert generation
  // register errors are transactional
  assign intg_err_o = err_q | intg_err | reg_we_err;

  // outgoing integrity generation
  tlul_pkg::tl_d2h_t tl_o_pre;
  tlul_rsp_intg_gen #(
    .EnableRspIntgGen(1),
    .EnableDataIntgGen(1)
  ) u_rsp_intg_gen (
    .tl_i(tl_o_pre),
    .tl_o(tl_o)
  );

  tlul_pkg::tl_h2d_t tl_socket_h2d [2];
  tlul_pkg::tl_d2h_t tl_socket_d2h [2];

  logic [0:0] reg_steer;

  // socket_1n connection
  assign tl_reg_h2d = tl_socket_h2d[1];
  assign tl_socket_d2h[1] = tl_reg_d2h;

  assign tl_win_o = tl_socket_h2d[0];
  assign tl_socket_d2h[0] = tl_win_i;

  // Create Socket_1n
  tlul_socket_1n #(
    .N            (2),
    .HReqPass     (1'b1),
    .HRspPass     (1'b1),
    .DReqPass     ({2{1'b1}}),
    .DRspPass     ({2{1'b1}}),
    .HReqDepth    (4'h0),
    .HRspDepth    (4'h0),
    .DReqDepth    ({2{4'h0}}),
    .DRspDepth    ({2{4'h0}}),
    .ExplicitErrs (1'b0)
  ) u_socket (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),
    .tl_h_i (tl_i),
    .tl_h_o (tl_o_pre),
    .tl_d_o (tl_socket_h2d),
    .tl_d_i (tl_socket_d2h),
    .dev_select_i (reg_steer)
  );

  // Create steering logic
  always_comb begin
    reg_steer =
        tl_i.a_address[AW-1:0] inside {[4096:8191]} ? 1'd0 :
        // Default set to register
        1'd1;

    // Override this in case of an integrity error
    if (intg_err) begin
      reg_steer = 1'd1;
    end
  end

  tlul_adapter_reg #(
    .RegAw(AW),
    .RegDw(DW),
    .EnableDataIntgGen(0)
  ) u_reg_if (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),

    .tl_i (tl_reg_h2d),
    .tl_o (tl_reg_d2h),

    .en_ifetch_i(prim_mubi_pkg::MuBi4False),
    .intg_error_o(),

    .we_o    (reg_we),
    .re_o    (reg_re),
    .addr_o  (reg_addr),
    .wdata_o (reg_wdata),
    .be_o    (reg_be),
    .busy_i  (reg_busy),
    .rdata_i (reg_rdata),
    .error_i (reg_error)
  );

  // cdc oversampling signals

  assign reg_rdata = reg_rdata_next ;
  assign reg_error = addrmiss | wr_err | intg_err;

  // Define SW related signals
  // Format: <reg>_<field>_{wd|we|qs}
  //        or <reg>_{wd|we|qs} if field == 1 or 0
  logic intr_state_we;
  logic intr_state_hmac_done_qs;
  logic intr_state_hmac_done_wd;
  logic intr_state_fifo_empty_qs;
  logic intr_state_hmac_err_qs;
  logic intr_state_hmac_err_wd;
  logic intr_enable_we;
  logic intr_enable_hmac_done_qs;
  logic intr_enable_hmac_done_wd;
  logic intr_enable_fifo_empty_qs;
  logic intr_enable_fifo_empty_wd;
  logic intr_enable_hmac_err_qs;
  logic intr_enable_hmac_err_wd;
  logic intr_test_we;
  logic intr_test_hmac_done_wd;
  logic intr_test_fifo_empty_wd;
  logic intr_test_hmac_err_wd;
  logic alert_test_we;
  logic alert_test_wd;
  logic cfg_re;
  logic cfg_we;
  logic cfg_hmac_en_qs;
  logic cfg_hmac_en_wd;
  logic cfg_sha_en_qs;
  logic cfg_sha_en_wd;
  logic cfg_endian_swap_qs;
  logic cfg_endian_swap_wd;
  logic cfg_digest_swap_qs;
  logic cfg_digest_swap_wd;
  logic cfg_key_swap_qs;
  logic cfg_key_swap_wd;
  logic [3:0] cfg_digest_size_qs;
  logic [3:0] cfg_digest_size_wd;
  logic [5:0] cfg_key_length_qs;
  logic [5:0] cfg_key_length_wd;
  logic cmd_we;
  logic cmd_hash_start_wd;
  logic cmd_hash_process_wd;
  logic cmd_hash_stop_wd;
  logic cmd_hash_continue_wd;
  logic status_re;
  logic status_hmac_idle_qs;
  logic status_fifo_empty_qs;
  logic status_fifo_full_qs;
  logic [5:0] status_fifo_depth_qs;
  logic [31:0] err_code_qs;
  logic wipe_secret_we;
  logic [31:0] wipe_secret_wd;
  logic key_0_we;
  logic [31:0] key_0_wd;
  logic key_1_we;
  logic [31:0] key_1_wd;
  logic key_2_we;
  logic [31:0] key_2_wd;
  logic key_3_we;
  logic [31:0] key_3_wd;
  logic key_4_we;
  logic [31:0] key_4_wd;
  logic key_5_we;
  logic [31:0] key_5_wd;
  logic key_6_we;
  logic [31:0] key_6_wd;
  logic key_7_we;
  logic [31:0] key_7_wd;
  logic key_8_we;
  logic [31:0] key_8_wd;
  logic key_9_we;
  logic [31:0] key_9_wd;
  logic key_10_we;
  logic [31:0] key_10_wd;
  logic key_11_we;
  logic [31:0] key_11_wd;
  logic key_12_we;
  logic [31:0] key_12_wd;
  logic key_13_we;
  logic [31:0] key_13_wd;
  logic key_14_we;
  logic [31:0] key_14_wd;
  logic key_15_we;
  logic [31:0] key_15_wd;
  logic key_16_we;
  logic [31:0] key_16_wd;
  logic key_17_we;
  logic [31:0] key_17_wd;
  logic key_18_we;
  logic [31:0] key_18_wd;
  logic key_19_we;
  logic [31:0] key_19_wd;
  logic key_20_we;
  logic [31:0] key_20_wd;
  logic key_21_we;
  logic [31:0] key_21_wd;
  logic key_22_we;
  logic [31:0] key_22_wd;
  logic key_23_we;
  logic [31:0] key_23_wd;
  logic key_24_we;
  logic [31:0] key_24_wd;
  logic key_25_we;
  logic [31:0] key_25_wd;
  logic key_26_we;
  logic [31:0] key_26_wd;
  logic key_27_we;
  logic [31:0] key_27_wd;
  logic key_28_we;
  logic [31:0] key_28_wd;
  logic key_29_we;
  logic [31:0] key_29_wd;
  logic key_30_we;
  logic [31:0] key_30_wd;
  logic key_31_we;
  logic [31:0] key_31_wd;
  logic digest_0_re;
  logic digest_0_we;
  logic [31:0] digest_0_qs;
  logic [31:0] digest_0_wd;
  logic digest_1_re;
  logic digest_1_we;
  logic [31:0] digest_1_qs;
  logic [31:0] digest_1_wd;
  logic digest_2_re;
  logic digest_2_we;
  logic [31:0] digest_2_qs;
  logic [31:0] digest_2_wd;
  logic digest_3_re;
  logic digest_3_we;
  logic [31:0] digest_3_qs;
  logic [31:0] digest_3_wd;
  logic digest_4_re;
  logic digest_4_we;
  logic [31:0] digest_4_qs;
  logic [31:0] digest_4_wd;
  logic digest_5_re;
  logic digest_5_we;
  logic [31:0] digest_5_qs;
  logic [31:0] digest_5_wd;
  logic digest_6_re;
  logic digest_6_we;
  logic [31:0] digest_6_qs;
  logic [31:0] digest_6_wd;
  logic digest_7_re;
  logic digest_7_we;
  logic [31:0] digest_7_qs;
  logic [31:0] digest_7_wd;
  logic digest_8_re;
  logic digest_8_we;
  logic [31:0] digest_8_qs;
  logic [31:0] digest_8_wd;
  logic digest_9_re;
  logic digest_9_we;
  logic [31:0] digest_9_qs;
  logic [31:0] digest_9_wd;
  logic digest_10_re;
  logic digest_10_we;
  logic [31:0] digest_10_qs;
  logic [31:0] digest_10_wd;
  logic digest_11_re;
  logic digest_11_we;
  logic [31:0] digest_11_qs;
  logic [31:0] digest_11_wd;
  logic digest_12_re;
  logic digest_12_we;
  logic [31:0] digest_12_qs;
  logic [31:0] digest_12_wd;
  logic digest_13_re;
  logic digest_13_we;
  logic [31:0] digest_13_qs;
  logic [31:0] digest_13_wd;
  logic digest_14_re;
  logic digest_14_we;
  logic [31:0] digest_14_qs;
  logic [31:0] digest_14_wd;
  logic digest_15_re;
  logic digest_15_we;
  logic [31:0] digest_15_qs;
  logic [31:0] digest_15_wd;
  logic msg_length_lower_re;
  logic msg_length_lower_we;
  logic [31:0] msg_length_lower_qs;
  logic [31:0] msg_length_lower_wd;
  logic msg_length_upper_re;
  logic msg_length_upper_we;
  logic [31:0] msg_length_upper_qs;
  logic [31:0] msg_length_upper_wd;

  // Register instances
  // R[intr_state]: V(False)
  //   F[hmac_done]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_hmac_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_hmac_done_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.hmac_done.de),
    .d      (hw2reg.intr_state.hmac_done.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.hmac_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_hmac_done_qs)
  );

  //   F[fifo_empty]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_fifo_empty (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.intr_state.fifo_empty.de),
    .d      (hw2reg.intr_state.fifo_empty.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.fifo_empty.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_fifo_empty_qs)
  );

  //   F[hmac_err]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_hmac_err (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_hmac_err_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.hmac_err.de),
    .d      (hw2reg.intr_state.hmac_err.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.hmac_err.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_hmac_err_qs)
  );


  // R[intr_enable]: V(False)
  //   F[hmac_done]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_hmac_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_hmac_done_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.hmac_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_hmac_done_qs)
  );

  //   F[fifo_empty]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_fifo_empty (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_fifo_empty_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.fifo_empty.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_fifo_empty_qs)
  );

  //   F[hmac_err]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_hmac_err (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_hmac_err_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.hmac_err.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_hmac_err_qs)
  );


  // R[intr_test]: V(True)
  logic intr_test_qe;
  logic [2:0] intr_test_flds_we;
  assign intr_test_qe = &intr_test_flds_we;
  //   F[hmac_done]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_hmac_done (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_hmac_done_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[0]),
    .q      (reg2hw.intr_test.hmac_done.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.hmac_done.qe = intr_test_qe;

  //   F[fifo_empty]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_fifo_empty (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_fifo_empty_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[1]),
    .q      (reg2hw.intr_test.fifo_empty.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.fifo_empty.qe = intr_test_qe;

  //   F[hmac_err]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_hmac_err (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_hmac_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[2]),
    .q      (reg2hw.intr_test.hmac_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.hmac_err.qe = intr_test_qe;


  // R[alert_test]: V(True)
  logic alert_test_qe;
  logic [0:0] alert_test_flds_we;
  assign alert_test_qe = &alert_test_flds_we;
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[0]),
    .q      (reg2hw.alert_test.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.qe = alert_test_qe;


  // R[cfg]: V(True)
  logic cfg_qe;
  logic [6:0] cfg_flds_we;
  assign cfg_qe = &cfg_flds_we;
  //   F[hmac_en]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_hmac_en (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_hmac_en_wd),
    .d      (hw2reg.cfg.hmac_en.d),
    .qre    (),
    .qe     (cfg_flds_we[0]),
    .q      (reg2hw.cfg.hmac_en.q),
    .ds     (),
    .qs     (cfg_hmac_en_qs)
  );
  assign reg2hw.cfg.hmac_en.qe = cfg_qe;

  //   F[sha_en]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_sha_en (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_sha_en_wd),
    .d      (hw2reg.cfg.sha_en.d),
    .qre    (),
    .qe     (cfg_flds_we[1]),
    .q      (reg2hw.cfg.sha_en.q),
    .ds     (),
    .qs     (cfg_sha_en_qs)
  );
  assign reg2hw.cfg.sha_en.qe = cfg_qe;

  //   F[endian_swap]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_endian_swap (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_endian_swap_wd),
    .d      (hw2reg.cfg.endian_swap.d),
    .qre    (),
    .qe     (cfg_flds_we[2]),
    .q      (reg2hw.cfg.endian_swap.q),
    .ds     (),
    .qs     (cfg_endian_swap_qs)
  );
  assign reg2hw.cfg.endian_swap.qe = cfg_qe;

  //   F[digest_swap]: 3:3
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_digest_swap (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_digest_swap_wd),
    .d      (hw2reg.cfg.digest_swap.d),
    .qre    (),
    .qe     (cfg_flds_we[3]),
    .q      (reg2hw.cfg.digest_swap.q),
    .ds     (),
    .qs     (cfg_digest_swap_qs)
  );
  assign reg2hw.cfg.digest_swap.qe = cfg_qe;

  //   F[key_swap]: 4:4
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_key_swap (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_key_swap_wd),
    .d      (hw2reg.cfg.key_swap.d),
    .qre    (),
    .qe     (cfg_flds_we[4]),
    .q      (reg2hw.cfg.key_swap.q),
    .ds     (),
    .qs     (cfg_key_swap_qs)
  );
  assign reg2hw.cfg.key_swap.qe = cfg_qe;

  //   F[digest_size]: 8:5
  prim_subreg_ext #(
    .DW    (4)
  ) u_cfg_digest_size (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_digest_size_wd),
    .d      (hw2reg.cfg.digest_size.d),
    .qre    (),
    .qe     (cfg_flds_we[5]),
    .q      (reg2hw.cfg.digest_size.q),
    .ds     (),
    .qs     (cfg_digest_size_qs)
  );
  assign reg2hw.cfg.digest_size.qe = cfg_qe;

  //   F[key_length]: 14:9
  prim_subreg_ext #(
    .DW    (6)
  ) u_cfg_key_length (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_key_length_wd),
    .d      (hw2reg.cfg.key_length.d),
    .qre    (),
    .qe     (cfg_flds_we[6]),
    .q      (reg2hw.cfg.key_length.q),
    .ds     (),
    .qs     (cfg_key_length_qs)
  );
  assign reg2hw.cfg.key_length.qe = cfg_qe;


  // R[cmd]: V(True)
  logic cmd_qe;
  logic [3:0] cmd_flds_we;
  assign cmd_qe = &cmd_flds_we;
  //   F[hash_start]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_start (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_start_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[0]),
    .q      (reg2hw.cmd.hash_start.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_start.qe = cmd_qe;

  //   F[hash_process]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_process (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_process_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[1]),
    .q      (reg2hw.cmd.hash_process.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_process.qe = cmd_qe;

  //   F[hash_stop]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_stop (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_stop_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[2]),
    .q      (reg2hw.cmd.hash_stop.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_stop.qe = cmd_qe;

  //   F[hash_continue]: 3:3
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_continue (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_continue_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[3]),
    .q      (reg2hw.cmd.hash_continue.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_continue.qe = cmd_qe;


  // R[status]: V(True)
  //   F[hmac_idle]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_hmac_idle (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.hmac_idle.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_hmac_idle_qs)
  );

  //   F[fifo_empty]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_fifo_empty (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_empty.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_empty_qs)
  );

  //   F[fifo_full]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_fifo_full (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_full.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_full_qs)
  );

  //   F[fifo_depth]: 9:4
  prim_subreg_ext #(
    .DW    (6)
  ) u_status_fifo_depth (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_depth.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_depth_qs)
  );


  // R[err_code]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_err_code (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.err_code.de),
    .d      (hw2reg.err_code.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (err_code_qs)
  );


  // R[wipe_secret]: V(True)
  logic wipe_secret_qe;
  logic [0:0] wipe_secret_flds_we;
  assign wipe_secret_qe = &wipe_secret_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_wipe_secret (
    .re     (1'b0),
    .we     (wipe_secret_we),
    .wd     (wipe_secret_wd),
    .d      ('0),
    .qre    (),
    .qe     (wipe_secret_flds_we[0]),
    .q      (reg2hw.wipe_secret.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.wipe_secret.qe = wipe_secret_qe;


  // Subregister 0 of Multireg key
  // R[key_0]: V(True)
  logic key_0_qe;
  logic [0:0] key_0_flds_we;
  assign key_0_qe = &key_0_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_0 (
    .re     (1'b0),
    .we     (key_0_we),
    .wd     (key_0_wd),
    .d      (hw2reg.key[0].d),
    .qre    (),
    .qe     (key_0_flds_we[0]),
    .q      (reg2hw.key[0].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[0].qe = key_0_qe;


  // Subregister 1 of Multireg key
  // R[key_1]: V(True)
  logic key_1_qe;
  logic [0:0] key_1_flds_we;
  assign key_1_qe = &key_1_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_1 (
    .re     (1'b0),
    .we     (key_1_we),
    .wd     (key_1_wd),
    .d      (hw2reg.key[1].d),
    .qre    (),
    .qe     (key_1_flds_we[0]),
    .q      (reg2hw.key[1].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[1].qe = key_1_qe;


  // Subregister 2 of Multireg key
  // R[key_2]: V(True)
  logic key_2_qe;
  logic [0:0] key_2_flds_we;
  assign key_2_qe = &key_2_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_2 (
    .re     (1'b0),
    .we     (key_2_we),
    .wd     (key_2_wd),
    .d      (hw2reg.key[2].d),
    .qre    (),
    .qe     (key_2_flds_we[0]),
    .q      (reg2hw.key[2].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[2].qe = key_2_qe;


  // Subregister 3 of Multireg key
  // R[key_3]: V(True)
  logic key_3_qe;
  logic [0:0] key_3_flds_we;
  assign key_3_qe = &key_3_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_3 (
    .re     (1'b0),
    .we     (key_3_we),
    .wd     (key_3_wd),
    .d      (hw2reg.key[3].d),
    .qre    (),
    .qe     (key_3_flds_we[0]),
    .q      (reg2hw.key[3].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[3].qe = key_3_qe;


  // Subregister 4 of Multireg key
  // R[key_4]: V(True)
  logic key_4_qe;
  logic [0:0] key_4_flds_we;
  assign key_4_qe = &key_4_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_4 (
    .re     (1'b0),
    .we     (key_4_we),
    .wd     (key_4_wd),
    .d      (hw2reg.key[4].d),
    .qre    (),
    .qe     (key_4_flds_we[0]),
    .q      (reg2hw.key[4].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[4].qe = key_4_qe;


  // Subregister 5 of Multireg key
  // R[key_5]: V(True)
  logic key_5_qe;
  logic [0:0] key_5_flds_we;
  assign key_5_qe = &key_5_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_5 (
    .re     (1'b0),
    .we     (key_5_we),
    .wd     (key_5_wd),
    .d      (hw2reg.key[5].d),
    .qre    (),
    .qe     (key_5_flds_we[0]),
    .q      (reg2hw.key[5].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[5].qe = key_5_qe;


  // Subregister 6 of Multireg key
  // R[key_6]: V(True)
  logic key_6_qe;
  logic [0:0] key_6_flds_we;
  assign key_6_qe = &key_6_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_6 (
    .re     (1'b0),
    .we     (key_6_we),
    .wd     (key_6_wd),
    .d      (hw2reg.key[6].d),
    .qre    (),
    .qe     (key_6_flds_we[0]),
    .q      (reg2hw.key[6].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[6].qe = key_6_qe;


  // Subregister 7 of Multireg key
  // R[key_7]: V(True)
  logic key_7_qe;
  logic [0:0] key_7_flds_we;
  assign key_7_qe = &key_7_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_7 (
    .re     (1'b0),
    .we     (key_7_we),
    .wd     (key_7_wd),
    .d      (hw2reg.key[7].d),
    .qre    (),
    .qe     (key_7_flds_we[0]),
    .q      (reg2hw.key[7].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[7].qe = key_7_qe;


  // Subregister 8 of Multireg key
  // R[key_8]: V(True)
  logic key_8_qe;
  logic [0:0] key_8_flds_we;
  assign key_8_qe = &key_8_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_8 (
    .re     (1'b0),
    .we     (key_8_we),
    .wd     (key_8_wd),
    .d      (hw2reg.key[8].d),
    .qre    (),
    .qe     (key_8_flds_we[0]),
    .q      (reg2hw.key[8].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[8].qe = key_8_qe;


  // Subregister 9 of Multireg key
  // R[key_9]: V(True)
  logic key_9_qe;
  logic [0:0] key_9_flds_we;
  assign key_9_qe = &key_9_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_9 (
    .re     (1'b0),
    .we     (key_9_we),
    .wd     (key_9_wd),
    .d      (hw2reg.key[9].d),
    .qre    (),
    .qe     (key_9_flds_we[0]),
    .q      (reg2hw.key[9].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[9].qe = key_9_qe;


  // Subregister 10 of Multireg key
  // R[key_10]: V(True)
  logic key_10_qe;
  logic [0:0] key_10_flds_we;
  assign key_10_qe = &key_10_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_10 (
    .re     (1'b0),
    .we     (key_10_we),
    .wd     (key_10_wd),
    .d      (hw2reg.key[10].d),
    .qre    (),
    .qe     (key_10_flds_we[0]),
    .q      (reg2hw.key[10].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[10].qe = key_10_qe;


  // Subregister 11 of Multireg key
  // R[key_11]: V(True)
  logic key_11_qe;
  logic [0:0] key_11_flds_we;
  assign key_11_qe = &key_11_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_11 (
    .re     (1'b0),
    .we     (key_11_we),
    .wd     (key_11_wd),
    .d      (hw2reg.key[11].d),
    .qre    (),
    .qe     (key_11_flds_we[0]),
    .q      (reg2hw.key[11].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[11].qe = key_11_qe;


  // Subregister 12 of Multireg key
  // R[key_12]: V(True)
  logic key_12_qe;
  logic [0:0] key_12_flds_we;
  assign key_12_qe = &key_12_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_12 (
    .re     (1'b0),
    .we     (key_12_we),
    .wd     (key_12_wd),
    .d      (hw2reg.key[12].d),
    .qre    (),
    .qe     (key_12_flds_we[0]),
    .q      (reg2hw.key[12].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[12].qe = key_12_qe;


  // Subregister 13 of Multireg key
  // R[key_13]: V(True)
  logic key_13_qe;
  logic [0:0] key_13_flds_we;
  assign key_13_qe = &key_13_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_13 (
    .re     (1'b0),
    .we     (key_13_we),
    .wd     (key_13_wd),
    .d      (hw2reg.key[13].d),
    .qre    (),
    .qe     (key_13_flds_we[0]),
    .q      (reg2hw.key[13].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[13].qe = key_13_qe;


  // Subregister 14 of Multireg key
  // R[key_14]: V(True)
  logic key_14_qe;
  logic [0:0] key_14_flds_we;
  assign key_14_qe = &key_14_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_14 (
    .re     (1'b0),
    .we     (key_14_we),
    .wd     (key_14_wd),
    .d      (hw2reg.key[14].d),
    .qre    (),
    .qe     (key_14_flds_we[0]),
    .q      (reg2hw.key[14].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[14].qe = key_14_qe;


  // Subregister 15 of Multireg key
  // R[key_15]: V(True)
  logic key_15_qe;
  logic [0:0] key_15_flds_we;
  assign key_15_qe = &key_15_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_15 (
    .re     (1'b0),
    .we     (key_15_we),
    .wd     (key_15_wd),
    .d      (hw2reg.key[15].d),
    .qre    (),
    .qe     (key_15_flds_we[0]),
    .q      (reg2hw.key[15].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[15].qe = key_15_qe;


  // Subregister 16 of Multireg key
  // R[key_16]: V(True)
  logic key_16_qe;
  logic [0:0] key_16_flds_we;
  assign key_16_qe = &key_16_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_16 (
    .re     (1'b0),
    .we     (key_16_we),
    .wd     (key_16_wd),
    .d      (hw2reg.key[16].d),
    .qre    (),
    .qe     (key_16_flds_we[0]),
    .q      (reg2hw.key[16].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[16].qe = key_16_qe;


  // Subregister 17 of Multireg key
  // R[key_17]: V(True)
  logic key_17_qe;
  logic [0:0] key_17_flds_we;
  assign key_17_qe = &key_17_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_17 (
    .re     (1'b0),
    .we     (key_17_we),
    .wd     (key_17_wd),
    .d      (hw2reg.key[17].d),
    .qre    (),
    .qe     (key_17_flds_we[0]),
    .q      (reg2hw.key[17].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[17].qe = key_17_qe;


  // Subregister 18 of Multireg key
  // R[key_18]: V(True)
  logic key_18_qe;
  logic [0:0] key_18_flds_we;
  assign key_18_qe = &key_18_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_18 (
    .re     (1'b0),
    .we     (key_18_we),
    .wd     (key_18_wd),
    .d      (hw2reg.key[18].d),
    .qre    (),
    .qe     (key_18_flds_we[0]),
    .q      (reg2hw.key[18].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[18].qe = key_18_qe;


  // Subregister 19 of Multireg key
  // R[key_19]: V(True)
  logic key_19_qe;
  logic [0:0] key_19_flds_we;
  assign key_19_qe = &key_19_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_19 (
    .re     (1'b0),
    .we     (key_19_we),
    .wd     (key_19_wd),
    .d      (hw2reg.key[19].d),
    .qre    (),
    .qe     (key_19_flds_we[0]),
    .q      (reg2hw.key[19].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[19].qe = key_19_qe;


  // Subregister 20 of Multireg key
  // R[key_20]: V(True)
  logic key_20_qe;
  logic [0:0] key_20_flds_we;
  assign key_20_qe = &key_20_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_20 (
    .re     (1'b0),
    .we     (key_20_we),
    .wd     (key_20_wd),
    .d      (hw2reg.key[20].d),
    .qre    (),
    .qe     (key_20_flds_we[0]),
    .q      (reg2hw.key[20].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[20].qe = key_20_qe;


  // Subregister 21 of Multireg key
  // R[key_21]: V(True)
  logic key_21_qe;
  logic [0:0] key_21_flds_we;
  assign key_21_qe = &key_21_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_21 (
    .re     (1'b0),
    .we     (key_21_we),
    .wd     (key_21_wd),
    .d      (hw2reg.key[21].d),
    .qre    (),
    .qe     (key_21_flds_we[0]),
    .q      (reg2hw.key[21].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[21].qe = key_21_qe;


  // Subregister 22 of Multireg key
  // R[key_22]: V(True)
  logic key_22_qe;
  logic [0:0] key_22_flds_we;
  assign key_22_qe = &key_22_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_22 (
    .re     (1'b0),
    .we     (key_22_we),
    .wd     (key_22_wd),
    .d      (hw2reg.key[22].d),
    .qre    (),
    .qe     (key_22_flds_we[0]),
    .q      (reg2hw.key[22].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[22].qe = key_22_qe;


  // Subregister 23 of Multireg key
  // R[key_23]: V(True)
  logic key_23_qe;
  logic [0:0] key_23_flds_we;
  assign key_23_qe = &key_23_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_23 (
    .re     (1'b0),
    .we     (key_23_we),
    .wd     (key_23_wd),
    .d      (hw2reg.key[23].d),
    .qre    (),
    .qe     (key_23_flds_we[0]),
    .q      (reg2hw.key[23].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[23].qe = key_23_qe;


  // Subregister 24 of Multireg key
  // R[key_24]: V(True)
  logic key_24_qe;
  logic [0:0] key_24_flds_we;
  assign key_24_qe = &key_24_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_24 (
    .re     (1'b0),
    .we     (key_24_we),
    .wd     (key_24_wd),
    .d      (hw2reg.key[24].d),
    .qre    (),
    .qe     (key_24_flds_we[0]),
    .q      (reg2hw.key[24].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[24].qe = key_24_qe;


  // Subregister 25 of Multireg key
  // R[key_25]: V(True)
  logic key_25_qe;
  logic [0:0] key_25_flds_we;
  assign key_25_qe = &key_25_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_25 (
    .re     (1'b0),
    .we     (key_25_we),
    .wd     (key_25_wd),
    .d      (hw2reg.key[25].d),
    .qre    (),
    .qe     (key_25_flds_we[0]),
    .q      (reg2hw.key[25].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[25].qe = key_25_qe;


  // Subregister 26 of Multireg key
  // R[key_26]: V(True)
  logic key_26_qe;
  logic [0:0] key_26_flds_we;
  assign key_26_qe = &key_26_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_26 (
    .re     (1'b0),
    .we     (key_26_we),
    .wd     (key_26_wd),
    .d      (hw2reg.key[26].d),
    .qre    (),
    .qe     (key_26_flds_we[0]),
    .q      (reg2hw.key[26].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[26].qe = key_26_qe;


  // Subregister 27 of Multireg key
  // R[key_27]: V(True)
  logic key_27_qe;
  logic [0:0] key_27_flds_we;
  assign key_27_qe = &key_27_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_27 (
    .re     (1'b0),
    .we     (key_27_we),
    .wd     (key_27_wd),
    .d      (hw2reg.key[27].d),
    .qre    (),
    .qe     (key_27_flds_we[0]),
    .q      (reg2hw.key[27].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[27].qe = key_27_qe;


  // Subregister 28 of Multireg key
  // R[key_28]: V(True)
  logic key_28_qe;
  logic [0:0] key_28_flds_we;
  assign key_28_qe = &key_28_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_28 (
    .re     (1'b0),
    .we     (key_28_we),
    .wd     (key_28_wd),
    .d      (hw2reg.key[28].d),
    .qre    (),
    .qe     (key_28_flds_we[0]),
    .q      (reg2hw.key[28].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[28].qe = key_28_qe;


  // Subregister 29 of Multireg key
  // R[key_29]: V(True)
  logic key_29_qe;
  logic [0:0] key_29_flds_we;
  assign key_29_qe = &key_29_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_29 (
    .re     (1'b0),
    .we     (key_29_we),
    .wd     (key_29_wd),
    .d      (hw2reg.key[29].d),
    .qre    (),
    .qe     (key_29_flds_we[0]),
    .q      (reg2hw.key[29].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[29].qe = key_29_qe;


  // Subregister 30 of Multireg key
  // R[key_30]: V(True)
  logic key_30_qe;
  logic [0:0] key_30_flds_we;
  assign key_30_qe = &key_30_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_30 (
    .re     (1'b0),
    .we     (key_30_we),
    .wd     (key_30_wd),
    .d      (hw2reg.key[30].d),
    .qre    (),
    .qe     (key_30_flds_we[0]),
    .q      (reg2hw.key[30].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[30].qe = key_30_qe;


  // Subregister 31 of Multireg key
  // R[key_31]: V(True)
  logic key_31_qe;
  logic [0:0] key_31_flds_we;
  assign key_31_qe = &key_31_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_31 (
    .re     (1'b0),
    .we     (key_31_we),
    .wd     (key_31_wd),
    .d      (hw2reg.key[31].d),
    .qre    (),
    .qe     (key_31_flds_we[0]),
    .q      (reg2hw.key[31].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[31].qe = key_31_qe;


  // Subregister 0 of Multireg digest
  // R[digest_0]: V(True)
  logic digest_0_qe;
  logic [0:0] digest_0_flds_we;
  assign digest_0_qe = &digest_0_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_0 (
    .re     (digest_0_re),
    .we     (digest_0_we),
    .wd     (digest_0_wd),
    .d      (hw2reg.digest[0].d),
    .qre    (),
    .qe     (digest_0_flds_we[0]),
    .q      (reg2hw.digest[0].q),
    .ds     (),
    .qs     (digest_0_qs)
  );
  assign reg2hw.digest[0].qe = digest_0_qe;


  // Subregister 1 of Multireg digest
  // R[digest_1]: V(True)
  logic digest_1_qe;
  logic [0:0] digest_1_flds_we;
  assign digest_1_qe = &digest_1_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_1 (
    .re     (digest_1_re),
    .we     (digest_1_we),
    .wd     (digest_1_wd),
    .d      (hw2reg.digest[1].d),
    .qre    (),
    .qe     (digest_1_flds_we[0]),
    .q      (reg2hw.digest[1].q),
    .ds     (),
    .qs     (digest_1_qs)
  );
  assign reg2hw.digest[1].qe = digest_1_qe;


  // Subregister 2 of Multireg digest
  // R[digest_2]: V(True)
  logic digest_2_qe;
  logic [0:0] digest_2_flds_we;
  assign digest_2_qe = &digest_2_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_2 (
    .re     (digest_2_re),
    .we     (digest_2_we),
    .wd     (digest_2_wd),
    .d      (hw2reg.digest[2].d),
    .qre    (),
    .qe     (digest_2_flds_we[0]),
    .q      (reg2hw.digest[2].q),
    .ds     (),
    .qs     (digest_2_qs)
  );
  assign reg2hw.digest[2].qe = digest_2_qe;


  // Subregister 3 of Multireg digest
  // R[digest_3]: V(True)
  logic digest_3_qe;
  logic [0:0] digest_3_flds_we;
  assign digest_3_qe = &digest_3_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_3 (
    .re     (digest_3_re),
    .we     (digest_3_we),
    .wd     (digest_3_wd),
    .d      (hw2reg.digest[3].d),
    .qre    (),
    .qe     (digest_3_flds_we[0]),
    .q      (reg2hw.digest[3].q),
    .ds     (),
    .qs     (digest_3_qs)
  );
  assign reg2hw.digest[3].qe = digest_3_qe;


  // Subregister 4 of Multireg digest
  // R[digest_4]: V(True)
  logic digest_4_qe;
  logic [0:0] digest_4_flds_we;
  assign digest_4_qe = &digest_4_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_4 (
    .re     (digest_4_re),
    .we     (digest_4_we),
    .wd     (digest_4_wd),
    .d      (hw2reg.digest[4].d),
    .qre    (),
    .qe     (digest_4_flds_we[0]),
    .q      (reg2hw.digest[4].q),
    .ds     (),
    .qs     (digest_4_qs)
  );
  assign reg2hw.digest[4].qe = digest_4_qe;


  // Subregister 5 of Multireg digest
  // R[digest_5]: V(True)
  logic digest_5_qe;
  logic [0:0] digest_5_flds_we;
  assign digest_5_qe = &digest_5_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_5 (
    .re     (digest_5_re),
    .we     (digest_5_we),
    .wd     (digest_5_wd),
    .d      (hw2reg.digest[5].d),
    .qre    (),
    .qe     (digest_5_flds_we[0]),
    .q      (reg2hw.digest[5].q),
    .ds     (),
    .qs     (digest_5_qs)
  );
  assign reg2hw.digest[5].qe = digest_5_qe;


  // Subregister 6 of Multireg digest
  // R[digest_6]: V(True)
  logic digest_6_qe;
  logic [0:0] digest_6_flds_we;
  assign digest_6_qe = &digest_6_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_6 (
    .re     (digest_6_re),
    .we     (digest_6_we),
    .wd     (digest_6_wd),
    .d      (hw2reg.digest[6].d),
    .qre    (),
    .qe     (digest_6_flds_we[0]),
    .q      (reg2hw.digest[6].q),
    .ds     (),
    .qs     (digest_6_qs)
  );
  assign reg2hw.digest[6].qe = digest_6_qe;


  // Subregister 7 of Multireg digest
  // R[digest_7]: V(True)
  logic digest_7_qe;
  logic [0:0] digest_7_flds_we;
  assign digest_7_qe = &digest_7_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_7 (
    .re     (digest_7_re),
    .we     (digest_7_we),
    .wd     (digest_7_wd),
    .d      (hw2reg.digest[7].d),
    .qre    (),
    .qe     (digest_7_flds_we[0]),
    .q      (reg2hw.digest[7].q),
    .ds     (),
    .qs     (digest_7_qs)
  );
  assign reg2hw.digest[7].qe = digest_7_qe;


  // Subregister 8 of Multireg digest
  // R[digest_8]: V(True)
  logic digest_8_qe;
  logic [0:0] digest_8_flds_we;
  assign digest_8_qe = &digest_8_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_8 (
    .re     (digest_8_re),
    .we     (digest_8_we),
    .wd     (digest_8_wd),
    .d      (hw2reg.digest[8].d),
    .qre    (),
    .qe     (digest_8_flds_we[0]),
    .q      (reg2hw.digest[8].q),
    .ds     (),
    .qs     (digest_8_qs)
  );
  assign reg2hw.digest[8].qe = digest_8_qe;


  // Subregister 9 of Multireg digest
  // R[digest_9]: V(True)
  logic digest_9_qe;
  logic [0:0] digest_9_flds_we;
  assign digest_9_qe = &digest_9_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_9 (
    .re     (digest_9_re),
    .we     (digest_9_we),
    .wd     (digest_9_wd),
    .d      (hw2reg.digest[9].d),
    .qre    (),
    .qe     (digest_9_flds_we[0]),
    .q      (reg2hw.digest[9].q),
    .ds     (),
    .qs     (digest_9_qs)
  );
  assign reg2hw.digest[9].qe = digest_9_qe;


  // Subregister 10 of Multireg digest
  // R[digest_10]: V(True)
  logic digest_10_qe;
  logic [0:0] digest_10_flds_we;
  assign digest_10_qe = &digest_10_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_10 (
    .re     (digest_10_re),
    .we     (digest_10_we),
    .wd     (digest_10_wd),
    .d      (hw2reg.digest[10].d),
    .qre    (),
    .qe     (digest_10_flds_we[0]),
    .q      (reg2hw.digest[10].q),
    .ds     (),
    .qs     (digest_10_qs)
  );
  assign reg2hw.digest[10].qe = digest_10_qe;


  // Subregister 11 of Multireg digest
  // R[digest_11]: V(True)
  logic digest_11_qe;
  logic [0:0] digest_11_flds_we;
  assign digest_11_qe = &digest_11_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_11 (
    .re     (digest_11_re),
    .we     (digest_11_we),
    .wd     (digest_11_wd),
    .d      (hw2reg.digest[11].d),
    .qre    (),
    .qe     (digest_11_flds_we[0]),
    .q      (reg2hw.digest[11].q),
    .ds     (),
    .qs     (digest_11_qs)
  );
  assign reg2hw.digest[11].qe = digest_11_qe;


  // Subregister 12 of Multireg digest
  // R[digest_12]: V(True)
  logic digest_12_qe;
  logic [0:0] digest_12_flds_we;
  assign digest_12_qe = &digest_12_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_12 (
    .re     (digest_12_re),
    .we     (digest_12_we),
    .wd     (digest_12_wd),
    .d      (hw2reg.digest[12].d),
    .qre    (),
    .qe     (digest_12_flds_we[0]),
    .q      (reg2hw.digest[12].q),
    .ds     (),
    .qs     (digest_12_qs)
  );
  assign reg2hw.digest[12].qe = digest_12_qe;


  // Subregister 13 of Multireg digest
  // R[digest_13]: V(True)
  logic digest_13_qe;
  logic [0:0] digest_13_flds_we;
  assign digest_13_qe = &digest_13_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_13 (
    .re     (digest_13_re),
    .we     (digest_13_we),
    .wd     (digest_13_wd),
    .d      (hw2reg.digest[13].d),
    .qre    (),
    .qe     (digest_13_flds_we[0]),
    .q      (reg2hw.digest[13].q),
    .ds     (),
    .qs     (digest_13_qs)
  );
  assign reg2hw.digest[13].qe = digest_13_qe;


  // Subregister 14 of Multireg digest
  // R[digest_14]: V(True)
  logic digest_14_qe;
  logic [0:0] digest_14_flds_we;
  assign digest_14_qe = &digest_14_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_14 (
    .re     (digest_14_re),
    .we     (digest_14_we),
    .wd     (digest_14_wd),
    .d      (hw2reg.digest[14].d),
    .qre    (),
    .qe     (digest_14_flds_we[0]),
    .q      (reg2hw.digest[14].q),
    .ds     (),
    .qs     (digest_14_qs)
  );
  assign reg2hw.digest[14].qe = digest_14_qe;


  // Subregister 15 of Multireg digest
  // R[digest_15]: V(True)
  logic digest_15_qe;
  logic [0:0] digest_15_flds_we;
  assign digest_15_qe = &digest_15_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_15 (
    .re     (digest_15_re),
    .we     (digest_15_we),
    .wd     (digest_15_wd),
    .d      (hw2reg.digest[15].d),
    .qre    (),
    .qe     (digest_15_flds_we[0]),
    .q      (reg2hw.digest[15].q),
    .ds     (),
    .qs     (digest_15_qs)
  );
  assign reg2hw.digest[15].qe = digest_15_qe;


  // R[msg_length_lower]: V(True)
  logic msg_length_lower_qe;
  logic [0:0] msg_length_lower_flds_we;
  assign msg_length_lower_qe = &msg_length_lower_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_msg_length_lower (
    .re     (msg_length_lower_re),
    .we     (msg_length_lower_we),
    .wd     (msg_length_lower_wd),
    .d      (hw2reg.msg_length_lower.d),
    .qre    (),
    .qe     (msg_length_lower_flds_we[0]),
    .q      (reg2hw.msg_length_lower.q),
    .ds     (),
    .qs     (msg_length_lower_qs)
  );
  assign reg2hw.msg_length_lower.qe = msg_length_lower_qe;


  // R[msg_length_upper]: V(True)
  logic msg_length_upper_qe;
  logic [0:0] msg_length_upper_flds_we;
  assign msg_length_upper_qe = &msg_length_upper_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_msg_length_upper (
    .re     (msg_length_upper_re),
    .we     (msg_length_upper_we),
    .wd     (msg_length_upper_wd),
    .d      (hw2reg.msg_length_upper.d),
    .qre    (),
    .qe     (msg_length_upper_flds_we[0]),
    .q      (reg2hw.msg_length_upper.q),
    .ds     (),
    .qs     (msg_length_upper_qs)
  );
  assign reg2hw.msg_length_upper.qe = msg_length_upper_qe;



  logic [58:0] addr_hit;
  always_comb begin
    addr_hit = '0;
    addr_hit[ 0] = (reg_addr == HMAC_INTR_STATE_OFFSET);
    addr_hit[ 1] = (reg_addr == HMAC_INTR_ENABLE_OFFSET);
    addr_hit[ 2] = (reg_addr == HMAC_INTR_TEST_OFFSET);
    addr_hit[ 3] = (reg_addr == HMAC_ALERT_TEST_OFFSET);
    addr_hit[ 4] = (reg_addr == HMAC_CFG_OFFSET);
    addr_hit[ 5] = (reg_addr == HMAC_CMD_OFFSET);
    addr_hit[ 6] = (reg_addr == HMAC_STATUS_OFFSET);
    addr_hit[ 7] = (reg_addr == HMAC_ERR_CODE_OFFSET);
    addr_hit[ 8] = (reg_addr == HMAC_WIPE_SECRET_OFFSET);
    addr_hit[ 9] = (reg_addr == HMAC_KEY_0_OFFSET);
    addr_hit[10] = (reg_addr == HMAC_KEY_1_OFFSET);
    addr_hit[11] = (reg_addr == HMAC_KEY_2_OFFSET);
    addr_hit[12] = (reg_addr == HMAC_KEY_3_OFFSET);
    addr_hit[13] = (reg_addr == HMAC_KEY_4_OFFSET);
    addr_hit[14] = (reg_addr == HMAC_KEY_5_OFFSET);
    addr_hit[15] = (reg_addr == HMAC_KEY_6_OFFSET);
    addr_hit[16] = (reg_addr == HMAC_KEY_7_OFFSET);
    addr_hit[17] = (reg_addr == HMAC_KEY_8_OFFSET);
    addr_hit[18] = (reg_addr == HMAC_KEY_9_OFFSET);
    addr_hit[19] = (reg_addr == HMAC_KEY_10_OFFSET);
    addr_hit[20] = (reg_addr == HMAC_KEY_11_OFFSET);
    addr_hit[21] = (reg_addr == HMAC_KEY_12_OFFSET);
    addr_hit[22] = (reg_addr == HMAC_KEY_13_OFFSET);
    addr_hit[23] = (reg_addr == HMAC_KEY_14_OFFSET);
    addr_hit[24] = (reg_addr == HMAC_KEY_15_OFFSET);
    addr_hit[25] = (reg_addr == HMAC_KEY_16_OFFSET);
    addr_hit[26] = (reg_addr == HMAC_KEY_17_OFFSET);
    addr_hit[27] = (reg_addr == HMAC_KEY_18_OFFSET);
    addr_hit[28] = (reg_addr == HMAC_KEY_19_OFFSET);
    addr_hit[29] = (reg_addr == HMAC_KEY_20_OFFSET);
    addr_hit[30] = (reg_addr == HMAC_KEY_21_OFFSET);
    addr_hit[31] = (reg_addr == HMAC_KEY_22_OFFSET);
    addr_hit[32] = (reg_addr == HMAC_KEY_23_OFFSET);
    addr_hit[33] = (reg_addr == HMAC_KEY_24_OFFSET);
    addr_hit[34] = (reg_addr == HMAC_KEY_25_OFFSET);
    addr_hit[35] = (reg_addr == HMAC_KEY_26_OFFSET);
    addr_hit[36] = (reg_addr == HMAC_KEY_27_OFFSET);
    addr_hit[37] = (reg_addr == HMAC_KEY_28_OFFSET);
    addr_hit[38] = (reg_addr == HMAC_KEY_29_OFFSET);
    addr_hit[39] = (reg_addr == HMAC_KEY_30_OFFSET);
    addr_hit[40] = (reg_addr == HMAC_KEY_31_OFFSET);
    addr_hit[41] = (reg_addr == HMAC_DIGEST_0_OFFSET);
    addr_hit[42] = (reg_addr == HMAC_DIGEST_1_OFFSET);
    addr_hit[43] = (reg_addr == HMAC_DIGEST_2_OFFSET);
    addr_hit[44] = (reg_addr == HMAC_DIGEST_3_OFFSET);
    addr_hit[45] = (reg_addr == HMAC_DIGEST_4_OFFSET);
    addr_hit[46] = (reg_addr == HMAC_DIGEST_5_OFFSET);
    addr_hit[47] = (reg_addr == HMAC_DIGEST_6_OFFSET);
    addr_hit[48] = (reg_addr == HMAC_DIGEST_7_OFFSET);
    addr_hit[49] = (reg_addr == HMAC_DIGEST_8_OFFSET);
    addr_hit[50] = (reg_addr == HMAC_DIGEST_9_OFFSET);
    addr_hit[51] = (reg_addr == HMAC_DIGEST_10_OFFSET);
    addr_hit[52] = (reg_addr == HMAC_DIGEST_11_OFFSET);
    addr_hit[53] = (reg_addr == HMAC_DIGEST_12_OFFSET);
    addr_hit[54] = (reg_addr == HMAC_DIGEST_13_OFFSET);
    addr_hit[55] = (reg_addr == HMAC_DIGEST_14_OFFSET);
    addr_hit[56] = (reg_addr == HMAC_DIGEST_15_OFFSET);
    addr_hit[57] = (reg_addr == HMAC_MSG_LENGTH_LOWER_OFFSET);
    addr_hit[58] = (reg_addr == HMAC_MSG_LENGTH_UPPER_OFFSET);
  end

  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;

  // Check sub-word write is permitted
  always_comb begin
    wr_err = (reg_we &
              ((addr_hit[ 0] & (|(HMAC_PERMIT[ 0] & ~reg_be))) |
               (addr_hit[ 1] & (|(HMAC_PERMIT[ 1] & ~reg_be))) |
               (addr_hit[ 2] & (|(HMAC_PERMIT[ 2] & ~reg_be))) |
               (addr_hit[ 3] & (|(HMAC_PERMIT[ 3] & ~reg_be))) |
               (addr_hit[ 4] & (|(HMAC_PERMIT[ 4] & ~reg_be))) |
               (addr_hit[ 5] & (|(HMAC_PERMIT[ 5] & ~reg_be))) |
               (addr_hit[ 6] & (|(HMAC_PERMIT[ 6] & ~reg_be))) |
               (addr_hit[ 7] & (|(HMAC_PERMIT[ 7] & ~reg_be))) |
               (addr_hit[ 8] & (|(HMAC_PERMIT[ 8] & ~reg_be))) |
               (addr_hit[ 9] & (|(HMAC_PERMIT[ 9] & ~reg_be))) |
               (addr_hit[10] & (|(HMAC_PERMIT[10] & ~reg_be))) |
               (addr_hit[11] & (|(HMAC_PERMIT[11] & ~reg_be))) |
               (addr_hit[12] & (|(HMAC_PERMIT[12] & ~reg_be))) |
               (addr_hit[13] & (|(HMAC_PERMIT[13] & ~reg_be))) |
               (addr_hit[14] & (|(HMAC_PERMIT[14] & ~reg_be))) |
               (addr_hit[15] & (|(HMAC_PERMIT[15] & ~reg_be))) |
               (addr_hit[16] & (|(HMAC_PERMIT[16] & ~reg_be))) |
               (addr_hit[17] & (|(HMAC_PERMIT[17] & ~reg_be))) |
               (addr_hit[18] & (|(HMAC_PERMIT[18] & ~reg_be))) |
               (addr_hit[19] & (|(HMAC_PERMIT[19] & ~reg_be))) |
               (addr_hit[20] & (|(HMAC_PERMIT[20] & ~reg_be))) |
               (addr_hit[21] & (|(HMAC_PERMIT[21] & ~reg_be))) |
               (addr_hit[22] & (|(HMAC_PERMIT[22] & ~reg_be))) |
               (addr_hit[23] & (|(HMAC_PERMIT[23] & ~reg_be))) |
               (addr_hit[24] & (|(HMAC_PERMIT[24] & ~reg_be))) |
               (addr_hit[25] & (|(HMAC_PERMIT[25] & ~reg_be))) |
               (addr_hit[26] & (|(HMAC_PERMIT[26] & ~reg_be))) |
               (addr_hit[27] & (|(HMAC_PERMIT[27] & ~reg_be))) |
               (addr_hit[28] & (|(HMAC_PERMIT[28] & ~reg_be))) |
               (addr_hit[29] & (|(HMAC_PERMIT[29] & ~reg_be))) |
               (addr_hit[30] & (|(HMAC_PERMIT[30] & ~reg_be))) |
               (addr_hit[31] & (|(HMAC_PERMIT[31] & ~reg_be))) |
               (addr_hit[32] & (|(HMAC_PERMIT[32] & ~reg_be))) |
               (addr_hit[33] & (|(HMAC_PERMIT[33] & ~reg_be))) |
               (addr_hit[34] & (|(HMAC_PERMIT[34] & ~reg_be))) |
               (addr_hit[35] & (|(HMAC_PERMIT[35] & ~reg_be))) |
               (addr_hit[36] & (|(HMAC_PERMIT[36] & ~reg_be))) |
               (addr_hit[37] & (|(HMAC_PERMIT[37] & ~reg_be))) |
               (addr_hit[38] & (|(HMAC_PERMIT[38] & ~reg_be))) |
               (addr_hit[39] & (|(HMAC_PERMIT[39] & ~reg_be))) |
               (addr_hit[40] & (|(HMAC_PERMIT[40] & ~reg_be))) |
               (addr_hit[41] & (|(HMAC_PERMIT[41] & ~reg_be))) |
               (addr_hit[42] & (|(HMAC_PERMIT[42] & ~reg_be))) |
               (addr_hit[43] & (|(HMAC_PERMIT[43] & ~reg_be))) |
               (addr_hit[44] & (|(HMAC_PERMIT[44] & ~reg_be))) |
               (addr_hit[45] & (|(HMAC_PERMIT[45] & ~reg_be))) |
               (addr_hit[46] & (|(HMAC_PERMIT[46] & ~reg_be))) |
               (addr_hit[47] & (|(HMAC_PERMIT[47] & ~reg_be))) |
               (addr_hit[48] & (|(HMAC_PERMIT[48] & ~reg_be))) |
               (addr_hit[49] & (|(HMAC_PERMIT[49] & ~reg_be))) |
               (addr_hit[50] & (|(HMAC_PERMIT[50] & ~reg_be))) |
               (addr_hit[51] & (|(HMAC_PERMIT[51] & ~reg_be))) |
               (addr_hit[52] & (|(HMAC_PERMIT[52] & ~reg_be))) |
               (addr_hit[53] & (|(HMAC_PERMIT[53] & ~reg_be))) |
               (addr_hit[54] & (|(HMAC_PERMIT[54] & ~reg_be))) |
               (addr_hit[55] & (|(HMAC_PERMIT[55] & ~reg_be))) |
               (addr_hit[56] & (|(HMAC_PERMIT[56] & ~reg_be))) |
               (addr_hit[57] & (|(HMAC_PERMIT[57] & ~reg_be))) |
               (addr_hit[58] & (|(HMAC_PERMIT[58] & ~reg_be)))));
  end

  // Generate write-enables
  assign intr_state_we = addr_hit[0] & reg_we & !reg_error;

  assign intr_state_hmac_done_wd = reg_wdata[0];

  assign intr_state_hmac_err_wd = reg_wdata[2];
  assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;

  assign intr_enable_hmac_done_wd = reg_wdata[0];

  assign intr_enable_fifo_empty_wd = reg_wdata[1];

  assign intr_enable_hmac_err_wd = reg_wdata[2];
  assign intr_test_we = addr_hit[2] & reg_we & !reg_error;

  assign intr_test_hmac_done_wd = reg_wdata[0];

  assign intr_test_fifo_empty_wd = reg_wdata[1];

  assign intr_test_hmac_err_wd = reg_wdata[2];
  assign alert_test_we = addr_hit[3] & reg_we & !reg_error;

  assign alert_test_wd = reg_wdata[0];
  assign cfg_re = addr_hit[4] & reg_re & !reg_error;
  assign cfg_we = addr_hit[4] & reg_we & !reg_error;

  assign cfg_hmac_en_wd = reg_wdata[0];

  assign cfg_sha_en_wd = reg_wdata[1];

  assign cfg_endian_swap_wd = reg_wdata[2];

  assign cfg_digest_swap_wd = reg_wdata[3];

  assign cfg_key_swap_wd = reg_wdata[4];

  assign cfg_digest_size_wd = reg_wdata[8:5];

  assign cfg_key_length_wd = reg_wdata[14:9];
  assign cmd_we = addr_hit[5] & reg_we & !reg_error;

  assign cmd_hash_start_wd = reg_wdata[0];

  assign cmd_hash_process_wd = reg_wdata[1];

  assign cmd_hash_stop_wd = reg_wdata[2];

  assign cmd_hash_continue_wd = reg_wdata[3];
  assign status_re = addr_hit[6] & reg_re & !reg_error;
  assign wipe_secret_we = addr_hit[8] & reg_we & reg_error;

  assign wipe_secret_wd = reg_wdata[31:0];
  assign key_0_we = addr_hit[9] & reg_we & !reg_error;

  assign key_0_wd = reg_wdata[31:0];
  assign key_1_we = addr_hit[10] & reg_we & !reg_error;

  assign key_1_wd = reg_wdata[31:0];
  assign key_2_we = addr_hit[11] & reg_we & !reg_error;

  assign key_2_wd = reg_wdata[31:0];
  assign key_3_we = addr_hit[12] & reg_we & !reg_error;

  assign key_3_wd = reg_wdata[31:0];
  assign key_4_we = addr_hit[13] & reg_we & !reg_error;

  assign key_4_wd = reg_wdata[31:0];
  assign key_5_we = addr_hit[14] & reg_we & !reg_error;

  assign key_5_wd = reg_wdata[31:0];
  assign key_6_we = addr_hit[15] & reg_we & !reg_error;

  assign key_6_wd = reg_wdata[31:0];
  assign key_7_we = addr_hit[16] & reg_we & !reg_error;

  assign key_7_wd = reg_wdata[31:0];
  assign key_8_we = addr_hit[17] & reg_we & !reg_error;

  assign key_8_wd = reg_wdata[31:0];
  assign key_9_we = addr_hit[18] & reg_we & !reg_error;

  assign key_9_wd = reg_wdata[31:0];
  assign key_10_we = addr_hit[19] & reg_we & !reg_error;

  assign key_10_wd = reg_wdata[31:0];
  assign key_11_we = addr_hit[20] & reg_we & !reg_error;

  assign key_11_wd = reg_wdata[31:0];
  assign key_12_we = addr_hit[21] & reg_we & !reg_error;

  assign key_12_wd = reg_wdata[31:0];
  assign key_13_we = addr_hit[22] & reg_we & !reg_error;

  assign key_13_wd = reg_wdata[31:0];
  assign key_14_we = addr_hit[23] & reg_we & !reg_error;

  assign key_14_wd = reg_wdata[31:0];
  assign key_15_we = addr_hit[24] & reg_we & !reg_error;

  assign key_15_wd = reg_wdata[31:0];
  assign key_16_we = addr_hit[25] & reg_we & !reg_error;

  assign key_16_wd = reg_wdata[31:0];
  assign key_17_we = addr_hit[26] & reg_we & !reg_error;

  assign key_17_wd = reg_wdata[31:0];
  assign key_18_we = addr_hit[27] & reg_we & !reg_error;

  assign key_18_wd = reg_wdata[31:0];
  assign key_19_we = addr_hit[28] & reg_we & !reg_error;

  assign key_19_wd = reg_wdata[31:0];
  assign key_20_we = addr_hit[29] & reg_we & !reg_error;

  assign key_20_wd = reg_wdata[31:0];
  assign key_21_we = addr_hit[30] & reg_we & !reg_error;

  assign key_21_wd = reg_wdata[31:0];
  assign key_22_we = addr_hit[31] & reg_we & !reg_error;

  assign key_22_wd = reg_wdata[31:0];
  assign key_23_we = addr_hit[32] & reg_we & !reg_error;

  assign key_23_wd = reg_wdata[31:0];
  assign key_24_we = addr_hit[33] & reg_we & !reg_error;

  assign key_24_wd = reg_wdata[31:0];
  assign key_25_we = addr_hit[34] & reg_we & !reg_error;

  assign key_25_wd = reg_wdata[31:0];
  assign key_26_we = addr_hit[35] & reg_we & !reg_error;

  assign key_26_wd = reg_wdata[31:0];
  assign key_27_we = addr_hit[36] & reg_we & !reg_error;

  assign key_27_wd = reg_wdata[31:0];
  assign key_28_we = addr_hit[37] & reg_we & !reg_error;

  assign key_28_wd = reg_wdata[31:0];
  assign key_29_we = addr_hit[38] & reg_we & !reg_error;

  assign key_29_wd = reg_wdata[31:0];
  assign key_30_we = addr_hit[39] & reg_we & !reg_error;

  assign key_30_wd = reg_wdata[31:0];
  assign key_31_we = addr_hit[40] & reg_we & !reg_error;

  assign key_31_wd = reg_wdata[31:0];
  assign digest_0_re = addr_hit[41] & reg_re & !reg_error;
  assign digest_0_we = addr_hit[41] & reg_we & !reg_error;

  assign digest_0_wd = reg_wdata[31:0];
  assign digest_1_re = addr_hit[42] & reg_re & !reg_error;
  assign digest_1_we = addr_hit[42] & reg_we & !reg_error;

  assign digest_1_wd = reg_wdata[31:0];
  assign digest_2_re = addr_hit[43] & reg_re & !reg_error;
  assign digest_2_we = addr_hit[43] & reg_we & !reg_error;

  assign digest_2_wd = reg_wdata[31:0];
  assign digest_3_re = addr_hit[44] & reg_re & !reg_error;
  assign digest_3_we = addr_hit[44] & reg_we & !reg_error;

  assign digest_3_wd = reg_wdata[31:0];
  assign digest_4_re = addr_hit[45] & reg_re & !reg_error;
  assign digest_4_we = addr_hit[45] & reg_we & !reg_error;

  assign digest_4_wd = reg_wdata[31:0];
  assign digest_5_re = addr_hit[46] & reg_re & !reg_error;
  assign digest_5_we = addr_hit[46] & reg_we & !reg_error;

  assign digest_5_wd = reg_wdata[31:0];
  assign digest_6_re = addr_hit[47] & reg_re & !reg_error;
  assign digest_6_we = addr_hit[47] & reg_we & !reg_error;

  assign digest_6_wd = reg_wdata[31:0];
  assign digest_7_re = addr_hit[48] & reg_re & !reg_error;
  assign digest_7_we = addr_hit[48] & reg_we & !reg_error;

  assign digest_7_wd = reg_wdata[31:0];
  assign digest_8_re = addr_hit[49] & reg_re & !reg_error;
  assign digest_8_we = addr_hit[49] & reg_we & !reg_error;

  assign digest_8_wd = reg_wdata[31:0];
  assign digest_9_re = addr_hit[50] & reg_re & !reg_error;
  assign digest_9_we = addr_hit[50] & reg_we & !reg_error;

  assign digest_9_wd = reg_wdata[31:0];
  assign digest_10_re = addr_hit[51] & reg_re & !reg_error;
  assign digest_10_we = addr_hit[51] & reg_we & !reg_error;

  assign digest_10_wd = reg_wdata[31:0];
  assign digest_11_re = addr_hit[52] & reg_re & !reg_error;
  assign digest_11_we = addr_hit[52] & reg_we & !reg_error;

  assign digest_11_wd = reg_wdata[31:0];
  assign digest_12_re = addr_hit[53] & reg_re & !reg_error;
  assign digest_12_we = addr_hit[53] & reg_we & !reg_error;

  assign digest_12_wd = reg_wdata[31:0];
  assign digest_13_re = addr_hit[54] & reg_re & !reg_error;
  assign digest_13_we = addr_hit[54] & reg_we & !reg_error;

  assign digest_13_wd = reg_wdata[31:0];
  assign digest_14_re = addr_hit[55] & reg_re & !reg_error;
  assign digest_14_we = addr_hit[55] & reg_we & !reg_error;

  assign digest_14_wd = reg_wdata[31:0];
  assign digest_15_re = addr_hit[56] & reg_re & !reg_error;
  assign digest_15_we = addr_hit[56] & reg_we & !reg_error;

  assign digest_15_wd = reg_wdata[31:0];
  assign msg_length_lower_re = addr_hit[57] & reg_re & !reg_error;
  assign msg_length_lower_we = addr_hit[57] & reg_we & !reg_error;

  assign msg_length_lower_wd = reg_wdata[31:0];
  assign msg_length_upper_re = addr_hit[58] & reg_re & !reg_error;
  assign msg_length_upper_we = addr_hit[58] & reg_we & !reg_error;

  assign msg_length_upper_wd = reg_wdata[31:0];

  // Assign write-enables to checker logic vector.
  always_comb begin
    reg_we_check = '0;
    reg_we_check[0] = intr_state_we;
    reg_we_check[1] = intr_enable_we;
    reg_we_check[2] = intr_test_we;
    reg_we_check[3] = alert_test_we;
    reg_we_check[4] = cfg_we;
    reg_we_check[5] = cmd_we;
    reg_we_check[6] = 1'b0;
    reg_we_check[7] = 1'b0;
    reg_we_check[8] = wipe_secret_we;
    reg_we_check[9] = key_0_we;
    reg_we_check[10] = key_1_we;
    reg_we_check[11] = key_2_we;
    reg_we_check[12] = key_3_we;
    reg_we_check[13] = key_4_we;
    reg_we_check[14] = key_5_we;
    reg_we_check[15] = key_6_we;
    reg_we_check[16] = key_7_we;
    reg_we_check[17] = key_8_we;
    reg_we_check[18] = key_9_we;
    reg_we_check[19] = key_10_we;
    reg_we_check[20] = key_11_we;
    reg_we_check[21] = key_12_we;
    reg_we_check[22] = key_13_we;
    reg_we_check[23] = key_14_we;
    reg_we_check[24] = key_15_we;
    reg_we_check[25] = key_16_we;
    reg_we_check[26] = key_17_we;
    reg_we_check[27] = key_18_we;
    reg_we_check[28] = key_19_we;
    reg_we_check[29] = key_20_we;
    reg_we_check[30] = key_21_we;
    reg_we_check[31] = key_22_we;
    reg_we_check[32] = key_23_we;
    reg_we_check[33] = key_24_we;
    reg_we_check[34] = key_25_we;
    reg_we_check[35] = key_26_we;
    reg_we_check[36] = key_27_we;
    reg_we_check[37] = key_28_we;
    reg_we_check[38] = key_29_we;
    reg_we_check[39] = key_30_we;
    reg_we_check[40] = key_31_we;
    reg_we_check[41] = digest_0_we;
    reg_we_check[42] = digest_1_we;
    reg_we_check[43] = digest_2_we;
    reg_we_check[44] = digest_3_we;
    reg_we_check[45] = digest_4_we;
    reg_we_check[46] = digest_5_we;
    reg_we_check[47] = digest_6_we;
    reg_we_check[48] = digest_7_we;
    reg_we_check[49] = digest_8_we;
    reg_we_check[50] = digest_9_we;
    reg_we_check[51] = digest_10_we;
    reg_we_check[52] = digest_11_we;
    reg_we_check[53] = digest_12_we;
    reg_we_check[54] = digest_13_we;
    reg_we_check[55] = digest_14_we;
    reg_we_check[56] = digest_15_we;
    reg_we_check[57] = msg_length_lower_we;
    reg_we_check[58] = msg_length_upper_we;
  end

  // Read data return
  always_comb begin
    reg_rdata_next = '0;
    unique case (1'b1)
      addr_hit[0]: begin
        reg_rdata_next[0] = intr_state_hmac_done_qs;
        reg_rdata_next[1] = intr_state_fifo_empty_qs;
        reg_rdata_next[2] = intr_state_hmac_err_qs;
      end

      addr_hit[1]: begin
        reg_rdata_next[0] = intr_enable_hmac_done_qs;
        reg_rdata_next[1] = intr_enable_fifo_empty_qs;
        reg_rdata_next[2] = intr_enable_hmac_err_qs;
      end

      addr_hit[2]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
        reg_rdata_next[2] = '0;
      end

      addr_hit[3]: begin
        reg_rdata_next[0] = '0;
      end

      addr_hit[4]: begin
        reg_rdata_next[0] = cfg_hmac_en_qs;
        reg_rdata_next[1] = cfg_sha_en_qs;
        reg_rdata_next[2] = cfg_endian_swap_qs;
        reg_rdata_next[3] = cfg_digest_swap_qs;
        reg_rdata_next[4] = cfg_key_swap_qs;
        reg_rdata_next[8:5] = cfg_digest_size_qs;
        reg_rdata_next[14:9] = cfg_key_length_qs;
      end

      addr_hit[5]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
        reg_rdata_next[2] = '0;
        reg_rdata_next[3] = '0;
      end

      addr_hit[6]: begin
        reg_rdata_next[0] = status_hmac_idle_qs;
        reg_rdata_next[1] = status_fifo_empty_qs;
        reg_rdata_next[2] = status_fifo_full_qs;
        reg_rdata_next[9:4] = status_fifo_depth_qs;
      end

      addr_hit[7]: begin
        reg_rdata_next[31:0] = err_code_qs;
      end

      addr_hit[8]: begin
        reg_rdata_next[31:0] = reg2hw.key[0].q;
      end

      addr_hit[9]: begin
        reg_rdata_next[31:0] = reg2hw.key[1].q;
      end

      addr_hit[10]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[11]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[12]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[13]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[14]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[15]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[16]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[17]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[18]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[19]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[20]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[21]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[22]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[23]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[24]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[25]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[26]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[27]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[28]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[29]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[30]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[31]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[32]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[33]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[34]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[35]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[36]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[37]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[38]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[39]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[40]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[41]: begin
        reg_rdata_next[31:0] = digest_0_qs;
      end

      addr_hit[42]: begin
        reg_rdata_next[31:0] = digest_1_qs;
      end

      addr_hit[43]: begin
        reg_rdata_next[31:0] = digest_2_qs;
      end

      addr_hit[44]: begin
        reg_rdata_next[31:0] = digest_3_qs;
      end

      addr_hit[45]: begin
        reg_rdata_next[31:0] = digest_4_qs;
      end

      addr_hit[46]: begin
        reg_rdata_next[31:0] = digest_5_qs;
      end

      addr_hit[47]: begin
        reg_rdata_next[31:0] = digest_6_qs;
      end

      addr_hit[48]: begin
        reg_rdata_next[31:0] = digest_7_qs;
      end

      addr_hit[49]: begin
        reg_rdata_next[31:0] = digest_8_qs;
      end

      addr_hit[50]: begin
        reg_rdata_next[31:0] = digest_9_qs;
      end

      addr_hit[51]: begin
        reg_rdata_next[31:0] = digest_10_qs;
      end

      addr_hit[52]: begin
        reg_rdata_next[31:0] = digest_11_qs;
      end

      addr_hit[53]: begin
        reg_rdata_next[31:0] = digest_12_qs;
      end

      addr_hit[54]: begin
        reg_rdata_next[31:0] = digest_13_qs;
      end

      addr_hit[55]: begin
        reg_rdata_next[31:0] = digest_14_qs;
      end

      addr_hit[56]: begin
        reg_rdata_next[31:0] = digest_15_qs;
      end

      addr_hit[57]: begin
        reg_rdata_next[31:0] = msg_length_lower_qs;
      end

      addr_hit[58]: begin
        reg_rdata_next[31:0] = msg_length_upper_qs;
      end

      default: begin
        reg_rdata_next = reg2hw.key[2].q;
      end
    endcase
  end

  // shadow busy
  logic shadow_busy;
  assign shadow_busy = 1'b0;

  // register busy
  assign reg_busy = shadow_busy;

  // Unused signal tieoff

  // wdata / byte enable are not always fully used
  // add a blanket unused statement to handle lint waivers
  logic unused_wdata;
  logic unused_be;
  assign unused_wdata = ^reg_wdata;
  assign unused_be = ^reg_be;

  // Assertions for Register Interface
  `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
  `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)

  `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)

  `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)

  // this is formulated as an assumption such that the FPV testbenches do disprove this
  // property by mistake
  //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)

endmodule


    """


    Identify the CWE relevant to the security issue for the given RTL.
    Obtain details of the CWE.

    Then determine if there are security issues relevant to the identified CWE in the RTL.
    Refer to the code that corresponds to the issues identified.
    
================================== Ai Message ==================================

[{'text': "I'll analyze the provided RTL code to identify any security concerns related to register access control and privilege enforcement.", 'type': 'text'}, {'id': 'toolu_01WsRaeJngtte4kS8bywZC3v', 'input': {'security_issue': 'register access control privilege enforcement hardware'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01WsRaeJngtte4kS8bywZC3v)
 Call ID: toolu_01WsRaeJngtte4kS8bywZC3v
  Args:
    security_issue: register access control privilege enforcement hardware
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1268: Policy Privileges are not Assigned Consistently Between Control and Data Agents
The product's hardware-enforced access control for a particular resource improperly accounts for privilege discrepancies between control and write policies.
Integrated circuits and hardware engines may provide access to resources (device-configuration, encryption keys, etc.) belonging to trusted firmware or software modules (commonly set by a BIOS or a bootloader). These accesses are typically controlled and limited by the hardware. Hardware design access control is sometimes implemented using a policy. A policy defines which entity or agent may or may not be allowed to perform an action. When a system implements multiple levels of policies, a control policy may allow direct access to a resource as well as changes to the policies themselves.
Example 1
Consider a system of seven registers for storing and configuring an AES key for encryption or decryption. Four 32-bit registers are used to store a 128-bit AES key. The names of those registers are AES_ENC_DEC_KEY_0, AES_ENC_DEC_KEY_1, AES_ENC_DEC_KEY_2, and AES_ENC_DEC_KEY_3. Collectively these are referred to as the AES Key registers. RegisterField description AES_ENC_DEC_KEY_0AES key [0:31] for encryption or decryption Default 0x00000000 AES_ENC_DEC_KEY_1AES key [32:63] for encryption or decryption Default 0x00000000 AES_ENC_DEC_KEY_2AES key [64:95] for encryption or decryption Default 0x00000000 AES_ENC_DEC_KEY_3AES key [96:127] for encryption or decryption Default 0x00000000 Three 32-bit registers are used to define access control for the AES-key registers. The names of those registers are AES_KEY_CONTROL_POLICY, AES_KEY_READ_POLICY, and AES_KEY_WRITE_POLICY. Collectively these registers are referred to as the Policy registers, and their functions are explained next. The AES_KEY_CONTROL_POLICY register defines which agents can write to the AES_KEY_READ_POLICY or AES_KEY_WRITE_POLICY registers. The AES_KEY_READ_POLICY register defines which agents can read the AES-key registers. The AES_KEY_WRITE_POLICY register defines which agents can write the AES key registers. The preceding three policy registers encode access control at the bit level. Therefore a maximum of 32 agents can be defined (1 bit per agent). The value of the bit when set (i.e., "1") allows the respective action from an agent whose identity corresponds to the number of the bit. If clear (i.e., "0"), it disallows the respective action to that corresponding agent. For example, if bit 0 is set to "1" in the AES_KEY_READ_POLICY register, then agent 0 has permission to read the AES-key registers. Consider that there are 4 agents named Agent 1, Agent 2, Agent 3, and Agent 4. For access control purposes Agent 1 is assigned to bit 1, Agent 2 to bit 2, Agent 3 to bit 3, and Agent 4 to bit 4. All agents are trusted except for Agent 3 who is untrusted. Also consider the register values in the below table.
(bad code)
RegisterField description AES_KEY_CONTROL_POLICYControls which agents can write to READ_POLICY and WRITE_POLICY registers [31:0] Default 0x00000018 AES_KEY_READ_POLICYControls which agents can read the AES-key registers [31:0] Default 0x00000002 AES_KEY_WRITE_POLICYControls which agents can write to the AES-key registers [31:0] Default 0x00000004
IThe AES_KEY_CONTROL_POLICY register value is 0x00000018. In binary, the lower 8 bits will be 0001 1000, meaning that: Bits 3 and 4 are set, thus Agents 3 and 4 will have write access to AES_KEY_READ_POLICY or AES_KEY_WRITE_POLICY. All other bits are clear, hence agents other than 3 and 4 will not have access to write to AES_KEY_READ_POLICY or AES_KEY_WRITE_POLICY. The AES_KEY_READ_POLICY register value is 0x00000002. In binary, the lower 8 bits will be 0000 0010, meaning that: Bit 1 is set, thus Agent 1 will be able to read the AES key registers. The AES_KEY_WRITE_POLICY register value is 0x00000004. In binary, the lower 8 bits will be 0000 0100, meaning that: Bit 2 is set, thus Agent 2 will be able to write the AES Key registers. The configured access control policy for Agents 1,2,3,4 is summarized in table below. AgentReadWriteControl Agent 1AllowedNot AllowedNot Allowed Agent 2Not AllowedAllowedNot Allowed Agent 3Not AllowedNot AllowedAllowed Agent 4Not AllowedNot AllowedAllowed At this point Agents 3 and 4 can only configure which agents can read AES keys and which agents can write AES keys. Agents 3 and 4 cannot read or write AES keys - just configure access control. Now, recall Agent 3 is untrusted. As explained above, the value of the AES_KEY_CONTROL_POLICY register gives agent 3 access to write to the AES_KEY_WRITE_POLICY register. Agent 3 can use this write access to add themselves to the AES_KEY_WRITE_POLICY register. This is accomplished by Agent 3 writing the value 0x00000006. In binary, the lower 8 bits are 0000 0110, meaning that bit 3 will be set. Thus, giving Agent 3 having the ability to write to the AES Key registers. If the AES_KEY_CONTROL_POLICY register value is 0x00000010, the lower 8 bits will be 0001 0000. This will give Agent 4, a trusted agent, write access to AES_KEY_WRITE_POLICY, but Agent 3, who is untrusted, will not have write access. The Policy register values should therefore be as follows:
(good code)
RegisterField description AES_KEY_CONTROL_POLICY[31:0] Default 0x00000010 AES_KEY_READ_POLICY[31:0] Default 0x00000002 AES_KEY_WRITE_POLICY[31:0] Default 0x00000004


================================== Ai Message ==================================

[{'id': 'toolu_018z89YFB3LDSoLhSsZyzgmd', 'input': {'security_issue': 'improper access control in hardware registers'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_018z89YFB3LDSoLhSsZyzgmd)
 Call ID: toolu_018z89YFB3LDSoLhSsZyzgmd
  Args:
    security_issue: improper access control in hardware registers
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1262: Improper Access Control for Register Interface
The product uses memory-mapped I/O registers that act as an interface to hardware functionality from software, but there is improper access control to those registers.
Software commonly accesses peripherals in a System-on-Chip (SoC) or other device through a memory-mapped register interface. Malicious software could tamper with any security-critical hardware data that is accessible directly or indirectly through the register interface, which could lead to a loss of confidentiality and integrity.
Example 1
The register interface provides software access to hardware functionality. This functionality is an attack surface. This attack surface may be used to run untrusted code on the system through the register interface. As an example, cryptographic accelerators require a mechanism for software to select modes of operation and to provide plaintext or ciphertext data to be encrypted or decrypted as well as other functions. This functionality is commonly provided through registers.
(bad code)
Cryptographic key material stored in registers inside the cryptographic accelerator can be accessed by software.
(good code)
Key material stored in registers should never be accessible to software. Even if software can provide a key, all read-back paths to software should be disabled.

Example 2
The example code is taken from the Control/Status Register (CSR) module inside the processor core of the HACK@DAC'19 buggy CVA6 SoC. In RISC-V ISA, the CSR file contains different sets of registers with different privilege levels, e.g., user mode (U), supervisor mode (S), hypervisor mode (H), machine mode (M), and debug mode (D), with different read-write policies, read-only (RO) and read-write (RW). For example, machine mode, which is the highest privilege mode in a RISC-V system, registers should not be accessible in user, supervisor, or hypervisor modes.
(bad code)
Example Language: Verilog
if (csr_we || csr_read) begin
if ((riscv::priv_lvl_t'(priv_lvl_o & csr_addr.csr_decode.priv_lvl) != csr_addr.csr_decode.priv_lvl) && !(csr_addr.address==riscv::CSR_MEPC)) begin
csr_exception_o.cause = riscv::ILLEGAL_INSTR;
csr_exception_o.valid = 1'b1;
end
// check access to debug mode only CSRs
if (csr_addr_i[11:4] == 8'h7b && !debug_mode_q) begin
csr_exception_o.cause = riscv::ILLEGAL_INSTR;
csr_exception_o.valid = 1'b1;
end
end
The vulnerable example code allows the machine exception program counter (MEPC) register to be accessed from a user mode program by excluding the MEPC from the access control check. MEPC as per the RISC-V specification can be only written or read by machine mode code. Thus, the attacker in the user mode can run code in machine mode privilege (privilege escalation). To mitigate the issue, fix the privilege check so that it throws an Illegal Instruction Exception for user mode accesses to the MEPC register.
(good code)
Example Language: Verilog
if (csr_we || csr_read) begin
if ((riscv::priv_lvl_t'(priv_lvl_o & csr_addr.csr_decode.priv_lvl) != csr_addr.csr_decode.priv_lvl)) begin
csr_exception_o.cause = riscv::ILLEGAL_INSTR;
csr_exception_o.valid = 1'b1;
end
// check access to debug mode only CSRs
if (csr_addr_i[11:4] == 8'h7b && !debug_mode_q) begin
csr_exception_o.cause = riscv::ILLEGAL_INSTR;
csr_exception_o.valid = 1'b1;
end
end


================================== Ai Message ==================================

Based on my analysis of the provided RTL code and the CWE information, I can identify several security concerns related to register access control and privilege enforcement:

## Security Concerns in the HMAC Register Top Module

### 1. Lack of Privilege-Based Access Control

The RTL code implements a register interface for an HMAC cryptographic module, but there appears to be no privilege-level checking for register access. This relates to **CWE-1262: Improper Access Control for Register Interface**.

The code doesn't implement any mechanism to restrict access to sensitive registers based on the privilege level of the requesting agent. All registers appear to be accessible to any entity that can access the TileLink bus interface, without checking if the requester has appropriate privileges.

### 2. Sensitive Key Material Exposure

The module contains key registers (`key_0` through `key_31`) that store cryptographic key material. Looking at the implementation:

```verilog
// Subregister 0 of Multireg key
// R[key_0]: V(True)
logic key_0_qe;
logic [0:0] key_0_flds_we;
assign key_0_qe = &key_0_flds_we;
prim_subreg_ext #(
  .DW    (32)
) u_key_0 (
  .re     (1'b0),
  .we     (key_0_we),
  .wd     (key_0_wd),
  .d      (hw2reg.key[0].d),
  .qre    (),
  .qe     (key_0_flds_we[0]),
  .q      (reg2hw.key[0].q),
  .ds     (),
  .qs     ()
);
```

While the `.re(1'b0)` parameter suggests the key registers are not directly readable, there's a concerning implementation in the read data return logic:

```verilog
addr_hit[8]: begin
  reg_rdata_next[31:0] = reg2hw.key[0].q;
end

addr_hit[9]: begin
  reg_rdata_next[31:0] = reg2hw.key[1].q;
end
```

This suggests that at least the first two key registers (key_0 and key_1) can be read back, which is a security concern according to CWE-1262's guidance: "Key material stored in registers should never be accessible to software. Even if software can provide a key, all read-back paths to software should be disabled."

### 3. Inconsistent Access Control Policies

The register interface doesn't implement a consistent policy for controlling access to different types of registers. This relates to **CWE-1268: Policy Privileges are not Assigned Consistently Between Control and Data Agents**.

For example, there's no clear separation between:
- Configuration registers (like `cfg`)
- Control registers (like `cmd`)
- Key material registers
- Status registers

All these registers appear to be accessible through the same interface without differentiated access control policies.

### 4. Lack of Write Protection for Critical Registers

The code doesn't implement write protection for critical configuration registers. For example, the `cfg` register controls important security settings:

```verilog
//   F[hmac_en]: 0:0
//   F[sha_en]: 1:1
//   F[endian_swap]: 2:2
//   F[digest_swap]: 3:3
//   F[key_swap]: 4:4
//   F[digest_size]: 8:5
//   F[key_length]: 14:9
```

These configuration settings could potentially be modified by an attacker to weaken the cryptographic implementation, but there's no mechanism to lock these settings once configured.

### 5. No Integrity Protection for Register Values

While the code includes integrity checking for the TileLink interface:

```verilog
// incoming payload check
logic intg_err;
tlul_cmd_intg_chk u_chk (
  .tl_i(tl_i),
  .err_o(intg_err)
);
```

There doesn't appear to be integrity protection for the register values themselves, which could make them vulnerable to fault injection attacks.

## Conclusion

The HMAC register interface implementation has several security concerns related to
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

Based on my analysis of the provided RTL code and the CWE information, I can identify several security concerns related to register access control and privilege enforcement:

## Security Concerns in the HMAC Register Top Module

### 1. Lack of Privilege-Based Access Control

The RTL code implements a register interface for an HMAC cryptographic module, but there appears to be no privilege-level checking for register access. This relates to **CWE-1262: Improper Access Control for Register Interface**.

The code doesn't implement any mechanism to restrict access to sensitive registers based on the privilege level of the requesting agent. All registers appear to be accessible to any entity that can access the TileLink bus interface, without checking if the requester has appropriate privileges.

### 2. Sensitive Key Material Exposure

The module contains key registers (`key_0` through `key_31`) that store cryptographic key material. Looking at the implementation:

```verilog
// Subregister 0 of Multireg key
// R[key_0]: V(True)
logic key_0_qe;
logic [0:0] key_0_flds_we;
assign key_0_qe = &key_0_flds_we;
prim_subreg_ext #(
  .DW    (32)
) u_key_0 (
  .re     (1'b0),
  .we     (key_0_we),
  .wd     (key_0_wd),
  .d      (hw2reg.key[0].d),
  .qre    (),
  .qe     (key_0_flds_we[0]),
  .q      (reg2hw.key[0].q),
  .ds     (),
  .qs     ()
);
```

While the `.re(1'b0)` parameter suggests the key registers are not directly readable, there's a concerning implementation in the read data return logic:

```verilog
addr_hit[8]: begin
  reg_rdata_next[31:0] = reg2hw.key[0].q;
end

addr_hit[9]: begin
  reg_rdata_next[31:0] = reg2hw.key[1].q;
end
```

This suggests that at least the first two key registers (key_0 and key_1) can be read back, which is a security concern according to CWE-1262's guidance: "Key material stored in registers should never be accessible to software. Even if software can provide a key, all read-back paths to software should be disabled."

### 3. Inconsistent Access Control Policies

The register interface doesn't implement a consistent policy for controlling access to different types of registers. This relates to **CWE-1268: Policy Privileges are not Assigned Consistently Between Control and Data Agents**.

For example, there's no clear separation between:
- Configuration registers (like `cfg`)
- Control registers (like `cmd`)
- Key material registers
- Status registers

All these registers appear to be accessible through the same interface without differentiated access control policies.

### 4. Lack of Write Protection for Critical Registers

The code doesn't implement write protection for critical configuration registers. For example, the `cfg` register controls important security settings:

```verilog
//   F[hmac_en]: 0:0
//   F[sha_en]: 1:1
//   F[endian_swap]: 2:2
//   F[digest_swap]: 3:3
//   F[key_swap]: 4:4
//   F[digest_size]: 8:5
//   F[key_length]: 14:9
```

These configuration settings could potentially be modified by an attacker to weaken the cryptographic implementation, but there's no mechanism to lock these settings once configured.

### 5. No Integrity Protection for Register Values

While the code includes integrity checking for the TileLink interface:

```verilog
// incoming payload check
logic intg_err;
tlul_cmd_intg_chk u_chk (
  .tl_i(tl_i),
  .err_o(intg_err)
);
```

There doesn't appear to be integrity protection for the register values themselves, which could make them vulnerable to fault injection attacks.

## Conclusion

The HMAC register interface implementation has several security concerns related to
================================== Ai Message ==================================
Tool Calls:
  run_similar_bug_agent (call_IvLZ2WcB9vPmJEO81J2ah0Vr)
 Call ID: call_IvLZ2WcB9vPmJEO81J2ah0Vr
  Args:
    bug: reg_rdata_next[31:0] = reg2hw.key[0].q;
    file_path: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv
================================ Human Message =================================

This bug was previously found in another file of this design:
    reg_rdata_next[31:0] = reg2hw.key[0].q;
    
    Please check the RTL code in the file /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv for similar bugs.
================================ Human Message =================================

This bug was previously found in another file of this design:
    reg_rdata_next[31:0] = reg2hw.key[0].q;
    
    Please check the RTL code in the file /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv for similar bugs.
================================== Ai Message ==================================

[{'text': "I'll help you find similar bug instances in the specified file. I'll use the similar_bug_tool to search for lines that match the pattern you've identified.", 'type': 'text'}, {'id': 'toolu_016JDcybC8frUNDDjmL6oxFG', 'input': {'bug': 'reg_rdata_next[31:0] = reg2hw.key[0].q;', 'ip_file': '/home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv'}, 'name': 'similar_bug_tool', 'type': 'tool_use'}]
Tool Calls:
  similar_bug_tool (toolu_016JDcybC8frUNDDjmL6oxFG)
 Call ID: toolu_016JDcybC8frUNDDjmL6oxFG
  Args:
    bug: reg_rdata_next[31:0] = reg2hw.key[0].q;
    ip_file: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv
================================= Tool Message =================================
Name: similar_bug_tool


Found similar bug in /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv at line 2617: reg_rdata_next = reg2hw.key[2].q;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv at line 2413: 
        reg_rdata_next[31:0] = reg2hw.key[0].q;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv at line 2417: 
        reg_rdata_next[31:0] = reg2hw.key[1].q;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1563: assign reg2hw.key[31].qe = key_31_qe;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1559: .q      (reg2hw.key[31].q),
Found similar bug in /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1542: assign reg2hw.key[30].qe = key_30_qe;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1223: .q      (reg2hw.key[15].q),
Found similar bug in /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1248: assign reg2hw.key[16].qe = key_16_qe;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1080: assign reg2hw.key[8].qe = key_8_qe;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1538: .q      (reg2hw.key[30].q),
================================= Tool Message =================================
Name: similar_bug_tool


Found similar bug in /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv at line 2617: reg_rdata_next = reg2hw.key[2].q;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv at line 2413: 
        reg_rdata_next[31:0] = reg2hw.key[0].q;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv at line 2417: 
        reg_rdata_next[31:0] = reg2hw.key[1].q;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1563: assign reg2hw.key[31].qe = key_31_qe;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1559: .q      (reg2hw.key[31].q),
Found similar bug in /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1542: assign reg2hw.key[30].qe = key_30_qe;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1223: .q      (reg2hw.key[15].q),
Found similar bug in /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1248: assign reg2hw.key[16].qe = key_16_qe;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1080: assign reg2hw.key[8].qe = key_8_qe;
Found similar bug in /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1538: .q      (reg2hw.key[30].q),
================================== Ai Message ==================================

[{'text': "To verify the context and confirm these are potential bugs, I'll read the file to examine the lines around these matches:", 'type': 'text'}, {'id': 'toolu_01KqJDv1J4kBLERZPHyKSRbA', 'input': {'file_path': '/home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv'}, 'name': 'read_file_with_line_numbers', 'type': 'tool_use'}]
Tool Calls:
  read_file_with_line_numbers (toolu_01KqJDv1J4kBLERZPHyKSRbA)
 Call ID: toolu_01KqJDv1J4kBLERZPHyKSRbA
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Register Top module auto-generated by `reggen`
6: 
7: `include "prim_assert.sv"
8: 
9: module hmac_reg_top (
10:   input clk_i,
11:   input rst_ni,
12:   input  tlul_pkg::tl_h2d_t tl_i,
13:   output tlul_pkg::tl_d2h_t tl_o,
14: 
15:   // Output port for window
16:   output tlul_pkg::tl_h2d_t tl_win_o,
17:   input  tlul_pkg::tl_d2h_t tl_win_i,
18: 
19:   // To HW
20:   output hmac_reg_pkg::hmac_reg2hw_t reg2hw, // Write
21:   input  hmac_reg_pkg::hmac_hw2reg_t hw2reg, // Read
22: 
23:   // Integrity check errors
24:   output logic intg_err_o
25: );
26: 
27:   import hmac_reg_pkg::* ;
28: 
29:   localparam int AW = 13;
30:   localparam int DW = 32;
31:   localparam int DBW = DW/8;                    // Byte Width
32: 
33:   // register signals
34:   logic           reg_we;
35:   logic           reg_re;
36:   logic [AW-1:0]  reg_addr;
37:   logic [DW-1:0]  reg_wdata;
38:   logic [DBW-1:0] reg_be;
39:   logic [DW-1:0]  reg_rdata;
40:   logic           reg_error;
41: 
42:   logic          addrmiss, wr_err;
43: 
44:   logic [DW-1:0] reg_rdata_next;
45:   logic reg_busy;
46: 
47:   tlul_pkg::tl_h2d_t tl_reg_h2d;
48:   tlul_pkg::tl_d2h_t tl_reg_d2h;
49: 
50: 
51:   // incoming payload check
52:   logic intg_err;
53:   tlul_cmd_intg_chk u_chk (
54:     .tl_i(tl_i),
55:     .err_o(intg_err)
56:   );
57: 
58:   // also check for spurious write enables
59:   logic reg_we_err;
60:   logic [58:0] reg_we_check;
61:   prim_reg_we_check #(
62:     .OneHotWidth(59)
63:   ) u_prim_reg_we_check (
64:     .clk_i(clk_i),
65:     .rst_ni(rst_ni),
66:     .oh_i  (reg_we_check),
67:     .en_i  (reg_we && !addrmiss),
68:     .err_o (reg_we_err)
69:   );
70: 
71:   logic err_q;
72:   always_ff @(posedge clk_i or negedge rst_ni) begin
73:     if (!rst_ni) begin
74:       err_q <= '0;
75:     end else if (intg_err || reg_we_err) begin
76:       err_q <= 1'b1;
77:     end
78:   end
79: 
80:   // integrity error output is permanent and should be used for alert generation
81:   // register errors are transactional
82:   assign intg_err_o = err_q | intg_err | reg_we_err;
83: 
84:   // outgoing integrity generation
85:   tlul_pkg::tl_d2h_t tl_o_pre;
86:   tlul_rsp_intg_gen #(
87:     .EnableRspIntgGen(1),
88:     .EnableDataIntgGen(1)
89:   ) u_rsp_intg_gen (
90:     .tl_i(tl_o_pre),
91:     .tl_o(tl_o)
92:   );
93: 
94:   tlul_pkg::tl_h2d_t tl_socket_h2d [2];
95:   tlul_pkg::tl_d2h_t tl_socket_d2h [2];
96: 
97:   logic [0:0] reg_steer;
98: 
99:   // socket_1n connection
100:   assign tl_reg_h2d = tl_socket_h2d[1];
101:   assign tl_socket_d2h[1] = tl_reg_d2h;
102: 
103:   assign tl_win_o = tl_socket_h2d[0];
104:   assign tl_socket_d2h[0] = tl_win_i;
105: 
106:   // Create Socket_1n
107:   tlul_socket_1n #(
108:     .N            (2),
109:     .HReqPass     (1'b1),
110:     .HRspPass     (1'b1),
111:     .DReqPass     ({2{1'b1}}),
112:     .DRspPass     ({2{1'b1}}),
113:     .HReqDepth    (4'h0),
114:     .HRspDepth    (4'h0),
115:     .DReqDepth    ({2{4'h0}}),
116:     .DRspDepth    ({2{4'h0}}),
117:     .ExplicitErrs (1'b0)
118:   ) u_socket (
119:     .clk_i  (clk_i),
120:     .rst_ni (rst_ni),
121:     .tl_h_i (tl_i),
122:     .tl_h_o (tl_o_pre),
123:     .tl_d_o (tl_socket_h2d),
124:     .tl_d_i (tl_socket_d2h),
125:     .dev_select_i (reg_steer)
126:   );
127: 
128:   // Create steering logic
129:   always_comb begin
130:     reg_steer =
131:         tl_i.a_address[AW-1:0] inside {[4096:8191]} ? 1'd0 :
132:         // Default set to register
133:         1'd1;
134: 
135:     // Override this in case of an integrity error
136:     if (intg_err) begin
137:       reg_steer = 1'd1;
138:     end
139:   end
140: 
141:   tlul_adapter_reg #(
142:     .RegAw(AW),
143:     .RegDw(DW),
144:     .EnableDataIntgGen(0)
145:   ) u_reg_if (
146:     .clk_i  (clk_i),
147:     .rst_ni (rst_ni),
148: 
149:     .tl_i (tl_reg_h2d),
150:     .tl_o (tl_reg_d2h),
151: 
152:     .en_ifetch_i(prim_mubi_pkg::MuBi4False),
153:     .intg_error_o(),
154: 
155:     .we_o    (reg_we),
156:     .re_o    (reg_re),
157:     .addr_o  (reg_addr),
158:     .wdata_o (reg_wdata),
159:     .be_o    (reg_be),
160:     .busy_i  (reg_busy),
161:     .rdata_i (reg_rdata),
162:     .error_i (reg_error)
163:   );
164: 
165:   // cdc oversampling signals
166: 
167:   assign reg_rdata = reg_rdata_next ;
168:   assign reg_error = addrmiss | wr_err | intg_err;
169: 
170:   // Define SW related signals
171:   // Format: <reg>_<field>_{wd|we|qs}
172:   //        or <reg>_{wd|we|qs} if field == 1 or 0
173:   logic intr_state_we;
174:   logic intr_state_hmac_done_qs;
175:   logic intr_state_hmac_done_wd;
176:   logic intr_state_fifo_empty_qs;
177:   logic intr_state_hmac_err_qs;
178:   logic intr_state_hmac_err_wd;
179:   logic intr_enable_we;
180:   logic intr_enable_hmac_done_qs;
181:   logic intr_enable_hmac_done_wd;
182:   logic intr_enable_fifo_empty_qs;
183:   logic intr_enable_fifo_empty_wd;
184:   logic intr_enable_hmac_err_qs;
185:   logic intr_enable_hmac_err_wd;
186:   logic intr_test_we;
187:   logic intr_test_hmac_done_wd;
188:   logic intr_test_fifo_empty_wd;
189:   logic intr_test_hmac_err_wd;
190:   logic alert_test_we;
191:   logic alert_test_wd;
192:   logic cfg_re;
193:   logic cfg_we;
194:   logic cfg_hmac_en_qs;
195:   logic cfg_hmac_en_wd;
196:   logic cfg_sha_en_qs;
197:   logic cfg_sha_en_wd;
198:   logic cfg_endian_swap_qs;
199:   logic cfg_endian_swap_wd;
200:   logic cfg_digest_swap_qs;
201:   logic cfg_digest_swap_wd;
202:   logic cfg_key_swap_qs;
203:   logic cfg_key_swap_wd;
204:   logic [3:0] cfg_digest_size_qs;
205:   logic [3:0] cfg_digest_size_wd;
206:   logic [5:0] cfg_key_length_qs;
207:   logic [5:0] cfg_key_length_wd;
208:   logic cmd_we;
209:   logic cmd_hash_start_wd;
210:   logic cmd_hash_process_wd;
211:   logic cmd_hash_stop_wd;
212:   logic cmd_hash_continue_wd;
213:   logic status_re;
214:   logic status_hmac_idle_qs;
215:   logic status_fifo_empty_qs;
216:   logic status_fifo_full_qs;
217:   logic [5:0] status_fifo_depth_qs;
218:   logic [31:0] err_code_qs;
219:   logic wipe_secret_we;
220:   logic [31:0] wipe_secret_wd;
221:   logic key_0_we;
222:   logic [31:0] key_0_wd;
223:   logic key_1_we;
224:   logic [31:0] key_1_wd;
225:   logic key_2_we;
226:   logic [31:0] key_2_wd;
227:   logic key_3_we;
228:   logic [31:0] key_3_wd;
229:   logic key_4_we;
230:   logic [31:0] key_4_wd;
231:   logic key_5_we;
232:   logic [31:0] key_5_wd;
233:   logic key_6_we;
234:   logic [31:0] key_6_wd;
235:   logic key_7_we;
236:   logic [31:0] key_7_wd;
237:   logic key_8_we;
238:   logic [31:0] key_8_wd;
239:   logic key_9_we;
240:   logic [31:0] key_9_wd;
241:   logic key_10_we;
242:   logic [31:0] key_10_wd;
243:   logic key_11_we;
244:   logic [31:0] key_11_wd;
245:   logic key_12_we;
246:   logic [31:0] key_12_wd;
247:   logic key_13_we;
248:   logic [31:0] key_13_wd;
249:   logic key_14_we;
250:   logic [31:0] key_14_wd;
251:   logic key_15_we;
252:   logic [31:0] key_15_wd;
253:   logic key_16_we;
254:   logic [31:0] key_16_wd;
255:   logic key_17_we;
256:   logic [31:0] key_17_wd;
257:   logic key_18_we;
258:   logic [31:0] key_18_wd;
259:   logic key_19_we;
260:   logic [31:0] key_19_wd;
261:   logic key_20_we;
262:   logic [31:0] key_20_wd;
263:   logic key_21_we;
264:   logic [31:0] key_21_wd;
265:   logic key_22_we;
266:   logic [31:0] key_22_wd;
267:   logic key_23_we;
268:   logic [31:0] key_23_wd;
269:   logic key_24_we;
270:   logic [31:0] key_24_wd;
271:   logic key_25_we;
272:   logic [31:0] key_25_wd;
273:   logic key_26_we;
274:   logic [31:0] key_26_wd;
275:   logic key_27_we;
276:   logic [31:0] key_27_wd;
277:   logic key_28_we;
278:   logic [31:0] key_28_wd;
279:   logic key_29_we;
280:   logic [31:0] key_29_wd;
281:   logic key_30_we;
282:   logic [31:0] key_30_wd;
283:   logic key_31_we;
284:   logic [31:0] key_31_wd;
285:   logic digest_0_re;
286:   logic digest_0_we;
287:   logic [31:0] digest_0_qs;
288:   logic [31:0] digest_0_wd;
289:   logic digest_1_re;
290:   logic digest_1_we;
291:   logic [31:0] digest_1_qs;
292:   logic [31:0] digest_1_wd;
293:   logic digest_2_re;
294:   logic digest_2_we;
295:   logic [31:0] digest_2_qs;
296:   logic [31:0] digest_2_wd;
297:   logic digest_3_re;
298:   logic digest_3_we;
299:   logic [31:0] digest_3_qs;
300:   logic [31:0] digest_3_wd;
301:   logic digest_4_re;
302:   logic digest_4_we;
303:   logic [31:0] digest_4_qs;
304:   logic [31:0] digest_4_wd;
305:   logic digest_5_re;
306:   logic digest_5_we;
307:   logic [31:0] digest_5_qs;
308:   logic [31:0] digest_5_wd;
309:   logic digest_6_re;
310:   logic digest_6_we;
311:   logic [31:0] digest_6_qs;
312:   logic [31:0] digest_6_wd;
313:   logic digest_7_re;
314:   logic digest_7_we;
315:   logic [31:0] digest_7_qs;
316:   logic [31:0] digest_7_wd;
317:   logic digest_8_re;
318:   logic digest_8_we;
319:   logic [31:0] digest_8_qs;
320:   logic [31:0] digest_8_wd;
321:   logic digest_9_re;
322:   logic digest_9_we;
323:   logic [31:0] digest_9_qs;
324:   logic [31:0] digest_9_wd;
325:   logic digest_10_re;
326:   logic digest_10_we;
327:   logic [31:0] digest_10_qs;
328:   logic [31:0] digest_10_wd;
329:   logic digest_11_re;
330:   logic digest_11_we;
331:   logic [31:0] digest_11_qs;
332:   logic [31:0] digest_11_wd;
333:   logic digest_12_re;
334:   logic digest_12_we;
335:   logic [31:0] digest_12_qs;
336:   logic [31:0] digest_12_wd;
337:   logic digest_13_re;
338:   logic digest_13_we;
339:   logic [31:0] digest_13_qs;
340:   logic [31:0] digest_13_wd;
341:   logic digest_14_re;
342:   logic digest_14_we;
343:   logic [31:0] digest_14_qs;
344:   logic [31:0] digest_14_wd;
345:   logic digest_15_re;
346:   logic digest_15_we;
347:   logic [31:0] digest_15_qs;
348:   logic [31:0] digest_15_wd;
349:   logic msg_length_lower_re;
350:   logic msg_length_lower_we;
351:   logic [31:0] msg_length_lower_qs;
352:   logic [31:0] msg_length_lower_wd;
353:   logic msg_length_upper_re;
354:   logic msg_length_upper_we;
355:   logic [31:0] msg_length_upper_qs;
356:   logic [31:0] msg_length_upper_wd;
357: 
358:   // Register instances
359:   // R[intr_state]: V(False)
360:   //   F[hmac_done]: 0:0
361:   prim_subreg #(
362:     .DW      (1),
363:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
364:     .RESVAL  (1'h0),
365:     .Mubi    (1'b0)
366:   ) u_intr_state_hmac_done (
367:     .clk_i   (clk_i),
368:     .rst_ni  (rst_ni),
369: 
370:     // from register interface
371:     .we     (intr_state_we),
372:     .wd     (intr_state_hmac_done_wd),
373: 
374:     // from internal hardware
375:     .de     (hw2reg.intr_state.hmac_done.de),
376:     .d      (hw2reg.intr_state.hmac_done.d),
377: 
378:     // to internal hardware
379:     .qe     (),
380:     .q      (reg2hw.intr_state.hmac_done.q),
381:     .ds     (),
382: 
383:     // to register interface (read)
384:     .qs     (intr_state_hmac_done_qs)
385:   );
386: 
387:   //   F[fifo_empty]: 1:1
388:   prim_subreg #(
389:     .DW      (1),
390:     .SwAccess(prim_subreg_pkg::SwAccessRO),
391:     .RESVAL  (1'h0),
392:     .Mubi    (1'b0)
393:   ) u_intr_state_fifo_empty (
394:     .clk_i   (clk_i),
395:     .rst_ni  (rst_ni),
396: 
397:     // from register interface
398:     .we     (1'b0),
399:     .wd     ('0),
400: 
401:     // from internal hardware
402:     .de     (hw2reg.intr_state.fifo_empty.de),
403:     .d      (hw2reg.intr_state.fifo_empty.d),
404: 
405:     // to internal hardware
406:     .qe     (),
407:     .q      (reg2hw.intr_state.fifo_empty.q),
408:     .ds     (),
409: 
410:     // to register interface (read)
411:     .qs     (intr_state_fifo_empty_qs)
412:   );
413: 
414:   //   F[hmac_err]: 2:2
415:   prim_subreg #(
416:     .DW      (1),
417:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
418:     .RESVAL  (1'h0),
419:     .Mubi    (1'b0)
420:   ) u_intr_state_hmac_err (
421:     .clk_i   (clk_i),
422:     .rst_ni  (rst_ni),
423: 
424:     // from register interface
425:     .we     (intr_state_we),
426:     .wd     (intr_state_hmac_err_wd),
427: 
428:     // from internal hardware
429:     .de     (hw2reg.intr_state.hmac_err.de),
430:     .d      (hw2reg.intr_state.hmac_err.d),
431: 
432:     // to internal hardware
433:     .qe     (),
434:     .q      (reg2hw.intr_state.hmac_err.q),
435:     .ds     (),
436: 
437:     // to register interface (read)
438:     .qs     (intr_state_hmac_err_qs)
439:   );
440: 
441: 
442:   // R[intr_enable]: V(False)
443:   //   F[hmac_done]: 0:0
444:   prim_subreg #(
445:     .DW      (1),
446:     .SwAccess(prim_subreg_pkg::SwAccessRW),
447:     .RESVAL  (1'h0),
448:     .Mubi    (1'b0)
449:   ) u_intr_enable_hmac_done (
450:     .clk_i   (clk_i),
451:     .rst_ni  (rst_ni),
452: 
453:     // from register interface
454:     .we     (intr_enable_we),
455:     .wd     (intr_enable_hmac_done_wd),
456: 
457:     // from internal hardware
458:     .de     (1'b0),
459:     .d      ('0),
460: 
461:     // to internal hardware
462:     .qe     (),
463:     .q      (reg2hw.intr_enable.hmac_done.q),
464:     .ds     (),
465: 
466:     // to register interface (read)
467:     .qs     (intr_enable_hmac_done_qs)
468:   );
469: 
470:   //   F[fifo_empty]: 1:1
471:   prim_subreg #(
472:     .DW      (1),
473:     .SwAccess(prim_subreg_pkg::SwAccessRW),
474:     .RESVAL  (1'h0),
475:     .Mubi    (1'b0)
476:   ) u_intr_enable_fifo_empty (
477:     .clk_i   (clk_i),
478:     .rst_ni  (rst_ni),
479: 
480:     // from register interface
481:     .we     (intr_enable_we),
482:     .wd     (intr_enable_fifo_empty_wd),
483: 
484:     // from internal hardware
485:     .de     (1'b0),
486:     .d      ('0),
487: 
488:     // to internal hardware
489:     .qe     (),
490:     .q      (reg2hw.intr_enable.fifo_empty.q),
491:     .ds     (),
492: 
493:     // to register interface (read)
494:     .qs     (intr_enable_fifo_empty_qs)
495:   );
496: 
497:   //   F[hmac_err]: 2:2
498:   prim_subreg #(
499:     .DW      (1),
500:     .SwAccess(prim_subreg_pkg::SwAccessRW),
501:     .RESVAL  (1'h0),
502:     .Mubi    (1'b0)
503:   ) u_intr_enable_hmac_err (
504:     .clk_i   (clk_i),
505:     .rst_ni  (rst_ni),
506: 
507:     // from register interface
508:     .we     (intr_enable_we),
509:     .wd     (intr_enable_hmac_err_wd),
510: 
511:     // from internal hardware
512:     .de     (1'b0),
513:     .d      ('0),
514: 
515:     // to internal hardware
516:     .qe     (),
517:     .q      (reg2hw.intr_enable.hmac_err.q),
518:     .ds     (),
519: 
520:     // to register interface (read)
521:     .qs     (intr_enable_hmac_err_qs)
522:   );
523: 
524: 
525:   // R[intr_test]: V(True)
526:   logic intr_test_qe;
527:   logic [2:0] intr_test_flds_we;
528:   assign intr_test_qe = &intr_test_flds_we;
529:   //   F[hmac_done]: 0:0
530:   prim_subreg_ext #(
531:     .DW    (1)
532:   ) u_intr_test_hmac_done (
533:     .re     (1'b0),
534:     .we     (intr_test_we),
535:     .wd     (intr_test_hmac_done_wd),
536:     .d      ('0),
537:     .qre    (),
538:     .qe     (intr_test_flds_we[0]),
539:     .q      (reg2hw.intr_test.hmac_done.q),
540:     .ds     (),
541:     .qs     ()
542:   );
543:   assign reg2hw.intr_test.hmac_done.qe = intr_test_qe;
544: 
545:   //   F[fifo_empty]: 1:1
546:   prim_subreg_ext #(
547:     .DW    (1)
548:   ) u_intr_test_fifo_empty (
549:     .re     (1'b0),
550:     .we     (intr_test_we),
551:     .wd     (intr_test_fifo_empty_wd),
552:     .d      ('0),
553:     .qre    (),
554:     .qe     (intr_test_flds_we[1]),
555:     .q      (reg2hw.intr_test.fifo_empty.q),
556:     .ds     (),
557:     .qs     ()
558:   );
559:   assign reg2hw.intr_test.fifo_empty.qe = intr_test_qe;
560: 
561:   //   F[hmac_err]: 2:2
562:   prim_subreg_ext #(
563:     .DW    (1)
564:   ) u_intr_test_hmac_err (
565:     .re     (1'b0),
566:     .we     (intr_test_we),
567:     .wd     (intr_test_hmac_err_wd),
568:     .d      ('0),
569:     .qre    (),
570:     .qe     (intr_test_flds_we[2]),
571:     .q      (reg2hw.intr_test.hmac_err.q),
572:     .ds     (),
573:     .qs     ()
574:   );
575:   assign reg2hw.intr_test.hmac_err.qe = intr_test_qe;
576: 
577: 
578:   // R[alert_test]: V(True)
579:   logic alert_test_qe;
580:   logic [0:0] alert_test_flds_we;
581:   assign alert_test_qe = &alert_test_flds_we;
582:   prim_subreg_ext #(
583:     .DW    (1)
584:   ) u_alert_test (
585:     .re     (1'b0),
586:     .we     (alert_test_we),
587:     .wd     (alert_test_wd),
588:     .d      ('0),
589:     .qre    (),
590:     .qe     (alert_test_flds_we[0]),
591:     .q      (reg2hw.alert_test.q),
592:     .ds     (),
593:     .qs     ()
594:   );
595:   assign reg2hw.alert_test.qe = alert_test_qe;
596: 
597: 
598:   // R[cfg]: V(True)
599:   logic cfg_qe;
600:   logic [6:0] cfg_flds_we;
601:   assign cfg_qe = &cfg_flds_we;
602:   //   F[hmac_en]: 0:0
603:   prim_subreg_ext #(
604:     .DW    (1)
605:   ) u_cfg_hmac_en (
606:     .re     (cfg_re),
607:     .we     (cfg_we),
608:     .wd     (cfg_hmac_en_wd),
609:     .d      (hw2reg.cfg.hmac_en.d),
610:     .qre    (),
611:     .qe     (cfg_flds_we[0]),
612:     .q      (reg2hw.cfg.hmac_en.q),
613:     .ds     (),
614:     .qs     (cfg_hmac_en_qs)
615:   );
616:   assign reg2hw.cfg.hmac_en.qe = cfg_qe;
617: 
618:   //   F[sha_en]: 1:1
619:   prim_subreg_ext #(
620:     .DW    (1)
621:   ) u_cfg_sha_en (
622:     .re     (cfg_re),
623:     .we     (cfg_we),
624:     .wd     (cfg_sha_en_wd),
625:     .d      (hw2reg.cfg.sha_en.d),
626:     .qre    (),
627:     .qe     (cfg_flds_we[1]),
628:     .q      (reg2hw.cfg.sha_en.q),
629:     .ds     (),
630:     .qs     (cfg_sha_en_qs)
631:   );
632:   assign reg2hw.cfg.sha_en.qe = cfg_qe;
633: 
634:   //   F[endian_swap]: 2:2
635:   prim_subreg_ext #(
636:     .DW    (1)
637:   ) u_cfg_endian_swap (
638:     .re     (cfg_re),
639:     .we     (cfg_we),
640:     .wd     (cfg_endian_swap_wd),
641:     .d      (hw2reg.cfg.endian_swap.d),
642:     .qre    (),
643:     .qe     (cfg_flds_we[2]),
644:     .q      (reg2hw.cfg.endian_swap.q),
645:     .ds     (),
646:     .qs     (cfg_endian_swap_qs)
647:   );
648:   assign reg2hw.cfg.endian_swap.qe = cfg_qe;
649: 
650:   //   F[digest_swap]: 3:3
651:   prim_subreg_ext #(
652:     .DW    (1)
653:   ) u_cfg_digest_swap (
654:     .re     (cfg_re),
655:     .we     (cfg_we),
656:     .wd     (cfg_digest_swap_wd),
657:     .d      (hw2reg.cfg.digest_swap.d),
658:     .qre    (),
659:     .qe     (cfg_flds_we[3]),
660:     .q      (reg2hw.cfg.digest_swap.q),
661:     .ds     (),
662:     .qs     (cfg_digest_swap_qs)
663:   );
664:   assign reg2hw.cfg.digest_swap.qe = cfg_qe;
665: 
666:   //   F[key_swap]: 4:4
667:   prim_subreg_ext #(
668:     .DW    (1)
669:   ) u_cfg_key_swap (
670:     .re     (cfg_re),
671:     .we     (cfg_we),
672:     .wd     (cfg_key_swap_wd),
673:     .d      (hw2reg.cfg.key_swap.d),
674:     .qre    (),
675:     .qe     (cfg_flds_we[4]),
676:     .q      (reg2hw.cfg.key_swap.q),
677:     .ds     (),
678:     .qs     (cfg_key_swap_qs)
679:   );
680:   assign reg2hw.cfg.key_swap.qe = cfg_qe;
681: 
682:   //   F[digest_size]: 8:5
683:   prim_subreg_ext #(
684:     .DW    (4)
685:   ) u_cfg_digest_size (
686:     .re     (cfg_re),
687:     .we     (cfg_we),
688:     .wd     (cfg_digest_size_wd),
689:     .d      (hw2reg.cfg.digest_size.d),
690:     .qre    (),
691:     .qe     (cfg_flds_we[5]),
692:     .q      (reg2hw.cfg.digest_size.q),
693:     .ds     (),
694:     .qs     (cfg_digest_size_qs)
695:   );
696:   assign reg2hw.cfg.digest_size.qe = cfg_qe;
697: 
698:   //   F[key_length]: 14:9
699:   prim_subreg_ext #(
700:     .DW    (6)
701:   ) u_cfg_key_length (
702:     .re     (cfg_re),
703:     .we     (cfg_we),
704:     .wd     (cfg_key_length_wd),
705:     .d      (hw2reg.cfg.key_length.d),
706:     .qre    (),
707:     .qe     (cfg_flds_we[6]),
708:     .q      (reg2hw.cfg.key_length.q),
709:     .ds     (),
710:     .qs     (cfg_key_length_qs)
711:   );
712:   assign reg2hw.cfg.key_length.qe = cfg_qe;
713: 
714: 
715:   // R[cmd]: V(True)
716:   logic cmd_qe;
717:   logic [3:0] cmd_flds_we;
718:   assign cmd_qe = &cmd_flds_we;
719:   //   F[hash_start]: 0:0
720:   prim_subreg_ext #(
721:     .DW    (1)
722:   ) u_cmd_hash_start (
723:     .re     (1'b0),
724:     .we     (cmd_we),
725:     .wd     (cmd_hash_start_wd),
726:     .d      ('0),
727:     .qre    (),
728:     .qe     (cmd_flds_we[0]),
729:     .q      (reg2hw.cmd.hash_start.q),
730:     .ds     (),
731:     .qs     ()
732:   );
733:   assign reg2hw.cmd.hash_start.qe = cmd_qe;
734: 
735:   //   F[hash_process]: 1:1
736:   prim_subreg_ext #(
737:     .DW    (1)
738:   ) u_cmd_hash_process (
739:     .re     (1'b0),
740:     .we     (cmd_we),
741:     .wd     (cmd_hash_process_wd),
742:     .d      ('0),
743:     .qre    (),
744:     .qe     (cmd_flds_we[1]),
745:     .q      (reg2hw.cmd.hash_process.q),
746:     .ds     (),
747:     .qs     ()
748:   );
749:   assign reg2hw.cmd.hash_process.qe = cmd_qe;
750: 
751:   //   F[hash_stop]: 2:2
752:   prim_subreg_ext #(
753:     .DW    (1)
754:   ) u_cmd_hash_stop (
755:     .re     (1'b0),
756:     .we     (cmd_we),
757:     .wd     (cmd_hash_stop_wd),
758:     .d      ('0),
759:     .qre    (),
760:     .qe     (cmd_flds_we[2]),
761:     .q      (reg2hw.cmd.hash_stop.q),
762:     .ds     (),
763:     .qs     ()
764:   );
765:   assign reg2hw.cmd.hash_stop.qe = cmd_qe;
766: 
767:   //   F[hash_continue]: 3:3
768:   prim_subreg_ext #(
769:     .DW    (1)
770:   ) u_cmd_hash_continue (
771:     .re     (1'b0),
772:     .we     (cmd_we),
773:     .wd     (cmd_hash_continue_wd),
774:     .d      ('0),
775:     .qre    (),
776:     .qe     (cmd_flds_we[3]),
777:     .q      (reg2hw.cmd.hash_continue.q),
778:     .ds     (),
779:     .qs     ()
780:   );
781:   assign reg2hw.cmd.hash_continue.qe = cmd_qe;
782: 
783: 
784:   // R[status]: V(True)
785:   //   F[hmac_idle]: 0:0
786:   prim_subreg_ext #(
787:     .DW    (1)
788:   ) u_status_hmac_idle (
789:     .re     (status_re),
790:     .we     (1'b0),
791:     .wd     ('0),
792:     .d      (hw2reg.status.hmac_idle.d),
793:     .qre    (),
794:     .qe     (),
795:     .q      (),
796:     .ds     (),
797:     .qs     (status_hmac_idle_qs)
798:   );
799: 
800:   //   F[fifo_empty]: 1:1
801:   prim_subreg_ext #(
802:     .DW    (1)
803:   ) u_status_fifo_empty (
804:     .re     (status_re),
805:     .we     (1'b0),
806:     .wd     ('0),
807:     .d      (hw2reg.status.fifo_empty.d),
808:     .qre    (),
809:     .qe     (),
810:     .q      (),
811:     .ds     (),
812:     .qs     (status_fifo_empty_qs)
813:   );
814: 
815:   //   F[fifo_full]: 2:2
816:   prim_subreg_ext #(
817:     .DW    (1)
818:   ) u_status_fifo_full (
819:     .re     (status_re),
820:     .we     (1'b0),
821:     .wd     ('0),
822:     .d      (hw2reg.status.fifo_full.d),
823:     .qre    (),
824:     .qe     (),
825:     .q      (),
826:     .ds     (),
827:     .qs     (status_fifo_full_qs)
828:   );
829: 
830:   //   F[fifo_depth]: 9:4
831:   prim_subreg_ext #(
832:     .DW    (6)
833:   ) u_status_fifo_depth (
834:     .re     (status_re),
835:     .we     (1'b0),
836:     .wd     ('0),
837:     .d      (hw2reg.status.fifo_depth.d),
838:     .qre    (),
839:     .qe     (),
840:     .q      (),
841:     .ds     (),
842:     .qs     (status_fifo_depth_qs)
843:   );
844: 
845: 
846:   // R[err_code]: V(False)
847:   prim_subreg #(
848:     .DW      (32),
849:     .SwAccess(prim_subreg_pkg::SwAccessRO),
850:     .RESVAL  (32'h0),
851:     .Mubi    (1'b0)
852:   ) u_err_code (
853:     .clk_i   (clk_i),
854:     .rst_ni  (rst_ni),
855: 
856:     // from register interface
857:     .we     (1'b0),
858:     .wd     ('0),
859: 
860:     // from internal hardware
861:     .de     (hw2reg.err_code.de),
862:     .d      (hw2reg.err_code.d),
863: 
864:     // to internal hardware
865:     .qe     (),
866:     .q      (),
867:     .ds     (),
868: 
869:     // to register interface (read)
870:     .qs     (err_code_qs)
871:   );
872: 
873: 
874:   // R[wipe_secret]: V(True)
875:   logic wipe_secret_qe;
876:   logic [0:0] wipe_secret_flds_we;
877:   assign wipe_secret_qe = &wipe_secret_flds_we;
878:   prim_subreg_ext #(
879:     .DW    (32)
880:   ) u_wipe_secret (
881:     .re     (1'b0),
882:     .we     (wipe_secret_we),
883:     .wd     (wipe_secret_wd),
884:     .d      ('0),
885:     .qre    (),
886:     .qe     (wipe_secret_flds_we[0]),
887:     .q      (reg2hw.wipe_secret.q),
888:     .ds     (),
889:     .qs     ()
890:   );
891:   assign reg2hw.wipe_secret.qe = wipe_secret_qe;
892: 
893: 
894:   // Subregister 0 of Multireg key
895:   // R[key_0]: V(True)
896:   logic key_0_qe;
897:   logic [0:0] key_0_flds_we;
898:   assign key_0_qe = &key_0_flds_we;
899:   prim_subreg_ext #(
900:     .DW    (32)
901:   ) u_key_0 (
902:     .re     (1'b0),
903:     .we     (key_0_we),
904:     .wd     (key_0_wd),
905:     .d      (hw2reg.key[0].d),
906:     .qre    (),
907:     .qe     (key_0_flds_we[0]),
908:     .q      (reg2hw.key[0].q),
909:     .ds     (),
910:     .qs     ()
911:   );
912:   assign reg2hw.key[0].qe = key_0_qe;
913: 
914: 
915:   // Subregister 1 of Multireg key
916:   // R[key_1]: V(True)
917:   logic key_1_qe;
918:   logic [0:0] key_1_flds_we;
919:   assign key_1_qe = &key_1_flds_we;
920:   prim_subreg_ext #(
921:     .DW    (32)
922:   ) u_key_1 (
923:     .re     (1'b0),
924:     .we     (key_1_we),
925:     .wd     (key_1_wd),
926:     .d      (hw2reg.key[1].d),
927:     .qre    (),
928:     .qe     (key_1_flds_we[0]),
929:     .q      (reg2hw.key[1].q),
930:     .ds     (),
931:     .qs     ()
932:   );
933:   assign reg2hw.key[1].qe = key_1_qe;
934: 
935: 
936:   // Subregister 2 of Multireg key
937:   // R[key_2]: V(True)
938:   logic key_2_qe;
939:   logic [0:0] key_2_flds_we;
940:   assign key_2_qe = &key_2_flds_we;
941:   prim_subreg_ext #(
942:     .DW    (32)
943:   ) u_key_2 (
944:     .re     (1'b0),
945:     .we     (key_2_we),
946:     .wd     (key_2_wd),
947:     .d      (hw2reg.key[2].d),
948:     .qre    (),
949:     .qe     (key_2_flds_we[0]),
950:     .q      (reg2hw.key[2].q),
951:     .ds     (),
952:     .qs     ()
953:   );
954:   assign reg2hw.key[2].qe = key_2_qe;
955: 
956: 
957:   // Subregister 3 of Multireg key
958:   // R[key_3]: V(True)
959:   logic key_3_qe;
960:   logic [0:0] key_3_flds_we;
961:   assign key_3_qe = &key_3_flds_we;
962:   prim_subreg_ext #(
963:     .DW    (32)
964:   ) u_key_3 (
965:     .re     (1'b0),
966:     .we     (key_3_we),
967:     .wd     (key_3_wd),
968:     .d      (hw2reg.key[3].d),
969:     .qre    (),
970:     .qe     (key_3_flds_we[0]),
971:     .q      (reg2hw.key[3].q),
972:     .ds     (),
973:     .qs     ()
974:   );
975:   assign reg2hw.key[3].qe = key_3_qe;
976: 
977: 
978:   // Subregister 4 of Multireg key
979:   // R[key_4]: V(True)
980:   logic key_4_qe;
981:   logic [0:0] key_4_flds_we;
982:   assign key_4_qe = &key_4_flds_we;
983:   prim_subreg_ext #(
984:     .DW    (32)
985:   ) u_key_4 (
986:     .re     (1'b0),
987:     .we     (key_4_we),
988:     .wd     (key_4_wd),
989:     .d      (hw2reg.key[4].d),
990:     .qre    (),
991:     .qe     (key_4_flds_we[0]),
992:     .q      (reg2hw.key[4].q),
993:     .ds     (),
994:     .qs     ()
995:   );
996:   assign reg2hw.key[4].qe = key_4_qe;
997: 
998: 
999:   // Subregister 5 of Multireg key
1000:   // R[key_5]: V(True)
1001:   logic key_5_qe;
1002:   logic [0:0] key_5_flds_we;
1003:   assign key_5_qe = &key_5_flds_we;
1004:   prim_subreg_ext #(
1005:     .DW    (32)
1006:   ) u_key_5 (
1007:     .re     (1'b0),
1008:     .we     (key_5_we),
1009:     .wd     (key_5_wd),
1010:     .d      (hw2reg.key[5].d),
1011:     .qre    (),
1012:     .qe     (key_5_flds_we[0]),
1013:     .q      (reg2hw.key[5].q),
1014:     .ds     (),
1015:     .qs     ()
1016:   );
1017:   assign reg2hw.key[5].qe = key_5_qe;
1018: 
1019: 
1020:   // Subregister 6 of Multireg key
1021:   // R[key_6]: V(True)
1022:   logic key_6_qe;
1023:   logic [0:0] key_6_flds_we;
1024:   assign key_6_qe = &key_6_flds_we;
1025:   prim_subreg_ext #(
1026:     .DW    (32)
1027:   ) u_key_6 (
1028:     .re     (1'b0),
1029:     .we     (key_6_we),
1030:     .wd     (key_6_wd),
1031:     .d      (hw2reg.key[6].d),
1032:     .qre    (),
1033:     .qe     (key_6_flds_we[0]),
1034:     .q      (reg2hw.key[6].q),
1035:     .ds     (),
1036:     .qs     ()
1037:   );
1038:   assign reg2hw.key[6].qe = key_6_qe;
1039: 
1040: 
1041:   // Subregister 7 of Multireg key
1042:   // R[key_7]: V(True)
1043:   logic key_7_qe;
1044:   logic [0:0] key_7_flds_we;
1045:   assign key_7_qe = &key_7_flds_we;
1046:   prim_subreg_ext #(
1047:     .DW    (32)
1048:   ) u_key_7 (
1049:     .re     (1'b0),
1050:     .we     (key_7_we),
1051:     .wd     (key_7_wd),
1052:     .d      (hw2reg.key[7].d),
1053:     .qre    (),
1054:     .qe     (key_7_flds_we[0]),
1055:     .q      (reg2hw.key[7].q),
1056:     .ds     (),
1057:     .qs     ()
1058:   );
1059:   assign reg2hw.key[7].qe = key_7_qe;
1060: 
1061: 
1062:   // Subregister 8 of Multireg key
1063:   // R[key_8]: V(True)
1064:   logic key_8_qe;
1065:   logic [0:0] key_8_flds_we;
1066:   assign key_8_qe = &key_8_flds_we;
1067:   prim_subreg_ext #(
1068:     .DW    (32)
1069:   ) u_key_8 (
1070:     .re     (1'b0),
1071:     .we     (key_8_we),
1072:     .wd     (key_8_wd),
1073:     .d      (hw2reg.key[8].d),
1074:     .qre    (),
1075:     .qe     (key_8_flds_we[0]),
1076:     .q      (reg2hw.key[8].q),
1077:     .ds     (),
1078:     .qs     ()
1079:   );
1080:   assign reg2hw.key[8].qe = key_8_qe;
1081: 
1082: 
1083:   // Subregister 9 of Multireg key
1084:   // R[key_9]: V(True)
1085:   logic key_9_qe;
1086:   logic [0:0] key_9_flds_we;
1087:   assign key_9_qe = &key_9_flds_we;
1088:   prim_subreg_ext #(
1089:     .DW    (32)
1090:   ) u_key_9 (
1091:     .re     (1'b0),
1092:     .we     (key_9_we),
1093:     .wd     (key_9_wd),
1094:     .d      (hw2reg.key[9].d),
1095:     .qre    (),
1096:     .qe     (key_9_flds_we[0]),
1097:     .q      (reg2hw.key[9].q),
1098:     .ds     (),
1099:     .qs     ()
1100:   );
1101:   assign reg2hw.key[9].qe = key_9_qe;
1102: 
1103: 
1104:   // Subregister 10 of Multireg key
1105:   // R[key_10]: V(True)
1106:   logic key_10_qe;
1107:   logic [0:0] key_10_flds_we;
1108:   assign key_10_qe = &key_10_flds_we;
1109:   prim_subreg_ext #(
1110:     .DW    (32)
1111:   ) u_key_10 (
1112:     .re     (1'b0),
1113:     .we     (key_10_we),
1114:     .wd     (key_10_wd),
1115:     .d      (hw2reg.key[10].d),
1116:     .qre    (),
1117:     .qe     (key_10_flds_we[0]),
1118:     .q      (reg2hw.key[10].q),
1119:     .ds     (),
1120:     .qs     ()
1121:   );
1122:   assign reg2hw.key[10].qe = key_10_qe;
1123: 
1124: 
1125:   // Subregister 11 of Multireg key
1126:   // R[key_11]: V(True)
1127:   logic key_11_qe;
1128:   logic [0:0] key_11_flds_we;
1129:   assign key_11_qe = &key_11_flds_we;
1130:   prim_subreg_ext #(
1131:     .DW    (32)
1132:   ) u_key_11 (
1133:     .re     (1'b0),
1134:     .we     (key_11_we),
1135:     .wd     (key_11_wd),
1136:     .d      (hw2reg.key[11].d),
1137:     .qre    (),
1138:     .qe     (key_11_flds_we[0]),
1139:     .q      (reg2hw.key[11].q),
1140:     .ds     (),
1141:     .qs     ()
1142:   );
1143:   assign reg2hw.key[11].qe = key_11_qe;
1144: 
1145: 
1146:   // Subregister 12 of Multireg key
1147:   // R[key_12]: V(True)
1148:   logic key_12_qe;
1149:   logic [0:0] key_12_flds_we;
1150:   assign key_12_qe = &key_12_flds_we;
1151:   prim_subreg_ext #(
1152:     .DW    (32)
1153:   ) u_key_12 (
1154:     .re     (1'b0),
1155:     .we     (key_12_we),
1156:     .wd     (key_12_wd),
1157:     .d      (hw2reg.key[12].d),
1158:     .qre    (),
1159:     .qe     (key_12_flds_we[0]),
1160:     .q      (reg2hw.key[12].q),
1161:     .ds     (),
1162:     .qs     ()
1163:   );
1164:   assign reg2hw.key[12].qe = key_12_qe;
1165: 
1166: 
1167:   // Subregister 13 of Multireg key
1168:   // R[key_13]: V(True)
1169:   logic key_13_qe;
1170:   logic [0:0] key_13_flds_we;
1171:   assign key_13_qe = &key_13_flds_we;
1172:   prim_subreg_ext #(
1173:     .DW    (32)
1174:   ) u_key_13 (
1175:     .re     (1'b0),
1176:     .we     (key_13_we),
1177:     .wd     (key_13_wd),
1178:     .d      (hw2reg.key[13].d),
1179:     .qre    (),
1180:     .qe     (key_13_flds_we[0]),
1181:     .q      (reg2hw.key[13].q),
1182:     .ds     (),
1183:     .qs     ()
1184:   );
1185:   assign reg2hw.key[13].qe = key_13_qe;
1186: 
1187: 
1188:   // Subregister 14 of Multireg key
1189:   // R[key_14]: V(True)
1190:   logic key_14_qe;
1191:   logic [0:0] key_14_flds_we;
1192:   assign key_14_qe = &key_14_flds_we;
1193:   prim_subreg_ext #(
1194:     .DW    (32)
1195:   ) u_key_14 (
1196:     .re     (1'b0),
1197:     .we     (key_14_we),
1198:     .wd     (key_14_wd),
1199:     .d      (hw2reg.key[14].d),
1200:     .qre    (),
1201:     .qe     (key_14_flds_we[0]),
1202:     .q      (reg2hw.key[14].q),
1203:     .ds     (),
1204:     .qs     ()
1205:   );
1206:   assign reg2hw.key[14].qe = key_14_qe;
1207: 
1208: 
1209:   // Subregister 15 of Multireg key
1210:   // R[key_15]: V(True)
1211:   logic key_15_qe;
1212:   logic [0:0] key_15_flds_we;
1213:   assign key_15_qe = &key_15_flds_we;
1214:   prim_subreg_ext #(
1215:     .DW    (32)
1216:   ) u_key_15 (
1217:     .re     (1'b0),
1218:     .we     (key_15_we),
1219:     .wd     (key_15_wd),
1220:     .d      (hw2reg.key[15].d),
1221:     .qre    (),
1222:     .qe     (key_15_flds_we[0]),
1223:     .q      (reg2hw.key[15].q),
1224:     .ds     (),
1225:     .qs     ()
1226:   );
1227:   assign reg2hw.key[15].qe = key_15_qe;
1228: 
1229: 
1230:   // Subregister 16 of Multireg key
1231:   // R[key_16]: V(True)
1232:   logic key_16_qe;
1233:   logic [0:0] key_16_flds_we;
1234:   assign key_16_qe = &key_16_flds_we;
1235:   prim_subreg_ext #(
1236:     .DW    (32)
1237:   ) u_key_16 (
1238:     .re     (1'b0),
1239:     .we     (key_16_we),
1240:     .wd     (key_16_wd),
1241:     .d      (hw2reg.key[16].d),
1242:     .qre    (),
1243:     .qe     (key_16_flds_we[0]),
1244:     .q      (reg2hw.key[16].q),
1245:     .ds     (),
1246:     .qs     ()
1247:   );
1248:   assign reg2hw.key[16].qe = key_16_qe;
1249: 
1250: 
1251:   // Subregister 17 of Multireg key
1252:   // R[key_17]: V(True)
1253:   logic key_17_qe;
1254:   logic [0:0] key_17_flds_we;
1255:   assign key_17_qe = &key_17_flds_we;
1256:   prim_subreg_ext #(
1257:     .DW    (32)
1258:   ) u_key_17 (
1259:     .re     (1'b0),
1260:     .we     (key_17_we),
1261:     .wd     (key_17_wd),
1262:     .d      (hw2reg.key[17].d),
1263:     .qre    (),
1264:     .qe     (key_17_flds_we[0]),
1265:     .q      (reg2hw.key[17].q),
1266:     .ds     (),
1267:     .qs     ()
1268:   );
1269:   assign reg2hw.key[17].qe = key_17_qe;
1270: 
1271: 
1272:   // Subregister 18 of Multireg key
1273:   // R[key_18]: V(True)
1274:   logic key_18_qe;
1275:   logic [0:0] key_18_flds_we;
1276:   assign key_18_qe = &key_18_flds_we;
1277:   prim_subreg_ext #(
1278:     .DW    (32)
1279:   ) u_key_18 (
1280:     .re     (1'b0),
1281:     .we     (key_18_we),
1282:     .wd     (key_18_wd),
1283:     .d      (hw2reg.key[18].d),
1284:     .qre    (),
1285:     .qe     (key_18_flds_we[0]),
1286:     .q      (reg2hw.key[18].q),
1287:     .ds     (),
1288:     .qs     ()
1289:   );
1290:   assign reg2hw.key[18].qe = key_18_qe;
1291: 
1292: 
1293:   // Subregister 19 of Multireg key
1294:   // R[key_19]: V(True)
1295:   logic key_19_qe;
1296:   logic [0:0] key_19_flds_we;
1297:   assign key_19_qe = &key_19_flds_we;
1298:   prim_subreg_ext #(
1299:     .DW    (32)
1300:   ) u_key_19 (
1301:     .re     (1'b0),
1302:     .we     (key_19_we),
1303:     .wd     (key_19_wd),
1304:     .d      (hw2reg.key[19].d),
1305:     .qre    (),
1306:     .qe     (key_19_flds_we[0]),
1307:     .q      (reg2hw.key[19].q),
1308:     .ds     (),
1309:     .qs     ()
1310:   );
1311:   assign reg2hw.key[19].qe = key_19_qe;
1312: 
1313: 
1314:   // Subregister 20 of Multireg key
1315:   // R[key_20]: V(True)
1316:   logic key_20_qe;
1317:   logic [0:0] key_20_flds_we;
1318:   assign key_20_qe = &key_20_flds_we;
1319:   prim_subreg_ext #(
1320:     .DW    (32)
1321:   ) u_key_20 (
1322:     .re     (1'b0),
1323:     .we     (key_20_we),
1324:     .wd     (key_20_wd),
1325:     .d      (hw2reg.key[20].d),
1326:     .qre    (),
1327:     .qe     (key_20_flds_we[0]),
1328:     .q      (reg2hw.key[20].q),
1329:     .ds     (),
1330:     .qs     ()
1331:   );
1332:   assign reg2hw.key[20].qe = key_20_qe;
1333: 
1334: 
1335:   // Subregister 21 of Multireg key
1336:   // R[key_21]: V(True)
1337:   logic key_21_qe;
1338:   logic [0:0] key_21_flds_we;
1339:   assign key_21_qe = &key_21_flds_we;
1340:   prim_subreg_ext #(
1341:     .DW    (32)
1342:   ) u_key_21 (
1343:     .re     (1'b0),
1344:     .we     (key_21_we),
1345:     .wd     (key_21_wd),
1346:     .d      (hw2reg.key[21].d),
1347:     .qre    (),
1348:     .qe     (key_21_flds_we[0]),
1349:     .q      (reg2hw.key[21].q),
1350:     .ds     (),
1351:     .qs     ()
1352:   );
1353:   assign reg2hw.key[21].qe = key_21_qe;
1354: 
1355: 
1356:   // Subregister 22 of Multireg key
1357:   // R[key_22]: V(True)
1358:   logic key_22_qe;
1359:   logic [0:0] key_22_flds_we;
1360:   assign key_22_qe = &key_22_flds_we;
1361:   prim_subreg_ext #(
1362:     .DW    (32)
1363:   ) u_key_22 (
1364:     .re     (1'b0),
1365:     .we     (key_22_we),
1366:     .wd     (key_22_wd),
1367:     .d      (hw2reg.key[22].d),
1368:     .qre    (),
1369:     .qe     (key_22_flds_we[0]),
1370:     .q      (reg2hw.key[22].q),
1371:     .ds     (),
1372:     .qs     ()
1373:   );
1374:   assign reg2hw.key[22].qe = key_22_qe;
1375: 
1376: 
1377:   // Subregister 23 of Multireg key
1378:   // R[key_23]: V(True)
1379:   logic key_23_qe;
1380:   logic [0:0] key_23_flds_we;
1381:   assign key_23_qe = &key_23_flds_we;
1382:   prim_subreg_ext #(
1383:     .DW    (32)
1384:   ) u_key_23 (
1385:     .re     (1'b0),
1386:     .we     (key_23_we),
1387:     .wd     (key_23_wd),
1388:     .d      (hw2reg.key[23].d),
1389:     .qre    (),
1390:     .qe     (key_23_flds_we[0]),
1391:     .q      (reg2hw.key[23].q),
1392:     .ds     (),
1393:     .qs     ()
1394:   );
1395:   assign reg2hw.key[23].qe = key_23_qe;
1396: 
1397: 
1398:   // Subregister 24 of Multireg key
1399:   // R[key_24]: V(True)
1400:   logic key_24_qe;
1401:   logic [0:0] key_24_flds_we;
1402:   assign key_24_qe = &key_24_flds_we;
1403:   prim_subreg_ext #(
1404:     .DW    (32)
1405:   ) u_key_24 (
1406:     .re     (1'b0),
1407:     .we     (key_24_we),
1408:     .wd     (key_24_wd),
1409:     .d      (hw2reg.key[24].d),
1410:     .qre    (),
1411:     .qe     (key_24_flds_we[0]),
1412:     .q      (reg2hw.key[24].q),
1413:     .ds     (),
1414:     .qs     ()
1415:   );
1416:   assign reg2hw.key[24].qe = key_24_qe;
1417: 
1418: 
1419:   // Subregister 25 of Multireg key
1420:   // R[key_25]: V(True)
1421:   logic key_25_qe;
1422:   logic [0:0] key_25_flds_we;
1423:   assign key_25_qe = &key_25_flds_we;
1424:   prim_subreg_ext #(
1425:     .DW    (32)
1426:   ) u_key_25 (
1427:     .re     (1'b0),
1428:     .we     (key_25_we),
1429:     .wd     (key_25_wd),
1430:     .d      (hw2reg.key[25].d),
1431:     .qre    (),
1432:     .qe     (key_25_flds_we[0]),
1433:     .q      (reg2hw.key[25].q),
1434:     .ds     (),
1435:     .qs     ()
1436:   );
1437:   assign reg2hw.key[25].qe = key_25_qe;
1438: 
1439: 
1440:   // Subregister 26 of Multireg key
1441:   // R[key_26]: V(True)
1442:   logic key_26_qe;
1443:   logic [0:0] key_26_flds_we;
1444:   assign key_26_qe = &key_26_flds_we;
1445:   prim_subreg_ext #(
1446:     .DW    (32)
1447:   ) u_key_26 (
1448:     .re     (1'b0),
1449:     .we     (key_26_we),
1450:     .wd     (key_26_wd),
1451:     .d      (hw2reg.key[26].d),
1452:     .qre    (),
1453:     .qe     (key_26_flds_we[0]),
1454:     .q      (reg2hw.key[26].q),
1455:     .ds     (),
1456:     .qs     ()
1457:   );
1458:   assign reg2hw.key[26].qe = key_26_qe;
1459: 
1460: 
1461:   // Subregister 27 of Multireg key
1462:   // R[key_27]: V(True)
1463:   logic key_27_qe;
1464:   logic [0:0] key_27_flds_we;
1465:   assign key_27_qe = &key_27_flds_we;
1466:   prim_subreg_ext #(
1467:     .DW    (32)
1468:   ) u_key_27 (
1469:     .re     (1'b0),
1470:     .we     (key_27_we),
1471:     .wd     (key_27_wd),
1472:     .d      (hw2reg.key[27].d),
1473:     .qre    (),
1474:     .qe     (key_27_flds_we[0]),
1475:     .q      (reg2hw.key[27].q),
1476:     .ds     (),
1477:     .qs     ()
1478:   );
1479:   assign reg2hw.key[27].qe = key_27_qe;
1480: 
1481: 
1482:   // Subregister 28 of Multireg key
1483:   // R[key_28]: V(True)
1484:   logic key_28_qe;
1485:   logic [0:0] key_28_flds_we;
1486:   assign key_28_qe = &key_28_flds_we;
1487:   prim_subreg_ext #(
1488:     .DW    (32)
1489:   ) u_key_28 (
1490:     .re     (1'b0),
1491:     .we     (key_28_we),
1492:     .wd     (key_28_wd),
1493:     .d      (hw2reg.key[28].d),
1494:     .qre    (),
1495:     .qe     (key_28_flds_we[0]),
1496:     .q      (reg2hw.key[28].q),
1497:     .ds     (),
1498:     .qs     ()
1499:   );
1500:   assign reg2hw.key[28].qe = key_28_qe;
1501: 
1502: 
1503:   // Subregister 29 of Multireg key
1504:   // R[key_29]: V(True)
1505:   logic key_29_qe;
1506:   logic [0:0] key_29_flds_we;
1507:   assign key_29_qe = &key_29_flds_we;
1508:   prim_subreg_ext #(
1509:     .DW    (32)
1510:   ) u_key_29 (
1511:     .re     (1'b0),
1512:     .we     (key_29_we),
1513:     .wd     (key_29_wd),
1514:     .d      (hw2reg.key[29].d),
1515:     .qre    (),
1516:     .qe     (key_29_flds_we[0]),
1517:     .q      (reg2hw.key[29].q),
1518:     .ds     (),
1519:     .qs     ()
1520:   );
1521:   assign reg2hw.key[29].qe = key_29_qe;
1522: 
1523: 
1524:   // Subregister 30 of Multireg key
1525:   // R[key_30]: V(True)
1526:   logic key_30_qe;
1527:   logic [0:0] key_30_flds_we;
1528:   assign key_30_qe = &key_30_flds_we;
1529:   prim_subreg_ext #(
1530:     .DW    (32)
1531:   ) u_key_30 (
1532:     .re     (1'b0),
1533:     .we     (key_30_we),
1534:     .wd     (key_30_wd),
1535:     .d      (hw2reg.key[30].d),
1536:     .qre    (),
1537:     .qe     (key_30_flds_we[0]),
1538:     .q      (reg2hw.key[30].q),
1539:     .ds     (),
1540:     .qs     ()
1541:   );
1542:   assign reg2hw.key[30].qe = key_30_qe;
1543: 
1544: 
1545:   // Subregister 31 of Multireg key
1546:   // R[key_31]: V(True)
1547:   logic key_31_qe;
1548:   logic [0:0] key_31_flds_we;
1549:   assign key_31_qe = &key_31_flds_we;
1550:   prim_subreg_ext #(
1551:     .DW    (32)
1552:   ) u_key_31 (
1553:     .re     (1'b0),
1554:     .we     (key_31_we),
1555:     .wd     (key_31_wd),
1556:     .d      (hw2reg.key[31].d),
1557:     .qre    (),
1558:     .qe     (key_31_flds_we[0]),
1559:     .q      (reg2hw.key[31].q),
1560:     .ds     (),
1561:     .qs     ()
1562:   );
1563:   assign reg2hw.key[31].qe = key_31_qe;
1564: 
1565: 
1566:   // Subregister 0 of Multireg digest
1567:   // R[digest_0]: V(True)
1568:   logic digest_0_qe;
1569:   logic [0:0] digest_0_flds_we;
1570:   assign digest_0_qe = &digest_0_flds_we;
1571:   prim_subreg_ext #(
1572:     .DW    (32)
1573:   ) u_digest_0 (
1574:     .re     (digest_0_re),
1575:     .we     (digest_0_we),
1576:     .wd     (digest_0_wd),
1577:     .d      (hw2reg.digest[0].d),
1578:     .qre    (),
1579:     .qe     (digest_0_flds_we[0]),
1580:     .q      (reg2hw.digest[0].q),
1581:     .ds     (),
1582:     .qs     (digest_0_qs)
1583:   );
1584:   assign reg2hw.digest[0].qe = digest_0_qe;
1585: 
1586: 
1587:   // Subregister 1 of Multireg digest
1588:   // R[digest_1]: V(True)
1589:   logic digest_1_qe;
1590:   logic [0:0] digest_1_flds_we;
1591:   assign digest_1_qe = &digest_1_flds_we;
1592:   prim_subreg_ext #(
1593:     .DW    (32)
1594:   ) u_digest_1 (
1595:     .re     (digest_1_re),
1596:     .we     (digest_1_we),
1597:     .wd     (digest_1_wd),
1598:     .d      (hw2reg.digest[1].d),
1599:     .qre    (),
1600:     .qe     (digest_1_flds_we[0]),
1601:     .q      (reg2hw.digest[1].q),
1602:     .ds     (),
1603:     .qs     (digest_1_qs)
1604:   );
1605:   assign reg2hw.digest[1].qe = digest_1_qe;
1606: 
1607: 
1608:   // Subregister 2 of Multireg digest
1609:   // R[digest_2]: V(True)
1610:   logic digest_2_qe;
1611:   logic [0:0] digest_2_flds_we;
1612:   assign digest_2_qe = &digest_2_flds_we;
1613:   prim_subreg_ext #(
1614:     .DW    (32)
1615:   ) u_digest_2 (
1616:     .re     (digest_2_re),
1617:     .we     (digest_2_we),
1618:     .wd     (digest_2_wd),
1619:     .d      (hw2reg.digest[2].d),
1620:     .qre    (),
1621:     .qe     (digest_2_flds_we[0]),
1622:     .q      (reg2hw.digest[2].q),
1623:     .ds     (),
1624:     .qs     (digest_2_qs)
1625:   );
1626:   assign reg2hw.digest[2].qe = digest_2_qe;
1627: 
1628: 
1629:   // Subregister 3 of Multireg digest
1630:   // R[digest_3]: V(True)
1631:   logic digest_3_qe;
1632:   logic [0:0] digest_3_flds_we;
1633:   assign digest_3_qe = &digest_3_flds_we;
1634:   prim_subreg_ext #(
1635:     .DW    (32)
1636:   ) u_digest_3 (
1637:     .re     (digest_3_re),
1638:     .we     (digest_3_we),
1639:     .wd     (digest_3_wd),
1640:     .d      (hw2reg.digest[3].d),
1641:     .qre    (),
1642:     .qe     (digest_3_flds_we[0]),
1643:     .q      (reg2hw.digest[3].q),
1644:     .ds     (),
1645:     .qs     (digest_3_qs)
1646:   );
1647:   assign reg2hw.digest[3].qe = digest_3_qe;
1648: 
1649: 
1650:   // Subregister 4 of Multireg digest
1651:   // R[digest_4]: V(True)
1652:   logic digest_4_qe;
1653:   logic [0:0] digest_4_flds_we;
1654:   assign digest_4_qe = &digest_4_flds_we;
1655:   prim_subreg_ext #(
1656:     .DW    (32)
1657:   ) u_digest_4 (
1658:     .re     (digest_4_re),
1659:     .we     (digest_4_we),
1660:     .wd     (digest_4_wd),
1661:     .d      (hw2reg.digest[4].d),
1662:     .qre    (),
1663:     .qe     (digest_4_flds_we[0]),
1664:     .q      (reg2hw.digest[4].q),
1665:     .ds     (),
1666:     .qs     (digest_4_qs)
1667:   );
1668:   assign reg2hw.digest[4].qe = digest_4_qe;
1669: 
1670: 
1671:   // Subregister 5 of Multireg digest
1672:   // R[digest_5]: V(True)
1673:   logic digest_5_qe;
1674:   logic [0:0] digest_5_flds_we;
1675:   assign digest_5_qe = &digest_5_flds_we;
1676:   prim_subreg_ext #(
1677:     .DW    (32)
1678:   ) u_digest_5 (
1679:     .re     (digest_5_re),
1680:     .we     (digest_5_we),
1681:     .wd     (digest_5_wd),
1682:     .d      (hw2reg.digest[5].d),
1683:     .qre    (),
1684:     .qe     (digest_5_flds_we[0]),
1685:     .q      (reg2hw.digest[5].q),
1686:     .ds     (),
1687:     .qs     (digest_5_qs)
1688:   );
1689:   assign reg2hw.digest[5].qe = digest_5_qe;
1690: 
1691: 
1692:   // Subregister 6 of Multireg digest
1693:   // R[digest_6]: V(True)
1694:   logic digest_6_qe;
1695:   logic [0:0] digest_6_flds_we;
1696:   assign digest_6_qe = &digest_6_flds_we;
1697:   prim_subreg_ext #(
1698:     .DW    (32)
1699:   ) u_digest_6 (
1700:     .re     (digest_6_re),
1701:     .we     (digest_6_we),
1702:     .wd     (digest_6_wd),
1703:     .d      (hw2reg.digest[6].d),
1704:     .qre    (),
1705:     .qe     (digest_6_flds_we[0]),
1706:     .q      (reg2hw.digest[6].q),
1707:     .ds     (),
1708:     .qs     (digest_6_qs)
1709:   );
1710:   assign reg2hw.digest[6].qe = digest_6_qe;
1711: 
1712: 
1713:   // Subregister 7 of Multireg digest
1714:   // R[digest_7]: V(True)
1715:   logic digest_7_qe;
1716:   logic [0:0] digest_7_flds_we;
1717:   assign digest_7_qe = &digest_7_flds_we;
1718:   prim_subreg_ext #(
1719:     .DW    (32)
1720:   ) u_digest_7 (
1721:     .re     (digest_7_re),
1722:     .we     (digest_7_we),
1723:     .wd     (digest_7_wd),
1724:     .d      (hw2reg.digest[7].d),
1725:     .qre    (),
1726:     .qe     (digest_7_flds_we[0]),
1727:     .q      (reg2hw.digest[7].q),
1728:     .ds     (),
1729:     .qs     (digest_7_qs)
1730:   );
1731:   assign reg2hw.digest[7].qe = digest_7_qe;
1732: 
1733: 
1734:   // Subregister 8 of Multireg digest
1735:   // R[digest_8]: V(True)
1736:   logic digest_8_qe;
1737:   logic [0:0] digest_8_flds_we;
1738:   assign digest_8_qe = &digest_8_flds_we;
1739:   prim_subreg_ext #(
1740:     .DW    (32)
1741:   ) u_digest_8 (
1742:     .re     (digest_8_re),
1743:     .we     (digest_8_we),
1744:     .wd     (digest_8_wd),
1745:     .d      (hw2reg.digest[8].d),
1746:     .qre    (),
1747:     .qe     (digest_8_flds_we[0]),
1748:     .q      (reg2hw.digest[8].q),
1749:     .ds     (),
1750:     .qs     (digest_8_qs)
1751:   );
1752:   assign reg2hw.digest[8].qe = digest_8_qe;
1753: 
1754: 
1755:   // Subregister 9 of Multireg digest
1756:   // R[digest_9]: V(True)
1757:   logic digest_9_qe;
1758:   logic [0:0] digest_9_flds_we;
1759:   assign digest_9_qe = &digest_9_flds_we;
1760:   prim_subreg_ext #(
1761:     .DW    (32)
1762:   ) u_digest_9 (
1763:     .re     (digest_9_re),
1764:     .we     (digest_9_we),
1765:     .wd     (digest_9_wd),
1766:     .d      (hw2reg.digest[9].d),
1767:     .qre    (),
1768:     .qe     (digest_9_flds_we[0]),
1769:     .q      (reg2hw.digest[9].q),
1770:     .ds     (),
1771:     .qs     (digest_9_qs)
1772:   );
1773:   assign reg2hw.digest[9].qe = digest_9_qe;
1774: 
1775: 
1776:   // Subregister 10 of Multireg digest
1777:   // R[digest_10]: V(True)
1778:   logic digest_10_qe;
1779:   logic [0:0] digest_10_flds_we;
1780:   assign digest_10_qe = &digest_10_flds_we;
1781:   prim_subreg_ext #(
1782:     .DW    (32)
1783:   ) u_digest_10 (
1784:     .re     (digest_10_re),
1785:     .we     (digest_10_we),
1786:     .wd     (digest_10_wd),
1787:     .d      (hw2reg.digest[10].d),
1788:     .qre    (),
1789:     .qe     (digest_10_flds_we[0]),
1790:     .q      (reg2hw.digest[10].q),
1791:     .ds     (),
1792:     .qs     (digest_10_qs)
1793:   );
1794:   assign reg2hw.digest[10].qe = digest_10_qe;
1795: 
1796: 
1797:   // Subregister 11 of Multireg digest
1798:   // R[digest_11]: V(True)
1799:   logic digest_11_qe;
1800:   logic [0:0] digest_11_flds_we;
1801:   assign digest_11_qe = &digest_11_flds_we;
1802:   prim_subreg_ext #(
1803:     .DW    (32)
1804:   ) u_digest_11 (
1805:     .re     (digest_11_re),
1806:     .we     (digest_11_we),
1807:     .wd     (digest_11_wd),
1808:     .d      (hw2reg.digest[11].d),
1809:     .qre    (),
1810:     .qe     (digest_11_flds_we[0]),
1811:     .q      (reg2hw.digest[11].q),
1812:     .ds     (),
1813:     .qs     (digest_11_qs)
1814:   );
1815:   assign reg2hw.digest[11].qe = digest_11_qe;
1816: 
1817: 
1818:   // Subregister 12 of Multireg digest
1819:   // R[digest_12]: V(True)
1820:   logic digest_12_qe;
1821:   logic [0:0] digest_12_flds_we;
1822:   assign digest_12_qe = &digest_12_flds_we;
1823:   prim_subreg_ext #(
1824:     .DW    (32)
1825:   ) u_digest_12 (
1826:     .re     (digest_12_re),
1827:     .we     (digest_12_we),
1828:     .wd     (digest_12_wd),
1829:     .d      (hw2reg.digest[12].d),
1830:     .qre    (),
1831:     .qe     (digest_12_flds_we[0]),
1832:     .q      (reg2hw.digest[12].q),
1833:     .ds     (),
1834:     .qs     (digest_12_qs)
1835:   );
1836:   assign reg2hw.digest[12].qe = digest_12_qe;
1837: 
1838: 
1839:   // Subregister 13 of Multireg digest
1840:   // R[digest_13]: V(True)
1841:   logic digest_13_qe;
1842:   logic [0:0] digest_13_flds_we;
1843:   assign digest_13_qe = &digest_13_flds_we;
1844:   prim_subreg_ext #(
1845:     .DW    (32)
1846:   ) u_digest_13 (
1847:     .re     (digest_13_re),
1848:     .we     (digest_13_we),
1849:     .wd     (digest_13_wd),
1850:     .d      (hw2reg.digest[13].d),
1851:     .qre    (),
1852:     .qe     (digest_13_flds_we[0]),
1853:     .q      (reg2hw.digest[13].q),
1854:     .ds     (),
1855:     .qs     (digest_13_qs)
1856:   );
1857:   assign reg2hw.digest[13].qe = digest_13_qe;
1858: 
1859: 
1860:   // Subregister 14 of Multireg digest
1861:   // R[digest_14]: V(True)
1862:   logic digest_14_qe;
1863:   logic [0:0] digest_14_flds_we;
1864:   assign digest_14_qe = &digest_14_flds_we;
1865:   prim_subreg_ext #(
1866:     .DW    (32)
1867:   ) u_digest_14 (
1868:     .re     (digest_14_re),
1869:     .we     (digest_14_we),
1870:     .wd     (digest_14_wd),
1871:     .d      (hw2reg.digest[14].d),
1872:     .qre    (),
1873:     .qe     (digest_14_flds_we[0]),
1874:     .q      (reg2hw.digest[14].q),
1875:     .ds     (),
1876:     .qs     (digest_14_qs)
1877:   );
1878:   assign reg2hw.digest[14].qe = digest_14_qe;
1879: 
1880: 
1881:   // Subregister 15 of Multireg digest
1882:   // R[digest_15]: V(True)
1883:   logic digest_15_qe;
1884:   logic [0:0] digest_15_flds_we;
1885:   assign digest_15_qe = &digest_15_flds_we;
1886:   prim_subreg_ext #(
1887:     .DW    (32)
1888:   ) u_digest_15 (
1889:     .re     (digest_15_re),
1890:     .we     (digest_15_we),
1891:     .wd     (digest_15_wd),
1892:     .d      (hw2reg.digest[15].d),
1893:     .qre    (),
1894:     .qe     (digest_15_flds_we[0]),
1895:     .q      (reg2hw.digest[15].q),
1896:     .ds     (),
1897:     .qs     (digest_15_qs)
1898:   );
1899:   assign reg2hw.digest[15].qe = digest_15_qe;
1900: 
1901: 
1902:   // R[msg_length_lower]: V(True)
1903:   logic msg_length_lower_qe;
1904:   logic [0:0] msg_length_lower_flds_we;
1905:   assign msg_length_lower_qe = &msg_length_lower_flds_we;
1906:   prim_subreg_ext #(
1907:     .DW    (32)
1908:   ) u_msg_length_lower (
1909:     .re     (msg_length_lower_re),
1910:     .we     (msg_length_lower_we),
1911:     .wd     (msg_length_lower_wd),
1912:     .d      (hw2reg.msg_length_lower.d),
1913:     .qre    (),
1914:     .qe     (msg_length_lower_flds_we[0]),
1915:     .q      (reg2hw.msg_length_lower.q),
1916:     .ds     (),
1917:     .qs     (msg_length_lower_qs)
1918:   );
1919:   assign reg2hw.msg_length_lower.qe = msg_length_lower_qe;
1920: 
1921: 
1922:   // R[msg_length_upper]: V(True)
1923:   logic msg_length_upper_qe;
1924:   logic [0:0] msg_length_upper_flds_we;
1925:   assign msg_length_upper_qe = &msg_length_upper_flds_we;
1926:   prim_subreg_ext #(
1927:     .DW    (32)
1928:   ) u_msg_length_upper (
1929:     .re     (msg_length_upper_re),
1930:     .we     (msg_length_upper_we),
1931:     .wd     (msg_length_upper_wd),
1932:     .d      (hw2reg.msg_length_upper.d),
1933:     .qre    (),
1934:     .qe     (msg_length_upper_flds_we[0]),
1935:     .q      (reg2hw.msg_length_upper.q),
1936:     .ds     (),
1937:     .qs     (msg_length_upper_qs)
1938:   );
1939:   assign reg2hw.msg_length_upper.qe = msg_length_upper_qe;
1940: 
1941: 
1942: 
1943:   logic [58:0] addr_hit;
1944:   always_comb begin
1945:     addr_hit = '0;
1946:     addr_hit[ 0] = (reg_addr == HMAC_INTR_STATE_OFFSET);
1947:     addr_hit[ 1] = (reg_addr == HMAC_INTR_ENABLE_OFFSET);
1948:     addr_hit[ 2] = (reg_addr == HMAC_INTR_TEST_OFFSET);
1949:     addr_hit[ 3] = (reg_addr == HMAC_ALERT_TEST_OFFSET);
1950:     addr_hit[ 4] = (reg_addr == HMAC_CFG_OFFSET);
1951:     addr_hit[ 5] = (reg_addr == HMAC_CMD_OFFSET);
1952:     addr_hit[ 6] = (reg_addr == HMAC_STATUS_OFFSET);
1953:     addr_hit[ 7] = (reg_addr == HMAC_ERR_CODE_OFFSET);
1954:     addr_hit[ 8] = (reg_addr == HMAC_WIPE_SECRET_OFFSET);
1955:     addr_hit[ 9] = (reg_addr == HMAC_KEY_0_OFFSET);
1956:     addr_hit[10] = (reg_addr == HMAC_KEY_1_OFFSET);
1957:     addr_hit[11] = (reg_addr == HMAC_KEY_2_OFFSET);
1958:     addr_hit[12] = (reg_addr == HMAC_KEY_3_OFFSET);
1959:     addr_hit[13] = (reg_addr == HMAC_KEY_4_OFFSET);
1960:     addr_hit[14] = (reg_addr == HMAC_KEY_5_OFFSET);
1961:     addr_hit[15] = (reg_addr == HMAC_KEY_6_OFFSET);
1962:     addr_hit[16] = (reg_addr == HMAC_KEY_7_OFFSET);
1963:     addr_hit[17] = (reg_addr == HMAC_KEY_8_OFFSET);
1964:     addr_hit[18] = (reg_addr == HMAC_KEY_9_OFFSET);
1965:     addr_hit[19] = (reg_addr == HMAC_KEY_10_OFFSET);
1966:     addr_hit[20] = (reg_addr == HMAC_KEY_11_OFFSET);
1967:     addr_hit[21] = (reg_addr == HMAC_KEY_12_OFFSET);
1968:     addr_hit[22] = (reg_addr == HMAC_KEY_13_OFFSET);
1969:     addr_hit[23] = (reg_addr == HMAC_KEY_14_OFFSET);
1970:     addr_hit[24] = (reg_addr == HMAC_KEY_15_OFFSET);
1971:     addr_hit[25] = (reg_addr == HMAC_KEY_16_OFFSET);
1972:     addr_hit[26] = (reg_addr == HMAC_KEY_17_OFFSET);
1973:     addr_hit[27] = (reg_addr == HMAC_KEY_18_OFFSET);
1974:     addr_hit[28] = (reg_addr == HMAC_KEY_19_OFFSET);
1975:     addr_hit[29] = (reg_addr == HMAC_KEY_20_OFFSET);
1976:     addr_hit[30] = (reg_addr == HMAC_KEY_21_OFFSET);
1977:     addr_hit[31] = (reg_addr == HMAC_KEY_22_OFFSET);
1978:     addr_hit[32] = (reg_addr == HMAC_KEY_23_OFFSET);
1979:     addr_hit[33] = (reg_addr == HMAC_KEY_24_OFFSET);
1980:     addr_hit[34] = (reg_addr == HMAC_KEY_25_OFFSET);
1981:     addr_hit[35] = (reg_addr == HMAC_KEY_26_OFFSET);
1982:     addr_hit[36] = (reg_addr == HMAC_KEY_27_OFFSET);
1983:     addr_hit[37] = (reg_addr == HMAC_KEY_28_OFFSET);
1984:     addr_hit[38] = (reg_addr == HMAC_KEY_29_OFFSET);
1985:     addr_hit[39] = (reg_addr == HMAC_KEY_30_OFFSET);
1986:     addr_hit[40] = (reg_addr == HMAC_KEY_31_OFFSET);
1987:     addr_hit[41] = (reg_addr == HMAC_DIGEST_0_OFFSET);
1988:     addr_hit[42] = (reg_addr == HMAC_DIGEST_1_OFFSET);
1989:     addr_hit[43] = (reg_addr == HMAC_DIGEST_2_OFFSET);
1990:     addr_hit[44] = (reg_addr == HMAC_DIGEST_3_OFFSET);
1991:     addr_hit[45] = (reg_addr == HMAC_DIGEST_4_OFFSET);
1992:     addr_hit[46] = (reg_addr == HMAC_DIGEST_5_OFFSET);
1993:     addr_hit[47] = (reg_addr == HMAC_DIGEST_6_OFFSET);
1994:     addr_hit[48] = (reg_addr == HMAC_DIGEST_7_OFFSET);
1995:     addr_hit[49] = (reg_addr == HMAC_DIGEST_8_OFFSET);
1996:     addr_hit[50] = (reg_addr == HMAC_DIGEST_9_OFFSET);
1997:     addr_hit[51] = (reg_addr == HMAC_DIGEST_10_OFFSET);
1998:     addr_hit[52] = (reg_addr == HMAC_DIGEST_11_OFFSET);
1999:     addr_hit[53] = (reg_addr == HMAC_DIGEST_12_OFFSET);
2000:     addr_hit[54] = (reg_addr == HMAC_DIGEST_13_OFFSET);
2001:     addr_hit[55] = (reg_addr == HMAC_DIGEST_14_OFFSET);
2002:     addr_hit[56] = (reg_addr == HMAC_DIGEST_15_OFFSET);
2003:     addr_hit[57] = (reg_addr == HMAC_MSG_LENGTH_LOWER_OFFSET);
2004:     addr_hit[58] = (reg_addr == HMAC_MSG_LENGTH_UPPER_OFFSET);
2005:   end
2006: 
2007:   assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;
2008: 
2009:   // Check sub-word write is permitted
2010:   always_comb begin
2011:     wr_err = (reg_we &
2012:               ((addr_hit[ 0] & (|(HMAC_PERMIT[ 0] & ~reg_be))) |
2013:                (addr_hit[ 1] & (|(HMAC_PERMIT[ 1] & ~reg_be))) |
2014:                (addr_hit[ 2] & (|(HMAC_PERMIT[ 2] & ~reg_be))) |
2015:                (addr_hit[ 3] & (|(HMAC_PERMIT[ 3] & ~reg_be))) |
2016:                (addr_hit[ 4] & (|(HMAC_PERMIT[ 4] & ~reg_be))) |
2017:                (addr_hit[ 5] & (|(HMAC_PERMIT[ 5] & ~reg_be))) |
2018:                (addr_hit[ 6] & (|(HMAC_PERMIT[ 6] & ~reg_be))) |
2019:                (addr_hit[ 7] & (|(HMAC_PERMIT[ 7] & ~reg_be))) |
2020:                (addr_hit[ 8] & (|(HMAC_PERMIT[ 8] & ~reg_be))) |
2021:                (addr_hit[ 9] & (|(HMAC_PERMIT[ 9] & ~reg_be))) |
2022:                (addr_hit[10] & (|(HMAC_PERMIT[10] & ~reg_be))) |
2023:                (addr_hit[11] & (|(HMAC_PERMIT[11] & ~reg_be))) |
2024:                (addr_hit[12] & (|(HMAC_PERMIT[12] & ~reg_be))) |
2025:                (addr_hit[13] & (|(HMAC_PERMIT[13] & ~reg_be))) |
2026:                (addr_hit[14] & (|(HMAC_PERMIT[14] & ~reg_be))) |
2027:                (addr_hit[15] & (|(HMAC_PERMIT[15] & ~reg_be))) |
2028:                (addr_hit[16] & (|(HMAC_PERMIT[16] & ~reg_be))) |
2029:                (addr_hit[17] & (|(HMAC_PERMIT[17] & ~reg_be))) |
2030:                (addr_hit[18] & (|(HMAC_PERMIT[18] & ~reg_be))) |
2031:                (addr_hit[19] & (|(HMAC_PERMIT[19] & ~reg_be))) |
2032:                (addr_hit[20] & (|(HMAC_PERMIT[20] & ~reg_be))) |
2033:                (addr_hit[21] & (|(HMAC_PERMIT[21] & ~reg_be))) |
2034:                (addr_hit[22] & (|(HMAC_PERMIT[22] & ~reg_be))) |
2035:                (addr_hit[23] & (|(HMAC_PERMIT[23] & ~reg_be))) |
2036:                (addr_hit[24] & (|(HMAC_PERMIT[24] & ~reg_be))) |
2037:                (addr_hit[25] & (|(HMAC_PERMIT[25] & ~reg_be))) |
2038:                (addr_hit[26] & (|(HMAC_PERMIT[26] & ~reg_be))) |
2039:                (addr_hit[27] & (|(HMAC_PERMIT[27] & ~reg_be))) |
2040:                (addr_hit[28] & (|(HMAC_PERMIT[28] & ~reg_be))) |
2041:                (addr_hit[29] & (|(HMAC_PERMIT[29] & ~reg_be))) |
2042:                (addr_hit[30] & (|(HMAC_PERMIT[30] & ~reg_be))) |
2043:                (addr_hit[31] & (|(HMAC_PERMIT[31] & ~reg_be))) |
2044:                (addr_hit[32] & (|(HMAC_PERMIT[32] & ~reg_be))) |
2045:                (addr_hit[33] & (|(HMAC_PERMIT[33] & ~reg_be))) |
2046:                (addr_hit[34] & (|(HMAC_PERMIT[34] & ~reg_be))) |
2047:                (addr_hit[35] & (|(HMAC_PERMIT[35] & ~reg_be))) |
2048:                (addr_hit[36] & (|(HMAC_PERMIT[36] & ~reg_be))) |
2049:                (addr_hit[37] & (|(HMAC_PERMIT[37] & ~reg_be))) |
2050:                (addr_hit[38] & (|(HMAC_PERMIT[38] & ~reg_be))) |
2051:                (addr_hit[39] & (|(HMAC_PERMIT[39] & ~reg_be))) |
2052:                (addr_hit[40] & (|(HMAC_PERMIT[40] & ~reg_be))) |
2053:                (addr_hit[41] & (|(HMAC_PERMIT[41] & ~reg_be))) |
2054:                (addr_hit[42] & (|(HMAC_PERMIT[42] & ~reg_be))) |
2055:                (addr_hit[43] & (|(HMAC_PERMIT[43] & ~reg_be))) |
2056:                (addr_hit[44] & (|(HMAC_PERMIT[44] & ~reg_be))) |
2057:                (addr_hit[45] & (|(HMAC_PERMIT[45] & ~reg_be))) |
2058:                (addr_hit[46] & (|(HMAC_PERMIT[46] & ~reg_be))) |
2059:                (addr_hit[47] & (|(HMAC_PERMIT[47] & ~reg_be))) |
2060:                (addr_hit[48] & (|(HMAC_PERMIT[48] & ~reg_be))) |
2061:                (addr_hit[49] & (|(HMAC_PERMIT[49] & ~reg_be))) |
2062:                (addr_hit[50] & (|(HMAC_PERMIT[50] & ~reg_be))) |
2063:                (addr_hit[51] & (|(HMAC_PERMIT[51] & ~reg_be))) |
2064:                (addr_hit[52] & (|(HMAC_PERMIT[52] & ~reg_be))) |
2065:                (addr_hit[53] & (|(HMAC_PERMIT[53] & ~reg_be))) |
2066:                (addr_hit[54] & (|(HMAC_PERMIT[54] & ~reg_be))) |
2067:                (addr_hit[55] & (|(HMAC_PERMIT[55] & ~reg_be))) |
2068:                (addr_hit[56] & (|(HMAC_PERMIT[56] & ~reg_be))) |
2069:                (addr_hit[57] & (|(HMAC_PERMIT[57] & ~reg_be))) |
2070:                (addr_hit[58] & (|(HMAC_PERMIT[58] & ~reg_be)))));
2071:   end
2072: 
2073:   // Generate write-enables
2074:   assign intr_state_we = addr_hit[0] & reg_we & !reg_error;
2075: 
2076:   assign intr_state_hmac_done_wd = reg_wdata[0];
2077: 
2078:   assign intr_state_hmac_err_wd = reg_wdata[2];
2079:   assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;
2080: 
2081:   assign intr_enable_hmac_done_wd = reg_wdata[0];
2082: 
2083:   assign intr_enable_fifo_empty_wd = reg_wdata[1];
2084: 
2085:   assign intr_enable_hmac_err_wd = reg_wdata[2];
2086:   assign intr_test_we = addr_hit[2] & reg_we & !reg_error;
2087: 
2088:   assign intr_test_hmac_done_wd = reg_wdata[0];
2089: 
2090:   assign intr_test_fifo_empty_wd = reg_wdata[1];
2091: 
2092:   assign intr_test_hmac_err_wd = reg_wdata[2];
2093:   assign alert_test_we = addr_hit[3] & reg_we & !reg_error;
2094: 
2095:   assign alert_test_wd = reg_wdata[0];
2096:   assign cfg_re = addr_hit[4] & reg_re & !reg_error;
2097:   assign cfg_we = addr_hit[4] & reg_we & !reg_error;
2098: 
2099:   assign cfg_hmac_en_wd = reg_wdata[0];
2100: 
2101:   assign cfg_sha_en_wd = reg_wdata[1];
2102: 
2103:   assign cfg_endian_swap_wd = reg_wdata[2];
2104: 
2105:   assign cfg_digest_swap_wd = reg_wdata[3];
2106: 
2107:   assign cfg_key_swap_wd = reg_wdata[4];
2108: 
2109:   assign cfg_digest_size_wd = reg_wdata[8:5];
2110: 
2111:   assign cfg_key_length_wd = reg_wdata[14:9];
2112:   assign cmd_we = addr_hit[5] & reg_we & !reg_error;
2113: 
2114:   assign cmd_hash_start_wd = reg_wdata[0];
2115: 
2116:   assign cmd_hash_process_wd = reg_wdata[1];
2117: 
2118:   assign cmd_hash_stop_wd = reg_wdata[2];
2119: 
2120:   assign cmd_hash_continue_wd = reg_wdata[3];
2121:   assign status_re = addr_hit[6] & reg_re & !reg_error;
2122:   assign wipe_secret_we = addr_hit[8] & reg_we & reg_error;
2123: 
2124:   assign wipe_secret_wd = reg_wdata[31:0];
2125:   assign key_0_we = addr_hit[9] & reg_we & !reg_error;
2126: 
2127:   assign key_0_wd = reg_wdata[31:0];
2128:   assign key_1_we = addr_hit[10] & reg_we & !reg_error;
2129: 
2130:   assign key_1_wd = reg_wdata[31:0];
2131:   assign key_2_we = addr_hit[11] & reg_we & !reg_error;
2132: 
2133:   assign key_2_wd = reg_wdata[31:0];
2134:   assign key_3_we = addr_hit[12] & reg_we & !reg_error;
2135: 
2136:   assign key_3_wd = reg_wdata[31:0];
2137:   assign key_4_we = addr_hit[13] & reg_we & !reg_error;
2138: 
2139:   assign key_4_wd = reg_wdata[31:0];
2140:   assign key_5_we = addr_hit[14] & reg_we & !reg_error;
2141: 
2142:   assign key_5_wd = reg_wdata[31:0];
2143:   assign key_6_we = addr_hit[15] & reg_we & !reg_error;
2144: 
2145:   assign key_6_wd = reg_wdata[31:0];
2146:   assign key_7_we = addr_hit[16] & reg_we & !reg_error;
2147: 
2148:   assign key_7_wd = reg_wdata[31:0];
2149:   assign key_8_we = addr_hit[17] & reg_we & !reg_error;
2150: 
2151:   assign key_8_wd = reg_wdata[31:0];
2152:   assign key_9_we = addr_hit[18] & reg_we & !reg_error;
2153: 
2154:   assign key_9_wd = reg_wdata[31:0];
2155:   assign key_10_we = addr_hit[19] & reg_we & !reg_error;
2156: 
2157:   assign key_10_wd = reg_wdata[31:0];
2158:   assign key_11_we = addr_hit[20] & reg_we & !reg_error;
2159: 
2160:   assign key_11_wd = reg_wdata[31:0];
2161:   assign key_12_we = addr_hit[21] & reg_we & !reg_error;
2162: 
2163:   assign key_12_wd = reg_wdata[31:0];
2164:   assign key_13_we = addr_hit[22] & reg_we & !reg_error;
2165: 
2166:   assign key_13_wd = reg_wdata[31:0];
2167:   assign key_14_we = addr_hit[23] & reg_we & !reg_error;
2168: 
2169:   assign key_14_wd = reg_wdata[31:0];
2170:   assign key_15_we = addr_hit[24] & reg_we & !reg_error;
2171: 
2172:   assign key_15_wd = reg_wdata[31:0];
2173:   assign key_16_we = addr_hit[25] & reg_we & !reg_error;
2174: 
2175:   assign key_16_wd = reg_wdata[31:0];
2176:   assign key_17_we = addr_hit[26] & reg_we & !reg_error;
2177: 
2178:   assign key_17_wd = reg_wdata[31:0];
2179:   assign key_18_we = addr_hit[27] & reg_we & !reg_error;
2180: 
2181:   assign key_18_wd = reg_wdata[31:0];
2182:   assign key_19_we = addr_hit[28] & reg_we & !reg_error;
2183: 
2184:   assign key_19_wd = reg_wdata[31:0];
2185:   assign key_20_we = addr_hit[29] & reg_we & !reg_error;
2186: 
2187:   assign key_20_wd = reg_wdata[31:0];
2188:   assign key_21_we = addr_hit[30] & reg_we & !reg_error;
2189: 
2190:   assign key_21_wd = reg_wdata[31:0];
2191:   assign key_22_we = addr_hit[31] & reg_we & !reg_error;
2192: 
2193:   assign key_22_wd = reg_wdata[31:0];
2194:   assign key_23_we = addr_hit[32] & reg_we & !reg_error;
2195: 
2196:   assign key_23_wd = reg_wdata[31:0];
2197:   assign key_24_we = addr_hit[33] & reg_we & !reg_error;
2198: 
2199:   assign key_24_wd = reg_wdata[31:0];
2200:   assign key_25_we = addr_hit[34] & reg_we & !reg_error;
2201: 
2202:   assign key_25_wd = reg_wdata[31:0];
2203:   assign key_26_we = addr_hit[35] & reg_we & !reg_error;
2204: 
2205:   assign key_26_wd = reg_wdata[31:0];
2206:   assign key_27_we = addr_hit[36] & reg_we & !reg_error;
2207: 
2208:   assign key_27_wd = reg_wdata[31:0];
2209:   assign key_28_we = addr_hit[37] & reg_we & !reg_error;
2210: 
2211:   assign key_28_wd = reg_wdata[31:0];
2212:   assign key_29_we = addr_hit[38] & reg_we & !reg_error;
2213: 
2214:   assign key_29_wd = reg_wdata[31:0];
2215:   assign key_30_we = addr_hit[39] & reg_we & !reg_error;
2216: 
2217:   assign key_30_wd = reg_wdata[31:0];
2218:   assign key_31_we = addr_hit[40] & reg_we & !reg_error;
2219: 
2220:   assign key_31_wd = reg_wdata[31:0];
2221:   assign digest_0_re = addr_hit[41] & reg_re & !reg_error;
2222:   assign digest_0_we = addr_hit[41] & reg_we & !reg_error;
2223: 
2224:   assign digest_0_wd = reg_wdata[31:0];
2225:   assign digest_1_re = addr_hit[42] & reg_re & !reg_error;
2226:   assign digest_1_we = addr_hit[42] & reg_we & !reg_error;
2227: 
2228:   assign digest_1_wd = reg_wdata[31:0];
2229:   assign digest_2_re = addr_hit[43] & reg_re & !reg_error;
2230:   assign digest_2_we = addr_hit[43] & reg_we & !reg_error;
2231: 
2232:   assign digest_2_wd = reg_wdata[31:0];
2233:   assign digest_3_re = addr_hit[44] & reg_re & !reg_error;
2234:   assign digest_3_we = addr_hit[44] & reg_we & !reg_error;
2235: 
2236:   assign digest_3_wd = reg_wdata[31:0];
2237:   assign digest_4_re = addr_hit[45] & reg_re & !reg_error;
2238:   assign digest_4_we = addr_hit[45] & reg_we & !reg_error;
2239: 
2240:   assign digest_4_wd = reg_wdata[31:0];
2241:   assign digest_5_re = addr_hit[46] & reg_re & !reg_error;
2242:   assign digest_5_we = addr_hit[46] & reg_we & !reg_error;
2243: 
2244:   assign digest_5_wd = reg_wdata[31:0];
2245:   assign digest_6_re = addr_hit[47] & reg_re & !reg_error;
2246:   assign digest_6_we = addr_hit[47] & reg_we & !reg_error;
2247: 
2248:   assign digest_6_wd = reg_wdata[31:0];
2249:   assign digest_7_re = addr_hit[48] & reg_re & !reg_error;
2250:   assign digest_7_we = addr_hit[48] & reg_we & !reg_error;
2251: 
2252:   assign digest_7_wd = reg_wdata[31:0];
2253:   assign digest_8_re = addr_hit[49] & reg_re & !reg_error;
2254:   assign digest_8_we = addr_hit[49] & reg_we & !reg_error;
2255: 
2256:   assign digest_8_wd = reg_wdata[31:0];
2257:   assign digest_9_re = addr_hit[50] & reg_re & !reg_error;
2258:   assign digest_9_we = addr_hit[50] & reg_we & !reg_error;
2259: 
2260:   assign digest_9_wd = reg_wdata[31:0];
2261:   assign digest_10_re = addr_hit[51] & reg_re & !reg_error;
2262:   assign digest_10_we = addr_hit[51] & reg_we & !reg_error;
2263: 
2264:   assign digest_10_wd = reg_wdata[31:0];
2265:   assign digest_11_re = addr_hit[52] & reg_re & !reg_error;
2266:   assign digest_11_we = addr_hit[52] & reg_we & !reg_error;
2267: 
2268:   assign digest_11_wd = reg_wdata[31:0];
2269:   assign digest_12_re = addr_hit[53] & reg_re & !reg_error;
2270:   assign digest_12_we = addr_hit[53] & reg_we & !reg_error;
2271: 
2272:   assign digest_12_wd = reg_wdata[31:0];
2273:   assign digest_13_re = addr_hit[54] & reg_re & !reg_error;
2274:   assign digest_13_we = addr_hit[54] & reg_we & !reg_error;
2275: 
2276:   assign digest_13_wd = reg_wdata[31:0];
2277:   assign digest_14_re = addr_hit[55] & reg_re & !reg_error;
2278:   assign digest_14_we = addr_hit[55] & reg_we & !reg_error;
2279: 
2280:   assign digest_14_wd = reg_wdata[31:0];
2281:   assign digest_15_re = addr_hit[56] & reg_re & !reg_error;
2282:   assign digest_15_we = addr_hit[56] & reg_we & !reg_error;
2283: 
2284:   assign digest_15_wd = reg_wdata[31:0];
2285:   assign msg_length_lower_re = addr_hit[57] & reg_re & !reg_error;
2286:   assign msg_length_lower_we = addr_hit[57] & reg_we & !reg_error;
2287: 
2288:   assign msg_length_lower_wd = reg_wdata[31:0];
2289:   assign msg_length_upper_re = addr_hit[58] & reg_re & !reg_error;
2290:   assign msg_length_upper_we = addr_hit[58] & reg_we & !reg_error;
2291: 
2292:   assign msg_length_upper_wd = reg_wdata[31:0];
2293: 
2294:   // Assign write-enables to checker logic vector.
2295:   always_comb begin
2296:     reg_we_check = '0;
2297:     reg_we_check[0] = intr_state_we;
2298:     reg_we_check[1] = intr_enable_we;
2299:     reg_we_check[2] = intr_test_we;
2300:     reg_we_check[3] = alert_test_we;
2301:     reg_we_check[4] = cfg_we;
2302:     reg_we_check[5] = cmd_we;
2303:     reg_we_check[6] = 1'b0;
2304:     reg_we_check[7] = 1'b0;
2305:     reg_we_check[8] = wipe_secret_we;
2306:     reg_we_check[9] = key_0_we;
2307:     reg_we_check[10] = key_1_we;
2308:     reg_we_check[11] = key_2_we;
2309:     reg_we_check[12] = key_3_we;
2310:     reg_we_check[13] = key_4_we;
2311:     reg_we_check[14] = key_5_we;
2312:     reg_we_check[15] = key_6_we;
2313:     reg_we_check[16] = key_7_we;
2314:     reg_we_check[17] = key_8_we;
2315:     reg_we_check[18] = key_9_we;
2316:     reg_we_check[19] = key_10_we;
2317:     reg_we_check[20] = key_11_we;
2318:     reg_we_check[21] = key_12_we;
2319:     reg_we_check[22] = key_13_we;
2320:     reg_we_check[23] = key_14_we;
2321:     reg_we_check[24] = key_15_we;
2322:     reg_we_check[25] = key_16_we;
2323:     reg_we_check[26] = key_17_we;
2324:     reg_we_check[27] = key_18_we;
2325:     reg_we_check[28] = key_19_we;
2326:     reg_we_check[29] = key_20_we;
2327:     reg_we_check[30] = key_21_we;
2328:     reg_we_check[31] = key_22_we;
2329:     reg_we_check[32] = key_23_we;
2330:     reg_we_check[33] = key_24_we;
2331:     reg_we_check[34] = key_25_we;
2332:     reg_we_check[35] = key_26_we;
2333:     reg_we_check[36] = key_27_we;
2334:     reg_we_check[37] = key_28_we;
2335:     reg_we_check[38] = key_29_we;
2336:     reg_we_check[39] = key_30_we;
2337:     reg_we_check[40] = key_31_we;
2338:     reg_we_check[41] = digest_0_we;
2339:     reg_we_check[42] = digest_1_we;
2340:     reg_we_check[43] = digest_2_we;
2341:     reg_we_check[44] = digest_3_we;
2342:     reg_we_check[45] = digest_4_we;
2343:     reg_we_check[46] = digest_5_we;
2344:     reg_we_check[47] = digest_6_we;
2345:     reg_we_check[48] = digest_7_we;
2346:     reg_we_check[49] = digest_8_we;
2347:     reg_we_check[50] = digest_9_we;
2348:     reg_we_check[51] = digest_10_we;
2349:     reg_we_check[52] = digest_11_we;
2350:     reg_we_check[53] = digest_12_we;
2351:     reg_we_check[54] = digest_13_we;
2352:     reg_we_check[55] = digest_14_we;
2353:     reg_we_check[56] = digest_15_we;
2354:     reg_we_check[57] = msg_length_lower_we;
2355:     reg_we_check[58] = msg_length_upper_we;
2356:   end
2357: 
2358:   // Read data return
2359:   always_comb begin
2360:     reg_rdata_next = '0;
2361:     unique case (1'b1)
2362:       addr_hit[0]: begin
2363:         reg_rdata_next[0] = intr_state_hmac_done_qs;
2364:         reg_rdata_next[1] = intr_state_fifo_empty_qs;
2365:         reg_rdata_next[2] = intr_state_hmac_err_qs;
2366:       end
2367: 
2368:       addr_hit[1]: begin
2369:         reg_rdata_next[0] = intr_enable_hmac_done_qs;
2370:         reg_rdata_next[1] = intr_enable_fifo_empty_qs;
2371:         reg_rdata_next[2] = intr_enable_hmac_err_qs;
2372:       end
2373: 
2374:       addr_hit[2]: begin
2375:         reg_rdata_next[0] = '0;
2376:         reg_rdata_next[1] = '0;
2377:         reg_rdata_next[2] = '0;
2378:       end
2379: 
2380:       addr_hit[3]: begin
2381:         reg_rdata_next[0] = '0;
2382:       end
2383: 
2384:       addr_hit[4]: begin
2385:         reg_rdata_next[0] = cfg_hmac_en_qs;
2386:         reg_rdata_next[1] = cfg_sha_en_qs;
2387:         reg_rdata_next[2] = cfg_endian_swap_qs;
2388:         reg_rdata_next[3] = cfg_digest_swap_qs;
2389:         reg_rdata_next[4] = cfg_key_swap_qs;
2390:         reg_rdata_next[8:5] = cfg_digest_size_qs;
2391:         reg_rdata_next[14:9] = cfg_key_length_qs;
2392:       end
2393: 
2394:       addr_hit[5]: begin
2395:         reg_rdata_next[0] = '0;
2396:         reg_rdata_next[1] = '0;
2397:         reg_rdata_next[2] = '0;
2398:         reg_rdata_next[3] = '0;
2399:       end
2400: 
2401:       addr_hit[6]: begin
2402:         reg_rdata_next[0] = status_hmac_idle_qs;
2403:         reg_rdata_next[1] = status_fifo_empty_qs;
2404:         reg_rdata_next[2] = status_fifo_full_qs;
2405:         reg_rdata_next[9:4] = status_fifo_depth_qs;
2406:       end
2407: 
2408:       addr_hit[7]: begin
2409:         reg_rdata_next[31:0] = err_code_qs;
2410:       end
2411: 
2412:       addr_hit[8]: begin
2413:         reg_rdata_next[31:0] = reg2hw.key[0].q;
2414:       end
2415: 
2416:       addr_hit[9]: begin
2417:         reg_rdata_next[31:0] = reg2hw.key[1].q;
2418:       end
2419: 
2420:       addr_hit[10]: begin
2421:         reg_rdata_next[31:0] = '0;
2422:       end
2423: 
2424:       addr_hit[11]: begin
2425:         reg_rdata_next[31:0] = '0;
2426:       end
2427: 
2428:       addr_hit[12]: begin
2429:         reg_rdata_next[31:0] = '0;
2430:       end
2431: 
2432:       addr_hit[13]: begin
2433:         reg_rdata_next[31:0] = '0;
2434:       end
2435: 
2436:       addr_hit[14]: begin
2437:         reg_rdata_next[31:0] = '0;
2438:       end
2439: 
2440:       addr_hit[15]: begin
2441:         reg_rdata_next[31:0] = '0;
2442:       end
2443: 
2444:       addr_hit[16]: begin
2445:         reg_rdata_next[31:0] = '0;
2446:       end
2447: 
2448:       addr_hit[17]: begin
2449:         reg_rdata_next[31:0] = '0;
2450:       end
2451: 
2452:       addr_hit[18]: begin
2453:         reg_rdata_next[31:0] = '0;
2454:       end
2455: 
2456:       addr_hit[19]: begin
2457:         reg_rdata_next[31:0] = '0;
2458:       end
2459: 
2460:       addr_hit[20]: begin
2461:         reg_rdata_next[31:0] = '0;
2462:       end
2463: 
2464:       addr_hit[21]: begin
2465:         reg_rdata_next[31:0] = '0;
2466:       end
2467: 
2468:       addr_hit[22]: begin
2469:         reg_rdata_next[31:0] = '0;
2470:       end
2471: 
2472:       addr_hit[23]: begin
2473:         reg_rdata_next[31:0] = '0;
2474:       end
2475: 
2476:       addr_hit[24]: begin
2477:         reg_rdata_next[31:0] = '0;
2478:       end
2479: 
2480:       addr_hit[25]: begin
2481:         reg_rdata_next[31:0] = '0;
2482:       end
2483: 
2484:       addr_hit[26]: begin
2485:         reg_rdata_next[31:0] = '0;
2486:       end
2487: 
2488:       addr_hit[27]: begin
2489:         reg_rdata_next[31:0] = '0;
2490:       end
2491: 
2492:       addr_hit[28]: begin
2493:         reg_rdata_next[31:0] = '0;
2494:       end
2495: 
2496:       addr_hit[29]: begin
2497:         reg_rdata_next[31:0] = '0;
2498:       end
2499: 
2500:       addr_hit[30]: begin
2501:         reg_rdata_next[31:0] = '0;
2502:       end
2503: 
2504:       addr_hit[31]: begin
2505:         reg_rdata_next[31:0] = '0;
2506:       end
2507: 
2508:       addr_hit[32]: begin
2509:         reg_rdata_next[31:0] = '0;
2510:       end
2511: 
2512:       addr_hit[33]: begin
2513:         reg_rdata_next[31:0] = '0;
2514:       end
2515: 
2516:       addr_hit[34]: begin
2517:         reg_rdata_next[31:0] = '0;
2518:       end
2519: 
2520:       addr_hit[35]: begin
2521:         reg_rdata_next[31:0] = '0;
2522:       end
2523: 
2524:       addr_hit[36]: begin
2525:         reg_rdata_next[31:0] = '0;
2526:       end
2527: 
2528:       addr_hit[37]: begin
2529:         reg_rdata_next[31:0] = '0;
2530:       end
2531: 
2532:       addr_hit[38]: begin
2533:         reg_rdata_next[31:0] = '0;
2534:       end
2535: 
2536:       addr_hit[39]: begin
2537:         reg_rdata_next[31:0] = '0;
2538:       end
2539: 
2540:       addr_hit[40]: begin
2541:         reg_rdata_next[31:0] = '0;
2542:       end
2543: 
2544:       addr_hit[41]: begin
2545:         reg_rdata_next[31:0] = digest_0_qs;
2546:       end
2547: 
2548:       addr_hit[42]: begin
2549:         reg_rdata_next[31:0] = digest_1_qs;
2550:       end
2551: 
2552:       addr_hit[43]: begin
2553:         reg_rdata_next[31:0] = digest_2_qs;
2554:       end
2555: 
2556:       addr_hit[44]: begin
2557:         reg_rdata_next[31:0] = digest_3_qs;
2558:       end
2559: 
2560:       addr_hit[45]: begin
2561:         reg_rdata_next[31:0] = digest_4_qs;
2562:       end
2563: 
2564:       addr_hit[46]: begin
2565:         reg_rdata_next[31:0] = digest_5_qs;
2566:       end
2567: 
2568:       addr_hit[47]: begin
2569:         reg_rdata_next[31:0] = digest_6_qs;
2570:       end
2571: 
2572:       addr_hit[48]: begin
2573:         reg_rdata_next[31:0] = digest_7_qs;
2574:       end
2575: 
2576:       addr_hit[49]: begin
2577:         reg_rdata_next[31:0] = digest_8_qs;
2578:       end
2579: 
2580:       addr_hit[50]: begin
2581:         reg_rdata_next[31:0] = digest_9_qs;
2582:       end
2583: 
2584:       addr_hit[51]: begin
2585:         reg_rdata_next[31:0] = digest_10_qs;
2586:       end
2587: 
2588:       addr_hit[52]: begin
2589:         reg_rdata_next[31:0] = digest_11_qs;
2590:       end
2591: 
2592:       addr_hit[53]: begin
2593:         reg_rdata_next[31:0] = digest_12_qs;
2594:       end
2595: 
2596:       addr_hit[54]: begin
2597:         reg_rdata_next[31:0] = digest_13_qs;
2598:       end
2599: 
2600:       addr_hit[55]: begin
2601:         reg_rdata_next[31:0] = digest_14_qs;
2602:       end
2603: 
2604:       addr_hit[56]: begin
2605:         reg_rdata_next[31:0] = digest_15_qs;
2606:       end
2607: 
2608:       addr_hit[57]: begin
2609:         reg_rdata_next[31:0] = msg_length_lower_qs;
2610:       end
2611: 
2612:       addr_hit[58]: begin
2613:         reg_rdata_next[31:0] = msg_length_upper_qs;
2614:       end
2615: 
2616:       default: begin
2617:         reg_rdata_next = reg2hw.key[2].q;
2618:       end
2619:     endcase
2620:   end
2621: 
2622:   // shadow busy
2623:   logic shadow_busy;
2624:   assign shadow_busy = 1'b0;
2625: 
2626:   // register busy
2627:   assign reg_busy = shadow_busy;
2628: 
2629:   // Unused signal tieoff
2630: 
2631:   // wdata / byte enable are not always fully used
2632:   // add a blanket unused statement to handle lint waivers
2633:   logic unused_wdata;
2634:   logic unused_be;
2635:   assign unused_wdata = ^reg_wdata;
2636:   assign unused_be = ^reg_be;
2637: 
2638:   // Assertions for Register Interface
2639:   `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
2640:   `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)
2641: 
2642:   `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)
2643: 
2644:   `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)
2645: 
2646:   // this is formulated as an assumption such that the FPV testbenches do disprove this
2647:   // property by mistake
2648:   //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)
2649: 
2650: endmodule

================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Register Top module auto-generated by `reggen`
6: 
7: `include "prim_assert.sv"
8: 
9: module hmac_reg_top (
10:   input clk_i,
11:   input rst_ni,
12:   input  tlul_pkg::tl_h2d_t tl_i,
13:   output tlul_pkg::tl_d2h_t tl_o,
14: 
15:   // Output port for window
16:   output tlul_pkg::tl_h2d_t tl_win_o,
17:   input  tlul_pkg::tl_d2h_t tl_win_i,
18: 
19:   // To HW
20:   output hmac_reg_pkg::hmac_reg2hw_t reg2hw, // Write
21:   input  hmac_reg_pkg::hmac_hw2reg_t hw2reg, // Read
22: 
23:   // Integrity check errors
24:   output logic intg_err_o
25: );
26: 
27:   import hmac_reg_pkg::* ;
28: 
29:   localparam int AW = 13;
30:   localparam int DW = 32;
31:   localparam int DBW = DW/8;                    // Byte Width
32: 
33:   // register signals
34:   logic           reg_we;
35:   logic           reg_re;
36:   logic [AW-1:0]  reg_addr;
37:   logic [DW-1:0]  reg_wdata;
38:   logic [DBW-1:0] reg_be;
39:   logic [DW-1:0]  reg_rdata;
40:   logic           reg_error;
41: 
42:   logic          addrmiss, wr_err;
43: 
44:   logic [DW-1:0] reg_rdata_next;
45:   logic reg_busy;
46: 
47:   tlul_pkg::tl_h2d_t tl_reg_h2d;
48:   tlul_pkg::tl_d2h_t tl_reg_d2h;
49: 
50: 
51:   // incoming payload check
52:   logic intg_err;
53:   tlul_cmd_intg_chk u_chk (
54:     .tl_i(tl_i),
55:     .err_o(intg_err)
56:   );
57: 
58:   // also check for spurious write enables
59:   logic reg_we_err;
60:   logic [58:0] reg_we_check;
61:   prim_reg_we_check #(
62:     .OneHotWidth(59)
63:   ) u_prim_reg_we_check (
64:     .clk_i(clk_i),
65:     .rst_ni(rst_ni),
66:     .oh_i  (reg_we_check),
67:     .en_i  (reg_we && !addrmiss),
68:     .err_o (reg_we_err)
69:   );
70: 
71:   logic err_q;
72:   always_ff @(posedge clk_i or negedge rst_ni) begin
73:     if (!rst_ni) begin
74:       err_q <= '0;
75:     end else if (intg_err || reg_we_err) begin
76:       err_q <= 1'b1;
77:     end
78:   end
79: 
80:   // integrity error output is permanent and should be used for alert generation
81:   // register errors are transactional
82:   assign intg_err_o = err_q | intg_err | reg_we_err;
83: 
84:   // outgoing integrity generation
85:   tlul_pkg::tl_d2h_t tl_o_pre;
86:   tlul_rsp_intg_gen #(
87:     .EnableRspIntgGen(1),
88:     .EnableDataIntgGen(1)
89:   ) u_rsp_intg_gen (
90:     .tl_i(tl_o_pre),
91:     .tl_o(tl_o)
92:   );
93: 
94:   tlul_pkg::tl_h2d_t tl_socket_h2d [2];
95:   tlul_pkg::tl_d2h_t tl_socket_d2h [2];
96: 
97:   logic [0:0] reg_steer;
98: 
99:   // socket_1n connection
100:   assign tl_reg_h2d = tl_socket_h2d[1];
101:   assign tl_socket_d2h[1] = tl_reg_d2h;
102: 
103:   assign tl_win_o = tl_socket_h2d[0];
104:   assign tl_socket_d2h[0] = tl_win_i;
105: 
106:   // Create Socket_1n
107:   tlul_socket_1n #(
108:     .N            (2),
109:     .HReqPass     (1'b1),
110:     .HRspPass     (1'b1),
111:     .DReqPass     ({2{1'b1}}),
112:     .DRspPass     ({2{1'b1}}),
113:     .HReqDepth    (4'h0),
114:     .HRspDepth    (4'h0),
115:     .DReqDepth    ({2{4'h0}}),
116:     .DRspDepth    ({2{4'h0}}),
117:     .ExplicitErrs (1'b0)
118:   ) u_socket (
119:     .clk_i  (clk_i),
120:     .rst_ni (rst_ni),
121:     .tl_h_i (tl_i),
122:     .tl_h_o (tl_o_pre),
123:     .tl_d_o (tl_socket_h2d),
124:     .tl_d_i (tl_socket_d2h),
125:     .dev_select_i (reg_steer)
126:   );
127: 
128:   // Create steering logic
129:   always_comb begin
130:     reg_steer =
131:         tl_i.a_address[AW-1:0] inside {[4096:8191]} ? 1'd0 :
132:         // Default set to register
133:         1'd1;
134: 
135:     // Override this in case of an integrity error
136:     if (intg_err) begin
137:       reg_steer = 1'd1;
138:     end
139:   end
140: 
141:   tlul_adapter_reg #(
142:     .RegAw(AW),
143:     .RegDw(DW),
144:     .EnableDataIntgGen(0)
145:   ) u_reg_if (
146:     .clk_i  (clk_i),
147:     .rst_ni (rst_ni),
148: 
149:     .tl_i (tl_reg_h2d),
150:     .tl_o (tl_reg_d2h),
151: 
152:     .en_ifetch_i(prim_mubi_pkg::MuBi4False),
153:     .intg_error_o(),
154: 
155:     .we_o    (reg_we),
156:     .re_o    (reg_re),
157:     .addr_o  (reg_addr),
158:     .wdata_o (reg_wdata),
159:     .be_o    (reg_be),
160:     .busy_i  (reg_busy),
161:     .rdata_i (reg_rdata),
162:     .error_i (reg_error)
163:   );
164: 
165:   // cdc oversampling signals
166: 
167:   assign reg_rdata = reg_rdata_next ;
168:   assign reg_error = addrmiss | wr_err | intg_err;
169: 
170:   // Define SW related signals
171:   // Format: <reg>_<field>_{wd|we|qs}
172:   //        or <reg>_{wd|we|qs} if field == 1 or 0
173:   logic intr_state_we;
174:   logic intr_state_hmac_done_qs;
175:   logic intr_state_hmac_done_wd;
176:   logic intr_state_fifo_empty_qs;
177:   logic intr_state_hmac_err_qs;
178:   logic intr_state_hmac_err_wd;
179:   logic intr_enable_we;
180:   logic intr_enable_hmac_done_qs;
181:   logic intr_enable_hmac_done_wd;
182:   logic intr_enable_fifo_empty_qs;
183:   logic intr_enable_fifo_empty_wd;
184:   logic intr_enable_hmac_err_qs;
185:   logic intr_enable_hmac_err_wd;
186:   logic intr_test_we;
187:   logic intr_test_hmac_done_wd;
188:   logic intr_test_fifo_empty_wd;
189:   logic intr_test_hmac_err_wd;
190:   logic alert_test_we;
191:   logic alert_test_wd;
192:   logic cfg_re;
193:   logic cfg_we;
194:   logic cfg_hmac_en_qs;
195:   logic cfg_hmac_en_wd;
196:   logic cfg_sha_en_qs;
197:   logic cfg_sha_en_wd;
198:   logic cfg_endian_swap_qs;
199:   logic cfg_endian_swap_wd;
200:   logic cfg_digest_swap_qs;
201:   logic cfg_digest_swap_wd;
202:   logic cfg_key_swap_qs;
203:   logic cfg_key_swap_wd;
204:   logic [3:0] cfg_digest_size_qs;
205:   logic [3:0] cfg_digest_size_wd;
206:   logic [5:0] cfg_key_length_qs;
207:   logic [5:0] cfg_key_length_wd;
208:   logic cmd_we;
209:   logic cmd_hash_start_wd;
210:   logic cmd_hash_process_wd;
211:   logic cmd_hash_stop_wd;
212:   logic cmd_hash_continue_wd;
213:   logic status_re;
214:   logic status_hmac_idle_qs;
215:   logic status_fifo_empty_qs;
216:   logic status_fifo_full_qs;
217:   logic [5:0] status_fifo_depth_qs;
218:   logic [31:0] err_code_qs;
219:   logic wipe_secret_we;
220:   logic [31:0] wipe_secret_wd;
221:   logic key_0_we;
222:   logic [31:0] key_0_wd;
223:   logic key_1_we;
224:   logic [31:0] key_1_wd;
225:   logic key_2_we;
226:   logic [31:0] key_2_wd;
227:   logic key_3_we;
228:   logic [31:0] key_3_wd;
229:   logic key_4_we;
230:   logic [31:0] key_4_wd;
231:   logic key_5_we;
232:   logic [31:0] key_5_wd;
233:   logic key_6_we;
234:   logic [31:0] key_6_wd;
235:   logic key_7_we;
236:   logic [31:0] key_7_wd;
237:   logic key_8_we;
238:   logic [31:0] key_8_wd;
239:   logic key_9_we;
240:   logic [31:0] key_9_wd;
241:   logic key_10_we;
242:   logic [31:0] key_10_wd;
243:   logic key_11_we;
244:   logic [31:0] key_11_wd;
245:   logic key_12_we;
246:   logic [31:0] key_12_wd;
247:   logic key_13_we;
248:   logic [31:0] key_13_wd;
249:   logic key_14_we;
250:   logic [31:0] key_14_wd;
251:   logic key_15_we;
252:   logic [31:0] key_15_wd;
253:   logic key_16_we;
254:   logic [31:0] key_16_wd;
255:   logic key_17_we;
256:   logic [31:0] key_17_wd;
257:   logic key_18_we;
258:   logic [31:0] key_18_wd;
259:   logic key_19_we;
260:   logic [31:0] key_19_wd;
261:   logic key_20_we;
262:   logic [31:0] key_20_wd;
263:   logic key_21_we;
264:   logic [31:0] key_21_wd;
265:   logic key_22_we;
266:   logic [31:0] key_22_wd;
267:   logic key_23_we;
268:   logic [31:0] key_23_wd;
269:   logic key_24_we;
270:   logic [31:0] key_24_wd;
271:   logic key_25_we;
272:   logic [31:0] key_25_wd;
273:   logic key_26_we;
274:   logic [31:0] key_26_wd;
275:   logic key_27_we;
276:   logic [31:0] key_27_wd;
277:   logic key_28_we;
278:   logic [31:0] key_28_wd;
279:   logic key_29_we;
280:   logic [31:0] key_29_wd;
281:   logic key_30_we;
282:   logic [31:0] key_30_wd;
283:   logic key_31_we;
284:   logic [31:0] key_31_wd;
285:   logic digest_0_re;
286:   logic digest_0_we;
287:   logic [31:0] digest_0_qs;
288:   logic [31:0] digest_0_wd;
289:   logic digest_1_re;
290:   logic digest_1_we;
291:   logic [31:0] digest_1_qs;
292:   logic [31:0] digest_1_wd;
293:   logic digest_2_re;
294:   logic digest_2_we;
295:   logic [31:0] digest_2_qs;
296:   logic [31:0] digest_2_wd;
297:   logic digest_3_re;
298:   logic digest_3_we;
299:   logic [31:0] digest_3_qs;
300:   logic [31:0] digest_3_wd;
301:   logic digest_4_re;
302:   logic digest_4_we;
303:   logic [31:0] digest_4_qs;
304:   logic [31:0] digest_4_wd;
305:   logic digest_5_re;
306:   logic digest_5_we;
307:   logic [31:0] digest_5_qs;
308:   logic [31:0] digest_5_wd;
309:   logic digest_6_re;
310:   logic digest_6_we;
311:   logic [31:0] digest_6_qs;
312:   logic [31:0] digest_6_wd;
313:   logic digest_7_re;
314:   logic digest_7_we;
315:   logic [31:0] digest_7_qs;
316:   logic [31:0] digest_7_wd;
317:   logic digest_8_re;
318:   logic digest_8_we;
319:   logic [31:0] digest_8_qs;
320:   logic [31:0] digest_8_wd;
321:   logic digest_9_re;
322:   logic digest_9_we;
323:   logic [31:0] digest_9_qs;
324:   logic [31:0] digest_9_wd;
325:   logic digest_10_re;
326:   logic digest_10_we;
327:   logic [31:0] digest_10_qs;
328:   logic [31:0] digest_10_wd;
329:   logic digest_11_re;
330:   logic digest_11_we;
331:   logic [31:0] digest_11_qs;
332:   logic [31:0] digest_11_wd;
333:   logic digest_12_re;
334:   logic digest_12_we;
335:   logic [31:0] digest_12_qs;
336:   logic [31:0] digest_12_wd;
337:   logic digest_13_re;
338:   logic digest_13_we;
339:   logic [31:0] digest_13_qs;
340:   logic [31:0] digest_13_wd;
341:   logic digest_14_re;
342:   logic digest_14_we;
343:   logic [31:0] digest_14_qs;
344:   logic [31:0] digest_14_wd;
345:   logic digest_15_re;
346:   logic digest_15_we;
347:   logic [31:0] digest_15_qs;
348:   logic [31:0] digest_15_wd;
349:   logic msg_length_lower_re;
350:   logic msg_length_lower_we;
351:   logic [31:0] msg_length_lower_qs;
352:   logic [31:0] msg_length_lower_wd;
353:   logic msg_length_upper_re;
354:   logic msg_length_upper_we;
355:   logic [31:0] msg_length_upper_qs;
356:   logic [31:0] msg_length_upper_wd;
357: 
358:   // Register instances
359:   // R[intr_state]: V(False)
360:   //   F[hmac_done]: 0:0
361:   prim_subreg #(
362:     .DW      (1),
363:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
364:     .RESVAL  (1'h0),
365:     .Mubi    (1'b0)
366:   ) u_intr_state_hmac_done (
367:     .clk_i   (clk_i),
368:     .rst_ni  (rst_ni),
369: 
370:     // from register interface
371:     .we     (intr_state_we),
372:     .wd     (intr_state_hmac_done_wd),
373: 
374:     // from internal hardware
375:     .de     (hw2reg.intr_state.hmac_done.de),
376:     .d      (hw2reg.intr_state.hmac_done.d),
377: 
378:     // to internal hardware
379:     .qe     (),
380:     .q      (reg2hw.intr_state.hmac_done.q),
381:     .ds     (),
382: 
383:     // to register interface (read)
384:     .qs     (intr_state_hmac_done_qs)
385:   );
386: 
387:   //   F[fifo_empty]: 1:1
388:   prim_subreg #(
389:     .DW      (1),
390:     .SwAccess(prim_subreg_pkg::SwAccessRO),
391:     .RESVAL  (1'h0),
392:     .Mubi    (1'b0)
393:   ) u_intr_state_fifo_empty (
394:     .clk_i   (clk_i),
395:     .rst_ni  (rst_ni),
396: 
397:     // from register interface
398:     .we     (1'b0),
399:     .wd     ('0),
400: 
401:     // from internal hardware
402:     .de     (hw2reg.intr_state.fifo_empty.de),
403:     .d      (hw2reg.intr_state.fifo_empty.d),
404: 
405:     // to internal hardware
406:     .qe     (),
407:     .q      (reg2hw.intr_state.fifo_empty.q),
408:     .ds     (),
409: 
410:     // to register interface (read)
411:     .qs     (intr_state_fifo_empty_qs)
412:   );
413: 
414:   //   F[hmac_err]: 2:2
415:   prim_subreg #(
416:     .DW      (1),
417:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
418:     .RESVAL  (1'h0),
419:     .Mubi    (1'b0)
420:   ) u_intr_state_hmac_err (
421:     .clk_i   (clk_i),
422:     .rst_ni  (rst_ni),
423: 
424:     // from register interface
425:     .we     (intr_state_we),
426:     .wd     (intr_state_hmac_err_wd),
427: 
428:     // from internal hardware
429:     .de     (hw2reg.intr_state.hmac_err.de),
430:     .d      (hw2reg.intr_state.hmac_err.d),
431: 
432:     // to internal hardware
433:     .qe     (),
434:     .q      (reg2hw.intr_state.hmac_err.q),
435:     .ds     (),
436: 
437:     // to register interface (read)
438:     .qs     (intr_state_hmac_err_qs)
439:   );
440: 
441: 
442:   // R[intr_enable]: V(False)
443:   //   F[hmac_done]: 0:0
444:   prim_subreg #(
445:     .DW      (1),
446:     .SwAccess(prim_subreg_pkg::SwAccessRW),
447:     .RESVAL  (1'h0),
448:     .Mubi    (1'b0)
449:   ) u_intr_enable_hmac_done (
450:     .clk_i   (clk_i),
451:     .rst_ni  (rst_ni),
452: 
453:     // from register interface
454:     .we     (intr_enable_we),
455:     .wd     (intr_enable_hmac_done_wd),
456: 
457:     // from internal hardware
458:     .de     (1'b0),
459:     .d      ('0),
460: 
461:     // to internal hardware
462:     .qe     (),
463:     .q      (reg2hw.intr_enable.hmac_done.q),
464:     .ds     (),
465: 
466:     // to register interface (read)
467:     .qs     (intr_enable_hmac_done_qs)
468:   );
469: 
470:   //   F[fifo_empty]: 1:1
471:   prim_subreg #(
472:     .DW      (1),
473:     .SwAccess(prim_subreg_pkg::SwAccessRW),
474:     .RESVAL  (1'h0),
475:     .Mubi    (1'b0)
476:   ) u_intr_enable_fifo_empty (
477:     .clk_i   (clk_i),
478:     .rst_ni  (rst_ni),
479: 
480:     // from register interface
481:     .we     (intr_enable_we),
482:     .wd     (intr_enable_fifo_empty_wd),
483: 
484:     // from internal hardware
485:     .de     (1'b0),
486:     .d      ('0),
487: 
488:     // to internal hardware
489:     .qe     (),
490:     .q      (reg2hw.intr_enable.fifo_empty.q),
491:     .ds     (),
492: 
493:     // to register interface (read)
494:     .qs     (intr_enable_fifo_empty_qs)
495:   );
496: 
497:   //   F[hmac_err]: 2:2
498:   prim_subreg #(
499:     .DW      (1),
500:     .SwAccess(prim_subreg_pkg::SwAccessRW),
501:     .RESVAL  (1'h0),
502:     .Mubi    (1'b0)
503:   ) u_intr_enable_hmac_err (
504:     .clk_i   (clk_i),
505:     .rst_ni  (rst_ni),
506: 
507:     // from register interface
508:     .we     (intr_enable_we),
509:     .wd     (intr_enable_hmac_err_wd),
510: 
511:     // from internal hardware
512:     .de     (1'b0),
513:     .d      ('0),
514: 
515:     // to internal hardware
516:     .qe     (),
517:     .q      (reg2hw.intr_enable.hmac_err.q),
518:     .ds     (),
519: 
520:     // to register interface (read)
521:     .qs     (intr_enable_hmac_err_qs)
522:   );
523: 
524: 
525:   // R[intr_test]: V(True)
526:   logic intr_test_qe;
527:   logic [2:0] intr_test_flds_we;
528:   assign intr_test_qe = &intr_test_flds_we;
529:   //   F[hmac_done]: 0:0
530:   prim_subreg_ext #(
531:     .DW    (1)
532:   ) u_intr_test_hmac_done (
533:     .re     (1'b0),
534:     .we     (intr_test_we),
535:     .wd     (intr_test_hmac_done_wd),
536:     .d      ('0),
537:     .qre    (),
538:     .qe     (intr_test_flds_we[0]),
539:     .q      (reg2hw.intr_test.hmac_done.q),
540:     .ds     (),
541:     .qs     ()
542:   );
543:   assign reg2hw.intr_test.hmac_done.qe = intr_test_qe;
544: 
545:   //   F[fifo_empty]: 1:1
546:   prim_subreg_ext #(
547:     .DW    (1)
548:   ) u_intr_test_fifo_empty (
549:     .re     (1'b0),
550:     .we     (intr_test_we),
551:     .wd     (intr_test_fifo_empty_wd),
552:     .d      ('0),
553:     .qre    (),
554:     .qe     (intr_test_flds_we[1]),
555:     .q      (reg2hw.intr_test.fifo_empty.q),
556:     .ds     (),
557:     .qs     ()
558:   );
559:   assign reg2hw.intr_test.fifo_empty.qe = intr_test_qe;
560: 
561:   //   F[hmac_err]: 2:2
562:   prim_subreg_ext #(
563:     .DW    (1)
564:   ) u_intr_test_hmac_err (
565:     .re     (1'b0),
566:     .we     (intr_test_we),
567:     .wd     (intr_test_hmac_err_wd),
568:     .d      ('0),
569:     .qre    (),
570:     .qe     (intr_test_flds_we[2]),
571:     .q      (reg2hw.intr_test.hmac_err.q),
572:     .ds     (),
573:     .qs     ()
574:   );
575:   assign reg2hw.intr_test.hmac_err.qe = intr_test_qe;
576: 
577: 
578:   // R[alert_test]: V(True)
579:   logic alert_test_qe;
580:   logic [0:0] alert_test_flds_we;
581:   assign alert_test_qe = &alert_test_flds_we;
582:   prim_subreg_ext #(
583:     .DW    (1)
584:   ) u_alert_test (
585:     .re     (1'b0),
586:     .we     (alert_test_we),
587:     .wd     (alert_test_wd),
588:     .d      ('0),
589:     .qre    (),
590:     .qe     (alert_test_flds_we[0]),
591:     .q      (reg2hw.alert_test.q),
592:     .ds     (),
593:     .qs     ()
594:   );
595:   assign reg2hw.alert_test.qe = alert_test_qe;
596: 
597: 
598:   // R[cfg]: V(True)
599:   logic cfg_qe;
600:   logic [6:0] cfg_flds_we;
601:   assign cfg_qe = &cfg_flds_we;
602:   //   F[hmac_en]: 0:0
603:   prim_subreg_ext #(
604:     .DW    (1)
605:   ) u_cfg_hmac_en (
606:     .re     (cfg_re),
607:     .we     (cfg_we),
608:     .wd     (cfg_hmac_en_wd),
609:     .d      (hw2reg.cfg.hmac_en.d),
610:     .qre    (),
611:     .qe     (cfg_flds_we[0]),
612:     .q      (reg2hw.cfg.hmac_en.q),
613:     .ds     (),
614:     .qs     (cfg_hmac_en_qs)
615:   );
616:   assign reg2hw.cfg.hmac_en.qe = cfg_qe;
617: 
618:   //   F[sha_en]: 1:1
619:   prim_subreg_ext #(
620:     .DW    (1)
621:   ) u_cfg_sha_en (
622:     .re     (cfg_re),
623:     .we     (cfg_we),
624:     .wd     (cfg_sha_en_wd),
625:     .d      (hw2reg.cfg.sha_en.d),
626:     .qre    (),
627:     .qe     (cfg_flds_we[1]),
628:     .q      (reg2hw.cfg.sha_en.q),
629:     .ds     (),
630:     .qs     (cfg_sha_en_qs)
631:   );
632:   assign reg2hw.cfg.sha_en.qe = cfg_qe;
633: 
634:   //   F[endian_swap]: 2:2
635:   prim_subreg_ext #(
636:     .DW    (1)
637:   ) u_cfg_endian_swap (
638:     .re     (cfg_re),
639:     .we     (cfg_we),
640:     .wd     (cfg_endian_swap_wd),
641:     .d      (hw2reg.cfg.endian_swap.d),
642:     .qre    (),
643:     .qe     (cfg_flds_we[2]),
644:     .q      (reg2hw.cfg.endian_swap.q),
645:     .ds     (),
646:     .qs     (cfg_endian_swap_qs)
647:   );
648:   assign reg2hw.cfg.endian_swap.qe = cfg_qe;
649: 
650:   //   F[digest_swap]: 3:3
651:   prim_subreg_ext #(
652:     .DW    (1)
653:   ) u_cfg_digest_swap (
654:     .re     (cfg_re),
655:     .we     (cfg_we),
656:     .wd     (cfg_digest_swap_wd),
657:     .d      (hw2reg.cfg.digest_swap.d),
658:     .qre    (),
659:     .qe     (cfg_flds_we[3]),
660:     .q      (reg2hw.cfg.digest_swap.q),
661:     .ds     (),
662:     .qs     (cfg_digest_swap_qs)
663:   );
664:   assign reg2hw.cfg.digest_swap.qe = cfg_qe;
665: 
666:   //   F[key_swap]: 4:4
667:   prim_subreg_ext #(
668:     .DW    (1)
669:   ) u_cfg_key_swap (
670:     .re     (cfg_re),
671:     .we     (cfg_we),
672:     .wd     (cfg_key_swap_wd),
673:     .d      (hw2reg.cfg.key_swap.d),
674:     .qre    (),
675:     .qe     (cfg_flds_we[4]),
676:     .q      (reg2hw.cfg.key_swap.q),
677:     .ds     (),
678:     .qs     (cfg_key_swap_qs)
679:   );
680:   assign reg2hw.cfg.key_swap.qe = cfg_qe;
681: 
682:   //   F[digest_size]: 8:5
683:   prim_subreg_ext #(
684:     .DW    (4)
685:   ) u_cfg_digest_size (
686:     .re     (cfg_re),
687:     .we     (cfg_we),
688:     .wd     (cfg_digest_size_wd),
689:     .d      (hw2reg.cfg.digest_size.d),
690:     .qre    (),
691:     .qe     (cfg_flds_we[5]),
692:     .q      (reg2hw.cfg.digest_size.q),
693:     .ds     (),
694:     .qs     (cfg_digest_size_qs)
695:   );
696:   assign reg2hw.cfg.digest_size.qe = cfg_qe;
697: 
698:   //   F[key_length]: 14:9
699:   prim_subreg_ext #(
700:     .DW    (6)
701:   ) u_cfg_key_length (
702:     .re     (cfg_re),
703:     .we     (cfg_we),
704:     .wd     (cfg_key_length_wd),
705:     .d      (hw2reg.cfg.key_length.d),
706:     .qre    (),
707:     .qe     (cfg_flds_we[6]),
708:     .q      (reg2hw.cfg.key_length.q),
709:     .ds     (),
710:     .qs     (cfg_key_length_qs)
711:   );
712:   assign reg2hw.cfg.key_length.qe = cfg_qe;
713: 
714: 
715:   // R[cmd]: V(True)
716:   logic cmd_qe;
717:   logic [3:0] cmd_flds_we;
718:   assign cmd_qe = &cmd_flds_we;
719:   //   F[hash_start]: 0:0
720:   prim_subreg_ext #(
721:     .DW    (1)
722:   ) u_cmd_hash_start (
723:     .re     (1'b0),
724:     .we     (cmd_we),
725:     .wd     (cmd_hash_start_wd),
726:     .d      ('0),
727:     .qre    (),
728:     .qe     (cmd_flds_we[0]),
729:     .q      (reg2hw.cmd.hash_start.q),
730:     .ds     (),
731:     .qs     ()
732:   );
733:   assign reg2hw.cmd.hash_start.qe = cmd_qe;
734: 
735:   //   F[hash_process]: 1:1
736:   prim_subreg_ext #(
737:     .DW    (1)
738:   ) u_cmd_hash_process (
739:     .re     (1'b0),
740:     .we     (cmd_we),
741:     .wd     (cmd_hash_process_wd),
742:     .d      ('0),
743:     .qre    (),
744:     .qe     (cmd_flds_we[1]),
745:     .q      (reg2hw.cmd.hash_process.q),
746:     .ds     (),
747:     .qs     ()
748:   );
749:   assign reg2hw.cmd.hash_process.qe = cmd_qe;
750: 
751:   //   F[hash_stop]: 2:2
752:   prim_subreg_ext #(
753:     .DW    (1)
754:   ) u_cmd_hash_stop (
755:     .re     (1'b0),
756:     .we     (cmd_we),
757:     .wd     (cmd_hash_stop_wd),
758:     .d      ('0),
759:     .qre    (),
760:     .qe     (cmd_flds_we[2]),
761:     .q      (reg2hw.cmd.hash_stop.q),
762:     .ds     (),
763:     .qs     ()
764:   );
765:   assign reg2hw.cmd.hash_stop.qe = cmd_qe;
766: 
767:   //   F[hash_continue]: 3:3
768:   prim_subreg_ext #(
769:     .DW    (1)
770:   ) u_cmd_hash_continue (
771:     .re     (1'b0),
772:     .we     (cmd_we),
773:     .wd     (cmd_hash_continue_wd),
774:     .d      ('0),
775:     .qre    (),
776:     .qe     (cmd_flds_we[3]),
777:     .q      (reg2hw.cmd.hash_continue.q),
778:     .ds     (),
779:     .qs     ()
780:   );
781:   assign reg2hw.cmd.hash_continue.qe = cmd_qe;
782: 
783: 
784:   // R[status]: V(True)
785:   //   F[hmac_idle]: 0:0
786:   prim_subreg_ext #(
787:     .DW    (1)
788:   ) u_status_hmac_idle (
789:     .re     (status_re),
790:     .we     (1'b0),
791:     .wd     ('0),
792:     .d      (hw2reg.status.hmac_idle.d),
793:     .qre    (),
794:     .qe     (),
795:     .q      (),
796:     .ds     (),
797:     .qs     (status_hmac_idle_qs)
798:   );
799: 
800:   //   F[fifo_empty]: 1:1
801:   prim_subreg_ext #(
802:     .DW    (1)
803:   ) u_status_fifo_empty (
804:     .re     (status_re),
805:     .we     (1'b0),
806:     .wd     ('0),
807:     .d      (hw2reg.status.fifo_empty.d),
808:     .qre    (),
809:     .qe     (),
810:     .q      (),
811:     .ds     (),
812:     .qs     (status_fifo_empty_qs)
813:   );
814: 
815:   //   F[fifo_full]: 2:2
816:   prim_subreg_ext #(
817:     .DW    (1)
818:   ) u_status_fifo_full (
819:     .re     (status_re),
820:     .we     (1'b0),
821:     .wd     ('0),
822:     .d      (hw2reg.status.fifo_full.d),
823:     .qre    (),
824:     .qe     (),
825:     .q      (),
826:     .ds     (),
827:     .qs     (status_fifo_full_qs)
828:   );
829: 
830:   //   F[fifo_depth]: 9:4
831:   prim_subreg_ext #(
832:     .DW    (6)
833:   ) u_status_fifo_depth (
834:     .re     (status_re),
835:     .we     (1'b0),
836:     .wd     ('0),
837:     .d      (hw2reg.status.fifo_depth.d),
838:     .qre    (),
839:     .qe     (),
840:     .q      (),
841:     .ds     (),
842:     .qs     (status_fifo_depth_qs)
843:   );
844: 
845: 
846:   // R[err_code]: V(False)
847:   prim_subreg #(
848:     .DW      (32),
849:     .SwAccess(prim_subreg_pkg::SwAccessRO),
850:     .RESVAL  (32'h0),
851:     .Mubi    (1'b0)
852:   ) u_err_code (
853:     .clk_i   (clk_i),
854:     .rst_ni  (rst_ni),
855: 
856:     // from register interface
857:     .we     (1'b0),
858:     .wd     ('0),
859: 
860:     // from internal hardware
861:     .de     (hw2reg.err_code.de),
862:     .d      (hw2reg.err_code.d),
863: 
864:     // to internal hardware
865:     .qe     (),
866:     .q      (),
867:     .ds     (),
868: 
869:     // to register interface (read)
870:     .qs     (err_code_qs)
871:   );
872: 
873: 
874:   // R[wipe_secret]: V(True)
875:   logic wipe_secret_qe;
876:   logic [0:0] wipe_secret_flds_we;
877:   assign wipe_secret_qe = &wipe_secret_flds_we;
878:   prim_subreg_ext #(
879:     .DW    (32)
880:   ) u_wipe_secret (
881:     .re     (1'b0),
882:     .we     (wipe_secret_we),
883:     .wd     (wipe_secret_wd),
884:     .d      ('0),
885:     .qre    (),
886:     .qe     (wipe_secret_flds_we[0]),
887:     .q      (reg2hw.wipe_secret.q),
888:     .ds     (),
889:     .qs     ()
890:   );
891:   assign reg2hw.wipe_secret.qe = wipe_secret_qe;
892: 
893: 
894:   // Subregister 0 of Multireg key
895:   // R[key_0]: V(True)
896:   logic key_0_qe;
897:   logic [0:0] key_0_flds_we;
898:   assign key_0_qe = &key_0_flds_we;
899:   prim_subreg_ext #(
900:     .DW    (32)
901:   ) u_key_0 (
902:     .re     (1'b0),
903:     .we     (key_0_we),
904:     .wd     (key_0_wd),
905:     .d      (hw2reg.key[0].d),
906:     .qre    (),
907:     .qe     (key_0_flds_we[0]),
908:     .q      (reg2hw.key[0].q),
909:     .ds     (),
910:     .qs     ()
911:   );
912:   assign reg2hw.key[0].qe = key_0_qe;
913: 
914: 
915:   // Subregister 1 of Multireg key
916:   // R[key_1]: V(True)
917:   logic key_1_qe;
918:   logic [0:0] key_1_flds_we;
919:   assign key_1_qe = &key_1_flds_we;
920:   prim_subreg_ext #(
921:     .DW    (32)
922:   ) u_key_1 (
923:     .re     (1'b0),
924:     .we     (key_1_we),
925:     .wd     (key_1_wd),
926:     .d      (hw2reg.key[1].d),
927:     .qre    (),
928:     .qe     (key_1_flds_we[0]),
929:     .q      (reg2hw.key[1].q),
930:     .ds     (),
931:     .qs     ()
932:   );
933:   assign reg2hw.key[1].qe = key_1_qe;
934: 
935: 
936:   // Subregister 2 of Multireg key
937:   // R[key_2]: V(True)
938:   logic key_2_qe;
939:   logic [0:0] key_2_flds_we;
940:   assign key_2_qe = &key_2_flds_we;
941:   prim_subreg_ext #(
942:     .DW    (32)
943:   ) u_key_2 (
944:     .re     (1'b0),
945:     .we     (key_2_we),
946:     .wd     (key_2_wd),
947:     .d      (hw2reg.key[2].d),
948:     .qre    (),
949:     .qe     (key_2_flds_we[0]),
950:     .q      (reg2hw.key[2].q),
951:     .ds     (),
952:     .qs     ()
953:   );
954:   assign reg2hw.key[2].qe = key_2_qe;
955: 
956: 
957:   // Subregister 3 of Multireg key
958:   // R[key_3]: V(True)
959:   logic key_3_qe;
960:   logic [0:0] key_3_flds_we;
961:   assign key_3_qe = &key_3_flds_we;
962:   prim_subreg_ext #(
963:     .DW    (32)
964:   ) u_key_3 (
965:     .re     (1'b0),
966:     .we     (key_3_we),
967:     .wd     (key_3_wd),
968:     .d      (hw2reg.key[3].d),
969:     .qre    (),
970:     .qe     (key_3_flds_we[0]),
971:     .q      (reg2hw.key[3].q),
972:     .ds     (),
973:     .qs     ()
974:   );
975:   assign reg2hw.key[3].qe = key_3_qe;
976: 
977: 
978:   // Subregister 4 of Multireg key
979:   // R[key_4]: V(True)
980:   logic key_4_qe;
981:   logic [0:0] key_4_flds_we;
982:   assign key_4_qe = &key_4_flds_we;
983:   prim_subreg_ext #(
984:     .DW    (32)
985:   ) u_key_4 (
986:     .re     (1'b0),
987:     .we     (key_4_we),
988:     .wd     (key_4_wd),
989:     .d      (hw2reg.key[4].d),
990:     .qre    (),
991:     .qe     (key_4_flds_we[0]),
992:     .q      (reg2hw.key[4].q),
993:     .ds     (),
994:     .qs     ()
995:   );
996:   assign reg2hw.key[4].qe = key_4_qe;
997: 
998: 
999:   // Subregister 5 of Multireg key
1000:   // R[key_5]: V(True)
1001:   logic key_5_qe;
1002:   logic [0:0] key_5_flds_we;
1003:   assign key_5_qe = &key_5_flds_we;
1004:   prim_subreg_ext #(
1005:     .DW    (32)
1006:   ) u_key_5 (
1007:     .re     (1'b0),
1008:     .we     (key_5_we),
1009:     .wd     (key_5_wd),
1010:     .d      (hw2reg.key[5].d),
1011:     .qre    (),
1012:     .qe     (key_5_flds_we[0]),
1013:     .q      (reg2hw.key[5].q),
1014:     .ds     (),
1015:     .qs     ()
1016:   );
1017:   assign reg2hw.key[5].qe = key_5_qe;
1018: 
1019: 
1020:   // Subregister 6 of Multireg key
1021:   // R[key_6]: V(True)
1022:   logic key_6_qe;
1023:   logic [0:0] key_6_flds_we;
1024:   assign key_6_qe = &key_6_flds_we;
1025:   prim_subreg_ext #(
1026:     .DW    (32)
1027:   ) u_key_6 (
1028:     .re     (1'b0),
1029:     .we     (key_6_we),
1030:     .wd     (key_6_wd),
1031:     .d      (hw2reg.key[6].d),
1032:     .qre    (),
1033:     .qe     (key_6_flds_we[0]),
1034:     .q      (reg2hw.key[6].q),
1035:     .ds     (),
1036:     .qs     ()
1037:   );
1038:   assign reg2hw.key[6].qe = key_6_qe;
1039: 
1040: 
1041:   // Subregister 7 of Multireg key
1042:   // R[key_7]: V(True)
1043:   logic key_7_qe;
1044:   logic [0:0] key_7_flds_we;
1045:   assign key_7_qe = &key_7_flds_we;
1046:   prim_subreg_ext #(
1047:     .DW    (32)
1048:   ) u_key_7 (
1049:     .re     (1'b0),
1050:     .we     (key_7_we),
1051:     .wd     (key_7_wd),
1052:     .d      (hw2reg.key[7].d),
1053:     .qre    (),
1054:     .qe     (key_7_flds_we[0]),
1055:     .q      (reg2hw.key[7].q),
1056:     .ds     (),
1057:     .qs     ()
1058:   );
1059:   assign reg2hw.key[7].qe = key_7_qe;
1060: 
1061: 
1062:   // Subregister 8 of Multireg key
1063:   // R[key_8]: V(True)
1064:   logic key_8_qe;
1065:   logic [0:0] key_8_flds_we;
1066:   assign key_8_qe = &key_8_flds_we;
1067:   prim_subreg_ext #(
1068:     .DW    (32)
1069:   ) u_key_8 (
1070:     .re     (1'b0),
1071:     .we     (key_8_we),
1072:     .wd     (key_8_wd),
1073:     .d      (hw2reg.key[8].d),
1074:     .qre    (),
1075:     .qe     (key_8_flds_we[0]),
1076:     .q      (reg2hw.key[8].q),
1077:     .ds     (),
1078:     .qs     ()
1079:   );
1080:   assign reg2hw.key[8].qe = key_8_qe;
1081: 
1082: 
1083:   // Subregister 9 of Multireg key
1084:   // R[key_9]: V(True)
1085:   logic key_9_qe;
1086:   logic [0:0] key_9_flds_we;
1087:   assign key_9_qe = &key_9_flds_we;
1088:   prim_subreg_ext #(
1089:     .DW    (32)
1090:   ) u_key_9 (
1091:     .re     (1'b0),
1092:     .we     (key_9_we),
1093:     .wd     (key_9_wd),
1094:     .d      (hw2reg.key[9].d),
1095:     .qre    (),
1096:     .qe     (key_9_flds_we[0]),
1097:     .q      (reg2hw.key[9].q),
1098:     .ds     (),
1099:     .qs     ()
1100:   );
1101:   assign reg2hw.key[9].qe = key_9_qe;
1102: 
1103: 
1104:   // Subregister 10 of Multireg key
1105:   // R[key_10]: V(True)
1106:   logic key_10_qe;
1107:   logic [0:0] key_10_flds_we;
1108:   assign key_10_qe = &key_10_flds_we;
1109:   prim_subreg_ext #(
1110:     .DW    (32)
1111:   ) u_key_10 (
1112:     .re     (1'b0),
1113:     .we     (key_10_we),
1114:     .wd     (key_10_wd),
1115:     .d      (hw2reg.key[10].d),
1116:     .qre    (),
1117:     .qe     (key_10_flds_we[0]),
1118:     .q      (reg2hw.key[10].q),
1119:     .ds     (),
1120:     .qs     ()
1121:   );
1122:   assign reg2hw.key[10].qe = key_10_qe;
1123: 
1124: 
1125:   // Subregister 11 of Multireg key
1126:   // R[key_11]: V(True)
1127:   logic key_11_qe;
1128:   logic [0:0] key_11_flds_we;
1129:   assign key_11_qe = &key_11_flds_we;
1130:   prim_subreg_ext #(
1131:     .DW    (32)
1132:   ) u_key_11 (
1133:     .re     (1'b0),
1134:     .we     (key_11_we),
1135:     .wd     (key_11_wd),
1136:     .d      (hw2reg.key[11].d),
1137:     .qre    (),
1138:     .qe     (key_11_flds_we[0]),
1139:     .q      (reg2hw.key[11].q),
1140:     .ds     (),
1141:     .qs     ()
1142:   );
1143:   assign reg2hw.key[11].qe = key_11_qe;
1144: 
1145: 
1146:   // Subregister 12 of Multireg key
1147:   // R[key_12]: V(True)
1148:   logic key_12_qe;
1149:   logic [0:0] key_12_flds_we;
1150:   assign key_12_qe = &key_12_flds_we;
1151:   prim_subreg_ext #(
1152:     .DW    (32)
1153:   ) u_key_12 (
1154:     .re     (1'b0),
1155:     .we     (key_12_we),
1156:     .wd     (key_12_wd),
1157:     .d      (hw2reg.key[12].d),
1158:     .qre    (),
1159:     .qe     (key_12_flds_we[0]),
1160:     .q      (reg2hw.key[12].q),
1161:     .ds     (),
1162:     .qs     ()
1163:   );
1164:   assign reg2hw.key[12].qe = key_12_qe;
1165: 
1166: 
1167:   // Subregister 13 of Multireg key
1168:   // R[key_13]: V(True)
1169:   logic key_13_qe;
1170:   logic [0:0] key_13_flds_we;
1171:   assign key_13_qe = &key_13_flds_we;
1172:   prim_subreg_ext #(
1173:     .DW    (32)
1174:   ) u_key_13 (
1175:     .re     (1'b0),
1176:     .we     (key_13_we),
1177:     .wd     (key_13_wd),
1178:     .d      (hw2reg.key[13].d),
1179:     .qre    (),
1180:     .qe     (key_13_flds_we[0]),
1181:     .q      (reg2hw.key[13].q),
1182:     .ds     (),
1183:     .qs     ()
1184:   );
1185:   assign reg2hw.key[13].qe = key_13_qe;
1186: 
1187: 
1188:   // Subregister 14 of Multireg key
1189:   // R[key_14]: V(True)
1190:   logic key_14_qe;
1191:   logic [0:0] key_14_flds_we;
1192:   assign key_14_qe = &key_14_flds_we;
1193:   prim_subreg_ext #(
1194:     .DW    (32)
1195:   ) u_key_14 (
1196:     .re     (1'b0),
1197:     .we     (key_14_we),
1198:     .wd     (key_14_wd),
1199:     .d      (hw2reg.key[14].d),
1200:     .qre    (),
1201:     .qe     (key_14_flds_we[0]),
1202:     .q      (reg2hw.key[14].q),
1203:     .ds     (),
1204:     .qs     ()
1205:   );
1206:   assign reg2hw.key[14].qe = key_14_qe;
1207: 
1208: 
1209:   // Subregister 15 of Multireg key
1210:   // R[key_15]: V(True)
1211:   logic key_15_qe;
1212:   logic [0:0] key_15_flds_we;
1213:   assign key_15_qe = &key_15_flds_we;
1214:   prim_subreg_ext #(
1215:     .DW    (32)
1216:   ) u_key_15 (
1217:     .re     (1'b0),
1218:     .we     (key_15_we),
1219:     .wd     (key_15_wd),
1220:     .d      (hw2reg.key[15].d),
1221:     .qre    (),
1222:     .qe     (key_15_flds_we[0]),
1223:     .q      (reg2hw.key[15].q),
1224:     .ds     (),
1225:     .qs     ()
1226:   );
1227:   assign reg2hw.key[15].qe = key_15_qe;
1228: 
1229: 
1230:   // Subregister 16 of Multireg key
1231:   // R[key_16]: V(True)
1232:   logic key_16_qe;
1233:   logic [0:0] key_16_flds_we;
1234:   assign key_16_qe = &key_16_flds_we;
1235:   prim_subreg_ext #(
1236:     .DW    (32)
1237:   ) u_key_16 (
1238:     .re     (1'b0),
1239:     .we     (key_16_we),
1240:     .wd     (key_16_wd),
1241:     .d      (hw2reg.key[16].d),
1242:     .qre    (),
1243:     .qe     (key_16_flds_we[0]),
1244:     .q      (reg2hw.key[16].q),
1245:     .ds     (),
1246:     .qs     ()
1247:   );
1248:   assign reg2hw.key[16].qe = key_16_qe;
1249: 
1250: 
1251:   // Subregister 17 of Multireg key
1252:   // R[key_17]: V(True)
1253:   logic key_17_qe;
1254:   logic [0:0] key_17_flds_we;
1255:   assign key_17_qe = &key_17_flds_we;
1256:   prim_subreg_ext #(
1257:     .DW    (32)
1258:   ) u_key_17 (
1259:     .re     (1'b0),
1260:     .we     (key_17_we),
1261:     .wd     (key_17_wd),
1262:     .d      (hw2reg.key[17].d),
1263:     .qre    (),
1264:     .qe     (key_17_flds_we[0]),
1265:     .q      (reg2hw.key[17].q),
1266:     .ds     (),
1267:     .qs     ()
1268:   );
1269:   assign reg2hw.key[17].qe = key_17_qe;
1270: 
1271: 
1272:   // Subregister 18 of Multireg key
1273:   // R[key_18]: V(True)
1274:   logic key_18_qe;
1275:   logic [0:0] key_18_flds_we;
1276:   assign key_18_qe = &key_18_flds_we;
1277:   prim_subreg_ext #(
1278:     .DW    (32)
1279:   ) u_key_18 (
1280:     .re     (1'b0),
1281:     .we     (key_18_we),
1282:     .wd     (key_18_wd),
1283:     .d      (hw2reg.key[18].d),
1284:     .qre    (),
1285:     .qe     (key_18_flds_we[0]),
1286:     .q      (reg2hw.key[18].q),
1287:     .ds     (),
1288:     .qs     ()
1289:   );
1290:   assign reg2hw.key[18].qe = key_18_qe;
1291: 
1292: 
1293:   // Subregister 19 of Multireg key
1294:   // R[key_19]: V(True)
1295:   logic key_19_qe;
1296:   logic [0:0] key_19_flds_we;
1297:   assign key_19_qe = &key_19_flds_we;
1298:   prim_subreg_ext #(
1299:     .DW    (32)
1300:   ) u_key_19 (
1301:     .re     (1'b0),
1302:     .we     (key_19_we),
1303:     .wd     (key_19_wd),
1304:     .d      (hw2reg.key[19].d),
1305:     .qre    (),
1306:     .qe     (key_19_flds_we[0]),
1307:     .q      (reg2hw.key[19].q),
1308:     .ds     (),
1309:     .qs     ()
1310:   );
1311:   assign reg2hw.key[19].qe = key_19_qe;
1312: 
1313: 
1314:   // Subregister 20 of Multireg key
1315:   // R[key_20]: V(True)
1316:   logic key_20_qe;
1317:   logic [0:0] key_20_flds_we;
1318:   assign key_20_qe = &key_20_flds_we;
1319:   prim_subreg_ext #(
1320:     .DW    (32)
1321:   ) u_key_20 (
1322:     .re     (1'b0),
1323:     .we     (key_20_we),
1324:     .wd     (key_20_wd),
1325:     .d      (hw2reg.key[20].d),
1326:     .qre    (),
1327:     .qe     (key_20_flds_we[0]),
1328:     .q      (reg2hw.key[20].q),
1329:     .ds     (),
1330:     .qs     ()
1331:   );
1332:   assign reg2hw.key[20].qe = key_20_qe;
1333: 
1334: 
1335:   // Subregister 21 of Multireg key
1336:   // R[key_21]: V(True)
1337:   logic key_21_qe;
1338:   logic [0:0] key_21_flds_we;
1339:   assign key_21_qe = &key_21_flds_we;
1340:   prim_subreg_ext #(
1341:     .DW    (32)
1342:   ) u_key_21 (
1343:     .re     (1'b0),
1344:     .we     (key_21_we),
1345:     .wd     (key_21_wd),
1346:     .d      (hw2reg.key[21].d),
1347:     .qre    (),
1348:     .qe     (key_21_flds_we[0]),
1349:     .q      (reg2hw.key[21].q),
1350:     .ds     (),
1351:     .qs     ()
1352:   );
1353:   assign reg2hw.key[21].qe = key_21_qe;
1354: 
1355: 
1356:   // Subregister 22 of Multireg key
1357:   // R[key_22]: V(True)
1358:   logic key_22_qe;
1359:   logic [0:0] key_22_flds_we;
1360:   assign key_22_qe = &key_22_flds_we;
1361:   prim_subreg_ext #(
1362:     .DW    (32)
1363:   ) u_key_22 (
1364:     .re     (1'b0),
1365:     .we     (key_22_we),
1366:     .wd     (key_22_wd),
1367:     .d      (hw2reg.key[22].d),
1368:     .qre    (),
1369:     .qe     (key_22_flds_we[0]),
1370:     .q      (reg2hw.key[22].q),
1371:     .ds     (),
1372:     .qs     ()
1373:   );
1374:   assign reg2hw.key[22].qe = key_22_qe;
1375: 
1376: 
1377:   // Subregister 23 of Multireg key
1378:   // R[key_23]: V(True)
1379:   logic key_23_qe;
1380:   logic [0:0] key_23_flds_we;
1381:   assign key_23_qe = &key_23_flds_we;
1382:   prim_subreg_ext #(
1383:     .DW    (32)
1384:   ) u_key_23 (
1385:     .re     (1'b0),
1386:     .we     (key_23_we),
1387:     .wd     (key_23_wd),
1388:     .d      (hw2reg.key[23].d),
1389:     .qre    (),
1390:     .qe     (key_23_flds_we[0]),
1391:     .q      (reg2hw.key[23].q),
1392:     .ds     (),
1393:     .qs     ()
1394:   );
1395:   assign reg2hw.key[23].qe = key_23_qe;
1396: 
1397: 
1398:   // Subregister 24 of Multireg key
1399:   // R[key_24]: V(True)
1400:   logic key_24_qe;
1401:   logic [0:0] key_24_flds_we;
1402:   assign key_24_qe = &key_24_flds_we;
1403:   prim_subreg_ext #(
1404:     .DW    (32)
1405:   ) u_key_24 (
1406:     .re     (1'b0),
1407:     .we     (key_24_we),
1408:     .wd     (key_24_wd),
1409:     .d      (hw2reg.key[24].d),
1410:     .qre    (),
1411:     .qe     (key_24_flds_we[0]),
1412:     .q      (reg2hw.key[24].q),
1413:     .ds     (),
1414:     .qs     ()
1415:   );
1416:   assign reg2hw.key[24].qe = key_24_qe;
1417: 
1418: 
1419:   // Subregister 25 of Multireg key
1420:   // R[key_25]: V(True)
1421:   logic key_25_qe;
1422:   logic [0:0] key_25_flds_we;
1423:   assign key_25_qe = &key_25_flds_we;
1424:   prim_subreg_ext #(
1425:     .DW    (32)
1426:   ) u_key_25 (
1427:     .re     (1'b0),
1428:     .we     (key_25_we),
1429:     .wd     (key_25_wd),
1430:     .d      (hw2reg.key[25].d),
1431:     .qre    (),
1432:     .qe     (key_25_flds_we[0]),
1433:     .q      (reg2hw.key[25].q),
1434:     .ds     (),
1435:     .qs     ()
1436:   );
1437:   assign reg2hw.key[25].qe = key_25_qe;
1438: 
1439: 
1440:   // Subregister 26 of Multireg key
1441:   // R[key_26]: V(True)
1442:   logic key_26_qe;
1443:   logic [0:0] key_26_flds_we;
1444:   assign key_26_qe = &key_26_flds_we;
1445:   prim_subreg_ext #(
1446:     .DW    (32)
1447:   ) u_key_26 (
1448:     .re     (1'b0),
1449:     .we     (key_26_we),
1450:     .wd     (key_26_wd),
1451:     .d      (hw2reg.key[26].d),
1452:     .qre    (),
1453:     .qe     (key_26_flds_we[0]),
1454:     .q      (reg2hw.key[26].q),
1455:     .ds     (),
1456:     .qs     ()
1457:   );
1458:   assign reg2hw.key[26].qe = key_26_qe;
1459: 
1460: 
1461:   // Subregister 27 of Multireg key
1462:   // R[key_27]: V(True)
1463:   logic key_27_qe;
1464:   logic [0:0] key_27_flds_we;
1465:   assign key_27_qe = &key_27_flds_we;
1466:   prim_subreg_ext #(
1467:     .DW    (32)
1468:   ) u_key_27 (
1469:     .re     (1'b0),
1470:     .we     (key_27_we),
1471:     .wd     (key_27_wd),
1472:     .d      (hw2reg.key[27].d),
1473:     .qre    (),
1474:     .qe     (key_27_flds_we[0]),
1475:     .q      (reg2hw.key[27].q),
1476:     .ds     (),
1477:     .qs     ()
1478:   );
1479:   assign reg2hw.key[27].qe = key_27_qe;
1480: 
1481: 
1482:   // Subregister 28 of Multireg key
1483:   // R[key_28]: V(True)
1484:   logic key_28_qe;
1485:   logic [0:0] key_28_flds_we;
1486:   assign key_28_qe = &key_28_flds_we;
1487:   prim_subreg_ext #(
1488:     .DW    (32)
1489:   ) u_key_28 (
1490:     .re     (1'b0),
1491:     .we     (key_28_we),
1492:     .wd     (key_28_wd),
1493:     .d      (hw2reg.key[28].d),
1494:     .qre    (),
1495:     .qe     (key_28_flds_we[0]),
1496:     .q      (reg2hw.key[28].q),
1497:     .ds     (),
1498:     .qs     ()
1499:   );
1500:   assign reg2hw.key[28].qe = key_28_qe;
1501: 
1502: 
1503:   // Subregister 29 of Multireg key
1504:   // R[key_29]: V(True)
1505:   logic key_29_qe;
1506:   logic [0:0] key_29_flds_we;
1507:   assign key_29_qe = &key_29_flds_we;
1508:   prim_subreg_ext #(
1509:     .DW    (32)
1510:   ) u_key_29 (
1511:     .re     (1'b0),
1512:     .we     (key_29_we),
1513:     .wd     (key_29_wd),
1514:     .d      (hw2reg.key[29].d),
1515:     .qre    (),
1516:     .qe     (key_29_flds_we[0]),
1517:     .q      (reg2hw.key[29].q),
1518:     .ds     (),
1519:     .qs     ()
1520:   );
1521:   assign reg2hw.key[29].qe = key_29_qe;
1522: 
1523: 
1524:   // Subregister 30 of Multireg key
1525:   // R[key_30]: V(True)
1526:   logic key_30_qe;
1527:   logic [0:0] key_30_flds_we;
1528:   assign key_30_qe = &key_30_flds_we;
1529:   prim_subreg_ext #(
1530:     .DW    (32)
1531:   ) u_key_30 (
1532:     .re     (1'b0),
1533:     .we     (key_30_we),
1534:     .wd     (key_30_wd),
1535:     .d      (hw2reg.key[30].d),
1536:     .qre    (),
1537:     .qe     (key_30_flds_we[0]),
1538:     .q      (reg2hw.key[30].q),
1539:     .ds     (),
1540:     .qs     ()
1541:   );
1542:   assign reg2hw.key[30].qe = key_30_qe;
1543: 
1544: 
1545:   // Subregister 31 of Multireg key
1546:   // R[key_31]: V(True)
1547:   logic key_31_qe;
1548:   logic [0:0] key_31_flds_we;
1549:   assign key_31_qe = &key_31_flds_we;
1550:   prim_subreg_ext #(
1551:     .DW    (32)
1552:   ) u_key_31 (
1553:     .re     (1'b0),
1554:     .we     (key_31_we),
1555:     .wd     (key_31_wd),
1556:     .d      (hw2reg.key[31].d),
1557:     .qre    (),
1558:     .qe     (key_31_flds_we[0]),
1559:     .q      (reg2hw.key[31].q),
1560:     .ds     (),
1561:     .qs     ()
1562:   );
1563:   assign reg2hw.key[31].qe = key_31_qe;
1564: 
1565: 
1566:   // Subregister 0 of Multireg digest
1567:   // R[digest_0]: V(True)
1568:   logic digest_0_qe;
1569:   logic [0:0] digest_0_flds_we;
1570:   assign digest_0_qe = &digest_0_flds_we;
1571:   prim_subreg_ext #(
1572:     .DW    (32)
1573:   ) u_digest_0 (
1574:     .re     (digest_0_re),
1575:     .we     (digest_0_we),
1576:     .wd     (digest_0_wd),
1577:     .d      (hw2reg.digest[0].d),
1578:     .qre    (),
1579:     .qe     (digest_0_flds_we[0]),
1580:     .q      (reg2hw.digest[0].q),
1581:     .ds     (),
1582:     .qs     (digest_0_qs)
1583:   );
1584:   assign reg2hw.digest[0].qe = digest_0_qe;
1585: 
1586: 
1587:   // Subregister 1 of Multireg digest
1588:   // R[digest_1]: V(True)
1589:   logic digest_1_qe;
1590:   logic [0:0] digest_1_flds_we;
1591:   assign digest_1_qe = &digest_1_flds_we;
1592:   prim_subreg_ext #(
1593:     .DW    (32)
1594:   ) u_digest_1 (
1595:     .re     (digest_1_re),
1596:     .we     (digest_1_we),
1597:     .wd     (digest_1_wd),
1598:     .d      (hw2reg.digest[1].d),
1599:     .qre    (),
1600:     .qe     (digest_1_flds_we[0]),
1601:     .q      (reg2hw.digest[1].q),
1602:     .ds     (),
1603:     .qs     (digest_1_qs)
1604:   );
1605:   assign reg2hw.digest[1].qe = digest_1_qe;
1606: 
1607: 
1608:   // Subregister 2 of Multireg digest
1609:   // R[digest_2]: V(True)
1610:   logic digest_2_qe;
1611:   logic [0:0] digest_2_flds_we;
1612:   assign digest_2_qe = &digest_2_flds_we;
1613:   prim_subreg_ext #(
1614:     .DW    (32)
1615:   ) u_digest_2 (
1616:     .re     (digest_2_re),
1617:     .we     (digest_2_we),
1618:     .wd     (digest_2_wd),
1619:     .d      (hw2reg.digest[2].d),
1620:     .qre    (),
1621:     .qe     (digest_2_flds_we[0]),
1622:     .q      (reg2hw.digest[2].q),
1623:     .ds     (),
1624:     .qs     (digest_2_qs)
1625:   );
1626:   assign reg2hw.digest[2].qe = digest_2_qe;
1627: 
1628: 
1629:   // Subregister 3 of Multireg digest
1630:   // R[digest_3]: V(True)
1631:   logic digest_3_qe;
1632:   logic [0:0] digest_3_flds_we;
1633:   assign digest_3_qe = &digest_3_flds_we;
1634:   prim_subreg_ext #(
1635:     .DW    (32)
1636:   ) u_digest_3 (
1637:     .re     (digest_3_re),
1638:     .we     (digest_3_we),
1639:     .wd     (digest_3_wd),
1640:     .d      (hw2reg.digest[3].d),
1641:     .qre    (),
1642:     .qe     (digest_3_flds_we[0]),
1643:     .q      (reg2hw.digest[3].q),
1644:     .ds     (),
1645:     .qs     (digest_3_qs)
1646:   );
1647:   assign reg2hw.digest[3].qe = digest_3_qe;
1648: 
1649: 
1650:   // Subregister 4 of Multireg digest
1651:   // R[digest_4]: V(True)
1652:   logic digest_4_qe;
1653:   logic [0:0] digest_4_flds_we;
1654:   assign digest_4_qe = &digest_4_flds_we;
1655:   prim_subreg_ext #(
1656:     .DW    (32)
1657:   ) u_digest_4 (
1658:     .re     (digest_4_re),
1659:     .we     (digest_4_we),
1660:     .wd     (digest_4_wd),
1661:     .d      (hw2reg.digest[4].d),
1662:     .qre    (),
1663:     .qe     (digest_4_flds_we[0]),
1664:     .q      (reg2hw.digest[4].q),
1665:     .ds     (),
1666:     .qs     (digest_4_qs)
1667:   );
1668:   assign reg2hw.digest[4].qe = digest_4_qe;
1669: 
1670: 
1671:   // Subregister 5 of Multireg digest
1672:   // R[digest_5]: V(True)
1673:   logic digest_5_qe;
1674:   logic [0:0] digest_5_flds_we;
1675:   assign digest_5_qe = &digest_5_flds_we;
1676:   prim_subreg_ext #(
1677:     .DW    (32)
1678:   ) u_digest_5 (
1679:     .re     (digest_5_re),
1680:     .we     (digest_5_we),
1681:     .wd     (digest_5_wd),
1682:     .d      (hw2reg.digest[5].d),
1683:     .qre    (),
1684:     .qe     (digest_5_flds_we[0]),
1685:     .q      (reg2hw.digest[5].q),
1686:     .ds     (),
1687:     .qs     (digest_5_qs)
1688:   );
1689:   assign reg2hw.digest[5].qe = digest_5_qe;
1690: 
1691: 
1692:   // Subregister 6 of Multireg digest
1693:   // R[digest_6]: V(True)
1694:   logic digest_6_qe;
1695:   logic [0:0] digest_6_flds_we;
1696:   assign digest_6_qe = &digest_6_flds_we;
1697:   prim_subreg_ext #(
1698:     .DW    (32)
1699:   ) u_digest_6 (
1700:     .re     (digest_6_re),
1701:     .we     (digest_6_we),
1702:     .wd     (digest_6_wd),
1703:     .d      (hw2reg.digest[6].d),
1704:     .qre    (),
1705:     .qe     (digest_6_flds_we[0]),
1706:     .q      (reg2hw.digest[6].q),
1707:     .ds     (),
1708:     .qs     (digest_6_qs)
1709:   );
1710:   assign reg2hw.digest[6].qe = digest_6_qe;
1711: 
1712: 
1713:   // Subregister 7 of Multireg digest
1714:   // R[digest_7]: V(True)
1715:   logic digest_7_qe;
1716:   logic [0:0] digest_7_flds_we;
1717:   assign digest_7_qe = &digest_7_flds_we;
1718:   prim_subreg_ext #(
1719:     .DW    (32)
1720:   ) u_digest_7 (
1721:     .re     (digest_7_re),
1722:     .we     (digest_7_we),
1723:     .wd     (digest_7_wd),
1724:     .d      (hw2reg.digest[7].d),
1725:     .qre    (),
1726:     .qe     (digest_7_flds_we[0]),
1727:     .q      (reg2hw.digest[7].q),
1728:     .ds     (),
1729:     .qs     (digest_7_qs)
1730:   );
1731:   assign reg2hw.digest[7].qe = digest_7_qe;
1732: 
1733: 
1734:   // Subregister 8 of Multireg digest
1735:   // R[digest_8]: V(True)
1736:   logic digest_8_qe;
1737:   logic [0:0] digest_8_flds_we;
1738:   assign digest_8_qe = &digest_8_flds_we;
1739:   prim_subreg_ext #(
1740:     .DW    (32)
1741:   ) u_digest_8 (
1742:     .re     (digest_8_re),
1743:     .we     (digest_8_we),
1744:     .wd     (digest_8_wd),
1745:     .d      (hw2reg.digest[8].d),
1746:     .qre    (),
1747:     .qe     (digest_8_flds_we[0]),
1748:     .q      (reg2hw.digest[8].q),
1749:     .ds     (),
1750:     .qs     (digest_8_qs)
1751:   );
1752:   assign reg2hw.digest[8].qe = digest_8_qe;
1753: 
1754: 
1755:   // Subregister 9 of Multireg digest
1756:   // R[digest_9]: V(True)
1757:   logic digest_9_qe;
1758:   logic [0:0] digest_9_flds_we;
1759:   assign digest_9_qe = &digest_9_flds_we;
1760:   prim_subreg_ext #(
1761:     .DW    (32)
1762:   ) u_digest_9 (
1763:     .re     (digest_9_re),
1764:     .we     (digest_9_we),
1765:     .wd     (digest_9_wd),
1766:     .d      (hw2reg.digest[9].d),
1767:     .qre    (),
1768:     .qe     (digest_9_flds_we[0]),
1769:     .q      (reg2hw.digest[9].q),
1770:     .ds     (),
1771:     .qs     (digest_9_qs)
1772:   );
1773:   assign reg2hw.digest[9].qe = digest_9_qe;
1774: 
1775: 
1776:   // Subregister 10 of Multireg digest
1777:   // R[digest_10]: V(True)
1778:   logic digest_10_qe;
1779:   logic [0:0] digest_10_flds_we;
1780:   assign digest_10_qe = &digest_10_flds_we;
1781:   prim_subreg_ext #(
1782:     .DW    (32)
1783:   ) u_digest_10 (
1784:     .re     (digest_10_re),
1785:     .we     (digest_10_we),
1786:     .wd     (digest_10_wd),
1787:     .d      (hw2reg.digest[10].d),
1788:     .qre    (),
1789:     .qe     (digest_10_flds_we[0]),
1790:     .q      (reg2hw.digest[10].q),
1791:     .ds     (),
1792:     .qs     (digest_10_qs)
1793:   );
1794:   assign reg2hw.digest[10].qe = digest_10_qe;
1795: 
1796: 
1797:   // Subregister 11 of Multireg digest
1798:   // R[digest_11]: V(True)
1799:   logic digest_11_qe;
1800:   logic [0:0] digest_11_flds_we;
1801:   assign digest_11_qe = &digest_11_flds_we;
1802:   prim_subreg_ext #(
1803:     .DW    (32)
1804:   ) u_digest_11 (
1805:     .re     (digest_11_re),
1806:     .we     (digest_11_we),
1807:     .wd     (digest_11_wd),
1808:     .d      (hw2reg.digest[11].d),
1809:     .qre    (),
1810:     .qe     (digest_11_flds_we[0]),
1811:     .q      (reg2hw.digest[11].q),
1812:     .ds     (),
1813:     .qs     (digest_11_qs)
1814:   );
1815:   assign reg2hw.digest[11].qe = digest_11_qe;
1816: 
1817: 
1818:   // Subregister 12 of Multireg digest
1819:   // R[digest_12]: V(True)
1820:   logic digest_12_qe;
1821:   logic [0:0] digest_12_flds_we;
1822:   assign digest_12_qe = &digest_12_flds_we;
1823:   prim_subreg_ext #(
1824:     .DW    (32)
1825:   ) u_digest_12 (
1826:     .re     (digest_12_re),
1827:     .we     (digest_12_we),
1828:     .wd     (digest_12_wd),
1829:     .d      (hw2reg.digest[12].d),
1830:     .qre    (),
1831:     .qe     (digest_12_flds_we[0]),
1832:     .q      (reg2hw.digest[12].q),
1833:     .ds     (),
1834:     .qs     (digest_12_qs)
1835:   );
1836:   assign reg2hw.digest[12].qe = digest_12_qe;
1837: 
1838: 
1839:   // Subregister 13 of Multireg digest
1840:   // R[digest_13]: V(True)
1841:   logic digest_13_qe;
1842:   logic [0:0] digest_13_flds_we;
1843:   assign digest_13_qe = &digest_13_flds_we;
1844:   prim_subreg_ext #(
1845:     .DW    (32)
1846:   ) u_digest_13 (
1847:     .re     (digest_13_re),
1848:     .we     (digest_13_we),
1849:     .wd     (digest_13_wd),
1850:     .d      (hw2reg.digest[13].d),
1851:     .qre    (),
1852:     .qe     (digest_13_flds_we[0]),
1853:     .q      (reg2hw.digest[13].q),
1854:     .ds     (),
1855:     .qs     (digest_13_qs)
1856:   );
1857:   assign reg2hw.digest[13].qe = digest_13_qe;
1858: 
1859: 
1860:   // Subregister 14 of Multireg digest
1861:   // R[digest_14]: V(True)
1862:   logic digest_14_qe;
1863:   logic [0:0] digest_14_flds_we;
1864:   assign digest_14_qe = &digest_14_flds_we;
1865:   prim_subreg_ext #(
1866:     .DW    (32)
1867:   ) u_digest_14 (
1868:     .re     (digest_14_re),
1869:     .we     (digest_14_we),
1870:     .wd     (digest_14_wd),
1871:     .d      (hw2reg.digest[14].d),
1872:     .qre    (),
1873:     .qe     (digest_14_flds_we[0]),
1874:     .q      (reg2hw.digest[14].q),
1875:     .ds     (),
1876:     .qs     (digest_14_qs)
1877:   );
1878:   assign reg2hw.digest[14].qe = digest_14_qe;
1879: 
1880: 
1881:   // Subregister 15 of Multireg digest
1882:   // R[digest_15]: V(True)
1883:   logic digest_15_qe;
1884:   logic [0:0] digest_15_flds_we;
1885:   assign digest_15_qe = &digest_15_flds_we;
1886:   prim_subreg_ext #(
1887:     .DW    (32)
1888:   ) u_digest_15 (
1889:     .re     (digest_15_re),
1890:     .we     (digest_15_we),
1891:     .wd     (digest_15_wd),
1892:     .d      (hw2reg.digest[15].d),
1893:     .qre    (),
1894:     .qe     (digest_15_flds_we[0]),
1895:     .q      (reg2hw.digest[15].q),
1896:     .ds     (),
1897:     .qs     (digest_15_qs)
1898:   );
1899:   assign reg2hw.digest[15].qe = digest_15_qe;
1900: 
1901: 
1902:   // R[msg_length_lower]: V(True)
1903:   logic msg_length_lower_qe;
1904:   logic [0:0] msg_length_lower_flds_we;
1905:   assign msg_length_lower_qe = &msg_length_lower_flds_we;
1906:   prim_subreg_ext #(
1907:     .DW    (32)
1908:   ) u_msg_length_lower (
1909:     .re     (msg_length_lower_re),
1910:     .we     (msg_length_lower_we),
1911:     .wd     (msg_length_lower_wd),
1912:     .d      (hw2reg.msg_length_lower.d),
1913:     .qre    (),
1914:     .qe     (msg_length_lower_flds_we[0]),
1915:     .q      (reg2hw.msg_length_lower.q),
1916:     .ds     (),
1917:     .qs     (msg_length_lower_qs)
1918:   );
1919:   assign reg2hw.msg_length_lower.qe = msg_length_lower_qe;
1920: 
1921: 
1922:   // R[msg_length_upper]: V(True)
1923:   logic msg_length_upper_qe;
1924:   logic [0:0] msg_length_upper_flds_we;
1925:   assign msg_length_upper_qe = &msg_length_upper_flds_we;
1926:   prim_subreg_ext #(
1927:     .DW    (32)
1928:   ) u_msg_length_upper (
1929:     .re     (msg_length_upper_re),
1930:     .we     (msg_length_upper_we),
1931:     .wd     (msg_length_upper_wd),
1932:     .d      (hw2reg.msg_length_upper.d),
1933:     .qre    (),
1934:     .qe     (msg_length_upper_flds_we[0]),
1935:     .q      (reg2hw.msg_length_upper.q),
1936:     .ds     (),
1937:     .qs     (msg_length_upper_qs)
1938:   );
1939:   assign reg2hw.msg_length_upper.qe = msg_length_upper_qe;
1940: 
1941: 
1942: 
1943:   logic [58:0] addr_hit;
1944:   always_comb begin
1945:     addr_hit = '0;
1946:     addr_hit[ 0] = (reg_addr == HMAC_INTR_STATE_OFFSET);
1947:     addr_hit[ 1] = (reg_addr == HMAC_INTR_ENABLE_OFFSET);
1948:     addr_hit[ 2] = (reg_addr == HMAC_INTR_TEST_OFFSET);
1949:     addr_hit[ 3] = (reg_addr == HMAC_ALERT_TEST_OFFSET);
1950:     addr_hit[ 4] = (reg_addr == HMAC_CFG_OFFSET);
1951:     addr_hit[ 5] = (reg_addr == HMAC_CMD_OFFSET);
1952:     addr_hit[ 6] = (reg_addr == HMAC_STATUS_OFFSET);
1953:     addr_hit[ 7] = (reg_addr == HMAC_ERR_CODE_OFFSET);
1954:     addr_hit[ 8] = (reg_addr == HMAC_WIPE_SECRET_OFFSET);
1955:     addr_hit[ 9] = (reg_addr == HMAC_KEY_0_OFFSET);
1956:     addr_hit[10] = (reg_addr == HMAC_KEY_1_OFFSET);
1957:     addr_hit[11] = (reg_addr == HMAC_KEY_2_OFFSET);
1958:     addr_hit[12] = (reg_addr == HMAC_KEY_3_OFFSET);
1959:     addr_hit[13] = (reg_addr == HMAC_KEY_4_OFFSET);
1960:     addr_hit[14] = (reg_addr == HMAC_KEY_5_OFFSET);
1961:     addr_hit[15] = (reg_addr == HMAC_KEY_6_OFFSET);
1962:     addr_hit[16] = (reg_addr == HMAC_KEY_7_OFFSET);
1963:     addr_hit[17] = (reg_addr == HMAC_KEY_8_OFFSET);
1964:     addr_hit[18] = (reg_addr == HMAC_KEY_9_OFFSET);
1965:     addr_hit[19] = (reg_addr == HMAC_KEY_10_OFFSET);
1966:     addr_hit[20] = (reg_addr == HMAC_KEY_11_OFFSET);
1967:     addr_hit[21] = (reg_addr == HMAC_KEY_12_OFFSET);
1968:     addr_hit[22] = (reg_addr == HMAC_KEY_13_OFFSET);
1969:     addr_hit[23] = (reg_addr == HMAC_KEY_14_OFFSET);
1970:     addr_hit[24] = (reg_addr == HMAC_KEY_15_OFFSET);
1971:     addr_hit[25] = (reg_addr == HMAC_KEY_16_OFFSET);
1972:     addr_hit[26] = (reg_addr == HMAC_KEY_17_OFFSET);
1973:     addr_hit[27] = (reg_addr == HMAC_KEY_18_OFFSET);
1974:     addr_hit[28] = (reg_addr == HMAC_KEY_19_OFFSET);
1975:     addr_hit[29] = (reg_addr == HMAC_KEY_20_OFFSET);
1976:     addr_hit[30] = (reg_addr == HMAC_KEY_21_OFFSET);
1977:     addr_hit[31] = (reg_addr == HMAC_KEY_22_OFFSET);
1978:     addr_hit[32] = (reg_addr == HMAC_KEY_23_OFFSET);
1979:     addr_hit[33] = (reg_addr == HMAC_KEY_24_OFFSET);
1980:     addr_hit[34] = (reg_addr == HMAC_KEY_25_OFFSET);
1981:     addr_hit[35] = (reg_addr == HMAC_KEY_26_OFFSET);
1982:     addr_hit[36] = (reg_addr == HMAC_KEY_27_OFFSET);
1983:     addr_hit[37] = (reg_addr == HMAC_KEY_28_OFFSET);
1984:     addr_hit[38] = (reg_addr == HMAC_KEY_29_OFFSET);
1985:     addr_hit[39] = (reg_addr == HMAC_KEY_30_OFFSET);
1986:     addr_hit[40] = (reg_addr == HMAC_KEY_31_OFFSET);
1987:     addr_hit[41] = (reg_addr == HMAC_DIGEST_0_OFFSET);
1988:     addr_hit[42] = (reg_addr == HMAC_DIGEST_1_OFFSET);
1989:     addr_hit[43] = (reg_addr == HMAC_DIGEST_2_OFFSET);
1990:     addr_hit[44] = (reg_addr == HMAC_DIGEST_3_OFFSET);
1991:     addr_hit[45] = (reg_addr == HMAC_DIGEST_4_OFFSET);
1992:     addr_hit[46] = (reg_addr == HMAC_DIGEST_5_OFFSET);
1993:     addr_hit[47] = (reg_addr == HMAC_DIGEST_6_OFFSET);
1994:     addr_hit[48] = (reg_addr == HMAC_DIGEST_7_OFFSET);
1995:     addr_hit[49] = (reg_addr == HMAC_DIGEST_8_OFFSET);
1996:     addr_hit[50] = (reg_addr == HMAC_DIGEST_9_OFFSET);
1997:     addr_hit[51] = (reg_addr == HMAC_DIGEST_10_OFFSET);
1998:     addr_hit[52] = (reg_addr == HMAC_DIGEST_11_OFFSET);
1999:     addr_hit[53] = (reg_addr == HMAC_DIGEST_12_OFFSET);
2000:     addr_hit[54] = (reg_addr == HMAC_DIGEST_13_OFFSET);
2001:     addr_hit[55] = (reg_addr == HMAC_DIGEST_14_OFFSET);
2002:     addr_hit[56] = (reg_addr == HMAC_DIGEST_15_OFFSET);
2003:     addr_hit[57] = (reg_addr == HMAC_MSG_LENGTH_LOWER_OFFSET);
2004:     addr_hit[58] = (reg_addr == HMAC_MSG_LENGTH_UPPER_OFFSET);
2005:   end
2006: 
2007:   assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;
2008: 
2009:   // Check sub-word write is permitted
2010:   always_comb begin
2011:     wr_err = (reg_we &
2012:               ((addr_hit[ 0] & (|(HMAC_PERMIT[ 0] & ~reg_be))) |
2013:                (addr_hit[ 1] & (|(HMAC_PERMIT[ 1] & ~reg_be))) |
2014:                (addr_hit[ 2] & (|(HMAC_PERMIT[ 2] & ~reg_be))) |
2015:                (addr_hit[ 3] & (|(HMAC_PERMIT[ 3] & ~reg_be))) |
2016:                (addr_hit[ 4] & (|(HMAC_PERMIT[ 4] & ~reg_be))) |
2017:                (addr_hit[ 5] & (|(HMAC_PERMIT[ 5] & ~reg_be))) |
2018:                (addr_hit[ 6] & (|(HMAC_PERMIT[ 6] & ~reg_be))) |
2019:                (addr_hit[ 7] & (|(HMAC_PERMIT[ 7] & ~reg_be))) |
2020:                (addr_hit[ 8] & (|(HMAC_PERMIT[ 8] & ~reg_be))) |
2021:                (addr_hit[ 9] & (|(HMAC_PERMIT[ 9] & ~reg_be))) |
2022:                (addr_hit[10] & (|(HMAC_PERMIT[10] & ~reg_be))) |
2023:                (addr_hit[11] & (|(HMAC_PERMIT[11] & ~reg_be))) |
2024:                (addr_hit[12] & (|(HMAC_PERMIT[12] & ~reg_be))) |
2025:                (addr_hit[13] & (|(HMAC_PERMIT[13] & ~reg_be))) |
2026:                (addr_hit[14] & (|(HMAC_PERMIT[14] & ~reg_be))) |
2027:                (addr_hit[15] & (|(HMAC_PERMIT[15] & ~reg_be))) |
2028:                (addr_hit[16] & (|(HMAC_PERMIT[16] & ~reg_be))) |
2029:                (addr_hit[17] & (|(HMAC_PERMIT[17] & ~reg_be))) |
2030:                (addr_hit[18] & (|(HMAC_PERMIT[18] & ~reg_be))) |
2031:                (addr_hit[19] & (|(HMAC_PERMIT[19] & ~reg_be))) |
2032:                (addr_hit[20] & (|(HMAC_PERMIT[20] & ~reg_be))) |
2033:                (addr_hit[21] & (|(HMAC_PERMIT[21] & ~reg_be))) |
2034:                (addr_hit[22] & (|(HMAC_PERMIT[22] & ~reg_be))) |
2035:                (addr_hit[23] & (|(HMAC_PERMIT[23] & ~reg_be))) |
2036:                (addr_hit[24] & (|(HMAC_PERMIT[24] & ~reg_be))) |
2037:                (addr_hit[25] & (|(HMAC_PERMIT[25] & ~reg_be))) |
2038:                (addr_hit[26] & (|(HMAC_PERMIT[26] & ~reg_be))) |
2039:                (addr_hit[27] & (|(HMAC_PERMIT[27] & ~reg_be))) |
2040:                (addr_hit[28] & (|(HMAC_PERMIT[28] & ~reg_be))) |
2041:                (addr_hit[29] & (|(HMAC_PERMIT[29] & ~reg_be))) |
2042:                (addr_hit[30] & (|(HMAC_PERMIT[30] & ~reg_be))) |
2043:                (addr_hit[31] & (|(HMAC_PERMIT[31] & ~reg_be))) |
2044:                (addr_hit[32] & (|(HMAC_PERMIT[32] & ~reg_be))) |
2045:                (addr_hit[33] & (|(HMAC_PERMIT[33] & ~reg_be))) |
2046:                (addr_hit[34] & (|(HMAC_PERMIT[34] & ~reg_be))) |
2047:                (addr_hit[35] & (|(HMAC_PERMIT[35] & ~reg_be))) |
2048:                (addr_hit[36] & (|(HMAC_PERMIT[36] & ~reg_be))) |
2049:                (addr_hit[37] & (|(HMAC_PERMIT[37] & ~reg_be))) |
2050:                (addr_hit[38] & (|(HMAC_PERMIT[38] & ~reg_be))) |
2051:                (addr_hit[39] & (|(HMAC_PERMIT[39] & ~reg_be))) |
2052:                (addr_hit[40] & (|(HMAC_PERMIT[40] & ~reg_be))) |
2053:                (addr_hit[41] & (|(HMAC_PERMIT[41] & ~reg_be))) |
2054:                (addr_hit[42] & (|(HMAC_PERMIT[42] & ~reg_be))) |
2055:                (addr_hit[43] & (|(HMAC_PERMIT[43] & ~reg_be))) |
2056:                (addr_hit[44] & (|(HMAC_PERMIT[44] & ~reg_be))) |
2057:                (addr_hit[45] & (|(HMAC_PERMIT[45] & ~reg_be))) |
2058:                (addr_hit[46] & (|(HMAC_PERMIT[46] & ~reg_be))) |
2059:                (addr_hit[47] & (|(HMAC_PERMIT[47] & ~reg_be))) |
2060:                (addr_hit[48] & (|(HMAC_PERMIT[48] & ~reg_be))) |
2061:                (addr_hit[49] & (|(HMAC_PERMIT[49] & ~reg_be))) |
2062:                (addr_hit[50] & (|(HMAC_PERMIT[50] & ~reg_be))) |
2063:                (addr_hit[51] & (|(HMAC_PERMIT[51] & ~reg_be))) |
2064:                (addr_hit[52] & (|(HMAC_PERMIT[52] & ~reg_be))) |
2065:                (addr_hit[53] & (|(HMAC_PERMIT[53] & ~reg_be))) |
2066:                (addr_hit[54] & (|(HMAC_PERMIT[54] & ~reg_be))) |
2067:                (addr_hit[55] & (|(HMAC_PERMIT[55] & ~reg_be))) |
2068:                (addr_hit[56] & (|(HMAC_PERMIT[56] & ~reg_be))) |
2069:                (addr_hit[57] & (|(HMAC_PERMIT[57] & ~reg_be))) |
2070:                (addr_hit[58] & (|(HMAC_PERMIT[58] & ~reg_be)))));
2071:   end
2072: 
2073:   // Generate write-enables
2074:   assign intr_state_we = addr_hit[0] & reg_we & !reg_error;
2075: 
2076:   assign intr_state_hmac_done_wd = reg_wdata[0];
2077: 
2078:   assign intr_state_hmac_err_wd = reg_wdata[2];
2079:   assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;
2080: 
2081:   assign intr_enable_hmac_done_wd = reg_wdata[0];
2082: 
2083:   assign intr_enable_fifo_empty_wd = reg_wdata[1];
2084: 
2085:   assign intr_enable_hmac_err_wd = reg_wdata[2];
2086:   assign intr_test_we = addr_hit[2] & reg_we & !reg_error;
2087: 
2088:   assign intr_test_hmac_done_wd = reg_wdata[0];
2089: 
2090:   assign intr_test_fifo_empty_wd = reg_wdata[1];
2091: 
2092:   assign intr_test_hmac_err_wd = reg_wdata[2];
2093:   assign alert_test_we = addr_hit[3] & reg_we & !reg_error;
2094: 
2095:   assign alert_test_wd = reg_wdata[0];
2096:   assign cfg_re = addr_hit[4] & reg_re & !reg_error;
2097:   assign cfg_we = addr_hit[4] & reg_we & !reg_error;
2098: 
2099:   assign cfg_hmac_en_wd = reg_wdata[0];
2100: 
2101:   assign cfg_sha_en_wd = reg_wdata[1];
2102: 
2103:   assign cfg_endian_swap_wd = reg_wdata[2];
2104: 
2105:   assign cfg_digest_swap_wd = reg_wdata[3];
2106: 
2107:   assign cfg_key_swap_wd = reg_wdata[4];
2108: 
2109:   assign cfg_digest_size_wd = reg_wdata[8:5];
2110: 
2111:   assign cfg_key_length_wd = reg_wdata[14:9];
2112:   assign cmd_we = addr_hit[5] & reg_we & !reg_error;
2113: 
2114:   assign cmd_hash_start_wd = reg_wdata[0];
2115: 
2116:   assign cmd_hash_process_wd = reg_wdata[1];
2117: 
2118:   assign cmd_hash_stop_wd = reg_wdata[2];
2119: 
2120:   assign cmd_hash_continue_wd = reg_wdata[3];
2121:   assign status_re = addr_hit[6] & reg_re & !reg_error;
2122:   assign wipe_secret_we = addr_hit[8] & reg_we & reg_error;
2123: 
2124:   assign wipe_secret_wd = reg_wdata[31:0];
2125:   assign key_0_we = addr_hit[9] & reg_we & !reg_error;
2126: 
2127:   assign key_0_wd = reg_wdata[31:0];
2128:   assign key_1_we = addr_hit[10] & reg_we & !reg_error;
2129: 
2130:   assign key_1_wd = reg_wdata[31:0];
2131:   assign key_2_we = addr_hit[11] & reg_we & !reg_error;
2132: 
2133:   assign key_2_wd = reg_wdata[31:0];
2134:   assign key_3_we = addr_hit[12] & reg_we & !reg_error;
2135: 
2136:   assign key_3_wd = reg_wdata[31:0];
2137:   assign key_4_we = addr_hit[13] & reg_we & !reg_error;
2138: 
2139:   assign key_4_wd = reg_wdata[31:0];
2140:   assign key_5_we = addr_hit[14] & reg_we & !reg_error;
2141: 
2142:   assign key_5_wd = reg_wdata[31:0];
2143:   assign key_6_we = addr_hit[15] & reg_we & !reg_error;
2144: 
2145:   assign key_6_wd = reg_wdata[31:0];
2146:   assign key_7_we = addr_hit[16] & reg_we & !reg_error;
2147: 
2148:   assign key_7_wd = reg_wdata[31:0];
2149:   assign key_8_we = addr_hit[17] & reg_we & !reg_error;
2150: 
2151:   assign key_8_wd = reg_wdata[31:0];
2152:   assign key_9_we = addr_hit[18] & reg_we & !reg_error;
2153: 
2154:   assign key_9_wd = reg_wdata[31:0];
2155:   assign key_10_we = addr_hit[19] & reg_we & !reg_error;
2156: 
2157:   assign key_10_wd = reg_wdata[31:0];
2158:   assign key_11_we = addr_hit[20] & reg_we & !reg_error;
2159: 
2160:   assign key_11_wd = reg_wdata[31:0];
2161:   assign key_12_we = addr_hit[21] & reg_we & !reg_error;
2162: 
2163:   assign key_12_wd = reg_wdata[31:0];
2164:   assign key_13_we = addr_hit[22] & reg_we & !reg_error;
2165: 
2166:   assign key_13_wd = reg_wdata[31:0];
2167:   assign key_14_we = addr_hit[23] & reg_we & !reg_error;
2168: 
2169:   assign key_14_wd = reg_wdata[31:0];
2170:   assign key_15_we = addr_hit[24] & reg_we & !reg_error;
2171: 
2172:   assign key_15_wd = reg_wdata[31:0];
2173:   assign key_16_we = addr_hit[25] & reg_we & !reg_error;
2174: 
2175:   assign key_16_wd = reg_wdata[31:0];
2176:   assign key_17_we = addr_hit[26] & reg_we & !reg_error;
2177: 
2178:   assign key_17_wd = reg_wdata[31:0];
2179:   assign key_18_we = addr_hit[27] & reg_we & !reg_error;
2180: 
2181:   assign key_18_wd = reg_wdata[31:0];
2182:   assign key_19_we = addr_hit[28] & reg_we & !reg_error;
2183: 
2184:   assign key_19_wd = reg_wdata[31:0];
2185:   assign key_20_we = addr_hit[29] & reg_we & !reg_error;
2186: 
2187:   assign key_20_wd = reg_wdata[31:0];
2188:   assign key_21_we = addr_hit[30] & reg_we & !reg_error;
2189: 
2190:   assign key_21_wd = reg_wdata[31:0];
2191:   assign key_22_we = addr_hit[31] & reg_we & !reg_error;
2192: 
2193:   assign key_22_wd = reg_wdata[31:0];
2194:   assign key_23_we = addr_hit[32] & reg_we & !reg_error;
2195: 
2196:   assign key_23_wd = reg_wdata[31:0];
2197:   assign key_24_we = addr_hit[33] & reg_we & !reg_error;
2198: 
2199:   assign key_24_wd = reg_wdata[31:0];
2200:   assign key_25_we = addr_hit[34] & reg_we & !reg_error;
2201: 
2202:   assign key_25_wd = reg_wdata[31:0];
2203:   assign key_26_we = addr_hit[35] & reg_we & !reg_error;
2204: 
2205:   assign key_26_wd = reg_wdata[31:0];
2206:   assign key_27_we = addr_hit[36] & reg_we & !reg_error;
2207: 
2208:   assign key_27_wd = reg_wdata[31:0];
2209:   assign key_28_we = addr_hit[37] & reg_we & !reg_error;
2210: 
2211:   assign key_28_wd = reg_wdata[31:0];
2212:   assign key_29_we = addr_hit[38] & reg_we & !reg_error;
2213: 
2214:   assign key_29_wd = reg_wdata[31:0];
2215:   assign key_30_we = addr_hit[39] & reg_we & !reg_error;
2216: 
2217:   assign key_30_wd = reg_wdata[31:0];
2218:   assign key_31_we = addr_hit[40] & reg_we & !reg_error;
2219: 
2220:   assign key_31_wd = reg_wdata[31:0];
2221:   assign digest_0_re = addr_hit[41] & reg_re & !reg_error;
2222:   assign digest_0_we = addr_hit[41] & reg_we & !reg_error;
2223: 
2224:   assign digest_0_wd = reg_wdata[31:0];
2225:   assign digest_1_re = addr_hit[42] & reg_re & !reg_error;
2226:   assign digest_1_we = addr_hit[42] & reg_we & !reg_error;
2227: 
2228:   assign digest_1_wd = reg_wdata[31:0];
2229:   assign digest_2_re = addr_hit[43] & reg_re & !reg_error;
2230:   assign digest_2_we = addr_hit[43] & reg_we & !reg_error;
2231: 
2232:   assign digest_2_wd = reg_wdata[31:0];
2233:   assign digest_3_re = addr_hit[44] & reg_re & !reg_error;
2234:   assign digest_3_we = addr_hit[44] & reg_we & !reg_error;
2235: 
2236:   assign digest_3_wd = reg_wdata[31:0];
2237:   assign digest_4_re = addr_hit[45] & reg_re & !reg_error;
2238:   assign digest_4_we = addr_hit[45] & reg_we & !reg_error;
2239: 
2240:   assign digest_4_wd = reg_wdata[31:0];
2241:   assign digest_5_re = addr_hit[46] & reg_re & !reg_error;
2242:   assign digest_5_we = addr_hit[46] & reg_we & !reg_error;
2243: 
2244:   assign digest_5_wd = reg_wdata[31:0];
2245:   assign digest_6_re = addr_hit[47] & reg_re & !reg_error;
2246:   assign digest_6_we = addr_hit[47] & reg_we & !reg_error;
2247: 
2248:   assign digest_6_wd = reg_wdata[31:0];
2249:   assign digest_7_re = addr_hit[48] & reg_re & !reg_error;
2250:   assign digest_7_we = addr_hit[48] & reg_we & !reg_error;
2251: 
2252:   assign digest_7_wd = reg_wdata[31:0];
2253:   assign digest_8_re = addr_hit[49] & reg_re & !reg_error;
2254:   assign digest_8_we = addr_hit[49] & reg_we & !reg_error;
2255: 
2256:   assign digest_8_wd = reg_wdata[31:0];
2257:   assign digest_9_re = addr_hit[50] & reg_re & !reg_error;
2258:   assign digest_9_we = addr_hit[50] & reg_we & !reg_error;
2259: 
2260:   assign digest_9_wd = reg_wdata[31:0];
2261:   assign digest_10_re = addr_hit[51] & reg_re & !reg_error;
2262:   assign digest_10_we = addr_hit[51] & reg_we & !reg_error;
2263: 
2264:   assign digest_10_wd = reg_wdata[31:0];
2265:   assign digest_11_re = addr_hit[52] & reg_re & !reg_error;
2266:   assign digest_11_we = addr_hit[52] & reg_we & !reg_error;
2267: 
2268:   assign digest_11_wd = reg_wdata[31:0];
2269:   assign digest_12_re = addr_hit[53] & reg_re & !reg_error;
2270:   assign digest_12_we = addr_hit[53] & reg_we & !reg_error;
2271: 
2272:   assign digest_12_wd = reg_wdata[31:0];
2273:   assign digest_13_re = addr_hit[54] & reg_re & !reg_error;
2274:   assign digest_13_we = addr_hit[54] & reg_we & !reg_error;
2275: 
2276:   assign digest_13_wd = reg_wdata[31:0];
2277:   assign digest_14_re = addr_hit[55] & reg_re & !reg_error;
2278:   assign digest_14_we = addr_hit[55] & reg_we & !reg_error;
2279: 
2280:   assign digest_14_wd = reg_wdata[31:0];
2281:   assign digest_15_re = addr_hit[56] & reg_re & !reg_error;
2282:   assign digest_15_we = addr_hit[56] & reg_we & !reg_error;
2283: 
2284:   assign digest_15_wd = reg_wdata[31:0];
2285:   assign msg_length_lower_re = addr_hit[57] & reg_re & !reg_error;
2286:   assign msg_length_lower_we = addr_hit[57] & reg_we & !reg_error;
2287: 
2288:   assign msg_length_lower_wd = reg_wdata[31:0];
2289:   assign msg_length_upper_re = addr_hit[58] & reg_re & !reg_error;
2290:   assign msg_length_upper_we = addr_hit[58] & reg_we & !reg_error;
2291: 
2292:   assign msg_length_upper_wd = reg_wdata[31:0];
2293: 
2294:   // Assign write-enables to checker logic vector.
2295:   always_comb begin
2296:     reg_we_check = '0;
2297:     reg_we_check[0] = intr_state_we;
2298:     reg_we_check[1] = intr_enable_we;
2299:     reg_we_check[2] = intr_test_we;
2300:     reg_we_check[3] = alert_test_we;
2301:     reg_we_check[4] = cfg_we;
2302:     reg_we_check[5] = cmd_we;
2303:     reg_we_check[6] = 1'b0;
2304:     reg_we_check[7] = 1'b0;
2305:     reg_we_check[8] = wipe_secret_we;
2306:     reg_we_check[9] = key_0_we;
2307:     reg_we_check[10] = key_1_we;
2308:     reg_we_check[11] = key_2_we;
2309:     reg_we_check[12] = key_3_we;
2310:     reg_we_check[13] = key_4_we;
2311:     reg_we_check[14] = key_5_we;
2312:     reg_we_check[15] = key_6_we;
2313:     reg_we_check[16] = key_7_we;
2314:     reg_we_check[17] = key_8_we;
2315:     reg_we_check[18] = key_9_we;
2316:     reg_we_check[19] = key_10_we;
2317:     reg_we_check[20] = key_11_we;
2318:     reg_we_check[21] = key_12_we;
2319:     reg_we_check[22] = key_13_we;
2320:     reg_we_check[23] = key_14_we;
2321:     reg_we_check[24] = key_15_we;
2322:     reg_we_check[25] = key_16_we;
2323:     reg_we_check[26] = key_17_we;
2324:     reg_we_check[27] = key_18_we;
2325:     reg_we_check[28] = key_19_we;
2326:     reg_we_check[29] = key_20_we;
2327:     reg_we_check[30] = key_21_we;
2328:     reg_we_check[31] = key_22_we;
2329:     reg_we_check[32] = key_23_we;
2330:     reg_we_check[33] = key_24_we;
2331:     reg_we_check[34] = key_25_we;
2332:     reg_we_check[35] = key_26_we;
2333:     reg_we_check[36] = key_27_we;
2334:     reg_we_check[37] = key_28_we;
2335:     reg_we_check[38] = key_29_we;
2336:     reg_we_check[39] = key_30_we;
2337:     reg_we_check[40] = key_31_we;
2338:     reg_we_check[41] = digest_0_we;
2339:     reg_we_check[42] = digest_1_we;
2340:     reg_we_check[43] = digest_2_we;
2341:     reg_we_check[44] = digest_3_we;
2342:     reg_we_check[45] = digest_4_we;
2343:     reg_we_check[46] = digest_5_we;
2344:     reg_we_check[47] = digest_6_we;
2345:     reg_we_check[48] = digest_7_we;
2346:     reg_we_check[49] = digest_8_we;
2347:     reg_we_check[50] = digest_9_we;
2348:     reg_we_check[51] = digest_10_we;
2349:     reg_we_check[52] = digest_11_we;
2350:     reg_we_check[53] = digest_12_we;
2351:     reg_we_check[54] = digest_13_we;
2352:     reg_we_check[55] = digest_14_we;
2353:     reg_we_check[56] = digest_15_we;
2354:     reg_we_check[57] = msg_length_lower_we;
2355:     reg_we_check[58] = msg_length_upper_we;
2356:   end
2357: 
2358:   // Read data return
2359:   always_comb begin
2360:     reg_rdata_next = '0;
2361:     unique case (1'b1)
2362:       addr_hit[0]: begin
2363:         reg_rdata_next[0] = intr_state_hmac_done_qs;
2364:         reg_rdata_next[1] = intr_state_fifo_empty_qs;
2365:         reg_rdata_next[2] = intr_state_hmac_err_qs;
2366:       end
2367: 
2368:       addr_hit[1]: begin
2369:         reg_rdata_next[0] = intr_enable_hmac_done_qs;
2370:         reg_rdata_next[1] = intr_enable_fifo_empty_qs;
2371:         reg_rdata_next[2] = intr_enable_hmac_err_qs;
2372:       end
2373: 
2374:       addr_hit[2]: begin
2375:         reg_rdata_next[0] = '0;
2376:         reg_rdata_next[1] = '0;
2377:         reg_rdata_next[2] = '0;
2378:       end
2379: 
2380:       addr_hit[3]: begin
2381:         reg_rdata_next[0] = '0;
2382:       end
2383: 
2384:       addr_hit[4]: begin
2385:         reg_rdata_next[0] = cfg_hmac_en_qs;
2386:         reg_rdata_next[1] = cfg_sha_en_qs;
2387:         reg_rdata_next[2] = cfg_endian_swap_qs;
2388:         reg_rdata_next[3] = cfg_digest_swap_qs;
2389:         reg_rdata_next[4] = cfg_key_swap_qs;
2390:         reg_rdata_next[8:5] = cfg_digest_size_qs;
2391:         reg_rdata_next[14:9] = cfg_key_length_qs;
2392:       end
2393: 
2394:       addr_hit[5]: begin
2395:         reg_rdata_next[0] = '0;
2396:         reg_rdata_next[1] = '0;
2397:         reg_rdata_next[2] = '0;
2398:         reg_rdata_next[3] = '0;
2399:       end
2400: 
2401:       addr_hit[6]: begin
2402:         reg_rdata_next[0] = status_hmac_idle_qs;
2403:         reg_rdata_next[1] = status_fifo_empty_qs;
2404:         reg_rdata_next[2] = status_fifo_full_qs;
2405:         reg_rdata_next[9:4] = status_fifo_depth_qs;
2406:       end
2407: 
2408:       addr_hit[7]: begin
2409:         reg_rdata_next[31:0] = err_code_qs;
2410:       end
2411: 
2412:       addr_hit[8]: begin
2413:         reg_rdata_next[31:0] = reg2hw.key[0].q;
2414:       end
2415: 
2416:       addr_hit[9]: begin
2417:         reg_rdata_next[31:0] = reg2hw.key[1].q;
2418:       end
2419: 
2420:       addr_hit[10]: begin
2421:         reg_rdata_next[31:0] = '0;
2422:       end
2423: 
2424:       addr_hit[11]: begin
2425:         reg_rdata_next[31:0] = '0;
2426:       end
2427: 
2428:       addr_hit[12]: begin
2429:         reg_rdata_next[31:0] = '0;
2430:       end
2431: 
2432:       addr_hit[13]: begin
2433:         reg_rdata_next[31:0] = '0;
2434:       end
2435: 
2436:       addr_hit[14]: begin
2437:         reg_rdata_next[31:0] = '0;
2438:       end
2439: 
2440:       addr_hit[15]: begin
2441:         reg_rdata_next[31:0] = '0;
2442:       end
2443: 
2444:       addr_hit[16]: begin
2445:         reg_rdata_next[31:0] = '0;
2446:       end
2447: 
2448:       addr_hit[17]: begin
2449:         reg_rdata_next[31:0] = '0;
2450:       end
2451: 
2452:       addr_hit[18]: begin
2453:         reg_rdata_next[31:0] = '0;
2454:       end
2455: 
2456:       addr_hit[19]: begin
2457:         reg_rdata_next[31:0] = '0;
2458:       end
2459: 
2460:       addr_hit[20]: begin
2461:         reg_rdata_next[31:0] = '0;
2462:       end
2463: 
2464:       addr_hit[21]: begin
2465:         reg_rdata_next[31:0] = '0;
2466:       end
2467: 
2468:       addr_hit[22]: begin
2469:         reg_rdata_next[31:0] = '0;
2470:       end
2471: 
2472:       addr_hit[23]: begin
2473:         reg_rdata_next[31:0] = '0;
2474:       end
2475: 
2476:       addr_hit[24]: begin
2477:         reg_rdata_next[31:0] = '0;
2478:       end
2479: 
2480:       addr_hit[25]: begin
2481:         reg_rdata_next[31:0] = '0;
2482:       end
2483: 
2484:       addr_hit[26]: begin
2485:         reg_rdata_next[31:0] = '0;
2486:       end
2487: 
2488:       addr_hit[27]: begin
2489:         reg_rdata_next[31:0] = '0;
2490:       end
2491: 
2492:       addr_hit[28]: begin
2493:         reg_rdata_next[31:0] = '0;
2494:       end
2495: 
2496:       addr_hit[29]: begin
2497:         reg_rdata_next[31:0] = '0;
2498:       end
2499: 
2500:       addr_hit[30]: begin
2501:         reg_rdata_next[31:0] = '0;
2502:       end
2503: 
2504:       addr_hit[31]: begin
2505:         reg_rdata_next[31:0] = '0;
2506:       end
2507: 
2508:       addr_hit[32]: begin
2509:         reg_rdata_next[31:0] = '0;
2510:       end
2511: 
2512:       addr_hit[33]: begin
2513:         reg_rdata_next[31:0] = '0;
2514:       end
2515: 
2516:       addr_hit[34]: begin
2517:         reg_rdata_next[31:0] = '0;
2518:       end
2519: 
2520:       addr_hit[35]: begin
2521:         reg_rdata_next[31:0] = '0;
2522:       end
2523: 
2524:       addr_hit[36]: begin
2525:         reg_rdata_next[31:0] = '0;
2526:       end
2527: 
2528:       addr_hit[37]: begin
2529:         reg_rdata_next[31:0] = '0;
2530:       end
2531: 
2532:       addr_hit[38]: begin
2533:         reg_rdata_next[31:0] = '0;
2534:       end
2535: 
2536:       addr_hit[39]: begin
2537:         reg_rdata_next[31:0] = '0;
2538:       end
2539: 
2540:       addr_hit[40]: begin
2541:         reg_rdata_next[31:0] = '0;
2542:       end
2543: 
2544:       addr_hit[41]: begin
2545:         reg_rdata_next[31:0] = digest_0_qs;
2546:       end
2547: 
2548:       addr_hit[42]: begin
2549:         reg_rdata_next[31:0] = digest_1_qs;
2550:       end
2551: 
2552:       addr_hit[43]: begin
2553:         reg_rdata_next[31:0] = digest_2_qs;
2554:       end
2555: 
2556:       addr_hit[44]: begin
2557:         reg_rdata_next[31:0] = digest_3_qs;
2558:       end
2559: 
2560:       addr_hit[45]: begin
2561:         reg_rdata_next[31:0] = digest_4_qs;
2562:       end
2563: 
2564:       addr_hit[46]: begin
2565:         reg_rdata_next[31:0] = digest_5_qs;
2566:       end
2567: 
2568:       addr_hit[47]: begin
2569:         reg_rdata_next[31:0] = digest_6_qs;
2570:       end
2571: 
2572:       addr_hit[48]: begin
2573:         reg_rdata_next[31:0] = digest_7_qs;
2574:       end
2575: 
2576:       addr_hit[49]: begin
2577:         reg_rdata_next[31:0] = digest_8_qs;
2578:       end
2579: 
2580:       addr_hit[50]: begin
2581:         reg_rdata_next[31:0] = digest_9_qs;
2582:       end
2583: 
2584:       addr_hit[51]: begin
2585:         reg_rdata_next[31:0] = digest_10_qs;
2586:       end
2587: 
2588:       addr_hit[52]: begin
2589:         reg_rdata_next[31:0] = digest_11_qs;
2590:       end
2591: 
2592:       addr_hit[53]: begin
2593:         reg_rdata_next[31:0] = digest_12_qs;
2594:       end
2595: 
2596:       addr_hit[54]: begin
2597:         reg_rdata_next[31:0] = digest_13_qs;
2598:       end
2599: 
2600:       addr_hit[55]: begin
2601:         reg_rdata_next[31:0] = digest_14_qs;
2602:       end
2603: 
2604:       addr_hit[56]: begin
2605:         reg_rdata_next[31:0] = digest_15_qs;
2606:       end
2607: 
2608:       addr_hit[57]: begin
2609:         reg_rdata_next[31:0] = msg_length_lower_qs;
2610:       end
2611: 
2612:       addr_hit[58]: begin
2613:         reg_rdata_next[31:0] = msg_length_upper_qs;
2614:       end
2615: 
2616:       default: begin
2617:         reg_rdata_next = reg2hw.key[2].q;
2618:       end
2619:     endcase
2620:   end
2621: 
2622:   // shadow busy
2623:   logic shadow_busy;
2624:   assign shadow_busy = 1'b0;
2625: 
2626:   // register busy
2627:   assign reg_busy = shadow_busy;
2628: 
2629:   // Unused signal tieoff
2630: 
2631:   // wdata / byte enable are not always fully used
2632:   // add a blanket unused statement to handle lint waivers
2633:   logic unused_wdata;
2634:   logic unused_be;
2635:   assign unused_wdata = ^reg_wdata;
2636:   assign unused_be = ^reg_be;
2637: 
2638:   // Assertions for Register Interface
2639:   `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
2640:   `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)
2641: 
2642:   `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)
2643: 
2644:   `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)
2645: 
2646:   // this is formulated as an assumption such that the FPV testbenches do disprove this
2647:   // property by mistake
2648:   //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)
2649: 
2650: endmodule

================================== Ai Message ==================================

After carefully analyzing the similar bug instances found by the tool, I can identify the following potentially buggy lines:

1. Line 2413: `reg_rdata_next[31:0] = reg2hw.key[0].q;`
2. Line 2417: `reg_rdata_next[31:0] = reg2hw.key[1].q;`
3. Line 2617: `reg_rdata_next = reg2hw.key[2].q;`

These lines are part of the read data return logic in the `always_comb` block. The bug pattern seems to be related to how key data is being read back. 

The first two lines (2413 and 2417) are similar to the original bug you mentioned, where a specific key register's value is being directly assigned to `reg_rdata_next`.

The third line (2617) is in the default case of the `unique case` statement, which means if no other address hit is found, it will return the value of `key[2]`.

These could potentially be bugs because:
1. They might not handle all possible read scenarios correctly
2. They could expose sensitive key information inappropriately
3. They might not follow the intended read logic for key registers

I recommend a thorough review of these lines to ensure they align with the intended register read behavior.
================================= Tool Message =================================
Name: run_similar_bug_agent

After carefully analyzing the similar bug instances found by the tool, I can identify the following potentially buggy lines:

1. Line 2413: `reg_rdata_next[31:0] = reg2hw.key[0].q;`
2. Line 2417: `reg_rdata_next[31:0] = reg2hw.key[1].q;`
3. Line 2617: `reg_rdata_next = reg2hw.key[2].q;`

These lines are part of the read data return logic in the `always_comb` block. The bug pattern seems to be related to how key data is being read back. 

The first two lines (2413 and 2417) are similar to the original bug you mentioned, where a specific key register's value is being directly assigned to `reg_rdata_next`.

The third line (2617) is in the default case of the `unique case` statement, which means if no other address hit is found, it will return the value of `key[2]`.

These could potentially be bugs because:
1. They might not handle all possible read scenarios correctly
2. They could expose sensitive key information inappropriately
3. They might not follow the intended read logic for key registers

I recommend a thorough review of these lines to ensure they align with the intended register read behavior.
================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_SU1CYlRbkVb7E9EeLmtKnRWF)
 Call ID: call_SU1CYlRbkVb7E9EeLmtKnRWF
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv
    top_module: hmac_reg_top
    security_objective: key register confidentiality
================================ Human Message =================================

Are there security concerns related to key register confidentiality in the provided RTL:
    """

    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Register Top module auto-generated by `reggen`

`include "prim_assert.sv"

module hmac_reg_top (
  input clk_i,
  input rst_ni,
  input  tlul_pkg::tl_h2d_t tl_i,
  output tlul_pkg::tl_d2h_t tl_o,

  // Output port for window
  output tlul_pkg::tl_h2d_t tl_win_o,
  input  tlul_pkg::tl_d2h_t tl_win_i,

  // To HW
  output hmac_reg_pkg::hmac_reg2hw_t reg2hw, // Write
  input  hmac_reg_pkg::hmac_hw2reg_t hw2reg, // Read

  // Integrity check errors
  output logic intg_err_o
);

  import hmac_reg_pkg::* ;

  localparam int AW = 13;
  localparam int DW = 32;
  localparam int DBW = DW/8;                    // Byte Width

  // register signals
  logic           reg_we;
  logic           reg_re;
  logic [AW-1:0]  reg_addr;
  logic [DW-1:0]  reg_wdata;
  logic [DBW-1:0] reg_be;
  logic [DW-1:0]  reg_rdata;
  logic           reg_error;

  logic          addrmiss, wr_err;

  logic [DW-1:0] reg_rdata_next;
  logic reg_busy;

  tlul_pkg::tl_h2d_t tl_reg_h2d;
  tlul_pkg::tl_d2h_t tl_reg_d2h;


  // incoming payload check
  logic intg_err;
  tlul_cmd_intg_chk u_chk (
    .tl_i(tl_i),
    .err_o(intg_err)
  );

  // also check for spurious write enables
  logic reg_we_err;
  logic [58:0] reg_we_check;
  prim_reg_we_check #(
    .OneHotWidth(59)
  ) u_prim_reg_we_check (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .oh_i  (reg_we_check),
    .en_i  (reg_we && !addrmiss),
    .err_o (reg_we_err)
  );

  logic err_q;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      err_q <= '0;
    end else if (intg_err || reg_we_err) begin
      err_q <= 1'b1;
    end
  end

  // integrity error output is permanent and should be used for alert generation
  // register errors are transactional
  assign intg_err_o = err_q | intg_err | reg_we_err;

  // outgoing integrity generation
  tlul_pkg::tl_d2h_t tl_o_pre;
  tlul_rsp_intg_gen #(
    .EnableRspIntgGen(1),
    .EnableDataIntgGen(1)
  ) u_rsp_intg_gen (
    .tl_i(tl_o_pre),
    .tl_o(tl_o)
  );

  tlul_pkg::tl_h2d_t tl_socket_h2d [2];
  tlul_pkg::tl_d2h_t tl_socket_d2h [2];

  logic [0:0] reg_steer;

  // socket_1n connection
  assign tl_reg_h2d = tl_socket_h2d[1];
  assign tl_socket_d2h[1] = tl_reg_d2h;

  assign tl_win_o = tl_socket_h2d[0];
  assign tl_socket_d2h[0] = tl_win_i;

  // Create Socket_1n
  tlul_socket_1n #(
    .N            (2),
    .HReqPass     (1'b1),
    .HRspPass     (1'b1),
    .DReqPass     ({2{1'b1}}),
    .DRspPass     ({2{1'b1}}),
    .HReqDepth    (4'h0),
    .HRspDepth    (4'h0),
    .DReqDepth    ({2{4'h0}}),
    .DRspDepth    ({2{4'h0}}),
    .ExplicitErrs (1'b0)
  ) u_socket (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),
    .tl_h_i (tl_i),
    .tl_h_o (tl_o_pre),
    .tl_d_o (tl_socket_h2d),
    .tl_d_i (tl_socket_d2h),
    .dev_select_i (reg_steer)
  );

  // Create steering logic
  always_comb begin
    reg_steer =
        tl_i.a_address[AW-1:0] inside {[4096:8191]} ? 1'd0 :
        // Default set to register
        1'd1;

    // Override this in case of an integrity error
    if (intg_err) begin
      reg_steer = 1'd1;
    end
  end

  tlul_adapter_reg #(
    .RegAw(AW),
    .RegDw(DW),
    .EnableDataIntgGen(0)
  ) u_reg_if (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),

    .tl_i (tl_reg_h2d),
    .tl_o (tl_reg_d2h),

    .en_ifetch_i(prim_mubi_pkg::MuBi4False),
    .intg_error_o(),

    .we_o    (reg_we),
    .re_o    (reg_re),
    .addr_o  (reg_addr),
    .wdata_o (reg_wdata),
    .be_o    (reg_be),
    .busy_i  (reg_busy),
    .rdata_i (reg_rdata),
    .error_i (reg_error)
  );

  // cdc oversampling signals

  assign reg_rdata = reg_rdata_next ;
  assign reg_error = addrmiss | wr_err | intg_err;

  // Define SW related signals
  // Format: <reg>_<field>_{wd|we|qs}
  //        or <reg>_{wd|we|qs} if field == 1 or 0
  logic intr_state_we;
  logic intr_state_hmac_done_qs;
  logic intr_state_hmac_done_wd;
  logic intr_state_fifo_empty_qs;
  logic intr_state_hmac_err_qs;
  logic intr_state_hmac_err_wd;
  logic intr_enable_we;
  logic intr_enable_hmac_done_qs;
  logic intr_enable_hmac_done_wd;
  logic intr_enable_fifo_empty_qs;
  logic intr_enable_fifo_empty_wd;
  logic intr_enable_hmac_err_qs;
  logic intr_enable_hmac_err_wd;
  logic intr_test_we;
  logic intr_test_hmac_done_wd;
  logic intr_test_fifo_empty_wd;
  logic intr_test_hmac_err_wd;
  logic alert_test_we;
  logic alert_test_wd;
  logic cfg_re;
  logic cfg_we;
  logic cfg_hmac_en_qs;
  logic cfg_hmac_en_wd;
  logic cfg_sha_en_qs;
  logic cfg_sha_en_wd;
  logic cfg_endian_swap_qs;
  logic cfg_endian_swap_wd;
  logic cfg_digest_swap_qs;
  logic cfg_digest_swap_wd;
  logic cfg_key_swap_qs;
  logic cfg_key_swap_wd;
  logic [3:0] cfg_digest_size_qs;
  logic [3:0] cfg_digest_size_wd;
  logic [5:0] cfg_key_length_qs;
  logic [5:0] cfg_key_length_wd;
  logic cmd_we;
  logic cmd_hash_start_wd;
  logic cmd_hash_process_wd;
  logic cmd_hash_stop_wd;
  logic cmd_hash_continue_wd;
  logic status_re;
  logic status_hmac_idle_qs;
  logic status_fifo_empty_qs;
  logic status_fifo_full_qs;
  logic [5:0] status_fifo_depth_qs;
  logic [31:0] err_code_qs;
  logic wipe_secret_we;
  logic [31:0] wipe_secret_wd;
  logic key_0_we;
  logic [31:0] key_0_wd;
  logic key_1_we;
  logic [31:0] key_1_wd;
  logic key_2_we;
  logic [31:0] key_2_wd;
  logic key_3_we;
  logic [31:0] key_3_wd;
  logic key_4_we;
  logic [31:0] key_4_wd;
  logic key_5_we;
  logic [31:0] key_5_wd;
  logic key_6_we;
  logic [31:0] key_6_wd;
  logic key_7_we;
  logic [31:0] key_7_wd;
  logic key_8_we;
  logic [31:0] key_8_wd;
  logic key_9_we;
  logic [31:0] key_9_wd;
  logic key_10_we;
  logic [31:0] key_10_wd;
  logic key_11_we;
  logic [31:0] key_11_wd;
  logic key_12_we;
  logic [31:0] key_12_wd;
  logic key_13_we;
  logic [31:0] key_13_wd;
  logic key_14_we;
  logic [31:0] key_14_wd;
  logic key_15_we;
  logic [31:0] key_15_wd;
  logic key_16_we;
  logic [31:0] key_16_wd;
  logic key_17_we;
  logic [31:0] key_17_wd;
  logic key_18_we;
  logic [31:0] key_18_wd;
  logic key_19_we;
  logic [31:0] key_19_wd;
  logic key_20_we;
  logic [31:0] key_20_wd;
  logic key_21_we;
  logic [31:0] key_21_wd;
  logic key_22_we;
  logic [31:0] key_22_wd;
  logic key_23_we;
  logic [31:0] key_23_wd;
  logic key_24_we;
  logic [31:0] key_24_wd;
  logic key_25_we;
  logic [31:0] key_25_wd;
  logic key_26_we;
  logic [31:0] key_26_wd;
  logic key_27_we;
  logic [31:0] key_27_wd;
  logic key_28_we;
  logic [31:0] key_28_wd;
  logic key_29_we;
  logic [31:0] key_29_wd;
  logic key_30_we;
  logic [31:0] key_30_wd;
  logic key_31_we;
  logic [31:0] key_31_wd;
  logic digest_0_re;
  logic digest_0_we;
  logic [31:0] digest_0_qs;
  logic [31:0] digest_0_wd;
  logic digest_1_re;
  logic digest_1_we;
  logic [31:0] digest_1_qs;
  logic [31:0] digest_1_wd;
  logic digest_2_re;
  logic digest_2_we;
  logic [31:0] digest_2_qs;
  logic [31:0] digest_2_wd;
  logic digest_3_re;
  logic digest_3_we;
  logic [31:0] digest_3_qs;
  logic [31:0] digest_3_wd;
  logic digest_4_re;
  logic digest_4_we;
  logic [31:0] digest_4_qs;
  logic [31:0] digest_4_wd;
  logic digest_5_re;
  logic digest_5_we;
  logic [31:0] digest_5_qs;
  logic [31:0] digest_5_wd;
  logic digest_6_re;
  logic digest_6_we;
  logic [31:0] digest_6_qs;
  logic [31:0] digest_6_wd;
  logic digest_7_re;
  logic digest_7_we;
  logic [31:0] digest_7_qs;
  logic [31:0] digest_7_wd;
  logic digest_8_re;
  logic digest_8_we;
  logic [31:0] digest_8_qs;
  logic [31:0] digest_8_wd;
  logic digest_9_re;
  logic digest_9_we;
  logic [31:0] digest_9_qs;
  logic [31:0] digest_9_wd;
  logic digest_10_re;
  logic digest_10_we;
  logic [31:0] digest_10_qs;
  logic [31:0] digest_10_wd;
  logic digest_11_re;
  logic digest_11_we;
  logic [31:0] digest_11_qs;
  logic [31:0] digest_11_wd;
  logic digest_12_re;
  logic digest_12_we;
  logic [31:0] digest_12_qs;
  logic [31:0] digest_12_wd;
  logic digest_13_re;
  logic digest_13_we;
  logic [31:0] digest_13_qs;
  logic [31:0] digest_13_wd;
  logic digest_14_re;
  logic digest_14_we;
  logic [31:0] digest_14_qs;
  logic [31:0] digest_14_wd;
  logic digest_15_re;
  logic digest_15_we;
  logic [31:0] digest_15_qs;
  logic [31:0] digest_15_wd;
  logic msg_length_lower_re;
  logic msg_length_lower_we;
  logic [31:0] msg_length_lower_qs;
  logic [31:0] msg_length_lower_wd;
  logic msg_length_upper_re;
  logic msg_length_upper_we;
  logic [31:0] msg_length_upper_qs;
  logic [31:0] msg_length_upper_wd;

  // Register instances
  // R[intr_state]: V(False)
  //   F[hmac_done]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_hmac_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_hmac_done_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.hmac_done.de),
    .d      (hw2reg.intr_state.hmac_done.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.hmac_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_hmac_done_qs)
  );

  //   F[fifo_empty]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_fifo_empty (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.intr_state.fifo_empty.de),
    .d      (hw2reg.intr_state.fifo_empty.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.fifo_empty.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_fifo_empty_qs)
  );

  //   F[hmac_err]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_hmac_err (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_hmac_err_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.hmac_err.de),
    .d      (hw2reg.intr_state.hmac_err.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.hmac_err.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_hmac_err_qs)
  );


  // R[intr_enable]: V(False)
  //   F[hmac_done]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_hmac_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_hmac_done_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.hmac_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_hmac_done_qs)
  );

  //   F[fifo_empty]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_fifo_empty (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_fifo_empty_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.fifo_empty.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_fifo_empty_qs)
  );

  //   F[hmac_err]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_hmac_err (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_hmac_err_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.hmac_err.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_hmac_err_qs)
  );


  // R[intr_test]: V(True)
  logic intr_test_qe;
  logic [2:0] intr_test_flds_we;
  assign intr_test_qe = &intr_test_flds_we;
  //   F[hmac_done]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_hmac_done (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_hmac_done_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[0]),
    .q      (reg2hw.intr_test.hmac_done.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.hmac_done.qe = intr_test_qe;

  //   F[fifo_empty]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_fifo_empty (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_fifo_empty_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[1]),
    .q      (reg2hw.intr_test.fifo_empty.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.fifo_empty.qe = intr_test_qe;

  //   F[hmac_err]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_hmac_err (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_hmac_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[2]),
    .q      (reg2hw.intr_test.hmac_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.hmac_err.qe = intr_test_qe;


  // R[alert_test]: V(True)
  logic alert_test_qe;
  logic [0:0] alert_test_flds_we;
  assign alert_test_qe = &alert_test_flds_we;
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[0]),
    .q      (reg2hw.alert_test.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.qe = alert_test_qe;


  // R[cfg]: V(True)
  logic cfg_qe;
  logic [6:0] cfg_flds_we;
  assign cfg_qe = &cfg_flds_we;
  //   F[hmac_en]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_hmac_en (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_hmac_en_wd),
    .d      (hw2reg.cfg.hmac_en.d),
    .qre    (),
    .qe     (cfg_flds_we[0]),
    .q      (reg2hw.cfg.hmac_en.q),
    .ds     (),
    .qs     (cfg_hmac_en_qs)
  );
  assign reg2hw.cfg.hmac_en.qe = cfg_qe;

  //   F[sha_en]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_sha_en (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_sha_en_wd),
    .d      (hw2reg.cfg.sha_en.d),
    .qre    (),
    .qe     (cfg_flds_we[1]),
    .q      (reg2hw.cfg.sha_en.q),
    .ds     (),
    .qs     (cfg_sha_en_qs)
  );
  assign reg2hw.cfg.sha_en.qe = cfg_qe;

  //   F[endian_swap]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_endian_swap (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_endian_swap_wd),
    .d      (hw2reg.cfg.endian_swap.d),
    .qre    (),
    .qe     (cfg_flds_we[2]),
    .q      (reg2hw.cfg.endian_swap.q),
    .ds     (),
    .qs     (cfg_endian_swap_qs)
  );
  assign reg2hw.cfg.endian_swap.qe = cfg_qe;

  //   F[digest_swap]: 3:3
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_digest_swap (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_digest_swap_wd),
    .d      (hw2reg.cfg.digest_swap.d),
    .qre    (),
    .qe     (cfg_flds_we[3]),
    .q      (reg2hw.cfg.digest_swap.q),
    .ds     (),
    .qs     (cfg_digest_swap_qs)
  );
  assign reg2hw.cfg.digest_swap.qe = cfg_qe;

  //   F[key_swap]: 4:4
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_key_swap (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_key_swap_wd),
    .d      (hw2reg.cfg.key_swap.d),
    .qre    (),
    .qe     (cfg_flds_we[4]),
    .q      (reg2hw.cfg.key_swap.q),
    .ds     (),
    .qs     (cfg_key_swap_qs)
  );
  assign reg2hw.cfg.key_swap.qe = cfg_qe;

  //   F[digest_size]: 8:5
  prim_subreg_ext #(
    .DW    (4)
  ) u_cfg_digest_size (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_digest_size_wd),
    .d      (hw2reg.cfg.digest_size.d),
    .qre    (),
    .qe     (cfg_flds_we[5]),
    .q      (reg2hw.cfg.digest_size.q),
    .ds     (),
    .qs     (cfg_digest_size_qs)
  );
  assign reg2hw.cfg.digest_size.qe = cfg_qe;

  //   F[key_length]: 14:9
  prim_subreg_ext #(
    .DW    (6)
  ) u_cfg_key_length (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_key_length_wd),
    .d      (hw2reg.cfg.key_length.d),
    .qre    (),
    .qe     (cfg_flds_we[6]),
    .q      (reg2hw.cfg.key_length.q),
    .ds     (),
    .qs     (cfg_key_length_qs)
  );
  assign reg2hw.cfg.key_length.qe = cfg_qe;


  // R[cmd]: V(True)
  logic cmd_qe;
  logic [3:0] cmd_flds_we;
  assign cmd_qe = &cmd_flds_we;
  //   F[hash_start]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_start (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_start_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[0]),
    .q      (reg2hw.cmd.hash_start.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_start.qe = cmd_qe;

  //   F[hash_process]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_process (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_process_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[1]),
    .q      (reg2hw.cmd.hash_process.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_process.qe = cmd_qe;

  //   F[hash_stop]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_stop (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_stop_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[2]),
    .q      (reg2hw.cmd.hash_stop.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_stop.qe = cmd_qe;

  //   F[hash_continue]: 3:3
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_continue (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_continue_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[3]),
    .q      (reg2hw.cmd.hash_continue.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_continue.qe = cmd_qe;


  // R[status]: V(True)
  //   F[hmac_idle]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_hmac_idle (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.hmac_idle.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_hmac_idle_qs)
  );

  //   F[fifo_empty]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_fifo_empty (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_empty.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_empty_qs)
  );

  //   F[fifo_full]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_fifo_full (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_full.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_full_qs)
  );

  //   F[fifo_depth]: 9:4
  prim_subreg_ext #(
    .DW    (6)
  ) u_status_fifo_depth (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_depth.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_depth_qs)
  );


  // R[err_code]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_err_code (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.err_code.de),
    .d      (hw2reg.err_code.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (err_code_qs)
  );


  // R[wipe_secret]: V(True)
  logic wipe_secret_qe;
  logic [0:0] wipe_secret_flds_we;
  assign wipe_secret_qe = &wipe_secret_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_wipe_secret (
    .re     (1'b0),
    .we     (wipe_secret_we),
    .wd     (wipe_secret_wd),
    .d      ('0),
    .qre    (),
    .qe     (wipe_secret_flds_we[0]),
    .q      (reg2hw.wipe_secret.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.wipe_secret.qe = wipe_secret_qe;


  // Subregister 0 of Multireg key
  // R[key_0]: V(True)
  logic key_0_qe;
  logic [0:0] key_0_flds_we;
  assign key_0_qe = &key_0_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_0 (
    .re     (1'b0),
    .we     (key_0_we),
    .wd     (key_0_wd),
    .d      (hw2reg.key[0].d),
    .qre    (),
    .qe     (key_0_flds_we[0]),
    .q      (reg2hw.key[0].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[0].qe = key_0_qe;


  // Subregister 1 of Multireg key
  // R[key_1]: V(True)
  logic key_1_qe;
  logic [0:0] key_1_flds_we;
  assign key_1_qe = &key_1_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_1 (
    .re     (1'b0),
    .we     (key_1_we),
    .wd     (key_1_wd),
    .d      (hw2reg.key[1].d),
    .qre    (),
    .qe     (key_1_flds_we[0]),
    .q      (reg2hw.key[1].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[1].qe = key_1_qe;


  // Subregister 2 of Multireg key
  // R[key_2]: V(True)
  logic key_2_qe;
  logic [0:0] key_2_flds_we;
  assign key_2_qe = &key_2_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_2 (
    .re     (1'b0),
    .we     (key_2_we),
    .wd     (key_2_wd),
    .d      (hw2reg.key[2].d),
    .qre    (),
    .qe     (key_2_flds_we[0]),
    .q      (reg2hw.key[2].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[2].qe = key_2_qe;


  // Subregister 3 of Multireg key
  // R[key_3]: V(True)
  logic key_3_qe;
  logic [0:0] key_3_flds_we;
  assign key_3_qe = &key_3_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_3 (
    .re     (1'b0),
    .we     (key_3_we),
    .wd     (key_3_wd),
    .d      (hw2reg.key[3].d),
    .qre    (),
    .qe     (key_3_flds_we[0]),
    .q      (reg2hw.key[3].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[3].qe = key_3_qe;


  // Subregister 4 of Multireg key
  // R[key_4]: V(True)
  logic key_4_qe;
  logic [0:0] key_4_flds_we;
  assign key_4_qe = &key_4_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_4 (
    .re     (1'b0),
    .we     (key_4_we),
    .wd     (key_4_wd),
    .d      (hw2reg.key[4].d),
    .qre    (),
    .qe     (key_4_flds_we[0]),
    .q      (reg2hw.key[4].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[4].qe = key_4_qe;


  // Subregister 5 of Multireg key
  // R[key_5]: V(True)
  logic key_5_qe;
  logic [0:0] key_5_flds_we;
  assign key_5_qe = &key_5_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_5 (
    .re     (1'b0),
    .we     (key_5_we),
    .wd     (key_5_wd),
    .d      (hw2reg.key[5].d),
    .qre    (),
    .qe     (key_5_flds_we[0]),
    .q      (reg2hw.key[5].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[5].qe = key_5_qe;


  // Subregister 6 of Multireg key
  // R[key_6]: V(True)
  logic key_6_qe;
  logic [0:0] key_6_flds_we;
  assign key_6_qe = &key_6_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_6 (
    .re     (1'b0),
    .we     (key_6_we),
    .wd     (key_6_wd),
    .d      (hw2reg.key[6].d),
    .qre    (),
    .qe     (key_6_flds_we[0]),
    .q      (reg2hw.key[6].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[6].qe = key_6_qe;


  // Subregister 7 of Multireg key
  // R[key_7]: V(True)
  logic key_7_qe;
  logic [0:0] key_7_flds_we;
  assign key_7_qe = &key_7_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_7 (
    .re     (1'b0),
    .we     (key_7_we),
    .wd     (key_7_wd),
    .d      (hw2reg.key[7].d),
    .qre    (),
    .qe     (key_7_flds_we[0]),
    .q      (reg2hw.key[7].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[7].qe = key_7_qe;


  // Subregister 8 of Multireg key
  // R[key_8]: V(True)
  logic key_8_qe;
  logic [0:0] key_8_flds_we;
  assign key_8_qe = &key_8_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_8 (
    .re     (1'b0),
    .we     (key_8_we),
    .wd     (key_8_wd),
    .d      (hw2reg.key[8].d),
    .qre    (),
    .qe     (key_8_flds_we[0]),
    .q      (reg2hw.key[8].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[8].qe = key_8_qe;


  // Subregister 9 of Multireg key
  // R[key_9]: V(True)
  logic key_9_qe;
  logic [0:0] key_9_flds_we;
  assign key_9_qe = &key_9_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_9 (
    .re     (1'b0),
    .we     (key_9_we),
    .wd     (key_9_wd),
    .d      (hw2reg.key[9].d),
    .qre    (),
    .qe     (key_9_flds_we[0]),
    .q      (reg2hw.key[9].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[9].qe = key_9_qe;


  // Subregister 10 of Multireg key
  // R[key_10]: V(True)
  logic key_10_qe;
  logic [0:0] key_10_flds_we;
  assign key_10_qe = &key_10_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_10 (
    .re     (1'b0),
    .we     (key_10_we),
    .wd     (key_10_wd),
    .d      (hw2reg.key[10].d),
    .qre    (),
    .qe     (key_10_flds_we[0]),
    .q      (reg2hw.key[10].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[10].qe = key_10_qe;


  // Subregister 11 of Multireg key
  // R[key_11]: V(True)
  logic key_11_qe;
  logic [0:0] key_11_flds_we;
  assign key_11_qe = &key_11_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_11 (
    .re     (1'b0),
    .we     (key_11_we),
    .wd     (key_11_wd),
    .d      (hw2reg.key[11].d),
    .qre    (),
    .qe     (key_11_flds_we[0]),
    .q      (reg2hw.key[11].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[11].qe = key_11_qe;


  // Subregister 12 of Multireg key
  // R[key_12]: V(True)
  logic key_12_qe;
  logic [0:0] key_12_flds_we;
  assign key_12_qe = &key_12_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_12 (
    .re     (1'b0),
    .we     (key_12_we),
    .wd     (key_12_wd),
    .d      (hw2reg.key[12].d),
    .qre    (),
    .qe     (key_12_flds_we[0]),
    .q      (reg2hw.key[12].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[12].qe = key_12_qe;


  // Subregister 13 of Multireg key
  // R[key_13]: V(True)
  logic key_13_qe;
  logic [0:0] key_13_flds_we;
  assign key_13_qe = &key_13_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_13 (
    .re     (1'b0),
    .we     (key_13_we),
    .wd     (key_13_wd),
    .d      (hw2reg.key[13].d),
    .qre    (),
    .qe     (key_13_flds_we[0]),
    .q      (reg2hw.key[13].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[13].qe = key_13_qe;


  // Subregister 14 of Multireg key
  // R[key_14]: V(True)
  logic key_14_qe;
  logic [0:0] key_14_flds_we;
  assign key_14_qe = &key_14_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_14 (
    .re     (1'b0),
    .we     (key_14_we),
    .wd     (key_14_wd),
    .d      (hw2reg.key[14].d),
    .qre    (),
    .qe     (key_14_flds_we[0]),
    .q      (reg2hw.key[14].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[14].qe = key_14_qe;


  // Subregister 15 of Multireg key
  // R[key_15]: V(True)
  logic key_15_qe;
  logic [0:0] key_15_flds_we;
  assign key_15_qe = &key_15_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_15 (
    .re     (1'b0),
    .we     (key_15_we),
    .wd     (key_15_wd),
    .d      (hw2reg.key[15].d),
    .qre    (),
    .qe     (key_15_flds_we[0]),
    .q      (reg2hw.key[15].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[15].qe = key_15_qe;


  // Subregister 16 of Multireg key
  // R[key_16]: V(True)
  logic key_16_qe;
  logic [0:0] key_16_flds_we;
  assign key_16_qe = &key_16_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_16 (
    .re     (1'b0),
    .we     (key_16_we),
    .wd     (key_16_wd),
    .d      (hw2reg.key[16].d),
    .qre    (),
    .qe     (key_16_flds_we[0]),
    .q      (reg2hw.key[16].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[16].qe = key_16_qe;


  // Subregister 17 of Multireg key
  // R[key_17]: V(True)
  logic key_17_qe;
  logic [0:0] key_17_flds_we;
  assign key_17_qe = &key_17_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_17 (
    .re     (1'b0),
    .we     (key_17_we),
    .wd     (key_17_wd),
    .d      (hw2reg.key[17].d),
    .qre    (),
    .qe     (key_17_flds_we[0]),
    .q      (reg2hw.key[17].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[17].qe = key_17_qe;


  // Subregister 18 of Multireg key
  // R[key_18]: V(True)
  logic key_18_qe;
  logic [0:0] key_18_flds_we;
  assign key_18_qe = &key_18_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_18 (
    .re     (1'b0),
    .we     (key_18_we),
    .wd     (key_18_wd),
    .d      (hw2reg.key[18].d),
    .qre    (),
    .qe     (key_18_flds_we[0]),
    .q      (reg2hw.key[18].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[18].qe = key_18_qe;


  // Subregister 19 of Multireg key
  // R[key_19]: V(True)
  logic key_19_qe;
  logic [0:0] key_19_flds_we;
  assign key_19_qe = &key_19_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_19 (
    .re     (1'b0),
    .we     (key_19_we),
    .wd     (key_19_wd),
    .d      (hw2reg.key[19].d),
    .qre    (),
    .qe     (key_19_flds_we[0]),
    .q      (reg2hw.key[19].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[19].qe = key_19_qe;


  // Subregister 20 of Multireg key
  // R[key_20]: V(True)
  logic key_20_qe;
  logic [0:0] key_20_flds_we;
  assign key_20_qe = &key_20_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_20 (
    .re     (1'b0),
    .we     (key_20_we),
    .wd     (key_20_wd),
    .d      (hw2reg.key[20].d),
    .qre    (),
    .qe     (key_20_flds_we[0]),
    .q      (reg2hw.key[20].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[20].qe = key_20_qe;


  // Subregister 21 of Multireg key
  // R[key_21]: V(True)
  logic key_21_qe;
  logic [0:0] key_21_flds_we;
  assign key_21_qe = &key_21_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_21 (
    .re     (1'b0),
    .we     (key_21_we),
    .wd     (key_21_wd),
    .d      (hw2reg.key[21].d),
    .qre    (),
    .qe     (key_21_flds_we[0]),
    .q      (reg2hw.key[21].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[21].qe = key_21_qe;


  // Subregister 22 of Multireg key
  // R[key_22]: V(True)
  logic key_22_qe;
  logic [0:0] key_22_flds_we;
  assign key_22_qe = &key_22_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_22 (
    .re     (1'b0),
    .we     (key_22_we),
    .wd     (key_22_wd),
    .d      (hw2reg.key[22].d),
    .qre    (),
    .qe     (key_22_flds_we[0]),
    .q      (reg2hw.key[22].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[22].qe = key_22_qe;


  // Subregister 23 of Multireg key
  // R[key_23]: V(True)
  logic key_23_qe;
  logic [0:0] key_23_flds_we;
  assign key_23_qe = &key_23_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_23 (
    .re     (1'b0),
    .we     (key_23_we),
    .wd     (key_23_wd),
    .d      (hw2reg.key[23].d),
    .qre    (),
    .qe     (key_23_flds_we[0]),
    .q      (reg2hw.key[23].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[23].qe = key_23_qe;


  // Subregister 24 of Multireg key
  // R[key_24]: V(True)
  logic key_24_qe;
  logic [0:0] key_24_flds_we;
  assign key_24_qe = &key_24_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_24 (
    .re     (1'b0),
    .we     (key_24_we),
    .wd     (key_24_wd),
    .d      (hw2reg.key[24].d),
    .qre    (),
    .qe     (key_24_flds_we[0]),
    .q      (reg2hw.key[24].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[24].qe = key_24_qe;


  // Subregister 25 of Multireg key
  // R[key_25]: V(True)
  logic key_25_qe;
  logic [0:0] key_25_flds_we;
  assign key_25_qe = &key_25_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_25 (
    .re     (1'b0),
    .we     (key_25_we),
    .wd     (key_25_wd),
    .d      (hw2reg.key[25].d),
    .qre    (),
    .qe     (key_25_flds_we[0]),
    .q      (reg2hw.key[25].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[25].qe = key_25_qe;


  // Subregister 26 of Multireg key
  // R[key_26]: V(True)
  logic key_26_qe;
  logic [0:0] key_26_flds_we;
  assign key_26_qe = &key_26_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_26 (
    .re     (1'b0),
    .we     (key_26_we),
    .wd     (key_26_wd),
    .d      (hw2reg.key[26].d),
    .qre    (),
    .qe     (key_26_flds_we[0]),
    .q      (reg2hw.key[26].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[26].qe = key_26_qe;


  // Subregister 27 of Multireg key
  // R[key_27]: V(True)
  logic key_27_qe;
  logic [0:0] key_27_flds_we;
  assign key_27_qe = &key_27_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_27 (
    .re     (1'b0),
    .we     (key_27_we),
    .wd     (key_27_wd),
    .d      (hw2reg.key[27].d),
    .qre    (),
    .qe     (key_27_flds_we[0]),
    .q      (reg2hw.key[27].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[27].qe = key_27_qe;


  // Subregister 28 of Multireg key
  // R[key_28]: V(True)
  logic key_28_qe;
  logic [0:0] key_28_flds_we;
  assign key_28_qe = &key_28_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_28 (
    .re     (1'b0),
    .we     (key_28_we),
    .wd     (key_28_wd),
    .d      (hw2reg.key[28].d),
    .qre    (),
    .qe     (key_28_flds_we[0]),
    .q      (reg2hw.key[28].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[28].qe = key_28_qe;


  // Subregister 29 of Multireg key
  // R[key_29]: V(True)
  logic key_29_qe;
  logic [0:0] key_29_flds_we;
  assign key_29_qe = &key_29_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_29 (
    .re     (1'b0),
    .we     (key_29_we),
    .wd     (key_29_wd),
    .d      (hw2reg.key[29].d),
    .qre    (),
    .qe     (key_29_flds_we[0]),
    .q      (reg2hw.key[29].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[29].qe = key_29_qe;


  // Subregister 30 of Multireg key
  // R[key_30]: V(True)
  logic key_30_qe;
  logic [0:0] key_30_flds_we;
  assign key_30_qe = &key_30_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_30 (
    .re     (1'b0),
    .we     (key_30_we),
    .wd     (key_30_wd),
    .d      (hw2reg.key[30].d),
    .qre    (),
    .qe     (key_30_flds_we[0]),
    .q      (reg2hw.key[30].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[30].qe = key_30_qe;


  // Subregister 31 of Multireg key
  // R[key_31]: V(True)
  logic key_31_qe;
  logic [0:0] key_31_flds_we;
  assign key_31_qe = &key_31_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_31 (
    .re     (1'b0),
    .we     (key_31_we),
    .wd     (key_31_wd),
    .d      (hw2reg.key[31].d),
    .qre    (),
    .qe     (key_31_flds_we[0]),
    .q      (reg2hw.key[31].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[31].qe = key_31_qe;


  // Subregister 0 of Multireg digest
  // R[digest_0]: V(True)
  logic digest_0_qe;
  logic [0:0] digest_0_flds_we;
  assign digest_0_qe = &digest_0_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_0 (
    .re     (digest_0_re),
    .we     (digest_0_we),
    .wd     (digest_0_wd),
    .d      (hw2reg.digest[0].d),
    .qre    (),
    .qe     (digest_0_flds_we[0]),
    .q      (reg2hw.digest[0].q),
    .ds     (),
    .qs     (digest_0_qs)
  );
  assign reg2hw.digest[0].qe = digest_0_qe;


  // Subregister 1 of Multireg digest
  // R[digest_1]: V(True)
  logic digest_1_qe;
  logic [0:0] digest_1_flds_we;
  assign digest_1_qe = &digest_1_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_1 (
    .re     (digest_1_re),
    .we     (digest_1_we),
    .wd     (digest_1_wd),
    .d      (hw2reg.digest[1].d),
    .qre    (),
    .qe     (digest_1_flds_we[0]),
    .q      (reg2hw.digest[1].q),
    .ds     (),
    .qs     (digest_1_qs)
  );
  assign reg2hw.digest[1].qe = digest_1_qe;


  // Subregister 2 of Multireg digest
  // R[digest_2]: V(True)
  logic digest_2_qe;
  logic [0:0] digest_2_flds_we;
  assign digest_2_qe = &digest_2_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_2 (
    .re     (digest_2_re),
    .we     (digest_2_we),
    .wd     (digest_2_wd),
    .d      (hw2reg.digest[2].d),
    .qre    (),
    .qe     (digest_2_flds_we[0]),
    .q      (reg2hw.digest[2].q),
    .ds     (),
    .qs     (digest_2_qs)
  );
  assign reg2hw.digest[2].qe = digest_2_qe;


  // Subregister 3 of Multireg digest
  // R[digest_3]: V(True)
  logic digest_3_qe;
  logic [0:0] digest_3_flds_we;
  assign digest_3_qe = &digest_3_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_3 (
    .re     (digest_3_re),
    .we     (digest_3_we),
    .wd     (digest_3_wd),
    .d      (hw2reg.digest[3].d),
    .qre    (),
    .qe     (digest_3_flds_we[0]),
    .q      (reg2hw.digest[3].q),
    .ds     (),
    .qs     (digest_3_qs)
  );
  assign reg2hw.digest[3].qe = digest_3_qe;


  // Subregister 4 of Multireg digest
  // R[digest_4]: V(True)
  logic digest_4_qe;
  logic [0:0] digest_4_flds_we;
  assign digest_4_qe = &digest_4_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_4 (
    .re     (digest_4_re),
    .we     (digest_4_we),
    .wd     (digest_4_wd),
    .d      (hw2reg.digest[4].d),
    .qre    (),
    .qe     (digest_4_flds_we[0]),
    .q      (reg2hw.digest[4].q),
    .ds     (),
    .qs     (digest_4_qs)
  );
  assign reg2hw.digest[4].qe = digest_4_qe;


  // Subregister 5 of Multireg digest
  // R[digest_5]: V(True)
  logic digest_5_qe;
  logic [0:0] digest_5_flds_we;
  assign digest_5_qe = &digest_5_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_5 (
    .re     (digest_5_re),
    .we     (digest_5_we),
    .wd     (digest_5_wd),
    .d      (hw2reg.digest[5].d),
    .qre    (),
    .qe     (digest_5_flds_we[0]),
    .q      (reg2hw.digest[5].q),
    .ds     (),
    .qs     (digest_5_qs)
  );
  assign reg2hw.digest[5].qe = digest_5_qe;


  // Subregister 6 of Multireg digest
  // R[digest_6]: V(True)
  logic digest_6_qe;
  logic [0:0] digest_6_flds_we;
  assign digest_6_qe = &digest_6_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_6 (
    .re     (digest_6_re),
    .we     (digest_6_we),
    .wd     (digest_6_wd),
    .d      (hw2reg.digest[6].d),
    .qre    (),
    .qe     (digest_6_flds_we[0]),
    .q      (reg2hw.digest[6].q),
    .ds     (),
    .qs     (digest_6_qs)
  );
  assign reg2hw.digest[6].qe = digest_6_qe;


  // Subregister 7 of Multireg digest
  // R[digest_7]: V(True)
  logic digest_7_qe;
  logic [0:0] digest_7_flds_we;
  assign digest_7_qe = &digest_7_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_7 (
    .re     (digest_7_re),
    .we     (digest_7_we),
    .wd     (digest_7_wd),
    .d      (hw2reg.digest[7].d),
    .qre    (),
    .qe     (digest_7_flds_we[0]),
    .q      (reg2hw.digest[7].q),
    .ds     (),
    .qs     (digest_7_qs)
  );
  assign reg2hw.digest[7].qe = digest_7_qe;


  // Subregister 8 of Multireg digest
  // R[digest_8]: V(True)
  logic digest_8_qe;
  logic [0:0] digest_8_flds_we;
  assign digest_8_qe = &digest_8_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_8 (
    .re     (digest_8_re),
    .we     (digest_8_we),
    .wd     (digest_8_wd),
    .d      (hw2reg.digest[8].d),
    .qre    (),
    .qe     (digest_8_flds_we[0]),
    .q      (reg2hw.digest[8].q),
    .ds     (),
    .qs     (digest_8_qs)
  );
  assign reg2hw.digest[8].qe = digest_8_qe;


  // Subregister 9 of Multireg digest
  // R[digest_9]: V(True)
  logic digest_9_qe;
  logic [0:0] digest_9_flds_we;
  assign digest_9_qe = &digest_9_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_9 (
    .re     (digest_9_re),
    .we     (digest_9_we),
    .wd     (digest_9_wd),
    .d      (hw2reg.digest[9].d),
    .qre    (),
    .qe     (digest_9_flds_we[0]),
    .q      (reg2hw.digest[9].q),
    .ds     (),
    .qs     (digest_9_qs)
  );
  assign reg2hw.digest[9].qe = digest_9_qe;


  // Subregister 10 of Multireg digest
  // R[digest_10]: V(True)
  logic digest_10_qe;
  logic [0:0] digest_10_flds_we;
  assign digest_10_qe = &digest_10_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_10 (
    .re     (digest_10_re),
    .we     (digest_10_we),
    .wd     (digest_10_wd),
    .d      (hw2reg.digest[10].d),
    .qre    (),
    .qe     (digest_10_flds_we[0]),
    .q      (reg2hw.digest[10].q),
    .ds     (),
    .qs     (digest_10_qs)
  );
  assign reg2hw.digest[10].qe = digest_10_qe;


  // Subregister 11 of Multireg digest
  // R[digest_11]: V(True)
  logic digest_11_qe;
  logic [0:0] digest_11_flds_we;
  assign digest_11_qe = &digest_11_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_11 (
    .re     (digest_11_re),
    .we     (digest_11_we),
    .wd     (digest_11_wd),
    .d      (hw2reg.digest[11].d),
    .qre    (),
    .qe     (digest_11_flds_we[0]),
    .q      (reg2hw.digest[11].q),
    .ds     (),
    .qs     (digest_11_qs)
  );
  assign reg2hw.digest[11].qe = digest_11_qe;


  // Subregister 12 of Multireg digest
  // R[digest_12]: V(True)
  logic digest_12_qe;
  logic [0:0] digest_12_flds_we;
  assign digest_12_qe = &digest_12_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_12 (
    .re     (digest_12_re),
    .we     (digest_12_we),
    .wd     (digest_12_wd),
    .d      (hw2reg.digest[12].d),
    .qre    (),
    .qe     (digest_12_flds_we[0]),
    .q      (reg2hw.digest[12].q),
    .ds     (),
    .qs     (digest_12_qs)
  );
  assign reg2hw.digest[12].qe = digest_12_qe;


  // Subregister 13 of Multireg digest
  // R[digest_13]: V(True)
  logic digest_13_qe;
  logic [0:0] digest_13_flds_we;
  assign digest_13_qe = &digest_13_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_13 (
    .re     (digest_13_re),
    .we     (digest_13_we),
    .wd     (digest_13_wd),
    .d      (hw2reg.digest[13].d),
    .qre    (),
    .qe     (digest_13_flds_we[0]),
    .q      (reg2hw.digest[13].q),
    .ds     (),
    .qs     (digest_13_qs)
  );
  assign reg2hw.digest[13].qe = digest_13_qe;


  // Subregister 14 of Multireg digest
  // R[digest_14]: V(True)
  logic digest_14_qe;
  logic [0:0] digest_14_flds_we;
  assign digest_14_qe = &digest_14_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_14 (
    .re     (digest_14_re),
    .we     (digest_14_we),
    .wd     (digest_14_wd),
    .d      (hw2reg.digest[14].d),
    .qre    (),
    .qe     (digest_14_flds_we[0]),
    .q      (reg2hw.digest[14].q),
    .ds     (),
    .qs     (digest_14_qs)
  );
  assign reg2hw.digest[14].qe = digest_14_qe;


  // Subregister 15 of Multireg digest
  // R[digest_15]: V(True)
  logic digest_15_qe;
  logic [0:0] digest_15_flds_we;
  assign digest_15_qe = &digest_15_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_15 (
    .re     (digest_15_re),
    .we     (digest_15_we),
    .wd     (digest_15_wd),
    .d      (hw2reg.digest[15].d),
    .qre    (),
    .qe     (digest_15_flds_we[0]),
    .q      (reg2hw.digest[15].q),
    .ds     (),
    .qs     (digest_15_qs)
  );
  assign reg2hw.digest[15].qe = digest_15_qe;


  // R[msg_length_lower]: V(True)
  logic msg_length_lower_qe;
  logic [0:0] msg_length_lower_flds_we;
  assign msg_length_lower_qe = &msg_length_lower_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_msg_length_lower (
    .re     (msg_length_lower_re),
    .we     (msg_length_lower_we),
    .wd     (msg_length_lower_wd),
    .d      (hw2reg.msg_length_lower.d),
    .qre    (),
    .qe     (msg_length_lower_flds_we[0]),
    .q      (reg2hw.msg_length_lower.q),
    .ds     (),
    .qs     (msg_length_lower_qs)
  );
  assign reg2hw.msg_length_lower.qe = msg_length_lower_qe;


  // R[msg_length_upper]: V(True)
  logic msg_length_upper_qe;
  logic [0:0] msg_length_upper_flds_we;
  assign msg_length_upper_qe = &msg_length_upper_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_msg_length_upper (
    .re     (msg_length_upper_re),
    .we     (msg_length_upper_we),
    .wd     (msg_length_upper_wd),
    .d      (hw2reg.msg_length_upper.d),
    .qre    (),
    .qe     (msg_length_upper_flds_we[0]),
    .q      (reg2hw.msg_length_upper.q),
    .ds     (),
    .qs     (msg_length_upper_qs)
  );
  assign reg2hw.msg_length_upper.qe = msg_length_upper_qe;



  logic [58:0] addr_hit;
  always_comb begin
    addr_hit = '0;
    addr_hit[ 0] = (reg_addr == HMAC_INTR_STATE_OFFSET);
    addr_hit[ 1] = (reg_addr == HMAC_INTR_ENABLE_OFFSET);
    addr_hit[ 2] = (reg_addr == HMAC_INTR_TEST_OFFSET);
    addr_hit[ 3] = (reg_addr == HMAC_ALERT_TEST_OFFSET);
    addr_hit[ 4] = (reg_addr == HMAC_CFG_OFFSET);
    addr_hit[ 5] = (reg_addr == HMAC_CMD_OFFSET);
    addr_hit[ 6] = (reg_addr == HMAC_STATUS_OFFSET);
    addr_hit[ 7] = (reg_addr == HMAC_ERR_CODE_OFFSET);
    addr_hit[ 8] = (reg_addr == HMAC_WIPE_SECRET_OFFSET);
    addr_hit[ 9] = (reg_addr == HMAC_KEY_0_OFFSET);
    addr_hit[10] = (reg_addr == HMAC_KEY_1_OFFSET);
    addr_hit[11] = (reg_addr == HMAC_KEY_2_OFFSET);
    addr_hit[12] = (reg_addr == HMAC_KEY_3_OFFSET);
    addr_hit[13] = (reg_addr == HMAC_KEY_4_OFFSET);
    addr_hit[14] = (reg_addr == HMAC_KEY_5_OFFSET);
    addr_hit[15] = (reg_addr == HMAC_KEY_6_OFFSET);
    addr_hit[16] = (reg_addr == HMAC_KEY_7_OFFSET);
    addr_hit[17] = (reg_addr == HMAC_KEY_8_OFFSET);
    addr_hit[18] = (reg_addr == HMAC_KEY_9_OFFSET);
    addr_hit[19] = (reg_addr == HMAC_KEY_10_OFFSET);
    addr_hit[20] = (reg_addr == HMAC_KEY_11_OFFSET);
    addr_hit[21] = (reg_addr == HMAC_KEY_12_OFFSET);
    addr_hit[22] = (reg_addr == HMAC_KEY_13_OFFSET);
    addr_hit[23] = (reg_addr == HMAC_KEY_14_OFFSET);
    addr_hit[24] = (reg_addr == HMAC_KEY_15_OFFSET);
    addr_hit[25] = (reg_addr == HMAC_KEY_16_OFFSET);
    addr_hit[26] = (reg_addr == HMAC_KEY_17_OFFSET);
    addr_hit[27] = (reg_addr == HMAC_KEY_18_OFFSET);
    addr_hit[28] = (reg_addr == HMAC_KEY_19_OFFSET);
    addr_hit[29] = (reg_addr == HMAC_KEY_20_OFFSET);
    addr_hit[30] = (reg_addr == HMAC_KEY_21_OFFSET);
    addr_hit[31] = (reg_addr == HMAC_KEY_22_OFFSET);
    addr_hit[32] = (reg_addr == HMAC_KEY_23_OFFSET);
    addr_hit[33] = (reg_addr == HMAC_KEY_24_OFFSET);
    addr_hit[34] = (reg_addr == HMAC_KEY_25_OFFSET);
    addr_hit[35] = (reg_addr == HMAC_KEY_26_OFFSET);
    addr_hit[36] = (reg_addr == HMAC_KEY_27_OFFSET);
    addr_hit[37] = (reg_addr == HMAC_KEY_28_OFFSET);
    addr_hit[38] = (reg_addr == HMAC_KEY_29_OFFSET);
    addr_hit[39] = (reg_addr == HMAC_KEY_30_OFFSET);
    addr_hit[40] = (reg_addr == HMAC_KEY_31_OFFSET);
    addr_hit[41] = (reg_addr == HMAC_DIGEST_0_OFFSET);
    addr_hit[42] = (reg_addr == HMAC_DIGEST_1_OFFSET);
    addr_hit[43] = (reg_addr == HMAC_DIGEST_2_OFFSET);
    addr_hit[44] = (reg_addr == HMAC_DIGEST_3_OFFSET);
    addr_hit[45] = (reg_addr == HMAC_DIGEST_4_OFFSET);
    addr_hit[46] = (reg_addr == HMAC_DIGEST_5_OFFSET);
    addr_hit[47] = (reg_addr == HMAC_DIGEST_6_OFFSET);
    addr_hit[48] = (reg_addr == HMAC_DIGEST_7_OFFSET);
    addr_hit[49] = (reg_addr == HMAC_DIGEST_8_OFFSET);
    addr_hit[50] = (reg_addr == HMAC_DIGEST_9_OFFSET);
    addr_hit[51] = (reg_addr == HMAC_DIGEST_10_OFFSET);
    addr_hit[52] = (reg_addr == HMAC_DIGEST_11_OFFSET);
    addr_hit[53] = (reg_addr == HMAC_DIGEST_12_OFFSET);
    addr_hit[54] = (reg_addr == HMAC_DIGEST_13_OFFSET);
    addr_hit[55] = (reg_addr == HMAC_DIGEST_14_OFFSET);
    addr_hit[56] = (reg_addr == HMAC_DIGEST_15_OFFSET);
    addr_hit[57] = (reg_addr == HMAC_MSG_LENGTH_LOWER_OFFSET);
    addr_hit[58] = (reg_addr == HMAC_MSG_LENGTH_UPPER_OFFSET);
  end

  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;

  // Check sub-word write is permitted
  always_comb begin
    wr_err = (reg_we &
              ((addr_hit[ 0] & (|(HMAC_PERMIT[ 0] & ~reg_be))) |
               (addr_hit[ 1] & (|(HMAC_PERMIT[ 1] & ~reg_be))) |
               (addr_hit[ 2] & (|(HMAC_PERMIT[ 2] & ~reg_be))) |
               (addr_hit[ 3] & (|(HMAC_PERMIT[ 3] & ~reg_be))) |
               (addr_hit[ 4] & (|(HMAC_PERMIT[ 4] & ~reg_be))) |
               (addr_hit[ 5] & (|(HMAC_PERMIT[ 5] & ~reg_be))) |
               (addr_hit[ 6] & (|(HMAC_PERMIT[ 6] & ~reg_be))) |
               (addr_hit[ 7] & (|(HMAC_PERMIT[ 7] & ~reg_be))) |
               (addr_hit[ 8] & (|(HMAC_PERMIT[ 8] & ~reg_be))) |
               (addr_hit[ 9] & (|(HMAC_PERMIT[ 9] & ~reg_be))) |
               (addr_hit[10] & (|(HMAC_PERMIT[10] & ~reg_be))) |
               (addr_hit[11] & (|(HMAC_PERMIT[11] & ~reg_be))) |
               (addr_hit[12] & (|(HMAC_PERMIT[12] & ~reg_be))) |
               (addr_hit[13] & (|(HMAC_PERMIT[13] & ~reg_be))) |
               (addr_hit[14] & (|(HMAC_PERMIT[14] & ~reg_be))) |
               (addr_hit[15] & (|(HMAC_PERMIT[15] & ~reg_be))) |
               (addr_hit[16] & (|(HMAC_PERMIT[16] & ~reg_be))) |
               (addr_hit[17] & (|(HMAC_PERMIT[17] & ~reg_be))) |
               (addr_hit[18] & (|(HMAC_PERMIT[18] & ~reg_be))) |
               (addr_hit[19] & (|(HMAC_PERMIT[19] & ~reg_be))) |
               (addr_hit[20] & (|(HMAC_PERMIT[20] & ~reg_be))) |
               (addr_hit[21] & (|(HMAC_PERMIT[21] & ~reg_be))) |
               (addr_hit[22] & (|(HMAC_PERMIT[22] & ~reg_be))) |
               (addr_hit[23] & (|(HMAC_PERMIT[23] & ~reg_be))) |
               (addr_hit[24] & (|(HMAC_PERMIT[24] & ~reg_be))) |
               (addr_hit[25] & (|(HMAC_PERMIT[25] & ~reg_be))) |
               (addr_hit[26] & (|(HMAC_PERMIT[26] & ~reg_be))) |
               (addr_hit[27] & (|(HMAC_PERMIT[27] & ~reg_be))) |
               (addr_hit[28] & (|(HMAC_PERMIT[28] & ~reg_be))) |
               (addr_hit[29] & (|(HMAC_PERMIT[29] & ~reg_be))) |
               (addr_hit[30] & (|(HMAC_PERMIT[30] & ~reg_be))) |
               (addr_hit[31] & (|(HMAC_PERMIT[31] & ~reg_be))) |
               (addr_hit[32] & (|(HMAC_PERMIT[32] & ~reg_be))) |
               (addr_hit[33] & (|(HMAC_PERMIT[33] & ~reg_be))) |
               (addr_hit[34] & (|(HMAC_PERMIT[34] & ~reg_be))) |
               (addr_hit[35] & (|(HMAC_PERMIT[35] & ~reg_be))) |
               (addr_hit[36] & (|(HMAC_PERMIT[36] & ~reg_be))) |
               (addr_hit[37] & (|(HMAC_PERMIT[37] & ~reg_be))) |
               (addr_hit[38] & (|(HMAC_PERMIT[38] & ~reg_be))) |
               (addr_hit[39] & (|(HMAC_PERMIT[39] & ~reg_be))) |
               (addr_hit[40] & (|(HMAC_PERMIT[40] & ~reg_be))) |
               (addr_hit[41] & (|(HMAC_PERMIT[41] & ~reg_be))) |
               (addr_hit[42] & (|(HMAC_PERMIT[42] & ~reg_be))) |
               (addr_hit[43] & (|(HMAC_PERMIT[43] & ~reg_be))) |
               (addr_hit[44] & (|(HMAC_PERMIT[44] & ~reg_be))) |
               (addr_hit[45] & (|(HMAC_PERMIT[45] & ~reg_be))) |
               (addr_hit[46] & (|(HMAC_PERMIT[46] & ~reg_be))) |
               (addr_hit[47] & (|(HMAC_PERMIT[47] & ~reg_be))) |
               (addr_hit[48] & (|(HMAC_PERMIT[48] & ~reg_be))) |
               (addr_hit[49] & (|(HMAC_PERMIT[49] & ~reg_be))) |
               (addr_hit[50] & (|(HMAC_PERMIT[50] & ~reg_be))) |
               (addr_hit[51] & (|(HMAC_PERMIT[51] & ~reg_be))) |
               (addr_hit[52] & (|(HMAC_PERMIT[52] & ~reg_be))) |
               (addr_hit[53] & (|(HMAC_PERMIT[53] & ~reg_be))) |
               (addr_hit[54] & (|(HMAC_PERMIT[54] & ~reg_be))) |
               (addr_hit[55] & (|(HMAC_PERMIT[55] & ~reg_be))) |
               (addr_hit[56] & (|(HMAC_PERMIT[56] & ~reg_be))) |
               (addr_hit[57] & (|(HMAC_PERMIT[57] & ~reg_be))) |
               (addr_hit[58] & (|(HMAC_PERMIT[58] & ~reg_be)))));
  end

  // Generate write-enables
  assign intr_state_we = addr_hit[0] & reg_we & !reg_error;

  assign intr_state_hmac_done_wd = reg_wdata[0];

  assign intr_state_hmac_err_wd = reg_wdata[2];
  assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;

  assign intr_enable_hmac_done_wd = reg_wdata[0];

  assign intr_enable_fifo_empty_wd = reg_wdata[1];

  assign intr_enable_hmac_err_wd = reg_wdata[2];
  assign intr_test_we = addr_hit[2] & reg_we & !reg_error;

  assign intr_test_hmac_done_wd = reg_wdata[0];

  assign intr_test_fifo_empty_wd = reg_wdata[1];

  assign intr_test_hmac_err_wd = reg_wdata[2];
  assign alert_test_we = addr_hit[3] & reg_we & !reg_error;

  assign alert_test_wd = reg_wdata[0];
  assign cfg_re = addr_hit[4] & reg_re & !reg_error;
  assign cfg_we = addr_hit[4] & reg_we & !reg_error;

  assign cfg_hmac_en_wd = reg_wdata[0];

  assign cfg_sha_en_wd = reg_wdata[1];

  assign cfg_endian_swap_wd = reg_wdata[2];

  assign cfg_digest_swap_wd = reg_wdata[3];

  assign cfg_key_swap_wd = reg_wdata[4];

  assign cfg_digest_size_wd = reg_wdata[8:5];

  assign cfg_key_length_wd = reg_wdata[14:9];
  assign cmd_we = addr_hit[5] & reg_we & !reg_error;

  assign cmd_hash_start_wd = reg_wdata[0];

  assign cmd_hash_process_wd = reg_wdata[1];

  assign cmd_hash_stop_wd = reg_wdata[2];

  assign cmd_hash_continue_wd = reg_wdata[3];
  assign status_re = addr_hit[6] & reg_re & !reg_error;
  assign wipe_secret_we = addr_hit[8] & reg_we & reg_error;

  assign wipe_secret_wd = reg_wdata[31:0];
  assign key_0_we = addr_hit[9] & reg_we & !reg_error;

  assign key_0_wd = reg_wdata[31:0];
  assign key_1_we = addr_hit[10] & reg_we & !reg_error;

  assign key_1_wd = reg_wdata[31:0];
  assign key_2_we = addr_hit[11] & reg_we & !reg_error;

  assign key_2_wd = reg_wdata[31:0];
  assign key_3_we = addr_hit[12] & reg_we & !reg_error;

  assign key_3_wd = reg_wdata[31:0];
  assign key_4_we = addr_hit[13] & reg_we & !reg_error;

  assign key_4_wd = reg_wdata[31:0];
  assign key_5_we = addr_hit[14] & reg_we & !reg_error;

  assign key_5_wd = reg_wdata[31:0];
  assign key_6_we = addr_hit[15] & reg_we & !reg_error;

  assign key_6_wd = reg_wdata[31:0];
  assign key_7_we = addr_hit[16] & reg_we & !reg_error;

  assign key_7_wd = reg_wdata[31:0];
  assign key_8_we = addr_hit[17] & reg_we & !reg_error;

  assign key_8_wd = reg_wdata[31:0];
  assign key_9_we = addr_hit[18] & reg_we & !reg_error;

  assign key_9_wd = reg_wdata[31:0];
  assign key_10_we = addr_hit[19] & reg_we & !reg_error;

  assign key_10_wd = reg_wdata[31:0];
  assign key_11_we = addr_hit[20] & reg_we & !reg_error;

  assign key_11_wd = reg_wdata[31:0];
  assign key_12_we = addr_hit[21] & reg_we & !reg_error;

  assign key_12_wd = reg_wdata[31:0];
  assign key_13_we = addr_hit[22] & reg_we & !reg_error;

  assign key_13_wd = reg_wdata[31:0];
  assign key_14_we = addr_hit[23] & reg_we & !reg_error;

  assign key_14_wd = reg_wdata[31:0];
  assign key_15_we = addr_hit[24] & reg_we & !reg_error;

  assign key_15_wd = reg_wdata[31:0];
  assign key_16_we = addr_hit[25] & reg_we & !reg_error;

  assign key_16_wd = reg_wdata[31:0];
  assign key_17_we = addr_hit[26] & reg_we & !reg_error;

  assign key_17_wd = reg_wdata[31:0];
  assign key_18_we = addr_hit[27] & reg_we & !reg_error;

  assign key_18_wd = reg_wdata[31:0];
  assign key_19_we = addr_hit[28] & reg_we & !reg_error;

  assign key_19_wd = reg_wdata[31:0];
  assign key_20_we = addr_hit[29] & reg_we & !reg_error;

  assign key_20_wd = reg_wdata[31:0];
  assign key_21_we = addr_hit[30] & reg_we & !reg_error;

  assign key_21_wd = reg_wdata[31:0];
  assign key_22_we = addr_hit[31] & reg_we & !reg_error;

  assign key_22_wd = reg_wdata[31:0];
  assign key_23_we = addr_hit[32] & reg_we & !reg_error;

  assign key_23_wd = reg_wdata[31:0];
  assign key_24_we = addr_hit[33] & reg_we & !reg_error;

  assign key_24_wd = reg_wdata[31:0];
  assign key_25_we = addr_hit[34] & reg_we & !reg_error;

  assign key_25_wd = reg_wdata[31:0];
  assign key_26_we = addr_hit[35] & reg_we & !reg_error;

  assign key_26_wd = reg_wdata[31:0];
  assign key_27_we = addr_hit[36] & reg_we & !reg_error;

  assign key_27_wd = reg_wdata[31:0];
  assign key_28_we = addr_hit[37] & reg_we & !reg_error;

  assign key_28_wd = reg_wdata[31:0];
  assign key_29_we = addr_hit[38] & reg_we & !reg_error;

  assign key_29_wd = reg_wdata[31:0];
  assign key_30_we = addr_hit[39] & reg_we & !reg_error;

  assign key_30_wd = reg_wdata[31:0];
  assign key_31_we = addr_hit[40] & reg_we & !reg_error;

  assign key_31_wd = reg_wdata[31:0];
  assign digest_0_re = addr_hit[41] & reg_re & !reg_error;
  assign digest_0_we = addr_hit[41] & reg_we & !reg_error;

  assign digest_0_wd = reg_wdata[31:0];
  assign digest_1_re = addr_hit[42] & reg_re & !reg_error;
  assign digest_1_we = addr_hit[42] & reg_we & !reg_error;

  assign digest_1_wd = reg_wdata[31:0];
  assign digest_2_re = addr_hit[43] & reg_re & !reg_error;
  assign digest_2_we = addr_hit[43] & reg_we & !reg_error;

  assign digest_2_wd = reg_wdata[31:0];
  assign digest_3_re = addr_hit[44] & reg_re & !reg_error;
  assign digest_3_we = addr_hit[44] & reg_we & !reg_error;

  assign digest_3_wd = reg_wdata[31:0];
  assign digest_4_re = addr_hit[45] & reg_re & !reg_error;
  assign digest_4_we = addr_hit[45] & reg_we & !reg_error;

  assign digest_4_wd = reg_wdata[31:0];
  assign digest_5_re = addr_hit[46] & reg_re & !reg_error;
  assign digest_5_we = addr_hit[46] & reg_we & !reg_error;

  assign digest_5_wd = reg_wdata[31:0];
  assign digest_6_re = addr_hit[47] & reg_re & !reg_error;
  assign digest_6_we = addr_hit[47] & reg_we & !reg_error;

  assign digest_6_wd = reg_wdata[31:0];
  assign digest_7_re = addr_hit[48] & reg_re & !reg_error;
  assign digest_7_we = addr_hit[48] & reg_we & !reg_error;

  assign digest_7_wd = reg_wdata[31:0];
  assign digest_8_re = addr_hit[49] & reg_re & !reg_error;
  assign digest_8_we = addr_hit[49] & reg_we & !reg_error;

  assign digest_8_wd = reg_wdata[31:0];
  assign digest_9_re = addr_hit[50] & reg_re & !reg_error;
  assign digest_9_we = addr_hit[50] & reg_we & !reg_error;

  assign digest_9_wd = reg_wdata[31:0];
  assign digest_10_re = addr_hit[51] & reg_re & !reg_error;
  assign digest_10_we = addr_hit[51] & reg_we & !reg_error;

  assign digest_10_wd = reg_wdata[31:0];
  assign digest_11_re = addr_hit[52] & reg_re & !reg_error;
  assign digest_11_we = addr_hit[52] & reg_we & !reg_error;

  assign digest_11_wd = reg_wdata[31:0];
  assign digest_12_re = addr_hit[53] & reg_re & !reg_error;
  assign digest_12_we = addr_hit[53] & reg_we & !reg_error;

  assign digest_12_wd = reg_wdata[31:0];
  assign digest_13_re = addr_hit[54] & reg_re & !reg_error;
  assign digest_13_we = addr_hit[54] & reg_we & !reg_error;

  assign digest_13_wd = reg_wdata[31:0];
  assign digest_14_re = addr_hit[55] & reg_re & !reg_error;
  assign digest_14_we = addr_hit[55] & reg_we & !reg_error;

  assign digest_14_wd = reg_wdata[31:0];
  assign digest_15_re = addr_hit[56] & reg_re & !reg_error;
  assign digest_15_we = addr_hit[56] & reg_we & !reg_error;

  assign digest_15_wd = reg_wdata[31:0];
  assign msg_length_lower_re = addr_hit[57] & reg_re & !reg_error;
  assign msg_length_lower_we = addr_hit[57] & reg_we & !reg_error;

  assign msg_length_lower_wd = reg_wdata[31:0];
  assign msg_length_upper_re = addr_hit[58] & reg_re & !reg_error;
  assign msg_length_upper_we = addr_hit[58] & reg_we & !reg_error;

  assign msg_length_upper_wd = reg_wdata[31:0];

  // Assign write-enables to checker logic vector.
  always_comb begin
    reg_we_check = '0;
    reg_we_check[0] = intr_state_we;
    reg_we_check[1] = intr_enable_we;
    reg_we_check[2] = intr_test_we;
    reg_we_check[3] = alert_test_we;
    reg_we_check[4] = cfg_we;
    reg_we_check[5] = cmd_we;
    reg_we_check[6] = 1'b0;
    reg_we_check[7] = 1'b0;
    reg_we_check[8] = wipe_secret_we;
    reg_we_check[9] = key_0_we;
    reg_we_check[10] = key_1_we;
    reg_we_check[11] = key_2_we;
    reg_we_check[12] = key_3_we;
    reg_we_check[13] = key_4_we;
    reg_we_check[14] = key_5_we;
    reg_we_check[15] = key_6_we;
    reg_we_check[16] = key_7_we;
    reg_we_check[17] = key_8_we;
    reg_we_check[18] = key_9_we;
    reg_we_check[19] = key_10_we;
    reg_we_check[20] = key_11_we;
    reg_we_check[21] = key_12_we;
    reg_we_check[22] = key_13_we;
    reg_we_check[23] = key_14_we;
    reg_we_check[24] = key_15_we;
    reg_we_check[25] = key_16_we;
    reg_we_check[26] = key_17_we;
    reg_we_check[27] = key_18_we;
    reg_we_check[28] = key_19_we;
    reg_we_check[29] = key_20_we;
    reg_we_check[30] = key_21_we;
    reg_we_check[31] = key_22_we;
    reg_we_check[32] = key_23_we;
    reg_we_check[33] = key_24_we;
    reg_we_check[34] = key_25_we;
    reg_we_check[35] = key_26_we;
    reg_we_check[36] = key_27_we;
    reg_we_check[37] = key_28_we;
    reg_we_check[38] = key_29_we;
    reg_we_check[39] = key_30_we;
    reg_we_check[40] = key_31_we;
    reg_we_check[41] = digest_0_we;
    reg_we_check[42] = digest_1_we;
    reg_we_check[43] = digest_2_we;
    reg_we_check[44] = digest_3_we;
    reg_we_check[45] = digest_4_we;
    reg_we_check[46] = digest_5_we;
    reg_we_check[47] = digest_6_we;
    reg_we_check[48] = digest_7_we;
    reg_we_check[49] = digest_8_we;
    reg_we_check[50] = digest_9_we;
    reg_we_check[51] = digest_10_we;
    reg_we_check[52] = digest_11_we;
    reg_we_check[53] = digest_12_we;
    reg_we_check[54] = digest_13_we;
    reg_we_check[55] = digest_14_we;
    reg_we_check[56] = digest_15_we;
    reg_we_check[57] = msg_length_lower_we;
    reg_we_check[58] = msg_length_upper_we;
  end

  // Read data return
  always_comb begin
    reg_rdata_next = '0;
    unique case (1'b1)
      addr_hit[0]: begin
        reg_rdata_next[0] = intr_state_hmac_done_qs;
        reg_rdata_next[1] = intr_state_fifo_empty_qs;
        reg_rdata_next[2] = intr_state_hmac_err_qs;
      end

      addr_hit[1]: begin
        reg_rdata_next[0] = intr_enable_hmac_done_qs;
        reg_rdata_next[1] = intr_enable_fifo_empty_qs;
        reg_rdata_next[2] = intr_enable_hmac_err_qs;
      end

      addr_hit[2]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
        reg_rdata_next[2] = '0;
      end

      addr_hit[3]: begin
        reg_rdata_next[0] = '0;
      end

      addr_hit[4]: begin
        reg_rdata_next[0] = cfg_hmac_en_qs;
        reg_rdata_next[1] = cfg_sha_en_qs;
        reg_rdata_next[2] = cfg_endian_swap_qs;
        reg_rdata_next[3] = cfg_digest_swap_qs;
        reg_rdata_next[4] = cfg_key_swap_qs;
        reg_rdata_next[8:5] = cfg_digest_size_qs;
        reg_rdata_next[14:9] = cfg_key_length_qs;
      end

      addr_hit[5]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
        reg_rdata_next[2] = '0;
        reg_rdata_next[3] = '0;
      end

      addr_hit[6]: begin
        reg_rdata_next[0] = status_hmac_idle_qs;
        reg_rdata_next[1] = status_fifo_empty_qs;
        reg_rdata_next[2] = status_fifo_full_qs;
        reg_rdata_next[9:4] = status_fifo_depth_qs;
      end

      addr_hit[7]: begin
        reg_rdata_next[31:0] = err_code_qs;
      end

      addr_hit[8]: begin
        reg_rdata_next[31:0] = reg2hw.key[0].q;
      end

      addr_hit[9]: begin
        reg_rdata_next[31:0] = reg2hw.key[1].q;
      end

      addr_hit[10]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[11]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[12]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[13]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[14]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[15]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[16]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[17]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[18]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[19]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[20]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[21]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[22]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[23]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[24]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[25]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[26]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[27]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[28]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[29]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[30]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[31]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[32]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[33]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[34]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[35]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[36]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[37]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[38]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[39]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[40]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[41]: begin
        reg_rdata_next[31:0] = digest_0_qs;
      end

      addr_hit[42]: begin
        reg_rdata_next[31:0] = digest_1_qs;
      end

      addr_hit[43]: begin
        reg_rdata_next[31:0] = digest_2_qs;
      end

      addr_hit[44]: begin
        reg_rdata_next[31:0] = digest_3_qs;
      end

      addr_hit[45]: begin
        reg_rdata_next[31:0] = digest_4_qs;
      end

      addr_hit[46]: begin
        reg_rdata_next[31:0] = digest_5_qs;
      end

      addr_hit[47]: begin
        reg_rdata_next[31:0] = digest_6_qs;
      end

      addr_hit[48]: begin
        reg_rdata_next[31:0] = digest_7_qs;
      end

      addr_hit[49]: begin
        reg_rdata_next[31:0] = digest_8_qs;
      end

      addr_hit[50]: begin
        reg_rdata_next[31:0] = digest_9_qs;
      end

      addr_hit[51]: begin
        reg_rdata_next[31:0] = digest_10_qs;
      end

      addr_hit[52]: begin
        reg_rdata_next[31:0] = digest_11_qs;
      end

      addr_hit[53]: begin
        reg_rdata_next[31:0] = digest_12_qs;
      end

      addr_hit[54]: begin
        reg_rdata_next[31:0] = digest_13_qs;
      end

      addr_hit[55]: begin
        reg_rdata_next[31:0] = digest_14_qs;
      end

      addr_hit[56]: begin
        reg_rdata_next[31:0] = digest_15_qs;
      end

      addr_hit[57]: begin
        reg_rdata_next[31:0] = msg_length_lower_qs;
      end

      addr_hit[58]: begin
        reg_rdata_next[31:0] = msg_length_upper_qs;
      end

      default: begin
        reg_rdata_next = reg2hw.key[2].q;
      end
    endcase
  end

  // shadow busy
  logic shadow_busy;
  assign shadow_busy = 1'b0;

  // register busy
  assign reg_busy = shadow_busy;

  // Unused signal tieoff

  // wdata / byte enable are not always fully used
  // add a blanket unused statement to handle lint waivers
  logic unused_wdata;
  logic unused_be;
  assign unused_wdata = ^reg_wdata;
  assign unused_be = ^reg_be;

  // Assertions for Register Interface
  `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
  `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)

  `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)

  `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)

  // this is formulated as an assumption such that the FPV testbenches do disprove this
  // property by mistake
  //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)

endmodule


    """


    Identify the CWE relevant to the security issue for the given RTL.
    Obtain details of the CWE.

    Then determine if there are security issues relevant to the identified CWE in the RTL.
    Refer to the code that corresponds to the issues identified.
    
================================== Ai Message ==================================

[{'text': "I'll analyze the provided RTL code to identify any security concerns related to key register confidentiality. Let me use the appropriate tool to get relevant CWE information first.", 'type': 'text'}, {'id': 'toolu_015d6EFaDromz8F6LiqfyhYt', 'input': {'security_issue': 'cryptographic key exposure in hardware registers'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_015d6EFaDromz8F6LiqfyhYt)
 Call ID: toolu_015d6EFaDromz8F6LiqfyhYt
  Args:
    security_issue: cryptographic key exposure in hardware registers
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1258: Exposure of Sensitive System Information Due to Uncleared Debug Information
The hardware does not fully clear security-sensitive values, such as keys and intermediate values in cryptographic operations, when debug mode is entered.
Security sensitive values, keys, intermediate steps of cryptographic operations, etc. are stored in temporary registers in the hardware. If these values are not cleared when debug mode is entered they may be accessed by a debugger allowing sensitive information to be accessible by untrusted parties.
Example 1
A cryptographic core in a System-On-a-Chip (SoC) is used for cryptographic acceleration and implements several cryptographic operations (e.g., computation of AES encryption and decryption, SHA-256, HMAC, etc.). The keys for these operations or the intermediate values are stored in registers internal to the cryptographic core. These internal registers are in the Memory Mapped Input Output (MMIO) space and are blocked from access by software and other untrusted agents on the SoC. These registers are accessible through the debug and test interface.
(bad code)
Example Language: Other
In the above scenario, registers that store keys and intermediate values of cryptographic operations are not cleared when system enters debug mode. An untrusted actor running a debugger may read the contents of these registers and gain access to secret keys and other sensitive cryptographic information.
(good code)
Example Language: Other
Whenever the chip enters debug mode, all registers containing security-sensitive data are be cleared rendering them unreadable.

Example 2
The following code example is extracted from the AES wrapper module, aes1_wrapper, of the Hack@DAC'21 buggy OpenPiton System-on-Chip (SoC). Within this wrapper module are four memory-mapped registers: core_key, core_key0, core_key1, and core_key2. Core_key0, core_key1, and core_key2 hold encryption/decryption keys. The core_key register selects a key and sends it to the underlying AES module to execute encryption/decryption operations. Debug mode in processors and SoCs facilitates design debugging by granting access to internal signal/register values, including physical pin values of peripherals/core, fabric bus data transactions, and inter-peripheral registers. Debug mode allows users to gather detailed, low-level information about the design to diagnose potential issues. While debug mode is beneficial for diagnosing processors or SoCs, it also introduces a new attack surface for potential attackers. For instance, if an attacker gains access to debug mode, they could potentially read any content transmitted through the fabric bus or access encryption/decryption keys stored in cryptographic peripherals. Therefore, it is crucial to clear the contents of secret registers upon entering debug mode. In the provided example of flawed code below, when debug_mode_i is activated, the register core_key0 is set to zero to prevent AES key leakage during debugging. However, this protective measure is not applied to the core_key1 register, leaving its contents uncleared during debug mode. This oversight enables a debugger to access sensitive information. Failing to clear sensitive data during debug mode may lead to unauthorized access to secret keys and compromise system security.
(bad code)
Example Language: Verilog
module aes1_wrapper #(
...
assign core_key0 = debug_mode_i ? 'b0 : {
key_reg0[7],
key_reg0[6],
key_reg0[5],
key_reg0[4],
key_reg0[3],
key_reg0[2],
key_reg0[1],
key_reg0[0]};
assign core_key1 = {
key_reg1[7],
key_reg1[6],
key_reg1[5],
key_reg1[4],
key_reg1[3],
key_reg1[2],
key_reg1[1],
key_reg1[0]};
...
endmodule
To address the issue, it is essential to ensure that the register is cleared and zeroized after activating debug mode on the SoC. In the correct implementation illustrated in the good code below, core_keyx registers are set to zero when debug mode is activated.
(good code)
Example Language: Verilog
module aes1_wrapper #(
...
assign core_key0 = debug_mode_i ? 'b0 : {
key_reg0[7],
key_reg0[6],
key_reg0[5],
key_reg0[4],
key_reg0[3],
key_reg0[2],
key_reg0[1],
key_reg0[0]};
assign core_key1 = debug_mode_i ? 'b0 : {
key_reg1[7],
key_reg1[6],
key_reg1[5],
key_reg1[4],
key_reg1[3],
key_reg1[2],
key_reg1[1],
key_reg1[0]};
...
endmodule

================================== Ai Message ==================================

Based on the CWE information and analyzing the provided RTL code, I've identified several security concerns related to key register confidentiality in the HMAC module:

## Security Concerns with Key Register Confidentiality

### 1. Lack of Debug Mode Protection (CWE-1258)

The provided RTL code implements an HMAC register top module that handles cryptographic keys, but there's no mechanism to clear sensitive key registers when in debug mode. This aligns with CWE-1258: "Exposure of Sensitive System Information Due to Uncleared Debug Information."

Specific issues in the code:

- The module contains 32 key registers (key_0 through key_31) that store cryptographic key material
- There is no logic to clear these registers when debug mode is entered
- No debug mode signal is present in the module interface to trigger key clearing

### 2. Key Register Read Access

The code shows concerning behavior regarding key register access:

```verilog
// In the read data return logic
addr_hit[9]: begin
  reg_rdata_next[31:0] = reg2hw.key[1].q;
end

// Default case
default: begin
  reg_rdata_next = reg2hw.key[2].q;
end
```

This indicates that:
- Key register 1 can be directly read when its address is hit
- More concerning, key register 2 is returned as the default value when an invalid address is accessed
- This creates a potential information leakage path where attackers could read key material

### 3. Insufficient Key Protection Mechanisms

The module lacks several key protection mechanisms:

- No hardware-enforced access control for key registers
- No key masking or obfuscation when reading key values
- No mechanism to detect unauthorized key access attempts
- The wipe_secret register (for secure key erasure) is only activated on register error conditions

### 4. Key Register Visibility

The key registers are implemented using standard register logic without special protection:

```verilog
prim_subreg_ext #(
  .DW    (32)
) u_key_0 (
  .re     (1'b0),
  .we     (key_0_we),
  .wd     (key_0_wd),
  .d      (hw2reg.key[0].d),
  .qre    (),
  .qe     (key_0_flds_we[0]),
  .q      (reg2hw.key[0].q),
  .ds     (),
  .qs     ()
);
```

This implementation doesn't provide any special protection against side-channel attacks or debug visibility.

## Recommendations

1. Implement debug mode protection that clears all key registers when debug mode is entered
2. Remove the ability to read key registers directly through the register interface
3. Implement access control mechanisms for key registers
4. Add key masking or obfuscation when key values must be accessed
5. Implement secure key storage using hardware security modules or secure elements
6. Add monitoring for unauthorized key access attempts
7. Ensure the default case in the read data logic doesn't expose sensitive information

These issues could potentially allow attackers to extract cryptographic keys from the device, especially if they have debug access, compromising the security of the entire system.
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

Based on the CWE information and analyzing the provided RTL code, I've identified several security concerns related to key register confidentiality in the HMAC module:

## Security Concerns with Key Register Confidentiality

### 1. Lack of Debug Mode Protection (CWE-1258)

The provided RTL code implements an HMAC register top module that handles cryptographic keys, but there's no mechanism to clear sensitive key registers when in debug mode. This aligns with CWE-1258: "Exposure of Sensitive System Information Due to Uncleared Debug Information."

Specific issues in the code:

- The module contains 32 key registers (key_0 through key_31) that store cryptographic key material
- There is no logic to clear these registers when debug mode is entered
- No debug mode signal is present in the module interface to trigger key clearing

### 2. Key Register Read Access

The code shows concerning behavior regarding key register access:

```verilog
// In the read data return logic
addr_hit[9]: begin
  reg_rdata_next[31:0] = reg2hw.key[1].q;
end

// Default case
default: begin
  reg_rdata_next = reg2hw.key[2].q;
end
```

This indicates that:
- Key register 1 can be directly read when its address is hit
- More concerning, key register 2 is returned as the default value when an invalid address is accessed
- This creates a potential information leakage path where attackers could read key material

### 3. Insufficient Key Protection Mechanisms

The module lacks several key protection mechanisms:

- No hardware-enforced access control for key registers
- No key masking or obfuscation when reading key values
- No mechanism to detect unauthorized key access attempts
- The wipe_secret register (for secure key erasure) is only activated on register error conditions

### 4. Key Register Visibility

The key registers are implemented using standard register logic without special protection:

```verilog
prim_subreg_ext #(
  .DW    (32)
) u_key_0 (
  .re     (1'b0),
  .we     (key_0_we),
  .wd     (key_0_wd),
  .d      (hw2reg.key[0].d),
  .qre    (),
  .qe     (key_0_flds_we[0]),
  .q      (reg2hw.key[0].q),
  .ds     (),
  .qs     ()
);
```

This implementation doesn't provide any special protection against side-channel attacks or debug visibility.

## Recommendations

1. Implement debug mode protection that clears all key registers when debug mode is entered
2. Remove the ability to read key registers directly through the register interface
3. Implement access control mechanisms for key registers
4. Add key masking or obfuscation when key values must be accessed
5. Implement secure key storage using hardware security modules or secure elements
6. Add monitoring for unauthorized key access attempts
7. Ensure the default case in the read data logic doesn't expose sensitive information

These issues could potentially allow attackers to extract cryptographic keys from the device, especially if they have debug access, compromising the security of the entire system.
================================== Ai Message ==================================

# OpenTitan HMAC IP Security Analysis Report

## 1. Security Features and Register Interface Policies

**Security Features (from documentation):**
- HMAC supports SHA-2 256/384/512 with secret key registers up to 1024 bits.
- Secret key registers are only writable when the engine is idle.
- Wipe secret mechanism: writing to `WIPE_SECRET` clears internal key and state.
- Endianness and digest output can be configured for cross-platform compatibility.
- Configuration and key registers are only updated when the engine is idle; writes during operation are ignored and flagged as errors.
- Error codes and interrupts are provided for error handling.
- Integrity checking on the TileLink interface for incoming payloads.

**Register Interface Policies:**
- Key registers (`KEY_0` to `KEY_31`) are write-only by design, but implementation details may differ.
- Digest registers are read/write only when the engine is idle.
- Configuration registers (`CFG`) are only updated when the engine is idle.
- Status and error registers are read-only.
- `WIPE_SECRET` is write-only and should be used to clear secrets after use.

---

## 2. Security Issues Identified

### Issue 1: Inconsistent Digest Computation in Multi-Stream Processing

- **File:** `hmac_core.sv`
- **Line(s):** State machine logic, especially lines 311–454 (FSM transitions)
- **Description:** When processing multiple HMAC streams in parallel, the internal state is not always properly preserved/restored, leading to incorrect digest computation. This can compromise integrity and authentication.
- **Security Aspect:** Data integrity, authentication, state isolation
- **Tools Used:** Verilator Agent, manual code review

---

### Issue 2: Register Interface Integrity Error Handling

- **File:** `hmac_reg_top.sv`
- **Line(s):** 129–139 (steering logic), assertion failures in integrity error handling
- **Description:** The assertion checker found that integrity errors do not always properly steer transactions to the register interface (`reg_steer`), potentially allowing unauthorized access or bypass of security checks.
- **Security Aspect:** Register access control, privilege enforcement
- **Tools Used:** Assertion Checker Agent

---

### Issue 3: Key Register Confidentiality Violation

- **File:** `hmac_reg_top.sv`
- **Line(s):** 2413, 2417, 2617 (read data return logic)
- **Description:** Key registers (`key_0`, `key_1`, and `key_2`) are exposed via the register read path, allowing software or an attacker to read back secret key material. The default case also exposes `key_2` if an invalid address is accessed.
- **Security Aspect:** Key confidentiality, information leakage (CWE-1258, CWE-1262)
- **Tools Used:** Similar Bug Agent, CWE Agent

---

### Issue 4: Lack of Privilege-Based Access Control

- **File:** `hmac_reg_top.sv`
- **Line(s):** Register access logic throughout, especially in always_comb for read/write enables
- **Description:** No privilege-level checking is implemented for register access. All registers are accessible to any agent on the TileLink bus, regardless of privilege or security context.
- **Security Aspect:** Privilege enforcement, access control (CWE-1262, CWE-1268)
- **Tools Used:** CWE Agent

---

### Issue 5: Lack of Debug Mode Protection for Key Registers

- **File:** `hmac_reg_top.sv`
- **Line(s):** Key register implementation and module interface
- **Description:** There is no mechanism to clear key registers when debug mode is entered, nor is there a debug mode signal to trigger such clearing. This could allow key extraction via debug access.
- **Security Aspect:** Key confidentiality, debug security (CWE-1258)
- **Tools Used:** CWE Agent

---

### Issue 6: FSM and Non-FSM Logic Mixing

- **File:** `hmac_core.sv`
- **Line(s):** 311–454 (FSM and control logic)
- **Description:** FSM logic is mixed with non-FSM logic, which can lead to confusion and potential errors in FSM behavior, indirectly affecting security if the FSM controls critical operations.
- **Security Aspect:** FSM robustness, maintainability
- **Tools Used:** Linter Agent

---

## 3. Recommendations

- **Fix context switching and state isolation in the HMAC core FSM** to ensure correct digest computation for multi-stream use.
- **Ensure all integrity errors force transactions to the register interface** and are handled securely.
- **Remove all read paths for key registers** and ensure no key material is ever exposed via software-readable registers.
- **Implement privilege-based access control** for sensitive registers, especially key and configuration registers.
- **Add debug mode detection and automatic key erasure** to prevent key leakage during debug sessions.
- **Refactor FSM logic to separate FSM and non-FSM code** for clarity and robustness.
- **Review and harden all register access logic** to ensure consistent enforcement of access policies.

---

## 4. Summary Table

| File                  | Line(s)      | Description                                      | Security Aspect                | Tools Used                   |
|-----------------------|--------------|--------------------------------------------------|-------------------------------|------------------------------|
| hmac_core.sv          | 311–454      | Multi-stream digest computation bug               | Integrity, state isolation     | Verilator, Manual Review     |
| hmac_reg_top.sv       | 129–139      | Integrity error steering failure                  | Register access control        | Assertion Checker            |
| hmac_reg_top.sv       | 2413,2417,2617| Key register readback (info leak)                | Key confidentiality           | Similar Bug, CWE Agent       |
| hmac_reg_top.sv       | all          | No privilege-based access control                 | Privilege enforcement          | CWE Agent                    |
| hmac_reg_top.sv       | all          | No debug mode key clearing                        | Key confidentiality, debug     | CWE Agent                    |
| hmac_core.sv          | 311–454      | FSM/non-FSM logic mixing                         | FSM robustness                 | Linter Agent                 |

---

**END**
================================== Ai Message ==================================

# OpenTitan HMAC IP Security Analysis Report

## 1. Security Features and Register Interface Policies

**Security Features (from documentation):**
- HMAC supports SHA-2 256/384/512 with secret key registers up to 1024 bits.
- Secret key registers are only writable when the engine is idle.
- Wipe secret mechanism: writing to `WIPE_SECRET` clears internal key and state.
- Endianness and digest output can be configured for cross-platform compatibility.
- Configuration and key registers are only updated when the engine is idle; writes during operation are ignored and flagged as errors.
- Error codes and interrupts are provided for error handling.
- Integrity checking on the TileLink interface for incoming payloads.

**Register Interface Policies:**
- Key registers (`KEY_0` to `KEY_31`) are write-only by design, but implementation details may differ.
- Digest registers are read/write only when the engine is idle.
- Configuration registers (`CFG`) are only updated when the engine is idle.
- Status and error registers are read-only.
- `WIPE_SECRET` is write-only and should be used to clear secrets after use.

---

## 2. Security Issues Identified

### Issue 1: Inconsistent Digest Computation in Multi-Stream Processing

- **File:** `hmac_core.sv`
- **Line(s):** State machine logic, especially lines 311–454 (FSM transitions)
- **Description:** When processing multiple HMAC streams in parallel, the internal state is not always properly preserved/restored, leading to incorrect digest computation. This can compromise integrity and authentication.
- **Security Aspect:** Data integrity, authentication, state isolation
- **Tools Used:** Verilator Agent, manual code review

---

### Issue 2: Register Interface Integrity Error Handling

- **File:** `hmac_reg_top.sv`
- **Line(s):** 129–139 (steering logic), assertion failures in integrity error handling
- **Description:** The assertion checker found that integrity errors do not always properly steer transactions to the register interface (`reg_steer`), potentially allowing unauthorized access or bypass of security checks.
- **Security Aspect:** Register access control, privilege enforcement
- **Tools Used:** Assertion Checker Agent

---

### Issue 3: Key Register Confidentiality Violation

- **File:** `hmac_reg_top.sv`
- **Line(s):** 2413, 2417, 2617 (read data return logic)
- **Description:** Key registers (`key_0`, `key_1`, and `key_2`) are exposed via the register read path, allowing software or an attacker to read back secret key material. The default case also exposes `key_2` if an invalid address is accessed.
- **Security Aspect:** Key confidentiality, information leakage (CWE-1258, CWE-1262)
- **Tools Used:** Similar Bug Agent, CWE Agent

---

### Issue 4: Lack of Privilege-Based Access Control

- **File:** `hmac_reg_top.sv`
- **Line(s):** Register access logic throughout, especially in always_comb for read/write enables
- **Description:** No privilege-level checking is implemented for register access. All registers are accessible to any agent on the TileLink bus, regardless of privilege or security context.
- **Security Aspect:** Privilege enforcement, access control (CWE-1262, CWE-1268)
- **Tools Used:** CWE Agent

---

### Issue 5: Lack of Debug Mode Protection for Key Registers

- **File:** `hmac_reg_top.sv`
- **Line(s):** Key register implementation and module interface
- **Description:** There is no mechanism to clear key registers when debug mode is entered, nor is there a debug mode signal to trigger such clearing. This could allow key extraction via debug access.
- **Security Aspect:** Key confidentiality, debug security (CWE-1258)
- **Tools Used:** CWE Agent

---

### Issue 6: FSM and Non-FSM Logic Mixing

- **File:** `hmac_core.sv`
- **Line(s):** 311–454 (FSM and control logic)
- **Description:** FSM logic is mixed with non-FSM logic, which can lead to confusion and potential errors in FSM behavior, indirectly affecting security if the FSM controls critical operations.
- **Security Aspect:** FSM robustness, maintainability
- **Tools Used:** Linter Agent

---

## 3. Recommendations

- **Fix context switching and state isolation in the HMAC core FSM** to ensure correct digest computation for multi-stream use.
- **Ensure all integrity errors force transactions to the register interface** and are handled securely.
- **Remove all read paths for key registers** and ensure no key material is ever exposed via software-readable registers.
- **Implement privilege-based access control** for sensitive registers, especially key and configuration registers.
- **Add debug mode detection and automatic key erasure** to prevent key leakage during debug sessions.
- **Refactor FSM logic to separate FSM and non-FSM code** for clarity and robustness.
- **Review and harden all register access logic** to ensure consistent enforcement of access policies.

---

## 4. Summary Table

| File                  | Line(s)      | Description                                      | Security Aspect                | Tools Used                   |
|-----------------------|--------------|--------------------------------------------------|-------------------------------|------------------------------|
| hmac_core.sv          | 311–454      | Multi-stream digest computation bug               | Integrity, state isolation     | Verilator, Manual Review     |
| hmac_reg_top.sv       | 129–139      | Integrity error steering failure                  | Register access control        | Assertion Checker            |
| hmac_reg_top.sv       | 2413,2417,2617| Key register readback (info leak)                | Key confidentiality           | Similar Bug, CWE Agent       |
| hmac_reg_top.sv       | all          | No privilege-based access control                 | Privilege enforcement          | CWE Agent                    |
| hmac_reg_top.sv       | all          | No debug mode key clearing                        | Key confidentiality, debug     | CWE Agent                    |
| hmac_core.sv          | 311–454      | FSM/non-FSM logic mixing                         | FSM robustness                 | Linter Agent                 |

---

**END**
================================== Ai Message ==================================

[]
