================================ System Message ================================


    You are a supervisor agent in a multi-agent system focused on identifying hardware security vulnerabilities in RTL code. 
    Your objective is to analyze the given SoC and generate a detailed security report.

    You have access to the following tools: ['run_verilator_agent', 'run_llm_cwe_checker_agent', 'run_assertions_checker_agent', 'run_linter_agent', 'run_similar_bug_agent', 'list_dir', 'read_file', 'read_file_with_line_numbers']. Each tool specializes in a specific task:

    - Verilator Agent: Runs Verilator tests on the given IP and analyzes failing test reports to detect potential security issues.
    - Assertion Agent: Takes a Verilog file, a top module name, and a security aspect to check. It generates and runs security assertions on the RTL. Failing assertions indicate potential issues that require further localization.
    - Linter Agent: Accepts a Verilog file, top module, and security focus. It selects relevant lint checks and flags design violations tied to security concerns.
    - CWE Agent: Given a Verilog file, a top module, and a security aspect, this agent maps the RTL code to relevant CWEs and detects CWE-related vulnerabilities.
    - Similar Bug Agent: Accepts a file path and a line number (where a bug was found) to locate similar patterns or recurring bugs throughout the RTL code.

    Instructions for analysis:

    - Read the documentataion to identify security features and register interfaces policies.
    - Use Verilator, Assertion, and Linter agents to uncover initial issues in the design.
    - If a bug is detected but not localized, use the CWE Agent to further inspect the related security aspect in the surrounding RTL.
    - After detecting any bugs, use the Similar Bug Agent to scan similar files (of the same or of different IPs) for similar vulnerabilities.

    Output Format:

    - For each identified issue, report:
    - File name
    - Line number(s)
    - Brief description of the issue
    - Security aspect affected
    - Tools used to identify the issue

    When your analysis is complete, end your response with "END".
    
================================ Human Message =================================

Identify security issues in the adc_ctrl IP of the OpenTitan SoC, located at /home/XXXX-2/hackdate.

    - All IPs are located in the 'hw/ip' directory.
    - RTL code for each IP is located in its 'rtl' subdirectory, with source files having the '.sv' extension.
        - reg_top files contain the register interface for the IP.
        - control/fsm files contain the control logic for the IP.
        - core files contain the core logic for the IP.
    - Documentation files (.md) are located in the 'doc' directories of each IP.
        - theory_of_operation explains the properties of the IP and its security features.
        - registers.md files contain the register interface and its read/write access policies.
    - Ignore '.core' files; they are used by build tools and are not relevant for security analysis.

    Focus on the adc_ctrl IP and make sure to analyze it thoroughly.

    First, identify the relevant security properties and read/write policies of the register interfaces from the documentation. 
    Then, use all available tools to perform a comprehensive security analysis on the RTL code.
    
================================== Ai Message ==================================

[{'text': "I'll help you identify security issues in the adc_ctrl IP of the OpenTitan SoC. Let's start by exploring the directory structure and documentation to understand the IP's security properties and register interfaces.", 'type': 'text'}, {'id': 'toolu_01XSQ49BNsJ7uBmWeBp1nb1B', 'input': {'dir_path': '/home/XXXX-2/hackdate/hw/ip/adc_ctrl'}, 'name': 'list_dir', 'type': 'tool_use'}]
Tool Calls:
  list_dir (toolu_01XSQ49BNsJ7uBmWeBp1nb1B)
 Call ID: toolu_01XSQ49BNsJ7uBmWeBp1nb1B
  Args:
    dir_path: /home/XXXX-2/hackdate/hw/ip/adc_ctrl
================================= Tool Message =================================
Name: list_dir

Files in /home/XXXX-2/hackdate/hw/ip/adc_ctrl:
adc_ctrl.core BUILD README.md

Directories in /home/XXXX-2/hackdate/hw/ip/adc_ctrl:
data doc dv rtl
================================== Ai Message ==================================

[{'text': "Let's first look at the documentation to understand the IP's security properties and register interfaces.", 'type': 'text'}, {'id': 'toolu_01S6fX3nFRWBudtCbA1a6yRJ', 'input': {'dir_path': '/home/XXXX-2/hackdate/hw/ip/adc_ctrl/doc'}, 'name': 'list_dir', 'type': 'tool_use'}]
Tool Calls:
  list_dir (toolu_01S6fX3nFRWBudtCbA1a6yRJ)
 Call ID: toolu_01S6fX3nFRWBudtCbA1a6yRJ
  Args:
    dir_path: /home/XXXX-2/hackdate/hw/ip/adc_ctrl/doc
================================= Tool Message =================================
Name: list_dir

Files in /home/XXXX-2/hackdate/hw/ip/adc_ctrl/doc:
adc_overview.svg checklist.md debug_cable_regions.svg interfaces.md programmers_guide.md registers.md theory_of_operation.md

Directories in /home/XXXX-2/hackdate/hw/ip/adc_ctrl/doc:

================================== Ai Message ==================================

[{'text': "Let's first read the theory of operation to understand the IP's functionality and security features:", 'type': 'text'}, {'id': 'toolu_01FZpBX4WzJ7wxuZEAPfukRb', 'input': {'file_path': '/home/XXXX-2/hackdate/hw/ip/adc_ctrl/doc/theory_of_operation.md'}, 'name': 'read_file', 'type': 'tool_use'}]
Tool Calls:
  read_file (toolu_01FZpBX4WzJ7wxuZEAPfukRb)
 Call ID: toolu_01FZpBX4WzJ7wxuZEAPfukRb
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/adc_ctrl/doc/theory_of_operation.md
================================= Tool Message =================================
Name: read_file

# Theory of Operation

The block diagram shows a conceptual view of the ADC controller state machine and filters.

## Block Diagram

![ADC_CTRL Block Diagram](../doc/adc_overview.svg)

### Signals

In addition to the interrupts and bus signals, the tables below lists additional IOs.

Signal                  | Direction | Description
------------------------|-----------|---------------
`adc_o`                 | `output`  | Output controls to the actual `AST ADC` module.  Contains signals such as power down control and ADC channel select.
`adc_i`                 | `input`   | Input data from `AST ADC` module. Contains ADC data output as well as data valid indication.


## Design Details

### Sampling state machine

The state machine that takes ADC samples follows a very simple pattern:

1. *Power up ADC*: The controller issues the power up command to the ADC.

2. *Wait for ADC turn on*: The controller waits for the number of clock cycles programmed in [`adc_pd_ctl.pwrup_time`](registers.md#adc_pd_ctl) which should be set to match the ADC power up delay.

3. *Take sample Channel 0*: The ADC is requested to sample channel 0.
When the ADC signals complete the value is stored in [`adc_chn_val[0].adc_chn_value`](registers.md#adc_chn_val).
Note that the time taken in this step depends on the properties of the ADC.

4. *Take sample Channel 1*: The ADC is requested to sample channel 1.
When the ADC signals complete the value is stored in [`adc_chn_val[1].adc_chn_value`](registers.md#adc_chn_val).
Note that the time taken in this step depends on the properties of the ADC.

5. *Evaluate Filters*: The filters are evaluated and debounce logic applied (see [next section](#filters-and-debounce)).

6. *Scan type check*: At this point if the [`adc_pd_ctl.lp_mode`](registers.md#adc_pd_ctl) bit is clear scanning continues at step (3).
   If the bit is set the next step depends on how many samples have hit the filters.
   If more than [`adc_lp_sample_ctl.lp_sample_cnt`](registers.md#adc_lp_sample_ctl) samples have hit then continuous scanning continues at step (3) else periodic scanning will continue at the next step (7).

7. *Power off ADC*: The controller issues the power down command to the ADC.

8. *Wait sleep time*: The controller will wait for the next sample timer to time out before restarting at step (1).

If the controller is configured as oneshot mode, ([`adc_en_ctl.oneshot_mode`](registers.md#adc_en_ctl)), the controller waits for high value (1) from channel 0 and 1 in order.
Once it gets high value from both channels, it goes back to power off state without evaluating the filters after setting [`adc_intr_status.oneshot`](registers.md#adc_intr_status).

In active operation the controller is in continuous scanning mode:
* The ADC is continually powered on.
* The sampling cycle time is the time taken for the ADC to take two samples (450us) plus internal processing time (4 clock cycles) from the ADC controller.
* The debounce timer will trigger the [`filter_status`](registers.md#filter_status) and interrupt after a configurable number of matching ADC samples have been seen, as determined by [`adc_sample_ctl`](registers.md#adc_sample_ctl).

For low power operation the periodic scanning mode can be used.
In this mode samples are taken using a slower periodic sampling cycle time with the ADC powered down most of the time.
Once a small number of cycles have hit the filter with periodic scanning then the controller switches to continuous scanning in order to more accurately debounce the signal.
In low power mode:
* The ADC is periodically powered up to take samples; this interval is determined by [`adc_pd_ctl.wakeup_time`](registers.md#adc_pd_ctl).
* Similar to normal operation, the ADC power-up delay is controlled by [`adc_pd_ctl.pwrup_time`](registers.md#adc_pd_ctl).
* Once the ADC is powered up, two samples are taken and compared to the filter thresholds.
* If a configurable number of matches, as determined by [`adc_lp_sample_ctl`](registers.md#adc_lp_sample_ctl), are seen, the ADC controller transitions to normal operation for continuous sampling.
* If a match cannot be confirmed in normal operation mode, the ADC controller switches back to low power mode without firmware intervention.

Although it can be used at any time, the periodic operation mode and use of the slow clock allows the ADC controller to continue to scan when most of the chip is in sleep or power-down modes.

The controller can be configured to issue a wakeup to the rest of the chip.
If a filter is enabled for wakeup in [`adc_wakeup_ctl`](registers.md#adc_wakeup_ctl) and [`filter_status`](registers.md#filter_status) indicates a match, a wakeup is generated to the system power manager.
For debug purposes, a transition from low power mode to normal power mode can also be configured to issue a wakeup to the rest of the chip via [`adc_wakeup_ctl`](registers.md#adc_wakeup_ctl).

## Filters and debounce

There are two reserved bits in ADC filter control registers for future use.
In the current implementation, ADC has 10-bit granularity.
Each step is 2.148mV.
It covers 0-2.2V.

The ADC controller implements eight pairs of filters that feed the debounce logic.
Each pair has a filter for channel 0 and a filter for channel 1.

A filter consists of a `max` value, a `min` value and a `cond` flag indicating if the filter is hit by a sample inside or outside the range.
* *Inside the range*: the filter is hit if `min` &le; `value` &le; `max`.
* *Outside the range*: inverse of inside, so the filter is hit if `value` &lt; `min` or `value` &gt; `max`.

Some example filters:
* Inside `min=7`, `max=23`: any value between and including 7 and 23 will hit.
* Outside `min=7`, `max=23`: any value less than 7 or greater than 23 will hit.
* Inside `min=7`, `max=7`: the value must be exactly 7 to hit (sample noise may make an exact hit unlikely).
* Inside `min=0`, `max=7`: the value must be less than 8 to hit.
* Outside `min=8`, `max=0xFFF`: the value must be less than 8 to hit (alternate method).
* Inside `min=0`, `max=0xFFF`: any value will hit. This may be useful to exclude one channel from the filter.
* Outside `min=0`, `max=0xFFF`: no value will hit. If set for either channel the filter is effectively disabled.

All pairs of filters that are enabled in [`adc_chn0_filter_ctl[7:0]`](registers.md#adc_chn0_filter_ctl) and [`adc_chn1_filter_ctl[7:0]`](registers.md#adc_chn1_filter_ctl) are evaluated after each pair of samples has been taken.
The filter result is passed to the periodic scan counter if enabled and not at its limit otherwise the result is passed to the debounce counter.
The list below describes how the counters interpret the filter results:
* If no filters are hit then the counter will reset to zero.
* If one or more filters are hit but the set hit differs from the previous evaluation the counter resets to zero.
* If one or more filters are hit and either none was hit in the previous evaluation or the same set was hit in the previous evaluation and the counter is not at its threshold then the counter will increment.
* If one or more filters are hit and the same set was hit in the previous evaluation and the counter is at its threshold then the counter stays at the threshold.
* If the counter is the periodic scan counter and it reaches its threshold, as defined by [`adc_lp_sample_ctl.lp_sample_cnt`](registers.md#adc_lp_sample_ctl), then continuous scanning is enabled and the debounce counter will be used for future evaluations.
* If the counter is the debounce counter and it reaches its threshold, as defined by [`adc_sample_ctl.np_sample_cnt`](registers.md#adc_sample_ctl), then:
  * An interrupt is raised if the threshold is met for the first time.
  * The current sample values are latched into [`adc_chn_val[0].adc_chn_value_intr`](registers.md#adc_chn_val) and  [`adc_chn_val[1].adc_chn_value_intr`](registers.md#adc_chn_val).
    *  If a series of interrupts and matches are seen, these registers only record the value of the first debounced hit.
  * The [`adc_intr_status`](registers.md#adc_intr_status) register is updated by setting the bits corresponding to filters that are hit (note that bits that are already set will not be cleared).
    This will cause the block to raise an interrupt if it was not already doing so.
  * If a filter is a hit and is also enabled in [`adc_wakeup_ctl`](registers.md#adc_wakeup_ctl) the corresponding filter generates a wakeup.
  * Note that the debounce counter will remain at its threshold until the set of filters are changed by software to debounce a different event or if the current match changes.
    *  This implies that a stable matching event continuously matches until some condition in the system (changed filter settings, changed ADC output, software issued fsm reset in [`adc_fsm_rst`](registers.md#adc_fsm_rst)) alters the result.


Because scanning continues the [`adc_intr_status`](registers.md#adc_intr_status) register will reflect any debounced events that are detected between the controller raising an interrupt and the status bits being cleared (by having 1 written to them).
However, the [`adc_chn_val[0].adc_chn_value_intr`](registers.md#adc_chn_val) and [`adc_chn_val[1].adc_chn_value_intr`](registers.md#adc_chn_val) registers record the value at the time the interrupt was first raised and thus reflect the filter state from that point.

### ADC_CTRL and ADC Interface

The interface between the ADC controller and the ADC is diagrammed below.
The interface is from the perspective of the ADC controller.
Before operation can begin, the ADC controller first powers on the ADC by setting `adc_o.pd` to 0.
The controller then waits for the ADC to fully power up, as determined by [`adc_pd_ctl.pwrup_time`](registers.md#adc_pd_ctl).

Once the ADC is ready to go, the controller then selects the channel it wishes to sample by setting `adc_o.channel_sel`.
The controller holds this value until the ADC responds with `adc_i.data_valid` and `adc_i.data`.

Since there is no request sample signal between the controller and the ADC, the ADC takes a new sample when `adc_o.channel_sel` is changed from 0 to a valid channel.
To take a new sample then, the controller actively sets `adc_o.channel_sel` to 0, before setting it to another valid channel.

```wavejson
{
  signal: [
    {node: '.a..b........', phase:0.2},
    {name: 'clk_aon_i',         wave: 'p.|..|.....|....|...'},
    {name: 'adc_o.pd',          wave: '10|..|.....|....|..1'},
    {name: 'adc_o.channel_sel', wave: '0.|.3|..04.|....|0..'},
    {name: 'adc_i.data_valid',  wave: '0.|..|.1.0.|.1..|.0.'},
    {name: 'adc_i.data',        wave: 'x.|..|.3.x.|.4..|.x.', data: ['ch0', 'ch1', 'ch1']},
  ],
  edge: [  'a<->b wakeup time',   ]
}
```

================================== Ai Message ==================================

[{'text': "Now let's look at the registers documentation to understand the register interfaces and their access policies:", 'type': 'text'}, {'id': 'toolu_01FrKSXmHQVv6VEKZCfFgxAi', 'input': {'file_path': '/home/XXXX-2/hackdate/hw/ip/adc_ctrl/doc/registers.md'}, 'name': 'read_file', 'type': 'tool_use'}]
Tool Calls:
  read_file (toolu_01FrKSXmHQVv6VEKZCfFgxAi)
 Call ID: toolu_01FrKSXmHQVv6VEKZCfFgxAi
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/adc_ctrl/doc/registers.md
================================= Tool Message =================================
Name: read_file

# Registers

<!-- BEGIN CMDGEN util/regtool.py -d ./hw/ip/adc_ctrl/data/adc_ctrl.hjson -->
## Summary

| Name                                                     | Offset   |   Length | Description                               |
|:---------------------------------------------------------|:---------|---------:|:------------------------------------------|
| adc_ctrl.[`INTR_STATE`](#intr_state)                     | 0x0      |        4 | Interrupt State Register                  |
| adc_ctrl.[`INTR_ENABLE`](#intr_enable)                   | 0x4      |        4 | Interrupt Enable Register                 |
| adc_ctrl.[`INTR_TEST`](#intr_test)                       | 0x8      |        4 | Interrupt Test Register                   |
| adc_ctrl.[`ALERT_TEST`](#alert_test)                     | 0xc      |        4 | Alert Test Register                       |
| adc_ctrl.[`adc_en_ctl`](#adc_en_ctl)                     | 0x10     |        4 | ADC enable control register               |
| adc_ctrl.[`adc_pd_ctl`](#adc_pd_ctl)                     | 0x14     |        4 | ADC PowerDown(PD) control register        |
| adc_ctrl.[`adc_lp_sample_ctl`](#adc_lp_sample_ctl)       | 0x18     |        4 | ADC Low-Power(LP) sample control register |
| adc_ctrl.[`adc_sample_ctl`](#adc_sample_ctl)             | 0x1c     |        4 | ADC sample control register               |
| adc_ctrl.[`adc_fsm_rst`](#adc_fsm_rst)                   | 0x20     |        4 | ADC FSM reset control                     |
| adc_ctrl.[`adc_chn0_filter_ctl_0`](#adc_chn0_filter_ctl) | 0x24     |        4 | ADC channel0 filter range                 |
| adc_ctrl.[`adc_chn0_filter_ctl_1`](#adc_chn0_filter_ctl) | 0x28     |        4 | ADC channel0 filter range                 |
| adc_ctrl.[`adc_chn0_filter_ctl_2`](#adc_chn0_filter_ctl) | 0x2c     |        4 | ADC channel0 filter range                 |
| adc_ctrl.[`adc_chn0_filter_ctl_3`](#adc_chn0_filter_ctl) | 0x30     |        4 | ADC channel0 filter range                 |
| adc_ctrl.[`adc_chn0_filter_ctl_4`](#adc_chn0_filter_ctl) | 0x34     |        4 | ADC channel0 filter range                 |
| adc_ctrl.[`adc_chn0_filter_ctl_5`](#adc_chn0_filter_ctl) | 0x38     |        4 | ADC channel0 filter range                 |
| adc_ctrl.[`adc_chn0_filter_ctl_6`](#adc_chn0_filter_ctl) | 0x3c     |        4 | ADC channel0 filter range                 |
| adc_ctrl.[`adc_chn0_filter_ctl_7`](#adc_chn0_filter_ctl) | 0x40     |        4 | ADC channel0 filter range                 |
| adc_ctrl.[`adc_chn1_filter_ctl_0`](#adc_chn1_filter_ctl) | 0x44     |        4 | ADC channel1 filter range                 |
| adc_ctrl.[`adc_chn1_filter_ctl_1`](#adc_chn1_filter_ctl) | 0x48     |        4 | ADC channel1 filter range                 |
| adc_ctrl.[`adc_chn1_filter_ctl_2`](#adc_chn1_filter_ctl) | 0x4c     |        4 | ADC channel1 filter range                 |
| adc_ctrl.[`adc_chn1_filter_ctl_3`](#adc_chn1_filter_ctl) | 0x50     |        4 | ADC channel1 filter range                 |
| adc_ctrl.[`adc_chn1_filter_ctl_4`](#adc_chn1_filter_ctl) | 0x54     |        4 | ADC channel1 filter range                 |
| adc_ctrl.[`adc_chn1_filter_ctl_5`](#adc_chn1_filter_ctl) | 0x58     |        4 | ADC channel1 filter range                 |
| adc_ctrl.[`adc_chn1_filter_ctl_6`](#adc_chn1_filter_ctl) | 0x5c     |        4 | ADC channel1 filter range                 |
| adc_ctrl.[`adc_chn1_filter_ctl_7`](#adc_chn1_filter_ctl) | 0x60     |        4 | ADC channel1 filter range                 |
| adc_ctrl.[`adc_chn_val_0`](#adc_chn_val)                 | 0x64     |        4 | ADC value sampled on channel              |
| adc_ctrl.[`adc_chn_val_1`](#adc_chn_val)                 | 0x68     |        4 | ADC value sampled on channel              |
| adc_ctrl.[`adc_wakeup_ctl`](#adc_wakeup_ctl)             | 0x6c     |        4 | Enable filter matches as wakeups          |
| adc_ctrl.[`filter_status`](#filter_status)               | 0x70     |        4 | Adc filter match status                   |
| adc_ctrl.[`adc_intr_ctl`](#adc_intr_ctl)                 | 0x74     |        4 | Interrupt enable controls.                |
| adc_ctrl.[`adc_intr_status`](#adc_intr_status)           | 0x78     |        4 | Debug cable internal status               |
| adc_ctrl.[`adc_fsm_state`](#adc_fsm_state)               | 0x7c     |        4 | State of the internal state machine       |

## INTR_STATE
Interrupt State Register
- Offset: `0x0`
- Reset default: `0x0`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "match_pending", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 150}}
```

|  Bits  |  Type  |  Reset  | Name          | Description                                 |
|:------:|:------:|:-------:|:--------------|:--------------------------------------------|
|  31:1  |        |         |               | Reserved                                    |
|   0    |   ro   |   0x0   | match_pending | ADC match or measurement event has occurred |

## INTR_ENABLE
Interrupt Enable Register
- Offset: `0x4`
- Reset default: `0x0`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "match_pending", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 150}}
```

|  Bits  |  Type  |  Reset  | Name          | Description                                                             |
|:------:|:------:|:-------:|:--------------|:------------------------------------------------------------------------|
|  31:1  |        |         |               | Reserved                                                                |
|   0    |   rw   |   0x0   | match_pending | Enable interrupt when [`INTR_STATE.match_pending`](#intr_state) is set. |

## INTR_TEST
Interrupt Test Register
- Offset: `0x8`
- Reset default: `0x0`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "match_pending", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 150}}
```

|  Bits  |  Type  |  Reset  | Name          | Description                                                      |
|:------:|:------:|:-------:|:--------------|:-----------------------------------------------------------------|
|  31:1  |        |         |               | Reserved                                                         |
|   0    |   wo   |   0x0   | match_pending | Write 1 to force [`INTR_STATE.match_pending`](#intr_state) to 1. |

## ALERT_TEST
Alert Test Register
- Offset: `0xc`
- Reset default: `0x0`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "fatal_fault", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 130}}
```

|  Bits  |  Type  |  Reset  | Name        | Description                                      |
|:------:|:------:|:-------:|:------------|:-------------------------------------------------|
|  31:1  |        |         |             | Reserved                                         |
|   0    |   wo   |   0x0   | fatal_fault | Write 1 to trigger one alert event of this kind. |

## adc_en_ctl
ADC enable control register
- Offset: `0x10`
- Reset default: `0x0`
- Reset mask: `0x3`

### Fields

```wavejson
{"reg": [{"name": "adc_enable", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "oneshot_mode", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 30}], "config": {"lanes": 1, "fontsize": 10, "vspace": 140}}
```

|  Bits  |  Type  |  Reset  | Name         | Description                                                                                                            |
|:------:|:------:|:-------:|:-------------|:-----------------------------------------------------------------------------------------------------------------------|
|  31:2  |        |         |              | Reserved                                                                                                               |
|   1    |   rw   |   0x0   | oneshot_mode | Oneshot mode does not care about the filter value. 1'b0: disable; 1'b1: enable                                         |
|   0    |   rw   |   0x0   | adc_enable   | 1'b0: to power down ADC and ADC_CTRL FSM will enter the reset state; 1'b1: to power up ADC and ADC_CTRL FSM will start |

## adc_pd_ctl
ADC PowerDown(PD) control register
- Offset: `0x14`
- Reset default: `0x64070`
- Reset mask: `0xfffffff1`

### Fields

```wavejson
{"reg": [{"name": "lp_mode", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 3}, {"name": "pwrup_time", "bits": 4, "attr": ["rw"], "rotate": -90}, {"name": "wakeup_time", "bits": 24, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 120}}
```

|  Bits  |  Type  |  Reset  | Name        | Description                                                                                                                                                                        |
|:------:|:------:|:-------:|:------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  31:8  |   rw   |  0x640  | wakeup_time | How often FSM wakes up from ADC PD mode to take a sample, measured in always on clock cycles.                                                                                      |
|  7:4   |   rw   |   0x7   | pwrup_time  | ADC power up time, measured in always on clock cycles. After power up time is reached, the ADC controller needs one additional cycle before an ADC channel is selected for access. |
|  3:1   |        |         |             | Reserved                                                                                                                                                                           |
|   0    |   rw   |   0x0   | lp_mode     | 1'b0: adc_pd is disabled, use adc_sample_ctl. 1'b1: adc_pd is enabled, use both adc_lp_sample_ctl & adc_sample_ctl                                                                 |

## adc_lp_sample_ctl
ADC Low-Power(LP) sample control register
- Offset: `0x18`
- Reset default: `0x4`
- Reset mask: `0xff`

### Fields

```wavejson
{"reg": [{"name": "lp_sample_cnt", "bits": 8, "attr": ["rw"], "rotate": 0}, {"bits": 24}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name          | Description                                                                                                                                                                         |
|:------:|:------:|:-------:|:--------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  31:8  |        |         |               | Reserved                                                                                                                                                                            |
|  7:0   |   rw   |   0x4   | lp_sample_cnt | The number of samples in low-power mode when the low-power mode is enabled. After the programmed number is met, ADC won't be powered down any more. This value must be 1 or larger. |

## adc_sample_ctl
ADC sample control register
- Offset: `0x1c`
- Reset default: `0x9b`
- Reset mask: `0xffff`

### Fields

```wavejson
{"reg": [{"name": "np_sample_cnt", "bits": 16, "attr": ["rw"], "rotate": 0}, {"bits": 16}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name          | Description                                                                                                                                                                       |
|:------:|:------:|:-------:|:--------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31:16  |        |         |               | Reserved                                                                                                                                                                          |
|  15:0  |   rw   |  0x9b   | np_sample_cnt | The number of samples in normal-power mode to meet the debounce spec. Used after the low-power mode condition is met or in the normal power mode. This value must be 1 or larger. |

## adc_fsm_rst
ADC FSM reset control
- Offset: `0x20`
- Reset default: `0x0`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "rst_en", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                                                             |
|:------:|:------:|:-------:|:-------|:------------------------------------------------------------------------|
|  31:1  |        |         |        | Reserved                                                                |
|   0    |   rw   |   0x0   | rst_en | 1'b0: Normal functional mode. 1'b1: SW to reset all the FSMs and timers |

## adc_chn0_filter_ctl
ADC channel0 filter range

Up to 8 filters can be configured per channel and each filter has an associated [min, max] range.
The condition bit then defines whether the sample values of that channel need to lie within the range or outside to create a match.
The filter range bounds can be configured with a granularity of 2.148mV.
- Reset default: `0x0`
- Reset mask: `0x8ffc1ffc`

### Instances

| Name                  | Offset   |
|:----------------------|:---------|
| adc_chn0_filter_ctl_0 | 0x24     |
| adc_chn0_filter_ctl_1 | 0x28     |
| adc_chn0_filter_ctl_2 | 0x2c     |
| adc_chn0_filter_ctl_3 | 0x30     |
| adc_chn0_filter_ctl_4 | 0x34     |
| adc_chn0_filter_ctl_5 | 0x38     |
| adc_chn0_filter_ctl_6 | 0x3c     |
| adc_chn0_filter_ctl_7 | 0x40     |


### Fields

```wavejson
{"reg": [{"bits": 2}, {"name": "min_v", "bits": 10, "attr": ["rw"], "rotate": 0}, {"name": "cond", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 5}, {"name": "max_v", "bits": 10, "attr": ["rw"], "rotate": 0}, {"bits": 3}, {"name": "EN", "bits": 1, "attr": ["rw"], "rotate": -90}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                                                                      |
|:------:|:------:|:-------:|:-------|:---------------------------------------------------------------------------------|
|   31   |   rw   |   0x0   | EN     | Enable for filter                                                                |
| 30:28  |        |         |        | Reserved                                                                         |
| 27:18  |   rw   |   0x0   | max_v  | 10-bit for chn0 filter max value                                                 |
| 17:13  |        |         |        | Reserved                                                                         |
|   12   |   rw   |   0x0   | cond   | 1-bit for the condition; 1'b0 means min<=ADC<=max, 1'b1 means ADC>max or ADC<min |
|  11:2  |   rw   |   0x0   | min_v  | 10-bit for chn0 filter min value                                                 |
|  1:0   |        |         |        | Reserved                                                                         |

## adc_chn1_filter_ctl
ADC channel1 filter range

Up to 8 filters can be configured per channel and each filter has an associated [min, max] range.
The condition bit then defines whether the sample values of that channel need to lie within the range or outside to create a match.
The filter range bounds can be configured with a granularity of 2.148mV.
- Reset default: `0x0`
- Reset mask: `0x8ffc1ffc`

### Instances

| Name                  | Offset   |
|:----------------------|:---------|
| adc_chn1_filter_ctl_0 | 0x44     |
| adc_chn1_filter_ctl_1 | 0x48     |
| adc_chn1_filter_ctl_2 | 0x4c     |
| adc_chn1_filter_ctl_3 | 0x50     |
| adc_chn1_filter_ctl_4 | 0x54     |
| adc_chn1_filter_ctl_5 | 0x58     |
| adc_chn1_filter_ctl_6 | 0x5c     |
| adc_chn1_filter_ctl_7 | 0x60     |


### Fields

```wavejson
{"reg": [{"bits": 2}, {"name": "min_v", "bits": 10, "attr": ["rw"], "rotate": 0}, {"name": "cond", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 5}, {"name": "max_v", "bits": 10, "attr": ["rw"], "rotate": 0}, {"bits": 3}, {"name": "EN", "bits": 1, "attr": ["rw"], "rotate": -90}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                                                                      |
|:------:|:------:|:-------:|:-------|:---------------------------------------------------------------------------------|
|   31   |   rw   |   0x0   | EN     | Enable for filter                                                                |
| 30:28  |        |         |        | Reserved                                                                         |
| 27:18  |   rw   |   0x0   | max_v  | 10-bit for chn0 filter max value                                                 |
| 17:13  |        |         |        | Reserved                                                                         |
|   12   |   rw   |   0x0   | cond   | 1-bit for the condition; 1'b0 means min<=ADC<=max, 1'b1 means ADC>max or ADC<min |
|  11:2  |   rw   |   0x0   | min_v  | 10-bit for chn0 filter min value                                                 |
|  1:0   |        |         |        | Reserved                                                                         |

## adc_chn_val
ADC value sampled on channel
- Reset default: `0x0`
- Reset mask: `0xfff0fff`

### Instances

| Name          | Offset   |
|:--------------|:---------|
| adc_chn_val_0 | 0x64     |
| adc_chn_val_1 | 0x68     |


### Fields

```wavejson
{"reg": [{"name": "adc_chn_value_ext", "bits": 2, "attr": ["ro"], "rotate": -90}, {"name": "adc_chn_value", "bits": 10, "attr": ["ro"], "rotate": 0}, {"bits": 4}, {"name": "adc_chn_value_intr_ext", "bits": 2, "attr": ["ro"], "rotate": -90}, {"name": "adc_chn_value_intr", "bits": 10, "attr": ["ro"], "rotate": 0}, {"bits": 4}], "config": {"lanes": 1, "fontsize": 10, "vspace": 240}}
```

|  Bits  |  Type  |  Reset  | Name                   | Description                                                                                                              |
|:------:|:------:|:-------:|:-----------------------|:-------------------------------------------------------------------------------------------------------------------------|
| 31:28  |        |         |                        | Reserved                                                                                                                 |
| 27:18  |   ro   |   0x0   | adc_chn_value_intr     | ADC value sampled on channel when the interrupt is raised(debug cable is attached or disconnected), each step is 2.148mV |
| 17:16  |   ro   |   0x0   | adc_chn_value_intr_ext | 2-bit extension; RO 0                                                                                                    |
| 15:12  |        |         |                        | Reserved                                                                                                                 |
|  11:2  |   ro   |   0x0   | adc_chn_value          | Latest ADC value sampled on channel. each step is 2.148mV                                                                |
|  1:0   |   ro   |   0x0   | adc_chn_value_ext      | 2-bit extension; RO 0                                                                                                    |

## adc_wakeup_ctl
Enable filter matches as wakeups
- Offset: `0x6c`
- Reset default: `0x0`
- Reset mask: `0x1ff`

### Fields

```wavejson
{"reg": [{"name": "MATCH_EN", "bits": 8, "attr": ["rw"], "rotate": 0}, {"name": "TRANS_EN", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 23}], "config": {"lanes": 1, "fontsize": 10, "vspace": 100}}
```

|  Bits  |  Type  |  Reset  | Name                                  |
|:------:|:------:|:-------:|:--------------------------------------|
|  31:9  |        |         | Reserved                              |
|   8    |   rw   |   0x0   | [TRANS_EN](#adc_wakeup_ctl--trans_en) |
|  7:0   |   rw   |   0x0   | [MATCH_EN](#adc_wakeup_ctl--match_en) |

### adc_wakeup_ctl . TRANS_EN
Wakeup due to FSM transition from low power sampling
mode to normal sampling mode.

Note that this wakeup source is primarily intended for debug purposes.
If enabled all the time, this can lead to many wakeups due to false
positives that are ruled out automatically by adc_ctrl after
transitioning from LP -> NP.

0: transition match will not generate wakeup;
1: transition match will generate wakeup

### adc_wakeup_ctl . MATCH_EN
Filter wakeup source.

0: filter match will not generate wakeup;
1: filter match will generate wakeup

## filter_status
Adc filter match status

Indicates whether a particular filter has matched on all channels.
- Offset: `0x70`
- Reset default: `0x0`
- Reset mask: `0x1ff`

### Fields

```wavejson
{"reg": [{"name": "MATCH", "bits": 8, "attr": ["rw1c"], "rotate": 0}, {"name": "TRANS", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"bits": 23}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                                                |
|:------:|:------:|:-------:|:-------|:-----------------------------------------------------------|
|  31:9  |        |         |        | Reserved                                                   |
|   8    |  rw1c  |   0x0   | TRANS  | 0: transition did not occur; 1: transition occurred        |
|  7:0   |  rw1c  |   0x0   | MATCH  | 0: filter condition is not met; 1: filter condition is met |

## adc_intr_ctl
Interrupt enable controls.

adc_ctrl sends out only 1 interrupt, so this register controls
which internal sources are actually registered.

This register uses the same bit enumeration as [`ADC_INTR_STATUS`](#adc_intr_status)
- Offset: `0x74`
- Reset default: `0x0`
- Reset mask: `0x3ff`

### Fields

```wavejson
{"reg": [{"name": "MATCH_EN", "bits": 8, "attr": ["rw"], "rotate": 0}, {"name": "TRANS_EN", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "ONESHOT_EN", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 22}], "config": {"lanes": 1, "fontsize": 10, "vspace": 120}}
```

|  Bits  |  Type  |  Reset  | Name                                    |
|:------:|:------:|:-------:|:----------------------------------------|
| 31:10  |        |         | Reserved                                |
|   9    |   rw   |   0x0   | [ONESHOT_EN](#adc_intr_ctl--oneshot_en) |
|   8    |   rw   |   0x0   | [TRANS_EN](#adc_intr_ctl--trans_en)     |
|  7:0   |   rw   |   0x0   | [MATCH_EN](#adc_intr_ctl--match_en)     |

### adc_intr_ctl . ONESHOT_EN
Interrupt due to oneshot sampling.

0: interrupt source is not enabled; 1: interrupt source is enabled

### adc_intr_ctl . TRANS_EN
Interrupt due to FSM transition from low power sampling
mode to normal sampling mode. This is mainly intended for debug.

Note that this interrupt is primarily intended for debug purposes.

0: interrupt source is not enabled; 1: interrupt source is enabled

### adc_intr_ctl . MATCH_EN
Filter interrupt source.

0: interrupt source is not enabled; 1: interrupt source is enabled

## adc_intr_status
Debug cable internal status
- Offset: `0x78`
- Reset default: `0x0`
- Reset mask: `0x3ff`

### Fields

```wavejson
{"reg": [{"name": "MATCH", "bits": 8, "attr": ["rw1c"], "rotate": 0}, {"name": "TRANS", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"name": "ONESHOT", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"bits": 22}], "config": {"lanes": 1, "fontsize": 10, "vspace": 90}}
```

|  Bits  |  Type  |  Reset  | Name    | Description                                                |
|:------:|:------:|:-------:|:--------|:-----------------------------------------------------------|
| 31:10  |        |         |         | Reserved                                                   |
|   9    |  rw1c  |   0x0   | ONESHOT | 0: oneshot sample is not done ; 1: oneshot sample is done  |
|   8    |  rw1c  |   0x0   | TRANS   | 0: transition did not occur; 1: transition occurred        |
|  7:0   |  rw1c  |   0x0   | MATCH   | 0: filter condition is not met; 1: filter condition is met |

## adc_fsm_state
State of the internal state machine
- Offset: `0x7c`
- Reset default: `0x0`
- Reset mask: `0x1f`

### Fields

```wavejson
{"reg": [{"name": "state", "bits": 5, "attr": ["ro"], "rotate": 0}, {"bits": 27}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                           |
|:------:|:------:|:-------:|:-------------------------------|
|  31:5  |        |         | Reserved                       |
|  4:0   |   ro   |   0x0   | [state](#adc_fsm_state--state) |

### adc_fsm_state . state
Current FSM state (for debug purposes)

| Value   | Name       | Description                                        |
|:--------|:-----------|:---------------------------------------------------|
| 0x00    | PWRDN      | in the power down state                            |
| 0x01    | PWRUP      | being powered up                                   |
| 0x02    | ONEST_0    | in oneshot mode; sample channel0 value             |
| 0x03    | ONEST_021  | in oneshot mode; transition from chn0 to chn1      |
| 0x04    | ONEST_1    | in oneshot mode; sample channel1 value             |
| 0x05    | ONEST_DONE | one shot done                                      |
| 0x06    | LP_0       | in low-power mode, sample channel0 value           |
| 0x07    | LP_021     | in low-power mode, transition from chn0 to chn1    |
| 0x08    | LP_1       | in low-power mode, sample channel1 value           |
| 0x09    | LP_EVAL    | in low-power mode, evaluate if there is a match    |
| 0x0a    | LP_SLP     | in low-power mode, go to sleep                     |
| 0x0b    | LP_PWRUP   | in low-power mode, being powered up                |
| 0x0c    | NP_0       | in normal-power mode, sample channel0 value        |
| 0x0d    | NP_021     | in normal-power mode, transition from chn0 to chn1 |
| 0x0e    | NP_1       | in normal-power mode, sample channel1 value        |
| 0x0f    | NP_EVAL    | in normal-power mode, detection is done            |
| 0x10    | NP_DONE    | normal-power detection done                        |

Other values are reserved.


<!-- END CMDGEN -->

================================== Ai Message ==================================

[{'text': "Now, let's examine the RTL code to understand the implementation. First, let's look at the directory structure of the RTL:", 'type': 'text'}, {'id': 'toolu_01XUsBMnW7vuiuqdCVUXHjhF', 'input': {'dir_path': '/home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl'}, 'name': 'list_dir', 'type': 'tool_use'}]
Tool Calls:
  list_dir (toolu_01XUsBMnW7vuiuqdCVUXHjhF)
 Call ID: toolu_01XUsBMnW7vuiuqdCVUXHjhF
  Args:
    dir_path: /home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl
================================= Tool Message =================================
Name: list_dir

Files in /home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl:
adc_ctrl.sv adc_ctrl_core.sv adc_ctrl_fsm.sv adc_ctrl_intr.sv adc_ctrl_pkg.sv adc_ctrl_reg_pkg.sv adc_ctrl_reg_top.sv adc_ctrl_core_assertion-inserted.sv adc_ctrl_fsm_assertion-inserted.sv adc_ctrl_reg_top_assertion-inserted.sv

Directories in /home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl:

================================== Ai Message ==================================

[{'text': "Let's first look at the top module to understand the overall structure:", 'type': 'text'}, {'id': 'toolu_01GpQALKmuqZ8ocJcHW7GYr5', 'input': {'file_path': '/home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl.sv'}, 'name': 'read_file_with_line_numbers', 'type': 'tool_use'}]
Tool Calls:
  read_file_with_line_numbers (toolu_01GpQALKmuqZ8ocJcHW7GYr5)
 Call ID: toolu_01GpQALKmuqZ8ocJcHW7GYr5
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // adc_ctrl module
6: 
7: `include "prim_assert.sv"
8: 
9: module adc_ctrl
10:   import adc_ctrl_reg_pkg::*;
11: #(
12:   parameter logic [NumAlerts-1:0] AlertAsyncOn = {NumAlerts{1'b1}}
13: ) (
14:   input clk_i,      // regular core clock for SW config interface
15:   input clk_aon_i,  // always-on slow clock for internal logic
16:   input rst_ni,     // power-on hardware reset
17:   input rst_aon_ni, // power-on reset for the 200KHz clock(logic)
18: 
19:   // Regster interface
20:   input  tlul_pkg::tl_h2d_t tl_i,
21:   output tlul_pkg::tl_d2h_t tl_o,
22: 
23:   // Alerts
24:   input  prim_alert_pkg::alert_rx_t [NumAlerts-1:0] alert_rx_i,
25:   output prim_alert_pkg::alert_tx_t [NumAlerts-1:0] alert_tx_o,
26: 
27:   // Inter-module IO, AST interface
28:   // .pd: Power down ADC (used in deep sleep mode to save power)
29:   // .channel_sel: channel select for ADC;
30:   // 2'b0 means stop, 2'b01 means first channel, 2'b10 means second channel, 2'b11 illegal
31:   output ast_pkg::adc_ast_req_t adc_o,
32:   // .data: ADC voltage level, each step is 2.148mV(2200mV/1024). It covers 0-2.2V
33:   // .data_valid: Valid bit(pulse) for adc_d
34:   input  ast_pkg::adc_ast_rsp_t adc_i,
35: 
36:   // Interrupt indicates a matching or measurement is done
37:   output logic intr_match_pending_o,
38: 
39:   // Pwrmgr interface
40:   // Debug cable is detected; wake up the chip in normal sleep and deep sleep mode
41:   output logic wkup_req_o
42: );
43: 
44:   adc_ctrl_reg2hw_t reg2hw;
45:   adc_ctrl_hw2reg_t hw2reg;
46: 
47:   // Alerts
48:   logic [NumAlerts-1:0] alert_test, alerts;
49:   assign alert_test = {reg2hw.alert_test.q & reg2hw.alert_test.qe};
50: 
51:   for (genvar i = 0; i < NumAlerts; i++) begin : gen_alert_tx
52:     prim_alert_sender #(
53:       .AsyncOn(AlertAsyncOn[i]),
54:       .IsFatal(1'b1)
55:     ) u_prim_alert_sender (
56:       .clk_i,
57:       .rst_ni,
58:       .alert_test_i (alert_test[i]),
59:       .alert_req_i  (alerts[0]),
60:       .alert_ack_o  (),
61:       .alert_state_o(),
62:       .alert_rx_i   (alert_rx_i[i]),
63:       .alert_tx_o   (alert_tx_o[i])
64:     );
65:   end
66: 
67:   // Register module
68:   adc_ctrl_reg_top u_reg (
69:     .clk_i,
70:     .rst_ni,
71:     .clk_aon_i,
72:     .rst_aon_ni,
73:     .tl_i(tl_i),
74:     .tl_o(tl_o),
75:     .reg2hw(reg2hw),
76:     .hw2reg(hw2reg),
77:     // SEC_CM: BUS.INTEGRITY
78:     .intg_err_o(alerts[0])
79:   );
80: 
81:   // Instantiate DCD core module
82:   adc_ctrl_core u_adc_ctrl_core (
83:     .clk_aon_i(clk_aon_i),
84:     .rst_aon_ni(rst_aon_ni),
85:     .clk_i(clk_i),
86:     .rst_ni(rst_ni),
87:     .reg2hw_i(reg2hw),
88:     .intr_state_o(hw2reg.intr_state),
89:     .adc_chn_val_o(hw2reg.adc_chn_val),
90:     .adc_intr_status_o(hw2reg.adc_intr_status),
91:     .aon_filter_status_o(hw2reg.filter_status),
92:     .wkup_req_o,
93:     .intr_o(intr_match_pending_o),
94:     .adc_i(adc_i),
95:     .adc_o(adc_o),
96:     .aon_fsm_state_o(hw2reg.adc_fsm_state.d)
97:   );
98: 
99:   // All outputs should be known value after reset
100:   `ASSERT_KNOWN(IntrKnown, intr_match_pending_o)
101:   `ASSERT_KNOWN(WakeKnown, wkup_req_o)
102:   `ASSERT_KNOWN(TlODValidKnown, tl_o.d_valid)
103:   `ASSERT_KNOWN(TlOAReadyKnown, tl_o.a_ready)
104:   `ASSERT_KNOWN(AdcKnown_A, adc_o)
105:   `ASSERT_KNOWN(AlertsKnown_A, alert_tx_o)
106: 
107:   // Alert assertions for reg_we onehot check
108:   `ASSERT_PRIM_REG_WE_ONEHOT_ERROR_TRIGGER_ALERT(RegWeOnehotCheck_A, u_reg, alert_tx_o[0])
109: endmodule

================================== Ai Message ==================================

[{'text': "Now, let's look at the core module:", 'type': 'text'}, {'id': 'toolu_01DsmPW3vNE9VrxsaTP7SfRh', 'input': {'file_path': '/home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_core.sv'}, 'name': 'read_file_with_line_numbers', 'type': 'tool_use'}]
Tool Calls:
  read_file_with_line_numbers (toolu_01DsmPW3vNE9VrxsaTP7SfRh)
 Call ID: toolu_01DsmPW3vNE9VrxsaTP7SfRh
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_core.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // adc_ctrl core module
6: 
7: module adc_ctrl_core import adc_ctrl_reg_pkg::* ; (
8:   input  clk_aon_i,//Always-on 200KHz clock(logic)
9:   input  rst_aon_ni,//power-on reset for the 200KHz clock(logic)
10:   input  clk_i,//regular core clock for SW config interface
11:   input  rst_ni,//power-on hardware reset
12: 
13:   // register interface inputs
14:   input  adc_ctrl_reg2hw_t reg2hw_i,
15: 
16:   // register interface outputs
17:   output adc_ctrl_hw2reg_intr_state_reg_t intr_state_o,
18:   output adc_ctrl_hw2reg_adc_chn_val_mreg_t [NumAdcChannel-1:0] adc_chn_val_o,
19:   output adc_ctrl_hw2reg_adc_intr_status_reg_t adc_intr_status_o,
20:   output adc_ctrl_hw2reg_filter_status_reg_t aon_filter_status_o,
21: 
22:   // interrupt and wakeup outputs
23:   output wkup_req_o,
24:   output intr_o,
25: 
26:   // adc interface
27:   input  ast_pkg::adc_ast_rsp_t adc_i,
28:   output ast_pkg::adc_ast_req_t adc_o,
29: 
30:   // FSM state output for debug purposes.
31:   output adc_ctrl_pkg::fsm_state_e aon_fsm_state_o
32: );
33: 
34:   logic chn0_val_we, chn1_val_we;//write enable for the latest ADC sample
35:   logic [9:0] chn0_val, chn1_val;
36: 
37:   logic [NumAdcFilter-1:0] chn0_match, chn1_match, match;
38:   logic [NumAdcFilter-1:0] match_pulse;
39:   logic aon_fsm_trans;
40: 
41:   //write enable for the ADC sample when the interrupt is triggered
42:   logic adc_ctrl_done, oneshot_done;
43: 
44:   // Pack channel 0/1 into one variable
45:   typedef struct packed {
46:     logic [9:0] min_v;
47:     logic [9:0] max_v;
48:     logic cond;
49:     logic en;
50:   } filter_ctl_t;
51: 
52:   filter_ctl_t [NumAdcChannel-1:0][NumAdcFilter-1:0] aon_filter_ctl;
53: 
54:   for (genvar k = 0 ; k < NumAdcFilter ; k++) begin : gen_filter_ctl_sync
55: 
56:     assign aon_filter_ctl[0][k] = '{
57:       min_v: reg2hw_i.adc_chn0_filter_ctl[k].min_v.q,
58:       max_v: reg2hw_i.adc_chn0_filter_ctl[k].max_v.q,
59:       cond:  reg2hw_i.adc_chn0_filter_ctl[k].cond.q,
60:       en:    reg2hw_i.adc_chn0_filter_ctl[k].en.q
61:     };
62: 
63:     assign aon_filter_ctl[1][k] = '{
64:       min_v: reg2hw_i.adc_chn1_filter_ctl[k].min_v.q,
65:       max_v: reg2hw_i.adc_chn1_filter_ctl[k].max_v.q,
66:       cond:  reg2hw_i.adc_chn1_filter_ctl[k].cond.q,
67:       en:    reg2hw_i.adc_chn1_filter_ctl[k].en.q
68:     };
69:   end // block: gen_filter_ctl_sync
70: 
71:   // Recent adc channel values
72:   assign adc_chn_val_o[0].adc_chn_value.de = chn0_val_we;
73:   assign adc_chn_val_o[0].adc_chn_value.d  = chn0_val;
74:   assign adc_chn_val_o[1].adc_chn_value.de = chn1_val_we;
75:   assign adc_chn_val_o[1].adc_chn_value.d  = chn1_val;
76: 
77:   // Interrupt based adc channel values
78:   // The value of the adc is captured whenever an interrupt triggers.
79:   // There are two cases:
80:   // completion of one shot mode
81:   // match detection from the filters
82:   logic chn_val_intr_we;
83:   assign chn_val_intr_we = reg2hw_i.adc_en_ctl.oneshot_mode.q ? oneshot_done :
84:                            reg2hw_i.adc_en_ctl.adc_enable.q   ? |match_pulse : '0;
85: 
86:   assign adc_chn_val_o[0].adc_chn_value_intr.de = chn_val_intr_we;
87:   assign adc_chn_val_o[0].adc_chn_value_intr.d  = chn0_val;
88:   assign adc_chn_val_o[1].adc_chn_value_intr.de = chn_val_intr_we;
89:   assign adc_chn_val_o[1].adc_chn_value_intr.d  = chn1_val;
90: 
91:   //Connect the ports for future extension
92:   assign adc_chn_val_o[0].adc_chn_value_ext.de = 1'b0;
93:   assign adc_chn_val_o[0].adc_chn_value_ext.d  = 2'b0;
94:   assign adc_chn_val_o[1].adc_chn_value_ext.de = 1'b0;
95:   assign adc_chn_val_o[1].adc_chn_value_ext.d  = 2'b0;
96: 
97:   assign adc_chn_val_o[0].adc_chn_value_intr_ext.de = 1'b0;
98:   assign adc_chn_val_o[0].adc_chn_value_intr_ext.d  = 2'b0;
99:   assign adc_chn_val_o[1].adc_chn_value_intr_ext.de = 1'b0;
100:   assign adc_chn_val_o[1].adc_chn_value_intr_ext.d  = 2'b0;
101: 
102:   // Evaluate if there is a match from chn0 and chn1 samples
103:   for (genvar k = 0 ; k < NumAdcFilter ; k++) begin : gen_filter_match
104:     assign chn0_match[k] = (!aon_filter_ctl[0][k].cond) ?
105:             (aon_filter_ctl[0][k].min_v <= chn0_val) && (chn0_val <= aon_filter_ctl[0][k].max_v) :
106:             (aon_filter_ctl[0][k].min_v >  chn0_val) || (chn0_val >  aon_filter_ctl[0][k].max_v);
107:     assign chn1_match[k] = (!aon_filter_ctl[1][k].cond) ?
108:             (aon_filter_ctl[1][k].min_v <= chn1_val) && (chn1_val <= aon_filter_ctl[1][k].max_v) :
109:             (aon_filter_ctl[1][k].min_v >  chn1_val) || (chn1_val >  aon_filter_ctl[1][k].max_v);
110: 
111:     // If the filter on a particular channel is NOT enabled, it does not participate in the final
112:     // match decision.  This means the match value should have no impact on the final result.
113:     // For example, if channel 0's filter is enabled, but channel 1's is not, the match result
114:     // is determined solely based on whether channel 0's filter shows a match.
115:     // On the other hand, if all channel's filters are enabled, then a match is seen only when
116:     // both filters match.
117:     assign match[k] = |{aon_filter_ctl[0][k].en, aon_filter_ctl[1][k].en} &
118:                       (!aon_filter_ctl[0][k].en | (chn0_match[k] & aon_filter_ctl[0][k].en)) &
119:                       (!aon_filter_ctl[1][k].en | (chn1_match[k] & aon_filter_ctl[1][k].en)) ;
120: 
121:     assign match_pulse[k] = adc_ctrl_done && match[k];
122: 
123:    // Explicitly create assertions for all the matching conditions.
124:    // These assertions are unwieldy and not suitable for expansion to more channels.
125:    // They should be adjusted eventually.
126:    `ASSERT(MatchCheck00_A, !aon_filter_ctl[0][k].en & !aon_filter_ctl[1][k].en |->
127:            !match[k], clk_aon_i, !rst_aon_ni)
128:    `ASSERT(MatchCheck01_A, !aon_filter_ctl[0][k].en & aon_filter_ctl[1][k].en  |->
129:            match[k] == chn1_match[k], clk_aon_i, !rst_aon_ni)
130:    `ASSERT(MatchCheck10_A, aon_filter_ctl[0][k].en & !aon_filter_ctl[1][k].en  |->
131:            match[k] == chn0_match[k], clk_aon_i, !rst_aon_ni)
132:    `ASSERT(MatchCheck11_A, aon_filter_ctl[0][k].en & aon_filter_ctl[1][k].en   |->
133:            match[k] == (chn0_match[k] & chn1_match[k]), clk_aon_i, !rst_aon_ni)
134:   end
135: 
136:   // adc filter status
137:   assign aon_filter_status_o.match.d  = match_pulse | reg2hw_i.filter_status.match.q;
138:   assign aon_filter_status_o.match.de = |match_pulse;
139:   // transition status
140:   assign aon_filter_status_o.trans.d  = aon_fsm_trans | reg2hw_i.filter_status.trans.q;
141:   assign aon_filter_status_o.trans.de = aon_fsm_trans;
142: 
143:   // generate wakeup to external power manager if filter status
144:   // and wakeup enable are set.
145:   assign wkup_req_o = |(reg2hw_i.filter_status.match.q &
146:                         reg2hw_i.adc_wakeup_ctl.match_en.q) ||
147:                        (reg2hw_i.filter_status.trans.q &
148:                         reg2hw_i.adc_wakeup_ctl.trans_en.q);
149: 
150:   //instantiate the main state machine
151:   adc_ctrl_fsm u_adc_ctrl_fsm (
152:     .clk_aon_i,
153:     .rst_aon_ni,
154:     // configuration and settings from reg interface
155:     .cfg_fsm_rst_i(reg2hw_i.adc_fsm_rst.q),
156:     .cfg_adc_enable_i(reg2hw_i.adc_en_ctl.adc_enable.q),
157:     .cfg_oneshot_mode_i(reg2hw_i.adc_en_ctl.oneshot_mode.q),
158:     .cfg_lp_mode_i(reg2hw_i.adc_pd_ctl.lp_mode.q),
159:     .cfg_pwrup_time_i(reg2hw_i.adc_pd_ctl.pwrup_time.q),
160:     .cfg_wakeup_time_i(reg2hw_i.adc_pd_ctl.wakeup_time.q),
161:     .cfg_lp_sample_cnt_i(reg2hw_i.adc_lp_sample_ctl.q),
162:     .cfg_np_sample_cnt_i(reg2hw_i.adc_sample_ctl.q),
163:     //
164:     .adc_ctrl_match_i(match),
165:     .adc_d_i(adc_i.data),
166:     .adc_d_val_i(adc_i.data_valid),
167:     .adc_pd_o(adc_o.pd),
168:     .adc_chn_sel_o(adc_o.channel_sel),
169:     .chn0_val_we_o(chn0_val_we),
170:     .chn1_val_we_o(chn1_val_we),
171:     .chn0_val_o(chn0_val),
172:     .chn1_val_o(chn1_val),
173:     .adc_ctrl_done_o(adc_ctrl_done),
174:     .oneshot_done_o(oneshot_done),
175:     .aon_fsm_state_o,
176:     .aon_fsm_trans_o(aon_fsm_trans)
177:   );
178: 
179:   // synchronzie from clk_aon into cfg domain
180:   logic cfg_oneshot_done;
181:   prim_pulse_sync u_oneshot_done_sync (
182:     .clk_src_i(clk_aon_i),
183:     .rst_src_ni(rst_aon_ni),
184:     .src_pulse_i(oneshot_done),
185:     .clk_dst_i(clk_i),
186:     .rst_dst_ni(rst_ni),
187:     .dst_pulse_o(cfg_oneshot_done)
188:   );
189: 
190:   //Instantiate the interrupt module
191:   adc_ctrl_intr u_adc_ctrl_intr (
192:     .clk_i,
193:     .rst_ni,
194:     .clk_aon_i,
195:     .rst_aon_ni,
196:     .aon_filter_match_i(match_pulse),
197:     .aon_fsm_trans_i(aon_fsm_trans),
198:     .cfg_oneshot_done_i(cfg_oneshot_done),
199:     .cfg_intr_en_i(reg2hw_i.adc_intr_ctl.match_en.q),
200:     .cfg_intr_trans_en_i(reg2hw_i.adc_intr_ctl.trans_en.q),
201:     .cfg_oneshot_done_en_i(reg2hw_i.adc_intr_ctl.oneshot_en.q),
202:     .intr_state_i(reg2hw_i.intr_state),
203:     .intr_enable_i(reg2hw_i.intr_enable),
204:     .intr_test_i(reg2hw_i.intr_test),
205:     .intr_state_o,
206:     .adc_intr_status_i(reg2hw_i.adc_intr_status),
207:     .adc_intr_status_o,
208:     .intr_o
209:   );
210: 
211:   // unused register inputs
212:   logic unused_cfgs;
213:   assign unused_cfgs = ^reg2hw_i;
214: 
215:   //////////////////////
216:   // Assertions
217:   //////////////////////
218: 
219:   `ASSERT(MaxFilters_A, NumAdcFilter <= 32, clk_aon_i, !rst_aon_ni)
220: 
221: endmodule

================================== Ai Message ==================================

[{'text': "Let's also look at the FSM implementation:", 'type': 'text'}, {'id': 'toolu_01LwQSuquykHczmDniwhQW6f', 'input': {'file_path': '/home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_fsm.sv'}, 'name': 'read_file_with_line_numbers', 'type': 'tool_use'}]
Tool Calls:
  read_file_with_line_numbers (toolu_01LwQSuquykHczmDniwhQW6f)
 Call ID: toolu_01LwQSuquykHczmDniwhQW6f
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_fsm.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Description adc_ctrl detection FSM module
6: 
7: module adc_ctrl_fsm
8:   import adc_ctrl_reg_pkg::*;
9:   import adc_ctrl_pkg::*;
10: (
11:   input clk_aon_i,
12:   input rst_aon_ni,
13:   input cfg_fsm_rst_i,
14:   input cfg_adc_enable_i,
15:   input cfg_oneshot_mode_i,
16:   input cfg_lp_mode_i,
17:   input [3:0] cfg_pwrup_time_i,
18:   input [23:0] cfg_wakeup_time_i,
19:   input [7:0]  cfg_lp_sample_cnt_i,
20:   input [15:0] cfg_np_sample_cnt_i,
21:   input [NumAdcFilter-1:0] adc_ctrl_match_i,
22:   input [9:0] adc_d_i,
23:   input       adc_d_val_i,//valid bit for ADC value
24:   output logic      adc_pd_o,
25:   output logic[1:0] adc_chn_sel_o,
26:   output logic      chn0_val_we_o,
27:   output logic      chn1_val_we_o,
28:   output logic [9:0] chn0_val_o,
29:   output logic [9:0] chn1_val_o,
30:   output logic       adc_ctrl_done_o,
31:   output logic       oneshot_done_o,
32:   output fsm_state_e aon_fsm_state_o, // FSM state output for debug purposes
33:   output logic       aon_fsm_trans_o // FSM lp -> np transition indication pulse
34: );
35: 
36:   logic trigger_q;
37:   logic trigger_l2h, trigger_h2l;
38: 
39: 
40:   logic [3:0] pwrup_timer_cnt_d, pwrup_timer_cnt_q;
41:   logic pwrup_timer_cnt_clr, pwrup_timer_cnt_en;
42:   logic [9:0] chn0_val_d, chn1_val_d;
43:   logic fsm_chn0_sel, fsm_chn1_sel;
44:   logic chn0_val_we_d, chn1_val_we_d;
45:   logic [7:0] lp_sample_cnt_d, lp_sample_cnt_q;
46:   logic lp_sample_cnt_clr, lp_sample_cnt_en;
47:   logic [23:0] wakeup_timer_cnt_d, wakeup_timer_cnt_q;
48:   logic wakeup_timer_cnt_clr, wakeup_timer_cnt_en;
49:   logic [NumAdcFilter-1:0] adc_ctrl_match_q;
50:   logic stay_match;
51:   logic [15:0] np_sample_cnt_d, np_sample_cnt_q;
52:   logic np_sample_cnt_clr, np_sample_cnt_en;
53:   logic [7:0] lp_sample_cnt_thresh;
54:   logic [15:0] np_sample_cnt_thresh;
55: 
56: 
57:   fsm_state_e fsm_state_q, fsm_state_d;
58:   assign aon_fsm_state_o = fsm_state_q;
59: 
60:   always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin
61:     if (!rst_aon_ni) begin
62:       trigger_q <= 1'b0;
63:     end
64:     else if (cfg_fsm_rst_i) begin
65:       trigger_q <= 1'b0;
66:     end else begin
67:       trigger_q  <= cfg_adc_enable_i;
68:     end
69:   end
70: 
71:   assign trigger_l2h = (trigger_q == 1'b0) && (cfg_adc_enable_i == 1'b1);
72:   assign trigger_h2l = (trigger_q == 1'b1) && (cfg_adc_enable_i == 1'b0);
73: 
74:   assign pwrup_timer_cnt_d = (pwrup_timer_cnt_en) ? pwrup_timer_cnt_q + 1'b1 : pwrup_timer_cnt_q;
75: 
76:   always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin
77:     if (!rst_aon_ni) begin
78:       pwrup_timer_cnt_q    <= '0;
79:     end
80:     else if (pwrup_timer_cnt_clr || cfg_fsm_rst_i || trigger_h2l) begin
81:        pwrup_timer_cnt_q <= '0;
82:     end else begin
83:        pwrup_timer_cnt_q <= pwrup_timer_cnt_d;
84:     end
85:   end
86: 
87:   assign lp_sample_cnt_d = (lp_sample_cnt_en) ? lp_sample_cnt_q + 1'b1 : lp_sample_cnt_q;
88: 
89:   always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin
90:     if (!rst_aon_ni) begin
91:       lp_sample_cnt_q    <= '0;
92:     end
93:     else if (lp_sample_cnt_clr || cfg_fsm_rst_i || trigger_h2l) begin
94:       lp_sample_cnt_q <= '0;
95:     end else begin
96:       lp_sample_cnt_q <= lp_sample_cnt_d;
97:     end
98:   end
99: 
100:   assign np_sample_cnt_d = (np_sample_cnt_en) ? np_sample_cnt_q + 1'b1 : np_sample_cnt_q;
101: 
102:   always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin
103:     if (!rst_aon_ni) begin
104:       np_sample_cnt_q    <= '0;
105:     end
106:     else if (np_sample_cnt_clr || cfg_fsm_rst_i || trigger_h2l) begin
107:       np_sample_cnt_q <= '0;
108:     end else begin
109:       np_sample_cnt_q <= np_sample_cnt_d;
110:     end
111:   end
112: 
113:   assign wakeup_timer_cnt_d = (wakeup_timer_cnt_en) ?
114:            wakeup_timer_cnt_q + 1'b1 : wakeup_timer_cnt_q;
115: 
116:   always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin
117:     if (!rst_aon_ni) begin
118:       wakeup_timer_cnt_q    <= '0;
119:     end
120:     else if (wakeup_timer_cnt_clr || cfg_fsm_rst_i || trigger_h2l) begin
121:       wakeup_timer_cnt_q <= '0;
122:     end else begin
123:       wakeup_timer_cnt_q <= wakeup_timer_cnt_d;
124:     end
125:   end
126: 
127:   assign fsm_chn0_sel = (fsm_state_q == ONEST_0) || (fsm_state_q == LP_0) || (fsm_state_q == NP_0);
128:   assign chn0_val_we_d = fsm_chn0_sel && adc_d_val_i;//adc_d_val_i is a valid pulse
129:   assign chn0_val_d = (chn0_val_we_d) ? adc_d_i : chn0_val_o;
130: 
131:   assign fsm_chn1_sel = (fsm_state_q == ONEST_1) || (fsm_state_q == LP_1) || (fsm_state_q == NP_1);
132:   assign chn1_val_we_d = fsm_chn1_sel && adc_d_val_i;
133:   assign chn1_val_d = (chn1_val_we_d) ? adc_d_i : chn1_val_o;
134: 
135:   always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin
136:     if (!rst_aon_ni) begin
137:       chn0_val_we_o  <= '0;
138:       chn1_val_we_o  <= '0;
139:       chn0_val_o     <= '0;
140:       chn1_val_o     <= '0;
141:     end
142:     else if (cfg_fsm_rst_i) begin
143:       chn0_val_we_o  <= '0;
144:       chn1_val_we_o  <= '0;
145:       chn0_val_o     <= '0;
146:       chn1_val_o     <= '0;
147:     end else begin
148:       chn0_val_we_o  <= chn0_val_we_d;
149:       chn1_val_we_o  <= chn1_val_we_d;
150:       chn0_val_o     <= chn0_val_d;
151:       chn1_val_o     <= chn1_val_d;
152:     end
153:   end
154: 
155:   logic ld_match;
156:   always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin
157:     if (!rst_aon_ni) begin
158:         adc_ctrl_match_q  <= '0;
159:     end
160:     else if (cfg_fsm_rst_i) begin
161:         adc_ctrl_match_q  <= '0;
162:     end
163:     else if (ld_match) begin
164:         adc_ctrl_match_q  <= adc_ctrl_match_i;
165:     end
166:   end
167: 
168:   logic np_match;
169:   assign np_match = |adc_ctrl_match_i &                       // if current match is non-zero
170:                     ((adc_ctrl_match_i == adc_ctrl_match_q) | // match if same as previous match
171:                     ~|adc_ctrl_match_q);                      // or match if previous match was zero
172: 
173:   assign stay_match = np_match;
174: 
175:   always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin
176:     if (!rst_aon_ni) begin
177:       fsm_state_q    <= PWRDN;
178:     end
179:     else if (trigger_h2l || cfg_fsm_rst_i) begin
180:       fsm_state_q    <= PWRDN;
181:     end else begin
182:       fsm_state_q    <= fsm_state_d;
183:     end
184:   end
185: 
186:   assign lp_sample_cnt_thresh = cfg_lp_sample_cnt_i - 1'b1;
187:   assign np_sample_cnt_thresh = cfg_np_sample_cnt_i - 1'b1;
188: 
189:   always_comb begin: adc_fsm
190:     fsm_state_d = fsm_state_q;
191:     //outputs
192:     adc_chn_sel_o = 2'b0;
193:     adc_pd_o = 1'b0;//default value
194:     pwrup_timer_cnt_clr = 1'b0;
195:     pwrup_timer_cnt_en = 1'b0;
196:     lp_sample_cnt_clr = 1'b0;
197:     lp_sample_cnt_en = 1'b0;
198:     wakeup_timer_cnt_clr = 1'b0;
199:     wakeup_timer_cnt_en = 1'b0;
200:     np_sample_cnt_clr = 1'b0;
201:     np_sample_cnt_en = 1'b0;
202:     adc_ctrl_done_o = 1'b0;
203:     oneshot_done_o = 1'b0;
204:     ld_match = 1'b0;
205:     aon_fsm_trans_o = 1'b0;
206: 
207:     unique case (fsm_state_q)
208:       PWRDN: begin
209:         adc_pd_o = 1'b1;
210:         if (trigger_l2h) begin
211:           fsm_state_d = PWRUP;
212:         end
213:       end
214: 
215:       PWRUP: begin
216:         if (pwrup_timer_cnt_q != cfg_pwrup_time_i) begin
217:           pwrup_timer_cnt_en = 1'b1;
218:         end
219:         else if (pwrup_timer_cnt_q == cfg_pwrup_time_i) begin
220:           pwrup_timer_cnt_clr = 1'b1;
221:           if (cfg_oneshot_mode_i) begin
222:             fsm_state_d = ONEST_0;
223:           end
224:           else if (cfg_lp_mode_i) begin
225:             fsm_state_d = LP_0;
226:           end
227:           else if (!cfg_lp_mode_i) begin
228:             fsm_state_d = NP_0;
229:           end
230:         end
231:       end
232: 
233:       ONEST_0: begin
234:         adc_chn_sel_o = 2'b01;
235:         if (adc_d_val_i) begin//sample chn0 value
236:           fsm_state_d = ONEST_021;
237:         end
238:       end
239: 
240:       ONEST_021: begin//transition between chn0 and chn1; adc_chn_sel_o=2'b0
241:         if (!adc_d_val_i) begin
242:           fsm_state_d = ONEST_1;
243:         end
244:       end
245: 
246:       ONEST_1: begin
247:         adc_chn_sel_o = 2'b10;
248:         if (adc_d_val_i) begin//sample chn1 value
249:           fsm_state_d = ONEST_DONE;
250:         end
251:       end
252: 
253:       // delay done assertion by one cycle to match
254:       // adc capture register timing
255:       ONEST_DONE: begin
256:         oneshot_done_o = 1'b1;
257:         fsm_state_d = PWRDN;
258:       end
259: 
260:       LP_0: begin
261:         adc_chn_sel_o = 2'b01;
262:         if (adc_d_val_i) begin//sample chn0 value
263:           fsm_state_d = LP_021;
264:         end
265:       end
266: 
267:       LP_021: begin//transition between chn0 and chn1; adc_chn_sel_o=2'b0
268:         if (!adc_d_val_i) begin
269:           fsm_state_d = LP_1;
270:         end
271:       end
272: 
273:       LP_1: begin
274:         adc_chn_sel_o = 2'b10;
275:         if (adc_d_val_i) begin//sample chn1 value
276:           fsm_state_d = LP_EVAL;
277:         end
278:       end
279: 
280:       LP_EVAL: begin
281:         // do not transition forward until handshake with ADC is complete
282:         if (!adc_d_val_i) begin
283:           ld_match = 1'b1;
284:           if (!stay_match) begin
285:             fsm_state_d = LP_SLP;
286:             lp_sample_cnt_clr = 1'b1;
287:           end else if (lp_sample_cnt_q < lp_sample_cnt_thresh) begin
288:             fsm_state_d = LP_SLP;
289:             lp_sample_cnt_en = 1'b1;
290:           end else if (lp_sample_cnt_q == lp_sample_cnt_thresh) begin
291:             fsm_state_d = NP_0;
292:             lp_sample_cnt_clr = 1'b1;
293:             aon_fsm_trans_o = 1'b1;
294:           end
295:         end
296:       end
297: 
298:       LP_SLP: begin
299:         adc_pd_o = 1'b1;
300:         if (wakeup_timer_cnt_q  != cfg_wakeup_time_i) begin
301:           wakeup_timer_cnt_en = 1'b1;
302:         end
303:         else if (wakeup_timer_cnt_q == cfg_wakeup_time_i) begin
304:           wakeup_timer_cnt_clr = 1'b1;
305:         end
306:       end
307: 
308:       LP_PWRUP: begin
309:         if (pwrup_timer_cnt_q != cfg_pwrup_time_i) begin
310:           pwrup_timer_cnt_en = 1'b1;
311:         end
312:         else if (pwrup_timer_cnt_q == cfg_pwrup_time_i) begin
313:           pwrup_timer_cnt_clr = 1'b1;
314:           fsm_state_d = LP_0;
315:         end
316:       end
317: 
318:       NP_0: begin
319:         adc_chn_sel_o = 2'b01;
320:         if (adc_d_val_i) begin//sample chn0 value
321:           fsm_state_d = NP_021;
322:         end
323:       end
324: 
325:       NP_021: begin//transition between chn0 and chn1; adc_chn_sel_o=2'b0
326:         if (!adc_d_val_i) begin
327:           fsm_state_d = NP_1;
328:         end
329:       end
330: 
331:       NP_1: begin
332:         adc_chn_sel_o = 2'b10;
333:         if (adc_d_val_i) begin//sample chn1 value
334:           fsm_state_d = NP_EVAL;
335:         end
336:       end
337: 
338:       NP_EVAL: begin
339:         // do not transition forward until handshake with ADC is complete
340:         if (!adc_d_val_i) begin
341:           ld_match = 1'b1;
342:           // if there is no match in normal power mode, clear counter and begin sampling again.
343:           // if there is no match and low power mode is enabled, clear counter and go back to LP_0.
344:           //
345:           // if there is a match, there are 3 conditions:
346:           // 1. the sample count is less than the threshold -> still attempting to make a new match,
347:           //    keep sampling.
348:           // 2. the sample count is equal to the threshold -> a new match has just been made, go to
349:           //    DONE.
350:           // 3, the sample count is greater than the threshold -> this is a continued stable match,
351:           //    keep sampling.
352:           if (!stay_match) begin
353:             if (cfg_lp_mode_i) begin
354:               fsm_state_d = LP_0;
355:             end else begin
356:               fsm_state_d = NP_0;
357:             end
358:             np_sample_cnt_clr = 1'b1;
359:           end else if (np_sample_cnt_q < np_sample_cnt_thresh) begin
360:             fsm_state_d = NP_0;
361:             np_sample_cnt_en = 1'b1;
362:           end else if (np_sample_cnt_q == np_sample_cnt_thresh) begin
363:             fsm_state_d = NP_DONE;
364:             np_sample_cnt_en = 1'b1;
365:           end else if (np_sample_cnt_q > np_sample_cnt_thresh) begin
366:             fsm_state_d = NP_0;
367:           end
368:         end
369:       end
370: 
371:       // delay done assertion by one cycle to match with channel register timing
372:       NP_DONE: begin
373:         adc_ctrl_done_o = 1'b1;
374:         fsm_state_d = NP_0;
375:       end
376: 
377:       default: fsm_state_d = PWRDN;
378:     endcase
379:   end
380: 
381:    `ASSUME(LpSampleCntCfg_M, cfg_lp_sample_cnt_i > '0, clk_aon_i, !rst_aon_ni)
382:    `ASSUME(NpSampleCntCfg_M, cfg_np_sample_cnt_i > '0, clk_aon_i, !rst_aon_ni)
383:    `ASSERT(NpCntClrPwrDn_A, fsm_state_q == PWRDN |-> (np_sample_cnt_q == '0),
384:            clk_aon_i, !rst_aon_ni)
385: 
386:    // This statement should hold true even during low power scanning
387:    `ASSERT(NpCntClrMisMatch_A, ld_match & !stay_match |=>
388:            (np_sample_cnt_q == '0), clk_aon_i, !rst_aon_ni)
389: 
390: endmodule

================================== Ai Message ==================================

[{'text': "Now, let's run some security analysis tools to identify potential security issues in the adc_ctrl IP.\n\nFirst, let's run the Verilator agent to check for any failing tests:", 'type': 'text'}, {'id': 'toolu_01SMJYLX3ineHS3BHsX5iDqf', 'input': {'ip': 'adc_ctrl'}, 'name': 'run_verilator_agent', 'type': 'tool_use'}]
Tool Calls:
  run_verilator_agent (toolu_01SMJYLX3ineHS3BHsX5iDqf)
 Call ID: toolu_01SMJYLX3ineHS3BHsX5iDqf
  Args:
    ip: adc_ctrl
================================= Tool Message =================================
Name: run_verilator_agent

Based on the verilator test results for the adc_ctrl IP, I can see that the test has passed successfully. The output shows:

- The adc_ctrl_unittest was executed and PASSED
- The test completed in 0.4 seconds
- There were no failing tests reported

Since there are no failing tests, there are no immediate security issues detected by the verilator tests for this IP. The test output doesn't indicate any security vulnerabilities in the RTL code of the adc_ctrl IP.

However, there is a note about tests with specified sizes that are too big. This is not a security issue but rather a configuration note about test sizes.

Would you like me to examine any specific part of the adc_ctrl IP code for a more detailed security analysis? I could look at the RTL code directly if you're concerned about potential issues that might not be covered by the existing tests.
================================== Ai Message ==================================

[{'text': "Let's run the CWE checker to look for potential security vulnerabilities:", 'type': 'text'}, {'id': 'toolu_01QJ1dkYA6xJFhTjujn5YtX2', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_fsm.sv', 'top_module': 'adc_ctrl_fsm', 'security_objective': 'state machine security'}, 'name': 'run_llm_cwe_checker_agent', 'type': 'tool_use'}]
Tool Calls:
  run_llm_cwe_checker_agent (toolu_01QJ1dkYA6xJFhTjujn5YtX2)
 Call ID: toolu_01QJ1dkYA6xJFhTjujn5YtX2
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_fsm.sv
    top_module: adc_ctrl_fsm
    security_objective: state machine security
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

Based on the CWE details, I'll now analyze the provided RTL code for state machine security concerns, specifically focusing on CWE-1245: Improper Finite State Machines (FSMs) in Hardware Logic.

## Analysis of State Machine Security in the RTL

The provided RTL implements an ADC controller state machine (`adc_ctrl_fsm`) that manages different operating modes for an analog-to-digital converter. Let me analyze it for potential security issues:

### Identified Security Concerns:

1. **Incomplete State Handling in Case Statement**:
   The main state machine implementation in the `adc_fsm` always_comb block uses a `unique case` statement, which is good practice. However, there's a potential issue:
   
   ```verilog
   unique case (fsm_state_q)
     // Various states handled...
     default: fsm_state_d = PWRDN;
   endcase
   ```
   
   While there is a default case that transitions to PWRDN state, this might not be the most secure approach if an unexpected state is reached. The default case should ideally handle error conditions more explicitly.

2. **State Transition Security**:
   The state machine has complex transition logic, particularly in the `LP_EVAL` and `NP_EVAL` states where decisions are made based on match conditions. These critical decision points could be vulnerable to timing attacks or glitches.

3. **Reset Handling**:
   The code has reset handling in multiple places:
   ```verilog
   if (!rst_aon_ni) begin
     fsm_state_q <= PWRDN;
   end
   else if (trigger_h2l || cfg_fsm_rst_i) begin
     fsm_state_q <= PWRDN;
   end
   ```
   This is generally good, but there's a potential concern with the multiple reset conditions that could lead to inconsistent state if not properly synchronized.

4. **Potential for Unreachable States**:
   The FSM has states like `LP_PWRUP` that appear in the state enumeration but don't have clear transition paths to them in the state machine logic. This could indicate a design flaw or incomplete implementation.

5. **Lack of Explicit Illegal State Detection**:
   The design doesn't appear to have explicit detection or handling for illegal state transitions, which could be exploited in a fault injection attack.

6. **Signal Synchronization**:
   The code uses signals like `adc_d_val_i` for state transitions, but there's no explicit synchronization logic to prevent metastability issues when crossing clock domains, which could lead to unpredictable state transitions.

### Positive Security Aspects:

1. The use of `unique case` statement helps ensure that synthesis tools will generate logic to detect unspecified states.

2. The module includes assertions and assumptions that help verify correct behavior:
   ```verilog
   `ASSUME(LpSampleCntCfg_M, cfg_lp_sample_cnt_i > '0, clk_aon_i, !rst_aon_ni)
   `ASSUME(NpSampleCntCfg_M, cfg_np_sample_cnt_i > '0, clk_aon_i, !rst_aon_ni)
   `ASSERT(NpCntClrPwrDn_A, fsm_state_q == PWRDN |-> (np_sample_cnt_q == '0),
           clk_aon_i, !rst_aon_ni)
   ```

3. The state machine has clear reset paths to a known safe state (PWRDN).

## Conclusion

The RTL code has several potential security concerns related to CWE-1245 (Improper Finite State Machines in Hardware Logic). The most significant issues are:

1. Potential unreachable states or incomplete state transition paths
2. Lack of explicit illegal state detection and recovery
3. Complex transition logic that could be vulnerable to timing attacks

To improve security, the design should:
- Implement explicit detection and handling of illegal states
- Ensure all states have clear, defined transition paths
- Add more comprehensive assertions to verify state machine behavior
- Consider adding timeout mechanisms for states that wait for external events
- Implement more robust synchronization for signals crossing clock domains

These improvements would help mitigate the risk of an attacker manipulating the
================================== Ai Message ==================================

[{'text': "Let's also run the assertions checker to identify potential security issues:", 'type': 'text'}, {'id': 'toolu_013Qb4KTYTxYPeLT7vsKhiPW', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_fsm.sv', 'top_module': 'adc_ctrl_fsm', 'security_objective': 'state machine security'}, 'name': 'run_assertions_checker_agent', 'type': 'tool_use'}]
Tool Calls:
  run_assertions_checker_agent (toolu_013Qb4KTYTxYPeLT7vsKhiPW)
 Call ID: toolu_013Qb4KTYTxYPeLT7vsKhiPW
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_fsm.sv
    top_module: adc_ctrl_fsm
    security_objective: state machine security
================================= Tool Message =================================
Name: run_assertions_checker_agent

[{"text": "I need to provide the assertions parameter. Let me create relevant assertions for state machine security:", "type": "text"}, {"id": "toolu_01JJycvKwKJV9FBXL8PaUdzt", "input": {"design_filepath": "/home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_fsm.sv", "top_module": "adc_ctrl_fsm", "clock_signal": "clk_aon_i", "reset_signal": "rst_aon_ni", "reset_active": "low", "assertions": {"reset_state_check": "property reset_state_check;\n    @(posedge clk_aon_i) !rst_aon_ni |=> (fsm_state_q == PWRDN);\nendproperty\nassertion_reset_state_check: assert property (reset_state_check);", "fsm_disable_check": "property fsm_disable_check;\n    @(posedge clk_aon_i) trigger_h2l |=> (fsm_state_q == PWRDN);\nendproperty\nassertion_fsm_disable_check: assert property (fsm_disable_check);", "fsm_reset_check": "property fsm_reset_check;\n    @(posedge clk_aon_i) cfg_fsm_rst_i |=> (fsm_state_q == PWRDN);\nendproperty\nassertion_fsm_reset_check: assert property (fsm_reset_check);", "no_invalid_states": "property no_invalid_states;\n    @(posedge clk_aon_i) (fsm_state_q inside {PWRDN, PWRUP, ONEST_0, ONEST_021, ONEST_1, ONEST_DONE, LP_0, LP_021, LP_1, LP_EVAL, LP_SLP, LP_PWRUP, NP_0, NP_021, NP_1, NP_EVAL, NP_DONE});\nendproperty\nassertion_no_invalid_states: assert property (no_invalid_states);", "lp_to_np_transition": "property lp_to_np_transition;\n    @(posedge clk_aon_i) (fsm_state_q == LP_EVAL && lp_sample_cnt_q == lp_sample_cnt_thresh && stay_match) |=> (fsm_state_q == NP_0);\nendproperty\nassertion_lp_to_np_transition: assert property (lp_to_np_transition);", "np_done_transition": "property np_done_transition;\n    @(posedge clk_aon_i) (fsm_state_q == NP_EVAL && np_sample_cnt_q == np_sample_cnt_thresh && stay_match) |=> (fsm_state_q == NP_DONE);\nendproperty\nassertion_np_done_transition: assert property (np_done_transition);", "oneshot_completion": "property oneshot_completion;\n    @(posedge clk_aon_i) (fsm_state_q == ONEST_DONE) |=> (fsm_state_q == PWRDN);\nendproperty\nassertion_oneshot_completion: assert property (oneshot_completion);"}}, "name": "assertion_checker_tool", "type": "tool_use"}]
================================== Ai Message ==================================

[{'text': "Let's run the linter agent to check for potential security issues:", 'type': 'text'}, {'id': 'toolu_01VWmUyyMtNPTc27UAnsuaa7', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_fsm.sv', 'top_module': 'adc_ctrl_fsm', 'security_objective': 'FSM security'}, 'name': 'run_linter_agent', 'type': 'tool_use'}]
Tool Calls:
  run_linter_agent (toolu_01VWmUyyMtNPTc27UAnsuaa7)
 Call ID: toolu_01VWmUyyMtNPTc27UAnsuaa7
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_fsm.sv
    top_module: adc_ctrl_fsm
    security_objective: FSM security
================================= Tool Message =================================
Name: run_linter_agent

Based on the lint check results and analysis, here are the security concerns in the ADC controller FSM:

1. Unreachable States:
   - The state `LP_PWRUP` appears to be unreachable in the current FSM implementation. This could potentially create unexpected behavior or security vulnerabilities if the state cannot be transitioned to under any circumstances.

2. States Without Exit:
   - The `LP_SLP` (Low Power Sleep) state is flagged as having no clear exit path. This means the FSM might get stuck in this state, which could be a potential denial of service (DoS) vulnerability.

3. Potential State Transition Issues:
   - The lint tool detected that some states might not have proper transition mechanisms, which could lead to unpredictable system behavior.

Recommendations:
1. Review and modify the FSM logic to ensure all states have clear and valid transition paths.
2. Specifically, investigate why `LP_PWRUP` is unreachable and add appropriate state transition logic.
3. Ensure the `LP_SLP` state has a definitive way to exit, preventing potential system lockup.
4. Add additional state transition checks or reset mechanisms to handle edge cases.

Additional Security Observations:
- The FSM does have some built-in security features like:
  - Reset handling for various states
  - Configurable power modes
  - Match detection mechanisms
  - Sample count thresholds

While these are positive aspects, the unreachable and exit-less states could be exploited to disrupt the ADC controller's normal operation.

Suggested Mitigation:
1. Add explicit state transition logic for `LP_PWRUP`
2. Implement a timeout or watchdog mechanism for the `LP_SLP` state
3. Add more robust error handling and state recovery mechanisms

Would you like me to elaborate on any of these findings or suggest specific code modifications to address these security concerns?
================================== Ai Message ==================================

[{'text': "Let's also check the interrupt handling logic:", 'type': 'text'}, {'id': 'toolu_012xeEFx7G6ihZRfopPif5FB', 'input': {'file_path': '/home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_intr.sv'}, 'name': 'read_file_with_line_numbers', 'type': 'tool_use'}]
Tool Calls:
  read_file_with_line_numbers (toolu_012xeEFx7G6ihZRfopPif5FB)
 Call ID: toolu_012xeEFx7G6ihZRfopPif5FB
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_intr.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Description: adc_ctrl interrupt Module
6: //
7: module adc_ctrl_intr
8:   import adc_ctrl_reg_pkg::*;
9: #(
10: ) (
11:   input  clk_aon_i,
12:   input  rst_aon_ni,
13:   input  clk_i,
14:   input  rst_ni,
15: 
16:   input  [NumAdcFilter-1:0] aon_filter_match_i,
17:   input  aon_fsm_trans_i,
18:   input  cfg_oneshot_done_i,
19: 
20:   input  [NumAdcFilter-1:0] cfg_intr_en_i,
21:   input  cfg_intr_trans_en_i,
22:   input  cfg_oneshot_done_en_i,
23: 
24:   input  adc_ctrl_reg2hw_intr_state_reg_t intr_state_i,
25:   input  adc_ctrl_reg2hw_intr_enable_reg_t intr_enable_i,
26:   input  adc_ctrl_reg2hw_intr_test_reg_t intr_test_i,
27: 
28:   output adc_ctrl_hw2reg_intr_state_reg_t intr_state_o,
29:   input  adc_ctrl_reg2hw_adc_intr_status_reg_t adc_intr_status_i,
30:   output adc_ctrl_hw2reg_adc_intr_status_reg_t adc_intr_status_o,
31: 
32:   output intr_o
33: );
34: 
35: 
36:   // Number of filters and FSM transition interrupt.
37:   localparam int NumAonIntrEvents = NumAdcFilter + 1;
38:   logic [NumAonIntrEvents-1:0] aon_reqs;
39:   assign aon_reqs = {aon_fsm_trans_i, aon_filter_match_i};
40: 
41:   // aon interrupt requests are split into staging and request portions.
42:   // The staging portion always absorbs the incoming event pulse.
43:   // The request portion on the other hand does not change until
44:   // a request/ack handshake cycle has completed.
45:   logic [NumAonIntrEvents-1:0] aon_staging_reqs_q;
46:   logic aon_ld_req;
47: 
48:   // staging portion takes on the value of the incoming event match
49:   // and clears when it is snapshot into request hold.
50:   always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin
51:      if (!rst_aon_ni) begin
52:         aon_staging_reqs_q <= '0;
53:      end else if (aon_ld_req) begin
54:         aon_staging_reqs_q <= aon_reqs;
55:      end else if (|aon_reqs) begin
56:         aon_staging_reqs_q <= aon_staging_reqs_q | aon_reqs;
57:      end
58:   end
59: 
60:   logic [NumAonIntrEvents-1:0] aon_req_hold_q;
61:   logic aon_ack;
62: 
63:   // staging has pending requsts
64:   assign aon_ld_req = (aon_req_hold_q == '0) && |aon_staging_reqs_q;
65: 
66:   // request hold self clears when the handshake cycle is complete
67:   always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin
68:      if (!rst_aon_ni) begin
69:         aon_req_hold_q <= '0;
70:      end else if (aon_ld_req) begin
71:         aon_req_hold_q <= aon_staging_reqs_q;
72:      end else if (aon_ack) begin
73:         aon_req_hold_q <= '0;
74:      end
75:   end
76: 
77:   logic dst_ack;
78:   prim_sync_reqack u_match_sync (
79:     .clk_src_i(clk_aon_i),
80:     .rst_src_ni(rst_aon_ni),
81:     .clk_dst_i(clk_i),
82:     .rst_dst_ni(rst_ni),
83:     .req_chk_i(1'b1),
84:     .src_req_i(|aon_req_hold_q),
85:     .src_ack_o(aon_ack),
86:     .dst_req_o(dst_ack),
87:     .dst_ack_i(dst_ack)
88:   );
89: 
90:   // Holding reg after the CDC. Note that aon_req_hold_q does not change until the handshake has
91:   // been completed, hence we can sample it safely upon a dst_ack pulse.
92:   logic dst_ack_q;
93:   logic [NumAonIntrEvents-1:0] req_hold_q;
94:   always_ff @(posedge clk_i or negedge rst_ni) begin
95:     if (!rst_ni) begin
96:       req_hold_q <= '0;
97:       dst_ack_q <= 1'b0;
98:     end else begin
99:       dst_ack_q <= dst_ack;
100:       if (dst_ack) begin
101:         req_hold_q <= aon_req_hold_q;
102:       end
103:     end
104:   end
105: 
106:   assign adc_intr_status_o.trans.de = cfg_intr_trans_en_i && dst_ack_q && req_hold_q[8];
107:   assign adc_intr_status_o.trans.d = 1'b1;
108:   // Since interrupt events are pulsed, when successive events arrive we need to make sure to
109:   // hold the previously latched values
110:   logic [NumAdcFilter-1:0] match_events;
111:   assign match_events = cfg_intr_en_i & {NumAdcFilter{dst_ack_q}} & req_hold_q[NumAdcFilter-1:0];
112:   assign adc_intr_status_o.match.de = |match_events;
113:   assign adc_intr_status_o.match.d = match_events | adc_intr_status_i.match.q;
114:   // Note that we're also adding the non-AON interrupt source cfg_oneshot_done_i at this point.
115:   assign adc_intr_status_o.oneshot.de = cfg_oneshot_done_i && cfg_oneshot_done_en_i;
116:   assign adc_intr_status_o.oneshot.d = 1'b1;
117: 
118:   logic status_irq_value;
119:   assign status_irq_value = |{adc_intr_status_i.oneshot.q,
120:                               adc_intr_status_i.trans.q,
121:                               adc_intr_status_i.match.q};
122: 
123:   // instantiate interrupt hardware primitive
124:   prim_intr_hw #(
125:     .Width(1),
126:     .IntrT("Status")
127:   ) i_adc_ctrl_intr_o (
128:     .clk_i(clk_i),
129:     .rst_ni(rst_ni),
130:     .event_intr_i           (status_irq_value),
131:     .reg2hw_intr_enable_q_i (intr_enable_i.q),
132:     .reg2hw_intr_test_q_i   (intr_test_i.q),
133:     .reg2hw_intr_test_qe_i  (intr_test_i.qe),
134:     .reg2hw_intr_state_q_i  (intr_state_i.q),
135:     .hw2reg_intr_state_de_o (intr_state_o.de),
136:     .hw2reg_intr_state_d_o  (intr_state_o.d),
137:     .intr_o
138:   );
139: 
140: endmodule

================================== Ai Message ==================================

[{'text': "Let's run the linter on the interrupt module:", 'type': 'text'}, {'id': 'toolu_012i5yZ2zZi7Nk7B6XB32MKc', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_intr.sv', 'top_module': 'adc_ctrl_intr', 'security_objective': 'interrupt security'}, 'name': 'run_linter_agent', 'type': 'tool_use'}]
Tool Calls:
  run_linter_agent (toolu_012i5yZ2zZi7Nk7B6XB32MKc)
 Call ID: toolu_012i5yZ2zZi7Nk7B6XB32MKc
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_intr.sv
    top_module: adc_ctrl_intr
    security_objective: interrupt security
================================= Tool Message =================================
Name: run_linter_agent

Analysis of Security Concerns:

1. Clock Domain Crossing (CDC) Vulnerability:
   - The lint checker identified a ClockDomain error, which indicates multiple clock domains (clk_aon_i and clk_i) in the interrupt module.
   - While the design uses a synchronization primitive (prim_sync_reqack) to handle clock domain crossing, there are potential security risks:
     a. Race conditions between clock domains
     b. Potential metastability issues
     c. Timing-related vulnerabilities

2. Interrupt Handling Security Observations:
   - The module uses a complex staging mechanism for interrupt requests across clock domains
   - Multiple registers (aon_staging_reqs_q, aon_req_hold_q, req_hold_q) are used to manage interrupt state
   - The synchronization uses a handshake protocol, which helps mitigate some CDC risks

3. Potential Security Recommendations:
   - Carefully review the CDC synchronization logic
   - Ensure robust handling of metastability
   - Add additional CDC verification and formal verification
   - Consider adding timeout mechanisms for cross-domain handshakes

Specific Concerns:
- The ClockDomain error suggests potential timing-related security vulnerabilities
- The interrupt staging and holding logic is complex, which could introduce subtle security issues
- Multiple clock domains increase the attack surface for timing-based side-channel attacks

Conclusion:
While the design uses a synchronization primitive and appears to have thoughtful interrupt handling, the multiple clock domains introduce potential security risks that should be carefully reviewed and validated through additional testing, formal verification, and side-channel analysis.

Recommendations:
1. Conduct thorough CDC verification
2. Perform side-channel analysis
3. Add formal verification for cross-domain logic
4. Consider simplifying the interrupt handling state machine if possible
================================== Ai Message ==================================

[{'text': "Let's also check the core module for security issues:", 'type': 'text'}, {'id': 'toolu_01Xw8MNyvAXzakNW8pkWLY8Q', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_core.sv', 'top_module': 'adc_ctrl_core', 'security_objective': 'register access security'}, 'name': 'run_linter_agent', 'type': 'tool_use'}]
Tool Calls:
  run_linter_agent (toolu_01Xw8MNyvAXzakNW8pkWLY8Q)
 Call ID: toolu_01Xw8MNyvAXzakNW8pkWLY8Q
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_core.sv
    top_module: adc_ctrl_core
    security_objective: register access security
================================= Tool Message =================================
Name: run_linter_agent

Analysis of Security Concerns:

1. Register Access Security Observations:
   - The design uses a structured register interface (`reg2hw_i`) which is a good practice for controlled register access.
   - There are multiple security-conscious design elements:
     a) Synchronized filter controls
     b) Explicit enable/disable mechanisms for filters
     c) Interrupt and wakeup controls with configurable settings

2. Potential Security Considerations:
   - The code uses an `unused_cfgs` signal that captures all register inputs, which could be a potential security measure to catch unexpected register accesses.
   - The design includes assertions to validate filter matching conditions, which helps prevent potential logic vulnerabilities.

3. Specific Security Mechanisms:
   - Wakeup request (`wkup_req_o`) is controlled by specific enable bits
   - Interrupt generation is carefully controlled with multiple enable conditions
   - Filter status tracking prevents unauthorized state changes

4. Lint Check Results:
   - No critical security violations were immediately flagged by the lint checks
   - The design appears to have robust register access controls

Recommendations:
1. Continue using structured register interfaces
2. Maintain the current assertion-based validation
3. Consider adding more explicit access control mechanisms if needed

While the lint checks didn't reveal immediate security concerns, it's always recommended to perform comprehensive security reviews, including:
- Formal verification
- Penetration testing
- Side-channel analysis

The RTL demonstrates a thoughtful approach to register access security with multiple layers of control and validation.
================================== Ai Message ==================================

[{'text': "Let's run the CWE checker on the core module:", 'type': 'text'}, {'id': 'toolu_0117u8ugSebJBMuaTJrwJn4Q', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_core.sv', 'top_module': 'adc_ctrl_core', 'security_objective': 'register access security'}, 'name': 'run_llm_cwe_checker_agent', 'type': 'tool_use'}]
Tool Calls:
  run_llm_cwe_checker_agent (toolu_0117u8ugSebJBMuaTJrwJn4Q)
 Call ID: toolu_0117u8ugSebJBMuaTJrwJn4Q
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_core.sv
    top_module: adc_ctrl_core
    security_objective: register access security
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

Based on my analysis of the provided RTL code and the relevant CWE information, I can identify potential security concerns related to register access security in the ADC controller module.

## Relevant CWE
The primary security concern relates to **CWE-1233: Security-Sensitive Hardware Controls with Missing Lock Bit Protection**. This weakness occurs when security-sensitive hardware controls lack proper lock bit protection mechanisms, allowing unauthorized modification of critical system registers or controls.

## Security Analysis of the ADC Controller RTL

After examining the code, I've identified several potential security issues related to register access control:

1. **Lack of Lock Bit Protection Mechanism**:
   - The RTL code doesn't implement any lock bit protection for critical configuration registers.
   - There's no mechanism to prevent modification of security-sensitive registers after initial configuration.
   - For example, the ADC filter controls, wakeup controls, and other critical configuration registers can be modified at any time.

2. **Critical Configuration Registers Without Protection**:
   - The following registers appear to control critical functionality but lack protection mechanisms:
     - `reg2hw_i.adc_en_ctl.adc_enable.q` - Controls ADC enabling
     - `reg2hw_i.adc_en_ctl.oneshot_mode.q` - Controls ADC operation mode
     - `reg2hw_i.adc_wakeup_ctl.match_en.q` and `reg2hw_i.adc_wakeup_ctl.trans_en.q` - Control wakeup functionality
     - `reg2hw_i.adc_fsm_rst.q` - Can reset the FSM
     - Filter configuration registers that determine match conditions

3. **No Access Control Differentiation**:
   - The code doesn't distinguish between privileged and unprivileged access to registers.
   - All registers appear to be directly accessible without privilege checks.

4. **Potential for Security Bypass**:
   - An attacker with access to these registers could:
     - Disable critical ADC functionality by modifying `adc_en_ctl`
     - Change filter parameters to prevent proper detection of conditions
     - Manipulate wakeup controls to prevent system wakeup on critical conditions
     - Reset the FSM during critical operations using `adc_fsm_rst`

5. **Specific Code Examples**:
   ```verilog
   // These critical control signals have no lock protection
   .cfg_fsm_rst_i(reg2hw_i.adc_fsm_rst.q),
   .cfg_adc_enable_i(reg2hw_i.adc_en_ctl.adc_enable.q),
   .cfg_oneshot_mode_i(reg2hw_i.adc_en_ctl.oneshot_mode.q),
   .cfg_lp_mode_i(reg2hw_i.adc_pd_ctl.lp_mode.q),
   ```

   ```verilog
   // Wakeup controls that could be manipulated
   assign wkup_req_o = |(reg2hw_i.filter_status.match.q &
                        reg2hw_i.adc_wakeup_ctl.match_en.q) ||
                       (reg2hw_i.filter_status.trans.q &
                        reg2hw_i.adc_wakeup_ctl.trans_en.q);
   ```

   ```verilog
   // Filter controls that determine match conditions
   assign aon_filter_ctl[0][k] = '{
     min_v: reg2hw_i.adc_chn0_filter_ctl[k].min_v.q,
     max_v: reg2hw_i.adc_chn0_filter_ctl[k].max_v.q,
     cond:  reg2hw_i.adc_chn0_filter_ctl[k].cond.q,
     en:    reg2hw_i.adc_chn0_filter_ctl[k].en.q
   };
   ```

## Recommendations

To address these security concerns:

1. Implement a lock bit mechanism for critical configuration registers that should not be modified after initial setup.
2. Add access control logic to differentiate between privileged and unprivileged register access
================================== Ai Message ==================================

[{'text': "Let's also check the register top module:", 'type': 'text'}, {'id': 'toolu_01HfpKBrD5Gwp9ecujPTeDHZ', 'input': {'file_path': '/home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_reg_top.sv'}, 'name': 'read_file_with_line_numbers', 'type': 'tool_use'}]
Tool Calls:
  read_file_with_line_numbers (toolu_01HfpKBrD5Gwp9ecujPTeDHZ)
 Call ID: toolu_01HfpKBrD5Gwp9ecujPTeDHZ
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_reg_top.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Register Top module auto-generated by `reggen`
6: 
7: `include "prim_assert.sv"
8: 
9: module adc_ctrl_reg_top (
10:   input clk_i,
11:   input rst_ni,
12:   input clk_aon_i,
13:   input rst_aon_ni,
14:   input  tlul_pkg::tl_h2d_t tl_i,
15:   output tlul_pkg::tl_d2h_t tl_o,
16:   // To HW
17:   output adc_ctrl_reg_pkg::adc_ctrl_reg2hw_t reg2hw, // Write
18:   input  adc_ctrl_reg_pkg::adc_ctrl_hw2reg_t hw2reg, // Read
19: 
20:   // Integrity check errors
21:   output logic intg_err_o
22: );
23: 
24:   import adc_ctrl_reg_pkg::* ;
25: 
26:   localparam int AW = 7;
27:   localparam int DW = 32;
28:   localparam int DBW = DW/8;                    // Byte Width
29: 
30:   // register signals
31:   logic           reg_we;
32:   logic           reg_re;
33:   logic [AW-1:0]  reg_addr;
34:   logic [DW-1:0]  reg_wdata;
35:   logic [DBW-1:0] reg_be;
36:   logic [DW-1:0]  reg_rdata;
37:   logic           reg_error;
38: 
39:   logic          addrmiss, wr_err;
40: 
41:   logic [DW-1:0] reg_rdata_next;
42:   logic reg_busy;
43: 
44:   tlul_pkg::tl_h2d_t tl_reg_h2d;
45:   tlul_pkg::tl_d2h_t tl_reg_d2h;
46: 
47: 
48:   // incoming payload check
49:   logic intg_err;
50:   tlul_cmd_intg_chk u_chk (
51:     .tl_i(tl_i),
52:     .err_o(intg_err)
53:   );
54: 
55:   // also check for spurious write enables
56:   logic reg_we_err;
57:   logic [31:0] reg_we_check;
58:   prim_reg_we_check #(
59:     .OneHotWidth(32)
60:   ) u_prim_reg_we_check (
61:     .clk_i(clk_i),
62:     .rst_ni(rst_ni),
63:     .oh_i  (reg_we_check),
64:     .en_i  (reg_we && !addrmiss),
65:     .err_o (reg_we_err)
66:   );
67: 
68:   logic err_q;
69:   always_ff @(posedge clk_i or negedge rst_ni) begin
70:     if (!rst_ni) begin
71:       err_q <= '0;
72:     end else if (intg_err || reg_we_err) begin
73:       err_q <= 1'b1;
74:     end
75:   end
76: 
77:   // integrity error output is permanent and should be used for alert generation
78:   // register errors are transactional
79:   assign intg_err_o = err_q | intg_err | reg_we_err;
80: 
81:   // outgoing integrity generation
82:   tlul_pkg::tl_d2h_t tl_o_pre;
83:   tlul_rsp_intg_gen #(
84:     .EnableRspIntgGen(1),
85:     .EnableDataIntgGen(1)
86:   ) u_rsp_intg_gen (
87:     .tl_i(tl_o_pre),
88:     .tl_o(tl_o)
89:   );
90: 
91:   assign tl_reg_h2d = tl_i;
92:   assign tl_o_pre   = tl_reg_d2h;
93: 
94:   tlul_adapter_reg #(
95:     .RegAw(AW),
96:     .RegDw(DW),
97:     .EnableDataIntgGen(0)
98:   ) u_reg_if (
99:     .clk_i  (clk_i),
100:     .rst_ni (rst_ni),
101: 
102:     .tl_i (tl_reg_h2d),
103:     .tl_o (tl_reg_d2h),
104: 
105:     .en_ifetch_i(prim_mubi_pkg::MuBi4False),
106:     .intg_error_o(),
107: 
108:     .we_o    (reg_we),
109:     .re_o    (reg_re),
110:     .addr_o  (reg_addr),
111:     .wdata_o (reg_wdata),
112:     .be_o    (reg_be),
113:     .busy_i  (reg_busy),
114:     .rdata_i (reg_rdata),
115:     .error_i (reg_error)
116:   );
117: 
118:   // cdc oversampling signals
119: 
120:   assign reg_rdata = reg_rdata_next ;
121:   assign reg_error = addrmiss | wr_err | intg_err;
122: 
123:   // Define SW related signals
124:   // Format: <reg>_<field>_{wd|we|qs}
125:   //        or <reg>_{wd|we|qs} if field == 1 or 0
126:   logic intr_state_qs;
127:   logic intr_enable_we;
128:   logic intr_enable_qs;
129:   logic intr_enable_wd;
130:   logic intr_test_we;
131:   logic intr_test_wd;
132:   logic alert_test_we;
133:   logic alert_test_wd;
134:   logic adc_en_ctl_we;
135:   logic [1:0] adc_en_ctl_qs;
136:   logic adc_en_ctl_busy;
137:   logic adc_pd_ctl_we;
138:   logic [31:0] adc_pd_ctl_qs;
139:   logic adc_pd_ctl_busy;
140:   logic adc_lp_sample_ctl_we;
141:   logic [7:0] adc_lp_sample_ctl_qs;
142:   logic adc_lp_sample_ctl_busy;
143:   logic adc_sample_ctl_we;
144:   logic [15:0] adc_sample_ctl_qs;
145:   logic adc_sample_ctl_busy;
146:   logic adc_fsm_rst_we;
147:   logic [0:0] adc_fsm_rst_qs;
148:   logic adc_fsm_rst_busy;
149:   logic adc_chn0_filter_ctl_0_we;
150:   logic [31:0] adc_chn0_filter_ctl_0_qs;
151:   logic adc_chn0_filter_ctl_0_busy;
152:   logic adc_chn0_filter_ctl_1_we;
153:   logic [31:0] adc_chn0_filter_ctl_1_qs;
154:   logic adc_chn0_filter_ctl_1_busy;
155:   logic adc_chn0_filter_ctl_2_we;
156:   logic [31:0] adc_chn0_filter_ctl_2_qs;
157:   logic adc_chn0_filter_ctl_2_busy;
158:   logic adc_chn0_filter_ctl_3_we;
159:   logic [31:0] adc_chn0_filter_ctl_3_qs;
160:   logic adc_chn0_filter_ctl_3_busy;
161:   logic adc_chn0_filter_ctl_4_we;
162:   logic [31:0] adc_chn0_filter_ctl_4_qs;
163:   logic adc_chn0_filter_ctl_4_busy;
164:   logic adc_chn0_filter_ctl_5_we;
165:   logic [31:0] adc_chn0_filter_ctl_5_qs;
166:   logic adc_chn0_filter_ctl_5_busy;
167:   logic adc_chn0_filter_ctl_6_we;
168:   logic [31:0] adc_chn0_filter_ctl_6_qs;
169:   logic adc_chn0_filter_ctl_6_busy;
170:   logic adc_chn0_filter_ctl_7_we;
171:   logic [31:0] adc_chn0_filter_ctl_7_qs;
172:   logic adc_chn0_filter_ctl_7_busy;
173:   logic adc_chn1_filter_ctl_0_we;
174:   logic [31:0] adc_chn1_filter_ctl_0_qs;
175:   logic adc_chn1_filter_ctl_0_busy;
176:   logic adc_chn1_filter_ctl_1_we;
177:   logic [31:0] adc_chn1_filter_ctl_1_qs;
178:   logic adc_chn1_filter_ctl_1_busy;
179:   logic adc_chn1_filter_ctl_2_we;
180:   logic [31:0] adc_chn1_filter_ctl_2_qs;
181:   logic adc_chn1_filter_ctl_2_busy;
182:   logic adc_chn1_filter_ctl_3_we;
183:   logic [31:0] adc_chn1_filter_ctl_3_qs;
184:   logic adc_chn1_filter_ctl_3_busy;
185:   logic adc_chn1_filter_ctl_4_we;
186:   logic [31:0] adc_chn1_filter_ctl_4_qs;
187:   logic adc_chn1_filter_ctl_4_busy;
188:   logic adc_chn1_filter_ctl_5_we;
189:   logic [31:0] adc_chn1_filter_ctl_5_qs;
190:   logic adc_chn1_filter_ctl_5_busy;
191:   logic adc_chn1_filter_ctl_6_we;
192:   logic [31:0] adc_chn1_filter_ctl_6_qs;
193:   logic adc_chn1_filter_ctl_6_busy;
194:   logic adc_chn1_filter_ctl_7_we;
195:   logic [31:0] adc_chn1_filter_ctl_7_qs;
196:   logic adc_chn1_filter_ctl_7_busy;
197:   logic [27:0] adc_chn_val_0_qs;
198:   logic adc_chn_val_0_busy;
199:   logic [27:0] adc_chn_val_1_qs;
200:   logic adc_chn_val_1_busy;
201:   logic adc_wakeup_ctl_we;
202:   logic [8:0] adc_wakeup_ctl_qs;
203:   logic adc_wakeup_ctl_busy;
204:   logic filter_status_we;
205:   logic [8:0] filter_status_qs;
206:   logic filter_status_busy;
207:   logic adc_intr_ctl_we;
208:   logic [7:0] adc_intr_ctl_match_en_qs;
209:   logic [7:0] adc_intr_ctl_match_en_wd;
210:   logic adc_intr_ctl_trans_en_qs;
211:   logic adc_intr_ctl_trans_en_wd;
212:   logic adc_intr_ctl_oneshot_en_qs;
213:   logic adc_intr_ctl_oneshot_en_wd;
214:   logic adc_intr_status_we;
215:   logic [7:0] adc_intr_status_match_qs;
216:   logic [7:0] adc_intr_status_match_wd;
217:   logic adc_intr_status_trans_qs;
218:   logic adc_intr_status_trans_wd;
219:   logic adc_intr_status_oneshot_qs;
220:   logic adc_intr_status_oneshot_wd;
221:   logic adc_fsm_state_re;
222:   logic [4:0] adc_fsm_state_qs;
223:   logic adc_fsm_state_busy;
224:   // Define register CDC handling.
225:   // CDC handling is done on a per-reg instead of per-field boundary.
226: 
227:   logic  aon_adc_en_ctl_adc_enable_qs_int;
228:   logic  aon_adc_en_ctl_oneshot_mode_qs_int;
229:   logic [1:0] aon_adc_en_ctl_qs;
230:   logic [1:0] aon_adc_en_ctl_wdata;
231:   logic aon_adc_en_ctl_we;
232:   logic unused_aon_adc_en_ctl_wdata;
233: 
234:   always_comb begin
235:     aon_adc_en_ctl_qs = 2'h0;
236:     aon_adc_en_ctl_qs[0] = aon_adc_en_ctl_adc_enable_qs_int;
237:     aon_adc_en_ctl_qs[1] = aon_adc_en_ctl_oneshot_mode_qs_int;
238:   end
239: 
240:   prim_reg_cdc #(
241:     .DataWidth(2),
242:     .ResetVal(2'h0),
243:     .BitMask(2'h3),
244:     .DstWrReq(0)
245:   ) u_adc_en_ctl_cdc (
246:     .clk_src_i    (clk_i),
247:     .rst_src_ni   (rst_ni),
248:     .clk_dst_i    (clk_aon_i),
249:     .rst_dst_ni   (rst_aon_ni),
250:     .src_regwen_i ('0),
251:     .src_we_i     (adc_en_ctl_we),
252:     .src_re_i     ('0),
253:     .src_wd_i     (reg_wdata[1:0]),
254:     .src_busy_o   (adc_en_ctl_busy),
255:     .src_qs_o     (adc_en_ctl_qs), // for software read back
256:     .dst_update_i ('0),
257:     .dst_ds_i     ('0),
258:     .dst_qs_i     (aon_adc_en_ctl_qs),
259:     .dst_we_o     (aon_adc_en_ctl_we),
260:     .dst_re_o     (),
261:     .dst_regwen_o (),
262:     .dst_wd_o     (aon_adc_en_ctl_wdata)
263:   );
264:   assign unused_aon_adc_en_ctl_wdata =
265:       ^aon_adc_en_ctl_wdata;
266: 
267:   logic  aon_adc_pd_ctl_lp_mode_qs_int;
268:   logic [3:0]  aon_adc_pd_ctl_pwrup_time_qs_int;
269:   logic [23:0]  aon_adc_pd_ctl_wakeup_time_qs_int;
270:   logic [31:0] aon_adc_pd_ctl_qs;
271:   logic [31:0] aon_adc_pd_ctl_wdata;
272:   logic aon_adc_pd_ctl_we;
273:   logic unused_aon_adc_pd_ctl_wdata;
274: 
275:   always_comb begin
276:     aon_adc_pd_ctl_qs = 32'h64070;
277:     aon_adc_pd_ctl_qs[0] = aon_adc_pd_ctl_lp_mode_qs_int;
278:     aon_adc_pd_ctl_qs[7:4] = aon_adc_pd_ctl_pwrup_time_qs_int;
279:     aon_adc_pd_ctl_qs[31:8] = aon_adc_pd_ctl_wakeup_time_qs_int;
280:   end
281: 
282:   prim_reg_cdc #(
283:     .DataWidth(32),
284:     .ResetVal(32'h64070),
285:     .BitMask(32'hfffffff1),
286:     .DstWrReq(0)
287:   ) u_adc_pd_ctl_cdc (
288:     .clk_src_i    (clk_i),
289:     .rst_src_ni   (rst_ni),
290:     .clk_dst_i    (clk_aon_i),
291:     .rst_dst_ni   (rst_aon_ni),
292:     .src_regwen_i ('0),
293:     .src_we_i     (adc_pd_ctl_we),
294:     .src_re_i     ('0),
295:     .src_wd_i     (reg_wdata[31:0]),
296:     .src_busy_o   (adc_pd_ctl_busy),
297:     .src_qs_o     (adc_pd_ctl_qs), // for software read back
298:     .dst_update_i ('0),
299:     .dst_ds_i     ('0),
300:     .dst_qs_i     (aon_adc_pd_ctl_qs),
301:     .dst_we_o     (aon_adc_pd_ctl_we),
302:     .dst_re_o     (),
303:     .dst_regwen_o (),
304:     .dst_wd_o     (aon_adc_pd_ctl_wdata)
305:   );
306:   assign unused_aon_adc_pd_ctl_wdata =
307:       ^aon_adc_pd_ctl_wdata;
308: 
309:   logic [7:0]  aon_adc_lp_sample_ctl_qs_int;
310:   logic [7:0] aon_adc_lp_sample_ctl_qs;
311:   logic [7:0] aon_adc_lp_sample_ctl_wdata;
312:   logic aon_adc_lp_sample_ctl_we;
313:   logic unused_aon_adc_lp_sample_ctl_wdata;
314: 
315:   always_comb begin
316:     aon_adc_lp_sample_ctl_qs = 8'h4;
317:     aon_adc_lp_sample_ctl_qs = aon_adc_lp_sample_ctl_qs_int;
318:   end
319: 
320:   prim_reg_cdc #(
321:     .DataWidth(8),
322:     .ResetVal(8'h4),
323:     .BitMask(8'hff),
324:     .DstWrReq(0)
325:   ) u_adc_lp_sample_ctl_cdc (
326:     .clk_src_i    (clk_i),
327:     .rst_src_ni   (rst_ni),
328:     .clk_dst_i    (clk_aon_i),
329:     .rst_dst_ni   (rst_aon_ni),
330:     .src_regwen_i ('0),
331:     .src_we_i     (adc_lp_sample_ctl_we),
332:     .src_re_i     ('0),
333:     .src_wd_i     (reg_wdata[7:0]),
334:     .src_busy_o   (adc_lp_sample_ctl_busy),
335:     .src_qs_o     (adc_lp_sample_ctl_qs), // for software read back
336:     .dst_update_i ('0),
337:     .dst_ds_i     ('0),
338:     .dst_qs_i     (aon_adc_lp_sample_ctl_qs),
339:     .dst_we_o     (aon_adc_lp_sample_ctl_we),
340:     .dst_re_o     (),
341:     .dst_regwen_o (),
342:     .dst_wd_o     (aon_adc_lp_sample_ctl_wdata)
343:   );
344:   assign unused_aon_adc_lp_sample_ctl_wdata =
345:       ^aon_adc_lp_sample_ctl_wdata;
346: 
347:   logic [15:0]  aon_adc_sample_ctl_qs_int;
348:   logic [15:0] aon_adc_sample_ctl_qs;
349:   logic [15:0] aon_adc_sample_ctl_wdata;
350:   logic aon_adc_sample_ctl_we;
351:   logic unused_aon_adc_sample_ctl_wdata;
352: 
353:   always_comb begin
354:     aon_adc_sample_ctl_qs = 16'h9b;
355:     aon_adc_sample_ctl_qs = aon_adc_sample_ctl_qs_int;
356:   end
357: 
358:   prim_reg_cdc #(
359:     .DataWidth(16),
360:     .ResetVal(16'h9b),
361:     .BitMask(16'hffff),
362:     .DstWrReq(0)
363:   ) u_adc_sample_ctl_cdc (
364:     .clk_src_i    (clk_i),
365:     .rst_src_ni   (rst_ni),
366:     .clk_dst_i    (clk_aon_i),
367:     .rst_dst_ni   (rst_aon_ni),
368:     .src_regwen_i ('0),
369:     .src_we_i     (adc_sample_ctl_we),
370:     .src_re_i     ('0),
371:     .src_wd_i     (reg_wdata[15:0]),
372:     .src_busy_o   (adc_sample_ctl_busy),
373:     .src_qs_o     (adc_sample_ctl_qs), // for software read back
374:     .dst_update_i ('0),
375:     .dst_ds_i     ('0),
376:     .dst_qs_i     (aon_adc_sample_ctl_qs),
377:     .dst_we_o     (aon_adc_sample_ctl_we),
378:     .dst_re_o     (),
379:     .dst_regwen_o (),
380:     .dst_wd_o     (aon_adc_sample_ctl_wdata)
381:   );
382:   assign unused_aon_adc_sample_ctl_wdata =
383:       ^aon_adc_sample_ctl_wdata;
384: 
385:   logic  aon_adc_fsm_rst_qs_int;
386:   logic [0:0] aon_adc_fsm_rst_qs;
387:   logic [0:0] aon_adc_fsm_rst_wdata;
388:   logic aon_adc_fsm_rst_we;
389:   logic unused_aon_adc_fsm_rst_wdata;
390: 
391:   always_comb begin
392:     aon_adc_fsm_rst_qs = 1'h0;
393:     aon_adc_fsm_rst_qs = aon_adc_fsm_rst_qs_int;
394:   end
395: 
396:   prim_reg_cdc #(
397:     .DataWidth(1),
398:     .ResetVal(1'h0),
399:     .BitMask(1'h1),
400:     .DstWrReq(0)
401:   ) u_adc_fsm_rst_cdc (
402:     .clk_src_i    (clk_i),
403:     .rst_src_ni   (rst_ni),
404:     .clk_dst_i    (clk_aon_i),
405:     .rst_dst_ni   (rst_aon_ni),
406:     .src_regwen_i ('0),
407:     .src_we_i     (adc_fsm_rst_we),
408:     .src_re_i     ('0),
409:     .src_wd_i     (reg_wdata[0:0]),
410:     .src_busy_o   (adc_fsm_rst_busy),
411:     .src_qs_o     (adc_fsm_rst_qs), // for software read back
412:     .dst_update_i ('0),
413:     .dst_ds_i     ('0),
414:     .dst_qs_i     (aon_adc_fsm_rst_qs),
415:     .dst_we_o     (aon_adc_fsm_rst_we),
416:     .dst_re_o     (),
417:     .dst_regwen_o (),
418:     .dst_wd_o     (aon_adc_fsm_rst_wdata)
419:   );
420:   assign unused_aon_adc_fsm_rst_wdata =
421:       ^aon_adc_fsm_rst_wdata;
422: 
423:   logic [9:0]  aon_adc_chn0_filter_ctl_0_min_v_0_qs_int;
424:   logic  aon_adc_chn0_filter_ctl_0_cond_0_qs_int;
425:   logic [9:0]  aon_adc_chn0_filter_ctl_0_max_v_0_qs_int;
426:   logic  aon_adc_chn0_filter_ctl_0_en_0_qs_int;
427:   logic [31:0] aon_adc_chn0_filter_ctl_0_qs;
428:   logic [31:0] aon_adc_chn0_filter_ctl_0_wdata;
429:   logic aon_adc_chn0_filter_ctl_0_we;
430:   logic unused_aon_adc_chn0_filter_ctl_0_wdata;
431: 
432:   always_comb begin
433:     aon_adc_chn0_filter_ctl_0_qs = 32'h0;
434:     aon_adc_chn0_filter_ctl_0_qs[11:2] = aon_adc_chn0_filter_ctl_0_min_v_0_qs_int;
435:     aon_adc_chn0_filter_ctl_0_qs[12] = aon_adc_chn0_filter_ctl_0_cond_0_qs_int;
436:     aon_adc_chn0_filter_ctl_0_qs[27:18] = aon_adc_chn0_filter_ctl_0_max_v_0_qs_int;
437:     aon_adc_chn0_filter_ctl_0_qs[31] = aon_adc_chn0_filter_ctl_0_en_0_qs_int;
438:   end
439: 
440:   prim_reg_cdc #(
441:     .DataWidth(32),
442:     .ResetVal(32'h0),
443:     .BitMask(32'h8ffc1ffc),
444:     .DstWrReq(0)
445:   ) u_adc_chn0_filter_ctl_0_cdc (
446:     .clk_src_i    (clk_i),
447:     .rst_src_ni   (rst_ni),
448:     .clk_dst_i    (clk_aon_i),
449:     .rst_dst_ni   (rst_aon_ni),
450:     .src_regwen_i ('0),
451:     .src_we_i     (adc_chn0_filter_ctl_0_we),
452:     .src_re_i     ('0),
453:     .src_wd_i     (reg_wdata[31:0]),
454:     .src_busy_o   (adc_chn0_filter_ctl_0_busy),
455:     .src_qs_o     (adc_chn0_filter_ctl_0_qs), // for software read back
456:     .dst_update_i ('0),
457:     .dst_ds_i     ('0),
458:     .dst_qs_i     (aon_adc_chn0_filter_ctl_0_qs),
459:     .dst_we_o     (aon_adc_chn0_filter_ctl_0_we),
460:     .dst_re_o     (),
461:     .dst_regwen_o (),
462:     .dst_wd_o     (aon_adc_chn0_filter_ctl_0_wdata)
463:   );
464:   assign unused_aon_adc_chn0_filter_ctl_0_wdata =
465:       ^aon_adc_chn0_filter_ctl_0_wdata;
466: 
467:   logic [9:0]  aon_adc_chn0_filter_ctl_1_min_v_1_qs_int;
468:   logic  aon_adc_chn0_filter_ctl_1_cond_1_qs_int;
469:   logic [9:0]  aon_adc_chn0_filter_ctl_1_max_v_1_qs_int;
470:   logic  aon_adc_chn0_filter_ctl_1_en_1_qs_int;
471:   logic [31:0] aon_adc_chn0_filter_ctl_1_qs;
472:   logic [31:0] aon_adc_chn0_filter_ctl_1_wdata;
473:   logic aon_adc_chn0_filter_ctl_1_we;
474:   logic unused_aon_adc_chn0_filter_ctl_1_wdata;
475: 
476:   always_comb begin
477:     aon_adc_chn0_filter_ctl_1_qs = 32'h0;
478:     aon_adc_chn0_filter_ctl_1_qs[11:2] = aon_adc_chn0_filter_ctl_1_min_v_1_qs_int;
479:     aon_adc_chn0_filter_ctl_1_qs[12] = aon_adc_chn0_filter_ctl_1_cond_1_qs_int;
480:     aon_adc_chn0_filter_ctl_1_qs[27:18] = aon_adc_chn0_filter_ctl_1_max_v_1_qs_int;
481:     aon_adc_chn0_filter_ctl_1_qs[31] = aon_adc_chn0_filter_ctl_1_en_1_qs_int;
482:   end
483: 
484:   prim_reg_cdc #(
485:     .DataWidth(32),
486:     .ResetVal(32'h0),
487:     .BitMask(32'h8ffc1ffc),
488:     .DstWrReq(0)
489:   ) u_adc_chn0_filter_ctl_1_cdc (
490:     .clk_src_i    (clk_i),
491:     .rst_src_ni   (rst_ni),
492:     .clk_dst_i    (clk_aon_i),
493:     .rst_dst_ni   (rst_aon_ni),
494:     .src_regwen_i ('0),
495:     .src_we_i     (adc_chn0_filter_ctl_1_we),
496:     .src_re_i     ('0),
497:     .src_wd_i     (reg_wdata[31:0]),
498:     .src_busy_o   (adc_chn0_filter_ctl_1_busy),
499:     .src_qs_o     (adc_chn0_filter_ctl_1_qs), // for software read back
500:     .dst_update_i ('0),
501:     .dst_ds_i     ('0),
502:     .dst_qs_i     (aon_adc_chn0_filter_ctl_1_qs),
503:     .dst_we_o     (aon_adc_chn0_filter_ctl_1_we),
504:     .dst_re_o     (),
505:     .dst_regwen_o (),
506:     .dst_wd_o     (aon_adc_chn0_filter_ctl_1_wdata)
507:   );
508:   assign unused_aon_adc_chn0_filter_ctl_1_wdata =
509:       ^aon_adc_chn0_filter_ctl_1_wdata;
510: 
511:   logic [9:0]  aon_adc_chn0_filter_ctl_2_min_v_2_qs_int;
512:   logic  aon_adc_chn0_filter_ctl_2_cond_2_qs_int;
513:   logic [9:0]  aon_adc_chn0_filter_ctl_2_max_v_2_qs_int;
514:   logic  aon_adc_chn0_filter_ctl_2_en_2_qs_int;
515:   logic [31:0] aon_adc_chn0_filter_ctl_2_qs;
516:   logic [31:0] aon_adc_chn0_filter_ctl_2_wdata;
517:   logic aon_adc_chn0_filter_ctl_2_we;
518:   logic unused_aon_adc_chn0_filter_ctl_2_wdata;
519: 
520:   always_comb begin
521:     aon_adc_chn0_filter_ctl_2_qs = 32'h0;
522:     aon_adc_chn0_filter_ctl_2_qs[11:2] = aon_adc_chn0_filter_ctl_2_min_v_2_qs_int;
523:     aon_adc_chn0_filter_ctl_2_qs[12] = aon_adc_chn0_filter_ctl_2_cond_2_qs_int;
524:     aon_adc_chn0_filter_ctl_2_qs[27:18] = aon_adc_chn0_filter_ctl_2_max_v_2_qs_int;
525:     aon_adc_chn0_filter_ctl_2_qs[31] = aon_adc_chn0_filter_ctl_2_en_2_qs_int;
526:   end
527: 
528:   prim_reg_cdc #(
529:     .DataWidth(32),
530:     .ResetVal(32'h0),
531:     .BitMask(32'h8ffc1ffc),
532:     .DstWrReq(0)
533:   ) u_adc_chn0_filter_ctl_2_cdc (
534:     .clk_src_i    (clk_i),
535:     .rst_src_ni   (rst_ni),
536:     .clk_dst_i    (clk_aon_i),
537:     .rst_dst_ni   (rst_aon_ni),
538:     .src_regwen_i ('0),
539:     .src_we_i     (adc_chn0_filter_ctl_2_we),
540:     .src_re_i     ('0),
541:     .src_wd_i     (reg_wdata[31:0]),
542:     .src_busy_o   (adc_chn0_filter_ctl_2_busy),
543:     .src_qs_o     (adc_chn0_filter_ctl_2_qs), // for software read back
544:     .dst_update_i ('0),
545:     .dst_ds_i     ('0),
546:     .dst_qs_i     (aon_adc_chn0_filter_ctl_2_qs),
547:     .dst_we_o     (aon_adc_chn0_filter_ctl_2_we),
548:     .dst_re_o     (),
549:     .dst_regwen_o (),
550:     .dst_wd_o     (aon_adc_chn0_filter_ctl_2_wdata)
551:   );
552:   assign unused_aon_adc_chn0_filter_ctl_2_wdata =
553:       ^aon_adc_chn0_filter_ctl_2_wdata;
554: 
555:   logic [9:0]  aon_adc_chn0_filter_ctl_3_min_v_3_qs_int;
556:   logic  aon_adc_chn0_filter_ctl_3_cond_3_qs_int;
557:   logic [9:0]  aon_adc_chn0_filter_ctl_3_max_v_3_qs_int;
558:   logic  aon_adc_chn0_filter_ctl_3_en_3_qs_int;
559:   logic [31:0] aon_adc_chn0_filter_ctl_3_qs;
560:   logic [31:0] aon_adc_chn0_filter_ctl_3_wdata;
561:   logic aon_adc_chn0_filter_ctl_3_we;
562:   logic unused_aon_adc_chn0_filter_ctl_3_wdata;
563: 
564:   always_comb begin
565:     aon_adc_chn0_filter_ctl_3_qs = 32'h0;
566:     aon_adc_chn0_filter_ctl_3_qs[11:2] = aon_adc_chn0_filter_ctl_3_min_v_3_qs_int;
567:     aon_adc_chn0_filter_ctl_3_qs[12] = aon_adc_chn0_filter_ctl_3_cond_3_qs_int;
568:     aon_adc_chn0_filter_ctl_3_qs[27:18] = aon_adc_chn0_filter_ctl_3_max_v_3_qs_int;
569:     aon_adc_chn0_filter_ctl_3_qs[31] = aon_adc_chn0_filter_ctl_3_en_3_qs_int;
570:   end
571: 
572:   prim_reg_cdc #(
573:     .DataWidth(32),
574:     .ResetVal(32'h0),
575:     .BitMask(32'h8ffc1ffc),
576:     .DstWrReq(0)
577:   ) u_adc_chn0_filter_ctl_3_cdc (
578:     .clk_src_i    (clk_i),
579:     .rst_src_ni   (rst_ni),
580:     .clk_dst_i    (clk_aon_i),
581:     .rst_dst_ni   (rst_aon_ni),
582:     .src_regwen_i ('0),
583:     .src_we_i     (adc_chn0_filter_ctl_3_we),
584:     .src_re_i     ('0),
585:     .src_wd_i     (reg_wdata[31:0]),
586:     .src_busy_o   (adc_chn0_filter_ctl_3_busy),
587:     .src_qs_o     (adc_chn0_filter_ctl_3_qs), // for software read back
588:     .dst_update_i ('0),
589:     .dst_ds_i     ('0),
590:     .dst_qs_i     (aon_adc_chn0_filter_ctl_3_qs),
591:     .dst_we_o     (aon_adc_chn0_filter_ctl_3_we),
592:     .dst_re_o     (),
593:     .dst_regwen_o (),
594:     .dst_wd_o     (aon_adc_chn0_filter_ctl_3_wdata)
595:   );
596:   assign unused_aon_adc_chn0_filter_ctl_3_wdata =
597:       ^aon_adc_chn0_filter_ctl_3_wdata;
598: 
599:   logic [9:0]  aon_adc_chn0_filter_ctl_4_min_v_4_qs_int;
600:   logic  aon_adc_chn0_filter_ctl_4_cond_4_qs_int;
601:   logic [9:0]  aon_adc_chn0_filter_ctl_4_max_v_4_qs_int;
602:   logic  aon_adc_chn0_filter_ctl_4_en_4_qs_int;
603:   logic [31:0] aon_adc_chn0_filter_ctl_4_qs;
604:   logic [31:0] aon_adc_chn0_filter_ctl_4_wdata;
605:   logic aon_adc_chn0_filter_ctl_4_we;
606:   logic unused_aon_adc_chn0_filter_ctl_4_wdata;
607: 
608:   always_comb begin
609:     aon_adc_chn0_filter_ctl_4_qs = 32'h0;
610:     aon_adc_chn0_filter_ctl_4_qs[11:2] = aon_adc_chn0_filter_ctl_4_min_v_4_qs_int;
611:     aon_adc_chn0_filter_ctl_4_qs[12] = aon_adc_chn0_filter_ctl_4_cond_4_qs_int;
612:     aon_adc_chn0_filter_ctl_4_qs[27:18] = aon_adc_chn0_filter_ctl_4_max_v_4_qs_int;
613:     aon_adc_chn0_filter_ctl_4_qs[31] = aon_adc_chn0_filter_ctl_4_en_4_qs_int;
614:   end
615: 
616:   prim_reg_cdc #(
617:     .DataWidth(32),
618:     .ResetVal(32'h0),
619:     .BitMask(32'h8ffc1ffc),
620:     .DstWrReq(0)
621:   ) u_adc_chn0_filter_ctl_4_cdc (
622:     .clk_src_i    (clk_i),
623:     .rst_src_ni   (rst_ni),
624:     .clk_dst_i    (clk_aon_i),
625:     .rst_dst_ni   (rst_aon_ni),
626:     .src_regwen_i ('0),
627:     .src_we_i     (adc_chn0_filter_ctl_4_we),
628:     .src_re_i     ('0),
629:     .src_wd_i     (reg_wdata[31:0]),
630:     .src_busy_o   (adc_chn0_filter_ctl_4_busy),
631:     .src_qs_o     (adc_chn0_filter_ctl_4_qs), // for software read back
632:     .dst_update_i ('0),
633:     .dst_ds_i     ('0),
634:     .dst_qs_i     (aon_adc_chn0_filter_ctl_4_qs),
635:     .dst_we_o     (aon_adc_chn0_filter_ctl_4_we),
636:     .dst_re_o     (),
637:     .dst_regwen_o (),
638:     .dst_wd_o     (aon_adc_chn0_filter_ctl_4_wdata)
639:   );
640:   assign unused_aon_adc_chn0_filter_ctl_4_wdata =
641:       ^aon_adc_chn0_filter_ctl_4_wdata;
642: 
643:   logic [9:0]  aon_adc_chn0_filter_ctl_5_min_v_5_qs_int;
644:   logic  aon_adc_chn0_filter_ctl_5_cond_5_qs_int;
645:   logic [9:0]  aon_adc_chn0_filter_ctl_5_max_v_5_qs_int;
646:   logic  aon_adc_chn0_filter_ctl_5_en_5_qs_int;
647:   logic [31:0] aon_adc_chn0_filter_ctl_5_qs;
648:   logic [31:0] aon_adc_chn0_filter_ctl_5_wdata;
649:   logic aon_adc_chn0_filter_ctl_5_we;
650:   logic unused_aon_adc_chn0_filter_ctl_5_wdata;
651: 
652:   always_comb begin
653:     aon_adc_chn0_filter_ctl_5_qs = 32'h0;
654:     aon_adc_chn0_filter_ctl_5_qs[11:2] = aon_adc_chn0_filter_ctl_5_min_v_5_qs_int;
655:     aon_adc_chn0_filter_ctl_5_qs[12] = aon_adc_chn0_filter_ctl_5_cond_5_qs_int;
656:     aon_adc_chn0_filter_ctl_5_qs[27:18] = aon_adc_chn0_filter_ctl_5_max_v_5_qs_int;
657:     aon_adc_chn0_filter_ctl_5_qs[31] = aon_adc_chn0_filter_ctl_5_en_5_qs_int;
658:   end
659: 
660:   prim_reg_cdc #(
661:     .DataWidth(32),
662:     .ResetVal(32'h0),
663:     .BitMask(32'h8ffc1ffc),
664:     .DstWrReq(0)
665:   ) u_adc_chn0_filter_ctl_5_cdc (
666:     .clk_src_i    (clk_i),
667:     .rst_src_ni   (rst_ni),
668:     .clk_dst_i    (clk_aon_i),
669:     .rst_dst_ni   (rst_aon_ni),
670:     .src_regwen_i ('0),
671:     .src_we_i     (adc_chn0_filter_ctl_5_we),
672:     .src_re_i     ('0),
673:     .src_wd_i     (reg_wdata[31:0]),
674:     .src_busy_o   (adc_chn0_filter_ctl_5_busy),
675:     .src_qs_o     (adc_chn0_filter_ctl_5_qs), // for software read back
676:     .dst_update_i ('0),
677:     .dst_ds_i     ('0),
678:     .dst_qs_i     (aon_adc_chn0_filter_ctl_5_qs),
679:     .dst_we_o     (aon_adc_chn0_filter_ctl_5_we),
680:     .dst_re_o     (),
681:     .dst_regwen_o (),
682:     .dst_wd_o     (aon_adc_chn0_filter_ctl_5_wdata)
683:   );
684:   assign unused_aon_adc_chn0_filter_ctl_5_wdata =
685:       ^aon_adc_chn0_filter_ctl_5_wdata;
686: 
687:   logic [9:0]  aon_adc_chn0_filter_ctl_6_min_v_6_qs_int;
688:   logic  aon_adc_chn0_filter_ctl_6_cond_6_qs_int;
689:   logic [9:0]  aon_adc_chn0_filter_ctl_6_max_v_6_qs_int;
690:   logic  aon_adc_chn0_filter_ctl_6_en_6_qs_int;
691:   logic [31:0] aon_adc_chn0_filter_ctl_6_qs;
692:   logic [31:0] aon_adc_chn0_filter_ctl_6_wdata;
693:   logic aon_adc_chn0_filter_ctl_6_we;
694:   logic unused_aon_adc_chn0_filter_ctl_6_wdata;
695: 
696:   always_comb begin
697:     aon_adc_chn0_filter_ctl_6_qs = 32'h0;
698:     aon_adc_chn0_filter_ctl_6_qs[11:2] = aon_adc_chn0_filter_ctl_6_min_v_6_qs_int;
699:     aon_adc_chn0_filter_ctl_6_qs[12] = aon_adc_chn0_filter_ctl_6_cond_6_qs_int;
700:     aon_adc_chn0_filter_ctl_6_qs[27:18] = aon_adc_chn0_filter_ctl_6_max_v_6_qs_int;
701:     aon_adc_chn0_filter_ctl_6_qs[31] = aon_adc_chn0_filter_ctl_6_en_6_qs_int;
702:   end
703: 
704:   prim_reg_cdc #(
705:     .DataWidth(32),
706:     .ResetVal(32'h0),
707:     .BitMask(32'h8ffc1ffc),
708:     .DstWrReq(0)
709:   ) u_adc_chn0_filter_ctl_6_cdc (
710:     .clk_src_i    (clk_i),
711:     .rst_src_ni   (rst_ni),
712:     .clk_dst_i    (clk_aon_i),
713:     .rst_dst_ni   (rst_aon_ni),
714:     .src_regwen_i ('0),
715:     .src_we_i     (adc_chn0_filter_ctl_6_we),
716:     .src_re_i     ('0),
717:     .src_wd_i     (reg_wdata[31:0]),
718:     .src_busy_o   (adc_chn0_filter_ctl_6_busy),
719:     .src_qs_o     (adc_chn0_filter_ctl_6_qs), // for software read back
720:     .dst_update_i ('0),
721:     .dst_ds_i     ('0),
722:     .dst_qs_i     (aon_adc_chn0_filter_ctl_6_qs),
723:     .dst_we_o     (aon_adc_chn0_filter_ctl_6_we),
724:     .dst_re_o     (),
725:     .dst_regwen_o (),
726:     .dst_wd_o     (aon_adc_chn0_filter_ctl_6_wdata)
727:   );
728:   assign unused_aon_adc_chn0_filter_ctl_6_wdata =
729:       ^aon_adc_chn0_filter_ctl_6_wdata;
730: 
731:   logic [9:0]  aon_adc_chn0_filter_ctl_7_min_v_7_qs_int;
732:   logic  aon_adc_chn0_filter_ctl_7_cond_7_qs_int;
733:   logic [9:0]  aon_adc_chn0_filter_ctl_7_max_v_7_qs_int;
734:   logic  aon_adc_chn0_filter_ctl_7_en_7_qs_int;
735:   logic [31:0] aon_adc_chn0_filter_ctl_7_qs;
736:   logic [31:0] aon_adc_chn0_filter_ctl_7_wdata;
737:   logic aon_adc_chn0_filter_ctl_7_we;
738:   logic unused_aon_adc_chn0_filter_ctl_7_wdata;
739: 
740:   always_comb begin
741:     aon_adc_chn0_filter_ctl_7_qs = 32'h0;
742:     aon_adc_chn0_filter_ctl_7_qs[11:2] = aon_adc_chn0_filter_ctl_7_min_v_7_qs_int;
743:     aon_adc_chn0_filter_ctl_7_qs[12] = aon_adc_chn0_filter_ctl_7_cond_7_qs_int;
744:     aon_adc_chn0_filter_ctl_7_qs[27:18] = aon_adc_chn0_filter_ctl_7_max_v_7_qs_int;
745:     aon_adc_chn0_filter_ctl_7_qs[31] = aon_adc_chn0_filter_ctl_7_en_7_qs_int;
746:   end
747: 
748:   prim_reg_cdc #(
749:     .DataWidth(32),
750:     .ResetVal(32'h0),
751:     .BitMask(32'h8ffc1ffc),
752:     .DstWrReq(0)
753:   ) u_adc_chn0_filter_ctl_7_cdc (
754:     .clk_src_i    (clk_i),
755:     .rst_src_ni   (rst_ni),
756:     .clk_dst_i    (clk_aon_i),
757:     .rst_dst_ni   (rst_aon_ni),
758:     .src_regwen_i ('0),
759:     .src_we_i     (adc_chn0_filter_ctl_7_we),
760:     .src_re_i     ('0),
761:     .src_wd_i     (reg_wdata[31:0]),
762:     .src_busy_o   (adc_chn0_filter_ctl_7_busy),
763:     .src_qs_o     (adc_chn0_filter_ctl_7_qs), // for software read back
764:     .dst_update_i ('0),
765:     .dst_ds_i     ('0),
766:     .dst_qs_i     (aon_adc_chn0_filter_ctl_7_qs),
767:     .dst_we_o     (aon_adc_chn0_filter_ctl_7_we),
768:     .dst_re_o     (),
769:     .dst_regwen_o (),
770:     .dst_wd_o     (aon_adc_chn0_filter_ctl_7_wdata)
771:   );
772:   assign unused_aon_adc_chn0_filter_ctl_7_wdata =
773:       ^aon_adc_chn0_filter_ctl_7_wdata;
774: 
775:   logic [9:0]  aon_adc_chn1_filter_ctl_0_min_v_0_qs_int;
776:   logic  aon_adc_chn1_filter_ctl_0_cond_0_qs_int;
777:   logic [9:0]  aon_adc_chn1_filter_ctl_0_max_v_0_qs_int;
778:   logic  aon_adc_chn1_filter_ctl_0_en_0_qs_int;
779:   logic [31:0] aon_adc_chn1_filter_ctl_0_qs;
780:   logic [31:0] aon_adc_chn1_filter_ctl_0_wdata;
781:   logic aon_adc_chn1_filter_ctl_0_we;
782:   logic unused_aon_adc_chn1_filter_ctl_0_wdata;
783: 
784:   always_comb begin
785:     aon_adc_chn1_filter_ctl_0_qs = 32'h0;
786:     aon_adc_chn1_filter_ctl_0_qs[11:2] = aon_adc_chn1_filter_ctl_0_min_v_0_qs_int;
787:     aon_adc_chn1_filter_ctl_0_qs[12] = aon_adc_chn1_filter_ctl_0_cond_0_qs_int;
788:     aon_adc_chn1_filter_ctl_0_qs[27:18] = aon_adc_chn1_filter_ctl_0_max_v_0_qs_int;
789:     aon_adc_chn1_filter_ctl_0_qs[31] = aon_adc_chn1_filter_ctl_0_en_0_qs_int;
790:   end
791: 
792:   prim_reg_cdc #(
793:     .DataWidth(32),
794:     .ResetVal(32'h0),
795:     .BitMask(32'h8ffc1ffc),
796:     .DstWrReq(0)
797:   ) u_adc_chn1_filter_ctl_0_cdc (
798:     .clk_src_i    (clk_i),
799:     .rst_src_ni   (rst_ni),
800:     .clk_dst_i    (clk_aon_i),
801:     .rst_dst_ni   (rst_aon_ni),
802:     .src_regwen_i ('0),
803:     .src_we_i     (adc_chn1_filter_ctl_0_we),
804:     .src_re_i     ('0),
805:     .src_wd_i     (reg_wdata[31:0]),
806:     .src_busy_o   (adc_chn1_filter_ctl_0_busy),
807:     .src_qs_o     (adc_chn1_filter_ctl_0_qs), // for software read back
808:     .dst_update_i ('0),
809:     .dst_ds_i     ('0),
810:     .dst_qs_i     (aon_adc_chn1_filter_ctl_0_qs),
811:     .dst_we_o     (aon_adc_chn1_filter_ctl_0_we),
812:     .dst_re_o     (),
813:     .dst_regwen_o (),
814:     .dst_wd_o     (aon_adc_chn1_filter_ctl_0_wdata)
815:   );
816:   assign unused_aon_adc_chn1_filter_ctl_0_wdata =
817:       ^aon_adc_chn1_filter_ctl_0_wdata;
818: 
819:   logic [9:0]  aon_adc_chn1_filter_ctl_1_min_v_1_qs_int;
820:   logic  aon_adc_chn1_filter_ctl_1_cond_1_qs_int;
821:   logic [9:0]  aon_adc_chn1_filter_ctl_1_max_v_1_qs_int;
822:   logic  aon_adc_chn1_filter_ctl_1_en_1_qs_int;
823:   logic [31:0] aon_adc_chn1_filter_ctl_1_qs;
824:   logic [31:0] aon_adc_chn1_filter_ctl_1_wdata;
825:   logic aon_adc_chn1_filter_ctl_1_we;
826:   logic unused_aon_adc_chn1_filter_ctl_1_wdata;
827: 
828:   always_comb begin
829:     aon_adc_chn1_filter_ctl_1_qs = 32'h0;
830:     aon_adc_chn1_filter_ctl_1_qs[11:2] = aon_adc_chn1_filter_ctl_1_min_v_1_qs_int;
831:     aon_adc_chn1_filter_ctl_1_qs[12] = aon_adc_chn1_filter_ctl_1_cond_1_qs_int;
832:     aon_adc_chn1_filter_ctl_1_qs[27:18] = aon_adc_chn1_filter_ctl_1_max_v_1_qs_int;
833:     aon_adc_chn1_filter_ctl_1_qs[31] = aon_adc_chn1_filter_ctl_1_en_1_qs_int;
834:   end
835: 
836:   prim_reg_cdc #(
837:     .DataWidth(32),
838:     .ResetVal(32'h0),
839:     .BitMask(32'h8ffc1ffc),
840:     .DstWrReq(0)
841:   ) u_adc_chn1_filter_ctl_1_cdc (
842:     .clk_src_i    (clk_i),
843:     .rst_src_ni   (rst_ni),
844:     .clk_dst_i    (clk_aon_i),
845:     .rst_dst_ni   (rst_aon_ni),
846:     .src_regwen_i ('0),
847:     .src_we_i     (adc_chn1_filter_ctl_1_we),
848:     .src_re_i     ('0),
849:     .src_wd_i     (reg_wdata[31:0]),
850:     .src_busy_o   (adc_chn1_filter_ctl_1_busy),
851:     .src_qs_o     (adc_chn1_filter_ctl_1_qs), // for software read back
852:     .dst_update_i ('0),
853:     .dst_ds_i     ('0),
854:     .dst_qs_i     (aon_adc_chn1_filter_ctl_1_qs),
855:     .dst_we_o     (aon_adc_chn1_filter_ctl_1_we),
856:     .dst_re_o     (),
857:     .dst_regwen_o (),
858:     .dst_wd_o     (aon_adc_chn1_filter_ctl_1_wdata)
859:   );
860:   assign unused_aon_adc_chn1_filter_ctl_1_wdata =
861:       ^aon_adc_chn1_filter_ctl_1_wdata;
862: 
863:   logic [9:0]  aon_adc_chn1_filter_ctl_2_min_v_2_qs_int;
864:   logic  aon_adc_chn1_filter_ctl_2_cond_2_qs_int;
865:   logic [9:0]  aon_adc_chn1_filter_ctl_2_max_v_2_qs_int;
866:   logic  aon_adc_chn1_filter_ctl_2_en_2_qs_int;
867:   logic [31:0] aon_adc_chn1_filter_ctl_2_qs;
868:   logic [31:0] aon_adc_chn1_filter_ctl_2_wdata;
869:   logic aon_adc_chn1_filter_ctl_2_we;
870:   logic unused_aon_adc_chn1_filter_ctl_2_wdata;
871: 
872:   always_comb begin
873:     aon_adc_chn1_filter_ctl_2_qs = 32'h0;
874:     aon_adc_chn1_filter_ctl_2_qs[11:2] = aon_adc_chn1_filter_ctl_2_min_v_2_qs_int;
875:     aon_adc_chn1_filter_ctl_2_qs[12] = aon_adc_chn1_filter_ctl_2_cond_2_qs_int;
876:     aon_adc_chn1_filter_ctl_2_qs[27:18] = aon_adc_chn1_filter_ctl_2_max_v_2_qs_int;
877:     aon_adc_chn1_filter_ctl_2_qs[31] = aon_adc_chn1_filter_ctl_2_en_2_qs_int;
878:   end
879: 
880:   prim_reg_cdc #(
881:     .DataWidth(32),
882:     .ResetVal(32'h0),
883:     .BitMask(32'h8ffc1ffc),
884:     .DstWrReq(0)
885:   ) u_adc_chn1_filter_ctl_2_cdc (
886:     .clk_src_i    (clk_i),
887:     .rst_src_ni   (rst_ni),
888:     .clk_dst_i    (clk_aon_i),
889:     .rst_dst_ni   (rst_aon_ni),
890:     .src_regwen_i ('0),
891:     .src_we_i     (adc_chn1_filter_ctl_2_we),
892:     .src_re_i     ('0),
893:     .src_wd_i     (reg_wdata[31:0]),
894:     .src_busy_o   (adc_chn1_filter_ctl_2_busy),
895:     .src_qs_o     (adc_chn1_filter_ctl_2_qs), // for software read back
896:     .dst_update_i ('0),
897:     .dst_ds_i     ('0),
898:     .dst_qs_i     (aon_adc_chn1_filter_ctl_2_qs),
899:     .dst_we_o     (aon_adc_chn1_filter_ctl_2_we),
900:     .dst_re_o     (),
901:     .dst_regwen_o (),
902:     .dst_wd_o     (aon_adc_chn1_filter_ctl_2_wdata)
903:   );
904:   assign unused_aon_adc_chn1_filter_ctl_2_wdata =
905:       ^aon_adc_chn1_filter_ctl_2_wdata;
906: 
907:   logic [9:0]  aon_adc_chn1_filter_ctl_3_min_v_3_qs_int;
908:   logic  aon_adc_chn1_filter_ctl_3_cond_3_qs_int;
909:   logic [9:0]  aon_adc_chn1_filter_ctl_3_max_v_3_qs_int;
910:   logic  aon_adc_chn1_filter_ctl_3_en_3_qs_int;
911:   logic [31:0] aon_adc_chn1_filter_ctl_3_qs;
912:   logic [31:0] aon_adc_chn1_filter_ctl_3_wdata;
913:   logic aon_adc_chn1_filter_ctl_3_we;
914:   logic unused_aon_adc_chn1_filter_ctl_3_wdata;
915: 
916:   always_comb begin
917:     aon_adc_chn1_filter_ctl_3_qs = 32'h0;
918:     aon_adc_chn1_filter_ctl_3_qs[11:2] = aon_adc_chn1_filter_ctl_3_min_v_3_qs_int;
919:     aon_adc_chn1_filter_ctl_3_qs[12] = aon_adc_chn1_filter_ctl_3_cond_3_qs_int;
920:     aon_adc_chn1_filter_ctl_3_qs[27:18] = aon_adc_chn1_filter_ctl_3_max_v_3_qs_int;
921:     aon_adc_chn1_filter_ctl_3_qs[31] = aon_adc_chn1_filter_ctl_3_en_3_qs_int;
922:   end
923: 
924:   prim_reg_cdc #(
925:     .DataWidth(32),
926:     .ResetVal(32'h0),
927:     .BitMask(32'h8ffc1ffc),
928:     .DstWrReq(0)
929:   ) u_adc_chn1_filter_ctl_3_cdc (
930:     .clk_src_i    (clk_i),
931:     .rst_src_ni   (rst_ni),
932:     .clk_dst_i    (clk_aon_i),
933:     .rst_dst_ni   (rst_aon_ni),
934:     .src_regwen_i ('0),
935:     .src_we_i     (adc_chn1_filter_ctl_3_we),
936:     .src_re_i     ('0),
937:     .src_wd_i     (reg_wdata[31:0]),
938:     .src_busy_o   (adc_chn1_filter_ctl_3_busy),
939:     .src_qs_o     (adc_chn1_filter_ctl_3_qs), // for software read back
940:     .dst_update_i ('0),
941:     .dst_ds_i     ('0),
942:     .dst_qs_i     (aon_adc_chn1_filter_ctl_3_qs),
943:     .dst_we_o     (aon_adc_chn1_filter_ctl_3_we),
944:     .dst_re_o     (),
945:     .dst_regwen_o (),
946:     .dst_wd_o     (aon_adc_chn1_filter_ctl_3_wdata)
947:   );
948:   assign unused_aon_adc_chn1_filter_ctl_3_wdata =
949:       ^aon_adc_chn1_filter_ctl_3_wdata;
950: 
951:   logic [9:0]  aon_adc_chn1_filter_ctl_4_min_v_4_qs_int;
952:   logic  aon_adc_chn1_filter_ctl_4_cond_4_qs_int;
953:   logic [9:0]  aon_adc_chn1_filter_ctl_4_max_v_4_qs_int;
954:   logic  aon_adc_chn1_filter_ctl_4_en_4_qs_int;
955:   logic [31:0] aon_adc_chn1_filter_ctl_4_qs;
956:   logic [31:0] aon_adc_chn1_filter_ctl_4_wdata;
957:   logic aon_adc_chn1_filter_ctl_4_we;
958:   logic unused_aon_adc_chn1_filter_ctl_4_wdata;
959: 
960:   always_comb begin
961:     aon_adc_chn1_filter_ctl_4_qs = 32'h0;
962:     aon_adc_chn1_filter_ctl_4_qs[11:2] = aon_adc_chn1_filter_ctl_4_min_v_4_qs_int;
963:     aon_adc_chn1_filter_ctl_4_qs[12] = aon_adc_chn1_filter_ctl_4_cond_4_qs_int;
964:     aon_adc_chn1_filter_ctl_4_qs[27:18] = aon_adc_chn1_filter_ctl_4_max_v_4_qs_int;
965:     aon_adc_chn1_filter_ctl_4_qs[31] = aon_adc_chn1_filter_ctl_4_en_4_qs_int;
966:   end
967: 
968:   prim_reg_cdc #(
969:     .DataWidth(32),
970:     .ResetVal(32'h0),
971:     .BitMask(32'h8ffc1ffc),
972:     .DstWrReq(0)
973:   ) u_adc_chn1_filter_ctl_4_cdc (
974:     .clk_src_i    (clk_i),
975:     .rst_src_ni   (rst_ni),
976:     .clk_dst_i    (clk_aon_i),
977:     .rst_dst_ni   (rst_aon_ni),
978:     .src_regwen_i ('0),
979:     .src_we_i     (adc_chn1_filter_ctl_4_we),
980:     .src_re_i     ('0),
981:     .src_wd_i     (reg_wdata[31:0]),
982:     .src_busy_o   (adc_chn1_filter_ctl_4_busy),
983:     .src_qs_o     (adc_chn1_filter_ctl_4_qs), // for software read back
984:     .dst_update_i ('0),
985:     .dst_ds_i     ('0),
986:     .dst_qs_i     (aon_adc_chn1_filter_ctl_4_qs),
987:     .dst_we_o     (aon_adc_chn1_filter_ctl_4_we),
988:     .dst_re_o     (),
989:     .dst_regwen_o (),
990:     .dst_wd_o     (aon_adc_chn1_filter_ctl_4_wdata)
991:   );
992:   assign unused_aon_adc_chn1_filter_ctl_4_wdata =
993:       ^aon_adc_chn1_filter_ctl_4_wdata;
994: 
995:   logic [9:0]  aon_adc_chn1_filter_ctl_5_min_v_5_qs_int;
996:   logic  aon_adc_chn1_filter_ctl_5_cond_5_qs_int;
997:   logic [9:0]  aon_adc_chn1_filter_ctl_5_max_v_5_qs_int;
998:   logic  aon_adc_chn1_filter_ctl_5_en_5_qs_int;
999:   logic [31:0] aon_adc_chn1_filter_ctl_5_qs;
1000:   logic [31:0] aon_adc_chn1_filter_ctl_5_wdata;
1001:   logic aon_adc_chn1_filter_ctl_5_we;
1002:   logic unused_aon_adc_chn1_filter_ctl_5_wdata;
1003: 
1004:   always_comb begin
1005:     aon_adc_chn1_filter_ctl_5_qs = 32'h0;
1006:     aon_adc_chn1_filter_ctl_5_qs[11:2] = aon_adc_chn1_filter_ctl_5_min_v_5_qs_int;
1007:     aon_adc_chn1_filter_ctl_5_qs[12] = aon_adc_chn1_filter_ctl_5_cond_5_qs_int;
1008:     aon_adc_chn1_filter_ctl_5_qs[27:18] = aon_adc_chn1_filter_ctl_5_max_v_5_qs_int;
1009:     aon_adc_chn1_filter_ctl_5_qs[31] = aon_adc_chn1_filter_ctl_5_en_5_qs_int;
1010:   end
1011: 
1012:   prim_reg_cdc #(
1013:     .DataWidth(32),
1014:     .ResetVal(32'h0),
1015:     .BitMask(32'h8ffc1ffc),
1016:     .DstWrReq(0)
1017:   ) u_adc_chn1_filter_ctl_5_cdc (
1018:     .clk_src_i    (clk_i),
1019:     .rst_src_ni   (rst_ni),
1020:     .clk_dst_i    (clk_aon_i),
1021:     .rst_dst_ni   (rst_aon_ni),
1022:     .src_regwen_i ('0),
1023:     .src_we_i     (adc_chn1_filter_ctl_5_we),
1024:     .src_re_i     ('0),
1025:     .src_wd_i     (reg_wdata[31:0]),
1026:     .src_busy_o   (adc_chn1_filter_ctl_5_busy),
1027:     .src_qs_o     (adc_chn1_filter_ctl_5_qs), // for software read back
1028:     .dst_update_i ('0),
1029:     .dst_ds_i     ('0),
1030:     .dst_qs_i     (aon_adc_chn1_filter_ctl_5_qs),
1031:     .dst_we_o     (aon_adc_chn1_filter_ctl_5_we),
1032:     .dst_re_o     (),
1033:     .dst_regwen_o (),
1034:     .dst_wd_o     (aon_adc_chn1_filter_ctl_5_wdata)
1035:   );
1036:   assign unused_aon_adc_chn1_filter_ctl_5_wdata =
1037:       ^aon_adc_chn1_filter_ctl_5_wdata;
1038: 
1039:   logic [9:0]  aon_adc_chn1_filter_ctl_6_min_v_6_qs_int;
1040:   logic  aon_adc_chn1_filter_ctl_6_cond_6_qs_int;
1041:   logic [9:0]  aon_adc_chn1_filter_ctl_6_max_v_6_qs_int;
1042:   logic  aon_adc_chn1_filter_ctl_6_en_6_qs_int;
1043:   logic [31:0] aon_adc_chn1_filter_ctl_6_qs;
1044:   logic [31:0] aon_adc_chn1_filter_ctl_6_wdata;
1045:   logic aon_adc_chn1_filter_ctl_6_we;
1046:   logic unused_aon_adc_chn1_filter_ctl_6_wdata;
1047: 
1048:   always_comb begin
1049:     aon_adc_chn1_filter_ctl_6_qs = 32'h0;
1050:     aon_adc_chn1_filter_ctl_6_qs[11:2] = aon_adc_chn1_filter_ctl_6_min_v_6_qs_int;
1051:     aon_adc_chn1_filter_ctl_6_qs[12] = aon_adc_chn1_filter_ctl_6_cond_6_qs_int;
1052:     aon_adc_chn1_filter_ctl_6_qs[27:18] = aon_adc_chn1_filter_ctl_6_max_v_6_qs_int;
1053:     aon_adc_chn1_filter_ctl_6_qs[31] = aon_adc_chn1_filter_ctl_6_en_6_qs_int;
1054:   end
1055: 
1056:   prim_reg_cdc #(
1057:     .DataWidth(32),
1058:     .ResetVal(32'h0),
1059:     .BitMask(32'h8ffc1ffc),
1060:     .DstWrReq(0)
1061:   ) u_adc_chn1_filter_ctl_6_cdc (
1062:     .clk_src_i    (clk_i),
1063:     .rst_src_ni   (rst_ni),
1064:     .clk_dst_i    (clk_aon_i),
1065:     .rst_dst_ni   (rst_aon_ni),
1066:     .src_regwen_i ('0),
1067:     .src_we_i     (adc_chn1_filter_ctl_6_we),
1068:     .src_re_i     ('0),
1069:     .src_wd_i     (reg_wdata[31:0]),
1070:     .src_busy_o   (adc_chn1_filter_ctl_6_busy),
1071:     .src_qs_o     (adc_chn1_filter_ctl_6_qs), // for software read back
1072:     .dst_update_i ('0),
1073:     .dst_ds_i     ('0),
1074:     .dst_qs_i     (aon_adc_chn1_filter_ctl_6_qs),
1075:     .dst_we_o     (aon_adc_chn1_filter_ctl_6_we),
1076:     .dst_re_o     (),
1077:     .dst_regwen_o (),
1078:     .dst_wd_o     (aon_adc_chn1_filter_ctl_6_wdata)
1079:   );
1080:   assign unused_aon_adc_chn1_filter_ctl_6_wdata =
1081:       ^aon_adc_chn1_filter_ctl_6_wdata;
1082: 
1083:   logic [9:0]  aon_adc_chn1_filter_ctl_7_min_v_7_qs_int;
1084:   logic  aon_adc_chn1_filter_ctl_7_cond_7_qs_int;
1085:   logic [9:0]  aon_adc_chn1_filter_ctl_7_max_v_7_qs_int;
1086:   logic  aon_adc_chn1_filter_ctl_7_en_7_qs_int;
1087:   logic [31:0] aon_adc_chn1_filter_ctl_7_qs;
1088:   logic [31:0] aon_adc_chn1_filter_ctl_7_wdata;
1089:   logic aon_adc_chn1_filter_ctl_7_we;
1090:   logic unused_aon_adc_chn1_filter_ctl_7_wdata;
1091: 
1092:   always_comb begin
1093:     aon_adc_chn1_filter_ctl_7_qs = 32'h0;
1094:     aon_adc_chn1_filter_ctl_7_qs[11:2] = aon_adc_chn1_filter_ctl_7_min_v_7_qs_int;
1095:     aon_adc_chn1_filter_ctl_7_qs[12] = aon_adc_chn1_filter_ctl_7_cond_7_qs_int;
1096:     aon_adc_chn1_filter_ctl_7_qs[27:18] = aon_adc_chn1_filter_ctl_7_max_v_7_qs_int;
1097:     aon_adc_chn1_filter_ctl_7_qs[31] = aon_adc_chn1_filter_ctl_7_en_7_qs_int;
1098:   end
1099: 
1100:   prim_reg_cdc #(
1101:     .DataWidth(32),
1102:     .ResetVal(32'h0),
1103:     .BitMask(32'h8ffc1ffc),
1104:     .DstWrReq(0)
1105:   ) u_adc_chn1_filter_ctl_7_cdc (
1106:     .clk_src_i    (clk_i),
1107:     .rst_src_ni   (rst_ni),
1108:     .clk_dst_i    (clk_aon_i),
1109:     .rst_dst_ni   (rst_aon_ni),
1110:     .src_regwen_i ('0),
1111:     .src_we_i     (adc_chn1_filter_ctl_7_we),
1112:     .src_re_i     ('0),
1113:     .src_wd_i     (reg_wdata[31:0]),
1114:     .src_busy_o   (adc_chn1_filter_ctl_7_busy),
1115:     .src_qs_o     (adc_chn1_filter_ctl_7_qs), // for software read back
1116:     .dst_update_i ('0),
1117:     .dst_ds_i     ('0),
1118:     .dst_qs_i     (aon_adc_chn1_filter_ctl_7_qs),
1119:     .dst_we_o     (aon_adc_chn1_filter_ctl_7_we),
1120:     .dst_re_o     (),
1121:     .dst_regwen_o (),
1122:     .dst_wd_o     (aon_adc_chn1_filter_ctl_7_wdata)
1123:   );
1124:   assign unused_aon_adc_chn1_filter_ctl_7_wdata =
1125:       ^aon_adc_chn1_filter_ctl_7_wdata;
1126: 
1127:   logic [1:0]  aon_adc_chn_val_0_adc_chn_value_ext_0_ds_int;
1128:   logic [1:0]  aon_adc_chn_val_0_adc_chn_value_ext_0_qs_int;
1129:   logic [9:0]  aon_adc_chn_val_0_adc_chn_value_0_ds_int;
1130:   logic [9:0]  aon_adc_chn_val_0_adc_chn_value_0_qs_int;
1131:   logic [1:0]  aon_adc_chn_val_0_adc_chn_value_intr_ext_0_ds_int;
1132:   logic [1:0]  aon_adc_chn_val_0_adc_chn_value_intr_ext_0_qs_int;
1133:   logic [9:0]  aon_adc_chn_val_0_adc_chn_value_intr_0_ds_int;
1134:   logic [9:0]  aon_adc_chn_val_0_adc_chn_value_intr_0_qs_int;
1135:   logic [27:0] aon_adc_chn_val_0_ds;
1136:   logic aon_adc_chn_val_0_qe;
1137:   logic [27:0] aon_adc_chn_val_0_qs;
1138: 
1139:   always_comb begin
1140:     aon_adc_chn_val_0_qs = 28'h0;
1141:     aon_adc_chn_val_0_ds = 28'h0;
1142:     aon_adc_chn_val_0_ds[1:0] = aon_adc_chn_val_0_adc_chn_value_ext_0_ds_int;
1143:     aon_adc_chn_val_0_qs[1:0] = aon_adc_chn_val_0_adc_chn_value_ext_0_qs_int;
1144:     aon_adc_chn_val_0_ds[11:2] = aon_adc_chn_val_0_adc_chn_value_0_ds_int;
1145:     aon_adc_chn_val_0_qs[11:2] = aon_adc_chn_val_0_adc_chn_value_0_qs_int;
1146:     aon_adc_chn_val_0_ds[17:16] = aon_adc_chn_val_0_adc_chn_value_intr_ext_0_ds_int;
1147:     aon_adc_chn_val_0_qs[17:16] = aon_adc_chn_val_0_adc_chn_value_intr_ext_0_qs_int;
1148:     aon_adc_chn_val_0_ds[27:18] = aon_adc_chn_val_0_adc_chn_value_intr_0_ds_int;
1149:     aon_adc_chn_val_0_qs[27:18] = aon_adc_chn_val_0_adc_chn_value_intr_0_qs_int;
1150:   end
1151: 
1152:   prim_reg_cdc #(
1153:     .DataWidth(28),
1154:     .ResetVal(28'h0),
1155:     .BitMask(28'hfff0fff),
1156:     .DstWrReq(1)
1157:   ) u_adc_chn_val_0_cdc (
1158:     .clk_src_i    (clk_i),
1159:     .rst_src_ni   (rst_ni),
1160:     .clk_dst_i    (clk_aon_i),
1161:     .rst_dst_ni   (rst_aon_ni),
1162:     .src_regwen_i ('0),
1163:     .src_we_i     ('0),
1164:     .src_re_i     ('0),
1165:     .src_wd_i     ('0),
1166:     .src_busy_o   (adc_chn_val_0_busy),
1167:     .src_qs_o     (adc_chn_val_0_qs), // for software read back
1168:     .dst_update_i (aon_adc_chn_val_0_qe),
1169:     .dst_ds_i     (aon_adc_chn_val_0_ds),
1170:     .dst_qs_i     (aon_adc_chn_val_0_qs),
1171:     .dst_we_o     (),
1172:     .dst_re_o     (),
1173:     .dst_regwen_o (),
1174:     .dst_wd_o     ()
1175:   );
1176: 
1177:   logic [1:0]  aon_adc_chn_val_1_adc_chn_value_ext_1_ds_int;
1178:   logic [1:0]  aon_adc_chn_val_1_adc_chn_value_ext_1_qs_int;
1179:   logic [9:0]  aon_adc_chn_val_1_adc_chn_value_1_ds_int;
1180:   logic [9:0]  aon_adc_chn_val_1_adc_chn_value_1_qs_int;
1181:   logic [1:0]  aon_adc_chn_val_1_adc_chn_value_intr_ext_1_ds_int;
1182:   logic [1:0]  aon_adc_chn_val_1_adc_chn_value_intr_ext_1_qs_int;
1183:   logic [9:0]  aon_adc_chn_val_1_adc_chn_value_intr_1_ds_int;
1184:   logic [9:0]  aon_adc_chn_val_1_adc_chn_value_intr_1_qs_int;
1185:   logic [27:0] aon_adc_chn_val_1_ds;
1186:   logic aon_adc_chn_val_1_qe;
1187:   logic [27:0] aon_adc_chn_val_1_qs;
1188: 
1189:   always_comb begin
1190:     aon_adc_chn_val_1_qs = 28'h0;
1191:     aon_adc_chn_val_1_ds = 28'h0;
1192:     aon_adc_chn_val_1_ds[1:0] = aon_adc_chn_val_1_adc_chn_value_ext_1_ds_int;
1193:     aon_adc_chn_val_1_qs[1:0] = aon_adc_chn_val_1_adc_chn_value_ext_1_qs_int;
1194:     aon_adc_chn_val_1_ds[11:2] = aon_adc_chn_val_1_adc_chn_value_1_ds_int;
1195:     aon_adc_chn_val_1_qs[11:2] = aon_adc_chn_val_1_adc_chn_value_1_qs_int;
1196:     aon_adc_chn_val_1_ds[17:16] = aon_adc_chn_val_1_adc_chn_value_intr_ext_1_ds_int;
1197:     aon_adc_chn_val_1_qs[17:16] = aon_adc_chn_val_1_adc_chn_value_intr_ext_1_qs_int;
1198:     aon_adc_chn_val_1_ds[27:18] = aon_adc_chn_val_1_adc_chn_value_intr_1_ds_int;
1199:     aon_adc_chn_val_1_qs[27:18] = aon_adc_chn_val_1_adc_chn_value_intr_1_qs_int;
1200:   end
1201: 
1202:   prim_reg_cdc #(
1203:     .DataWidth(28),
1204:     .ResetVal(28'h0),
1205:     .BitMask(28'hfff0fff),
1206:     .DstWrReq(1)
1207:   ) u_adc_chn_val_1_cdc (
1208:     .clk_src_i    (clk_i),
1209:     .rst_src_ni   (rst_ni),
1210:     .clk_dst_i    (clk_aon_i),
1211:     .rst_dst_ni   (rst_aon_ni),
1212:     .src_regwen_i ('0),
1213:     .src_we_i     ('0),
1214:     .src_re_i     ('0),
1215:     .src_wd_i     ('0),
1216:     .src_busy_o   (adc_chn_val_1_busy),
1217:     .src_qs_o     (adc_chn_val_1_qs), // for software read back
1218:     .dst_update_i (aon_adc_chn_val_1_qe),
1219:     .dst_ds_i     (aon_adc_chn_val_1_ds),
1220:     .dst_qs_i     (aon_adc_chn_val_1_qs),
1221:     .dst_we_o     (),
1222:     .dst_re_o     (),
1223:     .dst_regwen_o (),
1224:     .dst_wd_o     ()
1225:   );
1226: 
1227:   logic [7:0]  aon_adc_wakeup_ctl_match_en_qs_int;
1228:   logic  aon_adc_wakeup_ctl_trans_en_qs_int;
1229:   logic [8:0] aon_adc_wakeup_ctl_qs;
1230:   logic [8:0] aon_adc_wakeup_ctl_wdata;
1231:   logic aon_adc_wakeup_ctl_we;
1232:   logic unused_aon_adc_wakeup_ctl_wdata;
1233: 
1234:   always_comb begin
1235:     aon_adc_wakeup_ctl_qs = 9'h0;
1236:     aon_adc_wakeup_ctl_qs[7:0] = aon_adc_wakeup_ctl_match_en_qs_int;
1237:     aon_adc_wakeup_ctl_qs[8] = aon_adc_wakeup_ctl_trans_en_qs_int;
1238:   end
1239: 
1240:   prim_reg_cdc #(
1241:     .DataWidth(9),
1242:     .ResetVal(9'h0),
1243:     .BitMask(9'h1ff),
1244:     .DstWrReq(0)
1245:   ) u_adc_wakeup_ctl_cdc (
1246:     .clk_src_i    (clk_i),
1247:     .rst_src_ni   (rst_ni),
1248:     .clk_dst_i    (clk_aon_i),
1249:     .rst_dst_ni   (rst_aon_ni),
1250:     .src_regwen_i ('0),
1251:     .src_we_i     (adc_wakeup_ctl_we),
1252:     .src_re_i     ('0),
1253:     .src_wd_i     (reg_wdata[8:0]),
1254:     .src_busy_o   (adc_wakeup_ctl_busy),
1255:     .src_qs_o     (adc_wakeup_ctl_qs), // for software read back
1256:     .dst_update_i ('0),
1257:     .dst_ds_i     ('0),
1258:     .dst_qs_i     (aon_adc_wakeup_ctl_qs),
1259:     .dst_we_o     (aon_adc_wakeup_ctl_we),
1260:     .dst_re_o     (),
1261:     .dst_regwen_o (),
1262:     .dst_wd_o     (aon_adc_wakeup_ctl_wdata)
1263:   );
1264:   assign unused_aon_adc_wakeup_ctl_wdata =
1265:       ^aon_adc_wakeup_ctl_wdata;
1266: 
1267:   logic [7:0]  aon_filter_status_match_ds_int;
1268:   logic [7:0]  aon_filter_status_match_qs_int;
1269:   logic  aon_filter_status_trans_ds_int;
1270:   logic  aon_filter_status_trans_qs_int;
1271:   logic [8:0] aon_filter_status_ds;
1272:   logic aon_filter_status_qe;
1273:   logic [8:0] aon_filter_status_qs;
1274:   logic [8:0] aon_filter_status_wdata;
1275:   logic aon_filter_status_we;
1276:   logic unused_aon_filter_status_wdata;
1277: 
1278:   always_comb begin
1279:     aon_filter_status_qs = 9'h0;
1280:     aon_filter_status_ds = 9'h0;
1281:     aon_filter_status_ds[7:0] = aon_filter_status_match_ds_int;
1282:     aon_filter_status_qs[7:0] = aon_filter_status_match_qs_int;
1283:     aon_filter_status_ds[8] = aon_filter_status_trans_ds_int;
1284:     aon_filter_status_qs[8] = aon_filter_status_trans_qs_int;
1285:   end
1286: 
1287:   prim_reg_cdc #(
1288:     .DataWidth(9),
1289:     .ResetVal(9'h0),
1290:     .BitMask(9'h1ff),
1291:     .DstWrReq(1)
1292:   ) u_filter_status_cdc (
1293:     .clk_src_i    (clk_i),
1294:     .rst_src_ni   (rst_ni),
1295:     .clk_dst_i    (clk_aon_i),
1296:     .rst_dst_ni   (rst_aon_ni),
1297:     .src_regwen_i ('0),
1298:     .src_we_i     (filter_status_we),
1299:     .src_re_i     ('0),
1300:     .src_wd_i     (reg_wdata[8:0]),
1301:     .src_busy_o   (filter_status_busy),
1302:     .src_qs_o     (filter_status_qs), // for software read back
1303:     .dst_update_i (aon_filter_status_qe),
1304:     .dst_ds_i     (aon_filter_status_ds),
1305:     .dst_qs_i     (aon_filter_status_qs),
1306:     .dst_we_o     (aon_filter_status_we),
1307:     .dst_re_o     (),
1308:     .dst_regwen_o (),
1309:     .dst_wd_o     (aon_filter_status_wdata)
1310:   );
1311:   assign unused_aon_filter_status_wdata =
1312:       ^aon_filter_status_wdata;
1313: 
1314:   logic [4:0]  aon_adc_fsm_state_ds_int;
1315:   logic [4:0]  aon_adc_fsm_state_qs_int;
1316:   logic [4:0] aon_adc_fsm_state_ds;
1317:   logic aon_adc_fsm_state_qe;
1318:   logic [4:0] aon_adc_fsm_state_qs;
1319:   logic aon_adc_fsm_state_re;
1320: 
1321:   always_comb begin
1322:     aon_adc_fsm_state_qs = 5'h0;
1323:     aon_adc_fsm_state_ds = 5'h0;
1324:     aon_adc_fsm_state_ds = aon_adc_fsm_state_ds_int;
1325:     aon_adc_fsm_state_qs = aon_adc_fsm_state_qs_int;
1326:   end
1327: 
1328:   prim_reg_cdc #(
1329:     .DataWidth(5),
1330:     .ResetVal(5'h0),
1331:     .BitMask(5'h1f),
1332:     .DstWrReq(1)
1333:   ) u_adc_fsm_state_cdc (
1334:     .clk_src_i    (clk_i),
1335:     .rst_src_ni   (rst_ni),
1336:     .clk_dst_i    (clk_aon_i),
1337:     .rst_dst_ni   (rst_aon_ni),
1338:     .src_regwen_i ('0),
1339:     .src_we_i     ('0),
1340:     .src_re_i     (adc_fsm_state_re),
1341:     .src_wd_i     ('0),
1342:     .src_busy_o   (adc_fsm_state_busy),
1343:     .src_qs_o     (adc_fsm_state_qs), // for software read back
1344:     .dst_update_i (aon_adc_fsm_state_qe),
1345:     .dst_ds_i     (aon_adc_fsm_state_ds),
1346:     .dst_qs_i     (aon_adc_fsm_state_qs),
1347:     .dst_we_o     (),
1348:     .dst_re_o     (aon_adc_fsm_state_re),
1349:     .dst_regwen_o (),
1350:     .dst_wd_o     ()
1351:   );
1352: 
1353:   // Register instances
1354:   // R[intr_state]: V(False)
1355:   prim_subreg #(
1356:     .DW      (1),
1357:     .SwAccess(prim_subreg_pkg::SwAccessRO),
1358:     .RESVAL  (1'h0),
1359:     .Mubi    (1'b0)
1360:   ) u_intr_state (
1361:     .clk_i   (clk_i),
1362:     .rst_ni  (rst_ni),
1363: 
1364:     // from register interface
1365:     .we     (1'b0),
1366:     .wd     ('0),
1367: 
1368:     // from internal hardware
1369:     .de     (hw2reg.intr_state.de),
1370:     .d      (hw2reg.intr_state.d),
1371: 
1372:     // to internal hardware
1373:     .qe     (),
1374:     .q      (reg2hw.intr_state.q),
1375:     .ds     (),
1376: 
1377:     // to register interface (read)
1378:     .qs     (intr_state_qs)
1379:   );
1380: 
1381: 
1382:   // R[intr_enable]: V(False)
1383:   prim_subreg #(
1384:     .DW      (1),
1385:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1386:     .RESVAL  (1'h0),
1387:     .Mubi    (1'b0)
1388:   ) u_intr_enable (
1389:     .clk_i   (clk_i),
1390:     .rst_ni  (rst_ni),
1391: 
1392:     // from register interface
1393:     .we     (intr_enable_we),
1394:     .wd     (intr_enable_wd),
1395: 
1396:     // from internal hardware
1397:     .de     (1'b0),
1398:     .d      ('0),
1399: 
1400:     // to internal hardware
1401:     .qe     (),
1402:     .q      (reg2hw.intr_enable.q),
1403:     .ds     (),
1404: 
1405:     // to register interface (read)
1406:     .qs     (intr_enable_qs)
1407:   );
1408: 
1409: 
1410:   // R[intr_test]: V(True)
1411:   logic intr_test_qe;
1412:   logic [0:0] intr_test_flds_we;
1413:   assign intr_test_qe = &intr_test_flds_we;
1414:   prim_subreg_ext #(
1415:     .DW    (1)
1416:   ) u_intr_test (
1417:     .re     (1'b0),
1418:     .we     (intr_test_we),
1419:     .wd     (intr_test_wd),
1420:     .d      ('0),
1421:     .qre    (),
1422:     .qe     (intr_test_flds_we[0]),
1423:     .q      (reg2hw.intr_test.q),
1424:     .ds     (),
1425:     .qs     ()
1426:   );
1427:   assign reg2hw.intr_test.qe = intr_test_qe;
1428: 
1429: 
1430:   // R[alert_test]: V(True)
1431:   logic alert_test_qe;
1432:   logic [0:0] alert_test_flds_we;
1433:   assign alert_test_qe = &alert_test_flds_we;
1434:   prim_subreg_ext #(
1435:     .DW    (1)
1436:   ) u_alert_test (
1437:     .re     (1'b0),
1438:     .we     (alert_test_we),
1439:     .wd     (alert_test_wd),
1440:     .d      ('0),
1441:     .qre    (),
1442:     .qe     (alert_test_flds_we[0]),
1443:     .q      (reg2hw.alert_test.q),
1444:     .ds     (),
1445:     .qs     ()
1446:   );
1447:   assign reg2hw.alert_test.qe = alert_test_qe;
1448: 
1449: 
1450:   // R[adc_en_ctl]: V(False)
1451:   //   F[adc_enable]: 0:0
1452:   prim_subreg #(
1453:     .DW      (1),
1454:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1455:     .RESVAL  (1'h0),
1456:     .Mubi    (1'b0)
1457:   ) u_adc_en_ctl_adc_enable (
1458:     .clk_i   (clk_aon_i),
1459:     .rst_ni  (rst_aon_ni),
1460: 
1461:     // from register interface
1462:     .we     (aon_adc_en_ctl_we),
1463:     .wd     (aon_adc_en_ctl_wdata[0]),
1464: 
1465:     // from internal hardware
1466:     .de     (1'b0),
1467:     .d      ('0),
1468: 
1469:     // to internal hardware
1470:     .qe     (),
1471:     .q      (reg2hw.adc_en_ctl.adc_enable.q),
1472:     .ds     (),
1473: 
1474:     // to register interface (read)
1475:     .qs     (aon_adc_en_ctl_adc_enable_qs_int)
1476:   );
1477: 
1478:   //   F[oneshot_mode]: 1:1
1479:   prim_subreg #(
1480:     .DW      (1),
1481:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1482:     .RESVAL  (1'h0),
1483:     .Mubi    (1'b0)
1484:   ) u_adc_en_ctl_oneshot_mode (
1485:     .clk_i   (clk_aon_i),
1486:     .rst_ni  (rst_aon_ni),
1487: 
1488:     // from register interface
1489:     .we     (aon_adc_en_ctl_we),
1490:     .wd     (aon_adc_en_ctl_wdata[1]),
1491: 
1492:     // from internal hardware
1493:     .de     (1'b0),
1494:     .d      ('0),
1495: 
1496:     // to internal hardware
1497:     .qe     (),
1498:     .q      (reg2hw.adc_en_ctl.oneshot_mode.q),
1499:     .ds     (),
1500: 
1501:     // to register interface (read)
1502:     .qs     (aon_adc_en_ctl_oneshot_mode_qs_int)
1503:   );
1504: 
1505: 
1506:   // R[adc_pd_ctl]: V(False)
1507:   //   F[lp_mode]: 0:0
1508:   prim_subreg #(
1509:     .DW      (1),
1510:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1511:     .RESVAL  (1'h0),
1512:     .Mubi    (1'b0)
1513:   ) u_adc_pd_ctl_lp_mode (
1514:     .clk_i   (clk_aon_i),
1515:     .rst_ni  (rst_aon_ni),
1516: 
1517:     // from register interface
1518:     .we     (aon_adc_pd_ctl_we),
1519:     .wd     (aon_adc_pd_ctl_wdata[0]),
1520: 
1521:     // from internal hardware
1522:     .de     (1'b0),
1523:     .d      ('0),
1524: 
1525:     // to internal hardware
1526:     .qe     (),
1527:     .q      (reg2hw.adc_pd_ctl.lp_mode.q),
1528:     .ds     (),
1529: 
1530:     // to register interface (read)
1531:     .qs     (aon_adc_pd_ctl_lp_mode_qs_int)
1532:   );
1533: 
1534:   //   F[pwrup_time]: 7:4
1535:   prim_subreg #(
1536:     .DW      (4),
1537:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1538:     .RESVAL  (4'h7),
1539:     .Mubi    (1'b0)
1540:   ) u_adc_pd_ctl_pwrup_time (
1541:     .clk_i   (clk_aon_i),
1542:     .rst_ni  (rst_aon_ni),
1543: 
1544:     // from register interface
1545:     .we     (aon_adc_pd_ctl_we),
1546:     .wd     (aon_adc_pd_ctl_wdata[7:4]),
1547: 
1548:     // from internal hardware
1549:     .de     (1'b0),
1550:     .d      ('0),
1551: 
1552:     // to internal hardware
1553:     .qe     (),
1554:     .q      (reg2hw.adc_pd_ctl.pwrup_time.q),
1555:     .ds     (),
1556: 
1557:     // to register interface (read)
1558:     .qs     (aon_adc_pd_ctl_pwrup_time_qs_int)
1559:   );
1560: 
1561:   //   F[wakeup_time]: 31:8
1562:   prim_subreg #(
1563:     .DW      (24),
1564:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1565:     .RESVAL  (24'h640),
1566:     .Mubi    (1'b0)
1567:   ) u_adc_pd_ctl_wakeup_time (
1568:     .clk_i   (clk_aon_i),
1569:     .rst_ni  (rst_aon_ni),
1570: 
1571:     // from register interface
1572:     .we     (aon_adc_pd_ctl_we),
1573:     .wd     (aon_adc_pd_ctl_wdata[31:8]),
1574: 
1575:     // from internal hardware
1576:     .de     (1'b0),
1577:     .d      ('0),
1578: 
1579:     // to internal hardware
1580:     .qe     (),
1581:     .q      (reg2hw.adc_pd_ctl.wakeup_time.q),
1582:     .ds     (),
1583: 
1584:     // to register interface (read)
1585:     .qs     (aon_adc_pd_ctl_wakeup_time_qs_int)
1586:   );
1587: 
1588: 
1589:   // R[adc_lp_sample_ctl]: V(False)
1590:   prim_subreg #(
1591:     .DW      (8),
1592:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1593:     .RESVAL  (8'h4),
1594:     .Mubi    (1'b0)
1595:   ) u_adc_lp_sample_ctl (
1596:     .clk_i   (clk_aon_i),
1597:     .rst_ni  (rst_aon_ni),
1598: 
1599:     // from register interface
1600:     .we     (aon_adc_lp_sample_ctl_we),
1601:     .wd     (aon_adc_lp_sample_ctl_wdata[7:0]),
1602: 
1603:     // from internal hardware
1604:     .de     (1'b0),
1605:     .d      ('0),
1606: 
1607:     // to internal hardware
1608:     .qe     (),
1609:     .q      (reg2hw.adc_lp_sample_ctl.q),
1610:     .ds     (),
1611: 
1612:     // to register interface (read)
1613:     .qs     (aon_adc_lp_sample_ctl_qs_int)
1614:   );
1615: 
1616: 
1617:   // R[adc_sample_ctl]: V(False)
1618:   prim_subreg #(
1619:     .DW      (16),
1620:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1621:     .RESVAL  (16'h9b),
1622:     .Mubi    (1'b0)
1623:   ) u_adc_sample_ctl (
1624:     .clk_i   (clk_aon_i),
1625:     .rst_ni  (rst_aon_ni),
1626: 
1627:     // from register interface
1628:     .we     (aon_adc_sample_ctl_we),
1629:     .wd     (aon_adc_sample_ctl_wdata[15:0]),
1630: 
1631:     // from internal hardware
1632:     .de     (1'b0),
1633:     .d      ('0),
1634: 
1635:     // to internal hardware
1636:     .qe     (),
1637:     .q      (reg2hw.adc_sample_ctl.q),
1638:     .ds     (),
1639: 
1640:     // to register interface (read)
1641:     .qs     (aon_adc_sample_ctl_qs_int)
1642:   );
1643: 
1644: 
1645:   // R[adc_fsm_rst]: V(False)
1646:   prim_subreg #(
1647:     .DW      (1),
1648:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1649:     .RESVAL  (1'h0),
1650:     .Mubi    (1'b0)
1651:   ) u_adc_fsm_rst (
1652:     .clk_i   (clk_aon_i),
1653:     .rst_ni  (rst_aon_ni),
1654: 
1655:     // from register interface
1656:     .we     (aon_adc_fsm_rst_we),
1657:     .wd     (aon_adc_fsm_rst_wdata[0]),
1658: 
1659:     // from internal hardware
1660:     .de     (1'b0),
1661:     .d      ('0),
1662: 
1663:     // to internal hardware
1664:     .qe     (),
1665:     .q      (reg2hw.adc_fsm_rst.q),
1666:     .ds     (),
1667: 
1668:     // to register interface (read)
1669:     .qs     (aon_adc_fsm_rst_qs_int)
1670:   );
1671: 
1672: 
1673:   // Subregister 0 of Multireg adc_chn0_filter_ctl
1674:   // R[adc_chn0_filter_ctl_0]: V(False)
1675:   //   F[min_v_0]: 11:2
1676:   prim_subreg #(
1677:     .DW      (10),
1678:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1679:     .RESVAL  (10'h0),
1680:     .Mubi    (1'b0)
1681:   ) u_adc_chn0_filter_ctl_0_min_v_0 (
1682:     .clk_i   (clk_aon_i),
1683:     .rst_ni  (rst_aon_ni),
1684: 
1685:     // from register interface
1686:     .we     (aon_adc_chn0_filter_ctl_0_we),
1687:     .wd     (aon_adc_chn0_filter_ctl_0_wdata[11:2]),
1688: 
1689:     // from internal hardware
1690:     .de     (1'b0),
1691:     .d      ('0),
1692: 
1693:     // to internal hardware
1694:     .qe     (),
1695:     .q      (reg2hw.adc_chn0_filter_ctl[0].min_v.q),
1696:     .ds     (),
1697: 
1698:     // to register interface (read)
1699:     .qs     (aon_adc_chn0_filter_ctl_0_min_v_0_qs_int)
1700:   );
1701: 
1702:   //   F[cond_0]: 12:12
1703:   prim_subreg #(
1704:     .DW      (1),
1705:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1706:     .RESVAL  (1'h0),
1707:     .Mubi    (1'b0)
1708:   ) u_adc_chn0_filter_ctl_0_cond_0 (
1709:     .clk_i   (clk_aon_i),
1710:     .rst_ni  (rst_aon_ni),
1711: 
1712:     // from register interface
1713:     .we     (aon_adc_chn0_filter_ctl_0_we),
1714:     .wd     (aon_adc_chn0_filter_ctl_0_wdata[12]),
1715: 
1716:     // from internal hardware
1717:     .de     (1'b0),
1718:     .d      ('0),
1719: 
1720:     // to internal hardware
1721:     .qe     (),
1722:     .q      (reg2hw.adc_chn0_filter_ctl[0].cond.q),
1723:     .ds     (),
1724: 
1725:     // to register interface (read)
1726:     .qs     (aon_adc_chn0_filter_ctl_0_cond_0_qs_int)
1727:   );
1728: 
1729:   //   F[max_v_0]: 27:18
1730:   prim_subreg #(
1731:     .DW      (10),
1732:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1733:     .RESVAL  (10'h0),
1734:     .Mubi    (1'b0)
1735:   ) u_adc_chn0_filter_ctl_0_max_v_0 (
1736:     .clk_i   (clk_aon_i),
1737:     .rst_ni  (rst_aon_ni),
1738: 
1739:     // from register interface
1740:     .we     (aon_adc_chn0_filter_ctl_0_we),
1741:     .wd     (aon_adc_chn0_filter_ctl_0_wdata[27:18]),
1742: 
1743:     // from internal hardware
1744:     .de     (1'b0),
1745:     .d      ('0),
1746: 
1747:     // to internal hardware
1748:     .qe     (),
1749:     .q      (reg2hw.adc_chn0_filter_ctl[0].max_v.q),
1750:     .ds     (),
1751: 
1752:     // to register interface (read)
1753:     .qs     (aon_adc_chn0_filter_ctl_0_max_v_0_qs_int)
1754:   );
1755: 
1756:   //   F[en_0]: 31:31
1757:   prim_subreg #(
1758:     .DW      (1),
1759:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1760:     .RESVAL  (1'h0),
1761:     .Mubi    (1'b0)
1762:   ) u_adc_chn0_filter_ctl_0_en_0 (
1763:     .clk_i   (clk_aon_i),
1764:     .rst_ni  (rst_aon_ni),
1765: 
1766:     // from register interface
1767:     .we     (aon_adc_chn0_filter_ctl_0_we),
1768:     .wd     (aon_adc_chn0_filter_ctl_0_wdata[31]),
1769: 
1770:     // from internal hardware
1771:     .de     (1'b0),
1772:     .d      ('0),
1773: 
1774:     // to internal hardware
1775:     .qe     (),
1776:     .q      (reg2hw.adc_chn0_filter_ctl[0].en.q),
1777:     .ds     (),
1778: 
1779:     // to register interface (read)
1780:     .qs     (aon_adc_chn0_filter_ctl_0_en_0_qs_int)
1781:   );
1782: 
1783: 
1784:   // Subregister 1 of Multireg adc_chn0_filter_ctl
1785:   // R[adc_chn0_filter_ctl_1]: V(False)
1786:   //   F[min_v_1]: 11:2
1787:   prim_subreg #(
1788:     .DW      (10),
1789:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1790:     .RESVAL  (10'h0),
1791:     .Mubi    (1'b0)
1792:   ) u_adc_chn0_filter_ctl_1_min_v_1 (
1793:     .clk_i   (clk_aon_i),
1794:     .rst_ni  (rst_aon_ni),
1795: 
1796:     // from register interface
1797:     .we     (aon_adc_chn0_filter_ctl_1_we),
1798:     .wd     (aon_adc_chn0_filter_ctl_1_wdata[11:2]),
1799: 
1800:     // from internal hardware
1801:     .de     (1'b0),
1802:     .d      ('0),
1803: 
1804:     // to internal hardware
1805:     .qe     (),
1806:     .q      (reg2hw.adc_chn0_filter_ctl[1].min_v.q),
1807:     .ds     (),
1808: 
1809:     // to register interface (read)
1810:     .qs     (aon_adc_chn0_filter_ctl_1_min_v_1_qs_int)
1811:   );
1812: 
1813:   //   F[cond_1]: 12:12
1814:   prim_subreg #(
1815:     .DW      (1),
1816:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1817:     .RESVAL  (1'h0),
1818:     .Mubi    (1'b0)
1819:   ) u_adc_chn0_filter_ctl_1_cond_1 (
1820:     .clk_i   (clk_aon_i),
1821:     .rst_ni  (rst_aon_ni),
1822: 
1823:     // from register interface
1824:     .we     (aon_adc_chn0_filter_ctl_1_we),
1825:     .wd     (aon_adc_chn0_filter_ctl_1_wdata[12]),
1826: 
1827:     // from internal hardware
1828:     .de     (1'b0),
1829:     .d      ('0),
1830: 
1831:     // to internal hardware
1832:     .qe     (),
1833:     .q      (reg2hw.adc_chn0_filter_ctl[1].cond.q),
1834:     .ds     (),
1835: 
1836:     // to register interface (read)
1837:     .qs     (aon_adc_chn0_filter_ctl_1_cond_1_qs_int)
1838:   );
1839: 
1840:   //   F[max_v_1]: 27:18
1841:   prim_subreg #(
1842:     .DW      (10),
1843:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1844:     .RESVAL  (10'h0),
1845:     .Mubi    (1'b0)
1846:   ) u_adc_chn0_filter_ctl_1_max_v_1 (
1847:     .clk_i   (clk_aon_i),
1848:     .rst_ni  (rst_aon_ni),
1849: 
1850:     // from register interface
1851:     .we     (aon_adc_chn0_filter_ctl_1_we),
1852:     .wd     (aon_adc_chn0_filter_ctl_1_wdata[27:18]),
1853: 
1854:     // from internal hardware
1855:     .de     (1'b0),
1856:     .d      ('0),
1857: 
1858:     // to internal hardware
1859:     .qe     (),
1860:     .q      (reg2hw.adc_chn0_filter_ctl[1].max_v.q),
1861:     .ds     (),
1862: 
1863:     // to register interface (read)
1864:     .qs     (aon_adc_chn0_filter_ctl_1_max_v_1_qs_int)
1865:   );
1866: 
1867:   //   F[en_1]: 31:31
1868:   prim_subreg #(
1869:     .DW      (1),
1870:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1871:     .RESVAL  (1'h0),
1872:     .Mubi    (1'b0)
1873:   ) u_adc_chn0_filter_ctl_1_en_1 (
1874:     .clk_i   (clk_aon_i),
1875:     .rst_ni  (rst_aon_ni),
1876: 
1877:     // from register interface
1878:     .we     (aon_adc_chn0_filter_ctl_1_we),
1879:     .wd     (aon_adc_chn0_filter_ctl_1_wdata[31]),
1880: 
1881:     // from internal hardware
1882:     .de     (1'b0),
1883:     .d      ('0),
1884: 
1885:     // to internal hardware
1886:     .qe     (),
1887:     .q      (reg2hw.adc_chn0_filter_ctl[1].en.q),
1888:     .ds     (),
1889: 
1890:     // to register interface (read)
1891:     .qs     (aon_adc_chn0_filter_ctl_1_en_1_qs_int)
1892:   );
1893: 
1894: 
1895:   // Subregister 2 of Multireg adc_chn0_filter_ctl
1896:   // R[adc_chn0_filter_ctl_2]: V(False)
1897:   //   F[min_v_2]: 11:2
1898:   prim_subreg #(
1899:     .DW      (10),
1900:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1901:     .RESVAL  (10'h0),
1902:     .Mubi    (1'b0)
1903:   ) u_adc_chn0_filter_ctl_2_min_v_2 (
1904:     .clk_i   (clk_aon_i),
1905:     .rst_ni  (rst_aon_ni),
1906: 
1907:     // from register interface
1908:     .we     (aon_adc_chn0_filter_ctl_2_we),
1909:     .wd     (aon_adc_chn0_filter_ctl_2_wdata[11:2]),
1910: 
1911:     // from internal hardware
1912:     .de     (1'b0),
1913:     .d      ('0),
1914: 
1915:     // to internal hardware
1916:     .qe     (),
1917:     .q      (reg2hw.adc_chn0_filter_ctl[2].min_v.q),
1918:     .ds     (),
1919: 
1920:     // to register interface (read)
1921:     .qs     (aon_adc_chn0_filter_ctl_2_min_v_2_qs_int)
1922:   );
1923: 
1924:   //   F[cond_2]: 12:12
1925:   prim_subreg #(
1926:     .DW      (1),
1927:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1928:     .RESVAL  (1'h0),
1929:     .Mubi    (1'b0)
1930:   ) u_adc_chn0_filter_ctl_2_cond_2 (
1931:     .clk_i   (clk_aon_i),
1932:     .rst_ni  (rst_aon_ni),
1933: 
1934:     // from register interface
1935:     .we     (aon_adc_chn0_filter_ctl_2_we),
1936:     .wd     (aon_adc_chn0_filter_ctl_2_wdata[12]),
1937: 
1938:     // from internal hardware
1939:     .de     (1'b0),
1940:     .d      ('0),
1941: 
1942:     // to internal hardware
1943:     .qe     (),
1944:     .q      (reg2hw.adc_chn0_filter_ctl[2].cond.q),
1945:     .ds     (),
1946: 
1947:     // to register interface (read)
1948:     .qs     (aon_adc_chn0_filter_ctl_2_cond_2_qs_int)
1949:   );
1950: 
1951:   //   F[max_v_2]: 27:18
1952:   prim_subreg #(
1953:     .DW      (10),
1954:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1955:     .RESVAL  (10'h0),
1956:     .Mubi    (1'b0)
1957:   ) u_adc_chn0_filter_ctl_2_max_v_2 (
1958:     .clk_i   (clk_aon_i),
1959:     .rst_ni  (rst_aon_ni),
1960: 
1961:     // from register interface
1962:     .we     (aon_adc_chn0_filter_ctl_2_we),
1963:     .wd     (aon_adc_chn0_filter_ctl_2_wdata[27:18]),
1964: 
1965:     // from internal hardware
1966:     .de     (1'b0),
1967:     .d      ('0),
1968: 
1969:     // to internal hardware
1970:     .qe     (),
1971:     .q      (reg2hw.adc_chn0_filter_ctl[2].max_v.q),
1972:     .ds     (),
1973: 
1974:     // to register interface (read)
1975:     .qs     (aon_adc_chn0_filter_ctl_2_max_v_2_qs_int)
1976:   );
1977: 
1978:   //   F[en_2]: 31:31
1979:   prim_subreg #(
1980:     .DW      (1),
1981:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1982:     .RESVAL  (1'h0),
1983:     .Mubi    (1'b0)
1984:   ) u_adc_chn0_filter_ctl_2_en_2 (
1985:     .clk_i   (clk_aon_i),
1986:     .rst_ni  (rst_aon_ni),
1987: 
1988:     // from register interface
1989:     .we     (aon_adc_chn0_filter_ctl_2_we),
1990:     .wd     (aon_adc_chn0_filter_ctl_2_wdata[31]),
1991: 
1992:     // from internal hardware
1993:     .de     (1'b0),
1994:     .d      ('0),
1995: 
1996:     // to internal hardware
1997:     .qe     (),
1998:     .q      (reg2hw.adc_chn0_filter_ctl[2].en.q),
1999:     .ds     (),
2000: 
2001:     // to register interface (read)
2002:     .qs     (aon_adc_chn0_filter_ctl_2_en_2_qs_int)
2003:   );
2004: 
2005: 
2006:   // Subregister 3 of Multireg adc_chn0_filter_ctl
2007:   // R[adc_chn0_filter_ctl_3]: V(False)
2008:   //   F[min_v_3]: 11:2
2009:   prim_subreg #(
2010:     .DW      (10),
2011:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2012:     .RESVAL  (10'h0),
2013:     .Mubi    (1'b0)
2014:   ) u_adc_chn0_filter_ctl_3_min_v_3 (
2015:     .clk_i   (clk_aon_i),
2016:     .rst_ni  (rst_aon_ni),
2017: 
2018:     // from register interface
2019:     .we     (aon_adc_chn0_filter_ctl_3_we),
2020:     .wd     (aon_adc_chn0_filter_ctl_3_wdata[11:2]),
2021: 
2022:     // from internal hardware
2023:     .de     (1'b0),
2024:     .d      ('0),
2025: 
2026:     // to internal hardware
2027:     .qe     (),
2028:     .q      (reg2hw.adc_chn0_filter_ctl[3].min_v.q),
2029:     .ds     (),
2030: 
2031:     // to register interface (read)
2032:     .qs     (aon_adc_chn0_filter_ctl_3_min_v_3_qs_int)
2033:   );
2034: 
2035:   //   F[cond_3]: 12:12
2036:   prim_subreg #(
2037:     .DW      (1),
2038:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2039:     .RESVAL  (1'h0),
2040:     .Mubi    (1'b0)
2041:   ) u_adc_chn0_filter_ctl_3_cond_3 (
2042:     .clk_i   (clk_aon_i),
2043:     .rst_ni  (rst_aon_ni),
2044: 
2045:     // from register interface
2046:     .we     (aon_adc_chn0_filter_ctl_3_we),
2047:     .wd     (aon_adc_chn0_filter_ctl_3_wdata[12]),
2048: 
2049:     // from internal hardware
2050:     .de     (1'b0),
2051:     .d      ('0),
2052: 
2053:     // to internal hardware
2054:     .qe     (),
2055:     .q      (reg2hw.adc_chn0_filter_ctl[3].cond.q),
2056:     .ds     (),
2057: 
2058:     // to register interface (read)
2059:     .qs     (aon_adc_chn0_filter_ctl_3_cond_3_qs_int)
2060:   );
2061: 
2062:   //   F[max_v_3]: 27:18
2063:   prim_subreg #(
2064:     .DW      (10),
2065:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2066:     .RESVAL  (10'h0),
2067:     .Mubi    (1'b0)
2068:   ) u_adc_chn0_filter_ctl_3_max_v_3 (
2069:     .clk_i   (clk_aon_i),
2070:     .rst_ni  (rst_aon_ni),
2071: 
2072:     // from register interface
2073:     .we     (aon_adc_chn0_filter_ctl_3_we),
2074:     .wd     (aon_adc_chn0_filter_ctl_3_wdata[27:18]),
2075: 
2076:     // from internal hardware
2077:     .de     (1'b0),
2078:     .d      ('0),
2079: 
2080:     // to internal hardware
2081:     .qe     (),
2082:     .q      (reg2hw.adc_chn0_filter_ctl[3].max_v.q),
2083:     .ds     (),
2084: 
2085:     // to register interface (read)
2086:     .qs     (aon_adc_chn0_filter_ctl_3_max_v_3_qs_int)
2087:   );
2088: 
2089:   //   F[en_3]: 31:31
2090:   prim_subreg #(
2091:     .DW      (1),
2092:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2093:     .RESVAL  (1'h0),
2094:     .Mubi    (1'b0)
2095:   ) u_adc_chn0_filter_ctl_3_en_3 (
2096:     .clk_i   (clk_aon_i),
2097:     .rst_ni  (rst_aon_ni),
2098: 
2099:     // from register interface
2100:     .we     (aon_adc_chn0_filter_ctl_3_we),
2101:     .wd     (aon_adc_chn0_filter_ctl_3_wdata[31]),
2102: 
2103:     // from internal hardware
2104:     .de     (1'b0),
2105:     .d      ('0),
2106: 
2107:     // to internal hardware
2108:     .qe     (),
2109:     .q      (reg2hw.adc_chn0_filter_ctl[3].en.q),
2110:     .ds     (),
2111: 
2112:     // to register interface (read)
2113:     .qs     (aon_adc_chn0_filter_ctl_3_en_3_qs_int)
2114:   );
2115: 
2116: 
2117:   // Subregister 4 of Multireg adc_chn0_filter_ctl
2118:   // R[adc_chn0_filter_ctl_4]: V(False)
2119:   //   F[min_v_4]: 11:2
2120:   prim_subreg #(
2121:     .DW      (10),
2122:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2123:     .RESVAL  (10'h0),
2124:     .Mubi    (1'b0)
2125:   ) u_adc_chn0_filter_ctl_4_min_v_4 (
2126:     .clk_i   (clk_aon_i),
2127:     .rst_ni  (rst_aon_ni),
2128: 
2129:     // from register interface
2130:     .we     (aon_adc_chn0_filter_ctl_4_we),
2131:     .wd     (aon_adc_chn0_filter_ctl_4_wdata[11:2]),
2132: 
2133:     // from internal hardware
2134:     .de     (1'b0),
2135:     .d      ('0),
2136: 
2137:     // to internal hardware
2138:     .qe     (),
2139:     .q      (reg2hw.adc_chn0_filter_ctl[4].min_v.q),
2140:     .ds     (),
2141: 
2142:     // to register interface (read)
2143:     .qs     (aon_adc_chn0_filter_ctl_4_min_v_4_qs_int)
2144:   );
2145: 
2146:   //   F[cond_4]: 12:12
2147:   prim_subreg #(
2148:     .DW      (1),
2149:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2150:     .RESVAL  (1'h0),
2151:     .Mubi    (1'b0)
2152:   ) u_adc_chn0_filter_ctl_4_cond_4 (
2153:     .clk_i   (clk_aon_i),
2154:     .rst_ni  (rst_aon_ni),
2155: 
2156:     // from register interface
2157:     .we     (aon_adc_chn0_filter_ctl_4_we),
2158:     .wd     (aon_adc_chn0_filter_ctl_4_wdata[12]),
2159: 
2160:     // from internal hardware
2161:     .de     (1'b0),
2162:     .d      ('0),
2163: 
2164:     // to internal hardware
2165:     .qe     (),
2166:     .q      (reg2hw.adc_chn0_filter_ctl[4].cond.q),
2167:     .ds     (),
2168: 
2169:     // to register interface (read)
2170:     .qs     (aon_adc_chn0_filter_ctl_4_cond_4_qs_int)
2171:   );
2172: 
2173:   //   F[max_v_4]: 27:18
2174:   prim_subreg #(
2175:     .DW      (10),
2176:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2177:     .RESVAL  (10'h0),
2178:     .Mubi    (1'b0)
2179:   ) u_adc_chn0_filter_ctl_4_max_v_4 (
2180:     .clk_i   (clk_aon_i),
2181:     .rst_ni  (rst_aon_ni),
2182: 
2183:     // from register interface
2184:     .we     (aon_adc_chn0_filter_ctl_4_we),
2185:     .wd     (aon_adc_chn0_filter_ctl_4_wdata[27:18]),
2186: 
2187:     // from internal hardware
2188:     .de     (1'b0),
2189:     .d      ('0),
2190: 
2191:     // to internal hardware
2192:     .qe     (),
2193:     .q      (reg2hw.adc_chn0_filter_ctl[4].max_v.q),
2194:     .ds     (),
2195: 
2196:     // to register interface (read)
2197:     .qs     (aon_adc_chn0_filter_ctl_4_max_v_4_qs_int)
2198:   );
2199: 
2200:   //   F[en_4]: 31:31
2201:   prim_subreg #(
2202:     .DW      (1),
2203:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2204:     .RESVAL  (1'h0),
2205:     .Mubi    (1'b0)
2206:   ) u_adc_chn0_filter_ctl_4_en_4 (
2207:     .clk_i   (clk_aon_i),
2208:     .rst_ni  (rst_aon_ni),
2209: 
2210:     // from register interface
2211:     .we     (aon_adc_chn0_filter_ctl_4_we),
2212:     .wd     (aon_adc_chn0_filter_ctl_4_wdata[31]),
2213: 
2214:     // from internal hardware
2215:     .de     (1'b0),
2216:     .d      ('0),
2217: 
2218:     // to internal hardware
2219:     .qe     (),
2220:     .q      (reg2hw.adc_chn0_filter_ctl[4].en.q),
2221:     .ds     (),
2222: 
2223:     // to register interface (read)
2224:     .qs     (aon_adc_chn0_filter_ctl_4_en_4_qs_int)
2225:   );
2226: 
2227: 
2228:   // Subregister 5 of Multireg adc_chn0_filter_ctl
2229:   // R[adc_chn0_filter_ctl_5]: V(False)
2230:   //   F[min_v_5]: 11:2
2231:   prim_subreg #(
2232:     .DW      (10),
2233:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2234:     .RESVAL  (10'h0),
2235:     .Mubi    (1'b0)
2236:   ) u_adc_chn0_filter_ctl_5_min_v_5 (
2237:     .clk_i   (clk_aon_i),
2238:     .rst_ni  (rst_aon_ni),
2239: 
2240:     // from register interface
2241:     .we     (aon_adc_chn0_filter_ctl_5_we),
2242:     .wd     (aon_adc_chn0_filter_ctl_5_wdata[11:2]),
2243: 
2244:     // from internal hardware
2245:     .de     (1'b0),
2246:     .d      ('0),
2247: 
2248:     // to internal hardware
2249:     .qe     (),
2250:     .q      (reg2hw.adc_chn0_filter_ctl[5].min_v.q),
2251:     .ds     (),
2252: 
2253:     // to register interface (read)
2254:     .qs     (aon_adc_chn0_filter_ctl_5_min_v_5_qs_int)
2255:   );
2256: 
2257:   //   F[cond_5]: 12:12
2258:   prim_subreg #(
2259:     .DW      (1),
2260:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2261:     .RESVAL  (1'h0),
2262:     .Mubi    (1'b0)
2263:   ) u_adc_chn0_filter_ctl_5_cond_5 (
2264:     .clk_i   (clk_aon_i),
2265:     .rst_ni  (rst_aon_ni),
2266: 
2267:     // from register interface
2268:     .we     (aon_adc_chn0_filter_ctl_5_we),
2269:     .wd     (aon_adc_chn0_filter_ctl_5_wdata[12]),
2270: 
2271:     // from internal hardware
2272:     .de     (1'b0),
2273:     .d      ('0),
2274: 
2275:     // to internal hardware
2276:     .qe     (),
2277:     .q      (reg2hw.adc_chn0_filter_ctl[5].cond.q),
2278:     .ds     (),
2279: 
2280:     // to register interface (read)
2281:     .qs     (aon_adc_chn0_filter_ctl_5_cond_5_qs_int)
2282:   );
2283: 
2284:   //   F[max_v_5]: 27:18
2285:   prim_subreg #(
2286:     .DW      (10),
2287:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2288:     .RESVAL  (10'h0),
2289:     .Mubi    (1'b0)
2290:   ) u_adc_chn0_filter_ctl_5_max_v_5 (
2291:     .clk_i   (clk_aon_i),
2292:     .rst_ni  (rst_aon_ni),
2293: 
2294:     // from register interface
2295:     .we     (aon_adc_chn0_filter_ctl_5_we),
2296:     .wd     (aon_adc_chn0_filter_ctl_5_wdata[27:18]),
2297: 
2298:     // from internal hardware
2299:     .de     (1'b0),
2300:     .d      ('0),
2301: 
2302:     // to internal hardware
2303:     .qe     (),
2304:     .q      (reg2hw.adc_chn0_filter_ctl[5].max_v.q),
2305:     .ds     (),
2306: 
2307:     // to register interface (read)
2308:     .qs     (aon_adc_chn0_filter_ctl_5_max_v_5_qs_int)
2309:   );
2310: 
2311:   //   F[en_5]: 31:31
2312:   prim_subreg #(
2313:     .DW      (1),
2314:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2315:     .RESVAL  (1'h0),
2316:     .Mubi    (1'b0)
2317:   ) u_adc_chn0_filter_ctl_5_en_5 (
2318:     .clk_i   (clk_aon_i),
2319:     .rst_ni  (rst_aon_ni),
2320: 
2321:     // from register interface
2322:     .we     (aon_adc_chn0_filter_ctl_5_we),
2323:     .wd     (aon_adc_chn0_filter_ctl_5_wdata[31]),
2324: 
2325:     // from internal hardware
2326:     .de     (1'b0),
2327:     .d      ('0),
2328: 
2329:     // to internal hardware
2330:     .qe     (),
2331:     .q      (reg2hw.adc_chn0_filter_ctl[5].en.q),
2332:     .ds     (),
2333: 
2334:     // to register interface (read)
2335:     .qs     (aon_adc_chn0_filter_ctl_5_en_5_qs_int)
2336:   );
2337: 
2338: 
2339:   // Subregister 6 of Multireg adc_chn0_filter_ctl
2340:   // R[adc_chn0_filter_ctl_6]: V(False)
2341:   //   F[min_v_6]: 11:2
2342:   prim_subreg #(
2343:     .DW      (10),
2344:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2345:     .RESVAL  (10'h0),
2346:     .Mubi    (1'b0)
2347:   ) u_adc_chn0_filter_ctl_6_min_v_6 (
2348:     .clk_i   (clk_aon_i),
2349:     .rst_ni  (rst_aon_ni),
2350: 
2351:     // from register interface
2352:     .we     (aon_adc_chn0_filter_ctl_6_we),
2353:     .wd     (aon_adc_chn0_filter_ctl_6_wdata[11:2]),
2354: 
2355:     // from internal hardware
2356:     .de     (1'b0),
2357:     .d      ('0),
2358: 
2359:     // to internal hardware
2360:     .qe     (),
2361:     .q      (reg2hw.adc_chn0_filter_ctl[6].min_v.q),
2362:     .ds     (),
2363: 
2364:     // to register interface (read)
2365:     .qs     (aon_adc_chn0_filter_ctl_6_min_v_6_qs_int)
2366:   );
2367: 
2368:   //   F[cond_6]: 12:12
2369:   prim_subreg #(
2370:     .DW      (1),
2371:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2372:     .RESVAL  (1'h0),
2373:     .Mubi    (1'b0)
2374:   ) u_adc_chn0_filter_ctl_6_cond_6 (
2375:     .clk_i   (clk_aon_i),
2376:     .rst_ni  (rst_aon_ni),
2377: 
2378:     // from register interface
2379:     .we     (aon_adc_chn0_filter_ctl_6_we),
2380:     .wd     (aon_adc_chn0_filter_ctl_6_wdata[12]),
2381: 
2382:     // from internal hardware
2383:     .de     (1'b0),
2384:     .d      ('0),
2385: 
2386:     // to internal hardware
2387:     .qe     (),
2388:     .q      (reg2hw.adc_chn0_filter_ctl[6].cond.q),
2389:     .ds     (),
2390: 
2391:     // to register interface (read)
2392:     .qs     (aon_adc_chn0_filter_ctl_6_cond_6_qs_int)
2393:   );
2394: 
2395:   //   F[max_v_6]: 27:18
2396:   prim_subreg #(
2397:     .DW      (10),
2398:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2399:     .RESVAL  (10'h0),
2400:     .Mubi    (1'b0)
2401:   ) u_adc_chn0_filter_ctl_6_max_v_6 (
2402:     .clk_i   (clk_aon_i),
2403:     .rst_ni  (rst_aon_ni),
2404: 
2405:     // from register interface
2406:     .we     (aon_adc_chn0_filter_ctl_6_we),
2407:     .wd     (aon_adc_chn0_filter_ctl_6_wdata[27:18]),
2408: 
2409:     // from internal hardware
2410:     .de     (1'b0),
2411:     .d      ('0),
2412: 
2413:     // to internal hardware
2414:     .qe     (),
2415:     .q      (reg2hw.adc_chn0_filter_ctl[6].max_v.q),
2416:     .ds     (),
2417: 
2418:     // to register interface (read)
2419:     .qs     (aon_adc_chn0_filter_ctl_6_max_v_6_qs_int)
2420:   );
2421: 
2422:   //   F[en_6]: 31:31
2423:   prim_subreg #(
2424:     .DW      (1),
2425:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2426:     .RESVAL  (1'h0),
2427:     .Mubi    (1'b0)
2428:   ) u_adc_chn0_filter_ctl_6_en_6 (
2429:     .clk_i   (clk_aon_i),
2430:     .rst_ni  (rst_aon_ni),
2431: 
2432:     // from register interface
2433:     .we     (aon_adc_chn0_filter_ctl_6_we),
2434:     .wd     (aon_adc_chn0_filter_ctl_6_wdata[31]),
2435: 
2436:     // from internal hardware
2437:     .de     (1'b0),
2438:     .d      ('0),
2439: 
2440:     // to internal hardware
2441:     .qe     (),
2442:     .q      (reg2hw.adc_chn0_filter_ctl[6].en.q),
2443:     .ds     (),
2444: 
2445:     // to register interface (read)
2446:     .qs     (aon_adc_chn0_filter_ctl_6_en_6_qs_int)
2447:   );
2448: 
2449: 
2450:   // Subregister 7 of Multireg adc_chn0_filter_ctl
2451:   // R[adc_chn0_filter_ctl_7]: V(False)
2452:   //   F[min_v_7]: 11:2
2453:   prim_subreg #(
2454:     .DW      (10),
2455:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2456:     .RESVAL  (10'h0),
2457:     .Mubi    (1'b0)
2458:   ) u_adc_chn0_filter_ctl_7_min_v_7 (
2459:     .clk_i   (clk_aon_i),
2460:     .rst_ni  (rst_aon_ni),
2461: 
2462:     // from register interface
2463:     .we     (aon_adc_chn0_filter_ctl_7_we),
2464:     .wd     (aon_adc_chn0_filter_ctl_7_wdata[11:2]),
2465: 
2466:     // from internal hardware
2467:     .de     (1'b0),
2468:     .d      ('0),
2469: 
2470:     // to internal hardware
2471:     .qe     (),
2472:     .q      (reg2hw.adc_chn0_filter_ctl[7].min_v.q),
2473:     .ds     (),
2474: 
2475:     // to register interface (read)
2476:     .qs     (aon_adc_chn0_filter_ctl_7_min_v_7_qs_int)
2477:   );
2478: 
2479:   //   F[cond_7]: 12:12
2480:   prim_subreg #(
2481:     .DW      (1),
2482:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2483:     .RESVAL  (1'h0),
2484:     .Mubi    (1'b0)
2485:   ) u_adc_chn0_filter_ctl_7_cond_7 (
2486:     .clk_i   (clk_aon_i),
2487:     .rst_ni  (rst_aon_ni),
2488: 
2489:     // from register interface
2490:     .we     (aon_adc_chn0_filter_ctl_7_we),
2491:     .wd     (aon_adc_chn0_filter_ctl_7_wdata[12]),
2492: 
2493:     // from internal hardware
2494:     .de     (1'b0),
2495:     .d      ('0),
2496: 
2497:     // to internal hardware
2498:     .qe     (),
2499:     .q      (reg2hw.adc_chn0_filter_ctl[7].cond.q),
2500:     .ds     (),
2501: 
2502:     // to register interface (read)
2503:     .qs     (aon_adc_chn0_filter_ctl_7_cond_7_qs_int)
2504:   );
2505: 
2506:   //   F[max_v_7]: 27:18
2507:   prim_subreg #(
2508:     .DW      (10),
2509:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2510:     .RESVAL  (10'h0),
2511:     .Mubi    (1'b0)
2512:   ) u_adc_chn0_filter_ctl_7_max_v_7 (
2513:     .clk_i   (clk_aon_i),
2514:     .rst_ni  (rst_aon_ni),
2515: 
2516:     // from register interface
2517:     .we     (aon_adc_chn0_filter_ctl_7_we),
2518:     .wd     (aon_adc_chn0_filter_ctl_7_wdata[27:18]),
2519: 
2520:     // from internal hardware
2521:     .de     (1'b0),
2522:     .d      ('0),
2523: 
2524:     // to internal hardware
2525:     .qe     (),
2526:     .q      (reg2hw.adc_chn0_filter_ctl[7].max_v.q),
2527:     .ds     (),
2528: 
2529:     // to register interface (read)
2530:     .qs     (aon_adc_chn0_filter_ctl_7_max_v_7_qs_int)
2531:   );
2532: 
2533:   //   F[en_7]: 31:31
2534:   prim_subreg #(
2535:     .DW      (1),
2536:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2537:     .RESVAL  (1'h0),
2538:     .Mubi    (1'b0)
2539:   ) u_adc_chn0_filter_ctl_7_en_7 (
2540:     .clk_i   (clk_aon_i),
2541:     .rst_ni  (rst_aon_ni),
2542: 
2543:     // from register interface
2544:     .we     (aon_adc_chn0_filter_ctl_7_we),
2545:     .wd     (aon_adc_chn0_filter_ctl_7_wdata[31]),
2546: 
2547:     // from internal hardware
2548:     .de     (1'b0),
2549:     .d      ('0),
2550: 
2551:     // to internal hardware
2552:     .qe     (),
2553:     .q      (reg2hw.adc_chn0_filter_ctl[7].en.q),
2554:     .ds     (),
2555: 
2556:     // to register interface (read)
2557:     .qs     (aon_adc_chn0_filter_ctl_7_en_7_qs_int)
2558:   );
2559: 
2560: 
2561:   // Subregister 0 of Multireg adc_chn1_filter_ctl
2562:   // R[adc_chn1_filter_ctl_0]: V(False)
2563:   //   F[min_v_0]: 11:2
2564:   prim_subreg #(
2565:     .DW      (10),
2566:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2567:     .RESVAL  (10'h0),
2568:     .Mubi    (1'b0)
2569:   ) u_adc_chn1_filter_ctl_0_min_v_0 (
2570:     .clk_i   (clk_aon_i),
2571:     .rst_ni  (rst_aon_ni),
2572: 
2573:     // from register interface
2574:     .we     (aon_adc_chn1_filter_ctl_0_we),
2575:     .wd     (aon_adc_chn1_filter_ctl_0_wdata[11:2]),
2576: 
2577:     // from internal hardware
2578:     .de     (1'b0),
2579:     .d      ('0),
2580: 
2581:     // to internal hardware
2582:     .qe     (),
2583:     .q      (reg2hw.adc_chn1_filter_ctl[0].min_v.q),
2584:     .ds     (),
2585: 
2586:     // to register interface (read)
2587:     .qs     (aon_adc_chn1_filter_ctl_0_min_v_0_qs_int)
2588:   );
2589: 
2590:   //   F[cond_0]: 12:12
2591:   prim_subreg #(
2592:     .DW      (1),
2593:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2594:     .RESVAL  (1'h0),
2595:     .Mubi    (1'b0)
2596:   ) u_adc_chn1_filter_ctl_0_cond_0 (
2597:     .clk_i   (clk_aon_i),
2598:     .rst_ni  (rst_aon_ni),
2599: 
2600:     // from register interface
2601:     .we     (aon_adc_chn1_filter_ctl_0_we),
2602:     .wd     (aon_adc_chn1_filter_ctl_0_wdata[12]),
2603: 
2604:     // from internal hardware
2605:     .de     (1'b0),
2606:     .d      ('0),
2607: 
2608:     // to internal hardware
2609:     .qe     (),
2610:     .q      (reg2hw.adc_chn1_filter_ctl[0].cond.q),
2611:     .ds     (),
2612: 
2613:     // to register interface (read)
2614:     .qs     (aon_adc_chn1_filter_ctl_0_cond_0_qs_int)
2615:   );
2616: 
2617:   //   F[max_v_0]: 27:18
2618:   prim_subreg #(
2619:     .DW      (10),
2620:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2621:     .RESVAL  (10'h0),
2622:     .Mubi    (1'b0)
2623:   ) u_adc_chn1_filter_ctl_0_max_v_0 (
2624:     .clk_i   (clk_aon_i),
2625:     .rst_ni  (rst_aon_ni),
2626: 
2627:     // from register interface
2628:     .we     (aon_adc_chn1_filter_ctl_0_we),
2629:     .wd     (aon_adc_chn1_filter_ctl_0_wdata[27:18]),
2630: 
2631:     // from internal hardware
2632:     .de     (1'b0),
2633:     .d      ('0),
2634: 
2635:     // to internal hardware
2636:     .qe     (),
2637:     .q      (reg2hw.adc_chn1_filter_ctl[0].max_v.q),
2638:     .ds     (),
2639: 
2640:     // to register interface (read)
2641:     .qs     (aon_adc_chn1_filter_ctl_0_max_v_0_qs_int)
2642:   );
2643: 
2644:   //   F[en_0]: 31:31
2645:   prim_subreg #(
2646:     .DW      (1),
2647:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2648:     .RESVAL  (1'h0),
2649:     .Mubi    (1'b0)
2650:   ) u_adc_chn1_filter_ctl_0_en_0 (
2651:     .clk_i   (clk_aon_i),
2652:     .rst_ni  (rst_aon_ni),
2653: 
2654:     // from register interface
2655:     .we     (aon_adc_chn1_filter_ctl_0_we),
2656:     .wd     (aon_adc_chn1_filter_ctl_0_wdata[31]),
2657: 
2658:     // from internal hardware
2659:     .de     (1'b0),
2660:     .d      ('0),
2661: 
2662:     // to internal hardware
2663:     .qe     (),
2664:     .q      (reg2hw.adc_chn1_filter_ctl[0].en.q),
2665:     .ds     (),
2666: 
2667:     // to register interface (read)
2668:     .qs     (aon_adc_chn1_filter_ctl_0_en_0_qs_int)
2669:   );
2670: 
2671: 
2672:   // Subregister 1 of Multireg adc_chn1_filter_ctl
2673:   // R[adc_chn1_filter_ctl_1]: V(False)
2674:   //   F[min_v_1]: 11:2
2675:   prim_subreg #(
2676:     .DW      (10),
2677:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2678:     .RESVAL  (10'h0),
2679:     .Mubi    (1'b0)
2680:   ) u_adc_chn1_filter_ctl_1_min_v_1 (
2681:     .clk_i   (clk_aon_i),
2682:     .rst_ni  (rst_aon_ni),
2683: 
2684:     // from register interface
2685:     .we     (aon_adc_chn1_filter_ctl_1_we),
2686:     .wd     (aon_adc_chn1_filter_ctl_1_wdata[11:2]),
2687: 
2688:     // from internal hardware
2689:     .de     (1'b0),
2690:     .d      ('0),
2691: 
2692:     // to internal hardware
2693:     .qe     (),
2694:     .q      (reg2hw.adc_chn1_filter_ctl[1].min_v.q),
2695:     .ds     (),
2696: 
2697:     // to register interface (read)
2698:     .qs     (aon_adc_chn1_filter_ctl_1_min_v_1_qs_int)
2699:   );
2700: 
2701:   //   F[cond_1]: 12:12
2702:   prim_subreg #(
2703:     .DW      (1),
2704:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2705:     .RESVAL  (1'h0),
2706:     .Mubi    (1'b0)
2707:   ) u_adc_chn1_filter_ctl_1_cond_1 (
2708:     .clk_i   (clk_aon_i),
2709:     .rst_ni  (rst_aon_ni),
2710: 
2711:     // from register interface
2712:     .we     (aon_adc_chn1_filter_ctl_1_we),
2713:     .wd     (aon_adc_chn1_filter_ctl_1_wdata[12]),
2714: 
2715:     // from internal hardware
2716:     .de     (1'b0),
2717:     .d      ('0),
2718: 
2719:     // to internal hardware
2720:     .qe     (),
2721:     .q      (reg2hw.adc_chn1_filter_ctl[1].cond.q),
2722:     .ds     (),
2723: 
2724:     // to register interface (read)
2725:     .qs     (aon_adc_chn1_filter_ctl_1_cond_1_qs_int)
2726:   );
2727: 
2728:   //   F[max_v_1]: 27:18
2729:   prim_subreg #(
2730:     .DW      (10),
2731:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2732:     .RESVAL  (10'h0),
2733:     .Mubi    (1'b0)
2734:   ) u_adc_chn1_filter_ctl_1_max_v_1 (
2735:     .clk_i   (clk_aon_i),
2736:     .rst_ni  (rst_aon_ni),
2737: 
2738:     // from register interface
2739:     .we     (aon_adc_chn1_filter_ctl_1_we),
2740:     .wd     (aon_adc_chn1_filter_ctl_1_wdata[27:18]),
2741: 
2742:     // from internal hardware
2743:     .de     (1'b0),
2744:     .d      ('0),
2745: 
2746:     // to internal hardware
2747:     .qe     (),
2748:     .q      (reg2hw.adc_chn1_filter_ctl[1].max_v.q),
2749:     .ds     (),
2750: 
2751:     // to register interface (read)
2752:     .qs     (aon_adc_chn1_filter_ctl_1_max_v_1_qs_int)
2753:   );
2754: 
2755:   //   F[en_1]: 31:31
2756:   prim_subreg #(
2757:     .DW      (1),
2758:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2759:     .RESVAL  (1'h0),
2760:     .Mubi    (1'b0)
2761:   ) u_adc_chn1_filter_ctl_1_en_1 (
2762:     .clk_i   (clk_aon_i),
2763:     .rst_ni  (rst_aon_ni),
2764: 
2765:     // from register interface
2766:     .we     (aon_adc_chn1_filter_ctl_1_we),
2767:     .wd     (aon_adc_chn1_filter_ctl_1_wdata[31]),
2768: 
2769:     // from internal hardware
2770:     .de     (1'b0),
2771:     .d      ('0),
2772: 
2773:     // to internal hardware
2774:     .qe     (),
2775:     .q      (reg2hw.adc_chn1_filter_ctl[1].en.q),
2776:     .ds     (),
2777: 
2778:     // to register interface (read)
2779:     .qs     (aon_adc_chn1_filter_ctl_1_en_1_qs_int)
2780:   );
2781: 
2782: 
2783:   // Subregister 2 of Multireg adc_chn1_filter_ctl
2784:   // R[adc_chn1_filter_ctl_2]: V(False)
2785:   //   F[min_v_2]: 11:2
2786:   prim_subreg #(
2787:     .DW      (10),
2788:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2789:     .RESVAL  (10'h0),
2790:     .Mubi    (1'b0)
2791:   ) u_adc_chn1_filter_ctl_2_min_v_2 (
2792:     .clk_i   (clk_aon_i),
2793:     .rst_ni  (rst_aon_ni),
2794: 
2795:     // from register interface
2796:     .we     (aon_adc_chn1_filter_ctl_2_we),
2797:     .wd     (aon_adc_chn1_filter_ctl_2_wdata[11:2]),
2798: 
2799:     // from internal hardware
2800:     .de     (1'b0),
2801:     .d      ('0),
2802: 
2803:     // to internal hardware
2804:     .qe     (),
2805:     .q      (reg2hw.adc_chn1_filter_ctl[2].min_v.q),
2806:     .ds     (),
2807: 
2808:     // to register interface (read)
2809:     .qs     (aon_adc_chn1_filter_ctl_2_min_v_2_qs_int)
2810:   );
2811: 
2812:   //   F[cond_2]: 12:12
2813:   prim_subreg #(
2814:     .DW      (1),
2815:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2816:     .RESVAL  (1'h0),
2817:     .Mubi    (1'b0)
2818:   ) u_adc_chn1_filter_ctl_2_cond_2 (
2819:     .clk_i   (clk_aon_i),
2820:     .rst_ni  (rst_aon_ni),
2821: 
2822:     // from register interface
2823:     .we     (aon_adc_chn1_filter_ctl_2_we),
2824:     .wd     (aon_adc_chn1_filter_ctl_2_wdata[12]),
2825: 
2826:     // from internal hardware
2827:     .de     (1'b0),
2828:     .d      ('0),
2829: 
2830:     // to internal hardware
2831:     .qe     (),
2832:     .q      (reg2hw.adc_chn1_filter_ctl[2].cond.q),
2833:     .ds     (),
2834: 
2835:     // to register interface (read)
2836:     .qs     (aon_adc_chn1_filter_ctl_2_cond_2_qs_int)
2837:   );
2838: 
2839:   //   F[max_v_2]: 27:18
2840:   prim_subreg #(
2841:     .DW      (10),
2842:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2843:     .RESVAL  (10'h0),
2844:     .Mubi    (1'b0)
2845:   ) u_adc_chn1_filter_ctl_2_max_v_2 (
2846:     .clk_i   (clk_aon_i),
2847:     .rst_ni  (rst_aon_ni),
2848: 
2849:     // from register interface
2850:     .we     (aon_adc_chn1_filter_ctl_2_we),
2851:     .wd     (aon_adc_chn1_filter_ctl_2_wdata[27:18]),
2852: 
2853:     // from internal hardware
2854:     .de     (1'b0),
2855:     .d      ('0),
2856: 
2857:     // to internal hardware
2858:     .qe     (),
2859:     .q      (reg2hw.adc_chn1_filter_ctl[2].max_v.q),
2860:     .ds     (),
2861: 
2862:     // to register interface (read)
2863:     .qs     (aon_adc_chn1_filter_ctl_2_max_v_2_qs_int)
2864:   );
2865: 
2866:   //   F[en_2]: 31:31
2867:   prim_subreg #(
2868:     .DW      (1),
2869:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2870:     .RESVAL  (1'h0),
2871:     .Mubi    (1'b0)
2872:   ) u_adc_chn1_filter_ctl_2_en_2 (
2873:     .clk_i   (clk_aon_i),
2874:     .rst_ni  (rst_aon_ni),
2875: 
2876:     // from register interface
2877:     .we     (aon_adc_chn1_filter_ctl_2_we),
2878:     .wd     (aon_adc_chn1_filter_ctl_2_wdata[31]),
2879: 
2880:     // from internal hardware
2881:     .de     (1'b0),
2882:     .d      ('0),
2883: 
2884:     // to internal hardware
2885:     .qe     (),
2886:     .q      (reg2hw.adc_chn1_filter_ctl[2].en.q),
2887:     .ds     (),
2888: 
2889:     // to register interface (read)
2890:     .qs     (aon_adc_chn1_filter_ctl_2_en_2_qs_int)
2891:   );
2892: 
2893: 
2894:   // Subregister 3 of Multireg adc_chn1_filter_ctl
2895:   // R[adc_chn1_filter_ctl_3]: V(False)
2896:   //   F[min_v_3]: 11:2
2897:   prim_subreg #(
2898:     .DW      (10),
2899:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2900:     .RESVAL  (10'h0),
2901:     .Mubi    (1'b0)
2902:   ) u_adc_chn1_filter_ctl_3_min_v_3 (
2903:     .clk_i   (clk_aon_i),
2904:     .rst_ni  (rst_aon_ni),
2905: 
2906:     // from register interface
2907:     .we     (aon_adc_chn1_filter_ctl_3_we),
2908:     .wd     (aon_adc_chn1_filter_ctl_3_wdata[11:2]),
2909: 
2910:     // from internal hardware
2911:     .de     (1'b0),
2912:     .d      ('0),
2913: 
2914:     // to internal hardware
2915:     .qe     (),
2916:     .q      (reg2hw.adc_chn1_filter_ctl[3].min_v.q),
2917:     .ds     (),
2918: 
2919:     // to register interface (read)
2920:     .qs     (aon_adc_chn1_filter_ctl_3_min_v_3_qs_int)
2921:   );
2922: 
2923:   //   F[cond_3]: 12:12
2924:   prim_subreg #(
2925:     .DW      (1),
2926:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2927:     .RESVAL  (1'h0),
2928:     .Mubi    (1'b0)
2929:   ) u_adc_chn1_filter_ctl_3_cond_3 (
2930:     .clk_i   (clk_aon_i),
2931:     .rst_ni  (rst_aon_ni),
2932: 
2933:     // from register interface
2934:     .we     (aon_adc_chn1_filter_ctl_3_we),
2935:     .wd     (aon_adc_chn1_filter_ctl_3_wdata[12]),
2936: 
2937:     // from internal hardware
2938:     .de     (1'b0),
2939:     .d      ('0),
2940: 
2941:     // to internal hardware
2942:     .qe     (),
2943:     .q      (reg2hw.adc_chn1_filter_ctl[3].cond.q),
2944:     .ds     (),
2945: 
2946:     // to register interface (read)
2947:     .qs     (aon_adc_chn1_filter_ctl_3_cond_3_qs_int)
2948:   );
2949: 
2950:   //   F[max_v_3]: 27:18
2951:   prim_subreg #(
2952:     .DW      (10),
2953:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2954:     .RESVAL  (10'h0),
2955:     .Mubi    (1'b0)
2956:   ) u_adc_chn1_filter_ctl_3_max_v_3 (
2957:     .clk_i   (clk_aon_i),
2958:     .rst_ni  (rst_aon_ni),
2959: 
2960:     // from register interface
2961:     .we     (aon_adc_chn1_filter_ctl_3_we),
2962:     .wd     (aon_adc_chn1_filter_ctl_3_wdata[27:18]),
2963: 
2964:     // from internal hardware
2965:     .de     (1'b0),
2966:     .d      ('0),
2967: 
2968:     // to internal hardware
2969:     .qe     (),
2970:     .q      (reg2hw.adc_chn1_filter_ctl[3].max_v.q),
2971:     .ds     (),
2972: 
2973:     // to register interface (read)
2974:     .qs     (aon_adc_chn1_filter_ctl_3_max_v_3_qs_int)
2975:   );
2976: 
2977:   //   F[en_3]: 31:31
2978:   prim_subreg #(
2979:     .DW      (1),
2980:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2981:     .RESVAL  (1'h0),
2982:     .Mubi    (1'b0)
2983:   ) u_adc_chn1_filter_ctl_3_en_3 (
2984:     .clk_i   (clk_aon_i),
2985:     .rst_ni  (rst_aon_ni),
2986: 
2987:     // from register interface
2988:     .we     (aon_adc_chn1_filter_ctl_3_we),
2989:     .wd     (aon_adc_chn1_filter_ctl_3_wdata[31]),
2990: 
2991:     // from internal hardware
2992:     .de     (1'b0),
2993:     .d      ('0),
2994: 
2995:     // to internal hardware
2996:     .qe     (),
2997:     .q      (reg2hw.adc_chn1_filter_ctl[3].en.q),
2998:     .ds     (),
2999: 
3000:     // to register interface (read)
3001:     .qs     (aon_adc_chn1_filter_ctl_3_en_3_qs_int)
3002:   );
3003: 
3004: 
3005:   // Subregister 4 of Multireg adc_chn1_filter_ctl
3006:   // R[adc_chn1_filter_ctl_4]: V(False)
3007:   //   F[min_v_4]: 11:2
3008:   prim_subreg #(
3009:     .DW      (10),
3010:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3011:     .RESVAL  (10'h0),
3012:     .Mubi    (1'b0)
3013:   ) u_adc_chn1_filter_ctl_4_min_v_4 (
3014:     .clk_i   (clk_aon_i),
3015:     .rst_ni  (rst_aon_ni),
3016: 
3017:     // from register interface
3018:     .we     (aon_adc_chn1_filter_ctl_4_we),
3019:     .wd     (aon_adc_chn1_filter_ctl_4_wdata[11:2]),
3020: 
3021:     // from internal hardware
3022:     .de     (1'b0),
3023:     .d      ('0),
3024: 
3025:     // to internal hardware
3026:     .qe     (),
3027:     .q      (reg2hw.adc_chn1_filter_ctl[4].min_v.q),
3028:     .ds     (),
3029: 
3030:     // to register interface (read)
3031:     .qs     (aon_adc_chn1_filter_ctl_4_min_v_4_qs_int)
3032:   );
3033: 
3034:   //   F[cond_4]: 12:12
3035:   prim_subreg #(
3036:     .DW      (1),
3037:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3038:     .RESVAL  (1'h0),
3039:     .Mubi    (1'b0)
3040:   ) u_adc_chn1_filter_ctl_4_cond_4 (
3041:     .clk_i   (clk_aon_i),
3042:     .rst_ni  (rst_aon_ni),
3043: 
3044:     // from register interface
3045:     .we     (aon_adc_chn1_filter_ctl_4_we),
3046:     .wd     (aon_adc_chn1_filter_ctl_4_wdata[12]),
3047: 
3048:     // from internal hardware
3049:     .de     (1'b0),
3050:     .d      ('0),
3051: 
3052:     // to internal hardware
3053:     .qe     (),
3054:     .q      (reg2hw.adc_chn1_filter_ctl[4].cond.q),
3055:     .ds     (),
3056: 
3057:     // to register interface (read)
3058:     .qs     (aon_adc_chn1_filter_ctl_4_cond_4_qs_int)
3059:   );
3060: 
3061:   //   F[max_v_4]: 27:18
3062:   prim_subreg #(
3063:     .DW      (10),
3064:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3065:     .RESVAL  (10'h0),
3066:     .Mubi    (1'b0)
3067:   ) u_adc_chn1_filter_ctl_4_max_v_4 (
3068:     .clk_i   (clk_aon_i),
3069:     .rst_ni  (rst_aon_ni),
3070: 
3071:     // from register interface
3072:     .we     (aon_adc_chn1_filter_ctl_4_we),
3073:     .wd     (aon_adc_chn1_filter_ctl_4_wdata[27:18]),
3074: 
3075:     // from internal hardware
3076:     .de     (1'b0),
3077:     .d      ('0),
3078: 
3079:     // to internal hardware
3080:     .qe     (),
3081:     .q      (reg2hw.adc_chn1_filter_ctl[4].max_v.q),
3082:     .ds     (),
3083: 
3084:     // to register interface (read)
3085:     .qs     (aon_adc_chn1_filter_ctl_4_max_v_4_qs_int)
3086:   );
3087: 
3088:   //   F[en_4]: 31:31
3089:   prim_subreg #(
3090:     .DW      (1),
3091:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3092:     .RESVAL  (1'h0),
3093:     .Mubi    (1'b0)
3094:   ) u_adc_chn1_filter_ctl_4_en_4 (
3095:     .clk_i   (clk_aon_i),
3096:     .rst_ni  (rst_aon_ni),
3097: 
3098:     // from register interface
3099:     .we     (aon_adc_chn1_filter_ctl_4_we),
3100:     .wd     (aon_adc_chn1_filter_ctl_4_wdata[31]),
3101: 
3102:     // from internal hardware
3103:     .de     (1'b0),
3104:     .d      ('0),
3105: 
3106:     // to internal hardware
3107:     .qe     (),
3108:     .q      (reg2hw.adc_chn1_filter_ctl[4].en.q),
3109:     .ds     (),
3110: 
3111:     // to register interface (read)
3112:     .qs     (aon_adc_chn1_filter_ctl_4_en_4_qs_int)
3113:   );
3114: 
3115: 
3116:   // Subregister 5 of Multireg adc_chn1_filter_ctl
3117:   // R[adc_chn1_filter_ctl_5]: V(False)
3118:   //   F[min_v_5]: 11:2
3119:   prim_subreg #(
3120:     .DW      (10),
3121:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3122:     .RESVAL  (10'h0),
3123:     .Mubi    (1'b0)
3124:   ) u_adc_chn1_filter_ctl_5_min_v_5 (
3125:     .clk_i   (clk_aon_i),
3126:     .rst_ni  (rst_aon_ni),
3127: 
3128:     // from register interface
3129:     .we     (aon_adc_chn1_filter_ctl_5_we),
3130:     .wd     (aon_adc_chn1_filter_ctl_5_wdata[11:2]),
3131: 
3132:     // from internal hardware
3133:     .de     (1'b0),
3134:     .d      ('0),
3135: 
3136:     // to internal hardware
3137:     .qe     (),
3138:     .q      (reg2hw.adc_chn1_filter_ctl[5].min_v.q),
3139:     .ds     (),
3140: 
3141:     // to register interface (read)
3142:     .qs     (aon_adc_chn1_filter_ctl_5_min_v_5_qs_int)
3143:   );
3144: 
3145:   //   F[cond_5]: 12:12
3146:   prim_subreg #(
3147:     .DW      (1),
3148:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3149:     .RESVAL  (1'h0),
3150:     .Mubi    (1'b0)
3151:   ) u_adc_chn1_filter_ctl_5_cond_5 (
3152:     .clk_i   (clk_aon_i),
3153:     .rst_ni  (rst_aon_ni),
3154: 
3155:     // from register interface
3156:     .we     (aon_adc_chn1_filter_ctl_5_we),
3157:     .wd     (aon_adc_chn1_filter_ctl_5_wdata[12]),
3158: 
3159:     // from internal hardware
3160:     .de     (1'b0),
3161:     .d      ('0),
3162: 
3163:     // to internal hardware
3164:     .qe     (),
3165:     .q      (reg2hw.adc_chn1_filter_ctl[5].cond.q),
3166:     .ds     (),
3167: 
3168:     // to register interface (read)
3169:     .qs     (aon_adc_chn1_filter_ctl_5_cond_5_qs_int)
3170:   );
3171: 
3172:   //   F[max_v_5]: 27:18
3173:   prim_subreg #(
3174:     .DW      (10),
3175:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3176:     .RESVAL  (10'h0),
3177:     .Mubi    (1'b0)
3178:   ) u_adc_chn1_filter_ctl_5_max_v_5 (
3179:     .clk_i   (clk_aon_i),
3180:     .rst_ni  (rst_aon_ni),
3181: 
3182:     // from register interface
3183:     .we     (aon_adc_chn1_filter_ctl_5_we),
3184:     .wd     (aon_adc_chn1_filter_ctl_5_wdata[27:18]),
3185: 
3186:     // from internal hardware
3187:     .de     (1'b0),
3188:     .d      ('0),
3189: 
3190:     // to internal hardware
3191:     .qe     (),
3192:     .q      (reg2hw.adc_chn1_filter_ctl[5].max_v.q),
3193:     .ds     (),
3194: 
3195:     // to register interface (read)
3196:     .qs     (aon_adc_chn1_filter_ctl_5_max_v_5_qs_int)
3197:   );
3198: 
3199:   //   F[en_5]: 31:31
3200:   prim_subreg #(
3201:     .DW      (1),
3202:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3203:     .RESVAL  (1'h0),
3204:     .Mubi    (1'b0)
3205:   ) u_adc_chn1_filter_ctl_5_en_5 (
3206:     .clk_i   (clk_aon_i),
3207:     .rst_ni  (rst_aon_ni),
3208: 
3209:     // from register interface
3210:     .we     (aon_adc_chn1_filter_ctl_5_we),
3211:     .wd     (aon_adc_chn1_filter_ctl_5_wdata[31]),
3212: 
3213:     // from internal hardware
3214:     .de     (1'b0),
3215:     .d      ('0),
3216: 
3217:     // to internal hardware
3218:     .qe     (),
3219:     .q      (reg2hw.adc_chn1_filter_ctl[5].en.q),
3220:     .ds     (),
3221: 
3222:     // to register interface (read)
3223:     .qs     (aon_adc_chn1_filter_ctl_5_en_5_qs_int)
3224:   );
3225: 
3226: 
3227:   // Subregister 6 of Multireg adc_chn1_filter_ctl
3228:   // R[adc_chn1_filter_ctl_6]: V(False)
3229:   //   F[min_v_6]: 11:2
3230:   prim_subreg #(
3231:     .DW      (10),
3232:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3233:     .RESVAL  (10'h0),
3234:     .Mubi    (1'b0)
3235:   ) u_adc_chn1_filter_ctl_6_min_v_6 (
3236:     .clk_i   (clk_aon_i),
3237:     .rst_ni  (rst_aon_ni),
3238: 
3239:     // from register interface
3240:     .we     (aon_adc_chn1_filter_ctl_6_we),
3241:     .wd     (aon_adc_chn1_filter_ctl_6_wdata[11:2]),
3242: 
3243:     // from internal hardware
3244:     .de     (1'b0),
3245:     .d      ('0),
3246: 
3247:     // to internal hardware
3248:     .qe     (),
3249:     .q      (reg2hw.adc_chn1_filter_ctl[6].min_v.q),
3250:     .ds     (),
3251: 
3252:     // to register interface (read)
3253:     .qs     (aon_adc_chn1_filter_ctl_6_min_v_6_qs_int)
3254:   );
3255: 
3256:   //   F[cond_6]: 12:12
3257:   prim_subreg #(
3258:     .DW      (1),
3259:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3260:     .RESVAL  (1'h0),
3261:     .Mubi    (1'b0)
3262:   ) u_adc_chn1_filter_ctl_6_cond_6 (
3263:     .clk_i   (clk_aon_i),
3264:     .rst_ni  (rst_aon_ni),
3265: 
3266:     // from register interface
3267:     .we     (aon_adc_chn1_filter_ctl_6_we),
3268:     .wd     (aon_adc_chn1_filter_ctl_6_wdata[12]),
3269: 
3270:     // from internal hardware
3271:     .de     (1'b0),
3272:     .d      ('0),
3273: 
3274:     // to internal hardware
3275:     .qe     (),
3276:     .q      (reg2hw.adc_chn1_filter_ctl[6].cond.q),
3277:     .ds     (),
3278: 
3279:     // to register interface (read)
3280:     .qs     (aon_adc_chn1_filter_ctl_6_cond_6_qs_int)
3281:   );
3282: 
3283:   //   F[max_v_6]: 27:18
3284:   prim_subreg #(
3285:     .DW      (10),
3286:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3287:     .RESVAL  (10'h0),
3288:     .Mubi    (1'b0)
3289:   ) u_adc_chn1_filter_ctl_6_max_v_6 (
3290:     .clk_i   (clk_aon_i),
3291:     .rst_ni  (rst_aon_ni),
3292: 
3293:     // from register interface
3294:     .we     (aon_adc_chn1_filter_ctl_6_we),
3295:     .wd     (aon_adc_chn1_filter_ctl_6_wdata[27:18]),
3296: 
3297:     // from internal hardware
3298:     .de     (1'b0),
3299:     .d      ('0),
3300: 
3301:     // to internal hardware
3302:     .qe     (),
3303:     .q      (reg2hw.adc_chn1_filter_ctl[6].max_v.q),
3304:     .ds     (),
3305: 
3306:     // to register interface (read)
3307:     .qs     (aon_adc_chn1_filter_ctl_6_max_v_6_qs_int)
3308:   );
3309: 
3310:   //   F[en_6]: 31:31
3311:   prim_subreg #(
3312:     .DW      (1),
3313:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3314:     .RESVAL  (1'h0),
3315:     .Mubi    (1'b0)
3316:   ) u_adc_chn1_filter_ctl_6_en_6 (
3317:     .clk_i   (clk_aon_i),
3318:     .rst_ni  (rst_aon_ni),
3319: 
3320:     // from register interface
3321:     .we     (aon_adc_chn1_filter_ctl_6_we),
3322:     .wd     (aon_adc_chn1_filter_ctl_6_wdata[31]),
3323: 
3324:     // from internal hardware
3325:     .de     (1'b0),
3326:     .d      ('0),
3327: 
3328:     // to internal hardware
3329:     .qe     (),
3330:     .q      (reg2hw.adc_chn1_filter_ctl[6].en.q),
3331:     .ds     (),
3332: 
3333:     // to register interface (read)
3334:     .qs     (aon_adc_chn1_filter_ctl_6_en_6_qs_int)
3335:   );
3336: 
3337: 
3338:   // Subregister 7 of Multireg adc_chn1_filter_ctl
3339:   // R[adc_chn1_filter_ctl_7]: V(False)
3340:   //   F[min_v_7]: 11:2
3341:   prim_subreg #(
3342:     .DW      (10),
3343:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3344:     .RESVAL  (10'h0),
3345:     .Mubi    (1'b0)
3346:   ) u_adc_chn1_filter_ctl_7_min_v_7 (
3347:     .clk_i   (clk_aon_i),
3348:     .rst_ni  (rst_aon_ni),
3349: 
3350:     // from register interface
3351:     .we     (aon_adc_chn1_filter_ctl_7_we),
3352:     .wd     (aon_adc_chn1_filter_ctl_7_wdata[11:2]),
3353: 
3354:     // from internal hardware
3355:     .de     (1'b0),
3356:     .d      ('0),
3357: 
3358:     // to internal hardware
3359:     .qe     (),
3360:     .q      (reg2hw.adc_chn1_filter_ctl[7].min_v.q),
3361:     .ds     (),
3362: 
3363:     // to register interface (read)
3364:     .qs     (aon_adc_chn1_filter_ctl_7_min_v_7_qs_int)
3365:   );
3366: 
3367:   //   F[cond_7]: 12:12
3368:   prim_subreg #(
3369:     .DW      (1),
3370:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3371:     .RESVAL  (1'h0),
3372:     .Mubi    (1'b0)
3373:   ) u_adc_chn1_filter_ctl_7_cond_7 (
3374:     .clk_i   (clk_aon_i),
3375:     .rst_ni  (rst_aon_ni),
3376: 
3377:     // from register interface
3378:     .we     (aon_adc_chn1_filter_ctl_7_we),
3379:     .wd     (aon_adc_chn1_filter_ctl_7_wdata[12]),
3380: 
3381:     // from internal hardware
3382:     .de     (1'b0),
3383:     .d      ('0),
3384: 
3385:     // to internal hardware
3386:     .qe     (),
3387:     .q      (reg2hw.adc_chn1_filter_ctl[7].cond.q),
3388:     .ds     (),
3389: 
3390:     // to register interface (read)
3391:     .qs     (aon_adc_chn1_filter_ctl_7_cond_7_qs_int)
3392:   );
3393: 
3394:   //   F[max_v_7]: 27:18
3395:   prim_subreg #(
3396:     .DW      (10),
3397:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3398:     .RESVAL  (10'h0),
3399:     .Mubi    (1'b0)
3400:   ) u_adc_chn1_filter_ctl_7_max_v_7 (
3401:     .clk_i   (clk_aon_i),
3402:     .rst_ni  (rst_aon_ni),
3403: 
3404:     // from register interface
3405:     .we     (aon_adc_chn1_filter_ctl_7_we),
3406:     .wd     (aon_adc_chn1_filter_ctl_7_wdata[27:18]),
3407: 
3408:     // from internal hardware
3409:     .de     (1'b0),
3410:     .d      ('0),
3411: 
3412:     // to internal hardware
3413:     .qe     (),
3414:     .q      (reg2hw.adc_chn1_filter_ctl[7].max_v.q),
3415:     .ds     (),
3416: 
3417:     // to register interface (read)
3418:     .qs     (aon_adc_chn1_filter_ctl_7_max_v_7_qs_int)
3419:   );
3420: 
3421:   //   F[en_7]: 31:31
3422:   prim_subreg #(
3423:     .DW      (1),
3424:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3425:     .RESVAL  (1'h0),
3426:     .Mubi    (1'b0)
3427:   ) u_adc_chn1_filter_ctl_7_en_7 (
3428:     .clk_i   (clk_aon_i),
3429:     .rst_ni  (rst_aon_ni),
3430: 
3431:     // from register interface
3432:     .we     (aon_adc_chn1_filter_ctl_7_we),
3433:     .wd     (aon_adc_chn1_filter_ctl_7_wdata[31]),
3434: 
3435:     // from internal hardware
3436:     .de     (1'b0),
3437:     .d      ('0),
3438: 
3439:     // to internal hardware
3440:     .qe     (),
3441:     .q      (reg2hw.adc_chn1_filter_ctl[7].en.q),
3442:     .ds     (),
3443: 
3444:     // to register interface (read)
3445:     .qs     (aon_adc_chn1_filter_ctl_7_en_7_qs_int)
3446:   );
3447: 
3448: 
3449:   // Subregister 0 of Multireg adc_chn_val
3450:   // R[adc_chn_val_0]: V(False)
3451:   logic [3:0] adc_chn_val_0_flds_we;
3452:   assign aon_adc_chn_val_0_qe = |adc_chn_val_0_flds_we;
3453:   //   F[adc_chn_value_ext_0]: 1:0
3454:   prim_subreg #(
3455:     .DW      (2),
3456:     .SwAccess(prim_subreg_pkg::SwAccessRO),
3457:     .RESVAL  (2'h0),
3458:     .Mubi    (1'b0)
3459:   ) u_adc_chn_val_0_adc_chn_value_ext_0 (
3460:     .clk_i   (clk_aon_i),
3461:     .rst_ni  (rst_aon_ni),
3462: 
3463:     // from register interface
3464:     .we     (1'b0),
3465:     .wd     ('0),
3466: 
3467:     // from internal hardware
3468:     .de     (hw2reg.adc_chn_val[0].adc_chn_value_ext.de),
3469:     .d      (hw2reg.adc_chn_val[0].adc_chn_value_ext.d),
3470: 
3471:     // to internal hardware
3472:     .qe     (adc_chn_val_0_flds_we[0]),
3473:     .q      (),
3474:     .ds     (aon_adc_chn_val_0_adc_chn_value_ext_0_ds_int),
3475: 
3476:     // to register interface (read)
3477:     .qs     (aon_adc_chn_val_0_adc_chn_value_ext_0_qs_int)
3478:   );
3479: 
3480:   //   F[adc_chn_value_0]: 11:2
3481:   prim_subreg #(
3482:     .DW      (10),
3483:     .SwAccess(prim_subreg_pkg::SwAccessRO),
3484:     .RESVAL  (10'h0),
3485:     .Mubi    (1'b0)
3486:   ) u_adc_chn_val_0_adc_chn_value_0 (
3487:     .clk_i   (clk_aon_i),
3488:     .rst_ni  (rst_aon_ni),
3489: 
3490:     // from register interface
3491:     .we     (1'b0),
3492:     .wd     ('0),
3493: 
3494:     // from internal hardware
3495:     .de     (hw2reg.adc_chn_val[0].adc_chn_value.de),
3496:     .d      (hw2reg.adc_chn_val[0].adc_chn_value.d),
3497: 
3498:     // to internal hardware
3499:     .qe     (adc_chn_val_0_flds_we[1]),
3500:     .q      (),
3501:     .ds     (aon_adc_chn_val_0_adc_chn_value_0_ds_int),
3502: 
3503:     // to register interface (read)
3504:     .qs     (aon_adc_chn_val_0_adc_chn_value_0_qs_int)
3505:   );
3506: 
3507:   //   F[adc_chn_value_intr_ext_0]: 17:16
3508:   prim_subreg #(
3509:     .DW      (2),
3510:     .SwAccess(prim_subreg_pkg::SwAccessRO),
3511:     .RESVAL  (2'h0),
3512:     .Mubi    (1'b0)
3513:   ) u_adc_chn_val_0_adc_chn_value_intr_ext_0 (
3514:     .clk_i   (clk_aon_i),
3515:     .rst_ni  (rst_aon_ni),
3516: 
3517:     // from register interface
3518:     .we     (1'b0),
3519:     .wd     ('0),
3520: 
3521:     // from internal hardware
3522:     .de     (hw2reg.adc_chn_val[0].adc_chn_value_intr_ext.de),
3523:     .d      (hw2reg.adc_chn_val[0].adc_chn_value_intr_ext.d),
3524: 
3525:     // to internal hardware
3526:     .qe     (adc_chn_val_0_flds_we[2]),
3527:     .q      (),
3528:     .ds     (aon_adc_chn_val_0_adc_chn_value_intr_ext_0_ds_int),
3529: 
3530:     // to register interface (read)
3531:     .qs     (aon_adc_chn_val_0_adc_chn_value_intr_ext_0_qs_int)
3532:   );
3533: 
3534:   //   F[adc_chn_value_intr_0]: 27:18
3535:   prim_subreg #(
3536:     .DW      (10),
3537:     .SwAccess(prim_subreg_pkg::SwAccessRO),
3538:     .RESVAL  (10'h0),
3539:     .Mubi    (1'b0)
3540:   ) u_adc_chn_val_0_adc_chn_value_intr_0 (
3541:     .clk_i   (clk_aon_i),
3542:     .rst_ni  (rst_aon_ni),
3543: 
3544:     // from register interface
3545:     .we     (1'b0),
3546:     .wd     ('0),
3547: 
3548:     // from internal hardware
3549:     .de     (hw2reg.adc_chn_val[0].adc_chn_value_intr.de),
3550:     .d      (hw2reg.adc_chn_val[0].adc_chn_value_intr.d),
3551: 
3552:     // to internal hardware
3553:     .qe     (adc_chn_val_0_flds_we[3]),
3554:     .q      (),
3555:     .ds     (aon_adc_chn_val_0_adc_chn_value_intr_0_ds_int),
3556: 
3557:     // to register interface (read)
3558:     .qs     (aon_adc_chn_val_0_adc_chn_value_intr_0_qs_int)
3559:   );
3560: 
3561: 
3562:   // Subregister 1 of Multireg adc_chn_val
3563:   // R[adc_chn_val_1]: V(False)
3564:   logic [3:0] adc_chn_val_1_flds_we;
3565:   assign aon_adc_chn_val_1_qe = |adc_chn_val_1_flds_we;
3566:   //   F[adc_chn_value_ext_1]: 1:0
3567:   prim_subreg #(
3568:     .DW      (2),
3569:     .SwAccess(prim_subreg_pkg::SwAccessRO),
3570:     .RESVAL  (2'h0),
3571:     .Mubi    (1'b0)
3572:   ) u_adc_chn_val_1_adc_chn_value_ext_1 (
3573:     .clk_i   (clk_aon_i),
3574:     .rst_ni  (rst_aon_ni),
3575: 
3576:     // from register interface
3577:     .we     (1'b0),
3578:     .wd     ('0),
3579: 
3580:     // from internal hardware
3581:     .de     (hw2reg.adc_chn_val[1].adc_chn_value_ext.de),
3582:     .d      (hw2reg.adc_chn_val[1].adc_chn_value_ext.d),
3583: 
3584:     // to internal hardware
3585:     .qe     (adc_chn_val_1_flds_we[0]),
3586:     .q      (),
3587:     .ds     (aon_adc_chn_val_1_adc_chn_value_ext_1_ds_int),
3588: 
3589:     // to register interface (read)
3590:     .qs     (aon_adc_chn_val_1_adc_chn_value_ext_1_qs_int)
3591:   );
3592: 
3593:   //   F[adc_chn_value_1]: 11:2
3594:   prim_subreg #(
3595:     .DW      (10),
3596:     .SwAccess(prim_subreg_pkg::SwAccessRO),
3597:     .RESVAL  (10'h0),
3598:     .Mubi    (1'b0)
3599:   ) u_adc_chn_val_1_adc_chn_value_1 (
3600:     .clk_i   (clk_aon_i),
3601:     .rst_ni  (rst_aon_ni),
3602: 
3603:     // from register interface
3604:     .we     (1'b0),
3605:     .wd     ('0),
3606: 
3607:     // from internal hardware
3608:     .de     (hw2reg.adc_chn_val[1].adc_chn_value.de),
3609:     .d      (hw2reg.adc_chn_val[1].adc_chn_value.d),
3610: 
3611:     // to internal hardware
3612:     .qe     (adc_chn_val_1_flds_we[1]),
3613:     .q      (),
3614:     .ds     (aon_adc_chn_val_1_adc_chn_value_1_ds_int),
3615: 
3616:     // to register interface (read)
3617:     .qs     (aon_adc_chn_val_1_adc_chn_value_1_qs_int)
3618:   );
3619: 
3620:   //   F[adc_chn_value_intr_ext_1]: 17:16
3621:   prim_subreg #(
3622:     .DW      (2),
3623:     .SwAccess(prim_subreg_pkg::SwAccessRO),
3624:     .RESVAL  (2'h0),
3625:     .Mubi    (1'b0)
3626:   ) u_adc_chn_val_1_adc_chn_value_intr_ext_1 (
3627:     .clk_i   (clk_aon_i),
3628:     .rst_ni  (rst_aon_ni),
3629: 
3630:     // from register interface
3631:     .we     (1'b0),
3632:     .wd     ('0),
3633: 
3634:     // from internal hardware
3635:     .de     (hw2reg.adc_chn_val[1].adc_chn_value_intr_ext.de),
3636:     .d      (hw2reg.adc_chn_val[1].adc_chn_value_intr_ext.d),
3637: 
3638:     // to internal hardware
3639:     .qe     (adc_chn_val_1_flds_we[2]),
3640:     .q      (),
3641:     .ds     (aon_adc_chn_val_1_adc_chn_value_intr_ext_1_ds_int),
3642: 
3643:     // to register interface (read)
3644:     .qs     (aon_adc_chn_val_1_adc_chn_value_intr_ext_1_qs_int)
3645:   );
3646: 
3647:   //   F[adc_chn_value_intr_1]: 27:18
3648:   prim_subreg #(
3649:     .DW      (10),
3650:     .SwAccess(prim_subreg_pkg::SwAccessRO),
3651:     .RESVAL  (10'h0),
3652:     .Mubi    (1'b0)
3653:   ) u_adc_chn_val_1_adc_chn_value_intr_1 (
3654:     .clk_i   (clk_aon_i),
3655:     .rst_ni  (rst_aon_ni),
3656: 
3657:     // from register interface
3658:     .we     (1'b0),
3659:     .wd     ('0),
3660: 
3661:     // from internal hardware
3662:     .de     (hw2reg.adc_chn_val[1].adc_chn_value_intr.de),
3663:     .d      (hw2reg.adc_chn_val[1].adc_chn_value_intr.d),
3664: 
3665:     // to internal hardware
3666:     .qe     (adc_chn_val_1_flds_we[3]),
3667:     .q      (),
3668:     .ds     (aon_adc_chn_val_1_adc_chn_value_intr_1_ds_int),
3669: 
3670:     // to register interface (read)
3671:     .qs     (aon_adc_chn_val_1_adc_chn_value_intr_1_qs_int)
3672:   );
3673: 
3674: 
3675:   // R[adc_wakeup_ctl]: V(False)
3676:   //   F[match_en]: 7:0
3677:   prim_subreg #(
3678:     .DW      (8),
3679:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3680:     .RESVAL  (8'h0),
3681:     .Mubi    (1'b0)
3682:   ) u_adc_wakeup_ctl_match_en (
3683:     .clk_i   (clk_aon_i),
3684:     .rst_ni  (rst_aon_ni),
3685: 
3686:     // from register interface
3687:     .we     (aon_adc_wakeup_ctl_we),
3688:     .wd     (aon_adc_wakeup_ctl_wdata[7:0]),
3689: 
3690:     // from internal hardware
3691:     .de     (1'b0),
3692:     .d      ('0),
3693: 
3694:     // to internal hardware
3695:     .qe     (),
3696:     .q      (reg2hw.adc_wakeup_ctl.match_en.q),
3697:     .ds     (),
3698: 
3699:     // to register interface (read)
3700:     .qs     (aon_adc_wakeup_ctl_match_en_qs_int)
3701:   );
3702: 
3703:   //   F[trans_en]: 8:8
3704:   prim_subreg #(
3705:     .DW      (1),
3706:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3707:     .RESVAL  (1'h0),
3708:     .Mubi    (1'b0)
3709:   ) u_adc_wakeup_ctl_trans_en (
3710:     .clk_i   (clk_aon_i),
3711:     .rst_ni  (rst_aon_ni),
3712: 
3713:     // from register interface
3714:     .we     (aon_adc_wakeup_ctl_we),
3715:     .wd     (aon_adc_wakeup_ctl_wdata[8]),
3716: 
3717:     // from internal hardware
3718:     .de     (1'b0),
3719:     .d      ('0),
3720: 
3721:     // to internal hardware
3722:     .qe     (),
3723:     .q      (reg2hw.adc_wakeup_ctl.trans_en.q),
3724:     .ds     (),
3725: 
3726:     // to register interface (read)
3727:     .qs     (aon_adc_wakeup_ctl_trans_en_qs_int)
3728:   );
3729: 
3730: 
3731:   // R[filter_status]: V(False)
3732:   logic [1:0] filter_status_flds_we;
3733:   assign aon_filter_status_qe = |filter_status_flds_we;
3734:   //   F[match]: 7:0
3735:   prim_subreg #(
3736:     .DW      (8),
3737:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
3738:     .RESVAL  (8'h0),
3739:     .Mubi    (1'b0)
3740:   ) u_filter_status_match (
3741:     .clk_i   (clk_aon_i),
3742:     .rst_ni  (rst_aon_ni),
3743: 
3744:     // from register interface
3745:     .we     (aon_filter_status_we),
3746:     .wd     (aon_filter_status_wdata[7:0]),
3747: 
3748:     // from internal hardware
3749:     .de     (hw2reg.filter_status.match.de),
3750:     .d      (hw2reg.filter_status.match.d),
3751: 
3752:     // to internal hardware
3753:     .qe     (filter_status_flds_we[0]),
3754:     .q      (reg2hw.filter_status.match.q),
3755:     .ds     (aon_filter_status_match_ds_int),
3756: 
3757:     // to register interface (read)
3758:     .qs     (aon_filter_status_match_qs_int)
3759:   );
3760: 
3761:   //   F[trans]: 8:8
3762:   prim_subreg #(
3763:     .DW      (1),
3764:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
3765:     .RESVAL  (1'h0),
3766:     .Mubi    (1'b0)
3767:   ) u_filter_status_trans (
3768:     .clk_i   (clk_aon_i),
3769:     .rst_ni  (rst_aon_ni),
3770: 
3771:     // from register interface
3772:     .we     (aon_filter_status_we),
3773:     .wd     (aon_filter_status_wdata[8]),
3774: 
3775:     // from internal hardware
3776:     .de     (hw2reg.filter_status.trans.de),
3777:     .d      (hw2reg.filter_status.trans.d),
3778: 
3779:     // to internal hardware
3780:     .qe     (filter_status_flds_we[1]),
3781:     .q      (reg2hw.filter_status.trans.q),
3782:     .ds     (aon_filter_status_trans_ds_int),
3783: 
3784:     // to register interface (read)
3785:     .qs     (aon_filter_status_trans_qs_int)
3786:   );
3787: 
3788: 
3789:   // R[adc_intr_ctl]: V(False)
3790:   //   F[match_en]: 7:0
3791:   prim_subreg #(
3792:     .DW      (8),
3793:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3794:     .RESVAL  (8'h0),
3795:     .Mubi    (1'b0)
3796:   ) u_adc_intr_ctl_match_en (
3797:     .clk_i   (clk_i),
3798:     .rst_ni  (rst_ni),
3799: 
3800:     // from register interface
3801:     .we     (adc_intr_ctl_we),
3802:     .wd     (adc_intr_ctl_match_en_wd),
3803: 
3804:     // from internal hardware
3805:     .de     (1'b0),
3806:     .d      ('0),
3807: 
3808:     // to internal hardware
3809:     .qe     (),
3810:     .q      (reg2hw.adc_intr_ctl.match_en.q),
3811:     .ds     (),
3812: 
3813:     // to register interface (read)
3814:     .qs     (adc_intr_ctl_match_en_qs)
3815:   );
3816: 
3817:   //   F[trans_en]: 8:8
3818:   prim_subreg #(
3819:     .DW      (1),
3820:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3821:     .RESVAL  (1'h0),
3822:     .Mubi    (1'b0)
3823:   ) u_adc_intr_ctl_trans_en (
3824:     .clk_i   (clk_i),
3825:     .rst_ni  (rst_ni),
3826: 
3827:     // from register interface
3828:     .we     (adc_intr_ctl_we),
3829:     .wd     (adc_intr_ctl_trans_en_wd),
3830: 
3831:     // from internal hardware
3832:     .de     (1'b0),
3833:     .d      ('0),
3834: 
3835:     // to internal hardware
3836:     .qe     (),
3837:     .q      (reg2hw.adc_intr_ctl.trans_en.q),
3838:     .ds     (),
3839: 
3840:     // to register interface (read)
3841:     .qs     (adc_intr_ctl_trans_en_qs)
3842:   );
3843: 
3844:   //   F[oneshot_en]: 9:9
3845:   prim_subreg #(
3846:     .DW      (1),
3847:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3848:     .RESVAL  (1'h0),
3849:     .Mubi    (1'b0)
3850:   ) u_adc_intr_ctl_oneshot_en (
3851:     .clk_i   (clk_i),
3852:     .rst_ni  (rst_ni),
3853: 
3854:     // from register interface
3855:     .we     (adc_intr_ctl_we),
3856:     .wd     (adc_intr_ctl_oneshot_en_wd),
3857: 
3858:     // from internal hardware
3859:     .de     (1'b0),
3860:     .d      ('0),
3861: 
3862:     // to internal hardware
3863:     .qe     (),
3864:     .q      (reg2hw.adc_intr_ctl.oneshot_en.q),
3865:     .ds     (),
3866: 
3867:     // to register interface (read)
3868:     .qs     (adc_intr_ctl_oneshot_en_qs)
3869:   );
3870: 
3871: 
3872:   // R[adc_intr_status]: V(False)
3873:   //   F[match]: 7:0
3874:   prim_subreg #(
3875:     .DW      (8),
3876:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
3877:     .RESVAL  (8'h0),
3878:     .Mubi    (1'b0)
3879:   ) u_adc_intr_status_match (
3880:     .clk_i   (clk_i),
3881:     .rst_ni  (rst_ni),
3882: 
3883:     // from register interface
3884:     .we     (adc_intr_status_we),
3885:     .wd     (adc_intr_status_match_wd),
3886: 
3887:     // from internal hardware
3888:     .de     (hw2reg.adc_intr_status.match.de),
3889:     .d      (hw2reg.adc_intr_status.match.d),
3890: 
3891:     // to internal hardware
3892:     .qe     (),
3893:     .q      (reg2hw.adc_intr_status.match.q),
3894:     .ds     (),
3895: 
3896:     // to register interface (read)
3897:     .qs     (adc_intr_status_match_qs)
3898:   );
3899: 
3900:   //   F[trans]: 8:8
3901:   prim_subreg #(
3902:     .DW      (1),
3903:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
3904:     .RESVAL  (1'h0),
3905:     .Mubi    (1'b0)
3906:   ) u_adc_intr_status_trans (
3907:     .clk_i   (clk_i),
3908:     .rst_ni  (rst_ni),
3909: 
3910:     // from register interface
3911:     .we     (adc_intr_status_we),
3912:     .wd     (adc_intr_status_trans_wd),
3913: 
3914:     // from internal hardware
3915:     .de     (hw2reg.adc_intr_status.trans.de),
3916:     .d      (hw2reg.adc_intr_status.trans.d),
3917: 
3918:     // to internal hardware
3919:     .qe     (),
3920:     .q      (reg2hw.adc_intr_status.trans.q),
3921:     .ds     (),
3922: 
3923:     // to register interface (read)
3924:     .qs     (adc_intr_status_trans_qs)
3925:   );
3926: 
3927:   //   F[oneshot]: 9:9
3928:   prim_subreg #(
3929:     .DW      (1),
3930:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
3931:     .RESVAL  (1'h0),
3932:     .Mubi    (1'b0)
3933:   ) u_adc_intr_status_oneshot (
3934:     .clk_i   (clk_i),
3935:     .rst_ni  (rst_ni),
3936: 
3937:     // from register interface
3938:     .we     (adc_intr_status_we),
3939:     .wd     (adc_intr_status_oneshot_wd),
3940: 
3941:     // from internal hardware
3942:     .de     (hw2reg.adc_intr_status.oneshot.de),
3943:     .d      (hw2reg.adc_intr_status.oneshot.d),
3944: 
3945:     // to internal hardware
3946:     .qe     (),
3947:     .q      (reg2hw.adc_intr_status.oneshot.q),
3948:     .ds     (),
3949: 
3950:     // to register interface (read)
3951:     .qs     (adc_intr_status_oneshot_qs)
3952:   );
3953: 
3954: 
3955:   // R[adc_fsm_state]: V(True)
3956:   logic [0:0] adc_fsm_state_flds_we;
3957:   assign aon_adc_fsm_state_qe = |adc_fsm_state_flds_we;
3958:   prim_subreg_ext #(
3959:     .DW    (5)
3960:   ) u_adc_fsm_state (
3961:     .re     (aon_adc_fsm_state_re),
3962:     .we     (1'b0),
3963:     .wd     ('0),
3964:     .d      (hw2reg.adc_fsm_state.d),
3965:     .qre    (),
3966:     .qe     (adc_fsm_state_flds_we[0]),
3967:     .q      (),
3968:     .ds     (aon_adc_fsm_state_ds_int),
3969:     .qs     (aon_adc_fsm_state_qs_int)
3970:   );
3971: 
3972: 
3973: 
3974:   logic [31:0] addr_hit;
3975:   always_comb begin
3976:     addr_hit = '0;
3977:     addr_hit[ 0] = (reg_addr == ADC_CTRL_INTR_STATE_OFFSET);
3978:     addr_hit[ 1] = (reg_addr == ADC_CTRL_INTR_ENABLE_OFFSET);
3979:     addr_hit[ 2] = (reg_addr == ADC_CTRL_INTR_TEST_OFFSET);
3980:     addr_hit[ 3] = (reg_addr == ADC_CTRL_ALERT_TEST_OFFSET);
3981:     addr_hit[ 4] = (reg_addr == ADC_CTRL_ADC_EN_CTL_OFFSET);
3982:     addr_hit[ 5] = (reg_addr == ADC_CTRL_ADC_PD_CTL_OFFSET);
3983:     addr_hit[ 6] = (reg_addr == ADC_CTRL_ADC_LP_SAMPLE_CTL_OFFSET);
3984:     addr_hit[ 7] = (reg_addr == ADC_CTRL_ADC_SAMPLE_CTL_OFFSET);
3985:     addr_hit[ 8] = (reg_addr == ADC_CTRL_ADC_FSM_RST_OFFSET);
3986:     addr_hit[ 9] = (reg_addr == ADC_CTRL_ADC_CHN0_FILTER_CTL_0_OFFSET);
3987:     addr_hit[10] = (reg_addr == ADC_CTRL_ADC_CHN0_FILTER_CTL_1_OFFSET);
3988:     addr_hit[11] = (reg_addr == ADC_CTRL_ADC_CHN0_FILTER_CTL_2_OFFSET);
3989:     addr_hit[12] = (reg_addr == ADC_CTRL_ADC_CHN0_FILTER_CTL_3_OFFSET);
3990:     addr_hit[13] = (reg_addr == ADC_CTRL_ADC_CHN0_FILTER_CTL_4_OFFSET);
3991:     addr_hit[14] = (reg_addr == ADC_CTRL_ADC_CHN0_FILTER_CTL_5_OFFSET);
3992:     addr_hit[15] = (reg_addr == ADC_CTRL_ADC_CHN0_FILTER_CTL_6_OFFSET);
3993:     addr_hit[16] = (reg_addr == ADC_CTRL_ADC_CHN0_FILTER_CTL_7_OFFSET);
3994:     addr_hit[17] = (reg_addr == ADC_CTRL_ADC_CHN1_FILTER_CTL_0_OFFSET);
3995:     addr_hit[18] = (reg_addr == ADC_CTRL_ADC_CHN1_FILTER_CTL_1_OFFSET);
3996:     addr_hit[19] = (reg_addr == ADC_CTRL_ADC_CHN1_FILTER_CTL_2_OFFSET);
3997:     addr_hit[20] = (reg_addr == ADC_CTRL_ADC_CHN1_FILTER_CTL_3_OFFSET);
3998:     addr_hit[21] = (reg_addr == ADC_CTRL_ADC_CHN1_FILTER_CTL_4_OFFSET);
3999:     addr_hit[22] = (reg_addr == ADC_CTRL_ADC_CHN1_FILTER_CTL_5_OFFSET);
4000:     addr_hit[23] = (reg_addr == ADC_CTRL_ADC_CHN1_FILTER_CTL_6_OFFSET);
4001:     addr_hit[24] = (reg_addr == ADC_CTRL_ADC_CHN1_FILTER_CTL_7_OFFSET);
4002:     addr_hit[25] = (reg_addr == ADC_CTRL_ADC_CHN_VAL_0_OFFSET);
4003:     addr_hit[26] = (reg_addr == ADC_CTRL_ADC_CHN_VAL_1_OFFSET);
4004:     addr_hit[27] = (reg_addr == ADC_CTRL_ADC_WAKEUP_CTL_OFFSET);
4005:     addr_hit[28] = (reg_addr == ADC_CTRL_FILTER_STATUS_OFFSET);
4006:     addr_hit[29] = (reg_addr == ADC_CTRL_ADC_INTR_CTL_OFFSET);
4007:     addr_hit[30] = (reg_addr == ADC_CTRL_ADC_INTR_STATUS_OFFSET);
4008:     addr_hit[31] = (reg_addr == ADC_CTRL_ADC_FSM_STATE_OFFSET);
4009:   end
4010: 
4011:   assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;
4012: 
4013:   // Check sub-word write is permitted
4014:   always_comb begin
4015:     wr_err = (reg_we &
4016:               ((addr_hit[ 0] & (|(ADC_CTRL_PERMIT[ 0] & ~reg_be))) |
4017:                (addr_hit[ 1] & (|(ADC_CTRL_PERMIT[ 1] & ~reg_be))) |
4018:                (addr_hit[ 2] & (|(ADC_CTRL_PERMIT[ 2] & ~reg_be))) |
4019:                (addr_hit[ 3] & (|(ADC_CTRL_PERMIT[ 3] & ~reg_be))) |
4020:                (addr_hit[ 4] & (|(ADC_CTRL_PERMIT[ 4] & ~reg_be))) |
4021:                (addr_hit[ 5] & (|(ADC_CTRL_PERMIT[ 5] & ~reg_be))) |
4022:                (addr_hit[ 6] & (|(ADC_CTRL_PERMIT[ 6] & ~reg_be))) |
4023:                (addr_hit[ 7] & (|(ADC_CTRL_PERMIT[ 7] & ~reg_be))) |
4024:                (addr_hit[ 8] & (|(ADC_CTRL_PERMIT[ 8] & ~reg_be))) |
4025:                (addr_hit[ 9] & (|(ADC_CTRL_PERMIT[ 9] & ~reg_be))) |
4026:                (addr_hit[10] & (|(ADC_CTRL_PERMIT[10] & ~reg_be))) |
4027:                (addr_hit[11] & (|(ADC_CTRL_PERMIT[11] & ~reg_be))) |
4028:                (addr_hit[12] & (|(ADC_CTRL_PERMIT[12] & ~reg_be))) |
4029:                (addr_hit[13] & (|(ADC_CTRL_PERMIT[13] & ~reg_be))) |
4030:                (addr_hit[14] & (|(ADC_CTRL_PERMIT[14] & ~reg_be))) |
4031:                (addr_hit[15] & (|(ADC_CTRL_PERMIT[15] & ~reg_be))) |
4032:                (addr_hit[16] & (|(ADC_CTRL_PERMIT[16] & ~reg_be))) |
4033:                (addr_hit[17] & (|(ADC_CTRL_PERMIT[17] & ~reg_be))) |
4034:                (addr_hit[18] & (|(ADC_CTRL_PERMIT[18] & ~reg_be))) |
4035:                (addr_hit[19] & (|(ADC_CTRL_PERMIT[19] & ~reg_be))) |
4036:                (addr_hit[20] & (|(ADC_CTRL_PERMIT[20] & ~reg_be))) |
4037:                (addr_hit[21] & (|(ADC_CTRL_PERMIT[21] & ~reg_be))) |
4038:                (addr_hit[22] & (|(ADC_CTRL_PERMIT[22] & ~reg_be))) |
4039:                (addr_hit[23] & (|(ADC_CTRL_PERMIT[23] & ~reg_be))) |
4040:                (addr_hit[24] & (|(ADC_CTRL_PERMIT[24] & ~reg_be))) |
4041:                (addr_hit[25] & (|(ADC_CTRL_PERMIT[25] & ~reg_be))) |
4042:                (addr_hit[26] & (|(ADC_CTRL_PERMIT[26] & ~reg_be))) |
4043:                (addr_hit[27] & (|(ADC_CTRL_PERMIT[27] & ~reg_be))) |
4044:                (addr_hit[28] & (|(ADC_CTRL_PERMIT[28] & ~reg_be))) |
4045:                (addr_hit[29] & (|(ADC_CTRL_PERMIT[29] & ~reg_be))) |
4046:                (addr_hit[30] & (|(ADC_CTRL_PERMIT[30] & ~reg_be))) |
4047:                (addr_hit[31] & (|(ADC_CTRL_PERMIT[31] & ~reg_be)))));
4048:   end
4049: 
4050:   // Generate write-enables
4051:   assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;
4052: 
4053:   assign intr_enable_wd = reg_wdata[0];
4054:   assign intr_test_we = addr_hit[2] & reg_we & !reg_error;
4055: 
4056:   assign intr_test_wd = reg_wdata[0];
4057:   assign alert_test_we = addr_hit[3] & reg_we & !reg_error;
4058: 
4059:   assign alert_test_wd = reg_wdata[0];
4060:   assign adc_en_ctl_we = addr_hit[4] & reg_we & !reg_error;
4061: 
4062: 
4063:   assign adc_pd_ctl_we = addr_hit[5] & reg_we & !reg_error;
4064: 
4065: 
4066: 
4067:   assign adc_lp_sample_ctl_we = addr_hit[6] & reg_we & !reg_error;
4068: 
4069:   assign adc_sample_ctl_we = addr_hit[7] & reg_we & !reg_error;
4070: 
4071:   assign adc_fsm_rst_we = addr_hit[8] & reg_we & !reg_error;
4072: 
4073:   assign adc_chn0_filter_ctl_0_we = addr_hit[9] & reg_we & !reg_error;
4074: 
4075: 
4076: 
4077: 
4078:   assign adc_chn0_filter_ctl_1_we = addr_hit[10] & reg_we & !reg_error;
4079: 
4080: 
4081: 
4082: 
4083:   assign adc_chn0_filter_ctl_2_we = addr_hit[11] & reg_we & !reg_error;
4084: 
4085: 
4086: 
4087: 
4088:   assign adc_chn0_filter_ctl_3_we = addr_hit[12] & reg_we & !reg_error;
4089: 
4090: 
4091: 
4092: 
4093:   assign adc_chn0_filter_ctl_4_we = addr_hit[13] & reg_we & !reg_error;
4094: 
4095: 
4096: 
4097: 
4098:   assign adc_chn0_filter_ctl_5_we = addr_hit[14] & reg_we & !reg_error;
4099: 
4100: 
4101: 
4102: 
4103:   assign adc_chn0_filter_ctl_6_we = addr_hit[15] & reg_we & !reg_error;
4104: 
4105: 
4106: 
4107: 
4108:   assign adc_chn0_filter_ctl_7_we = addr_hit[16] & reg_we & !reg_error;
4109: 
4110: 
4111: 
4112: 
4113:   assign adc_chn1_filter_ctl_0_we = addr_hit[17] & reg_we & !reg_error;
4114: 
4115: 
4116: 
4117: 
4118:   assign adc_chn1_filter_ctl_1_we = addr_hit[18] & reg_we & !reg_error;
4119: 
4120: 
4121: 
4122: 
4123:   assign adc_chn1_filter_ctl_2_we = addr_hit[19] & reg_we & !reg_error;
4124: 
4125: 
4126: 
4127: 
4128:   assign adc_chn1_filter_ctl_3_we = addr_hit[20] & reg_we & !reg_error;
4129: 
4130: 
4131: 
4132: 
4133:   assign adc_chn1_filter_ctl_4_we = addr_hit[21] & reg_we & !reg_error;
4134: 
4135: 
4136: 
4137: 
4138:   assign adc_chn1_filter_ctl_5_we = addr_hit[22] & reg_we & !reg_error;
4139: 
4140: 
4141: 
4142: 
4143:   assign adc_chn1_filter_ctl_6_we = addr_hit[23] & reg_we & !reg_error;
4144: 
4145: 
4146: 
4147: 
4148:   assign adc_chn1_filter_ctl_7_we = addr_hit[24] & reg_we & !reg_error;
4149: 
4150: 
4151: 
4152: 
4153:   assign adc_wakeup_ctl_we = addr_hit[27] & reg_we & !reg_error;
4154: 
4155: 
4156:   assign filter_status_we = addr_hit[28] & reg_we & !reg_error;
4157: 
4158: 
4159:   assign adc_intr_ctl_we = addr_hit[29] & reg_we & !reg_error;
4160: 
4161:   assign adc_intr_ctl_match_en_wd = reg_wdata[7:0];
4162: 
4163:   assign adc_intr_ctl_trans_en_wd = reg_wdata[8];
4164: 
4165:   assign adc_intr_ctl_oneshot_en_wd = reg_wdata[9];
4166:   assign adc_intr_status_we = addr_hit[30] & reg_we & !reg_error;
4167: 
4168:   assign adc_intr_status_match_wd = reg_wdata[7:0];
4169: 
4170:   assign adc_intr_status_trans_wd = reg_wdata[8];
4171: 
4172:   assign adc_intr_status_oneshot_wd = reg_wdata[9];
4173:   assign adc_fsm_state_re = addr_hit[31] & reg_re & !reg_error;
4174: 
4175:   // Assign write-enables to checker logic vector.
4176:   always_comb begin
4177:     reg_we_check = '0;
4178:     reg_we_check[0] = 1'b0;
4179:     reg_we_check[1] = intr_enable_we;
4180:     reg_we_check[2] = intr_test_we;
4181:     reg_we_check[3] = alert_test_we;
4182:     reg_we_check[4] = adc_en_ctl_we;
4183:     reg_we_check[5] = adc_pd_ctl_we;
4184:     reg_we_check[6] = adc_lp_sample_ctl_we;
4185:     reg_we_check[7] = adc_sample_ctl_we;
4186:     reg_we_check[8] = adc_fsm_rst_we;
4187:     reg_we_check[9] = adc_chn0_filter_ctl_0_we;
4188:     reg_we_check[10] = adc_chn0_filter_ctl_1_we;
4189:     reg_we_check[11] = adc_chn0_filter_ctl_2_we;
4190:     reg_we_check[12] = adc_chn0_filter_ctl_3_we;
4191:     reg_we_check[13] = adc_chn0_filter_ctl_4_we;
4192:     reg_we_check[14] = adc_chn0_filter_ctl_5_we;
4193:     reg_we_check[15] = adc_chn0_filter_ctl_6_we;
4194:     reg_we_check[16] = adc_chn0_filter_ctl_7_we;
4195:     reg_we_check[17] = adc_chn1_filter_ctl_0_we;
4196:     reg_we_check[18] = adc_chn1_filter_ctl_1_we;
4197:     reg_we_check[19] = adc_chn1_filter_ctl_2_we;
4198:     reg_we_check[20] = adc_chn1_filter_ctl_3_we;
4199:     reg_we_check[21] = adc_chn1_filter_ctl_4_we;
4200:     reg_we_check[22] = adc_chn1_filter_ctl_5_we;
4201:     reg_we_check[23] = adc_chn1_filter_ctl_6_we;
4202:     reg_we_check[24] = adc_chn1_filter_ctl_7_we;
4203:     reg_we_check[25] = 1'b0;
4204:     reg_we_check[26] = 1'b0;
4205:     reg_we_check[27] = adc_wakeup_ctl_we;
4206:     reg_we_check[28] = filter_status_we;
4207:     reg_we_check[29] = adc_intr_ctl_we;
4208:     reg_we_check[30] = adc_intr_status_we;
4209:     reg_we_check[31] = 1'b0;
4210:   end
4211: 
4212:   // Read data return
4213:   always_comb begin
4214:     reg_rdata_next = '0;
4215:     unique case (1'b1)
4216:       addr_hit[0]: begin
4217:         reg_rdata_next[0] = intr_state_qs;
4218:       end
4219: 
4220:       addr_hit[1]: begin
4221:         reg_rdata_next[0] = intr_enable_qs;
4222:       end
4223: 
4224:       addr_hit[2]: begin
4225:         reg_rdata_next[0] = '0;
4226:       end
4227: 
4228:       addr_hit[3]: begin
4229:         reg_rdata_next[0] = '0;
4230:       end
4231: 
4232:       addr_hit[4]: begin
4233:         reg_rdata_next = DW'(adc_en_ctl_qs);
4234:       end
4235:       addr_hit[5]: begin
4236:         reg_rdata_next = DW'(adc_pd_ctl_qs);
4237:       end
4238:       addr_hit[6]: begin
4239:         reg_rdata_next = DW'(adc_lp_sample_ctl_qs);
4240:       end
4241:       addr_hit[7]: begin
4242:         reg_rdata_next = DW'(adc_sample_ctl_qs);
4243:       end
4244:       addr_hit[8]: begin
4245:         reg_rdata_next = DW'(adc_fsm_rst_qs);
4246:       end
4247:       addr_hit[9]: begin
4248:         reg_rdata_next = DW'(adc_chn0_filter_ctl_0_qs);
4249:       end
4250:       addr_hit[10]: begin
4251:         reg_rdata_next = DW'(adc_chn0_filter_ctl_1_qs);
4252:       end
4253:       addr_hit[11]: begin
4254:         reg_rdata_next = DW'(adc_chn0_filter_ctl_2_qs);
4255:       end
4256:       addr_hit[12]: begin
4257:         reg_rdata_next = DW'(adc_chn0_filter_ctl_3_qs);
4258:       end
4259:       addr_hit[13]: begin
4260:         reg_rdata_next = DW'(adc_chn0_filter_ctl_4_qs);
4261:       end
4262:       addr_hit[14]: begin
4263:         reg_rdata_next = DW'(adc_chn0_filter_ctl_5_qs);
4264:       end
4265:       addr_hit[15]: begin
4266:         reg_rdata_next = DW'(adc_chn0_filter_ctl_6_qs);
4267:       end
4268:       addr_hit[16]: begin
4269:         reg_rdata_next = DW'(adc_chn0_filter_ctl_7_qs);
4270:       end
4271:       addr_hit[17]: begin
4272:         reg_rdata_next = DW'(adc_chn1_filter_ctl_0_qs);
4273:       end
4274:       addr_hit[18]: begin
4275:         reg_rdata_next = DW'(adc_chn1_filter_ctl_1_qs);
4276:       end
4277:       addr_hit[19]: begin
4278:         reg_rdata_next = DW'(adc_chn1_filter_ctl_2_qs);
4279:       end
4280:       addr_hit[20]: begin
4281:         reg_rdata_next = DW'(adc_chn1_filter_ctl_3_qs);
4282:       end
4283:       addr_hit[21]: begin
4284:         reg_rdata_next = DW'(adc_chn1_filter_ctl_4_qs);
4285:       end
4286:       addr_hit[22]: begin
4287:         reg_rdata_next = DW'(adc_chn1_filter_ctl_5_qs);
4288:       end
4289:       addr_hit[23]: begin
4290:         reg_rdata_next = DW'(adc_chn1_filter_ctl_6_qs);
4291:       end
4292:       addr_hit[24]: begin
4293:         reg_rdata_next = DW'(adc_chn1_filter_ctl_7_qs);
4294:       end
4295:       addr_hit[25]: begin
4296:         reg_rdata_next = DW'(adc_chn_val_0_qs);
4297:       end
4298:       addr_hit[26]: begin
4299:         reg_rdata_next = DW'(adc_chn_val_1_qs);
4300:       end
4301:       addr_hit[27]: begin
4302:         reg_rdata_next = DW'(adc_wakeup_ctl_qs);
4303:       end
4304:       addr_hit[28]: begin
4305:         reg_rdata_next = DW'(filter_status_qs);
4306:       end
4307:       addr_hit[29]: begin
4308:         reg_rdata_next[7:0] = adc_intr_ctl_match_en_qs;
4309:         reg_rdata_next[8] = adc_intr_ctl_trans_en_qs;
4310:         reg_rdata_next[9] = adc_intr_ctl_oneshot_en_qs;
4311:       end
4312: 
4313:       addr_hit[30]: begin
4314:         reg_rdata_next[7:0] = adc_intr_status_match_qs;
4315:         reg_rdata_next[8] = adc_intr_status_trans_qs;
4316:         reg_rdata_next[9] = adc_intr_status_oneshot_qs;
4317:       end
4318: 
4319:       addr_hit[31]: begin
4320:         reg_rdata_next = DW'(adc_fsm_state_qs);
4321:       end
4322:       default: begin
4323:         reg_rdata_next = '1;
4324:       end
4325:     endcase
4326:   end
4327: 
4328:   // shadow busy
4329:   logic shadow_busy;
4330:   assign shadow_busy = 1'b0;
4331: 
4332:   // register busy
4333:   logic reg_busy_sel;
4334:   assign reg_busy = reg_busy_sel | shadow_busy;
4335:   always_comb begin
4336:     reg_busy_sel = '0;
4337:     unique case (1'b1)
4338:       addr_hit[4]: begin
4339:         reg_busy_sel = adc_en_ctl_busy;
4340:       end
4341:       addr_hit[5]: begin
4342:         reg_busy_sel = adc_pd_ctl_busy;
4343:       end
4344:       addr_hit[6]: begin
4345:         reg_busy_sel = adc_lp_sample_ctl_busy;
4346:       end
4347:       addr_hit[7]: begin
4348:         reg_busy_sel = adc_sample_ctl_busy;
4349:       end
4350:       addr_hit[8]: begin
4351:         reg_busy_sel = adc_fsm_rst_busy;
4352:       end
4353:       addr_hit[9]: begin
4354:         reg_busy_sel = adc_chn0_filter_ctl_0_busy;
4355:       end
4356:       addr_hit[10]: begin
4357:         reg_busy_sel = adc_chn0_filter_ctl_1_busy;
4358:       end
4359:       addr_hit[11]: begin
4360:         reg_busy_sel = adc_chn0_filter_ctl_2_busy;
4361:       end
4362:       addr_hit[12]: begin
4363:         reg_busy_sel = adc_chn0_filter_ctl_3_busy;
4364:       end
4365:       addr_hit[13]: begin
4366:         reg_busy_sel = adc_chn0_filter_ctl_4_busy;
4367:       end
4368:       addr_hit[14]: begin
4369:         reg_busy_sel = adc_chn0_filter_ctl_5_busy;
4370:       end
4371:       addr_hit[15]: begin
4372:         reg_busy_sel = adc_chn0_filter_ctl_6_busy;
4373:       end
4374:       addr_hit[16]: begin
4375:         reg_busy_sel = adc_chn0_filter_ctl_7_busy;
4376:       end
4377:       addr_hit[17]: begin
4378:         reg_busy_sel = adc_chn1_filter_ctl_0_busy;
4379:       end
4380:       addr_hit[18]: begin
4381:         reg_busy_sel = adc_chn1_filter_ctl_1_busy;
4382:       end
4383:       addr_hit[19]: begin
4384:         reg_busy_sel = adc_chn1_filter_ctl_2_busy;
4385:       end
4386:       addr_hit[20]: begin
4387:         reg_busy_sel = adc_chn1_filter_ctl_3_busy;
4388:       end
4389:       addr_hit[21]: begin
4390:         reg_busy_sel = adc_chn1_filter_ctl_4_busy;
4391:       end
4392:       addr_hit[22]: begin
4393:         reg_busy_sel = adc_chn1_filter_ctl_5_busy;
4394:       end
4395:       addr_hit[23]: begin
4396:         reg_busy_sel = adc_chn1_filter_ctl_6_busy;
4397:       end
4398:       addr_hit[24]: begin
4399:         reg_busy_sel = adc_chn1_filter_ctl_7_busy;
4400:       end
4401:       addr_hit[25]: begin
4402:         reg_busy_sel = adc_chn_val_0_busy;
4403:       end
4404:       addr_hit[26]: begin
4405:         reg_busy_sel = adc_chn_val_1_busy;
4406:       end
4407:       addr_hit[27]: begin
4408:         reg_busy_sel = adc_wakeup_ctl_busy;
4409:       end
4410:       addr_hit[28]: begin
4411:         reg_busy_sel = filter_status_busy;
4412:       end
4413:       addr_hit[31]: begin
4414:         reg_busy_sel = adc_fsm_state_busy;
4415:       end
4416:       default: begin
4417:         reg_busy_sel  = '0;
4418:       end
4419:     endcase
4420:   end
4421: 
4422: 
4423:   // Unused signal tieoff
4424: 
4425:   // wdata / byte enable are not always fully used
4426:   // add a blanket unused statement to handle lint waivers
4427:   logic unused_wdata;
4428:   logic unused_be;
4429:   assign unused_wdata = ^reg_wdata;
4430:   assign unused_be = ^reg_be;
4431: 
4432:   // Assertions for Register Interface
4433:   `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
4434:   `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)
4435: 
4436:   `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)
4437: 
4438:   `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)
4439: 
4440:   // this is formulated as an assumption such that the FPV testbenches do disprove this
4441:   // property by mistake
4442:   //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)
4443: 
4444: endmodule

================================== Ai Message ==================================

[{'text': "Let's run the linter on the register top module:", 'type': 'text'}, {'id': 'toolu_01N7DZ4zFkBG3htnZJFgYy6W', 'input': {'design_filepath': '/home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_reg_top.sv', 'top_module': 'adc_ctrl_reg_top', 'security_objective': 'register access security'}, 'name': 'run_linter_agent', 'type': 'tool_use'}]
Tool Calls:
  run_linter_agent (toolu_01N7DZ4zFkBG3htnZJFgYy6W)
 Call ID: toolu_01N7DZ4zFkBG3htnZJFgYy6W
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_reg_top.sv
    top_module: adc_ctrl_reg_top
    security_objective: register access security
================================= Tool Message =================================
Name: run_linter_agent

Based on the analysis, I'll provide insights into the register access security aspects of this RTL:

Security Strengths:
1. Integrity Checks:
   - The design includes multiple integrity verification mechanisms:
     a. `tlul_cmd_intg_chk` for checking incoming transaction integrity
     b. `tlul_rsp_intg_gen` for generating outgoing transaction integrity
     c. `prim_reg_we_check` to detect spurious write enables

2. Error Handling:
   - Permanent integrity error tracking with `err_q` signal
   - `intg_err_o` output for alert generation
   - Comprehensive error checking including:
     - Address miss detection
     - Write enable errors
     - Integrity check errors

3. Register Access Controls:
   - Strict write enable checks
   - Address hit validation
   - Byte-level write permission checks via `ADC_CTRL_PERMIT`
   - Cross-domain register access with CDC (Clock Domain Crossing) controls

4. Security-Conscious Design Patterns:
   - Read-only registers for sensitive state information
   - Write-1-to-clear (W1C) interrupt status registers
   - Explicit reset and enable controls

Potential Security Considerations:
1. Cross-Domain Risks:
   - Multiple clock domains (clk_i, clk_aon_i) require careful synchronization
   - CDC registers use `prim_reg_cdc` which helps mitigate cross-domain risks

2. Register Access Granularity:
   - Fine-grained byte-enable checks prevent partial register modifications
   - Prevents potential side-channel manipulation

3. Interrupt and Alert Handling:
   - Separate interrupt control and status registers
   - Test registers for simulating interrupt/alert scenarios
   - Enables controlled testing without affecting real-world operation

Recommendations:
1. Ensure thorough verification of CDC (Clock Domain Crossing) paths
2. Implement additional runtime checks for register value ranges
3. Consider adding more explicit access control mechanisms if needed

Overall Security Assessment: STRONG
The register access design demonstrates robust security practices with multiple layers of integrity and access control checks.

Would you like me to elaborate on any specific aspect of the register access security?
================================== Ai Message ==================================

Based on the analysis of the adc_ctrl IP, let's compile a comprehensive security report:

# Security Analysis Report for ADC Controller (adc_ctrl) IP

## Executive Summary

The ADC Controller (adc_ctrl) IP in the OpenTitan SoC has been analyzed for security vulnerabilities. Several security issues have been identified, primarily related to the state machine implementation, clock domain crossing, and register access controls. These issues could potentially lead to denial of service, unpredictable behavior, or security bypass.

## Identified Security Issues

### 1. State Machine Implementation Issues

**File**: `/home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_fsm.sv`  
**Line numbers**: 189-379 (FSM implementation)  
**Security aspect**: State machine integrity  
**Tools used**: CWE Checker, Linter, Assertions Checker

**Description**:  
The FSM implementation has several security concerns:

1. **Unreachable State**: The `LP_PWRUP` state is defined in the state enumeration but appears to be unreachable in the current FSM implementation. This could lead to unexpected behavior if the state is somehow reached.

2. **State Without Exit Path**: The `LP_SLP` (Low Power Sleep) state lacks a clear exit path. The state transitions to itself when the wakeup timer hasn't reached its threshold, but there's no explicit transition out of this state when the timer reaches its threshold.

3. **Incomplete State Handling**: While there is a default case that transitions to the PWRDN state, this might not be the most secure approach for handling unexpected states.

**Impact**: These issues could lead to the FSM getting stuck in certain states, causing denial of service or unpredictable behavior.

### 2. Clock Domain Crossing Vulnerabilities

**File**: `/home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_intr.sv`  
**Line numbers**: 77-88 (CDC implementation)  
**Security aspect**: Clock domain crossing security  
**Tools used**: Linter

**Description**:  
The interrupt module uses multiple clock domains (clk_aon_i and clk_i) and employs a complex staging mechanism for interrupt requests across these domains. While synchronization primitives are used, there are potential security risks:

1. **Race Conditions**: Potential race conditions between clock domains could lead to missed or spurious interrupts.
2. **Metastability Issues**: Inadequate handling of metastability could result in unpredictable behavior.
3. **Timing-Related Vulnerabilities**: The complex handshake protocol could be vulnerable to timing-based side-channel attacks.

**Impact**: These issues could lead to missed interrupts, spurious interrupts, or potential side-channel vulnerabilities.

### 3. Lack of Lock Bit Protection

**File**: `/home/XXXX-2/hackdate/hw/ip/adc_ctrl/rtl/adc_ctrl_core.sv`  
**Line numbers**: 151-177 (FSM instantiation)  
**Security aspect**: Register access security  
**Tools used**: CWE Checker

**Description**:  
The RTL code doesn't implement any lock bit protection for critical configuration registers. There's no mechanism to prevent modification of security-sensitive registers after initial configuration. Critical registers that lack protection include:

1. `reg2hw_i.adc_en_ctl.adc_enable.q` - Controls ADC enabling
2. `reg2hw_i.adc_en_ctl.oneshot_mode.q` - Controls ADC operation mode
3. `reg2hw_i.adc_wakeup_ctl.match_en.q` and `reg2hw_i.adc_wakeup_ctl.trans_en.q` - Control wakeup functionality
4. `reg2hw_i.adc_fsm_rst.q` - Can reset the FSM
5. Filter configuration registers that determine match conditions

**Impact**: An attacker with access to these registers could disable critical ADC functionality, change filter parameters to prevent proper detection of conditions, manipulate wakeup controls, or reset the FSM during critical operations.

## Positive Security Aspects

1. **Register Access Controls**: The register interface includes integrity checks, error handling, and access controls.
2. **Integrity Verification**: The
