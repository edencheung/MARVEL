================================ System Message ================================


    You are a supervisor agent in a multi-agent system focused on identifying hardware security vulnerabilities in RTL code. 
    Your objective is to analyze the given SoC and generate a detailed security report.

    You have access to the following tools: ['run_anomaly_detector_agent', 'run_verilator_agent', 'run_llm_cwe_checker_agent', 'run_assertions_checker_agent', 'run_linter_agent', 'run_similar_bug_agent', 'list_dir', 'read_file', 'read_file_with_line_numbers']. Each tool specializes in a specific task:

    - Verilator Agent: Runs Verilator tests on the given IP and analyzes failing test reports to detect potential security issues.
    - Assertion Agent: Takes a Verilog file, a top module name, and a security aspect to check. It generates and runs security assertions on the RTL. Failing assertions indicate potential issues that require further localization.
    - Linter Agent: Accepts a Verilog file, top module, and security focus. It selects relevant lint checks and flags design violations tied to security concerns.
    - CWE Agent: Given a Verilog file, a top module, and a security aspect, this agent maps the RTL code to relevant CWEs and detects CWE-related vulnerabilities.
    - Similar Bug Agent: Accepts a file path and a line number (where a bug was found) to locate similar patterns or recurring bugs throughout the RTL code.

    Instructions for analysis:

    - Read the documentataion to identify security features and register interfaces policies.
    - Use Verilator, Assertion, Anomaly and Linter agents to uncover initial issues in the design.
    - If a bug is detected but not localized, use the CWE Agent to further inspect the related security aspect in the surrounding RTL.
    - After detecting any bugs, use the Similar Bug Agent to scan similar files (of the same or of different IPs) for similar vulnerabilities.

    Output Format:

    - For each identified issue, report:
    - File name
    - Line number(s)
    - Brief description of the issue
    - Security aspect affected
    - Tools used to identify the issue

    When your analysis is complete, end your response with "END".
    
================================ Human Message =================================

Identify security issues in the hmac IP of the OpenTitan SoC, located at /home/XXXX-2/hackdate.

    - All IPs are located in the 'hw/ip' directory.
    - RTL code for each IP is located in its 'rtl' subdirectory, with source files having the '.sv' extension.
        - reg_top files contain the register interface for the IP.
        - control/fsm files contain the control logic for the IP.
        - core files contain the core logic for the IP.
    - Documentation files (.md) are located in the 'doc' directories of each IP.
        - theory_of_operation explains the properties of the IP and its security features.
        - registers.md files contain the register interface and its read/write access policies.
    - Ignore '.core' files; they are used by build tools and are not relevant for security analysis.

    Focus on the hmac IP and make sure to analyze it thoroughly.

    First, identify the relevant security properties and read/write policies of the register interfaces from the documentation. 
    Then, use all available tools to perform a comprehensive security analysis on the RTL code.
    
================================== Ai Message ==================================
Tool Calls:
  list_dir (call_A9va38TMYPHek3XrCn6gT9J2)
 Call ID: call_A9va38TMYPHek3XrCn6gT9J2
  Args:
    dir_path: /home/XXXX-2/hackdate/hw/ip/hmac/doc
================================= Tool Message =================================
Name: list_dir

Files in /home/XXXX-2/hackdate/hw/ip/hmac/doc:
checklist.md hmac_block_diagram.svg hmac_dataflow.svg interfaces.md message_padding.svg programmers_guide.md registers.md sha2_block_diagram.svg theory_of_operation.md

Directories in /home/XXXX-2/hackdate/hw/ip/hmac/doc:

================================== Ai Message ==================================
Tool Calls:
  read_file (call_cn5qmAd2XUsh9tPKJcbvf2j4)
 Call ID: call_cn5qmAd2XUsh9tPKJcbvf2j4
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/hmac/doc/theory_of_operation.md
================================= Tool Message =================================
Name: read_file

# Theory of Operation

## Block Diagram

![HMAC Block Diagram](../doc/hmac_block_diagram.svg)

The HMAC block diagram above shows that the HMAC core converts the secret key registers into an inner padded key and an outer padded key which are fed to the SHA-2 hash engine (which is a SHA-2 engine primitive instantiated with the multi-mode feature enabled) when appropriate.
The module also feeds the result of the first round message (which uses the inner padded key) from the SHA-2 hash engine into the 32x32b message FIFO for the second round (which uses the outer padded key).
The message length is automatically updated to reflect the size of the outer padded key and first round digest result for the second round.
See [Design Details](#design-details) for more information.

![SHA-2 Block Diagram](../doc/sha2_block_diagram.svg)

[sha256-spec]: XXXX

The SHA-2 engine block diagram shows the message scheduling FIFO array, hash registers, digest registers, and SHA-2 compression function inside SHA-2 engine.
The message scheduling FIFO is not software accessible but is fed from the 32x32b message FIFO seen in the HMAC block diagram via the HMAC core.
The HMAC core can forward the message directly from the 32x32b message FIFO if HMAC is not enabled.
The message words are padded with the message length appended to fit either the 512-bit or 1024-bit block size (depending on the configured digest size) as described in the [SHA-256
specification][sha256-spec].

With the 512-bit block (for SHA-2 256), the compression function runs 64 rounds to calculate the block hash, which is stored in the hash registers above.
After 64 rounds are completed, the SHA-2 256 updates the digest registers with the addition of the hash result and the previous digest registers.
With the 1024-bit block (for SHA-2 384/512), the compression function runs 80 rounds instead.
SHA-2 384 is a truncated version of SHA-2 512 where the last 128 bits of the final digest output are truncated to reduce the digest size to 384 bits.


## Design Details

### SHA-2 message feed and pad

A message is fed via a memory-mapped message FIFO.
Any write access to the memory-mapped window [`MSG_FIFO`](registers.md#msg_fifo) updates the message FIFO.
If the FIFO is full, the HMAC block will block any writes leading to back-pressure on the interconnect (as opposed to dropping those writes or overwriting existing FIFO contents).
It is recommended to avoid this back-pressure by not writing to the memory-mapped message FIFO when it is full.
To avoid doing so, software can read the [`STATUS.fifo_full`](registers.md#status) register.

The logic assumes the input message is little-endian.
It converts the byte order of the word right before writing to SHA-2 storage as SHA-2 treats the incoming message as big-endian.
If SW wants to convert the message byte order, SW should set [`CFG.endian_swap`](registers.md#cfg) to **1**.
The byte order of the digest registers, from [`DIGEST_0-DIGEST_15`](registers.md#digest) can be configured with [`CFG.digest_swap`](registers.md#cfg--digest_swap).

See the table below:

```
Input Msg #0: 010203h
Input Msg #1: 0405h
```

endian_swap     | 0         | 1
----------------|-----------|-----------
Push to SHA2 #0 | 03020105h | 01020304h
Push to SHA2 #1 | 00000004h | 00000005h


Small writes to [`MSG_FIFO`](registers.md#msg_fifo) are coalesced into 32-bit words by the [packer logic]({{< relref "hw/ip/prim/doc/prim_packer" >}}).
These words are fed into the internal message scheduling FIFO.
While passing writes to the packer logic, the block also counts the number of bytes that are being passed.
This computes the received message length, which is used in the HMAC and SHA-2 hash computation logic.

The SHA-2 engine computes an intermediate hash for every 512-bit or 1024-bit block depending on the configured digest size.
The message must be padded to fill the 512/1024-bit blocks.
This is done with an initial **1** bit after the actual message bits, followed by enough **0** padding bits, and then the 64/128-bit message length at the end of the block.
The number of **0** padding bits should be enough such that the full block size (512 or 1024 bits) is achieved.
The [SHA-256 specification][sha256-spec] describes this in more detail.
An example is shown below.
The padding logic handles this so software only needs to write the actual message bits into the message FIFO.

![SHA-2 Message Padding](../doc/message_padding.svg)

For example, for SHA-2 256, if the message is empty, the message length is 64-bit 0.
In this case, the padding logic gives `0x80000000` into the SHA-2 module first.
Then it sends (512 - 32 - 64)/32, 13 times of `0x00000000` for Padding `0x00`.
Lastly, it returns the message length which is 64-bit `0x00000000_00000000`.
If incomplete words are written, the packet logic appends `0x80` in the proper byte
location, such as `0xXX800000` for the message length % 4B == 1 case.
This similarly occurs for SHA-2 384/512 but with a 128-bit message length and block size of 1024 bits.

### SHA-2 computation

For SHA-2 256, the SHA-2 engine receives 16 32-bit words from the message FIFO or the HMAC core, which get padded into 16 64-bit words for the SHA-2 engine (upper 32 bits of each data word are all-zero padded), and then begin 64 rounds of the hash computation which is also called *compression*.
Alternatively for SHA-2 384/512, the SHA-2 engine receives 32 32-bit words from message FIFO, which get packed into 16 64-bit words for the SHA-2 engine, and then begin the 80 compression rounds.
In each round, the compression function fetches a 64-bit word from the buffer and computes the internal variables.
The first 16 rounds are fed by the words from the message FIFO or the HMAC core.
Input for later rounds comes from shuffling the given 512/1024-bit block.
Details are well described in [Wikipedia][sha2-wikipedia] and the [SHA-256 specification][sha256-spec].

[sha2-wikipedia]: XXXX

With the given hash values, 4-byte (or 8-byte) message word, and round constants, the compression function computes the next round hash values.
The round constants for the different digest sizes are hard-wired in the design.
After the compression at the last round is finished, the resulting hash values are added into the digest.
The digest, again, is used as initial hash values for the next block compression.
During the compression rounds, it doesn't fetch data from the message FIFO.
The software can push up to 16 (or 32 for SHA-2 384/512) entries to the FIFO for the next hash computation.

### HMAC computation

![Two steps of HMAC](../doc/hmac_dataflow.svg)

HMAC can be used with any hash algorithm but this version of HMAC IP uses SHA-2 256/384/512.
The first phase of HMAC calculates the SHA-2 hash of the inner secret key concatenated with the actual message to be authenticated.
This inner secret key is created with the 128/256/384/512/1024-bit (hashed) secret key (depending on the configured key length) and `0x36` padding to complete the corresponding block size of the configured digest size.
For example, for SHA-2 256 with 256-bit key, 512-bit inner secret key is created with the 256-bit secret key with 256-bit zero padding, XORed with 64{`0x36`}.

```verilog
    inner_pad_key = {key[255:0], 256'h0} ^ {64{8'h36}} // big-endian
```

The message length used in the SHA-2 module is calculated by the HMAC core by adding the block size to the original message length (to account for the length of `inner_pad_key`, which has been prepended to the message).

The first round digest is fed into the second round in HMAC.
The second round computes the hash of the outer secret key concatenated with the first round digest.
In case of SHA-2 256 with 256-bit key, as the digest result is 256-bit, it must be zero-padded to fit into 512-bit block size.

```verilog
    outer_pad_key = {key[255:0], 256'h0} ^ {64{8'h5c}} // big-endian
```

In the second round, the message length is a fixed 768 bits (512-bit size of outer secret key + 256-bit first round digest size).

HMAC supports a secret key of length 128/256/384/512/1024-bit, so long as the key length does not exceed the block size of the configured digest, i.e., for SHA-2 256 a maximum length of 512-bit key is supported.
The byte order of the key registers is big-endian by default, can be swapped to little endian by setting [`CFG.key_swap`](registers.md#cfg--key_swap) to 1.
To support any arbitrary key length, the software should configure the HMAC to the next largest supported key length, e.g. for an 80-bit key, HMAC should be configured with an 128-bit key length and fed with the 80-bit key.
It is also up to the software to shrink the key to the supported key length (up to 512-bit for SHA-2 256 and up to 1024-bit for SHA-2 384/512) using a hash function when setting up the HMAC.
For example, common key sizes may be 2048-bit or 4096-bit.
Software is expected to hash these into the supported key length and write the hashed result as the configured key to the HMAC IP.

### Performance in SHA-2 mode and HMAC mode

The SHA-2 256 hash algorithm computes 512 bits of data at a time.
The first 16 rounds need the actual 16 x 32-bit message and the following 48 rounds need some value derived from the message.

In these 48 rounds, the software can feed the next 16 x 32-bit message block.
But, once the FIFO gets full, the software cannot push more data until the current block is processed.
This version of the IP fetches the next 16 x 32-bit message into the internal message scheduling array only after completing the current block.
As such, it takes 80 cycles to complete a block.
The effective throughput considering this is `64 byte / 80 clk` or `16 clk / 80 clk`, 20% of the maximum throughput.
For instance, if the clock frequency is 100MHz, the SHA-2 256 can hash out 80MB/s at most.

For SHA-2 384/512, the algorithm computes 1024 bits of data a time and runs for 80 rounds where the first 16 rounds consume the actual 16 x 64-bit message.
It takes 96 cycles to complete a 1024-bit block. If the clock frequency is 100MHz, the SHA-2 384/512 can hash out 133MB/s at most.

This throughput could be enhanced in a future version by feeding the message into the internal buffer when the round hits 48, eliminating the extra 16 cycles to feed the message after completing a block.

If HMAC mode is turned on, it introduces extra latency due to the second round of computing the final hash of the outer key and the result of the first round using the inner key.
This adds an extra 240 cycles (80 for the inner key, 80 for the outer key, and 80 for the result of the first round) to complete a HMAC SHA-2 256 digest of a message.
For instance, if an empty message is given then it takes 360 cycles (80 for msg itself and 240 for the extra) to get the HMAC authentication token.

### MSG_FIFO

The MSG_FIFO in the HMAC IP has a wide address range not just one 4 byte address.
Any writes to the address range go into the single entry point of the `prim_packer`.
Then `prim_packer` compacts the data into the word-size if not a word-write then writes to the MSG_FIFO.
This is different from a conventional memory-mapped FIFO.

By having wide address range pointing to a single entry point, the FIFO can free software from the fixed address restriction.
For instance, the core can use "store multiple" commands to feed the message fifo efficiently.
Also, a DMA engine which might not have the ability to be configured to the fixed write and incremental read may benefit from this behavior.

================================== Ai Message ==================================
Tool Calls:
  read_file (call_5EDx7vSqD6NpNFND917sO8dK)
 Call ID: call_5EDx7vSqD6NpNFND917sO8dK
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/hmac/doc/registers.md
================================= Tool Message =================================
Name: read_file

# Registers

<!-- BEGIN CMDGEN util/regtool.py -d ./hw/ip/hmac/data/hmac.hjson -->
## Summary

| Name                                         | Offset   |   Length | Description                                                          |
|:---------------------------------------------|:---------|---------:|:---------------------------------------------------------------------|
| hmac.[`INTR_STATE`](#intr_state)             | 0x0      |        4 | Interrupt State Register                                             |
| hmac.[`INTR_ENABLE`](#intr_enable)           | 0x4      |        4 | Interrupt Enable Register                                            |
| hmac.[`INTR_TEST`](#intr_test)               | 0x8      |        4 | Interrupt Test Register                                              |
| hmac.[`ALERT_TEST`](#alert_test)             | 0xc      |        4 | Alert Test Register                                                  |
| hmac.[`CFG`](#cfg)                           | 0x10     |        4 | HMAC Configuration register.                                         |
| hmac.[`CMD`](#cmd)                           | 0x14     |        4 | HMAC command register                                                |
| hmac.[`STATUS`](#status)                     | 0x18     |        4 | HMAC Status register                                                 |
| hmac.[`ERR_CODE`](#err_code)                 | 0x1c     |        4 | HMAC Error Code                                                      |
| hmac.[`WIPE_SECRET`](#wipe_secret)           | 0x20     |        4 | Clear internal secret registers.                                     |
| hmac.[`KEY_0`](#key)                         | 0x24     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_1`](#key)                         | 0x28     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_2`](#key)                         | 0x2c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_3`](#key)                         | 0x30     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_4`](#key)                         | 0x34     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_5`](#key)                         | 0x38     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_6`](#key)                         | 0x3c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_7`](#key)                         | 0x40     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_8`](#key)                         | 0x44     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_9`](#key)                         | 0x48     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_10`](#key)                        | 0x4c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_11`](#key)                        | 0x50     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_12`](#key)                        | 0x54     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_13`](#key)                        | 0x58     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_14`](#key)                        | 0x5c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_15`](#key)                        | 0x60     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_16`](#key)                        | 0x64     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_17`](#key)                        | 0x68     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_18`](#key)                        | 0x6c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_19`](#key)                        | 0x70     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_20`](#key)                        | 0x74     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_21`](#key)                        | 0x78     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_22`](#key)                        | 0x7c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_23`](#key)                        | 0x80     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_24`](#key)                        | 0x84     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_25`](#key)                        | 0x88     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_26`](#key)                        | 0x8c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_27`](#key)                        | 0x90     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_28`](#key)                        | 0x94     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_29`](#key)                        | 0x98     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_30`](#key)                        | 0x9c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_31`](#key)                        | 0xa0     |        4 | HMAC Secret Key                                                      |
| hmac.[`DIGEST_0`](#digest)                   | 0xa4     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_1`](#digest)                   | 0xa8     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_2`](#digest)                   | 0xac     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_3`](#digest)                   | 0xb0     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_4`](#digest)                   | 0xb4     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_5`](#digest)                   | 0xb8     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_6`](#digest)                   | 0xbc     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_7`](#digest)                   | 0xc0     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_8`](#digest)                   | 0xc4     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_9`](#digest)                   | 0xc8     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_10`](#digest)                  | 0xcc     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_11`](#digest)                  | 0xd0     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_12`](#digest)                  | 0xd4     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_13`](#digest)                  | 0xd8     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_14`](#digest)                  | 0xdc     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_15`](#digest)                  | 0xe0     |        4 | Digest output.                                                       |
| hmac.[`MSG_LENGTH_LOWER`](#msg_length_lower) | 0xe4     |        4 | Received Message Length calculated by the HMAC in bits [31:0]        |
| hmac.[`MSG_LENGTH_UPPER`](#msg_length_upper) | 0xe8     |        4 | Received Message Length calculated by the HMAC in bits [63:32]       |
| hmac.[`MSG_FIFO`](#msg_fifo)                 | 0x1000   |     4096 | Message FIFO. Any write to this window will be appended to the FIFO. |

## INTR_STATE
Interrupt State Register
- Offset: `0x0`
- Reset default: `0x0`
- Reset mask: `0x7`

### Fields

```wavejson
{"reg": [{"name": "hmac_done", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"name": "fifo_empty", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "hmac_err", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 120}}
```

|  Bits  |  Type  |  Reset  | Name                                  |
|:------:|:------:|:-------:|:--------------------------------------|
|  31:3  |        |         | Reserved                              |
|   2    |  rw1c  |   0x0   | [hmac_err](#intr_state--hmac_err)     |
|   1    |   ro   |   0x0   | [fifo_empty](#intr_state--fifo_empty) |
|   0    |  rw1c  |   0x0   | [hmac_done](#intr_state--hmac_done)   |

### INTR_STATE . hmac_err
HMAC error has occurred. ERR_CODE register shows which error occurred.

### INTR_STATE . fifo_empty
The message FIFO is empty.
This interrupt is raised only if the message FIFO is actually writable by software, i.e., if all of the following conditions are met:
i) The HMAC block is not running in HMAC mode and performing the second round of computing the final hash of the outer key as well as the result of the first round using the inner key.
ii) Software has not yet written the Process or Stop command to finish the hashing operation.
For the interrupt to be raised, the message FIFO must also have been full previously.
Otherwise, the hardware empties the FIFO faster than software can fill it and there is no point in interrupting the software to inform it about the message FIFO being empty.

### INTR_STATE . hmac_done
HMAC/SHA-2 has completed.

## INTR_ENABLE
Interrupt Enable Register
- Offset: `0x4`
- Reset default: `0x0`
- Reset mask: `0x7`

### Fields

```wavejson
{"reg": [{"name": "hmac_done", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "fifo_empty", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "hmac_err", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 120}}
```

|  Bits  |  Type  |  Reset  | Name       | Description                                                          |
|:------:|:------:|:-------:|:-----------|:---------------------------------------------------------------------|
|  31:3  |        |         |            | Reserved                                                             |
|   2    |   rw   |   0x0   | hmac_err   | Enable interrupt when [`INTR_STATE.hmac_err`](#intr_state) is set.   |
|   1    |   rw   |   0x0   | fifo_empty | Enable interrupt when [`INTR_STATE.fifo_empty`](#intr_state) is set. |
|   0    |   rw   |   0x0   | hmac_done  | Enable interrupt when [`INTR_STATE.hmac_done`](#intr_state) is set.  |

## INTR_TEST
Interrupt Test Register
- Offset: `0x8`
- Reset default: `0x0`
- Reset mask: `0x7`

### Fields

```wavejson
{"reg": [{"name": "hmac_done", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "fifo_empty", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "hmac_err", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 120}}
```

|  Bits  |  Type  |  Reset  | Name       | Description                                                   |
|:------:|:------:|:-------:|:-----------|:--------------------------------------------------------------|
|  31:3  |        |         |            | Reserved                                                      |
|   2    |   wo   |   0x0   | hmac_err   | Write 1 to force [`INTR_STATE.hmac_err`](#intr_state) to 1.   |
|   1    |   wo   |   0x0   | fifo_empty | Write 1 to force [`INTR_STATE.fifo_empty`](#intr_state) to 1. |
|   0    |   wo   |   0x0   | hmac_done  | Write 1 to force [`INTR_STATE.hmac_done`](#intr_state) to 1.  |

## ALERT_TEST
Alert Test Register
- Offset: `0xc`
- Reset default: `0x0`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "fatal_fault", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 130}}
```

|  Bits  |  Type  |  Reset  | Name        | Description                                      |
|:------:|:------:|:-------:|:------------|:-------------------------------------------------|
|  31:1  |        |         |             | Reserved                                         |
|   0    |   wo   |   0x0   | fatal_fault | Write 1 to trigger one alert event of this kind. |

## CFG
HMAC Configuration register.

The register is updated when the engine is in Idle.
If the software updates the register while the engine computes the hash, the updated value is discarded.
- Offset: `0x10`
- Reset default: `0x4100`
- Reset mask: `0x7fff`

### Fields

```wavejson
{"reg": [{"name": "hmac_en", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "sha_en", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "endian_swap", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "digest_swap", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "key_swap", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "digest_size", "bits": 4, "attr": ["rw"], "rotate": -90}, {"name": "key_length", "bits": 6, "attr": ["rw"], "rotate": 0}, {"bits": 17}], "config": {"lanes": 1, "fontsize": 10, "vspace": 130}}
```

|  Bits  |  Type  |  Reset  | Name                             |
|:------:|:------:|:-------:|:---------------------------------|
| 31:15  |        |         | Reserved                         |
|  14:9  |   rw   |  0x20   | [key_length](#cfg--key_length)   |
|  8:5   |   rw   |   0x8   | [digest_size](#cfg--digest_size) |
|   4    |   rw   |   0x0   | [key_swap](#cfg--key_swap)       |
|   3    |   rw   |   0x0   | [digest_swap](#cfg--digest_swap) |
|   2    |   rw   |   0x0   | [endian_swap](#cfg--endian_swap) |
|   1    |   rw   |    x    | [sha_en](#cfg--sha_en)           |
|   0    |   rw   |    x    | [hmac_en](#cfg--hmac_en)         |

### CFG . key_length
Key length configuration.

This is a 6-bit one-hot encoded field to configure the key length for HMAC.
The HMAC supports key lengths of 128-bit, 256-bit, 384-bit, 512-bit and 1024-bit, as long as the key length is not greater than the block size: up to 1024-bit for SHA-2 384/512 and up to 512-bit for SHA-2 256.
The value of this register is irrelevant when only SHA-2 (not keyed HMAC) is configured.
However, for HMAC mode (`hmac_en == 1`), when HMAC is triggered to start while [`KEY_LENGTH`](#key_length) holds `Key_None` or [`KEY_LENGTH`](#key_length) holds `Key_1024` for [`DIGEST_SIZE`](#digest_size) = `SHA2_256`, starting is blocked and an error is signalled to SW.

| Value   | Name     | Description                                                                                                                                                                                                                                                                                                                                                                  |
|:--------|:---------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0x01    | Key_128  | 6'b00_0001: 128-bit secret key.                                                                                                                                                                                                                                                                                                                                              |
| 0x02    | Key_256  | 6'b00_0010: 256-bit secret key.                                                                                                                                                                                                                                                                                                                                              |
| 0x04    | Key_384  | 6'b00_0100: 384-bit secret key.                                                                                                                                                                                                                                                                                                                                              |
| 0x08    | Key_512  | 6'b00_1000: 512-bit secret key.                                                                                                                                                                                                                                                                                                                                              |
| 0x10    | Key_1024 | 6'b01_0000: 1024-bit secret key.                                                                                                                                                                                                                                                                                                                                             |
| 0x20    | Key_None | 6'b10_0000: Unsupported/invalid values and all-zero values are mapped to Key_None. With this value, when HMAC is triggered to start operation (via `hash_start` or `hash_continue`), it will be blocked from starting and an error is signalled to the SW. If only unkeyed SHA-2 is configured (`hmac_en == 0`), starting is not blocked, since this does not require a key. |

Other values are reserved.

### CFG . digest_size
Digest size configuration.

This is a 4-bit one-hot encoded field to select digest size for either HMAC or SHA-2.
Invalid/unsupported values, i.e., values that don't correspond to SHA2_256, SHA2_384, or SHA2_512, are mapped to SHA2_None.

| Value   | Name      | Description                                                                                                                                                                                                                                                    |
|:--------|:----------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0x1     | SHA2_256  | 4'b0001: SHA-2 256 digest.                                                                                                                                                                                                                                     |
| 0x2     | SHA2_384  | 4'b0010: SHA-2 384 digest.                                                                                                                                                                                                                                     |
| 0x4     | SHA2_512  | 4'b0100: SHA-2 512 digest.                                                                                                                                                                                                                                     |
| 0x8     | SHA2_None | 4'b1000: Unsupported/invalid values and all-zero values are mapped to SHA2_None. With this value, when HMAC/SHA-2 is triggered to start operation (via `hash_start` or `hash_continue`), it will be blocked from starting and an error is signalled to the SW. |

Other values are reserved.

### CFG . key_swap
Key register byte swap.

If 1 the endianness of each KEY_* register is swapped. Default value (value 0) is big endian representation of the KEY_* CSRs.

### CFG . digest_swap
Digest register byte swap.

If 1 the value in each digest output register is converted to big-endian byte order.
This setting does not affect the order of the digest output registers, [`DIGEST_0`](#digest_0) still contains the first 4 bytes of the digest.

### CFG . endian_swap
Endian swap.

If 0, each value will be added to the message in little-endian byte order.
The value is written to MSG_FIFO same to the SW writes.
If 1, then each individual multi-byte value, regardless of its alignment, written to [`MSG_FIFO`](#msg_fifo) will be added to the message in big-endian byte order.
A message written to [`MSG_FIFO`](#msg_fifo) one byte at a time will not be affected by this setting.
From a hardware perspective byte swaps are performed on a TL-UL word granularity.

### CFG . sha_en
SHA-2 enable.

 If 0, the SHA engine will not initiate compression, this is used to stop operation of the SHA-2 engine until configuration has been done.
 When the SHA-2 engine is disabled the digest is cleared.

### CFG . hmac_en
HMAC datapath enable.

If this bit is 1, HMAC operates when `hash_start` toggles.

## CMD
HMAC command register
- Offset: `0x14`
- Reset default: `0x0`
- Reset mask: `0xf`

### Fields

```wavejson
{"reg": [{"name": "hash_start", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"name": "hash_process", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"name": "hash_stop", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"name": "hash_continue", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"bits": 28}], "config": {"lanes": 1, "fontsize": 10, "vspace": 150}}
```

|  Bits  |  Type  |  Reset  | Name                                 |
|:------:|:------:|:-------:|:-------------------------------------|
|  31:4  |        |         | Reserved                             |
|   3    | r0w1c  |    x    | [hash_continue](#cmd--hash_continue) |
|   2    | r0w1c  |    x    | [hash_stop](#cmd--hash_stop)         |
|   1    | r0w1c  |    x    | [hash_process](#cmd--hash_process)   |
|   0    | r0w1c  |    x    | [hash_start](#cmd--hash_start)       |

### CMD . hash_continue
When 1 is written to this field, SHA-2 or HMAC will continue hashing based on the current hash in the digest registers and the message length, which both have to be restored to switch context.

### CMD . hash_stop
When 1 is written to this field, SHA-2 or HMAC will afterwards set the `hmac_done` interrupt as soon as the current block has been hashed.
The hash can then be read from the registers [`DIGEST_0`](#digest_0) to [`DIGEST_15.`](#digest_15)
Together with the message length in [`MSG_LENGTH_LOWER`](#msg_length_lower) and [`MSG_LENGTH_UPPER`](#msg_length_upper), this forms the information that has to be saved before switching context.

### CMD . hash_process
If 1 is written to this field, SHA-2 or HMAC calculates the digest or signing based on currently received message.

### CMD . hash_start
If 1 is written into this field, SHA-2 or HMAC begins its operation.
CPU must configure relative information first, such as the digest size, secret key and the key length.

## STATUS
HMAC Status register
- Offset: `0x18`
- Reset default: `0x3`
- Reset mask: `0x3f7`

### Fields

```wavejson
{"reg": [{"name": "hmac_idle", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "fifo_empty", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "fifo_full", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 1}, {"name": "fifo_depth", "bits": 6, "attr": ["ro"], "rotate": 0}, {"bits": 22}], "config": {"lanes": 1, "fontsize": 10, "vspace": 120}}
```

|  Bits  |  Type  |  Reset  | Name       | Description                                                                                                                                                                       |
|:------:|:------:|:-------:|:-----------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31:10  |        |         |            | Reserved                                                                                                                                                                          |
|  9:4   |   ro   |    x    | fifo_depth | FIFO entry count.                                                                                                                                                                 |
|   3    |        |         |            | Reserved                                                                                                                                                                          |
|   2    |   ro   |    x    | fifo_full  | FIFO full. Data written to the FIFO whilst it is full will cause back-pressure on the interconnect                                                                                |
|   1    |   ro   |   0x1   | fifo_empty | FIFO empty                                                                                                                                                                        |
|   0    |   ro   |   0x1   | hmac_idle  | HMAC idle status. When IDLE, the `DIGEST` and the `MSG_LENGTH_LOWER`/`MSG_LENGTH_UPPER` can be written to from SW which enables restoring context (to support context switching). |

## ERR_CODE
HMAC Error Code
- Offset: `0x1c`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "err_code", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name     | Description                                                                                                                                              |
|:------:|:------:|:-------:|:---------|:---------------------------------------------------------------------------------------------------------------------------------------------------------|
|  31:0  |   ro   |   0x0   | err_code | If an error interrupt occurs, this register has information of error cause. Please take a look at `hw/ip/prim/rtl/prim_sha2_pkg.sv:err_code_e enum type. |

## WIPE_SECRET
Clear internal secret registers.

If CPU writes a value into the register, the value is used to clear the internal variables such as the secret key, internal state machine, or hash value.
The clear secret operation overwrites the internal variables with the provided 32-bit value.
For SHA-2 384/512 that work with 64-bit words, the 32-bit value is duplicated and concatenated to generate the 64-bit value.
It is recommended to use a value extracted from an entropy source.
- Offset: `0x20`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "secret", "bits": 32, "attr": ["wo"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description   |
|:------:|:------:|:-------:|:-------|:--------------|
|  31:0  |   wo   |    x    | secret | Secret value  |

## KEY
HMAC Secret Key

HMAC using SHA-2 256/384/512 assumes any hashed secret key length up to the block size, thus capped at 1024-bit.
[`key_length`](#key_length) determines how many of these registers are relevant for the HMAC operation. Order of the secret key is:
key[1023:0] = {KEY0, KEY1, KEY2, ... , KEY31};

The registers are allowed to be updated only when the engine is in Idle state.
If the engine computes the hash, it discards any attempts to update the secret keys and report an error.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name   | Offset   |
|:-------|:---------|
| KEY_0  | 0x24     |
| KEY_1  | 0x28     |
| KEY_2  | 0x2c     |
| KEY_3  | 0x30     |
| KEY_4  | 0x34     |
| KEY_5  | 0x38     |
| KEY_6  | 0x3c     |
| KEY_7  | 0x40     |
| KEY_8  | 0x44     |
| KEY_9  | 0x48     |
| KEY_10 | 0x4c     |
| KEY_11 | 0x50     |
| KEY_12 | 0x54     |
| KEY_13 | 0x58     |
| KEY_14 | 0x5c     |
| KEY_15 | 0x60     |
| KEY_16 | 0x64     |
| KEY_17 | 0x68     |
| KEY_18 | 0x6c     |
| KEY_19 | 0x70     |
| KEY_20 | 0x74     |
| KEY_21 | 0x78     |
| KEY_22 | 0x7c     |
| KEY_23 | 0x80     |
| KEY_24 | 0x84     |
| KEY_25 | 0x88     |
| KEY_26 | 0x8c     |
| KEY_27 | 0x90     |
| KEY_28 | 0x94     |
| KEY_29 | 0x98     |
| KEY_30 | 0x9c     |
| KEY_31 | 0xa0     |


### Fields

```wavejson
{"reg": [{"name": "key", "bits": 32, "attr": ["wo"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                         |
|:------:|:------:|:-------:|:-------|:------------------------------------|
|  31:0  |   wo   |    x    | key    | 32-bit chunk of 1024-bit secret key |

## DIGEST
Digest output.

If HMAC is disabled, the register shows result of SHA-2 256/384/512.
Order of the 512-bit digest[511:0] = {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST15}.
For SHA-2 256 order of the 256-bit digest[255:0] = {DIGEST0, DIGEST1, DIGEST2, DIGEST3, DIGEST4, DIGEST5, DIGEST6, DIGEST7} and {DIGEST8 - DIGEST15} are irrelevant and should not be read out.
For SHA-2 384, {DIGEST12-DIGEST15} are truncated; they are irrelevant and should not be read out.

The digest gets cleared when `CFG.sha_en` transitions from 1 to 0.
When `STATUS.hmac_idle` is 1, these registers may be written to by software.
Outside of this window, writes can cause unpredictable behavior.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name      | Offset   |
|:----------|:---------|
| DIGEST_0  | 0xa4     |
| DIGEST_1  | 0xa8     |
| DIGEST_2  | 0xac     |
| DIGEST_3  | 0xb0     |
| DIGEST_4  | 0xb4     |
| DIGEST_5  | 0xb8     |
| DIGEST_6  | 0xbc     |
| DIGEST_7  | 0xc0     |
| DIGEST_8  | 0xc4     |
| DIGEST_9  | 0xc8     |
| DIGEST_10 | 0xcc     |
| DIGEST_11 | 0xd0     |
| DIGEST_12 | 0xd4     |
| DIGEST_13 | 0xd8     |
| DIGEST_14 | 0xdc     |
| DIGEST_15 | 0xe0     |


### Fields

```wavejson
{"reg": [{"name": "digest", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                    |
|:------:|:------:|:-------:|:-------|:-------------------------------|
|  31:0  |   rw   |    x    | digest | 32-bit chunk of 512-bit digest |

## MSG_LENGTH_LOWER
Received Message Length calculated by the HMAC in bits [31:0]

Message is byte granularity.
Lower 3 bits [2:0] are ignored.

When `STATUS.hmac_idle` is 1, this register may be written by software.
Outside of this window, writes can cause unpredictable behavior.
- Offset: `0xe4`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "v", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description           |
|:------:|:------:|:-------:|:-------|:----------------------|
|  31:0  |   rw   |    x    | v      | Message Length [31:0] |

## MSG_LENGTH_UPPER
Received Message Length calculated by the HMAC in bits [63:32]

When `STATUS.hmac_idle` is 1, this register may be written by software.
Outside of this window, writes can cause unpredictable behavior.
For SHA-2-2 256 computations, message length is 64-bit {MSG_LENGTH_UPPER, MSG_LENGTH_LOWER}.f
For SHA-2 384/512 message length is extended to 128-bit in line with [nist-fips-180-4] where the upper 64 bits get zero-padded: {32'b0, 32'b0, MSG_LENGTH_UPPER, MSG_LENGTH_LOWER}.
- Offset: `0xe8`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "v", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description            |
|:------:|:------:|:-------:|:-------|:-----------------------|
|  31:0  |   rw   |    x    | v      | Message Length [63:32] |

## MSG_FIFO
Message FIFO. Any write to this window will be appended to the FIFO.
Only the lower [1:0] bits of the address matter to writes within the window
(for correctly dealing with non 32-bit writes)

- Word Aligned Offset Range: `0x1000`to`0x1ffc`
- Size (words): `1024`
- Access: `wo`
- Byte writes are  supported.


<!-- END CMDGEN -->

================================== Ai Message ==================================
Tool Calls:
  list_dir (call_9O2vKlnsCguquOA3VOCsLzJu)
 Call ID: call_9O2vKlnsCguquOA3VOCsLzJu
  Args:
    dir_path: /home/XXXX-2/hackdate/hw/ip/hmac/rtl
================================= Tool Message =================================
Name: list_dir

Files in /home/XXXX-2/hackdate/hw/ip/hmac/rtl:
hmac.sv hmac_core.sv hmac_reg_pkg.sv hmac_reg_top.sv hmac_reg_top_assertion-inserted.sv hmac_core_assertion-inserted.sv

Directories in /home/XXXX-2/hackdate/hw/ip/hmac/rtl:

================================== Ai Message ==================================
Tool Calls:
  run_verilator_agent (call_TMa52rQSW563DGNqPQaXcDO7)
 Call ID: call_TMa52rQSW563DGNqPQaXcDO7
  Args:
    ip: hmac
================================= Tool Message =================================
Name: run_verilator_agent

Based on my analysis of the test logs and RTL code, I can provide the following security assessment of the HMAC IP:

## Security Analysis Summary

After examining the failing tests and the HMAC RTL implementation, I've identified one potential security issue in the HMAC implementation:

### Security Issue: Inconsistent Digest Computation in Multi-Stream Processing

**Location**: The issue is evident in the `hmac_multistream_functest_sim_qemu_rom_with_fake_keys` test, which shows a mismatch between expected and actual digest values when processing multiple HMAC streams in parallel.

**Details**: 
The test log shows that when processing multiple HMAC streams concurrently (particularly with HMAC-SHA512), the computed digest values don't match the expected values:

```
I00057 hmac_multistream_functest.c:399] Finalizing HMAC stream for vector #5
I00058 hmac_multistream_functest.c:343] Comparing result for ./sw/device/tests/crypto/hmac_gen_single_testvector.py --seed=20 --key_len=512 --operation=HMAC512 --input_msg_len=5616 <output-file>.
I00059 hmac_multistream_functest.c:344] CHECK-fail: act_tag  unmatches current_test_vector->digest.data
I00060 hmac_multistream_functest.c:344] CHECK-fail: [0] got: 0x3fe8c10f; want: 0x4152e67e
...
```

The issue appears to be related to the context switching mechanism in the HMAC core when handling multiple streams. When the HMAC engine switches between different streams, it doesn't properly preserve or restore the internal state, leading to incorrect digest computation.

Looking at the RTL code, the issue likely stems from the state management in `hmac_core.sv`, particularly in the state transitions between `StMsg`, `StWaitResp`, and `StPushToMsgFifo` states. The core doesn't properly handle the case where multiple streams are being processed concurrently, leading to state corruption.

**Security Implications**:
1. **Integrity Violation**: Incorrect HMAC digests compromise the integrity verification mechanism, potentially allowing modified messages to pass verification.
2. **Authentication Bypass**: If the HMAC is used for authentication, incorrect digest computation could lead to authentication bypass.
3. **Side-Channel Vulnerability**: The inconsistent behavior during multi-stream processing might leak information about the internal state, potentially exposing key material.

**Recommendation**:
The HMAC core should be modified to properly handle context switching between multiple streams. This would involve:
1. Saving and restoring the complete internal state when switching between streams
2. Ensuring proper isolation between different streams' contexts
3. Adding additional validation to detect and prevent state corruption during stream switching

### Other Observations

1. The `clkmgr_off_hmac_trans_test_sim_qemu_rom_with_fake_keys` test failure appears to be expected behavior. The test is checking that accessing the HMAC unit when its clock is disabled causes a system reset, which is a security feature to prevent tampering.

2. The HMAC implementation includes several security features:
   - Secret key wiping mechanism to prevent key leakage
   - Proper endianness handling for cross-platform compatibility
   - Configuration locking during operation to prevent tampering
   - Error detection for invalid configurations and operations

## Conclusion

The HMAC IP has one significant security issue related to multi-stream processing that could lead to incorrect digest computation, potentially compromising integrity and authentication mechanisms. The issue should be addressed by improving the context switching mechanism in the HMAC core to properly preserve and restore state when handling multiple streams.

The implementation otherwise appears to have good security controls, including proper key management, configuration locking, and error detection mechanisms.
================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_co4GSxrcZMsY1SjEVMAXX1uN)
 Call ID: call_co4GSxrcZMsY1SjEVMAXX1uN
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_core.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // HMAC Core implementation
6: 
7: module hmac_core import prim_sha2_pkg::*; (
8:   input clk_i,
9:   input rst_ni,
10: 
11:   input [1023:0]      secret_key_i, // {word0, word1, ..., word7}
12:   input               hmac_en_i,
13:   input digest_mode_e digest_size_i,
14:   input key_length_e  key_length_i,
15: 
16:   input        reg_hash_start_i,
17:   input        reg_hash_stop_i,
18:   input        reg_hash_continue_i,
19:   input        reg_hash_process_i,
20:   output logic hash_done_o,
21:   output logic sha_hash_start_o,
22:   output logic sha_hash_continue_o,
23:   output logic sha_hash_process_o,
24:   input        sha_hash_done_i,
25: 
26:   // fifo
27:   output logic        sha_rvalid_o,
28:   output sha_fifo32_t sha_rdata_o,
29:   input               sha_rready_i,
30: 
31:   input               fifo_rvalid_i,
32:   input  sha_fifo32_t fifo_rdata_i,
33:   output logic        fifo_rready_o,
34: 
35:   // fifo control (select and fifo write data)
36:   output logic       fifo_wsel_o,      // 0: from reg, 1: from digest
37:   output logic       fifo_wvalid_o,
38:   // 0: digest[0][upper], 1:digest[0][lower] .. 14: digest[7][upper], 15: digest[7][lower]
39:   output logic [3:0] fifo_wdata_sel_o,
40:   input              fifo_wready_i,
41: 
42:   input  [63:0] message_length_i,
43:   output [63:0] sha_message_length_o,
44: 
45:   output logic idle_o
46: );
47: 
48:   localparam int unsigned BlockSizeSHA256     = 512;
49:   localparam int unsigned BlockSizeSHA512     = 1024;
50: 
51:   localparam int unsigned BlockSizeBitsSHA256 = $clog2(BlockSizeSHA256);
52:   localparam int unsigned BlockSizeBitsSHA512 = $clog2(BlockSizeSHA512);
53: 
54:   localparam int unsigned HashWordBitsSHA256  = $clog2($bits(sha_word32_t));
55: 
56:   localparam bit [63:0] BlockSizeSHA256in64  = 64'(BlockSizeSHA256);
57:   localparam bit [63:0] BlockSizeSHA512in64  = 64'(BlockSizeSHA512);
58: 
59:   logic hash_start;    // generated from internal state machine
60:   logic hash_continue; // generated from internal state machine
61:   logic hash_process;  // generated from internal state machine to trigger hash
62:   logic hmac_hash_done;
63: 
64:   logic [BlockSizeSHA256-1:0] i_pad_256;
65:   logic [BlockSizeSHA512-1:0] i_pad_512;
66:   logic [BlockSizeSHA256-1:0] o_pad_256;
67:   logic [BlockSizeSHA512-1:0] o_pad_512;
68: 
69:   logic [63:0] txcount, txcount_d; // works for both digest lengths
70: 
71:   logic [BlockSizeBitsSHA512-HashWordBitsSHA256-1:0] pad_index_512;
72:   logic [BlockSizeBitsSHA256-HashWordBitsSHA256-1:0] pad_index_256;
73:   logic clr_txcount, load_txcount, inc_txcount;
74: 
75:   logic hmac_sha_rvalid;
76: 
77:   logic idle_d, idle_q;
78:   logic reg_hash_stop_d, reg_hash_stop_q;
79: 
80:   typedef enum logic [1:0] {
81:     SelIPad,
82:     SelOPad,
83:     SelFifo
84:   } sel_rdata_t;
85: 
86:   sel_rdata_t sel_rdata;
87: 
88:   typedef enum logic {
89:     SelIPadMsg,
90:     SelOPadMsg
91:   } sel_msglen_t;
92: 
93:   sel_msglen_t sel_msglen;
94: 
95:   typedef enum logic {
96:     Inner,  // Update when state goes to StIPad
97:     Outer   // Update when state enters StOPad
98:   } round_t ;
99: 
100:   logic update_round ;
101:   round_t round_q, round_d;
102: 
103:   typedef enum logic [2:0] {
104:     StIdle,
105:     StIPad,
106:     StMsg,              // Actual Msg, and Digest both
107:     StPushToMsgFifo,    // Digest --> Msg Fifo
108:     StWaitResp,         // Hash done( by checking processed_length? or hash_done)
109:     StOPad,
110:     StDone              // hmac_done
111:   } st_e ;
112: 
113:   st_e st_q, st_d;
114: 
115:   logic clr_fifo_wdata_sel;
116:   logic txcnt_eq_blksz;
117: 
118:   logic reg_hash_process_flag;
119: 
120:   assign sha_hash_start_o    = (hmac_en_i) ? hash_start    : reg_hash_start_i;
121:   assign sha_hash_continue_o = (hmac_en_i) ? hash_continue : reg_hash_continue_i;
122: 
123:   assign sha_hash_process_o  = (hmac_en_i) ? reg_hash_process_i | hash_process : reg_hash_process_i;
124:   assign hash_done_o         = (hmac_en_i) ? hmac_hash_done                    : sha_hash_done_i;
125: 
126:   assign pad_index_512 = txcount[BlockSizeBitsSHA512-1:HashWordBitsSHA256];
127:   assign pad_index_256 = txcount[BlockSizeBitsSHA256-1:HashWordBitsSHA256];
128: 
129:   // adjust inner and outer padding depending on key length and block size
130:   always_comb begin : adjust_key_pad_length
131:     // set defaults
132:     i_pad_256 = '{default: '0};
133:     i_pad_512 = '{default: '0};
134:     o_pad_256 = '{default: '0};
135:     o_pad_512 = '{default: '0};
136: 
137:     unique case (key_length_i)
138:       Key_128: begin
139:         i_pad_256 = {secret_key_i[1023:896],
140:                     {(BlockSizeSHA256-128){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
141:         i_pad_512 = {secret_key_i[1023:896],
142:                     {(BlockSizeSHA512-128){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
143:         o_pad_256 = {secret_key_i[1023:896],
144:                     {(BlockSizeSHA256-128){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
145:         o_pad_512 = {secret_key_i[1023:896],
146:                     {(BlockSizeSHA512-128){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
147:       end
148:       Key_256: begin
149:         i_pad_256 = {secret_key_i[1023:768],
150:                     {(BlockSizeSHA256-256){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
151:         i_pad_512 = {secret_key_i[1023:768],
152:                     {(BlockSizeSHA512-256){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
153:         o_pad_256 = {secret_key_i[1023:768],
154:                     {(BlockSizeSHA256-256){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
155:         o_pad_512 = {secret_key_i[1023:768],
156:                     {(BlockSizeSHA512-256){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
157:       end
158:       Key_384: begin
159:         i_pad_256 = {secret_key_i[1023:640],
160:                     {(BlockSizeSHA256-384){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
161:         i_pad_512 = {secret_key_i[1023:640],
162:                     {(BlockSizeSHA512-384){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
163:         o_pad_256 = {secret_key_i[1023:640],
164:                     {(BlockSizeSHA256-384){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
165:         o_pad_512 = {secret_key_i[1023:640],
166:                     {(BlockSizeSHA512-384){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
167:       end
168:       Key_512: begin
169:         i_pad_256 = secret_key_i[1023:512] ^ {(BlockSizeSHA256/8){8'h36}};
170:         i_pad_512 = {secret_key_i[1023:512],
171:                     {(BlockSizeSHA512-512){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
172:         o_pad_256 = secret_key_i[1023:512] ^ {(BlockSizeSHA256/8){8'h5c}};
173:         o_pad_512 = {secret_key_i[1023:512],
174:                     {(BlockSizeSHA512-512){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
175:       end
176:       Key_1024: begin // not allowed to be configured for SHA-2 256
177:         // zero out for SHA-2 256
178:         i_pad_256 = '{default: '0};
179:         i_pad_512 = secret_key_i[1023:0]   ^ {(BlockSizeSHA512/8){8'h36}};
180:         // zero out for SHA-2 256
181:         o_pad_256 = '{default: '0};
182:         o_pad_512 = secret_key_i[1023:0]   ^ {(BlockSizeSHA512/8){8'h5c}};
183:       end
184:       default: begin
185:       end
186:     endcase
187:   end
188: 
189:   assign fifo_rready_o = (hmac_en_i) ? (st_q == StMsg) & sha_rready_i : sha_rready_i ;
190:   // sha_rvalid is controlled by State Machine below.
191:   assign sha_rvalid_o  = (!hmac_en_i) ? fifo_rvalid_i : hmac_sha_rvalid ;
192:   assign sha_rdata_o =
193:     (!hmac_en_i)    ? fifo_rdata_i                                                             :
194:     (sel_rdata == SelIPad && digest_size_i == SHA2_256)
195:                   ? '{data: i_pad_256[(BlockSizeSHA256-1)-32*pad_index_256-:32], mask: '1} :
196:     (sel_rdata == SelIPad && ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)))
197:                   ? '{data: i_pad_512[(BlockSizeSHA512-1)-32*pad_index_512-:32], mask: '1} :
198:     (sel_rdata == SelOPad && digest_size_i == SHA2_256)
199:                   ? '{data: o_pad_256[(BlockSizeSHA256-1)-32*pad_index_256-:32], mask: '1} :
200:     (sel_rdata == SelOPad && ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)))
201:                   ? '{data: o_pad_512[(BlockSizeSHA512-1)-32*pad_index_512-:32], mask: '1} :
202:     (sel_rdata == SelFifo) ? fifo_rdata_i                                                    :
203:                   '{default: '0};
204: 
205:   logic [63:0] sha_msg_len;
206: 
207:   always_comb begin: assign_sha_message_length
208:     sha_msg_len = '0;
209:     if (!hmac_en_i) begin
210:       sha_msg_len = message_length_i;
211:     // HASH = (o_pad || HASH_INTERMEDIATE (i_pad || msg))
212:     // message length for HASH_INTERMEDIATE = block size (i_pad) + message length
213:     end else if (sel_msglen == SelIPadMsg) begin
214:       if (digest_size_i == SHA2_256) begin
215:         sha_msg_len = message_length_i + BlockSizeSHA256in64;
216:       end else if ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)) begin
217:         sha_msg_len = message_length_i + BlockSizeSHA512in64;
218:       end
219:     end else if (sel_msglen == SelOPadMsg) begin
220:     // message length for HASH = block size (o_pad) + HASH_INTERMEDIATE digest length
221:       if (digest_size_i == SHA2_256) begin
222:         sha_msg_len = BlockSizeSHA256in64 + 64'd256;
223:       end else if (digest_size_i == SHA2_384) begin
224:         sha_msg_len = BlockSizeSHA512in64 + 64'd384;
225:       end else if (digest_size_i == SHA2_512) begin
226:         sha_msg_len = BlockSizeSHA512in64 + 64'd512;
227:       end
228:     end else
229:       sha_msg_len = '0;
230:   end
231: 
232:   assign sha_message_length_o = sha_msg_len;
233: 
234:   always_comb begin
235:     txcnt_eq_blksz = '0;
236: 
237:     unique case (digest_size_i)
238:       SHA2_256: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA256-1:0] == '0) && (txcount != '0);
239:       SHA2_384: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA512-1:0] == '0) && (txcount != '0);
240:       SHA2_512: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA512-1:0] == '0) && (txcount != '0);
241:       default;
242:     endcase
243:   end
244: 
245:   assign inc_txcount = sha_rready_i && sha_rvalid_o;
246: 
247:   // txcount
248:   //    Looks like txcount can be removed entirely here in hmac_core
249:   //    In the first round (InnerPaddedKey), it can just watch process and hash_done
250:   //    In the second round, it only needs count 256 bits for hash digest to trigger
251:   //    hash_process to SHA2
252:   always_comb begin
253:     txcount_d = txcount;
254:     if (clr_txcount) begin
255:       txcount_d = '0;
256:     end else if (load_txcount) begin
257:       // When loading, add block size to the message length because the SW-visible message length
258:       // does not include the block containing the key xor'ed with the inner pad.
259:       unique case (digest_size_i)
260:         SHA2_256: txcount_d = message_length_i + BlockSizeSHA256in64;
261:         SHA2_384: txcount_d = message_length_i + BlockSizeSHA512in64;
262:         SHA2_512: txcount_d = message_length_i + BlockSizeSHA512in64;
263:         default : txcount_d = message_length_i + '0;
264:       endcase
265:     end else if (inc_txcount) begin
266:       txcount_d[63:5] = txcount[63:5] + 1'b1; // increment by 32 (data word size)
267:     end
268:   end
269: 
270:   always_ff @(posedge clk_i or negedge rst_ni) begin
271:     if (!rst_ni) txcount <= '0;
272:     else         txcount <= txcount_d;
273:   end
274: 
275:   // reg_hash_process_i trigger logic
276:   always_ff @(posedge clk_i or negedge rst_ni) begin
277:     if (!rst_ni) begin
278:       reg_hash_process_flag <= 1'b0;
279:     end else if (reg_hash_process_i) begin
280:       reg_hash_process_flag <= 1'b1;
281:     end else if (hmac_hash_done || reg_hash_start_i || reg_hash_continue_i) begin
282:       reg_hash_process_flag <= 1'b0;
283:     end
284:   end
285: 
286:   always_ff @(posedge clk_i or negedge rst_ni) begin
287:     if (!rst_ni) begin
288:       round_q <= Inner;
289:     end else if (update_round) begin
290:       round_q <= round_d;
291:     end
292:   end
293: 
294:   always_ff @(posedge clk_i or negedge rst_ni) begin
295:     if (!rst_ni) begin
296:       fifo_wdata_sel_o <= 3'h 0;
297:     end else if (clr_fifo_wdata_sel) begin
298:       fifo_wdata_sel_o <= 3'h 0;
299:     end else if (fifo_wsel_o && fifo_wvalid_o) begin
300:       fifo_wdata_sel_o <= fifo_wdata_sel_o + 1'b1; // increment by 1
301:     end
302:   end
303: 
304:   assign sel_msglen = (round_q == Inner) ? SelIPadMsg : SelOPadMsg ;
305: 
306:   always_ff @(posedge clk_i or negedge rst_ni) begin : state_ff
307:     if (!rst_ni) st_q <= StIdle;
308:     else         st_q <= st_d;
309:   end
310: 
311:   always_comb begin : next_state
312:     hmac_hash_done     = 1'b0;
313:     hmac_sha_rvalid    = 1'b0;
314:     clr_txcount        = 1'b0;
315:     load_txcount       = 1'b0;
316:     update_round       = 1'b0;
317:     round_d            = Inner;
318:     fifo_wsel_o        = 1'b0;   // from register
319:     fifo_wvalid_o      = 1'b0;
320:     clr_fifo_wdata_sel = 1'b1;
321:     sel_rdata          = SelFifo;
322:     hash_start         = 1'b0;
323:     hash_continue      = 1'b0;
324:     hash_process       = 1'b0;
325:     st_d               = st_q;
326: 
327:     unique case (st_q)
328:       StIdle: begin
329:         // reset round to Inner
330:         // we always switch context into inner round since outer round computes once over
331:         // single block at the end (outer key pad + inner hash)
332:         update_round = 1'b1;
333:         round_d      = Inner;
334:         if (hmac_en_i && reg_hash_start_i) begin
335:           st_d = StIPad; // start at StIPad if told to start
336: 
337:           clr_txcount  = 1'b1;
338:           hash_start   = 1'b1;
339:         end else if (hmac_en_i && reg_hash_continue_i) begin
340:           st_d = StMsg; // skip StIPad if told to continue - assumed it finished StIPad
341: 
342:           load_txcount  = 1'b1;
343:           hash_continue = 1'b1;
344:         end else begin
345:           st_d = StIdle;
346:         end
347:       end
348: 
349:       StIPad: begin
350:         sel_rdata = SelIPad;
351: 
352:         if (txcnt_eq_blksz) begin
353:           st_d = StMsg;
354: 
355:           hmac_sha_rvalid = 1'b0; // block new read request
356:         end else begin
357:           st_d = StIPad;
358: 
359:           hmac_sha_rvalid = 1'b1;
360:         end
361:       end
362: 
363:       StMsg: begin
364:         sel_rdata   = SelFifo;
365:         fifo_wsel_o = (round_q == Outer);
366: 
367:         if ( (((round_q == Inner) && reg_hash_process_flag) || (round_q == Outer))
368:             && (txcount >= sha_message_length_o)) begin
369:           st_d    = StWaitResp;
370: 
371:           hmac_sha_rvalid = 1'b0; // block reading words from MSG FIFO
372:           hash_process    = (round_q == Outer);
373:         end else if (txcnt_eq_blksz && (txcount >= sha_message_length_o)
374:                      && reg_hash_stop_q && (round_q == Inner)) begin
375:           // wait till all MSG words are pushed out from FIFO (txcount reaches msg length)
376:           // before transitioning to StWaitResp to wait on sha_hash_done_i and disabling
377:           // reading from MSG FIFO
378:           st_d =  StWaitResp;
379: 
380:           hmac_sha_rvalid = 1'b0;
381:         end else begin
382:           st_d            = StMsg;
383:           hmac_sha_rvalid = fifo_rvalid_i;
384:         end
385:       end
386: 
387:       StWaitResp: begin
388:         hmac_sha_rvalid = 1'b0;
389: 
390:         if (sha_hash_done_i) begin
391:           if (round_q == Outer) begin
392:             st_d = StDone;
393:           end else begin // round_q == Inner
394:             if (reg_hash_stop_q) begin
395:               st_d = StDone;
396:             end else begin
397:               st_d = StPushToMsgFifo;
398:             end
399:           end
400:         end else begin
401:           st_d = StWaitResp;
402:         end
403:       end
404: 
405:       StPushToMsgFifo: begin
406:         hmac_sha_rvalid    = 1'b0;
407:         fifo_wsel_o        = 1'b1;
408:         fifo_wvalid_o      = 1'b1;
409:         clr_fifo_wdata_sel = 1'b0;
410: 
411:         if (fifo_wready_i && (((fifo_wdata_sel_o == 4'd7) && (digest_size_i == SHA2_256)) ||
412:                              ((fifo_wdata_sel_o == 4'd15) && (digest_size_i == SHA2_512)) ||
413:                              ((fifo_wdata_sel_o == 4'd11) && (digest_size_i == SHA2_384)))) begin
414: 
415:           st_d = StOPad;
416: 
417:           clr_txcount  = 1'b1;
418:           update_round = 1'b1;
419:           round_d      = Outer;
420:           hash_start   = 1'b1;
421:         end else begin
422:           st_d = StPushToMsgFifo;
423: 
424:         end
425:       end
426: 
427:       StOPad: begin
428:         sel_rdata   = SelOPad;
429:         fifo_wsel_o = 1'b1; // Remained HMAC select to indicate HMAC is in second stage
430: 
431:         if (txcnt_eq_blksz) begin
432:           st_d = StMsg;
433: 
434:           hmac_sha_rvalid = 1'b0; // block new read request
435:         end else begin
436:           st_d = StOPad;
437: 
438:           hmac_sha_rvalid = 1'b1;
439:         end
440:       end
441: 
442:       StDone: begin
443:         // raise interrupt (hash_done)
444:         st_d = StIdle;
445: 
446:         hmac_hash_done = 1'b1;
447:       end
448: 
449:       default: begin
450:         st_d = StIdle;
451:       end
452: 
453:     endcase
454:   end
455: 
456:   // raise reg_hash_stop_d flag at reg_hash_stop_i and keep it until sha_hash_done_i is asserted
457:   // to indicate the hashing operation on current block has completed
458:   assign reg_hash_stop_d = (reg_hash_stop_i == 1'b1)                            ? 1'b1 :
459:                            (sha_hash_done_i == 1'b1 && reg_hash_stop_q == 1'b1) ? 1'b0 :
460:                                                                                   reg_hash_stop_q;
461: 
462:   always_ff @(posedge clk_i or negedge rst_ni) begin
463:     if (!rst_ni) begin
464:       reg_hash_stop_q <= 1'b0;
465:     end else begin
466:       reg_hash_stop_q <= reg_hash_stop_d;
467:     end
468:   end
469: 
470:   // Idle status signaling: This module ..
471:   assign idle_d =
472:       // .. is not idle when told to start or continue
473:       (reg_hash_start_i || reg_hash_continue_i) ? 1'b0 :
474:       // .. is idle when the FSM is in the Idle state
475:       (st_q == StIdle) ? 1'b1 :
476:       // .. is idle when it has processed a complete block of a message and is told to stop in any
477:       // FSM state
478:       (txcnt_eq_blksz && reg_hash_stop_d) ? 1'b1 :
479:       // .. and keeps the current idle state in all other cases.
480:       idle_q;
481: 
482:   assign idle_o = idle_d;
483: 
484:   always_ff @(posedge clk_i or negedge rst_ni) begin
485:     if (!rst_ni) begin
486:       idle_q <= 1'b1;
487:     end else begin
488:       idle_q <= idle_d;
489:     end
490:   end
491: endmodule

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_nt9chY1GWDtAyAoHZ3xeDMdJ)
 Call ID: call_nt9chY1GWDtAyAoHZ3xeDMdJ
  Args:
    file_path: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Register Top module auto-generated by `reggen`
6: 
7: `include "prim_assert.sv"
8: 
9: module hmac_reg_top (
10:   input clk_i,
11:   input rst_ni,
12:   input  tlul_pkg::tl_h2d_t tl_i,
13:   output tlul_pkg::tl_d2h_t tl_o,
14: 
15:   // Output port for window
16:   output tlul_pkg::tl_h2d_t tl_win_o,
17:   input  tlul_pkg::tl_d2h_t tl_win_i,
18: 
19:   // To HW
20:   output hmac_reg_pkg::hmac_reg2hw_t reg2hw, // Write
21:   input  hmac_reg_pkg::hmac_hw2reg_t hw2reg, // Read
22: 
23:   // Integrity check errors
24:   output logic intg_err_o
25: );
26: 
27:   import hmac_reg_pkg::* ;
28: 
29:   localparam int AW = 13;
30:   localparam int DW = 32;
31:   localparam int DBW = DW/8;                    // Byte Width
32: 
33:   // register signals
34:   logic           reg_we;
35:   logic           reg_re;
36:   logic [AW-1:0]  reg_addr;
37:   logic [DW-1:0]  reg_wdata;
38:   logic [DBW-1:0] reg_be;
39:   logic [DW-1:0]  reg_rdata;
40:   logic           reg_error;
41: 
42:   logic          addrmiss, wr_err;
43: 
44:   logic [DW-1:0] reg_rdata_next;
45:   logic reg_busy;
46: 
47:   tlul_pkg::tl_h2d_t tl_reg_h2d;
48:   tlul_pkg::tl_d2h_t tl_reg_d2h;
49: 
50: 
51:   // incoming payload check
52:   logic intg_err;
53:   tlul_cmd_intg_chk u_chk (
54:     .tl_i(tl_i),
55:     .err_o(intg_err)
56:   );
57: 
58:   // also check for spurious write enables
59:   logic reg_we_err;
60:   logic [58:0] reg_we_check;
61:   prim_reg_we_check #(
62:     .OneHotWidth(59)
63:   ) u_prim_reg_we_check (
64:     .clk_i(clk_i),
65:     .rst_ni(rst_ni),
66:     .oh_i  (reg_we_check),
67:     .en_i  (reg_we && !addrmiss),
68:     .err_o (reg_we_err)
69:   );
70: 
71:   logic err_q;
72:   always_ff @(posedge clk_i or negedge rst_ni) begin
73:     if (!rst_ni) begin
74:       err_q <= '0;
75:     end else if (intg_err || reg_we_err) begin
76:       err_q <= 1'b1;
77:     end
78:   end
79: 
80:   // integrity error output is permanent and should be used for alert generation
81:   // register errors are transactional
82:   assign intg_err_o = err_q | intg_err | reg_we_err;
83: 
84:   // outgoing integrity generation
85:   tlul_pkg::tl_d2h_t tl_o_pre;
86:   tlul_rsp_intg_gen #(
87:     .EnableRspIntgGen(1),
88:     .EnableDataIntgGen(1)
89:   ) u_rsp_intg_gen (
90:     .tl_i(tl_o_pre),
91:     .tl_o(tl_o)
92:   );
93: 
94:   tlul_pkg::tl_h2d_t tl_socket_h2d [2];
95:   tlul_pkg::tl_d2h_t tl_socket_d2h [2];
96: 
97:   logic [0:0] reg_steer;
98: 
99:   // socket_1n connection
100:   assign tl_reg_h2d = tl_socket_h2d[1];
101:   assign tl_socket_d2h[1] = tl_reg_d2h;
102: 
103:   assign tl_win_o = tl_socket_h2d[0];
104:   assign tl_socket_d2h[0] = tl_win_i;
105: 
106:   // Create Socket_1n
107:   tlul_socket_1n #(
108:     .N            (2),
109:     .HReqPass     (1'b1),
110:     .HRspPass     (1'b1),
111:     .DReqPass     ({2{1'b1}}),
112:     .DRspPass     ({2{1'b1}}),
113:     .HReqDepth    (4'h0),
114:     .HRspDepth    (4'h0),
115:     .DReqDepth    ({2{4'h0}}),
116:     .DRspDepth    ({2{4'h0}}),
117:     .ExplicitErrs (1'b0)
118:   ) u_socket (
119:     .clk_i  (clk_i),
120:     .rst_ni (rst_ni),
121:     .tl_h_i (tl_i),
122:     .tl_h_o (tl_o_pre),
123:     .tl_d_o (tl_socket_h2d),
124:     .tl_d_i (tl_socket_d2h),
125:     .dev_select_i (reg_steer)
126:   );
127: 
128:   // Create steering logic
129:   always_comb begin
130:     reg_steer =
131:         tl_i.a_address[AW-1:0] inside {[4096:8191]} ? 1'd0 :
132:         // Default set to register
133:         1'd1;
134: 
135:     // Override this in case of an integrity error
136:     if (intg_err) begin
137:       reg_steer = 1'd1;
138:     end
139:   end
140: 
141:   tlul_adapter_reg #(
142:     .RegAw(AW),
143:     .RegDw(DW),
144:     .EnableDataIntgGen(0)
145:   ) u_reg_if (
146:     .clk_i  (clk_i),
147:     .rst_ni (rst_ni),
148: 
149:     .tl_i (tl_reg_h2d),
150:     .tl_o (tl_reg_d2h),
151: 
152:     .en_ifetch_i(prim_mubi_pkg::MuBi4False),
153:     .intg_error_o(),
154: 
155:     .we_o    (reg_we),
156:     .re_o    (reg_re),
157:     .addr_o  (reg_addr),
158:     .wdata_o (reg_wdata),
159:     .be_o    (reg_be),
160:     .busy_i  (reg_busy),
161:     .rdata_i (reg_rdata),
162:     .error_i (reg_error)
163:   );
164: 
165:   // cdc oversampling signals
166: 
167:   assign reg_rdata = reg_rdata_next ;
168:   assign reg_error = addrmiss | wr_err | intg_err;
169: 
170:   // Define SW related signals
171:   // Format: <reg>_<field>_{wd|we|qs}
172:   //        or <reg>_{wd|we|qs} if field == 1 or 0
173:   logic intr_state_we;
174:   logic intr_state_hmac_done_qs;
175:   logic intr_state_hmac_done_wd;
176:   logic intr_state_fifo_empty_qs;
177:   logic intr_state_hmac_err_qs;
178:   logic intr_state_hmac_err_wd;
179:   logic intr_enable_we;
180:   logic intr_enable_hmac_done_qs;
181:   logic intr_enable_hmac_done_wd;
182:   logic intr_enable_fifo_empty_qs;
183:   logic intr_enable_fifo_empty_wd;
184:   logic intr_enable_hmac_err_qs;
185:   logic intr_enable_hmac_err_wd;
186:   logic intr_test_we;
187:   logic intr_test_hmac_done_wd;
188:   logic intr_test_fifo_empty_wd;
189:   logic intr_test_hmac_err_wd;
190:   logic alert_test_we;
191:   logic alert_test_wd;
192:   logic cfg_re;
193:   logic cfg_we;
194:   logic cfg_hmac_en_qs;
195:   logic cfg_hmac_en_wd;
196:   logic cfg_sha_en_qs;
197:   logic cfg_sha_en_wd;
198:   logic cfg_endian_swap_qs;
199:   logic cfg_endian_swap_wd;
200:   logic cfg_digest_swap_qs;
201:   logic cfg_digest_swap_wd;
202:   logic cfg_key_swap_qs;
203:   logic cfg_key_swap_wd;
204:   logic [3:0] cfg_digest_size_qs;
205:   logic [3:0] cfg_digest_size_wd;
206:   logic [5:0] cfg_key_length_qs;
207:   logic [5:0] cfg_key_length_wd;
208:   logic cmd_we;
209:   logic cmd_hash_start_wd;
210:   logic cmd_hash_process_wd;
211:   logic cmd_hash_stop_wd;
212:   logic cmd_hash_continue_wd;
213:   logic status_re;
214:   logic status_hmac_idle_qs;
215:   logic status_fifo_empty_qs;
216:   logic status_fifo_full_qs;
217:   logic [5:0] status_fifo_depth_qs;
218:   logic [31:0] err_code_qs;
219:   logic wipe_secret_we;
220:   logic [31:0] wipe_secret_wd;
221:   logic key_0_we;
222:   logic [31:0] key_0_wd;
223:   logic key_1_we;
224:   logic [31:0] key_1_wd;
225:   logic key_2_we;
226:   logic [31:0] key_2_wd;
227:   logic key_3_we;
228:   logic [31:0] key_3_wd;
229:   logic key_4_we;
230:   logic [31:0] key_4_wd;
231:   logic key_5_we;
232:   logic [31:0] key_5_wd;
233:   logic key_6_we;
234:   logic [31:0] key_6_wd;
235:   logic key_7_we;
236:   logic [31:0] key_7_wd;
237:   logic key_8_we;
238:   logic [31:0] key_8_wd;
239:   logic key_9_we;
240:   logic [31:0] key_9_wd;
241:   logic key_10_we;
242:   logic [31:0] key_10_wd;
243:   logic key_11_we;
244:   logic [31:0] key_11_wd;
245:   logic key_12_we;
246:   logic [31:0] key_12_wd;
247:   logic key_13_we;
248:   logic [31:0] key_13_wd;
249:   logic key_14_we;
250:   logic [31:0] key_14_wd;
251:   logic key_15_we;
252:   logic [31:0] key_15_wd;
253:   logic key_16_we;
254:   logic [31:0] key_16_wd;
255:   logic key_17_we;
256:   logic [31:0] key_17_wd;
257:   logic key_18_we;
258:   logic [31:0] key_18_wd;
259:   logic key_19_we;
260:   logic [31:0] key_19_wd;
261:   logic key_20_we;
262:   logic [31:0] key_20_wd;
263:   logic key_21_we;
264:   logic [31:0] key_21_wd;
265:   logic key_22_we;
266:   logic [31:0] key_22_wd;
267:   logic key_23_we;
268:   logic [31:0] key_23_wd;
269:   logic key_24_we;
270:   logic [31:0] key_24_wd;
271:   logic key_25_we;
272:   logic [31:0] key_25_wd;
273:   logic key_26_we;
274:   logic [31:0] key_26_wd;
275:   logic key_27_we;
276:   logic [31:0] key_27_wd;
277:   logic key_28_we;
278:   logic [31:0] key_28_wd;
279:   logic key_29_we;
280:   logic [31:0] key_29_wd;
281:   logic key_30_we;
282:   logic [31:0] key_30_wd;
283:   logic key_31_we;
284:   logic [31:0] key_31_wd;
285:   logic digest_0_re;
286:   logic digest_0_we;
287:   logic [31:0] digest_0_qs;
288:   logic [31:0] digest_0_wd;
289:   logic digest_1_re;
290:   logic digest_1_we;
291:   logic [31:0] digest_1_qs;
292:   logic [31:0] digest_1_wd;
293:   logic digest_2_re;
294:   logic digest_2_we;
295:   logic [31:0] digest_2_qs;
296:   logic [31:0] digest_2_wd;
297:   logic digest_3_re;
298:   logic digest_3_we;
299:   logic [31:0] digest_3_qs;
300:   logic [31:0] digest_3_wd;
301:   logic digest_4_re;
302:   logic digest_4_we;
303:   logic [31:0] digest_4_qs;
304:   logic [31:0] digest_4_wd;
305:   logic digest_5_re;
306:   logic digest_5_we;
307:   logic [31:0] digest_5_qs;
308:   logic [31:0] digest_5_wd;
309:   logic digest_6_re;
310:   logic digest_6_we;
311:   logic [31:0] digest_6_qs;
312:   logic [31:0] digest_6_wd;
313:   logic digest_7_re;
314:   logic digest_7_we;
315:   logic [31:0] digest_7_qs;
316:   logic [31:0] digest_7_wd;
317:   logic digest_8_re;
318:   logic digest_8_we;
319:   logic [31:0] digest_8_qs;
320:   logic [31:0] digest_8_wd;
321:   logic digest_9_re;
322:   logic digest_9_we;
323:   logic [31:0] digest_9_qs;
324:   logic [31:0] digest_9_wd;
325:   logic digest_10_re;
326:   logic digest_10_we;
327:   logic [31:0] digest_10_qs;
328:   logic [31:0] digest_10_wd;
329:   logic digest_11_re;
330:   logic digest_11_we;
331:   logic [31:0] digest_11_qs;
332:   logic [31:0] digest_11_wd;
333:   logic digest_12_re;
334:   logic digest_12_we;
335:   logic [31:0] digest_12_qs;
336:   logic [31:0] digest_12_wd;
337:   logic digest_13_re;
338:   logic digest_13_we;
339:   logic [31:0] digest_13_qs;
340:   logic [31:0] digest_13_wd;
341:   logic digest_14_re;
342:   logic digest_14_we;
343:   logic [31:0] digest_14_qs;
344:   logic [31:0] digest_14_wd;
345:   logic digest_15_re;
346:   logic digest_15_we;
347:   logic [31:0] digest_15_qs;
348:   logic [31:0] digest_15_wd;
349:   logic msg_length_lower_re;
350:   logic msg_length_lower_we;
351:   logic [31:0] msg_length_lower_qs;
352:   logic [31:0] msg_length_lower_wd;
353:   logic msg_length_upper_re;
354:   logic msg_length_upper_we;
355:   logic [31:0] msg_length_upper_qs;
356:   logic [31:0] msg_length_upper_wd;
357: 
358:   // Register instances
359:   // R[intr_state]: V(False)
360:   //   F[hmac_done]: 0:0
361:   prim_subreg #(
362:     .DW      (1),
363:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
364:     .RESVAL  (1'h0),
365:     .Mubi    (1'b0)
366:   ) u_intr_state_hmac_done (
367:     .clk_i   (clk_i),
368:     .rst_ni  (rst_ni),
369: 
370:     // from register interface
371:     .we     (intr_state_we),
372:     .wd     (intr_state_hmac_done_wd),
373: 
374:     // from internal hardware
375:     .de     (hw2reg.intr_state.hmac_done.de),
376:     .d      (hw2reg.intr_state.hmac_done.d),
377: 
378:     // to internal hardware
379:     .qe     (),
380:     .q      (reg2hw.intr_state.hmac_done.q),
381:     .ds     (),
382: 
383:     // to register interface (read)
384:     .qs     (intr_state_hmac_done_qs)
385:   );
386: 
387:   //   F[fifo_empty]: 1:1
388:   prim_subreg #(
389:     .DW      (1),
390:     .SwAccess(prim_subreg_pkg::SwAccessRO),
391:     .RESVAL  (1'h0),
392:     .Mubi    (1'b0)
393:   ) u_intr_state_fifo_empty (
394:     .clk_i   (clk_i),
395:     .rst_ni  (rst_ni),
396: 
397:     // from register interface
398:     .we     (1'b0),
399:     .wd     ('0),
400: 
401:     // from internal hardware
402:     .de     (hw2reg.intr_state.fifo_empty.de),
403:     .d      (hw2reg.intr_state.fifo_empty.d),
404: 
405:     // to internal hardware
406:     .qe     (),
407:     .q      (reg2hw.intr_state.fifo_empty.q),
408:     .ds     (),
409: 
410:     // to register interface (read)
411:     .qs     (intr_state_fifo_empty_qs)
412:   );
413: 
414:   //   F[hmac_err]: 2:2
415:   prim_subreg #(
416:     .DW      (1),
417:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
418:     .RESVAL  (1'h0),
419:     .Mubi    (1'b0)
420:   ) u_intr_state_hmac_err (
421:     .clk_i   (clk_i),
422:     .rst_ni  (rst_ni),
423: 
424:     // from register interface
425:     .we     (intr_state_we),
426:     .wd     (intr_state_hmac_err_wd),
427: 
428:     // from internal hardware
429:     .de     (hw2reg.intr_state.hmac_err.de),
430:     .d      (hw2reg.intr_state.hmac_err.d),
431: 
432:     // to internal hardware
433:     .qe     (),
434:     .q      (reg2hw.intr_state.hmac_err.q),
435:     .ds     (),
436: 
437:     // to register interface (read)
438:     .qs     (intr_state_hmac_err_qs)
439:   );
440: 
441: 
442:   // R[intr_enable]: V(False)
443:   //   F[hmac_done]: 0:0
444:   prim_subreg #(
445:     .DW      (1),
446:     .SwAccess(prim_subreg_pkg::SwAccessRW),
447:     .RESVAL  (1'h0),
448:     .Mubi    (1'b0)
449:   ) u_intr_enable_hmac_done (
450:     .clk_i   (clk_i),
451:     .rst_ni  (rst_ni),
452: 
453:     // from register interface
454:     .we     (intr_enable_we),
455:     .wd     (intr_enable_hmac_done_wd),
456: 
457:     // from internal hardware
458:     .de     (1'b0),
459:     .d      ('0),
460: 
461:     // to internal hardware
462:     .qe     (),
463:     .q      (reg2hw.intr_enable.hmac_done.q),
464:     .ds     (),
465: 
466:     // to register interface (read)
467:     .qs     (intr_enable_hmac_done_qs)
468:   );
469: 
470:   //   F[fifo_empty]: 1:1
471:   prim_subreg #(
472:     .DW      (1),
473:     .SwAccess(prim_subreg_pkg::SwAccessRW),
474:     .RESVAL  (1'h0),
475:     .Mubi    (1'b0)
476:   ) u_intr_enable_fifo_empty (
477:     .clk_i   (clk_i),
478:     .rst_ni  (rst_ni),
479: 
480:     // from register interface
481:     .we     (intr_enable_we),
482:     .wd     (intr_enable_fifo_empty_wd),
483: 
484:     // from internal hardware
485:     .de     (1'b0),
486:     .d      ('0),
487: 
488:     // to internal hardware
489:     .qe     (),
490:     .q      (reg2hw.intr_enable.fifo_empty.q),
491:     .ds     (),
492: 
493:     // to register interface (read)
494:     .qs     (intr_enable_fifo_empty_qs)
495:   );
496: 
497:   //   F[hmac_err]: 2:2
498:   prim_subreg #(
499:     .DW      (1),
500:     .SwAccess(prim_subreg_pkg::SwAccessRW),
501:     .RESVAL  (1'h0),
502:     .Mubi    (1'b0)
503:   ) u_intr_enable_hmac_err (
504:     .clk_i   (clk_i),
505:     .rst_ni  (rst_ni),
506: 
507:     // from register interface
508:     .we     (intr_enable_we),
509:     .wd     (intr_enable_hmac_err_wd),
510: 
511:     // from internal hardware
512:     .de     (1'b0),
513:     .d      ('0),
514: 
515:     // to internal hardware
516:     .qe     (),
517:     .q      (reg2hw.intr_enable.hmac_err.q),
518:     .ds     (),
519: 
520:     // to register interface (read)
521:     .qs     (intr_enable_hmac_err_qs)
522:   );
523: 
524: 
525:   // R[intr_test]: V(True)
526:   logic intr_test_qe;
527:   logic [2:0] intr_test_flds_we;
528:   assign intr_test_qe = &intr_test_flds_we;
529:   //   F[hmac_done]: 0:0
530:   prim_subreg_ext #(
531:     .DW    (1)
532:   ) u_intr_test_hmac_done (
533:     .re     (1'b0),
534:     .we     (intr_test_we),
535:     .wd     (intr_test_hmac_done_wd),
536:     .d      ('0),
537:     .qre    (),
538:     .qe     (intr_test_flds_we[0]),
539:     .q      (reg2hw.intr_test.hmac_done.q),
540:     .ds     (),
541:     .qs     ()
542:   );
543:   assign reg2hw.intr_test.hmac_done.qe = intr_test_qe;
544: 
545:   //   F[fifo_empty]: 1:1
546:   prim_subreg_ext #(
547:     .DW    (1)
548:   ) u_intr_test_fifo_empty (
549:     .re     (1'b0),
550:     .we     (intr_test_we),
551:     .wd     (intr_test_fifo_empty_wd),
552:     .d      ('0),
553:     .qre    (),
554:     .qe     (intr_test_flds_we[1]),
555:     .q      (reg2hw.intr_test.fifo_empty.q),
556:     .ds     (),
557:     .qs     ()
558:   );
559:   assign reg2hw.intr_test.fifo_empty.qe = intr_test_qe;
560: 
561:   //   F[hmac_err]: 2:2
562:   prim_subreg_ext #(
563:     .DW    (1)
564:   ) u_intr_test_hmac_err (
565:     .re     (1'b0),
566:     .we     (intr_test_we),
567:     .wd     (intr_test_hmac_err_wd),
568:     .d      ('0),
569:     .qre    (),
570:     .qe     (intr_test_flds_we[2]),
571:     .q      (reg2hw.intr_test.hmac_err.q),
572:     .ds     (),
573:     .qs     ()
574:   );
575:   assign reg2hw.intr_test.hmac_err.qe = intr_test_qe;
576: 
577: 
578:   // R[alert_test]: V(True)
579:   logic alert_test_qe;
580:   logic [0:0] alert_test_flds_we;
581:   assign alert_test_qe = &alert_test_flds_we;
582:   prim_subreg_ext #(
583:     .DW    (1)
584:   ) u_alert_test (
585:     .re     (1'b0),
586:     .we     (alert_test_we),
587:     .wd     (alert_test_wd),
588:     .d      ('0),
589:     .qre    (),
590:     .qe     (alert_test_flds_we[0]),
591:     .q      (reg2hw.alert_test.q),
592:     .ds     (),
593:     .qs     ()
594:   );
595:   assign reg2hw.alert_test.qe = alert_test_qe;
596: 
597: 
598:   // R[cfg]: V(True)
599:   logic cfg_qe;
600:   logic [6:0] cfg_flds_we;
601:   assign cfg_qe = &cfg_flds_we;
602:   //   F[hmac_en]: 0:0
603:   prim_subreg_ext #(
604:     .DW    (1)
605:   ) u_cfg_hmac_en (
606:     .re     (cfg_re),
607:     .we     (cfg_we),
608:     .wd     (cfg_hmac_en_wd),
609:     .d      (hw2reg.cfg.hmac_en.d),
610:     .qre    (),
611:     .qe     (cfg_flds_we[0]),
612:     .q      (reg2hw.cfg.hmac_en.q),
613:     .ds     (),
614:     .qs     (cfg_hmac_en_qs)
615:   );
616:   assign reg2hw.cfg.hmac_en.qe = cfg_qe;
617: 
618:   //   F[sha_en]: 1:1
619:   prim_subreg_ext #(
620:     .DW    (1)
621:   ) u_cfg_sha_en (
622:     .re     (cfg_re),
623:     .we     (cfg_we),
624:     .wd     (cfg_sha_en_wd),
625:     .d      (hw2reg.cfg.sha_en.d),
626:     .qre    (),
627:     .qe     (cfg_flds_we[1]),
628:     .q      (reg2hw.cfg.sha_en.q),
629:     .ds     (),
630:     .qs     (cfg_sha_en_qs)
631:   );
632:   assign reg2hw.cfg.sha_en.qe = cfg_qe;
633: 
634:   //   F[endian_swap]: 2:2
635:   prim_subreg_ext #(
636:     .DW    (1)
637:   ) u_cfg_endian_swap (
638:     .re     (cfg_re),
639:     .we     (cfg_we),
640:     .wd     (cfg_endian_swap_wd),
641:     .d      (hw2reg.cfg.endian_swap.d),
642:     .qre    (),
643:     .qe     (cfg_flds_we[2]),
644:     .q      (reg2hw.cfg.endian_swap.q),
645:     .ds     (),
646:     .qs     (cfg_endian_swap_qs)
647:   );
648:   assign reg2hw.cfg.endian_swap.qe = cfg_qe;
649: 
650:   //   F[digest_swap]: 3:3
651:   prim_subreg_ext #(
652:     .DW    (1)
653:   ) u_cfg_digest_swap (
654:     .re     (cfg_re),
655:     .we     (cfg_we),
656:     .wd     (cfg_digest_swap_wd),
657:     .d      (hw2reg.cfg.digest_swap.d),
658:     .qre    (),
659:     .qe     (cfg_flds_we[3]),
660:     .q      (reg2hw.cfg.digest_swap.q),
661:     .ds     (),
662:     .qs     (cfg_digest_swap_qs)
663:   );
664:   assign reg2hw.cfg.digest_swap.qe = cfg_qe;
665: 
666:   //   F[key_swap]: 4:4
667:   prim_subreg_ext #(
668:     .DW    (1)
669:   ) u_cfg_key_swap (
670:     .re     (cfg_re),
671:     .we     (cfg_we),
672:     .wd     (cfg_key_swap_wd),
673:     .d      (hw2reg.cfg.key_swap.d),
674:     .qre    (),
675:     .qe     (cfg_flds_we[4]),
676:     .q      (reg2hw.cfg.key_swap.q),
677:     .ds     (),
678:     .qs     (cfg_key_swap_qs)
679:   );
680:   assign reg2hw.cfg.key_swap.qe = cfg_qe;
681: 
682:   //   F[digest_size]: 8:5
683:   prim_subreg_ext #(
684:     .DW    (4)
685:   ) u_cfg_digest_size (
686:     .re     (cfg_re),
687:     .we     (cfg_we),
688:     .wd     (cfg_digest_size_wd),
689:     .d      (hw2reg.cfg.digest_size.d),
690:     .qre    (),
691:     .qe     (cfg_flds_we[5]),
692:     .q      (reg2hw.cfg.digest_size.q),
693:     .ds     (),
694:     .qs     (cfg_digest_size_qs)
695:   );
696:   assign reg2hw.cfg.digest_size.qe = cfg_qe;
697: 
698:   //   F[key_length]: 14:9
699:   prim_subreg_ext #(
700:     .DW    (6)
701:   ) u_cfg_key_length (
702:     .re     (cfg_re),
703:     .we     (cfg_we),
704:     .wd     (cfg_key_length_wd),
705:     .d      (hw2reg.cfg.key_length.d),
706:     .qre    (),
707:     .qe     (cfg_flds_we[6]),
708:     .q      (reg2hw.cfg.key_length.q),
709:     .ds     (),
710:     .qs     (cfg_key_length_qs)
711:   );
712:   assign reg2hw.cfg.key_length.qe = cfg_qe;
713: 
714: 
715:   // R[cmd]: V(True)
716:   logic cmd_qe;
717:   logic [3:0] cmd_flds_we;
718:   assign cmd_qe = &cmd_flds_we;
719:   //   F[hash_start]: 0:0
720:   prim_subreg_ext #(
721:     .DW    (1)
722:   ) u_cmd_hash_start (
723:     .re     (1'b0),
724:     .we     (cmd_we),
725:     .wd     (cmd_hash_start_wd),
726:     .d      ('0),
727:     .qre    (),
728:     .qe     (cmd_flds_we[0]),
729:     .q      (reg2hw.cmd.hash_start.q),
730:     .ds     (),
731:     .qs     ()
732:   );
733:   assign reg2hw.cmd.hash_start.qe = cmd_qe;
734: 
735:   //   F[hash_process]: 1:1
736:   prim_subreg_ext #(
737:     .DW    (1)
738:   ) u_cmd_hash_process (
739:     .re     (1'b0),
740:     .we     (cmd_we),
741:     .wd     (cmd_hash_process_wd),
742:     .d      ('0),
743:     .qre    (),
744:     .qe     (cmd_flds_we[1]),
745:     .q      (reg2hw.cmd.hash_process.q),
746:     .ds     (),
747:     .qs     ()
748:   );
749:   assign reg2hw.cmd.hash_process.qe = cmd_qe;
750: 
751:   //   F[hash_stop]: 2:2
752:   prim_subreg_ext #(
753:     .DW    (1)
754:   ) u_cmd_hash_stop (
755:     .re     (1'b0),
756:     .we     (cmd_we),
757:     .wd     (cmd_hash_stop_wd),
758:     .d      ('0),
759:     .qre    (),
760:     .qe     (cmd_flds_we[2]),
761:     .q      (reg2hw.cmd.hash_stop.q),
762:     .ds     (),
763:     .qs     ()
764:   );
765:   assign reg2hw.cmd.hash_stop.qe = cmd_qe;
766: 
767:   //   F[hash_continue]: 3:3
768:   prim_subreg_ext #(
769:     .DW    (1)
770:   ) u_cmd_hash_continue (
771:     .re     (1'b0),
772:     .we     (cmd_we),
773:     .wd     (cmd_hash_continue_wd),
774:     .d      ('0),
775:     .qre    (),
776:     .qe     (cmd_flds_we[3]),
777:     .q      (reg2hw.cmd.hash_continue.q),
778:     .ds     (),
779:     .qs     ()
780:   );
781:   assign reg2hw.cmd.hash_continue.qe = cmd_qe;
782: 
783: 
784:   // R[status]: V(True)
785:   //   F[hmac_idle]: 0:0
786:   prim_subreg_ext #(
787:     .DW    (1)
788:   ) u_status_hmac_idle (
789:     .re     (status_re),
790:     .we     (1'b0),
791:     .wd     ('0),
792:     .d      (hw2reg.status.hmac_idle.d),
793:     .qre    (),
794:     .qe     (),
795:     .q      (),
796:     .ds     (),
797:     .qs     (status_hmac_idle_qs)
798:   );
799: 
800:   //   F[fifo_empty]: 1:1
801:   prim_subreg_ext #(
802:     .DW    (1)
803:   ) u_status_fifo_empty (
804:     .re     (status_re),
805:     .we     (1'b0),
806:     .wd     ('0),
807:     .d      (hw2reg.status.fifo_empty.d),
808:     .qre    (),
809:     .qe     (),
810:     .q      (),
811:     .ds     (),
812:     .qs     (status_fifo_empty_qs)
813:   );
814: 
815:   //   F[fifo_full]: 2:2
816:   prim_subreg_ext #(
817:     .DW    (1)
818:   ) u_status_fifo_full (
819:     .re     (status_re),
820:     .we     (1'b0),
821:     .wd     ('0),
822:     .d      (hw2reg.status.fifo_full.d),
823:     .qre    (),
824:     .qe     (),
825:     .q      (),
826:     .ds     (),
827:     .qs     (status_fifo_full_qs)
828:   );
829: 
830:   //   F[fifo_depth]: 9:4
831:   prim_subreg_ext #(
832:     .DW    (6)
833:   ) u_status_fifo_depth (
834:     .re     (status_re),
835:     .we     (1'b0),
836:     .wd     ('0),
837:     .d      (hw2reg.status.fifo_depth.d),
838:     .qre    (),
839:     .qe     (),
840:     .q      (),
841:     .ds     (),
842:     .qs     (status_fifo_depth_qs)
843:   );
844: 
845: 
846:   // R[err_code]: V(False)
847:   prim_subreg #(
848:     .DW      (32),
849:     .SwAccess(prim_subreg_pkg::SwAccessRO),
850:     .RESVAL  (32'h0),
851:     .Mubi    (1'b0)
852:   ) u_err_code (
853:     .clk_i   (clk_i),
854:     .rst_ni  (rst_ni),
855: 
856:     // from register interface
857:     .we     (1'b0),
858:     .wd     ('0),
859: 
860:     // from internal hardware
861:     .de     (hw2reg.err_code.de),
862:     .d      (hw2reg.err_code.d),
863: 
864:     // to internal hardware
865:     .qe     (),
866:     .q      (),
867:     .ds     (),
868: 
869:     // to register interface (read)
870:     .qs     (err_code_qs)
871:   );
872: 
873: 
874:   // R[wipe_secret]: V(True)
875:   logic wipe_secret_qe;
876:   logic [0:0] wipe_secret_flds_we;
877:   assign wipe_secret_qe = &wipe_secret_flds_we;
878:   prim_subreg_ext #(
879:     .DW    (32)
880:   ) u_wipe_secret (
881:     .re     (1'b0),
882:     .we     (wipe_secret_we),
883:     .wd     (wipe_secret_wd),
884:     .d      ('0),
885:     .qre    (),
886:     .qe     (wipe_secret_flds_we[0]),
887:     .q      (reg2hw.wipe_secret.q),
888:     .ds     (),
889:     .qs     ()
890:   );
891:   assign reg2hw.wipe_secret.qe = wipe_secret_qe;
892: 
893: 
894:   // Subregister 0 of Multireg key
895:   // R[key_0]: V(True)
896:   logic key_0_qe;
897:   logic [0:0] key_0_flds_we;
898:   assign key_0_qe = &key_0_flds_we;
899:   prim_subreg_ext #(
900:     .DW    (32)
901:   ) u_key_0 (
902:     .re     (1'b0),
903:     .we     (key_0_we),
904:     .wd     (key_0_wd),
905:     .d      (hw2reg.key[0].d),
906:     .qre    (),
907:     .qe     (key_0_flds_we[0]),
908:     .q      (reg2hw.key[0].q),
909:     .ds     (),
910:     .qs     ()
911:   );
912:   assign reg2hw.key[0].qe = key_0_qe;
913: 
914: 
915:   // Subregister 1 of Multireg key
916:   // R[key_1]: V(True)
917:   logic key_1_qe;
918:   logic [0:0] key_1_flds_we;
919:   assign key_1_qe = &key_1_flds_we;
920:   prim_subreg_ext #(
921:     .DW    (32)
922:   ) u_key_1 (
923:     .re     (1'b0),
924:     .we     (key_1_we),
925:     .wd     (key_1_wd),
926:     .d      (hw2reg.key[1].d),
927:     .qre    (),
928:     .qe     (key_1_flds_we[0]),
929:     .q      (reg2hw.key[1].q),
930:     .ds     (),
931:     .qs     ()
932:   );
933:   assign reg2hw.key[1].qe = key_1_qe;
934: 
935: 
936:   // Subregister 2 of Multireg key
937:   // R[key_2]: V(True)
938:   logic key_2_qe;
939:   logic [0:0] key_2_flds_we;
940:   assign key_2_qe = &key_2_flds_we;
941:   prim_subreg_ext #(
942:     .DW    (32)
943:   ) u_key_2 (
944:     .re     (1'b0),
945:     .we     (key_2_we),
946:     .wd     (key_2_wd),
947:     .d      (hw2reg.key[2].d),
948:     .qre    (),
949:     .qe     (key_2_flds_we[0]),
950:     .q      (reg2hw.key[2].q),
951:     .ds     (),
952:     .qs     ()
953:   );
954:   assign reg2hw.key[2].qe = key_2_qe;
955: 
956: 
957:   // Subregister 3 of Multireg key
958:   // R[key_3]: V(True)
959:   logic key_3_qe;
960:   logic [0:0] key_3_flds_we;
961:   assign key_3_qe = &key_3_flds_we;
962:   prim_subreg_ext #(
963:     .DW    (32)
964:   ) u_key_3 (
965:     .re     (1'b0),
966:     .we     (key_3_we),
967:     .wd     (key_3_wd),
968:     .d      (hw2reg.key[3].d),
969:     .qre    (),
970:     .qe     (key_3_flds_we[0]),
971:     .q      (reg2hw.key[3].q),
972:     .ds     (),
973:     .qs     ()
974:   );
975:   assign reg2hw.key[3].qe = key_3_qe;
976: 
977: 
978:   // Subregister 4 of Multireg key
979:   // R[key_4]: V(True)
980:   logic key_4_qe;
981:   logic [0:0] key_4_flds_we;
982:   assign key_4_qe = &key_4_flds_we;
983:   prim_subreg_ext #(
984:     .DW    (32)
985:   ) u_key_4 (
986:     .re     (1'b0),
987:     .we     (key_4_we),
988:     .wd     (key_4_wd),
989:     .d      (hw2reg.key[4].d),
990:     .qre    (),
991:     .qe     (key_4_flds_we[0]),
992:     .q      (reg2hw.key[4].q),
993:     .ds     (),
994:     .qs     ()
995:   );
996:   assign reg2hw.key[4].qe = key_4_qe;
997: 
998: 
999:   // Subregister 5 of Multireg key
1000:   // R[key_5]: V(True)
1001:   logic key_5_qe;
1002:   logic [0:0] key_5_flds_we;
1003:   assign key_5_qe = &key_5_flds_we;
1004:   prim_subreg_ext #(
1005:     .DW    (32)
1006:   ) u_key_5 (
1007:     .re     (1'b0),
1008:     .we     (key_5_we),
1009:     .wd     (key_5_wd),
1010:     .d      (hw2reg.key[5].d),
1011:     .qre    (),
1012:     .qe     (key_5_flds_we[0]),
1013:     .q      (reg2hw.key[5].q),
1014:     .ds     (),
1015:     .qs     ()
1016:   );
1017:   assign reg2hw.key[5].qe = key_5_qe;
1018: 
1019: 
1020:   // Subregister 6 of Multireg key
1021:   // R[key_6]: V(True)
1022:   logic key_6_qe;
1023:   logic [0:0] key_6_flds_we;
1024:   assign key_6_qe = &key_6_flds_we;
1025:   prim_subreg_ext #(
1026:     .DW    (32)
1027:   ) u_key_6 (
1028:     .re     (1'b0),
1029:     .we     (key_6_we),
1030:     .wd     (key_6_wd),
1031:     .d      (hw2reg.key[6].d),
1032:     .qre    (),
1033:     .qe     (key_6_flds_we[0]),
1034:     .q      (reg2hw.key[6].q),
1035:     .ds     (),
1036:     .qs     ()
1037:   );
1038:   assign reg2hw.key[6].qe = key_6_qe;
1039: 
1040: 
1041:   // Subregister 7 of Multireg key
1042:   // R[key_7]: V(True)
1043:   logic key_7_qe;
1044:   logic [0:0] key_7_flds_we;
1045:   assign key_7_qe = &key_7_flds_we;
1046:   prim_subreg_ext #(
1047:     .DW    (32)
1048:   ) u_key_7 (
1049:     .re     (1'b0),
1050:     .we     (key_7_we),
1051:     .wd     (key_7_wd),
1052:     .d      (hw2reg.key[7].d),
1053:     .qre    (),
1054:     .qe     (key_7_flds_we[0]),
1055:     .q      (reg2hw.key[7].q),
1056:     .ds     (),
1057:     .qs     ()
1058:   );
1059:   assign reg2hw.key[7].qe = key_7_qe;
1060: 
1061: 
1062:   // Subregister 8 of Multireg key
1063:   // R[key_8]: V(True)
1064:   logic key_8_qe;
1065:   logic [0:0] key_8_flds_we;
1066:   assign key_8_qe = &key_8_flds_we;
1067:   prim_subreg_ext #(
1068:     .DW    (32)
1069:   ) u_key_8 (
1070:     .re     (1'b0),
1071:     .we     (key_8_we),
1072:     .wd     (key_8_wd),
1073:     .d      (hw2reg.key[8].d),
1074:     .qre    (),
1075:     .qe     (key_8_flds_we[0]),
1076:     .q      (reg2hw.key[8].q),
1077:     .ds     (),
1078:     .qs     ()
1079:   );
1080:   assign reg2hw.key[8].qe = key_8_qe;
1081: 
1082: 
1083:   // Subregister 9 of Multireg key
1084:   // R[key_9]: V(True)
1085:   logic key_9_qe;
1086:   logic [0:0] key_9_flds_we;
1087:   assign key_9_qe = &key_9_flds_we;
1088:   prim_subreg_ext #(
1089:     .DW    (32)
1090:   ) u_key_9 (
1091:     .re     (1'b0),
1092:     .we     (key_9_we),
1093:     .wd     (key_9_wd),
1094:     .d      (hw2reg.key[9].d),
1095:     .qre    (),
1096:     .qe     (key_9_flds_we[0]),
1097:     .q      (reg2hw.key[9].q),
1098:     .ds     (),
1099:     .qs     ()
1100:   );
1101:   assign reg2hw.key[9].qe = key_9_qe;
1102: 
1103: 
1104:   // Subregister 10 of Multireg key
1105:   // R[key_10]: V(True)
1106:   logic key_10_qe;
1107:   logic [0:0] key_10_flds_we;
1108:   assign key_10_qe = &key_10_flds_we;
1109:   prim_subreg_ext #(
1110:     .DW    (32)
1111:   ) u_key_10 (
1112:     .re     (1'b0),
1113:     .we     (key_10_we),
1114:     .wd     (key_10_wd),
1115:     .d      (hw2reg.key[10].d),
1116:     .qre    (),
1117:     .qe     (key_10_flds_we[0]),
1118:     .q      (reg2hw.key[10].q),
1119:     .ds     (),
1120:     .qs     ()
1121:   );
1122:   assign reg2hw.key[10].qe = key_10_qe;
1123: 
1124: 
1125:   // Subregister 11 of Multireg key
1126:   // R[key_11]: V(True)
1127:   logic key_11_qe;
1128:   logic [0:0] key_11_flds_we;
1129:   assign key_11_qe = &key_11_flds_we;
1130:   prim_subreg_ext #(
1131:     .DW    (32)
1132:   ) u_key_11 (
1133:     .re     (1'b0),
1134:     .we     (key_11_we),
1135:     .wd     (key_11_wd),
1136:     .d      (hw2reg.key[11].d),
1137:     .qre    (),
1138:     .qe     (key_11_flds_we[0]),
1139:     .q      (reg2hw.key[11].q),
1140:     .ds     (),
1141:     .qs     ()
1142:   );
1143:   assign reg2hw.key[11].qe = key_11_qe;
1144: 
1145: 
1146:   // Subregister 12 of Multireg key
1147:   // R[key_12]: V(True)
1148:   logic key_12_qe;
1149:   logic [0:0] key_12_flds_we;
1150:   assign key_12_qe = &key_12_flds_we;
1151:   prim_subreg_ext #(
1152:     .DW    (32)
1153:   ) u_key_12 (
1154:     .re     (1'b0),
1155:     .we     (key_12_we),
1156:     .wd     (key_12_wd),
1157:     .d      (hw2reg.key[12].d),
1158:     .qre    (),
1159:     .qe     (key_12_flds_we[0]),
1160:     .q      (reg2hw.key[12].q),
1161:     .ds     (),
1162:     .qs     ()
1163:   );
1164:   assign reg2hw.key[12].qe = key_12_qe;
1165: 
1166: 
1167:   // Subregister 13 of Multireg key
1168:   // R[key_13]: V(True)
1169:   logic key_13_qe;
1170:   logic [0:0] key_13_flds_we;
1171:   assign key_13_qe = &key_13_flds_we;
1172:   prim_subreg_ext #(
1173:     .DW    (32)
1174:   ) u_key_13 (
1175:     .re     (1'b0),
1176:     .we     (key_13_we),
1177:     .wd     (key_13_wd),
1178:     .d      (hw2reg.key[13].d),
1179:     .qre    (),
1180:     .qe     (key_13_flds_we[0]),
1181:     .q      (reg2hw.key[13].q),
1182:     .ds     (),
1183:     .qs     ()
1184:   );
1185:   assign reg2hw.key[13].qe = key_13_qe;
1186: 
1187: 
1188:   // Subregister 14 of Multireg key
1189:   // R[key_14]: V(True)
1190:   logic key_14_qe;
1191:   logic [0:0] key_14_flds_we;
1192:   assign key_14_qe = &key_14_flds_we;
1193:   prim_subreg_ext #(
1194:     .DW    (32)
1195:   ) u_key_14 (
1196:     .re     (1'b0),
1197:     .we     (key_14_we),
1198:     .wd     (key_14_wd),
1199:     .d      (hw2reg.key[14].d),
1200:     .qre    (),
1201:     .qe     (key_14_flds_we[0]),
1202:     .q      (reg2hw.key[14].q),
1203:     .ds     (),
1204:     .qs     ()
1205:   );
1206:   assign reg2hw.key[14].qe = key_14_qe;
1207: 
1208: 
1209:   // Subregister 15 of Multireg key
1210:   // R[key_15]: V(True)
1211:   logic key_15_qe;
1212:   logic [0:0] key_15_flds_we;
1213:   assign key_15_qe = &key_15_flds_we;
1214:   prim_subreg_ext #(
1215:     .DW    (32)
1216:   ) u_key_15 (
1217:     .re     (1'b0),
1218:     .we     (key_15_we),
1219:     .wd     (key_15_wd),
1220:     .d      (hw2reg.key[15].d),
1221:     .qre    (),
1222:     .qe     (key_15_flds_we[0]),
1223:     .q      (reg2hw.key[15].q),
1224:     .ds     (),
1225:     .qs     ()
1226:   );
1227:   assign reg2hw.key[15].qe = key_15_qe;
1228: 
1229: 
1230:   // Subregister 16 of Multireg key
1231:   // R[key_16]: V(True)
1232:   logic key_16_qe;
1233:   logic [0:0] key_16_flds_we;
1234:   assign key_16_qe = &key_16_flds_we;
1235:   prim_subreg_ext #(
1236:     .DW    (32)
1237:   ) u_key_16 (
1238:     .re     (1'b0),
1239:     .we     (key_16_we),
1240:     .wd     (key_16_wd),
1241:     .d      (hw2reg.key[16].d),
1242:     .qre    (),
1243:     .qe     (key_16_flds_we[0]),
1244:     .q      (reg2hw.key[16].q),
1245:     .ds     (),
1246:     .qs     ()
1247:   );
1248:   assign reg2hw.key[16].qe = key_16_qe;
1249: 
1250: 
1251:   // Subregister 17 of Multireg key
1252:   // R[key_17]: V(True)
1253:   logic key_17_qe;
1254:   logic [0:0] key_17_flds_we;
1255:   assign key_17_qe = &key_17_flds_we;
1256:   prim_subreg_ext #(
1257:     .DW    (32)
1258:   ) u_key_17 (
1259:     .re     (1'b0),
1260:     .we     (key_17_we),
1261:     .wd     (key_17_wd),
1262:     .d      (hw2reg.key[17].d),
1263:     .qre    (),
1264:     .qe     (key_17_flds_we[0]),
1265:     .q      (reg2hw.key[17].q),
1266:     .ds     (),
1267:     .qs     ()
1268:   );
1269:   assign reg2hw.key[17].qe = key_17_qe;
1270: 
1271: 
1272:   // Subregister 18 of Multireg key
1273:   // R[key_18]: V(True)
1274:   logic key_18_qe;
1275:   logic [0:0] key_18_flds_we;
1276:   assign key_18_qe = &key_18_flds_we;
1277:   prim_subreg_ext #(
1278:     .DW    (32)
1279:   ) u_key_18 (
1280:     .re     (1'b0),
1281:     .we     (key_18_we),
1282:     .wd     (key_18_wd),
1283:     .d      (hw2reg.key[18].d),
1284:     .qre    (),
1285:     .qe     (key_18_flds_we[0]),
1286:     .q      (reg2hw.key[18].q),
1287:     .ds     (),
1288:     .qs     ()
1289:   );
1290:   assign reg2hw.key[18].qe = key_18_qe;
1291: 
1292: 
1293:   // Subregister 19 of Multireg key
1294:   // R[key_19]: V(True)
1295:   logic key_19_qe;
1296:   logic [0:0] key_19_flds_we;
1297:   assign key_19_qe = &key_19_flds_we;
1298:   prim_subreg_ext #(
1299:     .DW    (32)
1300:   ) u_key_19 (
1301:     .re     (1'b0),
1302:     .we     (key_19_we),
1303:     .wd     (key_19_wd),
1304:     .d      (hw2reg.key[19].d),
1305:     .qre    (),
1306:     .qe     (key_19_flds_we[0]),
1307:     .q      (reg2hw.key[19].q),
1308:     .ds     (),
1309:     .qs     ()
1310:   );
1311:   assign reg2hw.key[19].qe = key_19_qe;
1312: 
1313: 
1314:   // Subregister 20 of Multireg key
1315:   // R[key_20]: V(True)
1316:   logic key_20_qe;
1317:   logic [0:0] key_20_flds_we;
1318:   assign key_20_qe = &key_20_flds_we;
1319:   prim_subreg_ext #(
1320:     .DW    (32)
1321:   ) u_key_20 (
1322:     .re     (1'b0),
1323:     .we     (key_20_we),
1324:     .wd     (key_20_wd),
1325:     .d      (hw2reg.key[20].d),
1326:     .qre    (),
1327:     .qe     (key_20_flds_we[0]),
1328:     .q      (reg2hw.key[20].q),
1329:     .ds     (),
1330:     .qs     ()
1331:   );
1332:   assign reg2hw.key[20].qe = key_20_qe;
1333: 
1334: 
1335:   // Subregister 21 of Multireg key
1336:   // R[key_21]: V(True)
1337:   logic key_21_qe;
1338:   logic [0:0] key_21_flds_we;
1339:   assign key_21_qe = &key_21_flds_we;
1340:   prim_subreg_ext #(
1341:     .DW    (32)
1342:   ) u_key_21 (
1343:     .re     (1'b0),
1344:     .we     (key_21_we),
1345:     .wd     (key_21_wd),
1346:     .d      (hw2reg.key[21].d),
1347:     .qre    (),
1348:     .qe     (key_21_flds_we[0]),
1349:     .q      (reg2hw.key[21].q),
1350:     .ds     (),
1351:     .qs     ()
1352:   );
1353:   assign reg2hw.key[21].qe = key_21_qe;
1354: 
1355: 
1356:   // Subregister 22 of Multireg key
1357:   // R[key_22]: V(True)
1358:   logic key_22_qe;
1359:   logic [0:0] key_22_flds_we;
1360:   assign key_22_qe = &key_22_flds_we;
1361:   prim_subreg_ext #(
1362:     .DW    (32)
1363:   ) u_key_22 (
1364:     .re     (1'b0),
1365:     .we     (key_22_we),
1366:     .wd     (key_22_wd),
1367:     .d      (hw2reg.key[22].d),
1368:     .qre    (),
1369:     .qe     (key_22_flds_we[0]),
1370:     .q      (reg2hw.key[22].q),
1371:     .ds     (),
1372:     .qs     ()
1373:   );
1374:   assign reg2hw.key[22].qe = key_22_qe;
1375: 
1376: 
1377:   // Subregister 23 of Multireg key
1378:   // R[key_23]: V(True)
1379:   logic key_23_qe;
1380:   logic [0:0] key_23_flds_we;
1381:   assign key_23_qe = &key_23_flds_we;
1382:   prim_subreg_ext #(
1383:     .DW    (32)
1384:   ) u_key_23 (
1385:     .re     (1'b0),
1386:     .we     (key_23_we),
1387:     .wd     (key_23_wd),
1388:     .d      (hw2reg.key[23].d),
1389:     .qre    (),
1390:     .qe     (key_23_flds_we[0]),
1391:     .q      (reg2hw.key[23].q),
1392:     .ds     (),
1393:     .qs     ()
1394:   );
1395:   assign reg2hw.key[23].qe = key_23_qe;
1396: 
1397: 
1398:   // Subregister 24 of Multireg key
1399:   // R[key_24]: V(True)
1400:   logic key_24_qe;
1401:   logic [0:0] key_24_flds_we;
1402:   assign key_24_qe = &key_24_flds_we;
1403:   prim_subreg_ext #(
1404:     .DW    (32)
1405:   ) u_key_24 (
1406:     .re     (1'b0),
1407:     .we     (key_24_we),
1408:     .wd     (key_24_wd),
1409:     .d      (hw2reg.key[24].d),
1410:     .qre    (),
1411:     .qe     (key_24_flds_we[0]),
1412:     .q      (reg2hw.key[24].q),
1413:     .ds     (),
1414:     .qs     ()
1415:   );
1416:   assign reg2hw.key[24].qe = key_24_qe;
1417: 
1418: 
1419:   // Subregister 25 of Multireg key
1420:   // R[key_25]: V(True)
1421:   logic key_25_qe;
1422:   logic [0:0] key_25_flds_we;
1423:   assign key_25_qe = &key_25_flds_we;
1424:   prim_subreg_ext #(
1425:     .DW    (32)
1426:   ) u_key_25 (
1427:     .re     (1'b0),
1428:     .we     (key_25_we),
1429:     .wd     (key_25_wd),
1430:     .d      (hw2reg.key[25].d),
1431:     .qre    (),
1432:     .qe     (key_25_flds_we[0]),
1433:     .q      (reg2hw.key[25].q),
1434:     .ds     (),
1435:     .qs     ()
1436:   );
1437:   assign reg2hw.key[25].qe = key_25_qe;
1438: 
1439: 
1440:   // Subregister 26 of Multireg key
1441:   // R[key_26]: V(True)
1442:   logic key_26_qe;
1443:   logic [0:0] key_26_flds_we;
1444:   assign key_26_qe = &key_26_flds_we;
1445:   prim_subreg_ext #(
1446:     .DW    (32)
1447:   ) u_key_26 (
1448:     .re     (1'b0),
1449:     .we     (key_26_we),
1450:     .wd     (key_26_wd),
1451:     .d      (hw2reg.key[26].d),
1452:     .qre    (),
1453:     .qe     (key_26_flds_we[0]),
1454:     .q      (reg2hw.key[26].q),
1455:     .ds     (),
1456:     .qs     ()
1457:   );
1458:   assign reg2hw.key[26].qe = key_26_qe;
1459: 
1460: 
1461:   // Subregister 27 of Multireg key
1462:   // R[key_27]: V(True)
1463:   logic key_27_qe;
1464:   logic [0:0] key_27_flds_we;
1465:   assign key_27_qe = &key_27_flds_we;
1466:   prim_subreg_ext #(
1467:     .DW    (32)
1468:   ) u_key_27 (
1469:     .re     (1'b0),
1470:     .we     (key_27_we),
1471:     .wd     (key_27_wd),
1472:     .d      (hw2reg.key[27].d),
1473:     .qre    (),
1474:     .qe     (key_27_flds_we[0]),
1475:     .q      (reg2hw.key[27].q),
1476:     .ds     (),
1477:     .qs     ()
1478:   );
1479:   assign reg2hw.key[27].qe = key_27_qe;
1480: 
1481: 
1482:   // Subregister 28 of Multireg key
1483:   // R[key_28]: V(True)
1484:   logic key_28_qe;
1485:   logic [0:0] key_28_flds_we;
1486:   assign key_28_qe = &key_28_flds_we;
1487:   prim_subreg_ext #(
1488:     .DW    (32)
1489:   ) u_key_28 (
1490:     .re     (1'b0),
1491:     .we     (key_28_we),
1492:     .wd     (key_28_wd),
1493:     .d      (hw2reg.key[28].d),
1494:     .qre    (),
1495:     .qe     (key_28_flds_we[0]),
1496:     .q      (reg2hw.key[28].q),
1497:     .ds     (),
1498:     .qs     ()
1499:   );
1500:   assign reg2hw.key[28].qe = key_28_qe;
1501: 
1502: 
1503:   // Subregister 29 of Multireg key
1504:   // R[key_29]: V(True)
1505:   logic key_29_qe;
1506:   logic [0:0] key_29_flds_we;
1507:   assign key_29_qe = &key_29_flds_we;
1508:   prim_subreg_ext #(
1509:     .DW    (32)
1510:   ) u_key_29 (
1511:     .re     (1'b0),
1512:     .we     (key_29_we),
1513:     .wd     (key_29_wd),
1514:     .d      (hw2reg.key[29].d),
1515:     .qre    (),
1516:     .qe     (key_29_flds_we[0]),
1517:     .q      (reg2hw.key[29].q),
1518:     .ds     (),
1519:     .qs     ()
1520:   );
1521:   assign reg2hw.key[29].qe = key_29_qe;
1522: 
1523: 
1524:   // Subregister 30 of Multireg key
1525:   // R[key_30]: V(True)
1526:   logic key_30_qe;
1527:   logic [0:0] key_30_flds_we;
1528:   assign key_30_qe = &key_30_flds_we;
1529:   prim_subreg_ext #(
1530:     .DW    (32)
1531:   ) u_key_30 (
1532:     .re     (1'b0),
1533:     .we     (key_30_we),
1534:     .wd     (key_30_wd),
1535:     .d      (hw2reg.key[30].d),
1536:     .qre    (),
1537:     .qe     (key_30_flds_we[0]),
1538:     .q      (reg2hw.key[30].q),
1539:     .ds     (),
1540:     .qs     ()
1541:   );
1542:   assign reg2hw.key[30].qe = key_30_qe;
1543: 
1544: 
1545:   // Subregister 31 of Multireg key
1546:   // R[key_31]: V(True)
1547:   logic key_31_qe;
1548:   logic [0:0] key_31_flds_we;
1549:   assign key_31_qe = &key_31_flds_we;
1550:   prim_subreg_ext #(
1551:     .DW    (32)
1552:   ) u_key_31 (
1553:     .re     (1'b0),
1554:     .we     (key_31_we),
1555:     .wd     (key_31_wd),
1556:     .d      (hw2reg.key[31].d),
1557:     .qre    (),
1558:     .qe     (key_31_flds_we[0]),
1559:     .q      (reg2hw.key[31].q),
1560:     .ds     (),
1561:     .qs     ()
1562:   );
1563:   assign reg2hw.key[31].qe = key_31_qe;
1564: 
1565: 
1566:   // Subregister 0 of Multireg digest
1567:   // R[digest_0]: V(True)
1568:   logic digest_0_qe;
1569:   logic [0:0] digest_0_flds_we;
1570:   assign digest_0_qe = &digest_0_flds_we;
1571:   prim_subreg_ext #(
1572:     .DW    (32)
1573:   ) u_digest_0 (
1574:     .re     (digest_0_re),
1575:     .we     (digest_0_we),
1576:     .wd     (digest_0_wd),
1577:     .d      (hw2reg.digest[0].d),
1578:     .qre    (),
1579:     .qe     (digest_0_flds_we[0]),
1580:     .q      (reg2hw.digest[0].q),
1581:     .ds     (),
1582:     .qs     (digest_0_qs)
1583:   );
1584:   assign reg2hw.digest[0].qe = digest_0_qe;
1585: 
1586: 
1587:   // Subregister 1 of Multireg digest
1588:   // R[digest_1]: V(True)
1589:   logic digest_1_qe;
1590:   logic [0:0] digest_1_flds_we;
1591:   assign digest_1_qe = &digest_1_flds_we;
1592:   prim_subreg_ext #(
1593:     .DW    (32)
1594:   ) u_digest_1 (
1595:     .re     (digest_1_re),
1596:     .we     (digest_1_we),
1597:     .wd     (digest_1_wd),
1598:     .d      (hw2reg.digest[1].d),
1599:     .qre    (),
1600:     .qe     (digest_1_flds_we[0]),
1601:     .q      (reg2hw.digest[1].q),
1602:     .ds     (),
1603:     .qs     (digest_1_qs)
1604:   );
1605:   assign reg2hw.digest[1].qe = digest_1_qe;
1606: 
1607: 
1608:   // Subregister 2 of Multireg digest
1609:   // R[digest_2]: V(True)
1610:   logic digest_2_qe;
1611:   logic [0:0] digest_2_flds_we;
1612:   assign digest_2_qe = &digest_2_flds_we;
1613:   prim_subreg_ext #(
1614:     .DW    (32)
1615:   ) u_digest_2 (
1616:     .re     (digest_2_re),
1617:     .we     (digest_2_we),
1618:     .wd     (digest_2_wd),
1619:     .d      (hw2reg.digest[2].d),
1620:     .qre    (),
1621:     .qe     (digest_2_flds_we[0]),
1622:     .q      (reg2hw.digest[2].q),
1623:     .ds     (),
1624:     .qs     (digest_2_qs)
1625:   );
1626:   assign reg2hw.digest[2].qe = digest_2_qe;
1627: 
1628: 
1629:   // Subregister 3 of Multireg digest
1630:   // R[digest_3]: V(True)
1631:   logic digest_3_qe;
1632:   logic [0:0] digest_3_flds_we;
1633:   assign digest_3_qe = &digest_3_flds_we;
1634:   prim_subreg_ext #(
1635:     .DW    (32)
1636:   ) u_digest_3 (
1637:     .re     (digest_3_re),
1638:     .we     (digest_3_we),
1639:     .wd     (digest_3_wd),
1640:     .d      (hw2reg.digest[3].d),
1641:     .qre    (),
1642:     .qe     (digest_3_flds_we[0]),
1643:     .q      (reg2hw.digest[3].q),
1644:     .ds     (),
1645:     .qs     (digest_3_qs)
1646:   );
1647:   assign reg2hw.digest[3].qe = digest_3_qe;
1648: 
1649: 
1650:   // Subregister 4 of Multireg digest
1651:   // R[digest_4]: V(True)
1652:   logic digest_4_qe;
1653:   logic [0:0] digest_4_flds_we;
1654:   assign digest_4_qe = &digest_4_flds_we;
1655:   prim_subreg_ext #(
1656:     .DW    (32)
1657:   ) u_digest_4 (
1658:     .re     (digest_4_re),
1659:     .we     (digest_4_we),
1660:     .wd     (digest_4_wd),
1661:     .d      (hw2reg.digest[4].d),
1662:     .qre    (),
1663:     .qe     (digest_4_flds_we[0]),
1664:     .q      (reg2hw.digest[4].q),
1665:     .ds     (),
1666:     .qs     (digest_4_qs)
1667:   );
1668:   assign reg2hw.digest[4].qe = digest_4_qe;
1669: 
1670: 
1671:   // Subregister 5 of Multireg digest
1672:   // R[digest_5]: V(True)
1673:   logic digest_5_qe;
1674:   logic [0:0] digest_5_flds_we;
1675:   assign digest_5_qe = &digest_5_flds_we;
1676:   prim_subreg_ext #(
1677:     .DW    (32)
1678:   ) u_digest_5 (
1679:     .re     (digest_5_re),
1680:     .we     (digest_5_we),
1681:     .wd     (digest_5_wd),
1682:     .d      (hw2reg.digest[5].d),
1683:     .qre    (),
1684:     .qe     (digest_5_flds_we[0]),
1685:     .q      (reg2hw.digest[5].q),
1686:     .ds     (),
1687:     .qs     (digest_5_qs)
1688:   );
1689:   assign reg2hw.digest[5].qe = digest_5_qe;
1690: 
1691: 
1692:   // Subregister 6 of Multireg digest
1693:   // R[digest_6]: V(True)
1694:   logic digest_6_qe;
1695:   logic [0:0] digest_6_flds_we;
1696:   assign digest_6_qe = &digest_6_flds_we;
1697:   prim_subreg_ext #(
1698:     .DW    (32)
1699:   ) u_digest_6 (
1700:     .re     (digest_6_re),
1701:     .we     (digest_6_we),
1702:     .wd     (digest_6_wd),
1703:     .d      (hw2reg.digest[6].d),
1704:     .qre    (),
1705:     .qe     (digest_6_flds_we[0]),
1706:     .q      (reg2hw.digest[6].q),
1707:     .ds     (),
1708:     .qs     (digest_6_qs)
1709:   );
1710:   assign reg2hw.digest[6].qe = digest_6_qe;
1711: 
1712: 
1713:   // Subregister 7 of Multireg digest
1714:   // R[digest_7]: V(True)
1715:   logic digest_7_qe;
1716:   logic [0:0] digest_7_flds_we;
1717:   assign digest_7_qe = &digest_7_flds_we;
1718:   prim_subreg_ext #(
1719:     .DW    (32)
1720:   ) u_digest_7 (
1721:     .re     (digest_7_re),
1722:     .we     (digest_7_we),
1723:     .wd     (digest_7_wd),
1724:     .d      (hw2reg.digest[7].d),
1725:     .qre    (),
1726:     .qe     (digest_7_flds_we[0]),
1727:     .q      (reg2hw.digest[7].q),
1728:     .ds     (),
1729:     .qs     (digest_7_qs)
1730:   );
1731:   assign reg2hw.digest[7].qe = digest_7_qe;
1732: 
1733: 
1734:   // Subregister 8 of Multireg digest
1735:   // R[digest_8]: V(True)
1736:   logic digest_8_qe;
1737:   logic [0:0] digest_8_flds_we;
1738:   assign digest_8_qe = &digest_8_flds_we;
1739:   prim_subreg_ext #(
1740:     .DW    (32)
1741:   ) u_digest_8 (
1742:     .re     (digest_8_re),
1743:     .we     (digest_8_we),
1744:     .wd     (digest_8_wd),
1745:     .d      (hw2reg.digest[8].d),
1746:     .qre    (),
1747:     .qe     (digest_8_flds_we[0]),
1748:     .q      (reg2hw.digest[8].q),
1749:     .ds     (),
1750:     .qs     (digest_8_qs)
1751:   );
1752:   assign reg2hw.digest[8].qe = digest_8_qe;
1753: 
1754: 
1755:   // Subregister 9 of Multireg digest
1756:   // R[digest_9]: V(True)
1757:   logic digest_9_qe;
1758:   logic [0:0] digest_9_flds_we;
1759:   assign digest_9_qe = &digest_9_flds_we;
1760:   prim_subreg_ext #(
1761:     .DW    (32)
1762:   ) u_digest_9 (
1763:     .re     (digest_9_re),
1764:     .we     (digest_9_we),
1765:     .wd     (digest_9_wd),
1766:     .d      (hw2reg.digest[9].d),
1767:     .qre    (),
1768:     .qe     (digest_9_flds_we[0]),
1769:     .q      (reg2hw.digest[9].q),
1770:     .ds     (),
1771:     .qs     (digest_9_qs)
1772:   );
1773:   assign reg2hw.digest[9].qe = digest_9_qe;
1774: 
1775: 
1776:   // Subregister 10 of Multireg digest
1777:   // R[digest_10]: V(True)
1778:   logic digest_10_qe;
1779:   logic [0:0] digest_10_flds_we;
1780:   assign digest_10_qe = &digest_10_flds_we;
1781:   prim_subreg_ext #(
1782:     .DW    (32)
1783:   ) u_digest_10 (
1784:     .re     (digest_10_re),
1785:     .we     (digest_10_we),
1786:     .wd     (digest_10_wd),
1787:     .d      (hw2reg.digest[10].d),
1788:     .qre    (),
1789:     .qe     (digest_10_flds_we[0]),
1790:     .q      (reg2hw.digest[10].q),
1791:     .ds     (),
1792:     .qs     (digest_10_qs)
1793:   );
1794:   assign reg2hw.digest[10].qe = digest_10_qe;
1795: 
1796: 
1797:   // Subregister 11 of Multireg digest
1798:   // R[digest_11]: V(True)
1799:   logic digest_11_qe;
1800:   logic [0:0] digest_11_flds_we;
1801:   assign digest_11_qe = &digest_11_flds_we;
1802:   prim_subreg_ext #(
1803:     .DW    (32)
1804:   ) u_digest_11 (
1805:     .re     (digest_11_re),
1806:     .we     (digest_11_we),
1807:     .wd     (digest_11_wd),
1808:     .d      (hw2reg.digest[11].d),
1809:     .qre    (),
1810:     .qe     (digest_11_flds_we[0]),
1811:     .q      (reg2hw.digest[11].q),
1812:     .ds     (),
1813:     .qs     (digest_11_qs)
1814:   );
1815:   assign reg2hw.digest[11].qe = digest_11_qe;
1816: 
1817: 
1818:   // Subregister 12 of Multireg digest
1819:   // R[digest_12]: V(True)
1820:   logic digest_12_qe;
1821:   logic [0:0] digest_12_flds_we;
1822:   assign digest_12_qe = &digest_12_flds_we;
1823:   prim_subreg_ext #(
1824:     .DW    (32)
1825:   ) u_digest_12 (
1826:     .re     (digest_12_re),
1827:     .we     (digest_12_we),
1828:     .wd     (digest_12_wd),
1829:     .d      (hw2reg.digest[12].d),
1830:     .qre    (),
1831:     .qe     (digest_12_flds_we[0]),
1832:     .q      (reg2hw.digest[12].q),
1833:     .ds     (),
1834:     .qs     (digest_12_qs)
1835:   );
1836:   assign reg2hw.digest[12].qe = digest_12_qe;
1837: 
1838: 
1839:   // Subregister 13 of Multireg digest
1840:   // R[digest_13]: V(True)
1841:   logic digest_13_qe;
1842:   logic [0:0] digest_13_flds_we;
1843:   assign digest_13_qe = &digest_13_flds_we;
1844:   prim_subreg_ext #(
1845:     .DW    (32)
1846:   ) u_digest_13 (
1847:     .re     (digest_13_re),
1848:     .we     (digest_13_we),
1849:     .wd     (digest_13_wd),
1850:     .d      (hw2reg.digest[13].d),
1851:     .qre    (),
1852:     .qe     (digest_13_flds_we[0]),
1853:     .q      (reg2hw.digest[13].q),
1854:     .ds     (),
1855:     .qs     (digest_13_qs)
1856:   );
1857:   assign reg2hw.digest[13].qe = digest_13_qe;
1858: 
1859: 
1860:   // Subregister 14 of Multireg digest
1861:   // R[digest_14]: V(True)
1862:   logic digest_14_qe;
1863:   logic [0:0] digest_14_flds_we;
1864:   assign digest_14_qe = &digest_14_flds_we;
1865:   prim_subreg_ext #(
1866:     .DW    (32)
1867:   ) u_digest_14 (
1868:     .re     (digest_14_re),
1869:     .we     (digest_14_we),
1870:     .wd     (digest_14_wd),
1871:     .d      (hw2reg.digest[14].d),
1872:     .qre    (),
1873:     .qe     (digest_14_flds_we[0]),
1874:     .q      (reg2hw.digest[14].q),
1875:     .ds     (),
1876:     .qs     (digest_14_qs)
1877:   );
1878:   assign reg2hw.digest[14].qe = digest_14_qe;
1879: 
1880: 
1881:   // Subregister 15 of Multireg digest
1882:   // R[digest_15]: V(True)
1883:   logic digest_15_qe;
1884:   logic [0:0] digest_15_flds_we;
1885:   assign digest_15_qe = &digest_15_flds_we;
1886:   prim_subreg_ext #(
1887:     .DW    (32)
1888:   ) u_digest_15 (
1889:     .re     (digest_15_re),
1890:     .we     (digest_15_we),
1891:     .wd     (digest_15_wd),
1892:     .d      (hw2reg.digest[15].d),
1893:     .qre    (),
1894:     .qe     (digest_15_flds_we[0]),
1895:     .q      (reg2hw.digest[15].q),
1896:     .ds     (),
1897:     .qs     (digest_15_qs)
1898:   );
1899:   assign reg2hw.digest[15].qe = digest_15_qe;
1900: 
1901: 
1902:   // R[msg_length_lower]: V(True)
1903:   logic msg_length_lower_qe;
1904:   logic [0:0] msg_length_lower_flds_we;
1905:   assign msg_length_lower_qe = &msg_length_lower_flds_we;
1906:   prim_subreg_ext #(
1907:     .DW    (32)
1908:   ) u_msg_length_lower (
1909:     .re     (msg_length_lower_re),
1910:     .we     (msg_length_lower_we),
1911:     .wd     (msg_length_lower_wd),
1912:     .d      (hw2reg.msg_length_lower.d),
1913:     .qre    (),
1914:     .qe     (msg_length_lower_flds_we[0]),
1915:     .q      (reg2hw.msg_length_lower.q),
1916:     .ds     (),
1917:     .qs     (msg_length_lower_qs)
1918:   );
1919:   assign reg2hw.msg_length_lower.qe = msg_length_lower_qe;
1920: 
1921: 
1922:   // R[msg_length_upper]: V(True)
1923:   logic msg_length_upper_qe;
1924:   logic [0:0] msg_length_upper_flds_we;
1925:   assign msg_length_upper_qe = &msg_length_upper_flds_we;
1926:   prim_subreg_ext #(
1927:     .DW    (32)
1928:   ) u_msg_length_upper (
1929:     .re     (msg_length_upper_re),
1930:     .we     (msg_length_upper_we),
1931:     .wd     (msg_length_upper_wd),
1932:     .d      (hw2reg.msg_length_upper.d),
1933:     .qre    (),
1934:     .qe     (msg_length_upper_flds_we[0]),
1935:     .q      (reg2hw.msg_length_upper.q),
1936:     .ds     (),
1937:     .qs     (msg_length_upper_qs)
1938:   );
1939:   assign reg2hw.msg_length_upper.qe = msg_length_upper_qe;
1940: 
1941: 
1942: 
1943:   logic [58:0] addr_hit;
1944:   always_comb begin
1945:     addr_hit = '0;
1946:     addr_hit[ 0] = (reg_addr == HMAC_INTR_STATE_OFFSET);
1947:     addr_hit[ 1] = (reg_addr == HMAC_INTR_ENABLE_OFFSET);
1948:     addr_hit[ 2] = (reg_addr == HMAC_INTR_TEST_OFFSET);
1949:     addr_hit[ 3] = (reg_addr == HMAC_ALERT_TEST_OFFSET);
1950:     addr_hit[ 4] = (reg_addr == HMAC_CFG_OFFSET);
1951:     addr_hit[ 5] = (reg_addr == HMAC_CMD_OFFSET);
1952:     addr_hit[ 6] = (reg_addr == HMAC_STATUS_OFFSET);
1953:     addr_hit[ 7] = (reg_addr == HMAC_ERR_CODE_OFFSET);
1954:     addr_hit[ 8] = (reg_addr == HMAC_WIPE_SECRET_OFFSET);
1955:     addr_hit[ 9] = (reg_addr == HMAC_KEY_0_OFFSET);
1956:     addr_hit[10] = (reg_addr == HMAC_KEY_1_OFFSET);
1957:     addr_hit[11] = (reg_addr == HMAC_KEY_2_OFFSET);
1958:     addr_hit[12] = (reg_addr == HMAC_KEY_3_OFFSET);
1959:     addr_hit[13] = (reg_addr == HMAC_KEY_4_OFFSET);
1960:     addr_hit[14] = (reg_addr == HMAC_KEY_5_OFFSET);
1961:     addr_hit[15] = (reg_addr == HMAC_KEY_6_OFFSET);
1962:     addr_hit[16] = (reg_addr == HMAC_KEY_7_OFFSET);
1963:     addr_hit[17] = (reg_addr == HMAC_KEY_8_OFFSET);
1964:     addr_hit[18] = (reg_addr == HMAC_KEY_9_OFFSET);
1965:     addr_hit[19] = (reg_addr == HMAC_KEY_10_OFFSET);
1966:     addr_hit[20] = (reg_addr == HMAC_KEY_11_OFFSET);
1967:     addr_hit[21] = (reg_addr == HMAC_KEY_12_OFFSET);
1968:     addr_hit[22] = (reg_addr == HMAC_KEY_13_OFFSET);
1969:     addr_hit[23] = (reg_addr == HMAC_KEY_14_OFFSET);
1970:     addr_hit[24] = (reg_addr == HMAC_KEY_15_OFFSET);
1971:     addr_hit[25] = (reg_addr == HMAC_KEY_16_OFFSET);
1972:     addr_hit[26] = (reg_addr == HMAC_KEY_17_OFFSET);
1973:     addr_hit[27] = (reg_addr == HMAC_KEY_18_OFFSET);
1974:     addr_hit[28] = (reg_addr == HMAC_KEY_19_OFFSET);
1975:     addr_hit[29] = (reg_addr == HMAC_KEY_20_OFFSET);
1976:     addr_hit[30] = (reg_addr == HMAC_KEY_21_OFFSET);
1977:     addr_hit[31] = (reg_addr == HMAC_KEY_22_OFFSET);
1978:     addr_hit[32] = (reg_addr == HMAC_KEY_23_OFFSET);
1979:     addr_hit[33] = (reg_addr == HMAC_KEY_24_OFFSET);
1980:     addr_hit[34] = (reg_addr == HMAC_KEY_25_OFFSET);
1981:     addr_hit[35] = (reg_addr == HMAC_KEY_26_OFFSET);
1982:     addr_hit[36] = (reg_addr == HMAC_KEY_27_OFFSET);
1983:     addr_hit[37] = (reg_addr == HMAC_KEY_28_OFFSET);
1984:     addr_hit[38] = (reg_addr == HMAC_KEY_29_OFFSET);
1985:     addr_hit[39] = (reg_addr == HMAC_KEY_30_OFFSET);
1986:     addr_hit[40] = (reg_addr == HMAC_KEY_31_OFFSET);
1987:     addr_hit[41] = (reg_addr == HMAC_DIGEST_0_OFFSET);
1988:     addr_hit[42] = (reg_addr == HMAC_DIGEST_1_OFFSET);
1989:     addr_hit[43] = (reg_addr == HMAC_DIGEST_2_OFFSET);
1990:     addr_hit[44] = (reg_addr == HMAC_DIGEST_3_OFFSET);
1991:     addr_hit[45] = (reg_addr == HMAC_DIGEST_4_OFFSET);
1992:     addr_hit[46] = (reg_addr == HMAC_DIGEST_5_OFFSET);
1993:     addr_hit[47] = (reg_addr == HMAC_DIGEST_6_OFFSET);
1994:     addr_hit[48] = (reg_addr == HMAC_DIGEST_7_OFFSET);
1995:     addr_hit[49] = (reg_addr == HMAC_DIGEST_8_OFFSET);
1996:     addr_hit[50] = (reg_addr == HMAC_DIGEST_9_OFFSET);
1997:     addr_hit[51] = (reg_addr == HMAC_DIGEST_10_OFFSET);
1998:     addr_hit[52] = (reg_addr == HMAC_DIGEST_11_OFFSET);
1999:     addr_hit[53] = (reg_addr == HMAC_DIGEST_12_OFFSET);
2000:     addr_hit[54] = (reg_addr == HMAC_DIGEST_13_OFFSET);
2001:     addr_hit[55] = (reg_addr == HMAC_DIGEST_14_OFFSET);
2002:     addr_hit[56] = (reg_addr == HMAC_DIGEST_15_OFFSET);
2003:     addr_hit[57] = (reg_addr == HMAC_MSG_LENGTH_LOWER_OFFSET);
2004:     addr_hit[58] = (reg_addr == HMAC_MSG_LENGTH_UPPER_OFFSET);
2005:   end
2006: 
2007:   assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;
2008: 
2009:   // Check sub-word write is permitted
2010:   always_comb begin
2011:     wr_err = (reg_we &
2012:               ((addr_hit[ 0] & (|(HMAC_PERMIT[ 0] & ~reg_be))) |
2013:                (addr_hit[ 1] & (|(HMAC_PERMIT[ 1] & ~reg_be))) |
2014:                (addr_hit[ 2] & (|(HMAC_PERMIT[ 2] & ~reg_be))) |
2015:                (addr_hit[ 3] & (|(HMAC_PERMIT[ 3] & ~reg_be))) |
2016:                (addr_hit[ 4] & (|(HMAC_PERMIT[ 4] & ~reg_be))) |
2017:                (addr_hit[ 5] & (|(HMAC_PERMIT[ 5] & ~reg_be))) |
2018:                (addr_hit[ 6] & (|(HMAC_PERMIT[ 6] & ~reg_be))) |
2019:                (addr_hit[ 7] & (|(HMAC_PERMIT[ 7] & ~reg_be))) |
2020:                (addr_hit[ 8] & (|(HMAC_PERMIT[ 8] & ~reg_be))) |
2021:                (addr_hit[ 9] & (|(HMAC_PERMIT[ 9] & ~reg_be))) |
2022:                (addr_hit[10] & (|(HMAC_PERMIT[10] & ~reg_be))) |
2023:                (addr_hit[11] & (|(HMAC_PERMIT[11] & ~reg_be))) |
2024:                (addr_hit[12] & (|(HMAC_PERMIT[12] & ~reg_be))) |
2025:                (addr_hit[13] & (|(HMAC_PERMIT[13] & ~reg_be))) |
2026:                (addr_hit[14] & (|(HMAC_PERMIT[14] & ~reg_be))) |
2027:                (addr_hit[15] & (|(HMAC_PERMIT[15] & ~reg_be))) |
2028:                (addr_hit[16] & (|(HMAC_PERMIT[16] & ~reg_be))) |
2029:                (addr_hit[17] & (|(HMAC_PERMIT[17] & ~reg_be))) |
2030:                (addr_hit[18] & (|(HMAC_PERMIT[18] & ~reg_be))) |
2031:                (addr_hit[19] & (|(HMAC_PERMIT[19] & ~reg_be))) |
2032:                (addr_hit[20] & (|(HMAC_PERMIT[20] & ~reg_be))) |
2033:                (addr_hit[21] & (|(HMAC_PERMIT[21] & ~reg_be))) |
2034:                (addr_hit[22] & (|(HMAC_PERMIT[22] & ~reg_be))) |
2035:                (addr_hit[23] & (|(HMAC_PERMIT[23] & ~reg_be))) |
2036:                (addr_hit[24] & (|(HMAC_PERMIT[24] & ~reg_be))) |
2037:                (addr_hit[25] & (|(HMAC_PERMIT[25] & ~reg_be))) |
2038:                (addr_hit[26] & (|(HMAC_PERMIT[26] & ~reg_be))) |
2039:                (addr_hit[27] & (|(HMAC_PERMIT[27] & ~reg_be))) |
2040:                (addr_hit[28] & (|(HMAC_PERMIT[28] & ~reg_be))) |
2041:                (addr_hit[29] & (|(HMAC_PERMIT[29] & ~reg_be))) |
2042:                (addr_hit[30] & (|(HMAC_PERMIT[30] & ~reg_be))) |
2043:                (addr_hit[31] & (|(HMAC_PERMIT[31] & ~reg_be))) |
2044:                (addr_hit[32] & (|(HMAC_PERMIT[32] & ~reg_be))) |
2045:                (addr_hit[33] & (|(HMAC_PERMIT[33] & ~reg_be))) |
2046:                (addr_hit[34] & (|(HMAC_PERMIT[34] & ~reg_be))) |
2047:                (addr_hit[35] & (|(HMAC_PERMIT[35] & ~reg_be))) |
2048:                (addr_hit[36] & (|(HMAC_PERMIT[36] & ~reg_be))) |
2049:                (addr_hit[37] & (|(HMAC_PERMIT[37] & ~reg_be))) |
2050:                (addr_hit[38] & (|(HMAC_PERMIT[38] & ~reg_be))) |
2051:                (addr_hit[39] & (|(HMAC_PERMIT[39] & ~reg_be))) |
2052:                (addr_hit[40] & (|(HMAC_PERMIT[40] & ~reg_be))) |
2053:                (addr_hit[41] & (|(HMAC_PERMIT[41] & ~reg_be))) |
2054:                (addr_hit[42] & (|(HMAC_PERMIT[42] & ~reg_be))) |
2055:                (addr_hit[43] & (|(HMAC_PERMIT[43] & ~reg_be))) |
2056:                (addr_hit[44] & (|(HMAC_PERMIT[44] & ~reg_be))) |
2057:                (addr_hit[45] & (|(HMAC_PERMIT[45] & ~reg_be))) |
2058:                (addr_hit[46] & (|(HMAC_PERMIT[46] & ~reg_be))) |
2059:                (addr_hit[47] & (|(HMAC_PERMIT[47] & ~reg_be))) |
2060:                (addr_hit[48] & (|(HMAC_PERMIT[48] & ~reg_be))) |
2061:                (addr_hit[49] & (|(HMAC_PERMIT[49] & ~reg_be))) |
2062:                (addr_hit[50] & (|(HMAC_PERMIT[50] & ~reg_be))) |
2063:                (addr_hit[51] & (|(HMAC_PERMIT[51] & ~reg_be))) |
2064:                (addr_hit[52] & (|(HMAC_PERMIT[52] & ~reg_be))) |
2065:                (addr_hit[53] & (|(HMAC_PERMIT[53] & ~reg_be))) |
2066:                (addr_hit[54] & (|(HMAC_PERMIT[54] & ~reg_be))) |
2067:                (addr_hit[55] & (|(HMAC_PERMIT[55] & ~reg_be))) |
2068:                (addr_hit[56] & (|(HMAC_PERMIT[56] & ~reg_be))) |
2069:                (addr_hit[57] & (|(HMAC_PERMIT[57] & ~reg_be))) |
2070:                (addr_hit[58] & (|(HMAC_PERMIT[58] & ~reg_be)))));
2071:   end
2072: 
2073:   // Generate write-enables
2074:   assign intr_state_we = addr_hit[0] & reg_we & !reg_error;
2075: 
2076:   assign intr_state_hmac_done_wd = reg_wdata[0];
2077: 
2078:   assign intr_state_hmac_err_wd = reg_wdata[2];
2079:   assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;
2080: 
2081:   assign intr_enable_hmac_done_wd = reg_wdata[0];
2082: 
2083:   assign intr_enable_fifo_empty_wd = reg_wdata[1];
2084: 
2085:   assign intr_enable_hmac_err_wd = reg_wdata[2];
2086:   assign intr_test_we = addr_hit[2] & reg_we & !reg_error;
2087: 
2088:   assign intr_test_hmac_done_wd = reg_wdata[0];
2089: 
2090:   assign intr_test_fifo_empty_wd = reg_wdata[1];
2091: 
2092:   assign intr_test_hmac_err_wd = reg_wdata[2];
2093:   assign alert_test_we = addr_hit[3] & reg_we & !reg_error;
2094: 
2095:   assign alert_test_wd = reg_wdata[0];
2096:   assign cfg_re = addr_hit[4] & reg_re & !reg_error;
2097:   assign cfg_we = addr_hit[4] & reg_we & !reg_error;
2098: 
2099:   assign cfg_hmac_en_wd = reg_wdata[0];
2100: 
2101:   assign cfg_sha_en_wd = reg_wdata[1];
2102: 
2103:   assign cfg_endian_swap_wd = reg_wdata[2];
2104: 
2105:   assign cfg_digest_swap_wd = reg_wdata[3];
2106: 
2107:   assign cfg_key_swap_wd = reg_wdata[4];
2108: 
2109:   assign cfg_digest_size_wd = reg_wdata[8:5];
2110: 
2111:   assign cfg_key_length_wd = reg_wdata[14:9];
2112:   assign cmd_we = addr_hit[5] & reg_we & !reg_error;
2113: 
2114:   assign cmd_hash_start_wd = reg_wdata[0];
2115: 
2116:   assign cmd_hash_process_wd = reg_wdata[1];
2117: 
2118:   assign cmd_hash_stop_wd = reg_wdata[2];
2119: 
2120:   assign cmd_hash_continue_wd = reg_wdata[3];
2121:   assign status_re = addr_hit[6] & reg_re & !reg_error;
2122:   assign wipe_secret_we = addr_hit[8] & reg_we & reg_error;
2123: 
2124:   assign wipe_secret_wd = reg_wdata[31:0];
2125:   assign key_0_we = addr_hit[9] & reg_we & !reg_error;
2126: 
2127:   assign key_0_wd = reg_wdata[31:0];
2128:   assign key_1_we = addr_hit[10] & reg_we & !reg_error;
2129: 
2130:   assign key_1_wd = reg_wdata[31:0];
2131:   assign key_2_we = addr_hit[11] & reg_we & !reg_error;
2132: 
2133:   assign key_2_wd = reg_wdata[31:0];
2134:   assign key_3_we = addr_hit[12] & reg_we & !reg_error;
2135: 
2136:   assign key_3_wd = reg_wdata[31:0];
2137:   assign key_4_we = addr_hit[13] & reg_we & !reg_error;
2138: 
2139:   assign key_4_wd = reg_wdata[31:0];
2140:   assign key_5_we = addr_hit[14] & reg_we & !reg_error;
2141: 
2142:   assign key_5_wd = reg_wdata[31:0];
2143:   assign key_6_we = addr_hit[15] & reg_we & !reg_error;
2144: 
2145:   assign key_6_wd = reg_wdata[31:0];
2146:   assign key_7_we = addr_hit[16] & reg_we & !reg_error;
2147: 
2148:   assign key_7_wd = reg_wdata[31:0];
2149:   assign key_8_we = addr_hit[17] & reg_we & !reg_error;
2150: 
2151:   assign key_8_wd = reg_wdata[31:0];
2152:   assign key_9_we = addr_hit[18] & reg_we & !reg_error;
2153: 
2154:   assign key_9_wd = reg_wdata[31:0];
2155:   assign key_10_we = addr_hit[19] & reg_we & !reg_error;
2156: 
2157:   assign key_10_wd = reg_wdata[31:0];
2158:   assign key_11_we = addr_hit[20] & reg_we & !reg_error;
2159: 
2160:   assign key_11_wd = reg_wdata[31:0];
2161:   assign key_12_we = addr_hit[21] & reg_we & !reg_error;
2162: 
2163:   assign key_12_wd = reg_wdata[31:0];
2164:   assign key_13_we = addr_hit[22] & reg_we & !reg_error;
2165: 
2166:   assign key_13_wd = reg_wdata[31:0];
2167:   assign key_14_we = addr_hit[23] & reg_we & !reg_error;
2168: 
2169:   assign key_14_wd = reg_wdata[31:0];
2170:   assign key_15_we = addr_hit[24] & reg_we & !reg_error;
2171: 
2172:   assign key_15_wd = reg_wdata[31:0];
2173:   assign key_16_we = addr_hit[25] & reg_we & !reg_error;
2174: 
2175:   assign key_16_wd = reg_wdata[31:0];
2176:   assign key_17_we = addr_hit[26] & reg_we & !reg_error;
2177: 
2178:   assign key_17_wd = reg_wdata[31:0];
2179:   assign key_18_we = addr_hit[27] & reg_we & !reg_error;
2180: 
2181:   assign key_18_wd = reg_wdata[31:0];
2182:   assign key_19_we = addr_hit[28] & reg_we & !reg_error;
2183: 
2184:   assign key_19_wd = reg_wdata[31:0];
2185:   assign key_20_we = addr_hit[29] & reg_we & !reg_error;
2186: 
2187:   assign key_20_wd = reg_wdata[31:0];
2188:   assign key_21_we = addr_hit[30] & reg_we & !reg_error;
2189: 
2190:   assign key_21_wd = reg_wdata[31:0];
2191:   assign key_22_we = addr_hit[31] & reg_we & !reg_error;
2192: 
2193:   assign key_22_wd = reg_wdata[31:0];
2194:   assign key_23_we = addr_hit[32] & reg_we & !reg_error;
2195: 
2196:   assign key_23_wd = reg_wdata[31:0];
2197:   assign key_24_we = addr_hit[33] & reg_we & !reg_error;
2198: 
2199:   assign key_24_wd = reg_wdata[31:0];
2200:   assign key_25_we = addr_hit[34] & reg_we & !reg_error;
2201: 
2202:   assign key_25_wd = reg_wdata[31:0];
2203:   assign key_26_we = addr_hit[35] & reg_we & !reg_error;
2204: 
2205:   assign key_26_wd = reg_wdata[31:0];
2206:   assign key_27_we = addr_hit[36] & reg_we & !reg_error;
2207: 
2208:   assign key_27_wd = reg_wdata[31:0];
2209:   assign key_28_we = addr_hit[37] & reg_we & !reg_error;
2210: 
2211:   assign key_28_wd = reg_wdata[31:0];
2212:   assign key_29_we = addr_hit[38] & reg_we & !reg_error;
2213: 
2214:   assign key_29_wd = reg_wdata[31:0];
2215:   assign key_30_we = addr_hit[39] & reg_we & !reg_error;
2216: 
2217:   assign key_30_wd = reg_wdata[31:0];
2218:   assign key_31_we = addr_hit[40] & reg_we & !reg_error;
2219: 
2220:   assign key_31_wd = reg_wdata[31:0];
2221:   assign digest_0_re = addr_hit[41] & reg_re & !reg_error;
2222:   assign digest_0_we = addr_hit[41] & reg_we & !reg_error;
2223: 
2224:   assign digest_0_wd = reg_wdata[31:0];
2225:   assign digest_1_re = addr_hit[42] & reg_re & !reg_error;
2226:   assign digest_1_we = addr_hit[42] & reg_we & !reg_error;
2227: 
2228:   assign digest_1_wd = reg_wdata[31:0];
2229:   assign digest_2_re = addr_hit[43] & reg_re & !reg_error;
2230:   assign digest_2_we = addr_hit[43] & reg_we & !reg_error;
2231: 
2232:   assign digest_2_wd = reg_wdata[31:0];
2233:   assign digest_3_re = addr_hit[44] & reg_re & !reg_error;
2234:   assign digest_3_we = addr_hit[44] & reg_we & !reg_error;
2235: 
2236:   assign digest_3_wd = reg_wdata[31:0];
2237:   assign digest_4_re = addr_hit[45] & reg_re & !reg_error;
2238:   assign digest_4_we = addr_hit[45] & reg_we & !reg_error;
2239: 
2240:   assign digest_4_wd = reg_wdata[31:0];
2241:   assign digest_5_re = addr_hit[46] & reg_re & !reg_error;
2242:   assign digest_5_we = addr_hit[46] & reg_we & !reg_error;
2243: 
2244:   assign digest_5_wd = reg_wdata[31:0];
2245:   assign digest_6_re = addr_hit[47] & reg_re & !reg_error;
2246:   assign digest_6_we = addr_hit[47] & reg_we & !reg_error;
2247: 
2248:   assign digest_6_wd = reg_wdata[31:0];
2249:   assign digest_7_re = addr_hit[48] & reg_re & !reg_error;
2250:   assign digest_7_we = addr_hit[48] & reg_we & !reg_error;
2251: 
2252:   assign digest_7_wd = reg_wdata[31:0];
2253:   assign digest_8_re = addr_hit[49] & reg_re & !reg_error;
2254:   assign digest_8_we = addr_hit[49] & reg_we & !reg_error;
2255: 
2256:   assign digest_8_wd = reg_wdata[31:0];
2257:   assign digest_9_re = addr_hit[50] & reg_re & !reg_error;
2258:   assign digest_9_we = addr_hit[50] & reg_we & !reg_error;
2259: 
2260:   assign digest_9_wd = reg_wdata[31:0];
2261:   assign digest_10_re = addr_hit[51] & reg_re & !reg_error;
2262:   assign digest_10_we = addr_hit[51] & reg_we & !reg_error;
2263: 
2264:   assign digest_10_wd = reg_wdata[31:0];
2265:   assign digest_11_re = addr_hit[52] & reg_re & !reg_error;
2266:   assign digest_11_we = addr_hit[52] & reg_we & !reg_error;
2267: 
2268:   assign digest_11_wd = reg_wdata[31:0];
2269:   assign digest_12_re = addr_hit[53] & reg_re & !reg_error;
2270:   assign digest_12_we = addr_hit[53] & reg_we & !reg_error;
2271: 
2272:   assign digest_12_wd = reg_wdata[31:0];
2273:   assign digest_13_re = addr_hit[54] & reg_re & !reg_error;
2274:   assign digest_13_we = addr_hit[54] & reg_we & !reg_error;
2275: 
2276:   assign digest_13_wd = reg_wdata[31:0];
2277:   assign digest_14_re = addr_hit[55] & reg_re & !reg_error;
2278:   assign digest_14_we = addr_hit[55] & reg_we & !reg_error;
2279: 
2280:   assign digest_14_wd = reg_wdata[31:0];
2281:   assign digest_15_re = addr_hit[56] & reg_re & !reg_error;
2282:   assign digest_15_we = addr_hit[56] & reg_we & !reg_error;
2283: 
2284:   assign digest_15_wd = reg_wdata[31:0];
2285:   assign msg_length_lower_re = addr_hit[57] & reg_re & !reg_error;
2286:   assign msg_length_lower_we = addr_hit[57] & reg_we & !reg_error;
2287: 
2288:   assign msg_length_lower_wd = reg_wdata[31:0];
2289:   assign msg_length_upper_re = addr_hit[58] & reg_re & !reg_error;
2290:   assign msg_length_upper_we = addr_hit[58] & reg_we & !reg_error;
2291: 
2292:   assign msg_length_upper_wd = reg_wdata[31:0];
2293: 
2294:   // Assign write-enables to checker logic vector.
2295:   always_comb begin
2296:     reg_we_check = '0;
2297:     reg_we_check[0] = intr_state_we;
2298:     reg_we_check[1] = intr_enable_we;
2299:     reg_we_check[2] = intr_test_we;
2300:     reg_we_check[3] = alert_test_we;
2301:     reg_we_check[4] = cfg_we;
2302:     reg_we_check[5] = cmd_we;
2303:     reg_we_check[6] = 1'b0;
2304:     reg_we_check[7] = 1'b0;
2305:     reg_we_check[8] = wipe_secret_we;
2306:     reg_we_check[9] = key_0_we;
2307:     reg_we_check[10] = key_1_we;
2308:     reg_we_check[11] = key_2_we;
2309:     reg_we_check[12] = key_3_we;
2310:     reg_we_check[13] = key_4_we;
2311:     reg_we_check[14] = key_5_we;
2312:     reg_we_check[15] = key_6_we;
2313:     reg_we_check[16] = key_7_we;
2314:     reg_we_check[17] = key_8_we;
2315:     reg_we_check[18] = key_9_we;
2316:     reg_we_check[19] = key_10_we;
2317:     reg_we_check[20] = key_11_we;
2318:     reg_we_check[21] = key_12_we;
2319:     reg_we_check[22] = key_13_we;
2320:     reg_we_check[23] = key_14_we;
2321:     reg_we_check[24] = key_15_we;
2322:     reg_we_check[25] = key_16_we;
2323:     reg_we_check[26] = key_17_we;
2324:     reg_we_check[27] = key_18_we;
2325:     reg_we_check[28] = key_19_we;
2326:     reg_we_check[29] = key_20_we;
2327:     reg_we_check[30] = key_21_we;
2328:     reg_we_check[31] = key_22_we;
2329:     reg_we_check[32] = key_23_we;
2330:     reg_we_check[33] = key_24_we;
2331:     reg_we_check[34] = key_25_we;
2332:     reg_we_check[35] = key_26_we;
2333:     reg_we_check[36] = key_27_we;
2334:     reg_we_check[37] = key_28_we;
2335:     reg_we_check[38] = key_29_we;
2336:     reg_we_check[39] = key_30_we;
2337:     reg_we_check[40] = key_31_we;
2338:     reg_we_check[41] = digest_0_we;
2339:     reg_we_check[42] = digest_1_we;
2340:     reg_we_check[43] = digest_2_we;
2341:     reg_we_check[44] = digest_3_we;
2342:     reg_we_check[45] = digest_4_we;
2343:     reg_we_check[46] = digest_5_we;
2344:     reg_we_check[47] = digest_6_we;
2345:     reg_we_check[48] = digest_7_we;
2346:     reg_we_check[49] = digest_8_we;
2347:     reg_we_check[50] = digest_9_we;
2348:     reg_we_check[51] = digest_10_we;
2349:     reg_we_check[52] = digest_11_we;
2350:     reg_we_check[53] = digest_12_we;
2351:     reg_we_check[54] = digest_13_we;
2352:     reg_we_check[55] = digest_14_we;
2353:     reg_we_check[56] = digest_15_we;
2354:     reg_we_check[57] = msg_length_lower_we;
2355:     reg_we_check[58] = msg_length_upper_we;
2356:   end
2357: 
2358:   // Read data return
2359:   always_comb begin
2360:     reg_rdata_next = '0;
2361:     unique case (1'b1)
2362:       addr_hit[0]: begin
2363:         reg_rdata_next[0] = intr_state_hmac_done_qs;
2364:         reg_rdata_next[1] = intr_state_fifo_empty_qs;
2365:         reg_rdata_next[2] = intr_state_hmac_err_qs;
2366:       end
2367: 
2368:       addr_hit[1]: begin
2369:         reg_rdata_next[0] = intr_enable_hmac_done_qs;
2370:         reg_rdata_next[1] = intr_enable_fifo_empty_qs;
2371:         reg_rdata_next[2] = intr_enable_hmac_err_qs;
2372:       end
2373: 
2374:       addr_hit[2]: begin
2375:         reg_rdata_next[0] = '0;
2376:         reg_rdata_next[1] = '0;
2377:         reg_rdata_next[2] = '0;
2378:       end
2379: 
2380:       addr_hit[3]: begin
2381:         reg_rdata_next[0] = '0;
2382:       end
2383: 
2384:       addr_hit[4]: begin
2385:         reg_rdata_next[0] = cfg_hmac_en_qs;
2386:         reg_rdata_next[1] = cfg_sha_en_qs;
2387:         reg_rdata_next[2] = cfg_endian_swap_qs;
2388:         reg_rdata_next[3] = cfg_digest_swap_qs;
2389:         reg_rdata_next[4] = cfg_key_swap_qs;
2390:         reg_rdata_next[8:5] = cfg_digest_size_qs;
2391:         reg_rdata_next[14:9] = cfg_key_length_qs;
2392:       end
2393: 
2394:       addr_hit[5]: begin
2395:         reg_rdata_next[0] = '0;
2396:         reg_rdata_next[1] = '0;
2397:         reg_rdata_next[2] = '0;
2398:         reg_rdata_next[3] = '0;
2399:       end
2400: 
2401:       addr_hit[6]: begin
2402:         reg_rdata_next[0] = status_hmac_idle_qs;
2403:         reg_rdata_next[1] = status_fifo_empty_qs;
2404:         reg_rdata_next[2] = status_fifo_full_qs;
2405:         reg_rdata_next[9:4] = status_fifo_depth_qs;
2406:       end
2407: 
2408:       addr_hit[7]: begin
2409:         reg_rdata_next[31:0] = err_code_qs;
2410:       end
2411: 
2412:       addr_hit[8]: begin
2413:         reg_rdata_next[31:0] = reg2hw.key[0].q;
2414:       end
2415: 
2416:       addr_hit[9]: begin
2417:         reg_rdata_next[31:0] = reg2hw.key[1].q;
2418:       end
2419: 
2420:       addr_hit[10]: begin
2421:         reg_rdata_next[31:0] = '0;
2422:       end
2423: 
2424:       addr_hit[11]: begin
2425:         reg_rdata_next[31:0] = '0;
2426:       end
2427: 
2428:       addr_hit[12]: begin
2429:         reg_rdata_next[31:0] = '0;
2430:       end
2431: 
2432:       addr_hit[13]: begin
2433:         reg_rdata_next[31:0] = '0;
2434:       end
2435: 
2436:       addr_hit[14]: begin
2437:         reg_rdata_next[31:0] = '0;
2438:       end
2439: 
2440:       addr_hit[15]: begin
2441:         reg_rdata_next[31:0] = '0;
2442:       end
2443: 
2444:       addr_hit[16]: begin
2445:         reg_rdata_next[31:0] = '0;
2446:       end
2447: 
2448:       addr_hit[17]: begin
2449:         reg_rdata_next[31:0] = '0;
2450:       end
2451: 
2452:       addr_hit[18]: begin
2453:         reg_rdata_next[31:0] = '0;
2454:       end
2455: 
2456:       addr_hit[19]: begin
2457:         reg_rdata_next[31:0] = '0;
2458:       end
2459: 
2460:       addr_hit[20]: begin
2461:         reg_rdata_next[31:0] = '0;
2462:       end
2463: 
2464:       addr_hit[21]: begin
2465:         reg_rdata_next[31:0] = '0;
2466:       end
2467: 
2468:       addr_hit[22]: begin
2469:         reg_rdata_next[31:0] = '0;
2470:       end
2471: 
2472:       addr_hit[23]: begin
2473:         reg_rdata_next[31:0] = '0;
2474:       end
2475: 
2476:       addr_hit[24]: begin
2477:         reg_rdata_next[31:0] = '0;
2478:       end
2479: 
2480:       addr_hit[25]: begin
2481:         reg_rdata_next[31:0] = '0;
2482:       end
2483: 
2484:       addr_hit[26]: begin
2485:         reg_rdata_next[31:0] = '0;
2486:       end
2487: 
2488:       addr_hit[27]: begin
2489:         reg_rdata_next[31:0] = '0;
2490:       end
2491: 
2492:       addr_hit[28]: begin
2493:         reg_rdata_next[31:0] = '0;
2494:       end
2495: 
2496:       addr_hit[29]: begin
2497:         reg_rdata_next[31:0] = '0;
2498:       end
2499: 
2500:       addr_hit[30]: begin
2501:         reg_rdata_next[31:0] = '0;
2502:       end
2503: 
2504:       addr_hit[31]: begin
2505:         reg_rdata_next[31:0] = '0;
2506:       end
2507: 
2508:       addr_hit[32]: begin
2509:         reg_rdata_next[31:0] = '0;
2510:       end
2511: 
2512:       addr_hit[33]: begin
2513:         reg_rdata_next[31:0] = '0;
2514:       end
2515: 
2516:       addr_hit[34]: begin
2517:         reg_rdata_next[31:0] = '0;
2518:       end
2519: 
2520:       addr_hit[35]: begin
2521:         reg_rdata_next[31:0] = '0;
2522:       end
2523: 
2524:       addr_hit[36]: begin
2525:         reg_rdata_next[31:0] = '0;
2526:       end
2527: 
2528:       addr_hit[37]: begin
2529:         reg_rdata_next[31:0] = '0;
2530:       end
2531: 
2532:       addr_hit[38]: begin
2533:         reg_rdata_next[31:0] = '0;
2534:       end
2535: 
2536:       addr_hit[39]: begin
2537:         reg_rdata_next[31:0] = '0;
2538:       end
2539: 
2540:       addr_hit[40]: begin
2541:         reg_rdata_next[31:0] = '0;
2542:       end
2543: 
2544:       addr_hit[41]: begin
2545:         reg_rdata_next[31:0] = digest_0_qs;
2546:       end
2547: 
2548:       addr_hit[42]: begin
2549:         reg_rdata_next[31:0] = digest_1_qs;
2550:       end
2551: 
2552:       addr_hit[43]: begin
2553:         reg_rdata_next[31:0] = digest_2_qs;
2554:       end
2555: 
2556:       addr_hit[44]: begin
2557:         reg_rdata_next[31:0] = digest_3_qs;
2558:       end
2559: 
2560:       addr_hit[45]: begin
2561:         reg_rdata_next[31:0] = digest_4_qs;
2562:       end
2563: 
2564:       addr_hit[46]: begin
2565:         reg_rdata_next[31:0] = digest_5_qs;
2566:       end
2567: 
2568:       addr_hit[47]: begin
2569:         reg_rdata_next[31:0] = digest_6_qs;
2570:       end
2571: 
2572:       addr_hit[48]: begin
2573:         reg_rdata_next[31:0] = digest_7_qs;
2574:       end
2575: 
2576:       addr_hit[49]: begin
2577:         reg_rdata_next[31:0] = digest_8_qs;
2578:       end
2579: 
2580:       addr_hit[50]: begin
2581:         reg_rdata_next[31:0] = digest_9_qs;
2582:       end
2583: 
2584:       addr_hit[51]: begin
2585:         reg_rdata_next[31:0] = digest_10_qs;
2586:       end
2587: 
2588:       addr_hit[52]: begin
2589:         reg_rdata_next[31:0] = digest_11_qs;
2590:       end
2591: 
2592:       addr_hit[53]: begin
2593:         reg_rdata_next[31:0] = digest_12_qs;
2594:       end
2595: 
2596:       addr_hit[54]: begin
2597:         reg_rdata_next[31:0] = digest_13_qs;
2598:       end
2599: 
2600:       addr_hit[55]: begin
2601:         reg_rdata_next[31:0] = digest_14_qs;
2602:       end
2603: 
2604:       addr_hit[56]: begin
2605:         reg_rdata_next[31:0] = digest_15_qs;
2606:       end
2607: 
2608:       addr_hit[57]: begin
2609:         reg_rdata_next[31:0] = msg_length_lower_qs;
2610:       end
2611: 
2612:       addr_hit[58]: begin
2613:         reg_rdata_next[31:0] = msg_length_upper_qs;
2614:       end
2615: 
2616:       default: begin
2617:         reg_rdata_next = reg2hw.key[2].q;
2618:       end
2619:     endcase
2620:   end
2621: 
2622:   // shadow busy
2623:   logic shadow_busy;
2624:   assign shadow_busy = 1'b0;
2625: 
2626:   // register busy
2627:   assign reg_busy = shadow_busy;
2628: 
2629:   // Unused signal tieoff
2630: 
2631:   // wdata / byte enable are not always fully used
2632:   // add a blanket unused statement to handle lint waivers
2633:   logic unused_wdata;
2634:   logic unused_be;
2635:   assign unused_wdata = ^reg_wdata;
2636:   assign unused_be = ^reg_be;
2637: 
2638:   // Assertions for Register Interface
2639:   `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
2640:   `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)
2641: 
2642:   `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)
2643: 
2644:   `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)
2645: 
2646:   // this is formulated as an assumption such that the FPV testbenches do disprove this
2647:   // property by mistake
2648:   //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)
2649: 
2650: endmodule

================================== Ai Message ==================================
Tool Calls:
  run_linter_agent (call_glQNDqQT1Z44syWToSRsxEB9)
 Call ID: call_glQNDqQT1Z44syWToSRsxEB9
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_core.sv
    top_module: hmac_core
    security_objective: register interface and FSM security
================================= Tool Message =================================
Name: run_linter_agent

The lint check for the hmac_core module on the provided RTL code reported the following issues related to FSM and register interface security:

1. FSMNextStateName-ML (Error):
   - The next state register name "st_d" does not follow the naming convention which expects a suffix "_ns" for next state variables.
   - This is a coding style issue that can affect readability and maintainability but is not a direct security vulnerability.

2. FsmUsage-ML (Error):
   - The finite state machine usage was detected on the state variable "st_q".
   - This is an informational lint indicating FSM usage, not necessarily an error or security issue by itself.

3. STARC05-2.11.2.1 (Error):
   - The FSM description is mixed with non-FSM descriptions in the same module.
   - This can lead to confusion and potential errors in FSM behavior, which might indirectly affect security if the FSM controls critical operations like register interface and hash processing.
   - The violation is reported at line 311 in the hmac_core.sv file.

Summary:
- The main security-related concern is the mixing of FSM and non-FSM logic in the same module, which can cause FSM behavior issues.
- The naming convention violation is a style issue.
- No direct security vulnerabilities like livelock, missing state transitions, or unreachable states were reported.

Recommendation:
- Refactor the code to separate FSM logic from non-FSM logic to improve clarity and reduce risk of FSM-related bugs.
- Follow naming conventions for FSM state variables.
- Review FSM transitions and state handling carefully to ensure no security issues are introduced due to complex state interactions.

Overall, the RTL does not show explicit security vulnerabilities related to register interface or FSM security from the lint results, but improvements in FSM coding practices are advised to enhance robustness and maintainability.
================================== Ai Message ==================================
Tool Calls:
  run_assertions_checker_agent (call_1Wxes70Sw6T0AuRPxkWTTqYa)
 Call ID: call_1Wxes70Sw6T0AuRPxkWTTqYa
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv
    top_module: hmac_reg_top
    security_objective: register access control and privilege enforcement
================================= Tool Message =================================
Name: run_assertions_checker_agent

Based on the assertion checker results, I've identified a security concern in the HMAC register top module:

The `assert_integrity_error_handling` assertion was falsified, which indicates a potential security issue. This assertion checks whether an integrity error properly steers transactions to the register interface (setting `reg_steer` to 1'd1). The falsification suggests that when an integrity error occurs, the system might not always properly route transactions, which could lead to unauthorized access.

Looking at the code more closely, there's a section that handles integrity error steering:

```verilog
// Create steering logic
always_comb begin
  reg_steer =
      tl_i.a_address[AW-1:0] inside {[4096:8191]} ? 1'd0 :
      // Default set to register
      1'd1;

  // Override this in case of an integrity error
  if (intg_err) begin
    reg_steer = 1'd1;
  end
end
```

The assertion failure suggests that this override mechanism might not be working correctly in all cases. When an integrity error occurs, the code intends to force `reg_steer` to 1'd1, which should route transactions to the register interface rather than the window interface. However, the assertion failure indicates that this doesn't always happen as expected.

This is a security concern because:

1. If integrity errors don't properly redirect transactions, it could allow attackers to bypass security checks
2. Malformed transactions might still be processed by the window interface instead of being handled by the register interface
3. This could potentially lead to unauthorized access to sensitive registers or memory regions

The other assertions we tested (wipe_secret_protection and key_write_protection) passed, which suggests that:
1. The wipe_secret register is properly protected and can only be written when reg_error is active
2. Key registers are protected from writes when there are integrity or register errors

However, the integrity error handling issue is significant and should be addressed to ensure proper security of the HMAC module.
================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_4OD6BAAuxkOBJjCnJ7Xwqvia)
 Call ID: call_4OD6BAAuxkOBJjCnJ7Xwqvia
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_core.sv
    top_module: hmac_core
    security_objective: context switching and state isolation
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

[{"id": "toolu_01V2DxALpZm9sXNYMcnG8Nhc", "input": {"security_issue": "hardware state machine secure transitions"}, "name": "llm_cwe_details_retriever_tool", "type": "tool_use"}]
================================== Ai Message ==================================
Tool Calls:
  run_anomaly_detector_agent (call_Uvka3Z6xA8dCvCNKDaErNRTh)
 Call ID: call_Uvka3Z6xA8dCvCNKDaErNRTh
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_core.sv
    top_module: hmac_core
    security_objective: state machine and context switching anomalies
================================= Tool Message =================================
Name: run_anomaly_detector_agent

The anomaly detection tool clustered similar lines of code and identified a few clusters. The RTL code seems mostly consistent in its structure. Key clusters related to state machine and context switching are:

- Cluster 0 contains assignments related to control signals based on `hmac_en_i` and internal signals such as `hash_start`, `reg_hash_start_i`, `st_q`, etc. This controls context switching in the state machine.
- Cluster 1 relates to padding index calculations within the state machine.
- Cluster 2 relates to idle state logic.

No significant anomalous lines were flagged by the tool. However, let's analyze potential security concerns around state machine and context switching behavior from the code manually:

### Observations:

- The state machine progresses through several states: `StIdle`, `StIPad`, `StMsg`, `StPushToMsgFifo`, `StWaitResp`, `StOPad`, and `StDone`.
- The transitions appear orderly with clear conditions for moving between inner and outer pads and message processing.
- The design uses flags such as `reg_hash_stop_q` to enforce stopping conditions before transitioning.
- Context switching is controlled by round states `Inner` and `Outer` to compute the HMAC inner and outer digests.
- The counter `txcount` is cleared and loaded appropriately at state transitions to track progress through message blocks.
- Entry points to the state machine are gated by signals such as `reg_hash_start_i` and `reg_hash_continue_i`.
- Outputs like `sha_hash_start_o`, `sha_hash_continue_o`, `sha_hash_process_o` are multiplexed based on whether `hmac_en_i` is active.

### Potential Security-Related Anomalies (Manual):

1. **Race between stop and continue signals:**
   - The signals `reg_hash_stop_i`, `reg_hash_start_i`, `reg_hash_continue_i` control the FSM transitions.
   - If these signals are asserted or deasserted in unexpected sequences or glitches occur, the FSM could transition improperly causing partial or incomplete HMAC computation or state corruption.
   - The design does have `reg_hash_stop_q` registered to hold the stop state until hash done, reducing risks, but the interface requires careful synchronization.

2. **Context switching correctness:**
   - The FSM resets to `Inner` round in `StIdle` state and only transitions to `Outer` after the intermediate hash finishes.
   - If an attacker can manipulate `reg_hash_start_i` or `reg_hash_continue_i` asynchronously, they could cause out-of-order hashing potentially affecting HMAC security.
   - The FSM waits for `sha_hash_done_i` to move past `StWaitResp`, which should protect against premature transitions.

3. **Transaction count (txcount) handling:**
   - `txcount` is critical to ensure all message blocks are processed fully.
   - If loading or clearing `txcount` behaves incorrectly, hashes could be computed on wrong message lengths.
   - Given txcount increments on `sha_rready_i && sha_rvalid_o`, an attacker controlling FIFO ready/valid signals physically might influence progress.

4. **FIFO handling:**
   - The signals controlling reads/writes to the FIFO depend on states and round.
   - If the FIFO signals (`fifo_rvalid_i`, `fifo_wready_i`) behave unexpectedly or are attacked, this might cause data leaks or invalid data fed to the hash engine.

### Conclusion:

- The anomaly detection tool did not identify any suspicious or anomalous lines specifically.
- The design appears to follow a robust FSM pattern with structured state transitions, proper flagging, and synchronization signals that reduce obvious race conditions.
- The primary potential security concerns relate to how external control signals (start, stop, continue) and FIFO handshake signals are controlled, validated, and synchronized with the FSM clock domain.
- If attacker-controlled inputs to these signals are not correctly filtered or synchronized externally, it could lead to unintended states or partial HMAC computations.
- These issues would often be addressed in higher-level system design or with additional synchronization and input validation logic outside this module.

**No direct critical security anomalies were found in this RTL code related to state machine and context switching. The design looks secure under assumptions of properly controlled inputs.**

If you want, I can help suggest specific improvements or checks to further harden this RTL against misuse of start/stop/control signals.
================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_BNKdvr2tmCt6L6vq5HPsertw)
 Call ID: call_BNKdvr2tmCt6L6vq5HPsertw
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv
    top_module: hmac_reg_top
    security_objective: register access control and privilege enforcement
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

Based on my analysis of the provided RTL code and the CWE information, I can identify several security concerns related to register access control and privilege enforcement:

## Security Concerns in the HMAC Register Top Module

### 1. Lack of Privilege-Based Access Control

The RTL code implements a register interface for an HMAC cryptographic module, but there appears to be no privilege-level checking for register access. This relates to **CWE-1262: Improper Access Control for Register Interface**.

The code doesn't implement any mechanism to restrict access to sensitive registers based on the privilege level of the requesting agent. All registers appear to be accessible to any entity that can access the TileLink bus interface, without checking if the requester has appropriate privileges.

### 2. Sensitive Key Material Exposure

The module contains key registers (`key_0` through `key_31`) that store cryptographic key material. Looking at the implementation:

```verilog
// Subregister 0 of Multireg key
// R[key_0]: V(True)
logic key_0_qe;
logic [0:0] key_0_flds_we;
assign key_0_qe = &key_0_flds_we;
prim_subreg_ext #(
  .DW    (32)
) u_key_0 (
  .re     (1'b0),
  .we     (key_0_we),
  .wd     (key_0_wd),
  .d      (hw2reg.key[0].d),
  .qre    (),
  .qe     (key_0_flds_we[0]),
  .q      (reg2hw.key[0].q),
  .ds     (),
  .qs     ()
);
```

While the `.re(1'b0)` parameter suggests the key registers are not directly readable, there's a concerning implementation in the read data return logic:

```verilog
addr_hit[8]: begin
  reg_rdata_next[31:0] = reg2hw.key[0].q;
end

addr_hit[9]: begin
  reg_rdata_next[31:0] = reg2hw.key[1].q;
end
```

This suggests that at least the first two key registers (key_0 and key_1) can be read back, which is a security concern according to CWE-1262's guidance: "Key material stored in registers should never be accessible to software. Even if software can provide a key, all read-back paths to software should be disabled."

### 3. Inconsistent Access Control Policies

The register interface doesn't implement a consistent policy for controlling access to different types of registers. This relates to **CWE-1268: Policy Privileges are not Assigned Consistently Between Control and Data Agents**.

For example, there's no clear separation between:
- Configuration registers (like `cfg`)
- Control registers (like `cmd`)
- Key material registers
- Status registers

All these registers appear to be accessible through the same interface without differentiated access control policies.

### 4. Lack of Write Protection for Critical Registers

The code doesn't implement write protection for critical configuration registers. For example, the `cfg` register controls important security settings:

```verilog
//   F[hmac_en]: 0:0
//   F[sha_en]: 1:1
//   F[endian_swap]: 2:2
//   F[digest_swap]: 3:3
//   F[key_swap]: 4:4
//   F[digest_size]: 8:5
//   F[key_length]: 14:9
```

These configuration settings could potentially be modified by an attacker to weaken the cryptographic implementation, but there's no mechanism to lock these settings once configured.

### 5. No Integrity Protection for Register Values

While the code includes integrity checking for the TileLink interface:

```verilog
// incoming payload check
logic intg_err;
tlul_cmd_intg_chk u_chk (
  .tl_i(tl_i),
  .err_o(intg_err)
);
```

There doesn't appear to be integrity protection for the register values themselves, which could make them vulnerable to fault injection attacks.

## Conclusion

The HMAC register interface implementation has several security concerns related to
================================== Ai Message ==================================
Tool Calls:
  run_similar_bug_agent (call_IvLZ2WcB9vPmJEO81J2ah0Vr)
 Call ID: call_IvLZ2WcB9vPmJEO81J2ah0Vr
  Args:
    bug: reg_rdata_next[31:0] = reg2hw.key[0].q;
    file_path: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv
================================= Tool Message =================================
Name: run_similar_bug_agent

After carefully analyzing the similar bug instances found by the tool, I can identify the following potentially buggy lines:

1. Line 2413: `reg_rdata_next[31:0] = reg2hw.key[0].q;`
2. Line 2417: `reg_rdata_next[31:0] = reg2hw.key[1].q;`
3. Line 2617: `reg_rdata_next = reg2hw.key[2].q;`

These lines are part of the read data return logic in the `always_comb` block. The bug pattern seems to be related to how key data is being read back. 

The first two lines (2413 and 2417) are similar to the original bug you mentioned, where a specific key register's value is being directly assigned to `reg_rdata_next`.

The third line (2617) is in the default case of the `unique case` statement, which means if no other address hit is found, it will return the value of `key[2]`.

These could potentially be bugs because:
1. They might not handle all possible read scenarios correctly
2. They could expose sensitive key information inappropriately
3. They might not follow the intended read logic for key registers

I recommend a thorough review of these lines to ensure they align with the intended register read behavior.
================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_SU1CYlRbkVb7E9EeLmtKnRWF)
 Call ID: call_SU1CYlRbkVb7E9EeLmtKnRWF
  Args:
    design_filepath: /home/XXXX-2/hackdate/hw/ip/hmac/rtl/hmac_reg_top.sv
    top_module: hmac_reg_top
    security_objective: key register confidentiality
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

Based on the CWE information and analyzing the provided RTL code, I've identified several security concerns related to key register confidentiality in the HMAC module:

## Security Concerns with Key Register Confidentiality

### 1. Lack of Debug Mode Protection (CWE-1258)

The provided RTL code implements an HMAC register top module that handles cryptographic keys, but there's no mechanism to clear sensitive key registers when in debug mode. This aligns with CWE-1258: "Exposure of Sensitive System Information Due to Uncleared Debug Information."

Specific issues in the code:

- The module contains 32 key registers (key_0 through key_31) that store cryptographic key material
- There is no logic to clear these registers when debug mode is entered
- No debug mode signal is present in the module interface to trigger key clearing

### 2. Key Register Read Access

The code shows concerning behavior regarding key register access:

```verilog
// In the read data return logic
addr_hit[9]: begin
  reg_rdata_next[31:0] = reg2hw.key[1].q;
end

// Default case
default: begin
  reg_rdata_next = reg2hw.key[2].q;
end
```

This indicates that:
- Key register 1 can be directly read when its address is hit
- More concerning, key register 2 is returned as the default value when an invalid address is accessed
- This creates a potential information leakage path where attackers could read key material

### 3. Insufficient Key Protection Mechanisms

The module lacks several key protection mechanisms:

- No hardware-enforced access control for key registers
- No key masking or obfuscation when reading key values
- No mechanism to detect unauthorized key access attempts
- The wipe_secret register (for secure key erasure) is only activated on register error conditions

### 4. Key Register Visibility

The key registers are implemented using standard register logic without special protection:

```verilog
prim_subreg_ext #(
  .DW    (32)
) u_key_0 (
  .re     (1'b0),
  .we     (key_0_we),
  .wd     (key_0_wd),
  .d      (hw2reg.key[0].d),
  .qre    (),
  .qe     (key_0_flds_we[0]),
  .q      (reg2hw.key[0].q),
  .ds     (),
  .qs     ()
);
```

This implementation doesn't provide any special protection against side-channel attacks or debug visibility.

## Recommendations

1. Implement debug mode protection that clears all key registers when debug mode is entered
2. Remove the ability to read key registers directly through the register interface
3. Implement access control mechanisms for key registers
4. Add key masking or obfuscation when key values must be accessed
5. Implement secure key storage using hardware security modules or secure elements
6. Add monitoring for unauthorized key access attempts
7. Ensure the default case in the read data logic doesn't expose sensitive information

These issues could potentially allow attackers to extract cryptographic keys from the device, especially if they have debug access, compromising the security of the entire system.
================================== Ai Message ==================================

# OpenTitan HMAC IP Security Analysis Report

## 1. Security Features and Register Interface Policies

**Security Features (from documentation):**
- HMAC supports SHA-2 256/384/512 with secret key registers up to 1024 bits.
- Secret key registers are only writable when the engine is idle.
- Wipe secret mechanism: writing to `WIPE_SECRET` clears internal key and state.
- Endianness and digest output can be configured for cross-platform compatibility.
- Configuration and key registers are only updated when the engine is idle; writes during operation are ignored and flagged as errors.
- Error codes and interrupts are provided for error handling.
- Integrity checking on the TileLink interface for incoming payloads.

**Register Interface Policies:**
- Key registers (`KEY_0` to `KEY_31`) are write-only by design, but implementation details may differ.
- Digest registers are read/write only when the engine is idle.
- Configuration registers (`CFG`) are only updated when the engine is idle.
- Status and error registers are read-only.
- `WIPE_SECRET` is write-only and should be used to clear secrets after use.

---

## 2. Security Issues Identified

### Issue 1: Inconsistent Digest Computation in Multi-Stream Processing

- **File:** `hmac_core.sv`
- **Line(s):** State machine logic, especially lines 311–454 (FSM transitions)
- **Description:** When processing multiple HMAC streams in parallel, the internal state is not always properly preserved/restored, leading to incorrect digest computation. This can compromise integrity and authentication.
- **Security Aspect:** Data integrity, authentication, state isolation
- **Tools Used:** Verilator Agent, manual code review

---

### Issue 2: Register Interface Integrity Error Handling

- **File:** `hmac_reg_top.sv`
- **Line(s):** 129–139 (steering logic), assertion failures in integrity error handling
- **Description:** The assertion checker found that integrity errors do not always properly steer transactions to the register interface (`reg_steer`), potentially allowing unauthorized access or bypass of security checks.
- **Security Aspect:** Register access control, privilege enforcement
- **Tools Used:** Assertion Checker Agent

---

### Issue 3: Key Register Confidentiality Violation

- **File:** `hmac_reg_top.sv`
- **Line(s):** 2413, 2417, 2617 (read data return logic)
- **Description:** Key registers (`key_0`, `key_1`, and `key_2`) are exposed via the register read path, allowing software or an attacker to read back secret key material. The default case also exposes `key_2` if an invalid address is accessed.
- **Security Aspect:** Key confidentiality, information leakage (CWE-1258, CWE-1262)
- **Tools Used:** Similar Bug Agent, CWE Agent

---

### Issue 4: Lack of Privilege-Based Access Control

- **File:** `hmac_reg_top.sv`
- **Line(s):** Register access logic throughout, especially in always_comb for read/write enables
- **Description:** No privilege-level checking is implemented for register access. All registers are accessible to any agent on the TileLink bus, regardless of privilege or security context.
- **Security Aspect:** Privilege enforcement, access control (CWE-1262, CWE-1268)
- **Tools Used:** CWE Agent

---

### Issue 5: Lack of Debug Mode Protection for Key Registers

- **File:** `hmac_reg_top.sv`
- **Line(s):** Key register implementation and module interface
- **Description:** There is no mechanism to clear key registers when debug mode is entered, nor is there a debug mode signal to trigger such clearing. This could allow key extraction via debug access.
- **Security Aspect:** Key confidentiality, debug security (CWE-1258)
- **Tools Used:** CWE Agent

---

### Issue 6: FSM and Non-FSM Logic Mixing

- **File:** `hmac_core.sv`
- **Line(s):** 311–454 (FSM and control logic)
- **Description:** FSM logic is mixed with non-FSM logic, which can lead to confusion and potential errors in FSM behavior, indirectly affecting security if the FSM controls critical operations.
- **Security Aspect:** FSM robustness, maintainability
- **Tools Used:** Linter Agent

---

## 3. Recommendations

- **Fix context switching and state isolation in the HMAC core FSM** to ensure correct digest computation for multi-stream use.
- **Ensure all integrity errors force transactions to the register interface** and are handled securely.
- **Remove all read paths for key registers** and ensure no key material is ever exposed via software-readable registers.
- **Implement privilege-based access control** for sensitive registers, especially key and configuration registers.
- **Add debug mode detection and automatic key erasure** to prevent key leakage during debug sessions.
- **Refactor FSM logic to separate FSM and non-FSM code** for clarity and robustness.
- **Review and harden all register access logic** to ensure consistent enforcement of access policies.

---

## 4. Summary Table

| File                  | Line(s)      | Description                                      | Security Aspect                | Tools Used                   |
|-----------------------|--------------|--------------------------------------------------|-------------------------------|------------------------------|
| hmac_core.sv          | 311–454      | Multi-stream digest computation bug               | Integrity, state isolation     | Verilator, Manual Review     |
| hmac_reg_top.sv       | 129–139      | Integrity error steering failure                  | Register access control        | Assertion Checker            |
| hmac_reg_top.sv       | 2413,2417,2617| Key register readback (info leak)                | Key confidentiality           | Similar Bug, CWE Agent       |
| hmac_reg_top.sv       | all          | No privilege-based access control                 | Privilege enforcement          | CWE Agent                    |
| hmac_reg_top.sv       | all          | No debug mode key clearing                        | Key confidentiality, debug     | CWE Agent                    |
| hmac_core.sv          | 311–454      | FSM/non-FSM logic mixing                         | FSM robustness                 | Linter Agent                 |

---

**END**
================================== Ai Message ==================================

# OpenTitan HMAC IP Security Analysis Report

## 1. Security Features and Register Interface Policies

**Security Features (from documentation):**
- HMAC supports SHA-2 256/384/512 with secret key registers up to 1024 bits.
- Secret key registers are only writable when the engine is idle.
- Wipe secret mechanism: writing to `WIPE_SECRET` clears internal key and state.
- Endianness and digest output can be configured for cross-platform compatibility.
- Configuration and key registers are only updated when the engine is idle; writes during operation are ignored and flagged as errors.
- Error codes and interrupts are provided for error handling.
- Integrity checking on the TileLink interface for incoming payloads.

**Register Interface Policies:**
- Key registers (`KEY_0` to `KEY_31`) are write-only by design, but implementation details may differ.
- Digest registers are read/write only when the engine is idle.
- Configuration registers (`CFG`) are only updated when the engine is idle.
- Status and error registers are read-only.
- `WIPE_SECRET` is write-only and should be used to clear secrets after use.

---

## 2. Security Issues Identified

### Issue 1: Inconsistent Digest Computation in Multi-Stream Processing

- **File:** `hmac_core.sv`
- **Line(s):** State machine logic, especially lines 311–454 (FSM transitions)
- **Description:** When processing multiple HMAC streams in parallel, the internal state is not always properly preserved/restored, leading to incorrect digest computation. This can compromise integrity and authentication.
- **Security Aspect:** Data integrity, authentication, state isolation
- **Tools Used:** Verilator Agent, manual code review

---

### Issue 2: Register Interface Integrity Error Handling

- **File:** `hmac_reg_top.sv`
- **Line(s):** 129–139 (steering logic), assertion failures in integrity error handling
- **Description:** The assertion checker found that integrity errors do not always properly steer transactions to the register interface (`reg_steer`), potentially allowing unauthorized access or bypass of security checks.
- **Security Aspect:** Register access control, privilege enforcement
- **Tools Used:** Assertion Checker Agent

---

### Issue 3: Key Register Confidentiality Violation

- **File:** `hmac_reg_top.sv`
- **Line(s):** 2413, 2417, 2617 (read data return logic)
- **Description:** Key registers (`key_0`, `key_1`, and `key_2`) are exposed via the register read path, allowing software or an attacker to read back secret key material. The default case also exposes `key_2` if an invalid address is accessed.
- **Security Aspect:** Key confidentiality, information leakage (CWE-1258, CWE-1262)
- **Tools Used:** Similar Bug Agent, CWE Agent

---

### Issue 4: Lack of Privilege-Based Access Control

- **File:** `hmac_reg_top.sv`
- **Line(s):** Register access logic throughout, especially in always_comb for read/write enables
- **Description:** No privilege-level checking is implemented for register access. All registers are accessible to any agent on the TileLink bus, regardless of privilege or security context.
- **Security Aspect:** Privilege enforcement, access control (CWE-1262, CWE-1268)
- **Tools Used:** CWE Agent

---

### Issue 5: Lack of Debug Mode Protection for Key Registers

- **File:** `hmac_reg_top.sv`
- **Line(s):** Key register implementation and module interface
- **Description:** There is no mechanism to clear key registers when debug mode is entered, nor is there a debug mode signal to trigger such clearing. This could allow key extraction via debug access.
- **Security Aspect:** Key confidentiality, debug security (CWE-1258)
- **Tools Used:** CWE Agent

---

### Issue 6: FSM and Non-FSM Logic Mixing

- **File:** `hmac_core.sv`
- **Line(s):** 311–454 (FSM and control logic)
- **Description:** FSM logic is mixed with non-FSM logic, which can lead to confusion and potential errors in FSM behavior, indirectly affecting security if the FSM controls critical operations.
- **Security Aspect:** FSM robustness, maintainability
- **Tools Used:** Linter Agent

---

## 3. Recommendations

- **Fix context switching and state isolation in the HMAC core FSM** to ensure correct digest computation for multi-stream use.
- **Ensure all integrity errors force transactions to the register interface** and are handled securely.
- **Remove all read paths for key registers** and ensure no key material is ever exposed via software-readable registers.
- **Implement privilege-based access control** for sensitive registers, especially key and configuration registers.
- **Add debug mode detection and automatic key erasure** to prevent key leakage during debug sessions.
- **Refactor FSM logic to separate FSM and non-FSM code** for clarity and robustness.
- **Review and harden all register access logic** to ensure consistent enforcement of access policies.

---

## 4. Summary Table

| File                  | Line(s)      | Description                                      | Security Aspect                | Tools Used                   |
|-----------------------|--------------|--------------------------------------------------|-------------------------------|------------------------------|
| hmac_core.sv          | 311–454      | Multi-stream digest computation bug               | Integrity, state isolation     | Verilator, Manual Review     |
| hmac_reg_top.sv       | 129–139      | Integrity error steering failure                  | Register access control        | Assertion Checker            |
| hmac_reg_top.sv       | 2413,2417,2617| Key register readback (info leak)                | Key confidentiality           | Similar Bug, CWE Agent       |
| hmac_reg_top.sv       | all          | No privilege-based access control                 | Privilege enforcement          | CWE Agent                    |
| hmac_reg_top.sv       | all          | No debug mode key clearing                        | Key confidentiality, debug     | CWE Agent                    |
| hmac_core.sv          | 311–454      | FSM/non-FSM logic mixing                         | FSM robustness                 | Linter Agent                 |

---

**END**
================================== Ai Message ==================================

[]
