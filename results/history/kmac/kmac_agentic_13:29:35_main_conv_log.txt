================================ System Message ================================


    You are a supervisor agent in a multi-agent system focused on identifying hardware security vulnerabilities in RTL code. 
    Your objective is to analyze the given SoC and generate a detailed security report.

    You have access to the following tools: ['run_anomaly_detector_agent', 'run_llm_cwe_checker_agent', 'run_similar_bug_agent', 'list_dir', 'read_file', 'read_file_with_line_numbers']. Each tool specializes in a specific task:

    - CWE Agent: Given a Verilog file, a top module, and a security aspect, this agent maps the RTL code to relevant CWEs and detects CWE-related vulnerabilities.
    - Similar Bug Agent: Accepts a file path and a line number (where a bug was found) to locate similar patterns or recurring bugs throughout the RTL code.

    Instructions for analysis:

    - Read the documentataion to identify security features and register interfaces policies.
    - Read through the different systemverilog files to probe for issues and use the anomaly agent
    - If a bug is detected but not localized, use the CWE Agent to further inspect the related security aspect in the surrounding RTL.
    - After detecting any bugs, use the Similar Bug Agent to scan similar files (of the same or of different IPs) for similar vulnerabilities.

    Output Format:

    - For each identified issue, report:
    - File name
    - Line number(s)
    - Brief description of the issue
    - Security aspect affected
    - Tools used to identify the issue

    When your analysis is complete, end your response with "END".
    
================================ Human Message =================================

Identify security issues in the kmac IP of the OpenTitan SoC, located at /home/eden/Desktop/Code/HACK@CHES/p2/opentitan.

    - All IPs are located in the 'hw/ip' directory.
    - RTL code for each IP is located in its 'rtl' subdirectory, with source files having the '.sv' extension.
        - reg_top files contain the register interface for the IP.
        - control/fsm files contain the control logic for the IP.
        - core files contain the core logic for the IP.
    - Documentation files (.md) are located in the 'doc' directories of each IP.
        - theory_of_operation explains the properties of the IP and its security features.
        - registers.md files contain the register interface and its read/write access policies.
    - Ignore '.core' files; they are used by build tools and are not relevant for security analysis.

    Focus on the kmac IP and make sure to analyze it thoroughly.

    First, identify the relevant security properties and read/write policies of the register interfaces from the documentation. 
    Then, use all available tools to perform a comprehensive security analysis on the RTL code.
    
================================== Ai Message ==================================
Tool Calls:
  list_dir (call_HOI4GDPrYWJ3JkiNru716W9f)
 Call ID: call_HOI4GDPrYWJ3JkiNru716W9f
  Args:
    dir_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac
================================= Tool Message =================================
Name: list_dir

Files in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac:
kmac_pkg.core README.md sha3.core BUILD kmac.core kmac_reduced.core defs.bzl

Directories in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac:
pre_dv data pre_syn syn dv rtl lint doc fpv pre_sca
================================== Ai Message ==================================
Tool Calls:
  list_dir (call_FAh2k9mQTI8Ttm7deNY95KTa)
 Call ID: call_FAh2k9mQTI8Ttm7deNY95KTa
  Args:
    dir_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/doc
================================= Tool Message =================================
Name: list_dir

Files in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/doc:
registers.md interfaces.md kmac-padding.svg checklist.md keccak-round.svg kmac-block-diagram.svg programmers_guide.md application-interface.svg sha3-padding-fsm.svg theory_of_operation.md sha3-padding.svg

Directories in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/doc:

================================== Ai Message ==================================
Tool Calls:
  read_file (call_Y7a0qC7Uvc30t4nBZr5XM3RZ)
 Call ID: call_Y7a0qC7Uvc30t4nBZr5XM3RZ
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/doc/theory_of_operation.md
================================= Tool Message =================================
Name: read_file

# Theory of Operation

## Block Diagram

![](../doc/kmac-block-diagram.svg)

The above figure shows the KMAC/SHA3 HWIP block diagram.
The KMAC has register interfaces for SW to configure the module, initiate the hashing process, and acquire the result digest from the STATE memory region.
It also has an interface to the KeyMgr to get the secret key (masked).
The IP has N x [application interfaces](#application-interface), which allows other HWIPs to request any pre-defined hashing operations.

As similar with HMAC, KMAC HWIP also has a message FIFO (MSG_FIFO) whose depth was determined based on a few criteria such as the register interface width, and its latency, the latency of hashing algorithm (Keccak).
Based on the given criteria, the MSG_FIFO depth was determined to store the incoming message while the SHA3 core is in computation.

The MSG_FIFO has a packer in front.
It packs any partial writes into the size of internal datapath (64bit) and stores in MSG_FIFO.
It frees the software from having to align the messages.
It also doesn't need the message length information.

The fed messages go into the KMAC core regardless of KMAC enabled or not.
The KMAC core forwards the messages to SHA3 core in case KMAC hash functionality is disabled.
KMAC core prepends the encoded secret key as described in the SHA3 Derived Functions specification.
It is expected that the software writes the encoded output length at the end of the message.
For hashing operations triggered by an IP through the application interface, the encoded output length is appended inside the AppIntf module in the KMAC HWIP.

The SHA3 core is the main Keccak processing module.
It supports SHA3 hashing functions, SHAKE128, SHAKE256 extended output functions, and also cSHAKE128, cSHAKE256 functions in order to support KMAC operation.
To support multiple hashing functions, it has the padding logic inside.
The padding logic mainly pads the predefined bits at the end of the message and also performs `pad10*1()` function.
If cSHAKE mode is set, the padding logic also prepends the encoded function name `N` and the customization string `S` prior to the incoming messages according to the spec requirements.

Both the internal state width and the masking of the Keccak core are configurable via compile-time Verilog parameters.
By default, 1600 bits of internal state are used and stored in two shares (1st order masking).
The masked Keccak core takes 4 clock cycles per round if sufficient entropy is available.
If desired, the masking can be disabled and the internal state width can be reduced to 25, 50, or 100 bits at compile time.

## Design Details

### Keccak Round

A Keccak round implements the Keccak_f function described in the SHA3 specification.
Keccak round logic in KMAC/SHA3 HWIP not only supports 1600 bit internal states but also all possible values {50, 100, 200, 400, 800, 1600} based on a parameter `Width`.
If masking is disabled via compile-time Verilog parameter `EnMasking`, also 25 can be selected as state width.
Keccak permutations in the specification allow arbitrary number of rounds.
This module, however, supports Keccak_f which always runs `12 + 2*L` rounds, where $$ L = log_2 {( {Width \over 25} )} $$ .
For instance, 200 bits of internal state run 18 rounds.
KMAC/SHA3 instantiates the Keccak round module with 1600 bit.

![](../doc/keccak-round.svg)

Keccak round logic has two phases inside.
Theta, Rho, Pi functions are executed at the 1st phase.
Chi and Iota functions run at the 2nd phase.
If the compile-time Verilog parameter `EnMasking` is not set, i.e., if masking is not enabled, the first phase and the second phase run at the same cycle.

If masking is enabled, the Keccak round logic stores the intermediate state after processing the 1st phase.
The stored values are then fed into the 2nd phase computing the Chi and Iota functions.
The Chi function leverages first-order [Domain-Oriented Masking (DOM)](https://eprint.iacr.org/2017/395.pdf) to deter SCA attacks.

To balance circuit area and SCA hardening, the Chi function uses 800 instead 1600 DOM multipliers but the multipliers are fully pipelined.
The Chi and Iota functions are thus separately applied to the two halves of the state and the 2nd phase takes in total three clock cycles to complete.
In the first clock cycle of the 2nd phase, the first stage of Chi is computed for the first lane halves of the state.
In the second clock cycle, the new first lane halves are output and written to state register.
At the same time, the first stage of Chi is computed for the second lane halves.
In the third clock cycle, the new second lane halves are output and written to the state register.

The 800 DOM multipliers need 800 bits of fresh entropy for remasking.
If fresh entropy is not available, the DOM multipliers do not move forward and the 2nd phase will take more than three clock cycles.
Processing a Keccak_f (1600 bit state) takes a total of 96 cycles (24 rounds X 4 cycles/round) including the 1st and 2nd phases.

If the masking compile time option is enabled, Keccak round logic requires an additional 3200 flip flops to store the intermediate half state inside the 800 DOM multipliers.
In addition to that Keccak round logic needs two sets of the same Theta, Rho, and Pi functions.
As a result, the masked Keccak round logic takes more than twice as much as area than the unmasked version of it.

### Padding for Keccak

Padding logic supports SHA3/SHAKE/cSHAKE algorithms.
cSHAKE needs the extra inputs for the Function-name `N` and the Customization string `S`.
Other than that, SHA3, SHAKE, and cSHAKE share similar datapath inside the padding module except the last part added next to the end of the message.
SHA3 adds `2'b 10`, SHAKE adds `4'b 1111`, cSHAKE adds `2'b00` then `pad10*1()` follows.
All are little-endian values.

Interface between this padding logic and the MSG_FIFO follows the conventional FIFO interface.
So `prim_fifo_*` can talk to the padding logic directly.
This module talks to Keccak round logic with a more memory-like interface.
The interface has an additional address signal on top of the valid, ready, and data signals.

![](../doc/sha3-padding.svg)

The hashing process begins when the software issues the start command to [`CMD`](registers.md#cmd) .
If cSHAKE is enabled, the padding logic expands the prefix value (`N || S` above) into a block size.
The block size is determined by the [`CFG_SHADOWED.kstrength`](registers.md#cfg_shadowed) .
If the value is 128, the block size will be 168 bytes.
If it is 256, the block size will be 136 bytes.
The expanded prefix value is transmitted to the Keccak round logic.
After sending the block size, the padding logic triggers the Keccak round logic to run a full 24 rounds.

If the mode is not cSHAKE, or cSHAKE mode and the prefix block has been processed, the padding logic accepts the incoming message bitstream and forward the data to the Keccak round logic in a block granularity.
The padding logic controls the data flow and makes the Keccak logic to run after sending a block size.

After the software writes the message bitstream, it should issue the Process command into [`CMD`](registers.md#cmd) register.
The padding logic, after receiving the Process command, appends proper ending bits with respect to the [`CFG_SHADOWED.mode`](registers.md#cfg_shadowed) value.
The logic writes 0 up to the block size to the Keccak round logic then ends with 1 at the end of the block.

![](../doc/sha3-padding-fsm.svg)

After the Keccak round completes the last block, the padding logic asserts an `absorbed` signal to notify the software.
The signal generates the `kmac_done` interrupt.
At this point, the software is able to read the digest in [`STATE`](registers.md#state) memory region.
If the output length is greater than the Keccak block rate in SHAKE and cSHAKE mode, the software may run the Keccak round manually by issuing Run command to [`CMD`](registers.md#cmd) register.

The software completes the operation by issuing Done command after reading the digest.
The padding logic clears internal variables and goes back to Idle state.

### Padding for KMAC

![](../doc/kmac-padding.svg)

KMAC core prepends and appends additional bitstream on top of Keccak padding logic in SHA3 core.
The [NIST SP 800-185](https://csrc.nist.gov/publications/detail/sp/800-185/final) defines `KMAC[128,256](K, X, L, S)` as a cSHAKE function.
See the section 4.3 in NIST SP 800-185 for details.
If KMAC is enabled, the software should configure [`CMD.mode`](registers.md#cmd) to cSHAKE and the first six bytes of [`PREFIX`](registers.md#prefix) to `0x01204B4D4143` (bigendian).
The first six bytes of [`PREFIX`](registers.md#prefix) represents the value of `encode_string("KMAC")`.

The KMAC padding logic prepends a block containing the encoded secret key to the output message.
The KMAC first sends the block of secret key then accepts the incoming message bitstream.
At the end of the message, the software writes `right_encode(output_length)` to MSG_FIFO prior to issue Process command.

### Message FIFO

The KMAC HWIP has a compile-time configurable depth message FIFO inside.
The message FIFO receives incoming message bitstream regardless of its byte position in a word.
Then it packs the partial message bytes into the internal 64 bit data width.
After packing the data, the logic stores the data into the FIFO until the internal KMAC/SHA3 engine consumes the data.

#### FIFO Depth calculation

The depth of the message FIFO is chosen to cover the throughput of the software or other producers such as DMA engine.
The size of the message FIFO is enough to hold the incoming data while the SHA3 engine is processing the previous block.
Details are in `kmac_pkg::MsgFifoDepth` parameter.
Default design parameters assume the system characteristics as below:

- `kmac_pkg::RegLatency`: The register write takes 5 cycles.
- `kmac_pkg::Sha3Latency`: Keccak round latency takes 96 cycles, which is the masked version of the Keccak round.

#### FIFO Depth and Empty status

If the SW is slow and the SHA3 engine pops the data fast enough, the Message FIFO's depth may remain **0**.
The Message FIFO's `fifo_empty` status bit, however, is lowered for a cycle.

However, if the SHA3 engine is currently busy or if the KMAC block is waiting for fresh entropy from EDN, the Message FIFO may actually run full (indicated by the `fifo_full` status bit).
Resolving these conditions may take hundreds of cycles or more.
After the SHA3 engine starts popping the data again, the Message FIFO will eventually run empty again and the `fifo_empty` status interrupt will fire.
Note that the `fifo_empty` status interrupt will not fire if i) one of the hardware application interfaces is using the KMAC block, ii) the SHA3 core is not in the `Absorb` state, or iii) after software has written the `Process` command.

The recommended approach for software to write messages is:

1. Check the FIFO depth [`STATUS.fifo_depth`](registers.md#status). This represents the number of entry slots currently occupied in the FIFO.
2. Calculate the remaining size as `<max number of fifo entries> - <STATUS.fifo_depth>) * <entry size>`.
3. Write data to fill the remaining size.
4. Repeat until all data is written.
   In case the FIFO runs full (check [`STATUS.fifo_full`](registers.md#status)), software can optionally wait for the `fifo_empty` status interrupt before continuing.

In code, this looks something like:
```c
/**
 * Absorb input data into the Keccak computation.
 *
 * Assumes that the KMAC block is in the "absorb" state; it is the caller's
 * responsibility to check before calling.
 *
 * @param in Input buffer.
 * @param in_len Length of input buffer (bytes).
 * @return Number of bytes written.
 */
size_t kmac_absorb(const uint8_t *in, size_t in_len) {
    // Read FIFO depth from the status register.
    uint32_t status = abs_mmio_read32(kBase + KMAC_STATUS_REG_OFFSET);
    uint32_t fifo_depth =
        bitfield_field32_read(status, KMAC_STATUS_FIFO_DEPTH_FIELD);

    // Calculate the remaining space in the FIFO using auto-generated KMAC
    // parameters and take the minimum of that space and the input length.
    size_t free_entries = (KMAC_PARAM_NUM_ENTRIES_MSG_FIFO - fifo_depth);
    size_t max_len = free_entries * KMAC_PARAM_NUM_BYTES_MSG_FIFO_ENTRY;
    size_t write_len = (in_len < max_len) ? in_len : max_len;

    // Note: this example uses byte-writes for simplicity, but in practice it
    // would be more efficient to use word-writes for aligned full words and
    // byte-writes only as needed at the beginning and end of the input.
    for (size_t i = 0; i < write_len; i++) {
      abs_mmio_write8(kBase + KMAC_MSG_FIFO_REG_OFFSET, in[i]);
    }

    return write_len;
}
```

The method recommended above is always safe.
However, in specific contexts, it may be okay to skip polling `STATUS.fifo_depth`.
Normally, KMAC will process data faster than software can write it, and back pressure on the FIFO interface, should ensure that writes from software will simply block until KMAC can process messages.
The only reason for polling, then, is to prevent a specific deadlock scenario:
1. Software has configured KMAC to wait forever for entropy.
2. There is a problem with the EDN, so entropy is never coming.
3. The FIFO is full and KMAC is waiting for entropy to process it.

If either the entropy wait timer is nonzero or `kmac_en` is false (so KMAC will not be refreshing entropy), it is safe to write to the FIFO without polling `STATUS.fifo_depth`.
However, this should be done carefully, and tests should always cover the scenario in which EDN is locked up.

#### Masking

The message FIFO does not generate the masked message data.
Incoming message bitstream is not sensitive to the leakage.
If the `EnMasking` parameter is set and [`CFG_SHADOWED.msg_mask`](registers.md#cfg_shadowed) is enabled, the message is masked upon loading into the Keccak core using the internal entropy generator.
The secret key, however, is stored as masked form always.

If the `EnMasking` parameter is not set, the masking is disabled.
Then, the software has to provide the key in unmasked form by default.
Any write operations to [`KEY_SHARE1_0`](registers.md#key_share1) - [`KEY_SHARE1_15`](registers.md#key_share1) are ignored.

If the `EnMasking` parameter is not set and the `SwKeyMasked` parameter is set, software has to provide the key in masked form.
Internally, the design then unmasks the key by XORing the two key shares together when loading the key into the engine.
This is useful when software interface compatibility between the masked and unmasked configuration is desirable.

If the `EnMasking` parameter is set, the `SwKeyMasked` parameter has no effect: Software always provides the key in two shares.

### Keccak State Access

After the Keccak round completes the KMAC/SHA3 operation, the contents of the Keccak state contain the digest value.
The software can access the 1600 bit of the Keccak state directly through the window of the KMAC/SHA3 register.

If the compile-time parameter masking feature is enabled, the upper 256B of the window is the second share of the Keccak state.
If not, the upper address space is zero value.
The software reads both of the Keccak state shares and XORed in the software to get the unmasked digest value if masking feature is set.

The Keccak state is valid after the sponge absorbing process is completed.
While in an idle state or in the sponge absorbing stage, the value is zero.
This ensures that the logic does not expose the secret key XORed with the keccak_f results of the prefix to the software.
In addition to that, the KMAC/SHA3 blocks the software access to the Keccak state when it processes the request from KeyMgr for Key Derivation Function (KDF).

### Application Interface

![](../doc/application-interface.svg)

KMAC/SHA3 HWIP has an option to receive the secret key from the KeyMgr via sideload key interface.
The software should set [`CFG_SHADOWED.sideload`](registers.md#cfg_shadowed) to use the KeyMgr sideloaded key for the SW-initiated KMAC operation.
`keymgr_pkg::hw_key_t` defines the structure of the sideloaded key.
KeyMgr provides the sideloaded key in two-share masked form regardless of the compile-time parameter `EnMasking`.
If `EnMasking` is not defined, the KMAC merges the shared key to the unmasked form before uses the key.

The IP has N number of the application interface. The apps connected to the KMAC IP may initiate the SHA3/cSHAKE/KMAC hashing operation via the application interface `kmac_pkg::app_{req|rsp}_t`.
The type of the hashing operation is determined in the compile-time parameter `kmac_pkg::AppCfg`.

| Index | App      | Algorithm | Prefix
|:-----:|:--------:|:---------:|------------
| 0     | KeyMgr   | KMAC      | CSR prefix
| 1     | LC_CTRL  | cSHAKE128 | "LC_CTRL"
| 2     | ROM_CTRL | cSHAKE256 | "ROM_CTRL"

In the current version of IP, the IP has three application interfaces, which are KeyMgr, LC_CTRL, and ROM_CTRL.
KeyMgr uses the KMAC operation with CSR prefix value.
LC_CTRL and ROM_CTRL use the cSHAKE operation with the compile-time parameter prefixes.

The app sends 64-bit data (`MsgWidth`) in a beat with the message strobe signal.
The state machine inside the AppIntf logic starts when it receives the first valid data from any of the AppIntf.
The AppIntf module chooses the winner based on the fixed priority.
Then it forwards the selected App to the next stage.
Because this logic sees the first valid data as an initiator, the Apps cannot run the hashing operation with an empty message.
After the logic switches to accept the message bitstream from the selected App, if the hashing operation is KMAC, the logic forces the sideloaded key to be used as a secret.
Also it ignores the command issued from the software.
Instead it generates the commands and sends them to the KMAC core.

The last beat of the App data moves the state machine to append the encoded output length if the hashing operation is KMAC.
The output length is the digest width, which is 256 bit always.
It means that the logic appends `0x020100` (little-endian) to the end of the message.
The output data from this logic goes to MSG_FIFO.
Because the MSG_FIFO handles un-aligned data inside, KeyMgr interface logic sends the encoded output length value in a separate beat.

After the encoded output length is pushed to the KMAC core, the interface logic issues a Process command to run the hashing logic.

After hashing operation is completed, KMAC does not raise a `kmac_done` interrupt; rather it triggers the `done` status in the App response channel.
The result digest always comes in two shares.
If the `EnMasking` parameter is not set, the second share is always zero.

### Entropy Generator

This section explains the entropy generator inside the KMAC HWIP.

KMAC has an entropy generator to provide the design with pseudo-random numbers while processing the secret key block.
The entropy is used for both remasking the DOM multipliers inside the Chi function of the Keccak core as well as for masking the message if [`CFG_SHADOWED.msg_mask`](registers.md#cfg_shadowed) is enabled.

The entropy generator is constructed using a [heavily unrolled Bivium stream cipher primitive](https://eprint.iacr.org/2023/1134).
This allows the module to generate 800 bits of fresh, pseudo-random numbers required by the 800 DOM multipliers for remasking in every clock cycle.

Depending on [`CFG_SHADOWED.entropy_mode`](registers.md#cfg_shadowed), the entropy generator fetches initial entropy from the [Entropy Distribution Network (EDN)][edn] module or software has to provide a seed by writing the [`ENTROPY_SEED`](registers.md#entropy_seed) register 9 times.
The module periodically refreshes the PRNG seed with fresh entropy from EDN.
Software can explicitly request a complete reseed of the PRNG state from EDN through [`CMD.entropy_req`](registers.md#cmd).

[edn]: ../../edn/README.md

### Error Report

This section explains the errors KMAC HWIP raises during the hashing operations, their meanings, and the error handling process.

KMAC HWIP has the error checkers in its internal datapath.
If the checkers detect errors, whether they are triggered by the SW mis-configure, or HW malfunctions, they report the error to [`ERR_CODE`](registers.md#err_code) and raise an `kmac_error` interrupt.
Each error code gives debugging information at the lower 24 bits of [`ERR_CODE`](registers.md#err_code).

Value | Error Code | Description
------|------------|-------------
0x01  | KeyNotValid | In KMAC mode with the sideloaded key, the IP raises an error if the sideloaded secret key is not ready.
0x02  | SwPushedMsgFifo | MsgFifo is updated while not being in the Message Feed state.
0x03  | SwIssuedCmdInAppActive | SW issued a command while the application interface is being used
0x04  | WaitTimerExpired | EDN has not responded within the wait timer limit.
0x05  | IncorrectEntropyMode | When SW sets `entropy_ready`, the `entropy_mode` is neither SW nor EDN.
0x06  | UnexpectedModeStrength | SHA3 mode and Keccak Strength combination is not expected.
0x07  | IncorrectFunctionName | In KMAC mode, the PREFIX has the value other than `encoded_string("KMAC")`
0x08  | SwCmdSequence | SW does not follow the guided sequence, `start` -> `process` -> {`run` ->} `done`
0x09  | SwHashingWithoutEntropyReady | SW requests KMAC op without proper config of Entropy in KMAC. This error occurs if KMAC IP masking feature is enabled.
0x80  | Sha3Control | SW may receive Sha3Control error along with `SwCmdSequence` error. Can be ignored.

#### KeyNotValid (0x01)

The `KeyNotValid` error is raised in the application interface module.
When a KMAC application requests a hashing operation, the module checks if the sideloaded key is ready.
If the key is not ready, the module reports `KeyNotValid` error and moves to dead-end state and waits the IP reset.

This error does not provide any additional information.

#### SwPushedMsgFifo (0x02)

The `SwPushedMsgFifo` error happens when the Message FIFO receives TL-UL transactions while the application interface is busy.
The Message FIFO drops the request.

The IP reports the error with an info field.

Bits    | Name        | Description
--------|-------------|-------------
[23:16] | reserved    | all zero
[15:8]  | kmac_app_st | KMAC_APP FSM state.
[7:0]   | mux_sel     | Current APP Mux selection. 0: None, 1: SW, 2: App

#### SwIssuedCmdInAppActive (0x03)

If the SW issues any commands while the application interface is being used, the module reports `SwIssuedCmdInAppActive` error.
The received command does not affect the Application process.
The request is dropped by the KMAC_APP module.

The lower 3 bits of [`ERR_CODE`](registers.md#err_code) contains the received command from the SW.
#### WaitTimerExpired (0x04)

The timer values set by SW is internally used only when pending EDN request is completed.
Therefore, dynamically changing wait timer cannot be used as a way to poke the timer out of a stalling EDN request.
If a non-zero timer expires, the module cancels the transaction and reports the `WaitTimerExpired` error.

When this error happens, the state machine in KMAC_ENTROPY module moves to Wait state.
In that state, it keeps using the pre-generated entropy and asserting the entropy valid signal.
It asserts the entropy valid signal to complete the current hashing operation.
If the module does not complete, or flush the pending operation, it creates the back pressure to the message FIFO.
Then, the SW may not be able to access the KMAC IP at all, as the crossbar is stuck.

The SW may move the state machine to the reset state by issuing [`CMD.err_processed`](registers.md#cmd).

#### IncorrectEntropyMode (0x05)

If SW misconfigures the entropy mode and let the entropy module prepare the random data, the module reports `IncorrectEntropyMode` error.
The state machine moves to Wait state after reporting the error.

The SW may move the state machine to the reset state by issuing [`CMD.err_processed`](registers.md#cmd).

#### UnexpectedModeStrength (0x06)

When the SW issues `Start` command, the KMAC_ERRCHK module checks the [`CFG_SHADOWED.mode`](registers.md#cfg_shadowed) and [`CFG_SHADOWED.kstrength`](registers.md#cfg_shadowed).
The KMAC HWIP assumes the combinations of two to be **SHA3-224**, **SHA3-256**, **SHA3-384**, **SHA3-512**, **SHAKE-128**, **SHAKE-256**, **cSHAKE-128**, and **cSHAKE-256**.
If the combination of the `mode` and `kstrength` does not fall into above, the module reports the `UnexpectedModeStrength` error.

However, the KMAC HWIP proceeds the hashing operation as other combinations does not cause any malfunctions inside the IP.
The SW may get the incorrect digest value.

#### IncorrectFunctionName (0x07)

If [`CFG_SHADOWED.kmac_en`](registers.md#cfg_shadowed) is set and the SW issues the `Start` command, the KMAC_ERRCHK checks if the [`PREFIX`](registers.md#prefix) has correct function name, `encode_string("KMAC")`.
If the value does not match to the byte form of `encode_string("KMAC")` (`0x4341_4D4B_2001`), it reports the `IncorrectFunctionName` error.

As same as `UnexpectedModeStrength` error, this error does not block the hashing operation.
The SW may get the incorrect signature value.

#### SwCmdSequence (0x08)

The KMAC_ERRCHK module checks the SW issued commands if it follows the guideline.
If the SW issues the command that is not relevant to the current context, the module reports the `SwCmdSequence` error.
The lower 3bits of the [`ERR_CODE`](registers.md#err_code) contains the received command.

This error, however, does not stop the KMAC HWIP.
The incorrect command is dropped at the following datapath, SHA3 core.

================================== Ai Message ==================================
Tool Calls:
  read_file (call_wxS2FYTP0VkaHP2Sad52vBWS)
 Call ID: call_wxS2FYTP0VkaHP2Sad52vBWS
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/doc/registers.md
================================= Tool Message =================================
Name: read_file

# Registers

<!-- BEGIN CMDGEN util/regtool.py -d ./hw/ip/kmac/data/kmac.hjson -->
## Summary

| Name                                                                             | Offset   |   Length | Description                                              |
|:---------------------------------------------------------------------------------|:---------|---------:|:---------------------------------------------------------|
| kmac.[`INTR_STATE`](#intr_state)                                                 | 0x0      |        4 | Interrupt State Register                                 |
| kmac.[`INTR_ENABLE`](#intr_enable)                                               | 0x4      |        4 | Interrupt Enable Register                                |
| kmac.[`INTR_TEST`](#intr_test)                                                   | 0x8      |        4 | Interrupt Test Register                                  |
| kmac.[`ALERT_TEST`](#alert_test)                                                 | 0xc      |        4 | Alert Test Register                                      |
| kmac.[`CFG_REGWEN`](#cfg_regwen)                                                 | 0x10     |        4 | Controls the configurability of !!CFG_SHADOWED register. |
| kmac.[`CFG_SHADOWED`](#cfg_shadowed)                                             | 0x14     |        4 | KMAC Configuration register.                             |
| kmac.[`CMD`](#cmd)                                                               | 0x18     |        4 | KMAC/ SHA3 command register.                             |
| kmac.[`STATUS`](#status)                                                         | 0x1c     |        4 | KMAC/SHA3 Status register.                               |
| kmac.[`ENTROPY_PERIOD`](#entropy_period)                                         | 0x20     |        4 | Entropy Timer Periods.                                   |
| kmac.[`ENTROPY_REFRESH_HASH_CNT`](#entropy_refresh_hash_cnt)                     | 0x24     |        4 | Entropy Refresh Counter                                  |
| kmac.[`ENTROPY_REFRESH_THRESHOLD_SHADOWED`](#entropy_refresh_threshold_shadowed) | 0x28     |        4 | Entropy Refresh Threshold                                |
| kmac.[`ENTROPY_SEED`](#entropy_seed)                                             | 0x2c     |        4 | Entropy Seed                                             |
| kmac.[`KEY_SHARE0_0`](#key_share0)                                               | 0x30     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_1`](#key_share0)                                               | 0x34     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_2`](#key_share0)                                               | 0x38     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_3`](#key_share0)                                               | 0x3c     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_4`](#key_share0)                                               | 0x40     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_5`](#key_share0)                                               | 0x44     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_6`](#key_share0)                                               | 0x48     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_7`](#key_share0)                                               | 0x4c     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_8`](#key_share0)                                               | 0x50     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_9`](#key_share0)                                               | 0x54     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_10`](#key_share0)                                              | 0x58     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_11`](#key_share0)                                              | 0x5c     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_12`](#key_share0)                                              | 0x60     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_13`](#key_share0)                                              | 0x64     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_14`](#key_share0)                                              | 0x68     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE0_15`](#key_share0)                                              | 0x6c     |        4 | KMAC Secret Key                                          |
| kmac.[`KEY_SHARE1_0`](#key_share1)                                               | 0x70     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_1`](#key_share1)                                               | 0x74     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_2`](#key_share1)                                               | 0x78     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_3`](#key_share1)                                               | 0x7c     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_4`](#key_share1)                                               | 0x80     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_5`](#key_share1)                                               | 0x84     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_6`](#key_share1)                                               | 0x88     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_7`](#key_share1)                                               | 0x8c     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_8`](#key_share1)                                               | 0x90     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_9`](#key_share1)                                               | 0x94     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_10`](#key_share1)                                              | 0x98     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_11`](#key_share1)                                              | 0x9c     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_12`](#key_share1)                                              | 0xa0     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_13`](#key_share1)                                              | 0xa4     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_14`](#key_share1)                                              | 0xa8     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_SHARE1_15`](#key_share1)                                              | 0xac     |        4 | KMAC Secret Key, 2nd share.                              |
| kmac.[`KEY_LEN`](#key_len)                                                       | 0xb0     |        4 | Secret Key length in bit.                                |
| kmac.[`PREFIX_0`](#prefix)                                                       | 0xb4     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`PREFIX_1`](#prefix)                                                       | 0xb8     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`PREFIX_2`](#prefix)                                                       | 0xbc     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`PREFIX_3`](#prefix)                                                       | 0xc0     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`PREFIX_4`](#prefix)                                                       | 0xc4     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`PREFIX_5`](#prefix)                                                       | 0xc8     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`PREFIX_6`](#prefix)                                                       | 0xcc     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`PREFIX_7`](#prefix)                                                       | 0xd0     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`PREFIX_8`](#prefix)                                                       | 0xd4     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`PREFIX_9`](#prefix)                                                       | 0xd8     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`PREFIX_10`](#prefix)                                                      | 0xdc     |        4 | cSHAKE Prefix register.                                  |
| kmac.[`ERR_CODE`](#err_code)                                                     | 0xe0     |        4 | KMAC/SHA3 Error Code                                     |
| kmac.[`STATE`](#state)                                                           | 0x400    |      512 | Keccak State (1600 bit) memory.                          |
| kmac.[`MSG_FIFO`](#msg_fifo)                                                     | 0x800    |     2048 | Message FIFO.                                            |

## INTR_STATE
Interrupt State Register
- Offset: `0x0`
- Reset default: `0x0`
- Reset mask: `0x7`

### Fields

```wavejson
{"reg": [{"name": "kmac_done", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"name": "fifo_empty", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "kmac_err", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 120}}
```

|  Bits  |  Type  |  Reset  | Name                                  |
|:------:|:------:|:-------:|:--------------------------------------|
|  31:3  |        |         | Reserved                              |
|   2    |  rw1c  |   0x0   | [kmac_err](#intr_state--kmac_err)     |
|   1    |   ro   |   0x0   | [fifo_empty](#intr_state--fifo_empty) |
|   0    |  rw1c  |   0x0   | [kmac_done](#intr_state--kmac_done)   |

### INTR_STATE . kmac_err
KMAC/SHA3 error occurred. ERR_CODE register shows the details

### INTR_STATE . fifo_empty
The message FIFO is empty.
This interrupt is raised only if the message FIFO is actually writable by software, i.e., if all of the following conditions are met:
i) The KMAC block is not exercised by a hardware application interface.
ii) The SHA3 block is in the Absorb state.
iii) Software has not yet written the Process command to finish the absorption process.
For the interrupt to be raised, the message FIFO must also have been full previously.
Otherwise, the hardware empties the FIFO faster than software can fill it and there is no point in interrupting the software to inform it about the message FIFO being empty.

### INTR_STATE . kmac_done
KMAC/SHA3 absorbing has been completed

## INTR_ENABLE
Interrupt Enable Register
- Offset: `0x4`
- Reset default: `0x0`
- Reset mask: `0x7`

### Fields

```wavejson
{"reg": [{"name": "kmac_done", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "fifo_empty", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "kmac_err", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 120}}
```

|  Bits  |  Type  |  Reset  | Name       | Description                                                          |
|:------:|:------:|:-------:|:-----------|:---------------------------------------------------------------------|
|  31:3  |        |         |            | Reserved                                                             |
|   2    |   rw   |   0x0   | kmac_err   | Enable interrupt when [`INTR_STATE.kmac_err`](#intr_state) is set.   |
|   1    |   rw   |   0x0   | fifo_empty | Enable interrupt when [`INTR_STATE.fifo_empty`](#intr_state) is set. |
|   0    |   rw   |   0x0   | kmac_done  | Enable interrupt when [`INTR_STATE.kmac_done`](#intr_state) is set.  |

## INTR_TEST
Interrupt Test Register
- Offset: `0x8`
- Reset default: `0x0`
- Reset mask: `0x7`

### Fields

```wavejson
{"reg": [{"name": "kmac_done", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "fifo_empty", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "kmac_err", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 120}}
```

|  Bits  |  Type  |  Reset  | Name       | Description                                                   |
|:------:|:------:|:-------:|:-----------|:--------------------------------------------------------------|
|  31:3  |        |         |            | Reserved                                                      |
|   2    |   wo   |   0x0   | kmac_err   | Write 1 to force [`INTR_STATE.kmac_err`](#intr_state) to 1.   |
|   1    |   wo   |   0x0   | fifo_empty | Write 1 to force [`INTR_STATE.fifo_empty`](#intr_state) to 1. |
|   0    |   wo   |   0x0   | kmac_done  | Write 1 to force [`INTR_STATE.kmac_done`](#intr_state) to 1.  |

## ALERT_TEST
Alert Test Register
- Offset: `0xc`
- Reset default: `0x0`
- Reset mask: `0x3`

### Fields

```wavejson
{"reg": [{"name": "recov_operation_err", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "fatal_fault_err", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 30}], "config": {"lanes": 1, "fontsize": 10, "vspace": 210}}
```

|  Bits  |  Type  |  Reset  | Name                | Description                                      |
|:------:|:------:|:-------:|:--------------------|:-------------------------------------------------|
|  31:2  |        |         |                     | Reserved                                         |
|   1    |   wo   |   0x0   | fatal_fault_err     | Write 1 to trigger one alert event of this kind. |
|   0    |   wo   |   0x0   | recov_operation_err | Write 1 to trigger one alert event of this kind. |

## CFG_REGWEN
Controls the configurability of [`CFG_SHADOWED`](#cfg_shadowed) register.

This register ensures the contents of [`CFG_SHADOWED`](#cfg_shadowed) register cannot be
changed by the software while the KMAC/SHA3 is in operation mode.
- Offset: `0x10`
- Reset default: `0x1`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "en", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description           |
|:------:|:------:|:-------:|:-------|:----------------------|
|  31:1  |        |         |        | Reserved              |
|   0    |   ro   |   0x1   | en     | Configuration enable. |

## CFG_SHADOWED
KMAC Configuration register.

This register is  updated when the hashing engine is in Idle.
If the software updates the register while the engine computes, the
updated value will be discarded.
- Offset: `0x14`
- Reset default: `0x0`
- Reset mask: `0x51b133f`
- Register enable: [`CFG_REGWEN`](#cfg_regwen)

### Fields

```wavejson
{"reg": [{"name": "kmac_en", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "kstrength", "bits": 3, "attr": ["rw"], "rotate": -90}, {"name": "mode", "bits": 2, "attr": ["rw"], "rotate": -90}, {"bits": 2}, {"name": "msg_endianness", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "state_endianness", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 2}, {"name": "sideload", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 3}, {"name": "entropy_mode", "bits": 2, "attr": ["rw"], "rotate": -90}, {"bits": 1}, {"name": "entropy_fast_process", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "msg_mask", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 3}, {"name": "entropy_ready", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 1}, {"name": "en_unsupported_modestrength", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 5}], "config": {"lanes": 1, "fontsize": 10, "vspace": 290}}
```

|  Bits  |  Type  |  Reset  | Name                                                                      |
|:------:|:------:|:-------:|:--------------------------------------------------------------------------|
| 31:27  |        |         | Reserved                                                                  |
|   26   |   rw   |   0x0   | [en_unsupported_modestrength](#cfg_shadowed--en_unsupported_modestrength) |
|   25   |        |         | Reserved                                                                  |
|   24   |   rw   |   0x0   | [entropy_ready](#cfg_shadowed--entropy_ready)                             |
| 23:21  |        |         | Reserved                                                                  |
|   20   |   rw   |   0x0   | [msg_mask](#cfg_shadowed--msg_mask)                                       |
|   19   |   rw   |   0x0   | [entropy_fast_process](#cfg_shadowed--entropy_fast_process)               |
|   18   |        |         | Reserved                                                                  |
| 17:16  |   rw   |   0x0   | [entropy_mode](#cfg_shadowed--entropy_mode)                               |
| 15:13  |        |         | Reserved                                                                  |
|   12   |   rw   |   0x0   | [sideload](#cfg_shadowed--sideload)                                       |
| 11:10  |        |         | Reserved                                                                  |
|   9    |   rw   |   0x0   | [state_endianness](#cfg_shadowed--state_endianness)                       |
|   8    |   rw   |   0x0   | [msg_endianness](#cfg_shadowed--msg_endianness)                           |
|  7:6   |        |         | Reserved                                                                  |
|  5:4   |   rw   |   0x0   | [mode](#cfg_shadowed--mode)                                               |
|  3:1   |   rw   |   0x0   | [kstrength](#cfg_shadowed--kstrength)                                     |
|   0    |   rw   |   0x0   | [kmac_en](#cfg_shadowed--kmac_en)                                         |

### CFG_SHADOWED . en_unsupported_modestrength
Enable Unsupported Mode and Strength configs.

SW may set this field for KMAC to move forward with unsupported
Keccak Mode and Strength configurations, such as cSHAKE512.

If not set, KMAC won't propagate the SW command (CmdStart) to the
rest of the blocks (AppIntf, KMAC Core, SHA3).

### CFG_SHADOWED . entropy_ready
Entropy Ready status.

Software sets this field to allow the entropy generator in KMAC to
fetch the entropy and run.

### CFG_SHADOWED . msg_mask
Message Masking with PRNG.

If 1, KMAC applies PRNG to the input messages to the Keccak module
when KMAC mode is on.

### CFG_SHADOWED . entropy_fast_process
Entropy Fast process mode.

If 1, entropy logic uses garbage data while not processing the KMAC
key block. It will re-use previous entropy value and will not
expand the entropy when it is consumed. Only it refreshes the
entropy while processing the secret key block. This process should
not be used if SCA resistance is required because it may cause side
channel leakage.

### CFG_SHADOWED . entropy_mode
Entropy Mode

Using this field, software can configure mode of operation of the internal pseudo-random number generator (PRNG).
For the hardware to actually switch to an entropy mode other than the default idle_mode, software further needs to set the [`CFG_SHADOWED.entropy_ready`](#cfg_shadowed) bit.
After that point, the hardware cannot be made to return to idle_mode unless the module is reset.

| Value   | Name      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|:--------|:----------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0x0     | idle_mode | Default mode after reset. The sole purpose of this mode is to enable ROM_CTRL operation right after coming out of reset. The internal PRNG is not reseeded with fresh entropy, nor updated while the core operates. It should therefore not be used after this very initial stage. Software should setup a different mode and set !!CFG_SHADOWED.entropy_ready as early as possible. The module cannot be made to return to idle_mode once any of the other modes have been used.                                                                                                                                                                                                                                                                                       |
| 0x1     | edn_mode  | Receive fresh entropy from EDN for reseeding the internal PRNG. This entropy mode is to be used for regular operation. Once the !!CFG_SHADOWED.entropy_ready bit is set after reset, the module requests fresh entropy from EDN for reseeding the internal PRNG. Only after that, the module can start processing commands. Depending on !!CFG_SHADOWED, the internal PRNG is then used for (re-)masking inputs (prefix, key, message) and intermediate results of the Keccak core. Depending on !!ENTROPY_PERIOD, the module will periodically reseed the internal PRNG with fresh entropy from EDN. Using !!CMD.entropy_req software can manually initiate the reseeding.                                                                                             |
| 0x2     | sw_mode   | Receive initial entropy from software for reseeding the internal PRNG. This entropy mode is a fall-back option to be used if the entropy complex is not available. Once the !!CFG_SHADOWED.entropy_ready bit is set after reset, the module will wait for software to write each of the !!ENTROPY_SEED_0 - !!ENTROPY_SEED_4 registers exactly once and in ascending order. Only after that, the module can start processing commands. Depending on !!CFG_SHADOWED, the internal PRNG is then used for (re-)masking inputs (prefix, key, message) and intermediate results of the Keccak core. After this point, the PRNG can no longer be reseeded by software - also after switching back into this mode from edn_mode. However, it is possible to switch to edn_mode. |

Other values are reserved.

### CFG_SHADOWED . sideload
Sideloaded Key.

If 1, KMAC uses KeyMgr sideloaded key for SW initiated KMAC
operation. KMAC uses the sideloaded key regardless of this
configuration when KeyMgr initiates the KMAC operation for
Key Derivation Function (KDF).

### CFG_SHADOWED . state_endianness
State Endianness.

If 1 then each individual word in the [`STATE`](#state) output register
is converted to big-endian byte order.
The order of the words in relation to one another is not
changed.
This setting does not affect how the state is interpreted
during computation.

### CFG_SHADOWED . msg_endianness
Message Endianness.

If 1 then each individual multi-byte value, regardless of its
alignment, written to [`MSG_FIFO`](#msg_fifo) will be added to the message
in big-endian byte order.
If 0, each value will be added to the message in little-endian
byte order.
A message written to [`MSG_FIFO`](#msg_fifo) one byte at a time will not be
affected by this setting.
From a hardware perspective byte swaps are performed on a TL-UL
word granularity.

### CFG_SHADOWED . mode
Keccak hashing mode.

This module supports SHA3 main hashing algorithm and the part
of its derived functions, SHAKE and cSHAKE with limitations.
This field is to select the mode.

| Value   | Name   | Description                                              |
|:--------|:-------|:---------------------------------------------------------|
| 0x0     | SHA3   | SHA3 hashing mode. It appends `2'b 10` to the end of msg |
| 0x2     | SHAKE  | SHAKE hashing mode. It appends `1111` to the end of msg  |
| 0x3     | cSHAKE | cSHAKE hashing mode. It appends `00` to the end of msg   |

Other values are reserved.

### CFG_SHADOWED . kstrength
Hashing Strength

3 bit field to select the security strength of SHA3 hashing
engine. If mode field is set to SHAKE or cSHAKE, only 128 and
256 strength can be selected. Other value will result error
when hashing starts.

| Value   | Name   | Description                               |
|:--------|:-------|:------------------------------------------|
| 0x0     | L128   | 128 bit strength. Keccak rate is 1344 bit |
| 0x1     | L224   | 224 bit strength. Keccak rate is 1152 bit |
| 0x2     | L256   | 256 bit strength. Keccak rate is 1088 bit |
| 0x3     | L384   | 384 bit strength. Keccak rate is 832 bit  |
| 0x4     | L512   | 512 bit strength. Keccak rate is 576 bit  |

Other values are reserved.

### CFG_SHADOWED . kmac_en
KMAC datapath enable.

If this bit is 1, the incoming message is processed in KMAC
with the secret key.

## CMD
KMAC/ SHA3 command register.

This register is to control the KMAC to start accepting message,
to process the message, and to manually run additional keccak
rounds at the end. Only at certain stage, the CMD affects to the
control logic. It follows the sequence of

`start` --> `process` --> {`run` if needed --> } `done`
- Offset: `0x18`
- Reset default: `0x0`
- Reset mask: `0x73f`

### Fields

```wavejson
{"reg": [{"name": "cmd", "bits": 6, "attr": ["r0w1c"], "rotate": 0}, {"bits": 2}, {"name": "entropy_req", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"name": "hash_cnt_clr", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"name": "err_processed", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"bits": 21}], "config": {"lanes": 1, "fontsize": 10, "vspace": 150}}
```

|  Bits  |  Type  |  Reset  | Name                                 |
|:------:|:------:|:-------:|:-------------------------------------|
| 31:11  |        |         | Reserved                             |
|   10   | r0w1c  |    x    | [err_processed](#cmd--err_processed) |
|   9    | r0w1c  |    x    | [hash_cnt_clr](#cmd--hash_cnt_clr)   |
|   8    | r0w1c  |    x    | [entropy_req](#cmd--entropy_req)     |
|  7:6   |        |         | Reserved                             |
|  5:0   | r0w1c  |    x    | [cmd](#cmd--cmd)                     |

### CMD . err_processed
When error occurs and one of the state machine stays at
 Error handling state, SW may process the error based on
 ERR_CODE, then let FSM back to the reset state

### CMD . hash_cnt_clr
If writes 1, it clears the hash (KMAC) counter in the entropy module

### CMD . entropy_req
SW triggered Entropy Request

If writes 1 to this field

### CMD . cmd
Issue a command to the KMAC/SHA3 IP. The command is sparse
encoded. To prevent sw from writing multiple commands at once,
the field is defined as enum.

| Value   | Name    | Description                                                                                                                                                                                                                                                                                                                 |
|:--------|:--------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0x1d    | start   | Writing 6'b011101 or dec 29 into this field when KMAC/SHA3 is in idle, KMAC/SHA3 begins its operation. If the mode is cSHAKE, before receiving the message, the hashing logic processes Function name string N and customization input string S first. If KMAC mode is enabled, additionally it processes secret key block. |
| 0x2e    | process | Writing 6'b101110 or dec 46 into this field when KMAC/SHA3 began its operation and received the entire message, it computes the digest or signing.                                                                                                                                                                          |
| 0x31    | run     | The `run` field is used in the sponge squeezing stage. It triggers the keccak round logic to run full 24 rounds. This is optional and used when software needs more digest bits than the keccak rate. It only affects when the kmac/sha3 operation is completed.                                                            |
| 0x16    | done    | Writing 6'b010110 or dec 22 into this field when KMAC/SHA3 squeezing is completed, KMAC/SHA3 hashing engine clears internal variables and goes back to Idle state for next command.                                                                                                                                         |

Other values are reserved.

## STATUS
KMAC/SHA3 Status register.
- Offset: `0x1c`
- Reset default: `0x4001`
- Reset mask: `0x3df07`

### Fields

```wavejson
{"reg": [{"name": "sha3_idle", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "sha3_absorb", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "sha3_squeeze", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 5}, {"name": "fifo_depth", "bits": 5, "attr": ["ro"], "rotate": -90}, {"bits": 1}, {"name": "fifo_empty", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "fifo_full", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "ALERT_FATAL_FAULT", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "ALERT_RECOV_CTRL_UPDATE_ERR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 14}], "config": {"lanes": 1, "fontsize": 10, "vspace": 290}}
```

|  Bits  |  Type  |  Reset  | Name                                                                |
|:------:|:------:|:-------:|:--------------------------------------------------------------------|
| 31:18  |        |         | Reserved                                                            |
|   17   |   ro   |   0x0   | [ALERT_RECOV_CTRL_UPDATE_ERR](#status--alert_recov_ctrl_update_err) |
|   16   |   ro   |   0x0   | [ALERT_FATAL_FAULT](#status--alert_fatal_fault)                     |
|   15   |   ro   |    x    | [fifo_full](#status--fifo_full)                                     |
|   14   |   ro   |   0x1   | [fifo_empty](#status--fifo_empty)                                   |
|   13   |        |         | Reserved                                                            |
|  12:8  |   ro   |    x    | [fifo_depth](#status--fifo_depth)                                   |
|  7:3   |        |         | Reserved                                                            |
|   2    |   ro   |    x    | [sha3_squeeze](#status--sha3_squeeze)                               |
|   1    |   ro   |    x    | [sha3_absorb](#status--sha3_absorb)                                 |
|   0    |   ro   |   0x1   | [sha3_idle](#status--sha3_idle)                                     |

### STATUS . ALERT_RECOV_CTRL_UPDATE_ERR
An update error has not occurred (0) or has occured (1) in the shadowed Control Register.
KMAC operation needs to be restarted by re-writing the Control Register.

### STATUS . ALERT_FATAL_FAULT
No fatal fault has occurred inside the KMAC unit (0).
A fatal fault has occured and the KMAC unit needs to be reset (1),
Examples for such faults include
i) TL-UL bus integrity fault
ii) storage errors in the shadow registers
iii) errors in the message, round, or key counter
iv) any internal FSM entering an invalid state
v) an error in the redundant lfsr

### STATUS . fifo_full
Message FIFO Full indicator

### STATUS . fifo_empty
Message FIFO Empty indicator.

The FIFO's `Pass` parameter is set to `1'b 1`. So, by default, if
the SHA engine is ready, the write data to FIFO just passes
through.

In this case, `fifo_depth` remains **0**. `fifo_empty`, however,
lowers the value to **0** for a cycle, then goes back to the empty
state, **1**.

See the "Message FIFO" section in the spec for the reason.

### STATUS . fifo_depth
Count of occupied entries in the message FIFO.

### STATUS . sha3_squeeze
If 1, SHA3 completes sponge absorbing stage.
In this stage, SW can manually run the hashing engine.

### STATUS . sha3_absorb
If 1, SHA3 is receiving message stream and processing it

### STATUS . sha3_idle
If 1, SHA3 hashing engine is in idle state.

## ENTROPY_PERIOD
Entropy Timer Periods.
- Offset: `0x20`
- Reset default: `0x0`
- Reset mask: `0xffff03ff`
- Register enable: [`CFG_REGWEN`](#cfg_regwen)

### Fields

```wavejson
{"reg": [{"name": "prescaler", "bits": 10, "attr": ["rw"], "rotate": 0}, {"bits": 6}, {"name": "wait_timer", "bits": 16, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                                      |
|:------:|:------:|:-------:|:------------------------------------------|
| 31:16  |   rw   |   0x0   | [wait_timer](#entropy_period--wait_timer) |
| 15:10  |        |         | Reserved                                  |
|  9:0   |   rw   |   0x0   | [prescaler](#entropy_period--prescaler)   |

### ENTROPY_PERIOD . wait_timer
EDN request wait timer.

The entropy module in KMAC waits up to this field in the timer pulse
after it sends request to EDN module. If the timer expires, the
entropy module moves to an error state and notifies to the system.

If there is a pending EDN request during wait timer update, then this update is delayed until the EDN request is complete.

If 0, the entropy module waits the EDN response always. If EDN does
not respond in this configuration, the software shall reset the IP.

### ENTROPY_PERIOD . prescaler
EDN Wait timer prescaler.

EDN Wait timer has 16 bit value. The timer value is increased when the timer pulse is generated. Timer pulse is raises when the number of the clock cycles hit this prescaler value.

The exact period of the timer pulse is unknown as the KMAC input clock may contain jitters.

## ENTROPY_REFRESH_HASH_CNT
Entropy Refresh Counter

KMAC entropy can be refreshed after the given threshold KMAC operations
run. If the KMAC hash counter [`ENTROPY_REFRESH_HASH_CNT`](#entropy_refresh_hash_cnt) hits (GTE) the
configured threshold [`ENTROPY_REFRESH_THRESHOLD_SHADOWED`](#entropy_refresh_threshold_shadowed), the entropy
module in the KMAC IP requests new seed to EDN and reset the KMAC
hash counter.

If the threshold is 0, the refresh by the counter does not work. And the
counter is only reset by the CMD.hash_cnt_clr CSR bit.
- Offset: `0x24`
- Reset default: `0x0`
- Reset mask: `0x3ff`
- Register enable: [`CFG_REGWEN`](#cfg_regwen)

### Fields

```wavejson
{"reg": [{"name": "hash_cnt", "bits": 10, "attr": ["ro"], "rotate": 0}, {"bits": 22}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name     | Description         |
|:------:|:------:|:-------:|:---------|:--------------------|
| 31:10  |        |         |          | Reserved            |
|  9:0   |   ro   |   0x0   | hash_cnt | Hash (KMAC) counter |

## ENTROPY_REFRESH_THRESHOLD_SHADOWED
Entropy Refresh Threshold

KMAC entropy can be refreshed after the given threshold KMAC operations
run. If the KMAC hash counter [`ENTROPY_REFRESH_HASH_CNT`](#entropy_refresh_hash_cnt) hits (GTE) the
configured threshold [`ENTROPY_REFRESH_THRESHOLD_SHADOWED`](#entropy_refresh_threshold_shadowed), the entropy
module in the KMAC IP requests new seed to EDN and reset the KMAC
hash counter.

If the threshold is 0, the refresh by the counter does not work. And the
counter is only reset by the CMD.hash_cnt_clr CSR bit.
- Offset: `0x28`
- Reset default: `0x0`
- Reset mask: `0x3ff`
- Register enable: [`CFG_REGWEN`](#cfg_regwen)

### Fields

```wavejson
{"reg": [{"name": "threshold", "bits": 10, "attr": ["rw"], "rotate": 0}, {"bits": 22}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name      | Description    |
|:------:|:------:|:-------:|:----------|:---------------|
| 31:10  |        |         |           | Reserved       |
|  9:0   |   rw   |   0x0   | threshold | Hash Threshold |

## ENTROPY_SEED
Entropy Seed

Entropy seed register for the integrated entropy generator.

If [`CFG_SHADOWED.entropy_mode`](#cfg_shadowed) is set to sw_mode, software first needs to set [`CFG_SHADOWED.entropy_ready.`](#cfg_shadowed)
Then, software needs to write the [`ENTROPY_SEED`](#entropy_seed) register 9 times.
Upon each write, the written value is loaded into the corresponding state chunk of the entropy generator.

After writing the [`ENTROPY_SEED`](#entropy_seed) register 9 times, the entropy generator will start its operation.
After this point, writing this register has no longer any effect.
- Offset: `0x2c`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "seed", "bits": 32, "attr": ["wo"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                                |
|:------:|:------:|:-------:|:-------|:-------------------------------------------|
|  31:0  |   wo   |    x    | seed   | 32-bit chunk of the entropy generator seed |

## KEY_SHARE0
KMAC Secret Key

KMAC secret key can be up to 512 bit.
Order of the secret key is:
key[512:0] = {KEY15, KEY14, ... , KEY0};

The registers are allowed to be updated when the engine is in Idle state.
If the engine computes the hash, it discards any attempts to update the secret keys
and report an error.

Current KMAC supports up to 512 bit secret key. It is the sw
responsibility to keep upper bits of the secret key to 0.
- Reset default: `0x0`
- Reset mask: `0xffffffff`
- Register enable: [`CFG_REGWEN`](#cfg_regwen)

### Instances

| Name          | Offset   |
|:--------------|:---------|
| KEY_SHARE0_0  | 0x30     |
| KEY_SHARE0_1  | 0x34     |
| KEY_SHARE0_2  | 0x38     |
| KEY_SHARE0_3  | 0x3c     |
| KEY_SHARE0_4  | 0x40     |
| KEY_SHARE0_5  | 0x44     |
| KEY_SHARE0_6  | 0x48     |
| KEY_SHARE0_7  | 0x4c     |
| KEY_SHARE0_8  | 0x50     |
| KEY_SHARE0_9  | 0x54     |
| KEY_SHARE0_10 | 0x58     |
| KEY_SHARE0_11 | 0x5c     |
| KEY_SHARE0_12 | 0x60     |
| KEY_SHARE0_13 | 0x64     |
| KEY_SHARE0_14 | 0x68     |
| KEY_SHARE0_15 | 0x6c     |


### Fields

```wavejson
{"reg": [{"name": "key", "bits": 32, "attr": ["wo"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                              |
|:------:|:------:|:-------:|:-------|:-----------------------------------------|
|  31:0  |   wo   |    x    | key    | 32-bit chunk of up-to 512-bit Secret Key |

## KEY_SHARE1
KMAC Secret Key, 2nd share.

KMAC secret key can be up to 512 bit.
Order of the secret key is:
key[512:0] = {KEY15, KEY14, ... , KEY0};

The registers are allowed to be updated when the engine is in Idle state.
If the engine computes the hash, it discards any attempts to update the secret keys
and report an error.

Current KMAC supports up to 512 bit secret key. It is the sw
responsibility to keep upper bits of the secret key to 0.
- Reset default: `0x0`
- Reset mask: `0xffffffff`
- Register enable: [`CFG_REGWEN`](#cfg_regwen)

### Instances

| Name          | Offset   |
|:--------------|:---------|
| KEY_SHARE1_0  | 0x70     |
| KEY_SHARE1_1  | 0x74     |
| KEY_SHARE1_2  | 0x78     |
| KEY_SHARE1_3  | 0x7c     |
| KEY_SHARE1_4  | 0x80     |
| KEY_SHARE1_5  | 0x84     |
| KEY_SHARE1_6  | 0x88     |
| KEY_SHARE1_7  | 0x8c     |
| KEY_SHARE1_8  | 0x90     |
| KEY_SHARE1_9  | 0x94     |
| KEY_SHARE1_10 | 0x98     |
| KEY_SHARE1_11 | 0x9c     |
| KEY_SHARE1_12 | 0xa0     |
| KEY_SHARE1_13 | 0xa4     |
| KEY_SHARE1_14 | 0xa8     |
| KEY_SHARE1_15 | 0xac     |


### Fields

```wavejson
{"reg": [{"name": "key", "bits": 32, "attr": ["wo"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                              |
|:------:|:------:|:-------:|:-------|:-----------------------------------------|
|  31:0  |   wo   |    x    | key    | 32-bit chunk of up-to 512-bit Secret Key |

## KEY_LEN
Secret Key length in bit.

This value is used to make encoded secret key in KMAC.
KMAC supports certain lengths of the secret key. Currently it
supports 128b, 192b, 256b, 384b, and 512b secret keys.
- Offset: `0xb0`
- Reset default: `0x0`
- Reset mask: `0x7`
- Register enable: [`CFG_REGWEN`](#cfg_regwen)

### Fields

```wavejson
{"reg": [{"name": "len", "bits": 3, "attr": ["wo"], "rotate": 0}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                 |
|:------:|:------:|:-------:|:---------------------|
|  31:3  |        |         | Reserved             |
|  2:0   |   wo   |   0x0   | [len](#key_len--len) |

### KEY_LEN . len
Key length choice

| Value   | Name   | Description            |
|:--------|:-------|:-----------------------|
| 0x0     | Key128 | Key length is 128 bit. |
| 0x1     | Key192 | Key length is 192 bit. |
| 0x2     | Key256 | Key length is 256 bit. |
| 0x3     | Key384 | Key length is 384 bit. |
| 0x4     | Key512 | Key length is 512 bit. |

Other values are reserved.

## PREFIX
cSHAKE Prefix register.

Prefix including Function Name N and Customization String S.
The SHA3 assumes this register value is encoded as:
`encode_string(N) || encode_string(S) || 0`. It means that the
software can freely decide the length of N or S based on the
given Prefix register size 320bit. 320bit is determined to have
32-bit of N and up to 256-bit of S + encode of their length.

It is SW responsibility to fill the register with encoded value
that is described at Section 2.3.2 String Encoding in NIST SP
800-185 specification.

Order of Prefix is:
prefix[end:0] := {PREFIX(N-1), ..., PREFIX(1), PREFIX(0) }

The registers are allowed to be updated when the engine is in Idle state.
If the engine computes the hash, it discards any attempts to update the secret keys
and report an error.
- Reset default: `0x0`
- Reset mask: `0xffffffff`
- Register enable: [`CFG_REGWEN`](#cfg_regwen)

### Instances

| Name      | Offset   |
|:----------|:---------|
| PREFIX_0  | 0xb4     |
| PREFIX_1  | 0xb8     |
| PREFIX_2  | 0xbc     |
| PREFIX_3  | 0xc0     |
| PREFIX_4  | 0xc4     |
| PREFIX_5  | 0xc8     |
| PREFIX_6  | 0xcc     |
| PREFIX_7  | 0xd0     |
| PREFIX_8  | 0xd4     |
| PREFIX_9  | 0xd8     |
| PREFIX_10 | 0xdc     |


### Fields

```wavejson
{"reg": [{"name": "prefix", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                       |
|:------:|:------:|:-------:|:-------|:----------------------------------|
|  31:0  |   rw   |   0x0   | prefix | 32-bit chunk of Encoded NS Prefix |

## ERR_CODE
KMAC/SHA3 Error Code
- Offset: `0xe0`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "err_code", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                            |
|:------:|:------:|:-------:|:--------------------------------|
|  31:0  |   ro   |   0x0   | [err_code](#err_code--err_code) |

### ERR_CODE . err_code
If the `kmac_err` interrupt occurs, this register has information on the error cause.
Bits 31:24 contain the error code (please refer to `err_code_e` in `hw/ip/kmac/rtl/kmac_pkg.sv`) for the encoding, and bits 23:0 contain additional debug information.
This register does *not* get cleared when the `kmac_err` interrupt state gets cleared.

## STATE
Keccak State (1600 bit) memory.

The software can get the processed digest by reading this memory
region. Unlike MSG_FIFO, STATE memory space sees the addr[9:0].
If Masking feature is enabled, the software reads two shares from
this memory space.

0x400 - 0x4C7: State share
0x500 - 0x5C7: Mask share of the state, 0 if EnMasking = 0

- Word Aligned Offset Range: `0x400`to`0x5fc`
- Size (words): `128`
- Access: `ro`
- Byte writes are *not* supported.

## MSG_FIFO
Message FIFO.

Any write operation to this window will be appended to MSG_FIFO. SW can
simply write bytes/words to any address within this address range.
Ordering and packing of the incoming bytes/words are handled
internally. Therefore, the least significant 12 bits of the address
are ignored.

- Word Aligned Offset Range: `0x800`to`0xffc`
- Size (words): `512`
- Access: `wo`
- Byte writes are  supported.


<!-- END CMDGEN -->

================================== Ai Message ==================================
Tool Calls:
  list_dir (call_lBvcrR2WehJmxpNLhVuDShJQ)
 Call ID: call_lBvcrR2WehJmxpNLhVuDShJQ
  Args:
    dir_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/rtl
================================= Tool Message =================================
Name: list_dir

Files in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/rtl:
kmac_pkg.sv kmac_entropy.sv kmac_staterd.sv kmac_reg_top.sv kmac_app.sv kmac_core.sv kmac_errchk.sv kmac_msgfifo.sv sha3.sv sha3pad.sv kmac.sv keccak_round.sv keccak_2share.sv kmac_reduced.sv kmac_reg_pkg.sv sha3_pkg.sv

Directories in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/rtl:

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_NWOVlUqjsNIqOrgbjNlFflcd)
 Call ID: call_NWOVlUqjsNIqOrgbjNlFflcd
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/rtl/kmac_reg_top.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Register Top module auto-generated by `reggen`
6: 
7: `include "prim_assert.sv"
8: 
9: module kmac_reg_top (
10:   input clk_i,
11:   input rst_ni,
12:   input rst_shadowed_ni,
13:   input  tlul_pkg::tl_h2d_t tl_i,
14:   output tlul_pkg::tl_d2h_t tl_o,
15: 
16:   // Output port for window
17:   output tlul_pkg::tl_h2d_t tl_win_o  [2],
18:   input  tlul_pkg::tl_d2h_t tl_win_i  [2],
19: 
20:   // To HW
21:   output kmac_reg_pkg::kmac_reg2hw_t reg2hw, // Write
22:   input  kmac_reg_pkg::kmac_hw2reg_t hw2reg, // Read
23: 
24:   output logic shadowed_storage_err_o,
25:   output logic shadowed_update_err_o,
26: 
27:   // Integrity check errors
28:   output logic intg_err_o
29: );
30: 
31:   import kmac_reg_pkg::* ;
32: 
33:   localparam int AW = 12;
34:   localparam int DW = 32;
35:   localparam int DBW = DW/8;                    // Byte Width
36: 
37:   // register signals
38:   logic           reg_we;
39:   logic           reg_re;
40:   logic [AW-1:0]  reg_addr;
41:   logic [DW-1:0]  reg_wdata;
42:   logic [DBW-1:0] reg_be;
43:   logic [DW-1:0]  reg_rdata;
44:   logic           reg_error;
45: 
46:   logic          addrmiss, wr_err;
47: 
48:   logic [DW-1:0] reg_rdata_next;
49:   logic reg_busy;
50: 
51:   tlul_pkg::tl_h2d_t tl_reg_h2d;
52:   tlul_pkg::tl_d2h_t tl_reg_d2h;
53: 
54: 
55:   // incoming payload check
56:   logic intg_err;
57:   tlul_cmd_intg_chk u_chk (
58:     .tl_i(tl_i),
59:     .err_o(intg_err)
60:   );
61: 
62:   // also check for spurious write enables
63:   logic reg_we_err;
64:   logic [56:0] reg_we_check;
65:   prim_reg_we_check #(
66:     .OneHotWidth(57)
67:   ) u_prim_reg_we_check (
68:     .clk_i(clk_i),
69:     .rst_ni(rst_ni),
70:     .oh_i  (reg_we_check),
71:     .en_i  (reg_we && !addrmiss),
72:     .err_o (reg_we_err)
73:   );
74: 
75:   logic err_q;
76:   always_ff @(posedge clk_i or negedge rst_ni) begin
77:     if (!rst_ni) begin
78:       err_q <= '0;
79:     end else if (intg_err || reg_we_err) begin
80:       err_q <= 1'b1;
81:     end
82:   end
83: 
84:   // integrity error output is permanent and should be used for alert generation
85:   // register errors are transactional
86:   assign intg_err_o = err_q | intg_err | reg_we_err;
87: 
88:   // outgoing integrity generation
89:   tlul_pkg::tl_d2h_t tl_o_pre;
90:   tlul_rsp_intg_gen #(
91:     .EnableRspIntgGen(1),
92:     .EnableDataIntgGen(1)
93:   ) u_rsp_intg_gen (
94:     .tl_i(tl_o_pre),
95:     .tl_o(tl_o)
96:   );
97: 
98:   tlul_pkg::tl_h2d_t tl_socket_h2d [3];
99:   tlul_pkg::tl_d2h_t tl_socket_d2h [3];
100: 
101:   logic [1:0] reg_steer;
102: 
103:   // socket_1n connection
104:   assign tl_reg_h2d = tl_socket_h2d[2];
105:   assign tl_socket_d2h[2] = tl_reg_d2h;
106: 
107:   assign tl_win_o[0] = tl_socket_h2d[0];
108:   assign tl_socket_d2h[0] = tl_win_i[0];
109:   assign tl_win_o[1] = tl_socket_h2d[1];
110:   assign tl_socket_d2h[1] = tl_win_i[1];
111: 
112:   // Create Socket_1n
113:   tlul_socket_1n #(
114:     .N            (3),
115:     .HReqPass     (1'b1),
116:     .HRspPass     (1'b1),
117:     .DReqPass     ({3{1'b1}}),
118:     .DRspPass     ({3{1'b1}}),
119:     .HReqDepth    (4'h0),
120:     .HRspDepth    (4'h0),
121:     .DReqDepth    ({3{4'h0}}),
122:     .DRspDepth    ({3{4'h0}}),
123:     .ExplicitErrs (1'b0)
124:   ) u_socket (
125:     .clk_i  (clk_i),
126:     .rst_ni (rst_ni),
127:     .tl_h_i (tl_i),
128:     .tl_h_o (tl_o_pre),
129:     .tl_d_o (tl_socket_h2d),
130:     .tl_d_i (tl_socket_d2h),
131:     .dev_select_i (reg_steer)
132:   );
133: 
134:   // Create steering logic
135:   always_comb begin
136:     reg_steer =
137:         tl_i.a_address[AW-1:0] inside {[1024:1535]} ? 2'd0 :
138:         tl_i.a_address[AW-1:0] inside {[2048:4095]} ? 2'd1 :
139:         // Default set to register
140:         2'd2;
141: 
142:     // Override this in case of an integrity error
143:     if (intg_err) begin
144:       reg_steer = 2'd2;
145:     end
146:   end
147: 
148:   tlul_adapter_reg #(
149:     .RegAw(AW),
150:     .RegDw(DW),
151:     .EnableDataIntgGen(0)
152:   ) u_reg_if (
153:     .clk_i  (clk_i),
154:     .rst_ni (rst_ni),
155: 
156:     .tl_i (tl_reg_h2d),
157:     .tl_o (tl_reg_d2h),
158: 
159:     .en_ifetch_i(prim_mubi_pkg::MuBi4False),
160:     .intg_error_o(),
161: 
162:     .we_o    (reg_we),
163:     .re_o    (reg_re),
164:     .addr_o  (reg_addr),
165:     .wdata_o (reg_wdata),
166:     .be_o    (reg_be),
167:     .busy_i  (reg_busy),
168:     .rdata_i (reg_rdata),
169:     .error_i (reg_error)
170:   );
171: 
172:   // cdc oversampling signals
173: 
174:   assign reg_rdata = reg_rdata_next ;
175:   assign reg_error = addrmiss | wr_err | intg_err;
176: 
177:   // Define SW related signals
178:   // Format: <reg>_<field>_{wd|we|qs}
179:   //        or <reg>_{wd|we|qs} if field == 1 or 0
180:   logic intr_state_we;
181:   logic intr_state_kmac_done_qs;
182:   logic intr_state_kmac_done_wd;
183:   logic intr_state_fifo_empty_qs;
184:   logic intr_state_kmac_err_qs;
185:   logic intr_state_kmac_err_wd;
186:   logic intr_enable_we;
187:   logic intr_enable_kmac_done_qs;
188:   logic intr_enable_kmac_done_wd;
189:   logic intr_enable_fifo_empty_qs;
190:   logic intr_enable_fifo_empty_wd;
191:   logic intr_enable_kmac_err_qs;
192:   logic intr_enable_kmac_err_wd;
193:   logic intr_test_we;
194:   logic intr_test_kmac_done_wd;
195:   logic intr_test_fifo_empty_wd;
196:   logic intr_test_kmac_err_wd;
197:   logic alert_test_we;
198:   logic alert_test_recov_operation_err_wd;
199:   logic alert_test_fatal_fault_err_wd;
200:   logic cfg_regwen_re;
201:   logic cfg_regwen_qs;
202:   logic cfg_shadowed_re;
203:   logic cfg_shadowed_we;
204:   logic cfg_shadowed_kmac_en_qs;
205:   logic cfg_shadowed_kmac_en_wd;
206:   logic cfg_shadowed_kmac_en_storage_err;
207:   logic cfg_shadowed_kmac_en_update_err;
208:   logic [2:0] cfg_shadowed_kstrength_qs;
209:   logic [2:0] cfg_shadowed_kstrength_wd;
210:   logic cfg_shadowed_kstrength_storage_err;
211:   logic cfg_shadowed_kstrength_update_err;
212:   logic [1:0] cfg_shadowed_mode_qs;
213:   logic [1:0] cfg_shadowed_mode_wd;
214:   logic cfg_shadowed_mode_storage_err;
215:   logic cfg_shadowed_mode_update_err;
216:   logic cfg_shadowed_msg_endianness_qs;
217:   logic cfg_shadowed_msg_endianness_wd;
218:   logic cfg_shadowed_msg_endianness_storage_err;
219:   logic cfg_shadowed_msg_endianness_update_err;
220:   logic cfg_shadowed_state_endianness_qs;
221:   logic cfg_shadowed_state_endianness_wd;
222:   logic cfg_shadowed_state_endianness_storage_err;
223:   logic cfg_shadowed_state_endianness_update_err;
224:   logic cfg_shadowed_sideload_qs;
225:   logic cfg_shadowed_sideload_wd;
226:   logic cfg_shadowed_sideload_storage_err;
227:   logic cfg_shadowed_sideload_update_err;
228:   logic [1:0] cfg_shadowed_entropy_mode_qs;
229:   logic [1:0] cfg_shadowed_entropy_mode_wd;
230:   logic cfg_shadowed_entropy_mode_storage_err;
231:   logic cfg_shadowed_entropy_mode_update_err;
232:   logic cfg_shadowed_entropy_fast_process_qs;
233:   logic cfg_shadowed_entropy_fast_process_wd;
234:   logic cfg_shadowed_entropy_fast_process_storage_err;
235:   logic cfg_shadowed_entropy_fast_process_update_err;
236:   logic cfg_shadowed_msg_mask_qs;
237:   logic cfg_shadowed_msg_mask_wd;
238:   logic cfg_shadowed_msg_mask_storage_err;
239:   logic cfg_shadowed_msg_mask_update_err;
240:   logic cfg_shadowed_entropy_ready_qs;
241:   logic cfg_shadowed_entropy_ready_wd;
242:   logic cfg_shadowed_entropy_ready_storage_err;
243:   logic cfg_shadowed_entropy_ready_update_err;
244:   logic cfg_shadowed_en_unsupported_modestrength_qs;
245:   logic cfg_shadowed_en_unsupported_modestrength_wd;
246:   logic cfg_shadowed_en_unsupported_modestrength_storage_err;
247:   logic cfg_shadowed_en_unsupported_modestrength_update_err;
248:   logic cmd_we;
249:   logic [5:0] cmd_cmd_wd;
250:   logic cmd_entropy_req_wd;
251:   logic cmd_hash_cnt_clr_wd;
252:   logic cmd_err_processed_wd;
253:   logic status_re;
254:   logic status_sha3_idle_qs;
255:   logic status_sha3_absorb_qs;
256:   logic status_sha3_squeeze_qs;
257:   logic [4:0] status_fifo_depth_qs;
258:   logic status_fifo_empty_qs;
259:   logic status_fifo_full_qs;
260:   logic status_alert_fatal_fault_qs;
261:   logic status_alert_recov_ctrl_update_err_qs;
262:   logic entropy_period_we;
263:   logic [9:0] entropy_period_prescaler_qs;
264:   logic [9:0] entropy_period_prescaler_wd;
265:   logic [15:0] entropy_period_wait_timer_qs;
266:   logic [15:0] entropy_period_wait_timer_wd;
267:   logic [9:0] entropy_refresh_hash_cnt_qs;
268:   logic entropy_refresh_threshold_shadowed_re;
269:   logic entropy_refresh_threshold_shadowed_we;
270:   logic [9:0] entropy_refresh_threshold_shadowed_qs;
271:   logic [9:0] entropy_refresh_threshold_shadowed_wd;
272:   logic entropy_refresh_threshold_shadowed_storage_err;
273:   logic entropy_refresh_threshold_shadowed_update_err;
274:   logic entropy_seed_we;
275:   logic [31:0] entropy_seed_wd;
276:   logic key_share0_0_we;
277:   logic [31:0] key_share0_0_wd;
278:   logic key_share0_1_we;
279:   logic [31:0] key_share0_1_wd;
280:   logic key_share0_2_we;
281:   logic [31:0] key_share0_2_wd;
282:   logic key_share0_3_we;
283:   logic [31:0] key_share0_3_wd;
284:   logic key_share0_4_we;
285:   logic [31:0] key_share0_4_wd;
286:   logic key_share0_5_we;
287:   logic [31:0] key_share0_5_wd;
288:   logic key_share0_6_we;
289:   logic [31:0] key_share0_6_wd;
290:   logic key_share0_7_we;
291:   logic [31:0] key_share0_7_wd;
292:   logic key_share0_8_we;
293:   logic [31:0] key_share0_8_wd;
294:   logic key_share0_9_we;
295:   logic [31:0] key_share0_9_wd;
296:   logic key_share0_10_we;
297:   logic [31:0] key_share0_10_wd;
298:   logic key_share0_11_we;
299:   logic [31:0] key_share0_11_wd;
300:   logic key_share0_12_we;
301:   logic [31:0] key_share0_12_wd;
302:   logic key_share0_13_we;
303:   logic [31:0] key_share0_13_wd;
304:   logic key_share0_14_we;
305:   logic [31:0] key_share0_14_wd;
306:   logic key_share0_15_we;
307:   logic [31:0] key_share0_15_wd;
308:   logic key_share1_0_we;
309:   logic [31:0] key_share1_0_wd;
310:   logic key_share1_1_we;
311:   logic [31:0] key_share1_1_wd;
312:   logic key_share1_2_we;
313:   logic [31:0] key_share1_2_wd;
314:   logic key_share1_3_we;
315:   logic [31:0] key_share1_3_wd;
316:   logic key_share1_4_we;
317:   logic [31:0] key_share1_4_wd;
318:   logic key_share1_5_we;
319:   logic [31:0] key_share1_5_wd;
320:   logic key_share1_6_we;
321:   logic [31:0] key_share1_6_wd;
322:   logic key_share1_7_we;
323:   logic [31:0] key_share1_7_wd;
324:   logic key_share1_8_we;
325:   logic [31:0] key_share1_8_wd;
326:   logic key_share1_9_we;
327:   logic [31:0] key_share1_9_wd;
328:   logic key_share1_10_we;
329:   logic [31:0] key_share1_10_wd;
330:   logic key_share1_11_we;
331:   logic [31:0] key_share1_11_wd;
332:   logic key_share1_12_we;
333:   logic [31:0] key_share1_12_wd;
334:   logic key_share1_13_we;
335:   logic [31:0] key_share1_13_wd;
336:   logic key_share1_14_we;
337:   logic [31:0] key_share1_14_wd;
338:   logic key_share1_15_we;
339:   logic [31:0] key_share1_15_wd;
340:   logic key_len_we;
341:   logic [2:0] key_len_wd;
342:   logic prefix_0_we;
343:   logic [31:0] prefix_0_qs;
344:   logic [31:0] prefix_0_wd;
345:   logic prefix_1_we;
346:   logic [31:0] prefix_1_qs;
347:   logic [31:0] prefix_1_wd;
348:   logic prefix_2_we;
349:   logic [31:0] prefix_2_qs;
350:   logic [31:0] prefix_2_wd;
351:   logic prefix_3_we;
352:   logic [31:0] prefix_3_qs;
353:   logic [31:0] prefix_3_wd;
354:   logic prefix_4_we;
355:   logic [31:0] prefix_4_qs;
356:   logic [31:0] prefix_4_wd;
357:   logic prefix_5_we;
358:   logic [31:0] prefix_5_qs;
359:   logic [31:0] prefix_5_wd;
360:   logic prefix_6_we;
361:   logic [31:0] prefix_6_qs;
362:   logic [31:0] prefix_6_wd;
363:   logic prefix_7_we;
364:   logic [31:0] prefix_7_qs;
365:   logic [31:0] prefix_7_wd;
366:   logic prefix_8_we;
367:   logic [31:0] prefix_8_qs;
368:   logic [31:0] prefix_8_wd;
369:   logic prefix_9_we;
370:   logic [31:0] prefix_9_qs;
371:   logic [31:0] prefix_9_wd;
372:   logic prefix_10_we;
373:   logic [31:0] prefix_10_qs;
374:   logic [31:0] prefix_10_wd;
375:   logic [31:0] err_code_qs;
376: 
377:   // Register instances
378:   // R[intr_state]: V(False)
379:   //   F[kmac_done]: 0:0
380:   prim_subreg #(
381:     .DW      (1),
382:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
383:     .RESVAL  (1'h0),
384:     .Mubi    (1'b0)
385:   ) u_intr_state_kmac_done (
386:     .clk_i   (clk_i),
387:     .rst_ni  (rst_ni),
388: 
389:     // from register interface
390:     .we     (intr_state_we),
391:     .wd     (intr_state_kmac_done_wd),
392: 
393:     // from internal hardware
394:     .de     (hw2reg.intr_state.kmac_done.de),
395:     .d      (hw2reg.intr_state.kmac_done.d),
396: 
397:     // to internal hardware
398:     .qe     (),
399:     .q      (reg2hw.intr_state.kmac_done.q),
400:     .ds     (),
401: 
402:     // to register interface (read)
403:     .qs     (intr_state_kmac_done_qs)
404:   );
405: 
406:   //   F[fifo_empty]: 1:1
407:   prim_subreg #(
408:     .DW      (1),
409:     .SwAccess(prim_subreg_pkg::SwAccessRO),
410:     .RESVAL  (1'h0),
411:     .Mubi    (1'b0)
412:   ) u_intr_state_fifo_empty (
413:     .clk_i   (clk_i),
414:     .rst_ni  (rst_ni),
415: 
416:     // from register interface
417:     .we     (1'b0),
418:     .wd     ('0),
419: 
420:     // from internal hardware
421:     .de     (hw2reg.intr_state.fifo_empty.de),
422:     .d      (hw2reg.intr_state.fifo_empty.d),
423: 
424:     // to internal hardware
425:     .qe     (),
426:     .q      (reg2hw.intr_state.fifo_empty.q),
427:     .ds     (),
428: 
429:     // to register interface (read)
430:     .qs     (intr_state_fifo_empty_qs)
431:   );
432: 
433:   //   F[kmac_err]: 2:2
434:   prim_subreg #(
435:     .DW      (1),
436:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
437:     .RESVAL  (1'h0),
438:     .Mubi    (1'b0)
439:   ) u_intr_state_kmac_err (
440:     .clk_i   (clk_i),
441:     .rst_ni  (rst_ni),
442: 
443:     // from register interface
444:     .we     (intr_state_we),
445:     .wd     (intr_state_kmac_err_wd),
446: 
447:     // from internal hardware
448:     .de     (hw2reg.intr_state.kmac_err.de),
449:     .d      (hw2reg.intr_state.kmac_err.d),
450: 
451:     // to internal hardware
452:     .qe     (),
453:     .q      (reg2hw.intr_state.kmac_err.q),
454:     .ds     (),
455: 
456:     // to register interface (read)
457:     .qs     (intr_state_kmac_err_qs)
458:   );
459: 
460: 
461:   // R[intr_enable]: V(False)
462:   //   F[kmac_done]: 0:0
463:   prim_subreg #(
464:     .DW      (1),
465:     .SwAccess(prim_subreg_pkg::SwAccessRW),
466:     .RESVAL  (1'h0),
467:     .Mubi    (1'b0)
468:   ) u_intr_enable_kmac_done (
469:     .clk_i   (clk_i),
470:     .rst_ni  (rst_ni),
471: 
472:     // from register interface
473:     .we     (intr_enable_we),
474:     .wd     (intr_enable_kmac_done_wd),
475: 
476:     // from internal hardware
477:     .de     (1'b0),
478:     .d      ('0),
479: 
480:     // to internal hardware
481:     .qe     (),
482:     .q      (reg2hw.intr_enable.kmac_done.q),
483:     .ds     (),
484: 
485:     // to register interface (read)
486:     .qs     (intr_enable_kmac_done_qs)
487:   );
488: 
489:   //   F[fifo_empty]: 1:1
490:   prim_subreg #(
491:     .DW      (1),
492:     .SwAccess(prim_subreg_pkg::SwAccessRW),
493:     .RESVAL  (1'h0),
494:     .Mubi    (1'b0)
495:   ) u_intr_enable_fifo_empty (
496:     .clk_i   (clk_i),
497:     .rst_ni  (rst_ni),
498: 
499:     // from register interface
500:     .we     (intr_enable_we),
501:     .wd     (intr_enable_fifo_empty_wd),
502: 
503:     // from internal hardware
504:     .de     (1'b0),
505:     .d      ('0),
506: 
507:     // to internal hardware
508:     .qe     (),
509:     .q      (reg2hw.intr_enable.fifo_empty.q),
510:     .ds     (),
511: 
512:     // to register interface (read)
513:     .qs     (intr_enable_fifo_empty_qs)
514:   );
515: 
516:   //   F[kmac_err]: 2:2
517:   prim_subreg #(
518:     .DW      (1),
519:     .SwAccess(prim_subreg_pkg::SwAccessRW),
520:     .RESVAL  (1'h0),
521:     .Mubi    (1'b0)
522:   ) u_intr_enable_kmac_err (
523:     .clk_i   (clk_i),
524:     .rst_ni  (rst_ni),
525: 
526:     // from register interface
527:     .we     (intr_enable_we),
528:     .wd     (intr_enable_kmac_err_wd),
529: 
530:     // from internal hardware
531:     .de     (1'b0),
532:     .d      ('0),
533: 
534:     // to internal hardware
535:     .qe     (),
536:     .q      (reg2hw.intr_enable.kmac_err.q),
537:     .ds     (),
538: 
539:     // to register interface (read)
540:     .qs     (intr_enable_kmac_err_qs)
541:   );
542: 
543: 
544:   // R[intr_test]: V(True)
545:   logic intr_test_qe;
546:   logic [2:0] intr_test_flds_we;
547:   assign intr_test_qe = &intr_test_flds_we;
548:   //   F[kmac_done]: 0:0
549:   prim_subreg_ext #(
550:     .DW    (1)
551:   ) u_intr_test_kmac_done (
552:     .re     (1'b0),
553:     .we     (intr_test_we),
554:     .wd     (intr_test_kmac_done_wd),
555:     .d      ('0),
556:     .qre    (),
557:     .qe     (intr_test_flds_we[0]),
558:     .q      (reg2hw.intr_test.kmac_done.q),
559:     .ds     (),
560:     .qs     ()
561:   );
562:   assign reg2hw.intr_test.kmac_done.qe = intr_test_qe;
563: 
564:   //   F[fifo_empty]: 1:1
565:   prim_subreg_ext #(
566:     .DW    (1)
567:   ) u_intr_test_fifo_empty (
568:     .re     (1'b0),
569:     .we     (intr_test_we),
570:     .wd     (intr_test_fifo_empty_wd),
571:     .d      ('0),
572:     .qre    (),
573:     .qe     (intr_test_flds_we[1]),
574:     .q      (reg2hw.intr_test.fifo_empty.q),
575:     .ds     (),
576:     .qs     ()
577:   );
578:   assign reg2hw.intr_test.fifo_empty.qe = intr_test_qe;
579: 
580:   //   F[kmac_err]: 2:2
581:   prim_subreg_ext #(
582:     .DW    (1)
583:   ) u_intr_test_kmac_err (
584:     .re     (1'b0),
585:     .we     (intr_test_we),
586:     .wd     (intr_test_kmac_err_wd),
587:     .d      ('0),
588:     .qre    (),
589:     .qe     (intr_test_flds_we[2]),
590:     .q      (reg2hw.intr_test.kmac_err.q),
591:     .ds     (),
592:     .qs     ()
593:   );
594:   assign reg2hw.intr_test.kmac_err.qe = intr_test_qe;
595: 
596: 
597:   // R[alert_test]: V(True)
598:   logic alert_test_qe;
599:   logic [1:0] alert_test_flds_we;
600:   assign alert_test_qe = &alert_test_flds_we;
601:   //   F[recov_operation_err]: 0:0
602:   prim_subreg_ext #(
603:     .DW    (1)
604:   ) u_alert_test_recov_operation_err (
605:     .re     (1'b0),
606:     .we     (alert_test_we),
607:     .wd     (alert_test_recov_operation_err_wd),
608:     .d      ('0),
609:     .qre    (),
610:     .qe     (alert_test_flds_we[0]),
611:     .q      (reg2hw.alert_test.recov_operation_err.q),
612:     .ds     (),
613:     .qs     ()
614:   );
615:   assign reg2hw.alert_test.recov_operation_err.qe = alert_test_qe;
616: 
617:   //   F[fatal_fault_err]: 1:1
618:   prim_subreg_ext #(
619:     .DW    (1)
620:   ) u_alert_test_fatal_fault_err (
621:     .re     (1'b0),
622:     .we     (alert_test_we),
623:     .wd     (alert_test_fatal_fault_err_wd),
624:     .d      ('0),
625:     .qre    (),
626:     .qe     (alert_test_flds_we[1]),
627:     .q      (reg2hw.alert_test.fatal_fault_err.q),
628:     .ds     (),
629:     .qs     ()
630:   );
631:   assign reg2hw.alert_test.fatal_fault_err.qe = alert_test_qe;
632: 
633: 
634:   // R[cfg_regwen]: V(True)
635:   prim_subreg_ext #(
636:     .DW    (1)
637:   ) u_cfg_regwen (
638:     .re     (cfg_regwen_re),
639:     .we     (1'b0),
640:     .wd     ('0),
641:     .d      (hw2reg.cfg_regwen.d),
642:     .qre    (),
643:     .qe     (),
644:     .q      (),
645:     .ds     (),
646:     .qs     (cfg_regwen_qs)
647:   );
648: 
649: 
650:   // R[cfg_shadowed]: V(False)
651:   logic cfg_shadowed_qe;
652:   logic [10:0] cfg_shadowed_flds_we;
653:   prim_flop #(
654:     .Width(1),
655:     .ResetValue(0)
656:   ) u_cfg_shadowed0_qe (
657:     .clk_i(clk_i),
658:     .rst_ni(rst_ni),
659:     .d_i(&cfg_shadowed_flds_we),
660:     .q_o(cfg_shadowed_qe)
661:   );
662:   // Create REGWEN-gated WE signal
663:   logic cfg_shadowed_gated_we;
664:   assign cfg_shadowed_gated_we = cfg_shadowed_we & cfg_regwen_qs;
665:   //   F[kmac_en]: 0:0
666:   prim_subreg_shadow #(
667:     .DW      (1),
668:     .SwAccess(prim_subreg_pkg::SwAccessRW),
669:     .RESVAL  (1'h0),
670:     .Mubi    (1'b0)
671:   ) u_cfg_shadowed_kmac_en (
672:     .clk_i   (clk_i),
673:     .rst_ni  (rst_ni),
674:     .rst_shadowed_ni (rst_shadowed_ni),
675: 
676:     // from register interface
677:     .re     (cfg_shadowed_re),
678:     .we     (cfg_shadowed_gated_we),
679:     .wd     (cfg_shadowed_kmac_en_wd),
680: 
681:     // from internal hardware
682:     .de     (1'b0),
683:     .d      ('0),
684: 
685:     // to internal hardware
686:     .qe     (cfg_shadowed_flds_we[0]),
687:     .q      (reg2hw.cfg_shadowed.kmac_en.q),
688:     .ds     (),
689: 
690:     // to register interface (read)
691:     .qs     (cfg_shadowed_kmac_en_qs),
692: 
693:     // Shadow register phase. Relevant for hwext only.
694:     .phase  (),
695: 
696:     // Shadow register error conditions
697:     .err_update  (cfg_shadowed_kmac_en_update_err),
698:     .err_storage (cfg_shadowed_kmac_en_storage_err)
699:   );
700:   assign reg2hw.cfg_shadowed.kmac_en.qe = cfg_shadowed_qe;
701: 
702:   //   F[kstrength]: 3:1
703:   prim_subreg_shadow #(
704:     .DW      (3),
705:     .SwAccess(prim_subreg_pkg::SwAccessRW),
706:     .RESVAL  (3'h0),
707:     .Mubi    (1'b0)
708:   ) u_cfg_shadowed_kstrength (
709:     .clk_i   (clk_i),
710:     .rst_ni  (rst_ni),
711:     .rst_shadowed_ni (rst_shadowed_ni),
712: 
713:     // from register interface
714:     .re     (cfg_shadowed_re),
715:     .we     (cfg_shadowed_gated_we),
716:     .wd     (cfg_shadowed_kstrength_wd),
717: 
718:     // from internal hardware
719:     .de     (1'b0),
720:     .d      ('0),
721: 
722:     // to internal hardware
723:     .qe     (cfg_shadowed_flds_we[1]),
724:     .q      (reg2hw.cfg_shadowed.kstrength.q),
725:     .ds     (),
726: 
727:     // to register interface (read)
728:     .qs     (cfg_shadowed_kstrength_qs),
729: 
730:     // Shadow register phase. Relevant for hwext only.
731:     .phase  (),
732: 
733:     // Shadow register error conditions
734:     .err_update  (cfg_shadowed_kstrength_update_err),
735:     .err_storage (cfg_shadowed_kstrength_storage_err)
736:   );
737:   assign reg2hw.cfg_shadowed.kstrength.qe = cfg_shadowed_qe;
738: 
739:   //   F[mode]: 5:4
740:   prim_subreg_shadow #(
741:     .DW      (2),
742:     .SwAccess(prim_subreg_pkg::SwAccessRW),
743:     .RESVAL  (2'h0),
744:     .Mubi    (1'b0)
745:   ) u_cfg_shadowed_mode (
746:     .clk_i   (clk_i),
747:     .rst_ni  (rst_ni),
748:     .rst_shadowed_ni (rst_shadowed_ni),
749: 
750:     // from register interface
751:     .re     (cfg_shadowed_re),
752:     .we     (cfg_shadowed_gated_we),
753:     .wd     (cfg_shadowed_mode_wd),
754: 
755:     // from internal hardware
756:     .de     (1'b0),
757:     .d      ('0),
758: 
759:     // to internal hardware
760:     .qe     (cfg_shadowed_flds_we[2]),
761:     .q      (reg2hw.cfg_shadowed.mode.q),
762:     .ds     (),
763: 
764:     // to register interface (read)
765:     .qs     (cfg_shadowed_mode_qs),
766: 
767:     // Shadow register phase. Relevant for hwext only.
768:     .phase  (),
769: 
770:     // Shadow register error conditions
771:     .err_update  (cfg_shadowed_mode_update_err),
772:     .err_storage (cfg_shadowed_mode_storage_err)
773:   );
774:   assign reg2hw.cfg_shadowed.mode.qe = cfg_shadowed_qe;
775: 
776:   //   F[msg_endianness]: 8:8
777:   prim_subreg_shadow #(
778:     .DW      (1),
779:     .SwAccess(prim_subreg_pkg::SwAccessRW),
780:     .RESVAL  (1'h0),
781:     .Mubi    (1'b0)
782:   ) u_cfg_shadowed_msg_endianness (
783:     .clk_i   (clk_i),
784:     .rst_ni  (rst_ni),
785:     .rst_shadowed_ni (rst_shadowed_ni),
786: 
787:     // from register interface
788:     .re     (cfg_shadowed_re),
789:     .we     (cfg_shadowed_gated_we),
790:     .wd     (cfg_shadowed_msg_endianness_wd),
791: 
792:     // from internal hardware
793:     .de     (1'b0),
794:     .d      ('0),
795: 
796:     // to internal hardware
797:     .qe     (cfg_shadowed_flds_we[3]),
798:     .q      (reg2hw.cfg_shadowed.msg_endianness.q),
799:     .ds     (),
800: 
801:     // to register interface (read)
802:     .qs     (cfg_shadowed_msg_endianness_qs),
803: 
804:     // Shadow register phase. Relevant for hwext only.
805:     .phase  (),
806: 
807:     // Shadow register error conditions
808:     .err_update  (cfg_shadowed_msg_endianness_update_err),
809:     .err_storage (cfg_shadowed_msg_endianness_storage_err)
810:   );
811:   assign reg2hw.cfg_shadowed.msg_endianness.qe = cfg_shadowed_qe;
812: 
813:   //   F[state_endianness]: 9:9
814:   prim_subreg_shadow #(
815:     .DW      (1),
816:     .SwAccess(prim_subreg_pkg::SwAccessRW),
817:     .RESVAL  (1'h0),
818:     .Mubi    (1'b0)
819:   ) u_cfg_shadowed_state_endianness (
820:     .clk_i   (clk_i),
821:     .rst_ni  (rst_ni),
822:     .rst_shadowed_ni (rst_shadowed_ni),
823: 
824:     // from register interface
825:     .re     (cfg_shadowed_re),
826:     .we     (cfg_shadowed_gated_we),
827:     .wd     (cfg_shadowed_state_endianness_wd),
828: 
829:     // from internal hardware
830:     .de     (1'b0),
831:     .d      ('0),
832: 
833:     // to internal hardware
834:     .qe     (cfg_shadowed_flds_we[4]),
835:     .q      (reg2hw.cfg_shadowed.state_endianness.q),
836:     .ds     (),
837: 
838:     // to register interface (read)
839:     .qs     (cfg_shadowed_state_endianness_qs),
840: 
841:     // Shadow register phase. Relevant for hwext only.
842:     .phase  (),
843: 
844:     // Shadow register error conditions
845:     .err_update  (cfg_shadowed_state_endianness_update_err),
846:     .err_storage (cfg_shadowed_state_endianness_storage_err)
847:   );
848:   assign reg2hw.cfg_shadowed.state_endianness.qe = cfg_shadowed_qe;
849: 
850:   //   F[sideload]: 12:12
851:   prim_subreg_shadow #(
852:     .DW      (1),
853:     .SwAccess(prim_subreg_pkg::SwAccessRW),
854:     .RESVAL  (1'h0),
855:     .Mubi    (1'b0)
856:   ) u_cfg_shadowed_sideload (
857:     .clk_i   (clk_i),
858:     .rst_ni  (rst_ni),
859:     .rst_shadowed_ni (rst_shadowed_ni),
860: 
861:     // from register interface
862:     .re     (cfg_shadowed_re),
863:     .we     (cfg_shadowed_gated_we),
864:     .wd     (cfg_shadowed_sideload_wd),
865: 
866:     // from internal hardware
867:     .de     (1'b0),
868:     .d      ('0),
869: 
870:     // to internal hardware
871:     .qe     (cfg_shadowed_flds_we[5]),
872:     .q      (reg2hw.cfg_shadowed.sideload.q),
873:     .ds     (),
874: 
875:     // to register interface (read)
876:     .qs     (cfg_shadowed_sideload_qs),
877: 
878:     // Shadow register phase. Relevant for hwext only.
879:     .phase  (),
880: 
881:     // Shadow register error conditions
882:     .err_update  (cfg_shadowed_sideload_update_err),
883:     .err_storage (cfg_shadowed_sideload_storage_err)
884:   );
885:   assign reg2hw.cfg_shadowed.sideload.qe = cfg_shadowed_qe;
886: 
887:   //   F[entropy_mode]: 17:16
888:   prim_subreg_shadow #(
889:     .DW      (2),
890:     .SwAccess(prim_subreg_pkg::SwAccessRW),
891:     .RESVAL  (2'h0),
892:     .Mubi    (1'b0)
893:   ) u_cfg_shadowed_entropy_mode (
894:     .clk_i   (clk_i),
895:     .rst_ni  (rst_ni),
896:     .rst_shadowed_ni (rst_shadowed_ni),
897: 
898:     // from register interface
899:     .re     (cfg_shadowed_re),
900:     .we     (cfg_shadowed_gated_we),
901:     .wd     (cfg_shadowed_entropy_mode_wd),
902: 
903:     // from internal hardware
904:     .de     (1'b0),
905:     .d      ('0),
906: 
907:     // to internal hardware
908:     .qe     (cfg_shadowed_flds_we[6]),
909:     .q      (reg2hw.cfg_shadowed.entropy_mode.q),
910:     .ds     (),
911: 
912:     // to register interface (read)
913:     .qs     (cfg_shadowed_entropy_mode_qs),
914: 
915:     // Shadow register phase. Relevant for hwext only.
916:     .phase  (),
917: 
918:     // Shadow register error conditions
919:     .err_update  (cfg_shadowed_entropy_mode_update_err),
920:     .err_storage (cfg_shadowed_entropy_mode_storage_err)
921:   );
922:   assign reg2hw.cfg_shadowed.entropy_mode.qe = cfg_shadowed_qe;
923: 
924:   //   F[entropy_fast_process]: 19:19
925:   prim_subreg_shadow #(
926:     .DW      (1),
927:     .SwAccess(prim_subreg_pkg::SwAccessRW),
928:     .RESVAL  (1'h0),
929:     .Mubi    (1'b0)
930:   ) u_cfg_shadowed_entropy_fast_process (
931:     .clk_i   (clk_i),
932:     .rst_ni  (rst_ni),
933:     .rst_shadowed_ni (rst_shadowed_ni),
934: 
935:     // from register interface
936:     .re     (cfg_shadowed_re),
937:     .we     (cfg_shadowed_gated_we),
938:     .wd     (cfg_shadowed_entropy_fast_process_wd),
939: 
940:     // from internal hardware
941:     .de     (1'b0),
942:     .d      ('0),
943: 
944:     // to internal hardware
945:     .qe     (cfg_shadowed_flds_we[7]),
946:     .q      (reg2hw.cfg_shadowed.entropy_fast_process.q),
947:     .ds     (),
948: 
949:     // to register interface (read)
950:     .qs     (cfg_shadowed_entropy_fast_process_qs),
951: 
952:     // Shadow register phase. Relevant for hwext only.
953:     .phase  (),
954: 
955:     // Shadow register error conditions
956:     .err_update  (cfg_shadowed_entropy_fast_process_update_err),
957:     .err_storage (cfg_shadowed_entropy_fast_process_storage_err)
958:   );
959:   assign reg2hw.cfg_shadowed.entropy_fast_process.qe = cfg_shadowed_qe;
960: 
961:   //   F[msg_mask]: 20:20
962:   prim_subreg_shadow #(
963:     .DW      (1),
964:     .SwAccess(prim_subreg_pkg::SwAccessRW),
965:     .RESVAL  (1'h0),
966:     .Mubi    (1'b0)
967:   ) u_cfg_shadowed_msg_mask (
968:     .clk_i   (clk_i),
969:     .rst_ni  (rst_ni),
970:     .rst_shadowed_ni (rst_shadowed_ni),
971: 
972:     // from register interface
973:     .re     (cfg_shadowed_re),
974:     .we     (cfg_shadowed_gated_we),
975:     .wd     (cfg_shadowed_msg_mask_wd),
976: 
977:     // from internal hardware
978:     .de     (1'b0),
979:     .d      ('0),
980: 
981:     // to internal hardware
982:     .qe     (cfg_shadowed_flds_we[8]),
983:     .q      (reg2hw.cfg_shadowed.msg_mask.q),
984:     .ds     (),
985: 
986:     // to register interface (read)
987:     .qs     (cfg_shadowed_msg_mask_qs),
988: 
989:     // Shadow register phase. Relevant for hwext only.
990:     .phase  (),
991: 
992:     // Shadow register error conditions
993:     .err_update  (cfg_shadowed_msg_mask_update_err),
994:     .err_storage (cfg_shadowed_msg_mask_storage_err)
995:   );
996:   assign reg2hw.cfg_shadowed.msg_mask.qe = cfg_shadowed_qe;
997: 
998:   //   F[entropy_ready]: 24:24
999:   prim_subreg_shadow #(
1000:     .DW      (1),
1001:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1002:     .RESVAL  (1'h0),
1003:     .Mubi    (1'b0)
1004:   ) u_cfg_shadowed_entropy_ready (
1005:     .clk_i   (clk_i),
1006:     .rst_ni  (rst_ni),
1007:     .rst_shadowed_ni (rst_shadowed_ni),
1008: 
1009:     // from register interface
1010:     .re     (cfg_shadowed_re),
1011:     .we     (cfg_shadowed_gated_we),
1012:     .wd     (cfg_shadowed_entropy_ready_wd),
1013: 
1014:     // from internal hardware
1015:     .de     (1'b0),
1016:     .d      ('0),
1017: 
1018:     // to internal hardware
1019:     .qe     (cfg_shadowed_flds_we[9]),
1020:     .q      (reg2hw.cfg_shadowed.entropy_ready.q),
1021:     .ds     (),
1022: 
1023:     // to register interface (read)
1024:     .qs     (cfg_shadowed_entropy_ready_qs),
1025: 
1026:     // Shadow register phase. Relevant for hwext only.
1027:     .phase  (),
1028: 
1029:     // Shadow register error conditions
1030:     .err_update  (cfg_shadowed_entropy_ready_update_err),
1031:     .err_storage (cfg_shadowed_entropy_ready_storage_err)
1032:   );
1033:   assign reg2hw.cfg_shadowed.entropy_ready.qe = cfg_shadowed_qe;
1034: 
1035:   //   F[en_unsupported_modestrength]: 26:26
1036:   prim_subreg_shadow #(
1037:     .DW      (1),
1038:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1039:     .RESVAL  (1'h0),
1040:     .Mubi    (1'b0)
1041:   ) u_cfg_shadowed_en_unsupported_modestrength (
1042:     .clk_i   (clk_i),
1043:     .rst_ni  (rst_ni),
1044:     .rst_shadowed_ni (rst_shadowed_ni),
1045: 
1046:     // from register interface
1047:     .re     (cfg_shadowed_re),
1048:     .we     (cfg_shadowed_gated_we),
1049:     .wd     (cfg_shadowed_en_unsupported_modestrength_wd),
1050: 
1051:     // from internal hardware
1052:     .de     (1'b0),
1053:     .d      ('0),
1054: 
1055:     // to internal hardware
1056:     .qe     (cfg_shadowed_flds_we[10]),
1057:     .q      (reg2hw.cfg_shadowed.en_unsupported_modestrength.q),
1058:     .ds     (),
1059: 
1060:     // to register interface (read)
1061:     .qs     (cfg_shadowed_en_unsupported_modestrength_qs),
1062: 
1063:     // Shadow register phase. Relevant for hwext only.
1064:     .phase  (),
1065: 
1066:     // Shadow register error conditions
1067:     .err_update  (cfg_shadowed_en_unsupported_modestrength_update_err),
1068:     .err_storage (cfg_shadowed_en_unsupported_modestrength_storage_err)
1069:   );
1070:   assign reg2hw.cfg_shadowed.en_unsupported_modestrength.qe = cfg_shadowed_qe;
1071: 
1072: 
1073:   // R[cmd]: V(True)
1074:   logic cmd_qe;
1075:   logic [3:0] cmd_flds_we;
1076:   assign cmd_qe = &cmd_flds_we;
1077:   //   F[cmd]: 5:0
1078:   prim_subreg_ext #(
1079:     .DW    (6)
1080:   ) u_cmd_cmd (
1081:     .re     (1'b0),
1082:     .we     (cmd_we),
1083:     .wd     (cmd_cmd_wd),
1084:     .d      ('0),
1085:     .qre    (),
1086:     .qe     (cmd_flds_we[0]),
1087:     .q      (reg2hw.cmd.cmd.q),
1088:     .ds     (),
1089:     .qs     ()
1090:   );
1091:   assign reg2hw.cmd.cmd.qe = cmd_qe;
1092: 
1093:   //   F[entropy_req]: 8:8
1094:   prim_subreg_ext #(
1095:     .DW    (1)
1096:   ) u_cmd_entropy_req (
1097:     .re     (1'b0),
1098:     .we     (cmd_we),
1099:     .wd     (cmd_entropy_req_wd),
1100:     .d      ('0),
1101:     .qre    (),
1102:     .qe     (cmd_flds_we[1]),
1103:     .q      (reg2hw.cmd.entropy_req.q),
1104:     .ds     (),
1105:     .qs     ()
1106:   );
1107:   assign reg2hw.cmd.entropy_req.qe = cmd_qe;
1108: 
1109:   //   F[hash_cnt_clr]: 9:9
1110:   prim_subreg_ext #(
1111:     .DW    (1)
1112:   ) u_cmd_hash_cnt_clr (
1113:     .re     (1'b0),
1114:     .we     (cmd_we),
1115:     .wd     (cmd_hash_cnt_clr_wd),
1116:     .d      ('0),
1117:     .qre    (),
1118:     .qe     (cmd_flds_we[2]),
1119:     .q      (reg2hw.cmd.hash_cnt_clr.q),
1120:     .ds     (),
1121:     .qs     ()
1122:   );
1123:   assign reg2hw.cmd.hash_cnt_clr.qe = cmd_qe;
1124: 
1125:   //   F[err_processed]: 10:10
1126:   prim_subreg_ext #(
1127:     .DW    (1)
1128:   ) u_cmd_err_processed (
1129:     .re     (1'b0),
1130:     .we     (cmd_we),
1131:     .wd     (cmd_err_processed_wd),
1132:     .d      ('0),
1133:     .qre    (),
1134:     .qe     (cmd_flds_we[3]),
1135:     .q      (reg2hw.cmd.err_processed.q),
1136:     .ds     (),
1137:     .qs     ()
1138:   );
1139:   assign reg2hw.cmd.err_processed.qe = cmd_qe;
1140: 
1141: 
1142:   // R[status]: V(True)
1143:   //   F[sha3_idle]: 0:0
1144:   prim_subreg_ext #(
1145:     .DW    (1)
1146:   ) u_status_sha3_idle (
1147:     .re     (status_re),
1148:     .we     (1'b0),
1149:     .wd     ('0),
1150:     .d      (hw2reg.status.sha3_idle.d),
1151:     .qre    (),
1152:     .qe     (),
1153:     .q      (),
1154:     .ds     (),
1155:     .qs     (status_sha3_idle_qs)
1156:   );
1157: 
1158:   //   F[sha3_absorb]: 1:1
1159:   prim_subreg_ext #(
1160:     .DW    (1)
1161:   ) u_status_sha3_absorb (
1162:     .re     (status_re),
1163:     .we     (1'b0),
1164:     .wd     ('0),
1165:     .d      (hw2reg.status.sha3_absorb.d),
1166:     .qre    (),
1167:     .qe     (),
1168:     .q      (),
1169:     .ds     (),
1170:     .qs     (status_sha3_absorb_qs)
1171:   );
1172: 
1173:   //   F[sha3_squeeze]: 2:2
1174:   prim_subreg_ext #(
1175:     .DW    (1)
1176:   ) u_status_sha3_squeeze (
1177:     .re     (status_re),
1178:     .we     (1'b0),
1179:     .wd     ('0),
1180:     .d      (hw2reg.status.sha3_squeeze.d),
1181:     .qre    (),
1182:     .qe     (),
1183:     .q      (),
1184:     .ds     (),
1185:     .qs     (status_sha3_squeeze_qs)
1186:   );
1187: 
1188:   //   F[fifo_depth]: 12:8
1189:   prim_subreg_ext #(
1190:     .DW    (5)
1191:   ) u_status_fifo_depth (
1192:     .re     (status_re),
1193:     .we     (1'b0),
1194:     .wd     ('0),
1195:     .d      (hw2reg.status.fifo_depth.d),
1196:     .qre    (),
1197:     .qe     (),
1198:     .q      (),
1199:     .ds     (),
1200:     .qs     (status_fifo_depth_qs)
1201:   );
1202: 
1203:   //   F[fifo_empty]: 14:14
1204:   prim_subreg_ext #(
1205:     .DW    (1)
1206:   ) u_status_fifo_empty (
1207:     .re     (status_re),
1208:     .we     (1'b0),
1209:     .wd     ('0),
1210:     .d      (hw2reg.status.fifo_empty.d),
1211:     .qre    (),
1212:     .qe     (),
1213:     .q      (),
1214:     .ds     (),
1215:     .qs     (status_fifo_empty_qs)
1216:   );
1217: 
1218:   //   F[fifo_full]: 15:15
1219:   prim_subreg_ext #(
1220:     .DW    (1)
1221:   ) u_status_fifo_full (
1222:     .re     (status_re),
1223:     .we     (1'b0),
1224:     .wd     ('0),
1225:     .d      (hw2reg.status.fifo_full.d),
1226:     .qre    (),
1227:     .qe     (),
1228:     .q      (),
1229:     .ds     (),
1230:     .qs     (status_fifo_full_qs)
1231:   );
1232: 
1233:   //   F[alert_fatal_fault]: 16:16
1234:   prim_subreg_ext #(
1235:     .DW    (1)
1236:   ) u_status_alert_fatal_fault (
1237:     .re     (status_re),
1238:     .we     (1'b0),
1239:     .wd     ('0),
1240:     .d      (hw2reg.status.alert_fatal_fault.d),
1241:     .qre    (),
1242:     .qe     (),
1243:     .q      (),
1244:     .ds     (),
1245:     .qs     (status_alert_fatal_fault_qs)
1246:   );
1247: 
1248:   //   F[alert_recov_ctrl_update_err]: 17:17
1249:   prim_subreg_ext #(
1250:     .DW    (1)
1251:   ) u_status_alert_recov_ctrl_update_err (
1252:     .re     (status_re),
1253:     .we     (1'b0),
1254:     .wd     ('0),
1255:     .d      (hw2reg.status.alert_recov_ctrl_update_err.d),
1256:     .qre    (),
1257:     .qe     (),
1258:     .q      (),
1259:     .ds     (),
1260:     .qs     (status_alert_recov_ctrl_update_err_qs)
1261:   );
1262: 
1263: 
1264:   // R[entropy_period]: V(False)
1265:   // Create REGWEN-gated WE signal
1266:   logic entropy_period_gated_we;
1267:   assign entropy_period_gated_we = entropy_period_we & cfg_regwen_qs;
1268:   //   F[prescaler]: 9:0
1269:   prim_subreg #(
1270:     .DW      (10),
1271:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1272:     .RESVAL  (10'h0),
1273:     .Mubi    (1'b0)
1274:   ) u_entropy_period_prescaler (
1275:     .clk_i   (clk_i),
1276:     .rst_ni  (rst_ni),
1277: 
1278:     // from register interface
1279:     .we     (entropy_period_gated_we),
1280:     .wd     (entropy_period_prescaler_wd),
1281: 
1282:     // from internal hardware
1283:     .de     (1'b0),
1284:     .d      ('0),
1285: 
1286:     // to internal hardware
1287:     .qe     (),
1288:     .q      (reg2hw.entropy_period.prescaler.q),
1289:     .ds     (),
1290: 
1291:     // to register interface (read)
1292:     .qs     (entropy_period_prescaler_qs)
1293:   );
1294: 
1295:   //   F[wait_timer]: 31:16
1296:   prim_subreg #(
1297:     .DW      (16),
1298:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1299:     .RESVAL  (16'h0),
1300:     .Mubi    (1'b0)
1301:   ) u_entropy_period_wait_timer (
1302:     .clk_i   (clk_i),
1303:     .rst_ni  (rst_ni),
1304: 
1305:     // from register interface
1306:     .we     (entropy_period_gated_we),
1307:     .wd     (entropy_period_wait_timer_wd),
1308: 
1309:     // from internal hardware
1310:     .de     (1'b0),
1311:     .d      ('0),
1312: 
1313:     // to internal hardware
1314:     .qe     (),
1315:     .q      (reg2hw.entropy_period.wait_timer.q),
1316:     .ds     (),
1317: 
1318:     // to register interface (read)
1319:     .qs     (entropy_period_wait_timer_qs)
1320:   );
1321: 
1322: 
1323:   // R[entropy_refresh_hash_cnt]: V(False)
1324:   prim_subreg #(
1325:     .DW      (10),
1326:     .SwAccess(prim_subreg_pkg::SwAccessRO),
1327:     .RESVAL  (10'h0),
1328:     .Mubi    (1'b0)
1329:   ) u_entropy_refresh_hash_cnt (
1330:     .clk_i   (clk_i),
1331:     .rst_ni  (rst_ni),
1332: 
1333:     // from register interface
1334:     .we     (1'b0),
1335:     .wd     ('0),
1336: 
1337:     // from internal hardware
1338:     .de     (hw2reg.entropy_refresh_hash_cnt.de),
1339:     .d      (hw2reg.entropy_refresh_hash_cnt.d),
1340: 
1341:     // to internal hardware
1342:     .qe     (),
1343:     .q      (),
1344:     .ds     (),
1345: 
1346:     // to register interface (read)
1347:     .qs     (entropy_refresh_hash_cnt_qs)
1348:   );
1349: 
1350: 
1351:   // R[entropy_refresh_threshold_shadowed]: V(False)
1352:   // Create REGWEN-gated WE signal
1353:   logic entropy_refresh_threshold_shadowed_gated_we;
1354:   assign entropy_refresh_threshold_shadowed_gated_we =
1355:     entropy_refresh_threshold_shadowed_we & cfg_regwen_qs;
1356:   prim_subreg_shadow #(
1357:     .DW      (10),
1358:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1359:     .RESVAL  (10'h0),
1360:     .Mubi    (1'b0)
1361:   ) u_entropy_refresh_threshold_shadowed (
1362:     .clk_i   (clk_i),
1363:     .rst_ni  (rst_ni),
1364:     .rst_shadowed_ni (rst_shadowed_ni),
1365: 
1366:     // from register interface
1367:     .re     (entropy_refresh_threshold_shadowed_re),
1368:     .we     (entropy_refresh_threshold_shadowed_gated_we),
1369:     .wd     (entropy_refresh_threshold_shadowed_wd),
1370: 
1371:     // from internal hardware
1372:     .de     (1'b0),
1373:     .d      ('0),
1374: 
1375:     // to internal hardware
1376:     .qe     (),
1377:     .q      (reg2hw.entropy_refresh_threshold_shadowed.q),
1378:     .ds     (),
1379: 
1380:     // to register interface (read)
1381:     .qs     (entropy_refresh_threshold_shadowed_qs),
1382: 
1383:     // Shadow register phase. Relevant for hwext only.
1384:     .phase  (),
1385: 
1386:     // Shadow register error conditions
1387:     .err_update  (entropy_refresh_threshold_shadowed_update_err),
1388:     .err_storage (entropy_refresh_threshold_shadowed_storage_err)
1389:   );
1390: 
1391: 
1392:   // R[entropy_seed]: V(True)
1393:   logic entropy_seed_qe;
1394:   logic [0:0] entropy_seed_flds_we;
1395:   assign entropy_seed_qe = &entropy_seed_flds_we;
1396:   prim_subreg_ext #(
1397:     .DW    (32)
1398:   ) u_entropy_seed (
1399:     .re     (1'b0),
1400:     .we     (entropy_seed_we),
1401:     .wd     (entropy_seed_wd),
1402:     .d      ('0),
1403:     .qre    (),
1404:     .qe     (entropy_seed_flds_we[0]),
1405:     .q      (reg2hw.entropy_seed.q),
1406:     .ds     (),
1407:     .qs     ()
1408:   );
1409:   assign reg2hw.entropy_seed.qe = entropy_seed_qe;
1410: 
1411: 
1412:   // Subregister 0 of Multireg key_share0
1413:   // R[key_share0_0]: V(True)
1414:   logic key_share0_0_qe;
1415:   logic [0:0] key_share0_0_flds_we;
1416:   assign key_share0_0_qe = &key_share0_0_flds_we;
1417:   // Create REGWEN-gated WE signal
1418:   logic key_share0_0_gated_we;
1419:   assign key_share0_0_gated_we = key_share0_0_we & cfg_regwen_qs;
1420:   prim_subreg_ext #(
1421:     .DW    (32)
1422:   ) u_key_share0_0 (
1423:     .re     (1'b0),
1424:     .we     (key_share0_0_gated_we),
1425:     .wd     (key_share0_0_wd),
1426:     .d      ('0),
1427:     .qre    (),
1428:     .qe     (key_share0_0_flds_we[0]),
1429:     .q      (reg2hw.key_share0[0].q),
1430:     .ds     (),
1431:     .qs     ()
1432:   );
1433:   assign reg2hw.key_share0[0].qe = key_share0_0_qe;
1434: 
1435: 
1436:   // Subregister 1 of Multireg key_share0
1437:   // R[key_share0_1]: V(True)
1438:   logic key_share0_1_qe;
1439:   logic [0:0] key_share0_1_flds_we;
1440:   assign key_share0_1_qe = &key_share0_1_flds_we;
1441:   // Create REGWEN-gated WE signal
1442:   logic key_share0_1_gated_we;
1443:   assign key_share0_1_gated_we = key_share0_1_we & cfg_regwen_qs;
1444:   prim_subreg_ext #(
1445:     .DW    (32)
1446:   ) u_key_share0_1 (
1447:     .re     (1'b0),
1448:     .we     (key_share0_1_gated_we),
1449:     .wd     (key_share0_1_wd),
1450:     .d      ('0),
1451:     .qre    (),
1452:     .qe     (key_share0_1_flds_we[0]),
1453:     .q      (reg2hw.key_share0[1].q),
1454:     .ds     (),
1455:     .qs     ()
1456:   );
1457:   assign reg2hw.key_share0[1].qe = key_share0_1_qe;
1458: 
1459: 
1460:   // Subregister 2 of Multireg key_share0
1461:   // R[key_share0_2]: V(True)
1462:   logic key_share0_2_qe;
1463:   logic [0:0] key_share0_2_flds_we;
1464:   assign key_share0_2_qe = &key_share0_2_flds_we;
1465:   // Create REGWEN-gated WE signal
1466:   logic key_share0_2_gated_we;
1467:   assign key_share0_2_gated_we = key_share0_2_we & cfg_regwen_qs;
1468:   prim_subreg_ext #(
1469:     .DW    (32)
1470:   ) u_key_share0_2 (
1471:     .re     (1'b0),
1472:     .we     (key_share0_2_gated_we),
1473:     .wd     (key_share0_2_wd),
1474:     .d      ('0),
1475:     .qre    (),
1476:     .qe     (key_share0_2_flds_we[0]),
1477:     .q      (reg2hw.key_share0[2].q),
1478:     .ds     (),
1479:     .qs     ()
1480:   );
1481:   assign reg2hw.key_share0[2].qe = key_share0_2_qe;
1482: 
1483: 
1484:   // Subregister 3 of Multireg key_share0
1485:   // R[key_share0_3]: V(True)
1486:   logic key_share0_3_qe;
1487:   logic [0:0] key_share0_3_flds_we;
1488:   assign key_share0_3_qe = &key_share0_3_flds_we;
1489:   // Create REGWEN-gated WE signal
1490:   logic key_share0_3_gated_we;
1491:   assign key_share0_3_gated_we = key_share0_3_we & cfg_regwen_qs;
1492:   prim_subreg_ext #(
1493:     .DW    (32)
1494:   ) u_key_share0_3 (
1495:     .re     (1'b0),
1496:     .we     (key_share0_3_gated_we),
1497:     .wd     (key_share0_3_wd),
1498:     .d      ('0),
1499:     .qre    (),
1500:     .qe     (key_share0_3_flds_we[0]),
1501:     .q      (reg2hw.key_share0[3].q),
1502:     .ds     (),
1503:     .qs     ()
1504:   );
1505:   assign reg2hw.key_share0[3].qe = key_share0_3_qe;
1506: 
1507: 
1508:   // Subregister 4 of Multireg key_share0
1509:   // R[key_share0_4]: V(True)
1510:   logic key_share0_4_qe;
1511:   logic [0:0] key_share0_4_flds_we;
1512:   assign key_share0_4_qe = &key_share0_4_flds_we;
1513:   // Create REGWEN-gated WE signal
1514:   logic key_share0_4_gated_we;
1515:   assign key_share0_4_gated_we = key_share0_4_we & cfg_regwen_qs;
1516:   prim_subreg_ext #(
1517:     .DW    (32)
1518:   ) u_key_share0_4 (
1519:     .re     (1'b0),
1520:     .we     (key_share0_4_gated_we),
1521:     .wd     (key_share0_4_wd),
1522:     .d      ('0),
1523:     .qre    (),
1524:     .qe     (key_share0_4_flds_we[0]),
1525:     .q      (reg2hw.key_share0[4].q),
1526:     .ds     (),
1527:     .qs     ()
1528:   );
1529:   assign reg2hw.key_share0[4].qe = key_share0_4_qe;
1530: 
1531: 
1532:   // Subregister 5 of Multireg key_share0
1533:   // R[key_share0_5]: V(True)
1534:   logic key_share0_5_qe;
1535:   logic [0:0] key_share0_5_flds_we;
1536:   assign key_share0_5_qe = &key_share0_5_flds_we;
1537:   // Create REGWEN-gated WE signal
1538:   logic key_share0_5_gated_we;
1539:   assign key_share0_5_gated_we = key_share0_5_we & cfg_regwen_qs;
1540:   prim_subreg_ext #(
1541:     .DW    (32)
1542:   ) u_key_share0_5 (
1543:     .re     (1'b0),
1544:     .we     (key_share0_5_gated_we),
1545:     .wd     (key_share0_5_wd),
1546:     .d      ('0),
1547:     .qre    (),
1548:     .qe     (key_share0_5_flds_we[0]),
1549:     .q      (reg2hw.key_share0[5].q),
1550:     .ds     (),
1551:     .qs     ()
1552:   );
1553:   assign reg2hw.key_share0[5].qe = key_share0_5_qe;
1554: 
1555: 
1556:   // Subregister 6 of Multireg key_share0
1557:   // R[key_share0_6]: V(True)
1558:   logic key_share0_6_qe;
1559:   logic [0:0] key_share0_6_flds_we;
1560:   assign key_share0_6_qe = &key_share0_6_flds_we;
1561:   // Create REGWEN-gated WE signal
1562:   logic key_share0_6_gated_we;
1563:   assign key_share0_6_gated_we = key_share0_6_we & cfg_regwen_qs;
1564:   prim_subreg_ext #(
1565:     .DW    (32)
1566:   ) u_key_share0_6 (
1567:     .re     (1'b0),
1568:     .we     (key_share0_6_gated_we),
1569:     .wd     (key_share0_6_wd),
1570:     .d      ('0),
1571:     .qre    (),
1572:     .qe     (key_share0_6_flds_we[0]),
1573:     .q      (reg2hw.key_share0[6].q),
1574:     .ds     (),
1575:     .qs     ()
1576:   );
1577:   assign reg2hw.key_share0[6].qe = key_share0_6_qe;
1578: 
1579: 
1580:   // Subregister 7 of Multireg key_share0
1581:   // R[key_share0_7]: V(True)
1582:   logic key_share0_7_qe;
1583:   logic [0:0] key_share0_7_flds_we;
1584:   assign key_share0_7_qe = &key_share0_7_flds_we;
1585:   // Create REGWEN-gated WE signal
1586:   logic key_share0_7_gated_we;
1587:   assign key_share0_7_gated_we = key_share0_7_we & cfg_regwen_qs;
1588:   prim_subreg_ext #(
1589:     .DW    (32)
1590:   ) u_key_share0_7 (
1591:     .re     (1'b0),
1592:     .we     (key_share0_7_gated_we),
1593:     .wd     (key_share0_7_wd),
1594:     .d      ('0),
1595:     .qre    (),
1596:     .qe     (key_share0_7_flds_we[0]),
1597:     .q      (reg2hw.key_share0[7].q),
1598:     .ds     (),
1599:     .qs     ()
1600:   );
1601:   assign reg2hw.key_share0[7].qe = key_share0_7_qe;
1602: 
1603: 
1604:   // Subregister 8 of Multireg key_share0
1605:   // R[key_share0_8]: V(True)
1606:   logic key_share0_8_qe;
1607:   logic [0:0] key_share0_8_flds_we;
1608:   assign key_share0_8_qe = &key_share0_8_flds_we;
1609:   // Create REGWEN-gated WE signal
1610:   logic key_share0_8_gated_we;
1611:   assign key_share0_8_gated_we = key_share0_8_we & cfg_regwen_qs;
1612:   prim_subreg_ext #(
1613:     .DW    (32)
1614:   ) u_key_share0_8 (
1615:     .re     (1'b0),
1616:     .we     (key_share0_8_gated_we),
1617:     .wd     (key_share0_8_wd),
1618:     .d      ('0),
1619:     .qre    (),
1620:     .qe     (key_share0_8_flds_we[0]),
1621:     .q      (reg2hw.key_share0[8].q),
1622:     .ds     (),
1623:     .qs     ()
1624:   );
1625:   assign reg2hw.key_share0[8].qe = key_share0_8_qe;
1626: 
1627: 
1628:   // Subregister 9 of Multireg key_share0
1629:   // R[key_share0_9]: V(True)
1630:   logic key_share0_9_qe;
1631:   logic [0:0] key_share0_9_flds_we;
1632:   assign key_share0_9_qe = &key_share0_9_flds_we;
1633:   // Create REGWEN-gated WE signal
1634:   logic key_share0_9_gated_we;
1635:   assign key_share0_9_gated_we = key_share0_9_we & cfg_regwen_qs;
1636:   prim_subreg_ext #(
1637:     .DW    (32)
1638:   ) u_key_share0_9 (
1639:     .re     (1'b0),
1640:     .we     (key_share0_9_gated_we),
1641:     .wd     (key_share0_9_wd),
1642:     .d      ('0),
1643:     .qre    (),
1644:     .qe     (key_share0_9_flds_we[0]),
1645:     .q      (reg2hw.key_share0[9].q),
1646:     .ds     (),
1647:     .qs     ()
1648:   );
1649:   assign reg2hw.key_share0[9].qe = key_share0_9_qe;
1650: 
1651: 
1652:   // Subregister 10 of Multireg key_share0
1653:   // R[key_share0_10]: V(True)
1654:   logic key_share0_10_qe;
1655:   logic [0:0] key_share0_10_flds_we;
1656:   assign key_share0_10_qe = &key_share0_10_flds_we;
1657:   // Create REGWEN-gated WE signal
1658:   logic key_share0_10_gated_we;
1659:   assign key_share0_10_gated_we = key_share0_10_we & cfg_regwen_qs;
1660:   prim_subreg_ext #(
1661:     .DW    (32)
1662:   ) u_key_share0_10 (
1663:     .re     (1'b0),
1664:     .we     (key_share0_10_gated_we),
1665:     .wd     (key_share0_10_wd),
1666:     .d      ('0),
1667:     .qre    (),
1668:     .qe     (key_share0_10_flds_we[0]),
1669:     .q      (reg2hw.key_share0[10].q),
1670:     .ds     (),
1671:     .qs     ()
1672:   );
1673:   assign reg2hw.key_share0[10].qe = key_share0_10_qe;
1674: 
1675: 
1676:   // Subregister 11 of Multireg key_share0
1677:   // R[key_share0_11]: V(True)
1678:   logic key_share0_11_qe;
1679:   logic [0:0] key_share0_11_flds_we;
1680:   assign key_share0_11_qe = &key_share0_11_flds_we;
1681:   // Create REGWEN-gated WE signal
1682:   logic key_share0_11_gated_we;
1683:   assign key_share0_11_gated_we = key_share0_11_we & cfg_regwen_qs;
1684:   prim_subreg_ext #(
1685:     .DW    (32)
1686:   ) u_key_share0_11 (
1687:     .re     (1'b0),
1688:     .we     (key_share0_11_gated_we),
1689:     .wd     (key_share0_11_wd),
1690:     .d      ('0),
1691:     .qre    (),
1692:     .qe     (key_share0_11_flds_we[0]),
1693:     .q      (reg2hw.key_share0[11].q),
1694:     .ds     (),
1695:     .qs     ()
1696:   );
1697:   assign reg2hw.key_share0[11].qe = key_share0_11_qe;
1698: 
1699: 
1700:   // Subregister 12 of Multireg key_share0
1701:   // R[key_share0_12]: V(True)
1702:   logic key_share0_12_qe;
1703:   logic [0:0] key_share0_12_flds_we;
1704:   assign key_share0_12_qe = &key_share0_12_flds_we;
1705:   // Create REGWEN-gated WE signal
1706:   logic key_share0_12_gated_we;
1707:   assign key_share0_12_gated_we = key_share0_12_we & cfg_regwen_qs;
1708:   prim_subreg_ext #(
1709:     .DW    (32)
1710:   ) u_key_share0_12 (
1711:     .re     (1'b0),
1712:     .we     (key_share0_12_gated_we),
1713:     .wd     (key_share0_12_wd),
1714:     .d      ('0),
1715:     .qre    (),
1716:     .qe     (key_share0_12_flds_we[0]),
1717:     .q      (reg2hw.key_share0[12].q),
1718:     .ds     (),
1719:     .qs     ()
1720:   );
1721:   assign reg2hw.key_share0[12].qe = key_share0_12_qe;
1722: 
1723: 
1724:   // Subregister 13 of Multireg key_share0
1725:   // R[key_share0_13]: V(True)
1726:   logic key_share0_13_qe;
1727:   logic [0:0] key_share0_13_flds_we;
1728:   assign key_share0_13_qe = &key_share0_13_flds_we;
1729:   // Create REGWEN-gated WE signal
1730:   logic key_share0_13_gated_we;
1731:   assign key_share0_13_gated_we = key_share0_13_we & cfg_regwen_qs;
1732:   prim_subreg_ext #(
1733:     .DW    (32)
1734:   ) u_key_share0_13 (
1735:     .re     (1'b0),
1736:     .we     (key_share0_13_gated_we),
1737:     .wd     (key_share0_13_wd),
1738:     .d      ('0),
1739:     .qre    (),
1740:     .qe     (key_share0_13_flds_we[0]),
1741:     .q      (reg2hw.key_share0[13].q),
1742:     .ds     (),
1743:     .qs     ()
1744:   );
1745:   assign reg2hw.key_share0[13].qe = key_share0_13_qe;
1746: 
1747: 
1748:   // Subregister 14 of Multireg key_share0
1749:   // R[key_share0_14]: V(True)
1750:   logic key_share0_14_qe;
1751:   logic [0:0] key_share0_14_flds_we;
1752:   assign key_share0_14_qe = &key_share0_14_flds_we;
1753:   // Create REGWEN-gated WE signal
1754:   logic key_share0_14_gated_we;
1755:   assign key_share0_14_gated_we = key_share0_14_we & cfg_regwen_qs;
1756:   prim_subreg_ext #(
1757:     .DW    (32)
1758:   ) u_key_share0_14 (
1759:     .re     (1'b0),
1760:     .we     (key_share0_14_gated_we),
1761:     .wd     (key_share0_14_wd),
1762:     .d      ('0),
1763:     .qre    (),
1764:     .qe     (key_share0_14_flds_we[0]),
1765:     .q      (reg2hw.key_share0[14].q),
1766:     .ds     (),
1767:     .qs     ()
1768:   );
1769:   assign reg2hw.key_share0[14].qe = key_share0_14_qe;
1770: 
1771: 
1772:   // Subregister 15 of Multireg key_share0
1773:   // R[key_share0_15]: V(True)
1774:   logic key_share0_15_qe;
1775:   logic [0:0] key_share0_15_flds_we;
1776:   assign key_share0_15_qe = &key_share0_15_flds_we;
1777:   // Create REGWEN-gated WE signal
1778:   logic key_share0_15_gated_we;
1779:   assign key_share0_15_gated_we = key_share0_15_we & cfg_regwen_qs;
1780:   prim_subreg_ext #(
1781:     .DW    (32)
1782:   ) u_key_share0_15 (
1783:     .re     (1'b0),
1784:     .we     (key_share0_15_gated_we),
1785:     .wd     (key_share0_15_wd),
1786:     .d      ('0),
1787:     .qre    (),
1788:     .qe     (key_share0_15_flds_we[0]),
1789:     .q      (reg2hw.key_share0[15].q),
1790:     .ds     (),
1791:     .qs     ()
1792:   );
1793:   assign reg2hw.key_share0[15].qe = key_share0_15_qe;
1794: 
1795: 
1796:   // Subregister 0 of Multireg key_share1
1797:   // R[key_share1_0]: V(True)
1798:   logic key_share1_0_qe;
1799:   logic [0:0] key_share1_0_flds_we;
1800:   assign key_share1_0_qe = &key_share1_0_flds_we;
1801:   // Create REGWEN-gated WE signal
1802:   logic key_share1_0_gated_we;
1803:   assign key_share1_0_gated_we = key_share1_0_we & cfg_regwen_qs;
1804:   prim_subreg_ext #(
1805:     .DW    (32)
1806:   ) u_key_share1_0 (
1807:     .re     (1'b0),
1808:     .we     (key_share1_0_gated_we),
1809:     .wd     (key_share1_0_wd),
1810:     .d      ('0),
1811:     .qre    (),
1812:     .qe     (key_share1_0_flds_we[0]),
1813:     .q      (reg2hw.key_share1[0].q),
1814:     .ds     (),
1815:     .qs     ()
1816:   );
1817:   assign reg2hw.key_share1[0].qe = key_share1_0_qe;
1818: 
1819: 
1820:   // Subregister 1 of Multireg key_share1
1821:   // R[key_share1_1]: V(True)
1822:   logic key_share1_1_qe;
1823:   logic [0:0] key_share1_1_flds_we;
1824:   assign key_share1_1_qe = &key_share1_1_flds_we;
1825:   // Create REGWEN-gated WE signal
1826:   logic key_share1_1_gated_we;
1827:   assign key_share1_1_gated_we = key_share1_1_we & cfg_regwen_qs;
1828:   prim_subreg_ext #(
1829:     .DW    (32)
1830:   ) u_key_share1_1 (
1831:     .re     (1'b0),
1832:     .we     (key_share1_1_gated_we),
1833:     .wd     (key_share1_1_wd),
1834:     .d      ('0),
1835:     .qre    (),
1836:     .qe     (key_share1_1_flds_we[0]),
1837:     .q      (reg2hw.key_share1[1].q),
1838:     .ds     (),
1839:     .qs     ()
1840:   );
1841:   assign reg2hw.key_share1[1].qe = key_share1_1_qe;
1842: 
1843: 
1844:   // Subregister 2 of Multireg key_share1
1845:   // R[key_share1_2]: V(True)
1846:   logic key_share1_2_qe;
1847:   logic [0:0] key_share1_2_flds_we;
1848:   assign key_share1_2_qe = &key_share1_2_flds_we;
1849:   // Create REGWEN-gated WE signal
1850:   logic key_share1_2_gated_we;
1851:   assign key_share1_2_gated_we = key_share1_2_we & cfg_regwen_qs;
1852:   prim_subreg_ext #(
1853:     .DW    (32)
1854:   ) u_key_share1_2 (
1855:     .re     (1'b0),
1856:     .we     (key_share1_2_gated_we),
1857:     .wd     (key_share1_2_wd),
1858:     .d      ('0),
1859:     .qre    (),
1860:     .qe     (key_share1_2_flds_we[0]),
1861:     .q      (reg2hw.key_share1[2].q),
1862:     .ds     (),
1863:     .qs     ()
1864:   );
1865:   assign reg2hw.key_share1[2].qe = key_share1_2_qe;
1866: 
1867: 
1868:   // Subregister 3 of Multireg key_share1
1869:   // R[key_share1_3]: V(True)
1870:   logic key_share1_3_qe;
1871:   logic [0:0] key_share1_3_flds_we;
1872:   assign key_share1_3_qe = &key_share1_3_flds_we;
1873:   // Create REGWEN-gated WE signal
1874:   logic key_share1_3_gated_we;
1875:   assign key_share1_3_gated_we = key_share1_3_we & cfg_regwen_qs;
1876:   prim_subreg_ext #(
1877:     .DW    (32)
1878:   ) u_key_share1_3 (
1879:     .re     (1'b0),
1880:     .we     (key_share1_3_gated_we),
1881:     .wd     (key_share1_3_wd),
1882:     .d      ('0),
1883:     .qre    (),
1884:     .qe     (key_share1_3_flds_we[0]),
1885:     .q      (reg2hw.key_share1[3].q),
1886:     .ds     (),
1887:     .qs     ()
1888:   );
1889:   assign reg2hw.key_share1[3].qe = key_share1_3_qe;
1890: 
1891: 
1892:   // Subregister 4 of Multireg key_share1
1893:   // R[key_share1_4]: V(True)
1894:   logic key_share1_4_qe;
1895:   logic [0:0] key_share1_4_flds_we;
1896:   assign key_share1_4_qe = &key_share1_4_flds_we;
1897:   // Create REGWEN-gated WE signal
1898:   logic key_share1_4_gated_we;
1899:   assign key_share1_4_gated_we = key_share1_4_we & cfg_regwen_qs;
1900:   prim_subreg_ext #(
1901:     .DW    (32)
1902:   ) u_key_share1_4 (
1903:     .re     (1'b0),
1904:     .we     (key_share1_4_gated_we),
1905:     .wd     (key_share1_4_wd),
1906:     .d      ('0),
1907:     .qre    (),
1908:     .qe     (key_share1_4_flds_we[0]),
1909:     .q      (reg2hw.key_share1[4].q),
1910:     .ds     (),
1911:     .qs     ()
1912:   );
1913:   assign reg2hw.key_share1[4].qe = key_share1_4_qe;
1914: 
1915: 
1916:   // Subregister 5 of Multireg key_share1
1917:   // R[key_share1_5]: V(True)
1918:   logic key_share1_5_qe;
1919:   logic [0:0] key_share1_5_flds_we;
1920:   assign key_share1_5_qe = &key_share1_5_flds_we;
1921:   // Create REGWEN-gated WE signal
1922:   logic key_share1_5_gated_we;
1923:   assign key_share1_5_gated_we = key_share1_5_we & cfg_regwen_qs;
1924:   prim_subreg_ext #(
1925:     .DW    (32)
1926:   ) u_key_share1_5 (
1927:     .re     (1'b0),
1928:     .we     (key_share1_5_gated_we),
1929:     .wd     (key_share1_5_wd),
1930:     .d      ('0),
1931:     .qre    (),
1932:     .qe     (key_share1_5_flds_we[0]),
1933:     .q      (reg2hw.key_share1[5].q),
1934:     .ds     (),
1935:     .qs     ()
1936:   );
1937:   assign reg2hw.key_share1[5].qe = key_share1_5_qe;
1938: 
1939: 
1940:   // Subregister 6 of Multireg key_share1
1941:   // R[key_share1_6]: V(True)
1942:   logic key_share1_6_qe;
1943:   logic [0:0] key_share1_6_flds_we;
1944:   assign key_share1_6_qe = &key_share1_6_flds_we;
1945:   // Create REGWEN-gated WE signal
1946:   logic key_share1_6_gated_we;
1947:   assign key_share1_6_gated_we = key_share1_6_we & cfg_regwen_qs;
1948:   prim_subreg_ext #(
1949:     .DW    (32)
1950:   ) u_key_share1_6 (
1951:     .re     (1'b0),
1952:     .we     (key_share1_6_gated_we),
1953:     .wd     (key_share1_6_wd),
1954:     .d      ('0),
1955:     .qre    (),
1956:     .qe     (key_share1_6_flds_we[0]),
1957:     .q      (reg2hw.key_share1[6].q),
1958:     .ds     (),
1959:     .qs     ()
1960:   );
1961:   assign reg2hw.key_share1[6].qe = key_share1_6_qe;
1962: 
1963: 
1964:   // Subregister 7 of Multireg key_share1
1965:   // R[key_share1_7]: V(True)
1966:   logic key_share1_7_qe;
1967:   logic [0:0] key_share1_7_flds_we;
1968:   assign key_share1_7_qe = &key_share1_7_flds_we;
1969:   // Create REGWEN-gated WE signal
1970:   logic key_share1_7_gated_we;
1971:   assign key_share1_7_gated_we = key_share1_7_we & cfg_regwen_qs;
1972:   prim_subreg_ext #(
1973:     .DW    (32)
1974:   ) u_key_share1_7 (
1975:     .re     (1'b0),
1976:     .we     (key_share1_7_gated_we),
1977:     .wd     (key_share1_7_wd),
1978:     .d      ('0),
1979:     .qre    (),
1980:     .qe     (key_share1_7_flds_we[0]),
1981:     .q      (reg2hw.key_share1[7].q),
1982:     .ds     (),
1983:     .qs     ()
1984:   );
1985:   assign reg2hw.key_share1[7].qe = key_share1_7_qe;
1986: 
1987: 
1988:   // Subregister 8 of Multireg key_share1
1989:   // R[key_share1_8]: V(True)
1990:   logic key_share1_8_qe;
1991:   logic [0:0] key_share1_8_flds_we;
1992:   assign key_share1_8_qe = &key_share1_8_flds_we;
1993:   // Create REGWEN-gated WE signal
1994:   logic key_share1_8_gated_we;
1995:   assign key_share1_8_gated_we = key_share1_8_we & cfg_regwen_qs;
1996:   prim_subreg_ext #(
1997:     .DW    (32)
1998:   ) u_key_share1_8 (
1999:     .re     (1'b0),
2000:     .we     (key_share1_8_gated_we),
2001:     .wd     (key_share1_8_wd),
2002:     .d      ('0),
2003:     .qre    (),
2004:     .qe     (key_share1_8_flds_we[0]),
2005:     .q      (reg2hw.key_share1[8].q),
2006:     .ds     (),
2007:     .qs     ()
2008:   );
2009:   assign reg2hw.key_share1[8].qe = key_share1_8_qe;
2010: 
2011: 
2012:   // Subregister 9 of Multireg key_share1
2013:   // R[key_share1_9]: V(True)
2014:   logic key_share1_9_qe;
2015:   logic [0:0] key_share1_9_flds_we;
2016:   assign key_share1_9_qe = &key_share1_9_flds_we;
2017:   // Create REGWEN-gated WE signal
2018:   logic key_share1_9_gated_we;
2019:   assign key_share1_9_gated_we = key_share1_9_we & cfg_regwen_qs;
2020:   prim_subreg_ext #(
2021:     .DW    (32)
2022:   ) u_key_share1_9 (
2023:     .re     (1'b0),
2024:     .we     (key_share1_9_gated_we),
2025:     .wd     (key_share1_9_wd),
2026:     .d      ('0),
2027:     .qre    (),
2028:     .qe     (key_share1_9_flds_we[0]),
2029:     .q      (reg2hw.key_share1[9].q),
2030:     .ds     (),
2031:     .qs     ()
2032:   );
2033:   assign reg2hw.key_share1[9].qe = key_share1_9_qe;
2034: 
2035: 
2036:   // Subregister 10 of Multireg key_share1
2037:   // R[key_share1_10]: V(True)
2038:   logic key_share1_10_qe;
2039:   logic [0:0] key_share1_10_flds_we;
2040:   assign key_share1_10_qe = &key_share1_10_flds_we;
2041:   // Create REGWEN-gated WE signal
2042:   logic key_share1_10_gated_we;
2043:   assign key_share1_10_gated_we = key_share1_10_we & cfg_regwen_qs;
2044:   prim_subreg_ext #(
2045:     .DW    (32)
2046:   ) u_key_share1_10 (
2047:     .re     (1'b0),
2048:     .we     (key_share1_10_gated_we),
2049:     .wd     (key_share1_10_wd),
2050:     .d      ('0),
2051:     .qre    (),
2052:     .qe     (key_share1_10_flds_we[0]),
2053:     .q      (reg2hw.key_share1[10].q),
2054:     .ds     (),
2055:     .qs     ()
2056:   );
2057:   assign reg2hw.key_share1[10].qe = key_share1_10_qe;
2058: 
2059: 
2060:   // Subregister 11 of Multireg key_share1
2061:   // R[key_share1_11]: V(True)
2062:   logic key_share1_11_qe;
2063:   logic [0:0] key_share1_11_flds_we;
2064:   assign key_share1_11_qe = &key_share1_11_flds_we;
2065:   // Create REGWEN-gated WE signal
2066:   logic key_share1_11_gated_we;
2067:   assign key_share1_11_gated_we = key_share1_11_we & cfg_regwen_qs;
2068:   prim_subreg_ext #(
2069:     .DW    (32)
2070:   ) u_key_share1_11 (
2071:     .re     (1'b0),
2072:     .we     (key_share1_11_gated_we),
2073:     .wd     (key_share1_11_wd),
2074:     .d      ('0),
2075:     .qre    (),
2076:     .qe     (key_share1_11_flds_we[0]),
2077:     .q      (reg2hw.key_share1[11].q),
2078:     .ds     (),
2079:     .qs     ()
2080:   );
2081:   assign reg2hw.key_share1[11].qe = key_share1_11_qe;
2082: 
2083: 
2084:   // Subregister 12 of Multireg key_share1
2085:   // R[key_share1_12]: V(True)
2086:   logic key_share1_12_qe;
2087:   logic [0:0] key_share1_12_flds_we;
2088:   assign key_share1_12_qe = &key_share1_12_flds_we;
2089:   // Create REGWEN-gated WE signal
2090:   logic key_share1_12_gated_we;
2091:   assign key_share1_12_gated_we = key_share1_12_we & cfg_regwen_qs;
2092:   prim_subreg_ext #(
2093:     .DW    (32)
2094:   ) u_key_share1_12 (
2095:     .re     (1'b0),
2096:     .we     (key_share1_12_gated_we),
2097:     .wd     (key_share1_12_wd),
2098:     .d      ('0),
2099:     .qre    (),
2100:     .qe     (key_share1_12_flds_we[0]),
2101:     .q      (reg2hw.key_share1[12].q),
2102:     .ds     (),
2103:     .qs     ()
2104:   );
2105:   assign reg2hw.key_share1[12].qe = key_share1_12_qe;
2106: 
2107: 
2108:   // Subregister 13 of Multireg key_share1
2109:   // R[key_share1_13]: V(True)
2110:   logic key_share1_13_qe;
2111:   logic [0:0] key_share1_13_flds_we;
2112:   assign key_share1_13_qe = &key_share1_13_flds_we;
2113:   // Create REGWEN-gated WE signal
2114:   logic key_share1_13_gated_we;
2115:   assign key_share1_13_gated_we = key_share1_13_we & cfg_regwen_qs;
2116:   prim_subreg_ext #(
2117:     .DW    (32)
2118:   ) u_key_share1_13 (
2119:     .re     (1'b0),
2120:     .we     (key_share1_13_gated_we),
2121:     .wd     (key_share1_13_wd),
2122:     .d      ('0),
2123:     .qre    (),
2124:     .qe     (key_share1_13_flds_we[0]),
2125:     .q      (reg2hw.key_share1[13].q),
2126:     .ds     (),
2127:     .qs     ()
2128:   );
2129:   assign reg2hw.key_share1[13].qe = key_share1_13_qe;
2130: 
2131: 
2132:   // Subregister 14 of Multireg key_share1
2133:   // R[key_share1_14]: V(True)
2134:   logic key_share1_14_qe;
2135:   logic [0:0] key_share1_14_flds_we;
2136:   assign key_share1_14_qe = &key_share1_14_flds_we;
2137:   // Create REGWEN-gated WE signal
2138:   logic key_share1_14_gated_we;
2139:   assign key_share1_14_gated_we = key_share1_14_we & cfg_regwen_qs;
2140:   prim_subreg_ext #(
2141:     .DW    (32)
2142:   ) u_key_share1_14 (
2143:     .re     (1'b0),
2144:     .we     (key_share1_14_gated_we),
2145:     .wd     (key_share1_14_wd),
2146:     .d      ('0),
2147:     .qre    (),
2148:     .qe     (key_share1_14_flds_we[0]),
2149:     .q      (reg2hw.key_share1[14].q),
2150:     .ds     (),
2151:     .qs     ()
2152:   );
2153:   assign reg2hw.key_share1[14].qe = key_share1_14_qe;
2154: 
2155: 
2156:   // Subregister 15 of Multireg key_share1
2157:   // R[key_share1_15]: V(True)
2158:   logic key_share1_15_qe;
2159:   logic [0:0] key_share1_15_flds_we;
2160:   assign key_share1_15_qe = &key_share1_15_flds_we;
2161:   // Create REGWEN-gated WE signal
2162:   logic key_share1_15_gated_we;
2163:   assign key_share1_15_gated_we = key_share1_15_we & cfg_regwen_qs;
2164:   prim_subreg_ext #(
2165:     .DW    (32)
2166:   ) u_key_share1_15 (
2167:     .re     (1'b0),
2168:     .we     (key_share1_15_gated_we),
2169:     .wd     (key_share1_15_wd),
2170:     .d      ('0),
2171:     .qre    (),
2172:     .qe     (key_share1_15_flds_we[0]),
2173:     .q      (reg2hw.key_share1[15].q),
2174:     .ds     (),
2175:     .qs     ()
2176:   );
2177:   assign reg2hw.key_share1[15].qe = key_share1_15_qe;
2178: 
2179: 
2180:   // R[key_len]: V(False)
2181:   // Create REGWEN-gated WE signal
2182:   logic key_len_gated_we;
2183:   assign key_len_gated_we = key_len_we & cfg_regwen_qs;
2184:   prim_subreg #(
2185:     .DW      (3),
2186:     .SwAccess(prim_subreg_pkg::SwAccessWO),
2187:     .RESVAL  (3'h0),
2188:     .Mubi    (1'b0)
2189:   ) u_key_len (
2190:     .clk_i   (clk_i),
2191:     .rst_ni  (rst_ni),
2192: 
2193:     // from register interface
2194:     .we     (key_len_gated_we),
2195:     .wd     (key_len_wd),
2196: 
2197:     // from internal hardware
2198:     .de     (1'b0),
2199:     .d      ('0),
2200: 
2201:     // to internal hardware
2202:     .qe     (),
2203:     .q      (reg2hw.key_len.q),
2204:     .ds     (),
2205: 
2206:     // to register interface (read)
2207:     .qs     ()
2208:   );
2209: 
2210: 
2211:   // Subregister 0 of Multireg prefix
2212:   // R[prefix_0]: V(False)
2213:   // Create REGWEN-gated WE signal
2214:   logic prefix_0_gated_we;
2215:   assign prefix_0_gated_we = prefix_0_we & cfg_regwen_qs;
2216:   prim_subreg #(
2217:     .DW      (32),
2218:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2219:     .RESVAL  (32'h0),
2220:     .Mubi    (1'b0)
2221:   ) u_prefix_0 (
2222:     .clk_i   (clk_i),
2223:     .rst_ni  (rst_ni),
2224: 
2225:     // from register interface
2226:     .we     (prefix_0_gated_we),
2227:     .wd     (prefix_0_wd),
2228: 
2229:     // from internal hardware
2230:     .de     (1'b0),
2231:     .d      ('0),
2232: 
2233:     // to internal hardware
2234:     .qe     (),
2235:     .q      (reg2hw.prefix[0].q),
2236:     .ds     (),
2237: 
2238:     // to register interface (read)
2239:     .qs     (prefix_0_qs)
2240:   );
2241: 
2242: 
2243:   // Subregister 1 of Multireg prefix
2244:   // R[prefix_1]: V(False)
2245:   // Create REGWEN-gated WE signal
2246:   logic prefix_1_gated_we;
2247:   assign prefix_1_gated_we = prefix_1_we & cfg_regwen_qs;
2248:   prim_subreg #(
2249:     .DW      (32),
2250:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2251:     .RESVAL  (32'h0),
2252:     .Mubi    (1'b0)
2253:   ) u_prefix_1 (
2254:     .clk_i   (clk_i),
2255:     .rst_ni  (rst_ni),
2256: 
2257:     // from register interface
2258:     .we     (prefix_1_gated_we),
2259:     .wd     (prefix_1_wd),
2260: 
2261:     // from internal hardware
2262:     .de     (1'b0),
2263:     .d      ('0),
2264: 
2265:     // to internal hardware
2266:     .qe     (),
2267:     .q      (reg2hw.prefix[1].q),
2268:     .ds     (),
2269: 
2270:     // to register interface (read)
2271:     .qs     (prefix_1_qs)
2272:   );
2273: 
2274: 
2275:   // Subregister 2 of Multireg prefix
2276:   // R[prefix_2]: V(False)
2277:   // Create REGWEN-gated WE signal
2278:   logic prefix_2_gated_we;
2279:   assign prefix_2_gated_we = prefix_2_we & cfg_regwen_qs;
2280:   prim_subreg #(
2281:     .DW      (32),
2282:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2283:     .RESVAL  (32'h0),
2284:     .Mubi    (1'b0)
2285:   ) u_prefix_2 (
2286:     .clk_i   (clk_i),
2287:     .rst_ni  (rst_ni),
2288: 
2289:     // from register interface
2290:     .we     (prefix_2_gated_we),
2291:     .wd     (prefix_2_wd),
2292: 
2293:     // from internal hardware
2294:     .de     (1'b0),
2295:     .d      ('0),
2296: 
2297:     // to internal hardware
2298:     .qe     (),
2299:     .q      (reg2hw.prefix[2].q),
2300:     .ds     (),
2301: 
2302:     // to register interface (read)
2303:     .qs     (prefix_2_qs)
2304:   );
2305: 
2306: 
2307:   // Subregister 3 of Multireg prefix
2308:   // R[prefix_3]: V(False)
2309:   // Create REGWEN-gated WE signal
2310:   logic prefix_3_gated_we;
2311:   assign prefix_3_gated_we = prefix_3_we & cfg_regwen_qs;
2312:   prim_subreg #(
2313:     .DW      (32),
2314:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2315:     .RESVAL  (32'h0),
2316:     .Mubi    (1'b0)
2317:   ) u_prefix_3 (
2318:     .clk_i   (clk_i),
2319:     .rst_ni  (rst_ni),
2320: 
2321:     // from register interface
2322:     .we     (prefix_3_gated_we),
2323:     .wd     (prefix_3_wd),
2324: 
2325:     // from internal hardware
2326:     .de     (1'b0),
2327:     .d      ('0),
2328: 
2329:     // to internal hardware
2330:     .qe     (),
2331:     .q      (reg2hw.prefix[3].q),
2332:     .ds     (),
2333: 
2334:     // to register interface (read)
2335:     .qs     (prefix_3_qs)
2336:   );
2337: 
2338: 
2339:   // Subregister 4 of Multireg prefix
2340:   // R[prefix_4]: V(False)
2341:   // Create REGWEN-gated WE signal
2342:   logic prefix_4_gated_we;
2343:   assign prefix_4_gated_we = prefix_4_we & cfg_regwen_qs;
2344:   prim_subreg #(
2345:     .DW      (32),
2346:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2347:     .RESVAL  (32'h0),
2348:     .Mubi    (1'b0)
2349:   ) u_prefix_4 (
2350:     .clk_i   (clk_i),
2351:     .rst_ni  (rst_ni),
2352: 
2353:     // from register interface
2354:     .we     (prefix_4_gated_we),
2355:     .wd     (prefix_4_wd),
2356: 
2357:     // from internal hardware
2358:     .de     (1'b0),
2359:     .d      ('0),
2360: 
2361:     // to internal hardware
2362:     .qe     (),
2363:     .q      (reg2hw.prefix[4].q),
2364:     .ds     (),
2365: 
2366:     // to register interface (read)
2367:     .qs     (prefix_4_qs)
2368:   );
2369: 
2370: 
2371:   // Subregister 5 of Multireg prefix
2372:   // R[prefix_5]: V(False)
2373:   // Create REGWEN-gated WE signal
2374:   logic prefix_5_gated_we;
2375:   assign prefix_5_gated_we = prefix_5_we & cfg_regwen_qs;
2376:   prim_subreg #(
2377:     .DW      (32),
2378:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2379:     .RESVAL  (32'h0),
2380:     .Mubi    (1'b0)
2381:   ) u_prefix_5 (
2382:     .clk_i   (clk_i),
2383:     .rst_ni  (rst_ni),
2384: 
2385:     // from register interface
2386:     .we     (prefix_5_gated_we),
2387:     .wd     (prefix_5_wd),
2388: 
2389:     // from internal hardware
2390:     .de     (1'b0),
2391:     .d      ('0),
2392: 
2393:     // to internal hardware
2394:     .qe     (),
2395:     .q      (reg2hw.prefix[5].q),
2396:     .ds     (),
2397: 
2398:     // to register interface (read)
2399:     .qs     (prefix_5_qs)
2400:   );
2401: 
2402: 
2403:   // Subregister 6 of Multireg prefix
2404:   // R[prefix_6]: V(False)
2405:   // Create REGWEN-gated WE signal
2406:   logic prefix_6_gated_we;
2407:   assign prefix_6_gated_we = prefix_6_we & cfg_regwen_qs;
2408:   prim_subreg #(
2409:     .DW      (32),
2410:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2411:     .RESVAL  (32'h0),
2412:     .Mubi    (1'b0)
2413:   ) u_prefix_6 (
2414:     .clk_i   (clk_i),
2415:     .rst_ni  (rst_ni),
2416: 
2417:     // from register interface
2418:     .we     (prefix_6_gated_we),
2419:     .wd     (prefix_6_wd),
2420: 
2421:     // from internal hardware
2422:     .de     (1'b0),
2423:     .d      ('0),
2424: 
2425:     // to internal hardware
2426:     .qe     (),
2427:     .q      (reg2hw.prefix[6].q),
2428:     .ds     (),
2429: 
2430:     // to register interface (read)
2431:     .qs     (prefix_6_qs)
2432:   );
2433: 
2434: 
2435:   // Subregister 7 of Multireg prefix
2436:   // R[prefix_7]: V(False)
2437:   // Create REGWEN-gated WE signal
2438:   logic prefix_7_gated_we;
2439:   assign prefix_7_gated_we = prefix_7_we & cfg_regwen_qs;
2440:   prim_subreg #(
2441:     .DW      (32),
2442:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2443:     .RESVAL  (32'h0),
2444:     .Mubi    (1'b0)
2445:   ) u_prefix_7 (
2446:     .clk_i   (clk_i),
2447:     .rst_ni  (rst_ni),
2448: 
2449:     // from register interface
2450:     .we     (prefix_7_gated_we),
2451:     .wd     (prefix_7_wd),
2452: 
2453:     // from internal hardware
2454:     .de     (1'b0),
2455:     .d      ('0),
2456: 
2457:     // to internal hardware
2458:     .qe     (),
2459:     .q      (reg2hw.prefix[7].q),
2460:     .ds     (),
2461: 
2462:     // to register interface (read)
2463:     .qs     (prefix_7_qs)
2464:   );
2465: 
2466: 
2467:   // Subregister 8 of Multireg prefix
2468:   // R[prefix_8]: V(False)
2469:   // Create REGWEN-gated WE signal
2470:   logic prefix_8_gated_we;
2471:   assign prefix_8_gated_we = prefix_8_we & cfg_regwen_qs;
2472:   prim_subreg #(
2473:     .DW      (32),
2474:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2475:     .RESVAL  (32'h0),
2476:     .Mubi    (1'b0)
2477:   ) u_prefix_8 (
2478:     .clk_i   (clk_i),
2479:     .rst_ni  (rst_ni),
2480: 
2481:     // from register interface
2482:     .we     (prefix_8_gated_we),
2483:     .wd     (prefix_8_wd),
2484: 
2485:     // from internal hardware
2486:     .de     (1'b0),
2487:     .d      ('0),
2488: 
2489:     // to internal hardware
2490:     .qe     (),
2491:     .q      (reg2hw.prefix[8].q),
2492:     .ds     (),
2493: 
2494:     // to register interface (read)
2495:     .qs     (prefix_8_qs)
2496:   );
2497: 
2498: 
2499:   // Subregister 9 of Multireg prefix
2500:   // R[prefix_9]: V(False)
2501:   // Create REGWEN-gated WE signal
2502:   logic prefix_9_gated_we;
2503:   assign prefix_9_gated_we = prefix_9_we & cfg_regwen_qs;
2504:   prim_subreg #(
2505:     .DW      (32),
2506:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2507:     .RESVAL  (32'h0),
2508:     .Mubi    (1'b0)
2509:   ) u_prefix_9 (
2510:     .clk_i   (clk_i),
2511:     .rst_ni  (rst_ni),
2512: 
2513:     // from register interface
2514:     .we     (prefix_9_gated_we),
2515:     .wd     (prefix_9_wd),
2516: 
2517:     // from internal hardware
2518:     .de     (1'b0),
2519:     .d      ('0),
2520: 
2521:     // to internal hardware
2522:     .qe     (),
2523:     .q      (reg2hw.prefix[9].q),
2524:     .ds     (),
2525: 
2526:     // to register interface (read)
2527:     .qs     (prefix_9_qs)
2528:   );
2529: 
2530: 
2531:   // Subregister 10 of Multireg prefix
2532:   // R[prefix_10]: V(False)
2533:   // Create REGWEN-gated WE signal
2534:   logic prefix_10_gated_we;
2535:   assign prefix_10_gated_we = prefix_10_we & cfg_regwen_qs;
2536:   prim_subreg #(
2537:     .DW      (32),
2538:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2539:     .RESVAL  (32'h0),
2540:     .Mubi    (1'b0)
2541:   ) u_prefix_10 (
2542:     .clk_i   (clk_i),
2543:     .rst_ni  (rst_ni),
2544: 
2545:     // from register interface
2546:     .we     (prefix_10_gated_we),
2547:     .wd     (prefix_10_wd),
2548: 
2549:     // from internal hardware
2550:     .de     (1'b0),
2551:     .d      ('0),
2552: 
2553:     // to internal hardware
2554:     .qe     (),
2555:     .q      (reg2hw.prefix[10].q),
2556:     .ds     (),
2557: 
2558:     // to register interface (read)
2559:     .qs     (prefix_10_qs)
2560:   );
2561: 
2562: 
2563:   // R[err_code]: V(False)
2564:   prim_subreg #(
2565:     .DW      (32),
2566:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2567:     .RESVAL  (32'h0),
2568:     .Mubi    (1'b0)
2569:   ) u_err_code (
2570:     .clk_i   (clk_i),
2571:     .rst_ni  (rst_ni),
2572: 
2573:     // from register interface
2574:     .we     (1'b0),
2575:     .wd     ('0),
2576: 
2577:     // from internal hardware
2578:     .de     (hw2reg.err_code.de),
2579:     .d      (hw2reg.err_code.d),
2580: 
2581:     // to internal hardware
2582:     .qe     (),
2583:     .q      (),
2584:     .ds     (),
2585: 
2586:     // to register interface (read)
2587:     .qs     (err_code_qs)
2588:   );
2589: 
2590: 
2591: 
2592:   logic [56:0] addr_hit;
2593:   always_comb begin
2594:     addr_hit[ 0] = (reg_addr == KMAC_INTR_STATE_OFFSET);
2595:     addr_hit[ 1] = (reg_addr == KMAC_INTR_ENABLE_OFFSET);
2596:     addr_hit[ 2] = (reg_addr == KMAC_INTR_TEST_OFFSET);
2597:     addr_hit[ 3] = (reg_addr == KMAC_ALERT_TEST_OFFSET);
2598:     addr_hit[ 4] = (reg_addr == KMAC_CFG_REGWEN_OFFSET);
2599:     addr_hit[ 5] = (reg_addr == KMAC_CFG_SHADOWED_OFFSET);
2600:     addr_hit[ 6] = (reg_addr == KMAC_CMD_OFFSET);
2601:     addr_hit[ 7] = (reg_addr == KMAC_STATUS_OFFSET);
2602:     addr_hit[ 8] = (reg_addr == KMAC_ENTROPY_PERIOD_OFFSET);
2603:     addr_hit[ 9] = (reg_addr == KMAC_ENTROPY_REFRESH_HASH_CNT_OFFSET);
2604:     addr_hit[10] = (reg_addr == KMAC_ENTROPY_REFRESH_THRESHOLD_SHADOWED_OFFSET);
2605:     addr_hit[11] = (reg_addr == KMAC_ENTROPY_SEED_OFFSET);
2606:     addr_hit[12] = (reg_addr == KMAC_KEY_SHARE0_0_OFFSET);
2607:     addr_hit[13] = (reg_addr == KMAC_KEY_SHARE0_1_OFFSET);
2608:     addr_hit[14] = (reg_addr == KMAC_KEY_SHARE0_2_OFFSET);
2609:     addr_hit[15] = (reg_addr == KMAC_KEY_SHARE0_3_OFFSET);
2610:     addr_hit[16] = (reg_addr == KMAC_KEY_SHARE0_4_OFFSET);
2611:     addr_hit[17] = (reg_addr == KMAC_KEY_SHARE0_5_OFFSET);
2612:     addr_hit[18] = (reg_addr == KMAC_KEY_SHARE0_6_OFFSET);
2613:     addr_hit[19] = (reg_addr == KMAC_KEY_SHARE0_7_OFFSET);
2614:     addr_hit[20] = (reg_addr == KMAC_KEY_SHARE0_8_OFFSET);
2615:     addr_hit[21] = (reg_addr == KMAC_KEY_SHARE0_9_OFFSET);
2616:     addr_hit[22] = (reg_addr == KMAC_KEY_SHARE0_10_OFFSET);
2617:     addr_hit[23] = (reg_addr == KMAC_KEY_SHARE0_11_OFFSET);
2618:     addr_hit[24] = (reg_addr == KMAC_KEY_SHARE0_12_OFFSET);
2619:     addr_hit[25] = (reg_addr == KMAC_KEY_SHARE0_13_OFFSET);
2620:     addr_hit[26] = (reg_addr == KMAC_KEY_SHARE0_14_OFFSET);
2621:     addr_hit[27] = (reg_addr == KMAC_KEY_SHARE0_15_OFFSET);
2622:     addr_hit[28] = (reg_addr == KMAC_KEY_SHARE1_0_OFFSET);
2623:     addr_hit[29] = (reg_addr == KMAC_KEY_SHARE1_1_OFFSET);
2624:     addr_hit[30] = (reg_addr == KMAC_KEY_SHARE1_2_OFFSET);
2625:     addr_hit[31] = (reg_addr == KMAC_KEY_SHARE1_3_OFFSET);
2626:     addr_hit[32] = (reg_addr == KMAC_KEY_SHARE1_4_OFFSET);
2627:     addr_hit[33] = (reg_addr == KMAC_KEY_SHARE1_5_OFFSET);
2628:     addr_hit[34] = (reg_addr == KMAC_KEY_SHARE1_6_OFFSET);
2629:     addr_hit[35] = (reg_addr == KMAC_KEY_SHARE1_7_OFFSET);
2630:     addr_hit[36] = (reg_addr == KMAC_KEY_SHARE1_8_OFFSET);
2631:     addr_hit[37] = (reg_addr == KMAC_KEY_SHARE1_9_OFFSET);
2632:     addr_hit[38] = (reg_addr == KMAC_KEY_SHARE1_10_OFFSET);
2633:     addr_hit[39] = (reg_addr == KMAC_KEY_SHARE1_11_OFFSET);
2634:     addr_hit[40] = (reg_addr == KMAC_KEY_SHARE1_12_OFFSET);
2635:     addr_hit[41] = (reg_addr == KMAC_KEY_SHARE1_13_OFFSET);
2636:     addr_hit[42] = (reg_addr == KMAC_KEY_SHARE1_14_OFFSET);
2637:     addr_hit[43] = (reg_addr == KMAC_KEY_SHARE1_15_OFFSET);
2638:     addr_hit[44] = (reg_addr == KMAC_KEY_LEN_OFFSET);
2639:     addr_hit[45] = (reg_addr == KMAC_PREFIX_0_OFFSET);
2640:     addr_hit[46] = (reg_addr == KMAC_PREFIX_1_OFFSET);
2641:     addr_hit[47] = (reg_addr == KMAC_PREFIX_2_OFFSET);
2642:     addr_hit[48] = (reg_addr == KMAC_PREFIX_3_OFFSET);
2643:     addr_hit[49] = (reg_addr == KMAC_PREFIX_4_OFFSET);
2644:     addr_hit[50] = (reg_addr == KMAC_PREFIX_5_OFFSET);
2645:     addr_hit[51] = (reg_addr == KMAC_PREFIX_6_OFFSET);
2646:     addr_hit[52] = (reg_addr == KMAC_PREFIX_7_OFFSET);
2647:     addr_hit[53] = (reg_addr == KMAC_PREFIX_8_OFFSET);
2648:     addr_hit[54] = (reg_addr == KMAC_PREFIX_9_OFFSET);
2649:     addr_hit[55] = (reg_addr == KMAC_PREFIX_10_OFFSET);
2650:     addr_hit[56] = (reg_addr == KMAC_ERR_CODE_OFFSET);
2651:   end
2652: 
2653:   assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;
2654: 
2655:   // Check sub-word write is permitted
2656:   always_comb begin
2657:     wr_err = (reg_we &
2658:               ((addr_hit[ 0] & (|(KMAC_PERMIT[ 0] & ~reg_be))) |
2659:                (addr_hit[ 1] & (|(KMAC_PERMIT[ 1] & ~reg_be))) |
2660:                (addr_hit[ 2] & (|(KMAC_PERMIT[ 2] & ~reg_be))) |
2661:                (addr_hit[ 3] & (|(KMAC_PERMIT[ 3] & ~reg_be))) |
2662:                (addr_hit[ 4] & (|(KMAC_PERMIT[ 4] & ~reg_be))) |
2663:                (addr_hit[ 5] & (|(KMAC_PERMIT[ 5] & ~reg_be))) |
2664:                (addr_hit[ 6] & (|(KMAC_PERMIT[ 6] & ~reg_be))) |
2665:                (addr_hit[ 7] & (|(KMAC_PERMIT[ 7] & ~reg_be))) |
2666:                (addr_hit[ 8] & (|(KMAC_PERMIT[ 8] & ~reg_be))) |
2667:                (addr_hit[ 9] & (|(KMAC_PERMIT[ 9] & ~reg_be))) |
2668:                (addr_hit[10] & (|(KMAC_PERMIT[10] & ~reg_be))) |
2669:                (addr_hit[11] & (|(KMAC_PERMIT[11] & ~reg_be))) |
2670:                (addr_hit[12] & (|(KMAC_PERMIT[12] & ~reg_be))) |
2671:                (addr_hit[13] & (|(KMAC_PERMIT[13] & ~reg_be))) |
2672:                (addr_hit[14] & (|(KMAC_PERMIT[14] & ~reg_be))) |
2673:                (addr_hit[15] & (|(KMAC_PERMIT[15] & ~reg_be))) |
2674:                (addr_hit[16] & (|(KMAC_PERMIT[16] & ~reg_be))) |
2675:                (addr_hit[17] & (|(KMAC_PERMIT[17] & ~reg_be))) |
2676:                (addr_hit[18] & (|(KMAC_PERMIT[18] & ~reg_be))) |
2677:                (addr_hit[19] & (|(KMAC_PERMIT[19] & ~reg_be))) |
2678:                (addr_hit[20] & (|(KMAC_PERMIT[20] & ~reg_be))) |
2679:                (addr_hit[21] & (|(KMAC_PERMIT[21] & ~reg_be))) |
2680:                (addr_hit[22] & (|(KMAC_PERMIT[22] & ~reg_be))) |
2681:                (addr_hit[23] & (|(KMAC_PERMIT[23] & ~reg_be))) |
2682:                (addr_hit[24] & (|(KMAC_PERMIT[24] & ~reg_be))) |
2683:                (addr_hit[25] & (|(KMAC_PERMIT[25] & ~reg_be))) |
2684:                (addr_hit[26] & (|(KMAC_PERMIT[26] & ~reg_be))) |
2685:                (addr_hit[27] & (|(KMAC_PERMIT[27] & ~reg_be))) |
2686:                (addr_hit[28] & (|(KMAC_PERMIT[28] & ~reg_be))) |
2687:                (addr_hit[29] & (|(KMAC_PERMIT[29] & ~reg_be))) |
2688:                (addr_hit[30] & (|(KMAC_PERMIT[30] & ~reg_be))) |
2689:                (addr_hit[31] & (|(KMAC_PERMIT[31] & ~reg_be))) |
2690:                (addr_hit[32] & (|(KMAC_PERMIT[32] & ~reg_be))) |
2691:                (addr_hit[33] & (|(KMAC_PERMIT[33] & ~reg_be))) |
2692:                (addr_hit[34] & (|(KMAC_PERMIT[34] & ~reg_be))) |
2693:                (addr_hit[35] & (|(KMAC_PERMIT[35] & ~reg_be))) |
2694:                (addr_hit[36] & (|(KMAC_PERMIT[36] & ~reg_be))) |
2695:                (addr_hit[37] & (|(KMAC_PERMIT[37] & ~reg_be))) |
2696:                (addr_hit[38] & (|(KMAC_PERMIT[38] & ~reg_be))) |
2697:                (addr_hit[39] & (|(KMAC_PERMIT[39] & ~reg_be))) |
2698:                (addr_hit[40] & (|(KMAC_PERMIT[40] & ~reg_be))) |
2699:                (addr_hit[41] & (|(KMAC_PERMIT[41] & ~reg_be))) |
2700:                (addr_hit[42] & (|(KMAC_PERMIT[42] & ~reg_be))) |
2701:                (addr_hit[43] & (|(KMAC_PERMIT[43] & ~reg_be))) |
2702:                (addr_hit[44] & (|(KMAC_PERMIT[44] & ~reg_be))) |
2703:                (addr_hit[45] & (|(KMAC_PERMIT[45] & ~reg_be))) |
2704:                (addr_hit[46] & (|(KMAC_PERMIT[46] & ~reg_be))) |
2705:                (addr_hit[47] & (|(KMAC_PERMIT[47] & ~reg_be))) |
2706:                (addr_hit[48] & (|(KMAC_PERMIT[48] & ~reg_be))) |
2707:                (addr_hit[49] & (|(KMAC_PERMIT[49] & ~reg_be))) |
2708:                (addr_hit[50] & (|(KMAC_PERMIT[50] & ~reg_be))) |
2709:                (addr_hit[51] & (|(KMAC_PERMIT[51] & ~reg_be))) |
2710:                (addr_hit[52] & (|(KMAC_PERMIT[52] & ~reg_be))) |
2711:                (addr_hit[53] & (|(KMAC_PERMIT[53] & ~reg_be))) |
2712:                (addr_hit[54] & (|(KMAC_PERMIT[54] & ~reg_be))) |
2713:                (addr_hit[55] & (|(KMAC_PERMIT[55] & ~reg_be))) |
2714:                (addr_hit[56] & (|(KMAC_PERMIT[56] & ~reg_be)))));
2715:   end
2716: 
2717:   // Generate write-enables
2718:   assign intr_state_we = addr_hit[0] & reg_we & !reg_error;
2719: 
2720:   assign intr_state_kmac_done_wd = reg_wdata[0];
2721: 
2722:   assign intr_state_kmac_err_wd = reg_wdata[2];
2723:   assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;
2724: 
2725:   assign intr_enable_kmac_done_wd = reg_wdata[0];
2726: 
2727:   assign intr_enable_fifo_empty_wd = reg_wdata[1];
2728: 
2729:   assign intr_enable_kmac_err_wd = reg_wdata[2];
2730:   assign intr_test_we = addr_hit[2] & reg_we & !reg_error;
2731: 
2732:   assign intr_test_kmac_done_wd = reg_wdata[0];
2733: 
2734:   assign intr_test_fifo_empty_wd = reg_wdata[1];
2735: 
2736:   assign intr_test_kmac_err_wd = reg_wdata[2];
2737:   assign alert_test_we = addr_hit[3] & reg_we & !reg_error;
2738: 
2739:   assign alert_test_recov_operation_err_wd = reg_wdata[0];
2740: 
2741:   assign alert_test_fatal_fault_err_wd = reg_wdata[1];
2742:   assign cfg_regwen_re = addr_hit[4] & reg_re & !reg_error;
2743:   assign cfg_shadowed_re = addr_hit[5] & reg_re & !reg_error;
2744:   assign cfg_shadowed_we = addr_hit[5] & reg_we & !reg_error;
2745: 
2746:   assign cfg_shadowed_kmac_en_wd = reg_wdata[0];
2747: 
2748:   assign cfg_shadowed_kstrength_wd = reg_wdata[3:1];
2749: 
2750:   assign cfg_shadowed_mode_wd = reg_wdata[5:4];
2751: 
2752:   assign cfg_shadowed_msg_endianness_wd = reg_wdata[8];
2753: 
2754:   assign cfg_shadowed_state_endianness_wd = reg_wdata[9];
2755: 
2756:   assign cfg_shadowed_sideload_wd = reg_wdata[12];
2757: 
2758:   assign cfg_shadowed_entropy_mode_wd = reg_wdata[17:16];
2759: 
2760:   assign cfg_shadowed_entropy_fast_process_wd = reg_wdata[19];
2761: 
2762:   assign cfg_shadowed_msg_mask_wd = reg_wdata[20];
2763: 
2764:   assign cfg_shadowed_entropy_ready_wd = reg_wdata[24];
2765: 
2766:   assign cfg_shadowed_en_unsupported_modestrength_wd = reg_wdata[26];
2767:   assign cmd_we = addr_hit[6] & reg_we & !reg_error;
2768: 
2769:   assign cmd_cmd_wd = reg_wdata[5:0];
2770: 
2771:   assign cmd_entropy_req_wd = reg_wdata[8];
2772: 
2773:   assign cmd_hash_cnt_clr_wd = reg_wdata[9];
2774: 
2775:   assign cmd_err_processed_wd = reg_wdata[10];
2776:   assign status_re = addr_hit[7] & reg_re & !reg_error;
2777:   assign entropy_period_we = addr_hit[8] & reg_we & !reg_error;
2778: 
2779:   assign entropy_period_prescaler_wd = reg_wdata[9:0];
2780: 
2781:   assign entropy_period_wait_timer_wd = reg_wdata[31:16];
2782:   assign entropy_refresh_threshold_shadowed_re = addr_hit[10] & reg_re & !reg_error;
2783:   assign entropy_refresh_threshold_shadowed_we = addr_hit[10] & reg_we & !reg_error;
2784: 
2785:   assign entropy_refresh_threshold_shadowed_wd = reg_wdata[9:0];
2786:   assign entropy_seed_we = addr_hit[11] & reg_we & !reg_error;
2787: 
2788:   assign entropy_seed_wd = reg_wdata[31:0];
2789:   assign key_share0_0_we = addr_hit[12] & reg_we & !reg_error;
2790: 
2791:   assign key_share0_0_wd = reg_wdata[31:0];
2792:   assign key_share0_1_we = addr_hit[13] & reg_we & !reg_error;
2793: 
2794:   assign key_share0_1_wd = reg_wdata[31:0];
2795:   assign key_share0_2_we = addr_hit[14] & reg_we & !reg_error;
2796: 
2797:   assign key_share0_2_wd = reg_wdata[31:0];
2798:   assign key_share0_3_we = addr_hit[15] & reg_we & !reg_error;
2799: 
2800:   assign key_share0_3_wd = reg_wdata[31:0];
2801:   assign key_share0_4_we = addr_hit[16] & reg_we & !reg_error;
2802: 
2803:   assign key_share0_4_wd = reg_wdata[31:0];
2804:   assign key_share0_5_we = addr_hit[17] & reg_we & !reg_error;
2805: 
2806:   assign key_share0_5_wd = reg_wdata[31:0];
2807:   assign key_share0_6_we = addr_hit[18] & reg_we & !reg_error;
2808: 
2809:   assign key_share0_6_wd = reg_wdata[31:0];
2810:   assign key_share0_7_we = addr_hit[19] & reg_we & !reg_error;
2811: 
2812:   assign key_share0_7_wd = reg_wdata[31:0];
2813:   assign key_share0_8_we = addr_hit[20] & reg_we & !reg_error;
2814: 
2815:   assign key_share0_8_wd = reg_wdata[31:0];
2816:   assign key_share0_9_we = addr_hit[21] & reg_we & !reg_error;
2817: 
2818:   assign key_share0_9_wd = reg_wdata[31:0];
2819:   assign key_share0_10_we = addr_hit[22] & reg_we & !reg_error;
2820: 
2821:   assign key_share0_10_wd = reg_wdata[31:0];
2822:   assign key_share0_11_we = addr_hit[23] & reg_we & !reg_error;
2823: 
2824:   assign key_share0_11_wd = reg_wdata[31:0];
2825:   assign key_share0_12_we = addr_hit[24] & reg_we & !reg_error;
2826: 
2827:   assign key_share0_12_wd = reg_wdata[31:0];
2828:   assign key_share0_13_we = addr_hit[25] & reg_we & !reg_error;
2829: 
2830:   assign key_share0_13_wd = reg_wdata[31:0];
2831:   assign key_share0_14_we = addr_hit[26] & reg_we & !reg_error;
2832: 
2833:   assign key_share0_14_wd = reg_wdata[31:0];
2834:   assign key_share0_15_we = addr_hit[27] & reg_we & !reg_error;
2835: 
2836:   assign key_share0_15_wd = reg_wdata[31:0];
2837:   assign key_share1_0_we = addr_hit[28] & reg_we & !reg_error;
2838: 
2839:   assign key_share1_0_wd = reg_wdata[31:0];
2840:   assign key_share1_1_we = addr_hit[29] & reg_we & !reg_error;
2841: 
2842:   assign key_share1_1_wd = reg_wdata[31:0];
2843:   assign key_share1_2_we = addr_hit[30] & reg_we & !reg_error;
2844: 
2845:   assign key_share1_2_wd = reg_wdata[31:0];
2846:   assign key_share1_3_we = addr_hit[31] & reg_we & !reg_error;
2847: 
2848:   assign key_share1_3_wd = reg_wdata[31:0];
2849:   assign key_share1_4_we = addr_hit[32] & reg_we & !reg_error;
2850: 
2851:   assign key_share1_4_wd = reg_wdata[31:0];
2852:   assign key_share1_5_we = addr_hit[33] & reg_we & !reg_error;
2853: 
2854:   assign key_share1_5_wd = reg_wdata[31:0];
2855:   assign key_share1_6_we = addr_hit[34] & reg_we & !reg_error;
2856: 
2857:   assign key_share1_6_wd = reg_wdata[31:0];
2858:   assign key_share1_7_we = addr_hit[35] & reg_we & !reg_error;
2859: 
2860:   assign key_share1_7_wd = reg_wdata[31:0];
2861:   assign key_share1_8_we = addr_hit[36] & reg_we & !reg_error;
2862: 
2863:   assign key_share1_8_wd = reg_wdata[31:0];
2864:   assign key_share1_9_we = addr_hit[37] & reg_we & !reg_error;
2865: 
2866:   assign key_share1_9_wd = reg_wdata[31:0];
2867:   assign key_share1_10_we = addr_hit[38] & reg_we & !reg_error;
2868: 
2869:   assign key_share1_10_wd = reg_wdata[31:0];
2870:   assign key_share1_11_we = addr_hit[39] & reg_we & !reg_error;
2871: 
2872:   assign key_share1_11_wd = reg_wdata[31:0];
2873:   assign key_share1_12_we = addr_hit[40] & reg_we & !reg_error;
2874: 
2875:   assign key_share1_12_wd = reg_wdata[31:0];
2876:   assign key_share1_13_we = addr_hit[41] & reg_we & !reg_error;
2877: 
2878:   assign key_share1_13_wd = reg_wdata[31:0];
2879:   assign key_share1_14_we = addr_hit[42] & reg_we & !reg_error;
2880: 
2881:   assign key_share1_14_wd = reg_wdata[31:0];
2882:   assign key_share1_15_we = addr_hit[43] & reg_we & !reg_error;
2883: 
2884:   assign key_share1_15_wd = reg_wdata[31:0];
2885:   assign key_len_we = addr_hit[44] & reg_we & !reg_error;
2886: 
2887:   assign key_len_wd = reg_wdata[2:0];
2888:   assign prefix_0_we = addr_hit[45] & reg_we & !reg_error;
2889: 
2890:   assign prefix_0_wd = reg_wdata[31:0];
2891:   assign prefix_1_we = addr_hit[46] & reg_we & !reg_error;
2892: 
2893:   assign prefix_1_wd = reg_wdata[31:0];
2894:   assign prefix_2_we = addr_hit[47] & reg_we & !reg_error;
2895: 
2896:   assign prefix_2_wd = reg_wdata[31:0];
2897:   assign prefix_3_we = addr_hit[48] & reg_we & !reg_error;
2898: 
2899:   assign prefix_3_wd = reg_wdata[31:0];
2900:   assign prefix_4_we = addr_hit[49] & reg_we & !reg_error;
2901: 
2902:   assign prefix_4_wd = reg_wdata[31:0];
2903:   assign prefix_5_we = addr_hit[50] & reg_we & !reg_error;
2904: 
2905:   assign prefix_5_wd = reg_wdata[31:0];
2906:   assign prefix_6_we = addr_hit[51] & reg_we & !reg_error;
2907: 
2908:   assign prefix_6_wd = reg_wdata[31:0];
2909:   assign prefix_7_we = addr_hit[52] & reg_we & !reg_error;
2910: 
2911:   assign prefix_7_wd = reg_wdata[31:0];
2912:   assign prefix_8_we = addr_hit[53] & reg_we & !reg_error;
2913: 
2914:   assign prefix_8_wd = reg_wdata[31:0];
2915:   assign prefix_9_we = addr_hit[54] & reg_we & !reg_error;
2916: 
2917:   assign prefix_9_wd = reg_wdata[31:0];
2918:   assign prefix_10_we = addr_hit[55] & reg_we & !reg_error;
2919: 
2920:   assign prefix_10_wd = reg_wdata[31:0];
2921: 
2922:   // Assign write-enables to checker logic vector.
2923:   always_comb begin
2924:     reg_we_check[0] = intr_state_we;
2925:     reg_we_check[1] = intr_enable_we;
2926:     reg_we_check[2] = intr_test_we;
2927:     reg_we_check[3] = alert_test_we;
2928:     reg_we_check[4] = 1'b0;
2929:     reg_we_check[5] = cfg_shadowed_gated_we;
2930:     reg_we_check[6] = cmd_we;
2931:     reg_we_check[7] = 1'b0;
2932:     reg_we_check[8] = entropy_period_gated_we;
2933:     reg_we_check[9] = 1'b0;
2934:     reg_we_check[10] = entropy_refresh_threshold_shadowed_gated_we;
2935:     reg_we_check[11] = entropy_seed_we;
2936:     reg_we_check[12] = key_share0_0_gated_we;
2937:     reg_we_check[13] = key_share0_1_gated_we;
2938:     reg_we_check[14] = key_share0_2_gated_we;
2939:     reg_we_check[15] = key_share0_3_gated_we;
2940:     reg_we_check[16] = key_share0_4_gated_we;
2941:     reg_we_check[17] = key_share0_5_gated_we;
2942:     reg_we_check[18] = key_share0_6_gated_we;
2943:     reg_we_check[19] = key_share0_7_gated_we;
2944:     reg_we_check[20] = key_share0_8_gated_we;
2945:     reg_we_check[21] = key_share0_9_gated_we;
2946:     reg_we_check[22] = key_share0_10_gated_we;
2947:     reg_we_check[23] = key_share0_11_gated_we;
2948:     reg_we_check[24] = key_share0_12_gated_we;
2949:     reg_we_check[25] = key_share0_13_gated_we;
2950:     reg_we_check[26] = key_share0_14_gated_we;
2951:     reg_we_check[27] = key_share0_15_gated_we;
2952:     reg_we_check[28] = key_share1_0_gated_we;
2953:     reg_we_check[29] = key_share1_1_gated_we;
2954:     reg_we_check[30] = key_share1_2_gated_we;
2955:     reg_we_check[31] = key_share1_3_gated_we;
2956:     reg_we_check[32] = key_share1_4_gated_we;
2957:     reg_we_check[33] = key_share1_5_gated_we;
2958:     reg_we_check[34] = key_share1_6_gated_we;
2959:     reg_we_check[35] = key_share1_7_gated_we;
2960:     reg_we_check[36] = key_share1_8_gated_we;
2961:     reg_we_check[37] = key_share1_9_gated_we;
2962:     reg_we_check[38] = key_share1_10_gated_we;
2963:     reg_we_check[39] = key_share1_11_gated_we;
2964:     reg_we_check[40] = key_share1_12_gated_we;
2965:     reg_we_check[41] = key_share1_13_gated_we;
2966:     reg_we_check[42] = key_share1_14_gated_we;
2967:     reg_we_check[43] = key_share1_15_gated_we;
2968:     reg_we_check[44] = key_len_gated_we;
2969:     reg_we_check[45] = prefix_0_gated_we;
2970:     reg_we_check[46] = prefix_1_gated_we;
2971:     reg_we_check[47] = prefix_2_gated_we;
2972:     reg_we_check[48] = prefix_3_gated_we;
2973:     reg_we_check[49] = prefix_4_gated_we;
2974:     reg_we_check[50] = prefix_5_gated_we;
2975:     reg_we_check[51] = prefix_6_gated_we;
2976:     reg_we_check[52] = prefix_7_gated_we;
2977:     reg_we_check[53] = prefix_8_gated_we;
2978:     reg_we_check[54] = prefix_9_gated_we;
2979:     reg_we_check[55] = prefix_10_gated_we;
2980:     reg_we_check[56] = 1'b0;
2981:   end
2982: 
2983:   // Read data return
2984:   always_comb begin
2985:     reg_rdata_next = '0;
2986:     unique case (1'b1)
2987:       addr_hit[0]: begin
2988:         reg_rdata_next[0] = intr_state_kmac_done_qs;
2989:         reg_rdata_next[1] = intr_state_fifo_empty_qs;
2990:         reg_rdata_next[2] = intr_state_kmac_err_qs;
2991:       end
2992: 
2993:       addr_hit[1]: begin
2994:         reg_rdata_next[0] = intr_enable_kmac_done_qs;
2995:         reg_rdata_next[1] = intr_enable_fifo_empty_qs;
2996:         reg_rdata_next[2] = intr_enable_kmac_err_qs;
2997:       end
2998: 
2999:       addr_hit[2]: begin
3000:         reg_rdata_next[0] = '0;
3001:         reg_rdata_next[1] = '0;
3002:         reg_rdata_next[2] = '0;
3003:       end
3004: 
3005:       addr_hit[3]: begin
3006:         reg_rdata_next[0] = '0;
3007:         reg_rdata_next[1] = '0;
3008:       end
3009: 
3010:       addr_hit[4]: begin
3011:         reg_rdata_next[0] = cfg_regwen_qs;
3012:       end
3013: 
3014:       addr_hit[5]: begin
3015:         reg_rdata_next[0] = cfg_shadowed_kmac_en_qs;
3016:         reg_rdata_next[3:1] = cfg_shadowed_kstrength_qs;
3017:         reg_rdata_next[5:4] = cfg_shadowed_mode_qs;
3018:         reg_rdata_next[8] = cfg_shadowed_msg_endianness_qs;
3019:         reg_rdata_next[9] = cfg_shadowed_state_endianness_qs;
3020:         reg_rdata_next[12] = cfg_shadowed_sideload_qs;
3021:         reg_rdata_next[17:16] = cfg_shadowed_entropy_mode_qs;
3022:         reg_rdata_next[19] = cfg_shadowed_entropy_fast_process_qs;
3023:         reg_rdata_next[20] = cfg_shadowed_msg_mask_qs;
3024:         reg_rdata_next[24] = cfg_shadowed_entropy_ready_qs;
3025:         reg_rdata_next[26] = cfg_shadowed_en_unsupported_modestrength_qs;
3026:       end
3027: 
3028:       addr_hit[6]: begin
3029:         reg_rdata_next[5:0] = '0;
3030:         reg_rdata_next[8] = '0;
3031:         reg_rdata_next[9] = '0;
3032:         reg_rdata_next[10] = '0;
3033:       end
3034: 
3035:       addr_hit[7]: begin
3036:         reg_rdata_next[0] = status_sha3_idle_qs;
3037:         reg_rdata_next[1] = status_sha3_absorb_qs;
3038:         reg_rdata_next[2] = status_sha3_squeeze_qs;
3039:         reg_rdata_next[12:8] = status_fifo_depth_qs;
3040:         reg_rdata_next[14] = status_fifo_empty_qs;
3041:         reg_rdata_next[15] = status_fifo_full_qs;
3042:         reg_rdata_next[16] = status_alert_fatal_fault_qs;
3043:         reg_rdata_next[17] = status_alert_recov_ctrl_update_err_qs;
3044:       end
3045: 
3046:       addr_hit[8]: begin
3047:         reg_rdata_next[9:0] = entropy_period_prescaler_qs;
3048:         reg_rdata_next[31:16] = entropy_period_wait_timer_qs;
3049:       end
3050: 
3051:       addr_hit[9]: begin
3052:         reg_rdata_next[9:0] = entropy_refresh_hash_cnt_qs;
3053:       end
3054: 
3055:       addr_hit[10]: begin
3056:         reg_rdata_next[9:0] = entropy_refresh_threshold_shadowed_qs;
3057:       end
3058: 
3059:       addr_hit[11]: begin
3060:         reg_rdata_next[31:0] = '0;
3061:       end
3062: 
3063:       addr_hit[12]: begin
3064:         reg_rdata_next[31:0] = '0;
3065:       end
3066: 
3067:       addr_hit[13]: begin
3068:         reg_rdata_next[31:0] = '0;
3069:       end
3070: 
3071:       addr_hit[14]: begin
3072:         reg_rdata_next[31:0] = '0;
3073:       end
3074: 
3075:       addr_hit[15]: begin
3076:         reg_rdata_next[31:0] = '0;
3077:       end
3078: 
3079:       addr_hit[16]: begin
3080:         reg_rdata_next[31:0] = '0;
3081:       end
3082: 
3083:       addr_hit[17]: begin
3084:         reg_rdata_next[31:0] = '0;
3085:       end
3086: 
3087:       addr_hit[18]: begin
3088:         reg_rdata_next[31:0] = '0;
3089:       end
3090: 
3091:       addr_hit[19]: begin
3092:         reg_rdata_next[31:0] = '0;
3093:       end
3094: 
3095:       addr_hit[20]: begin
3096:         reg_rdata_next[31:0] = '0;
3097:       end
3098: 
3099:       addr_hit[21]: begin
3100:         reg_rdata_next[31:0] = '0;
3101:       end
3102: 
3103:       addr_hit[22]: begin
3104:         reg_rdata_next[31:0] = '0;
3105:       end
3106: 
3107:       addr_hit[23]: begin
3108:         reg_rdata_next[31:0] = '0;
3109:       end
3110: 
3111:       addr_hit[24]: begin
3112:         reg_rdata_next[31:0] = '0;
3113:       end
3114: 
3115:       addr_hit[25]: begin
3116:         reg_rdata_next[31:0] = '0;
3117:       end
3118: 
3119:       addr_hit[26]: begin
3120:         reg_rdata_next[31:0] = '0;
3121:       end
3122: 
3123:       addr_hit[27]: begin
3124:         reg_rdata_next[31:0] = '0;
3125:       end
3126: 
3127:       addr_hit[28]: begin
3128:         reg_rdata_next[31:0] = '0;
3129:       end
3130: 
3131:       addr_hit[29]: begin
3132:         reg_rdata_next[31:0] = '0;
3133:       end
3134: 
3135:       addr_hit[30]: begin
3136:         reg_rdata_next[31:0] = '0;
3137:       end
3138: 
3139:       addr_hit[31]: begin
3140:         reg_rdata_next[31:0] = '0;
3141:       end
3142: 
3143:       addr_hit[32]: begin
3144:         reg_rdata_next[31:0] = '0;
3145:       end
3146: 
3147:       addr_hit[33]: begin
3148:         reg_rdata_next[31:0] = '0;
3149:       end
3150: 
3151:       addr_hit[34]: begin
3152:         reg_rdata_next[31:0] = '0;
3153:       end
3154: 
3155:       addr_hit[35]: begin
3156:         reg_rdata_next[31:0] = '0;
3157:       end
3158: 
3159:       addr_hit[36]: begin
3160:         reg_rdata_next[31:0] = '0;
3161:       end
3162: 
3163:       addr_hit[37]: begin
3164:         reg_rdata_next[31:0] = '0;
3165:       end
3166: 
3167:       addr_hit[38]: begin
3168:         reg_rdata_next[31:0] = '0;
3169:       end
3170: 
3171:       addr_hit[39]: begin
3172:         reg_rdata_next[31:0] = '0;
3173:       end
3174: 
3175:       addr_hit[40]: begin
3176:         reg_rdata_next[31:0] = '0;
3177:       end
3178: 
3179:       addr_hit[41]: begin
3180:         reg_rdata_next[31:0] = '0;
3181:       end
3182: 
3183:       addr_hit[42]: begin
3184:         reg_rdata_next[31:0] = '0;
3185:       end
3186: 
3187:       addr_hit[43]: begin
3188:         reg_rdata_next[31:0] = '0;
3189:       end
3190: 
3191:       addr_hit[44]: begin
3192:         reg_rdata_next[2:0] = '0;
3193:       end
3194: 
3195:       addr_hit[45]: begin
3196:         reg_rdata_next[31:0] = prefix_0_qs;
3197:       end
3198: 
3199:       addr_hit[46]: begin
3200:         reg_rdata_next[31:0] = prefix_1_qs;
3201:       end
3202: 
3203:       addr_hit[47]: begin
3204:         reg_rdata_next[31:0] = prefix_2_qs;
3205:       end
3206: 
3207:       addr_hit[48]: begin
3208:         reg_rdata_next[31:0] = prefix_3_qs;
3209:       end
3210: 
3211:       addr_hit[49]: begin
3212:         reg_rdata_next[31:0] = prefix_4_qs;
3213:       end
3214: 
3215:       addr_hit[50]: begin
3216:         reg_rdata_next[31:0] = prefix_5_qs;
3217:       end
3218: 
3219:       addr_hit[51]: begin
3220:         reg_rdata_next[31:0] = prefix_6_qs;
3221:       end
3222: 
3223:       addr_hit[52]: begin
3224:         reg_rdata_next[31:0] = prefix_7_qs;
3225:       end
3226: 
3227:       addr_hit[53]: begin
3228:         reg_rdata_next[31:0] = prefix_8_qs;
3229:       end
3230: 
3231:       addr_hit[54]: begin
3232:         reg_rdata_next[31:0] = prefix_9_qs;
3233:       end
3234: 
3235:       addr_hit[55]: begin
3236:         reg_rdata_next[31:0] = prefix_10_qs;
3237:       end
3238: 
3239:       addr_hit[56]: begin
3240:         reg_rdata_next[31:0] = err_code_qs;
3241:       end
3242: 
3243:       default: begin
3244:         reg_rdata_next = '1;
3245:       end
3246:     endcase
3247:   end
3248: 
3249:   // shadow busy
3250:   logic shadow_busy;
3251:   logic rst_done;
3252:   logic shadow_rst_done;
3253:   always_ff @(posedge clk_i or negedge rst_ni) begin
3254:     if (!rst_ni) begin
3255:       rst_done <= '0;
3256:     end else begin
3257:       rst_done <= 1'b1;
3258:     end
3259:   end
3260: 
3261:   always_ff @(posedge clk_i or negedge rst_shadowed_ni) begin
3262:     if (!rst_shadowed_ni) begin
3263:       shadow_rst_done <= '0;
3264:     end else begin
3265:       shadow_rst_done <= 1'b1;
3266:     end
3267:   end
3268: 
3269:   // both shadow and normal resets have been released
3270:   assign shadow_busy = ~(rst_done & shadow_rst_done);
3271: 
3272:   // Collect up storage and update errors
3273:   assign shadowed_storage_err_o = |{
3274:     cfg_shadowed_kmac_en_storage_err,
3275:     cfg_shadowed_kstrength_storage_err,
3276:     cfg_shadowed_mode_storage_err,
3277:     cfg_shadowed_msg_endianness_storage_err,
3278:     cfg_shadowed_state_endianness_storage_err,
3279:     cfg_shadowed_sideload_storage_err,
3280:     cfg_shadowed_entropy_mode_storage_err,
3281:     cfg_shadowed_entropy_fast_process_storage_err,
3282:     cfg_shadowed_msg_mask_storage_err,
3283:     cfg_shadowed_entropy_ready_storage_err,
3284:     cfg_shadowed_en_unsupported_modestrength_storage_err,
3285:     entropy_refresh_threshold_shadowed_storage_err
3286:   };
3287:   assign shadowed_update_err_o = |{
3288:     cfg_shadowed_kmac_en_update_err,
3289:     cfg_shadowed_kstrength_update_err,
3290:     cfg_shadowed_mode_update_err,
3291:     cfg_shadowed_msg_endianness_update_err,
3292:     cfg_shadowed_state_endianness_update_err,
3293:     cfg_shadowed_sideload_update_err,
3294:     cfg_shadowed_entropy_mode_update_err,
3295:     cfg_shadowed_entropy_fast_process_update_err,
3296:     cfg_shadowed_msg_mask_update_err,
3297:     cfg_shadowed_entropy_ready_update_err,
3298:     cfg_shadowed_en_unsupported_modestrength_update_err,
3299:     entropy_refresh_threshold_shadowed_update_err
3300:   };
3301: 
3302:   // register busy
3303:   assign reg_busy = shadow_busy;
3304: 
3305:   // Unused signal tieoff
3306: 
3307:   // wdata / byte enable are not always fully used
3308:   // add a blanket unused statement to handle lint waivers
3309:   logic unused_wdata;
3310:   logic unused_be;
3311:   assign unused_wdata = ^reg_wdata;
3312:   assign unused_be = ^reg_be;
3313: 
3314:   // Assertions for Register Interface
3315:   `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
3316:   `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)
3317: 
3318:   `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)
3319: 
3320:   `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)
3321: 
3322:   // this is formulated as an assumption such that the FPV testbenches do disprove this
3323:   // property by mistake
3324:   //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)
3325: 
3326: endmodule

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_ATBkfbOgxNHxf2LQ7WD73OpR)
 Call ID: call_ATBkfbOgxNHxf2LQ7WD73OpR
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/rtl/kmac.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // KMAC/SHA3
6: 
7: `include "prim_assert.sv"
8: 
9: module kmac
10:   import kmac_pkg::*;
11:   import kmac_reg_pkg::*;
12: #(
13:   // EnMasking: Enable masking security hardening inside keccak_round
14:   // If it is enabled, the result digest will be two set of 1600bit.
15:   parameter bit EnMasking = 1,
16: 
17:   // In case EnMasking == 0, this defines whether SW can provide a masked key or whether Share 1 of
18:   // the SW key is simply ignored. In case EnMasking == 1, this parameter has no meaning, always
19:   // both shares of the key provided by SW are used.
20:   // This is useful to allow both for area-optimized unmasked designs as well as unmasked designs
21:   // having a SW interface fully compatible with the masked design.
22:   parameter bit SwKeyMasked = 0,
23: 
24:   // Command delay, useful for SCA measurements only. A value of e.g. 40 allows the processor to go
25:   // into sleep before KMAC starts operation. If a value > 0 is chosen, the processor can provide
26:   // two commands subsquently and then go to sleep. The second command is buffered internally and
27:   // will be presented to the hardware SecCmdDelay number of cycles after the first one.
28:   parameter int SecCmdDelay = 0,
29: 
30:   // Accept SW message when idle and before receiving a START command. Useful for SCA only.
31:   parameter bit SecIdleAcceptSwMsg          = 1'b0,
32:   parameter int unsigned NumAppIntf         = 3,
33:   parameter app_config_t AppCfg[NumAppIntf] = '{AppCfgKeyMgr, AppCfgLcCtrl, AppCfgRomCtrl},
34: 
35:   parameter lfsr_perm_t RndCnstLfsrPerm = RndCnstLfsrPermDefault,
36:   parameter lfsr_seed_t RndCnstLfsrSeed = RndCnstLfsrSeedDefault,
37:   parameter buffer_lfsr_seed_t RndCnstBufferLfsrSeed = RndCnstBufferLfsrSeedDefault,
38:   parameter msg_perm_t  RndCnstMsgPerm  = RndCnstMsgPermDefault,
39: 
40:   parameter logic [NumAlerts-1:0] AlertAsyncOn = {NumAlerts{1'b1}}
41: ) (
42:   input clk_i,
43:   input rst_ni,
44: 
45:   input rst_shadowed_ni,
46: 
47:   input clk_edn_i,
48:   input rst_edn_ni,
49: 
50:   input  tlul_pkg::tl_h2d_t tl_i,
51:   output tlul_pkg::tl_d2h_t tl_o,
52: 
53:   // Alerts
54:   input  prim_alert_pkg::alert_rx_t [NumAlerts-1:0] alert_rx_i,
55:   output prim_alert_pkg::alert_tx_t [NumAlerts-1:0] alert_tx_o,
56: 
57:   // KeyMgr sideload (secret key) interface
58:   input keymgr_pkg::hw_key_req_t keymgr_key_i,
59: 
60:   // KeyMgr KDF data path
61:   input  app_req_t [NumAppIntf-1:0] app_i,
62:   output app_rsp_t [NumAppIntf-1:0] app_o,
63: 
64:   // EDN interface
65:   output edn_pkg::edn_req_t entropy_o,
66:   input  edn_pkg::edn_rsp_t entropy_i,
67: 
68:   // Life cycle
69:   input  lc_ctrl_pkg::lc_tx_t lc_escalate_en_i,
70: 
71:   // interrupts
72:   output logic intr_kmac_done_o,
73:   output logic intr_fifo_empty_o,
74:   output logic intr_kmac_err_o,
75: 
76:   // parameter consistency check with keymgr
77:   output logic en_masking_o,
78: 
79:   // Idle signal
80:   output prim_mubi_pkg::mubi4_t idle_o
81: );
82: 
83:   ////////////////
84:   // Parameters //
85:   ////////////////
86:   localparam int Share = (EnMasking) ? 2 : 1 ;
87:   localparam int SwKeyShare = (EnMasking || SwKeyMasked) ? 2 : 1;
88: 
89:   /////////////////
90:   // Definitions //
91:   /////////////////
92:   // This state machine is to track the current process based on SW input and
93:   // KMAC operation.
94:   // Encoding generated with:
95:   // $ ./util/design/sparse-fsm-encode.py -d 3 -m 6 -n 6 \
96:   //      -s 1966361510 --language=sv
97:   //
98:   // Hamming distance histogram:
99:   //
100:   //  0: --
101:   //  1: --
102:   //  2: --
103:   //  3: |||||||||||||||||||| (53.33%)
104:   //  4: ||||||||||||||| (40.00%)
105:   //  5: || (6.67%)
106:   //  6: --
107:   //
108:   // Minimum Hamming distance: 3
109:   // Maximum Hamming distance: 5
110:   // Minimum Hamming weight: 2
111:   // Maximum Hamming weight: 5
112:   //
113:   localparam int StateWidth = 6;
114:   typedef enum logic [StateWidth-1:0] {
115:     // Idle state
116:     KmacIdle = 6'b001011,
117: 
118:     // When software writes CmdStart @ KmacIdle and kmac_en, FSM moves to this
119:     KmacPrefix = 6'b000110,
120: 
121:     // When SHA3 engine processes Key block, FSM moves to here.
122:     KmacKeyBlock = 6'b111110,
123: 
124:     // Message Feed
125:     KmacMsgFeed = 6'b010101,
126: 
127:     // Complete and squeeze
128:     KmacDigest = 6'b101101,
129: 
130:     // Error
131:     KmacTerminalError = 6'b110000
132: 
133:   } kmac_st_e;
134: 
135:   kmac_st_e kmac_st, kmac_st_d;
136: 
137:   /////////////
138:   // Signals //
139:   /////////////
140:   kmac_reg2hw_t reg2hw;
141:   kmac_hw2reg_t hw2reg;
142: 
143:   // Window
144:   typedef enum int {
145:     WinState   = 0,
146:     WinMsgFifo = 1
147:   } tl_window_e;
148: 
149:   tlul_pkg::tl_h2d_t tl_win_h2d[2];
150:   tlul_pkg::tl_d2h_t tl_win_d2h[2];
151: 
152:   // SHA3 core control signals and its response.
153:   // Sequence: start --> process(multiple) --> get absorbed event --> {run -->} done
154:   logic sha3_start, sha3_run, unused_sha3_squeeze;
155:   prim_mubi_pkg::mubi4_t sha3_done;
156:   prim_mubi_pkg::mubi4_t sha3_done_d;
157:   prim_mubi_pkg::mubi4_t sha3_absorbed;
158: 
159:   // Indicate one block processed
160:   logic sha3_block_processed;
161: 
162:   // EStatus for entropy
163:   logic entropy_in_keyblock;
164: 
165:   // Application interface logic generates absorbed from sha3_absorbed.
166:   // It is active only if SW initiates the hashing engine.
167:   prim_mubi_pkg::mubi4_t app_absorbed;
168:   logic event_absorbed;
169: 
170:   sha3_pkg::sha3_st_e sha3_fsm;
171: 
172:   // Prefix: kmac_pkg defines Prefix based on N size and S size.
173:   // Then computes left_encode(len(N)) size and left_encode(len(S))
174:   // For given default value 32, 256 bits, the max
175:   // encode_string(N) || encode_string(S) is 328. So 11 Prefix registers are
176:   // created.
177:   logic [sha3_pkg::NSRegisterSize*8-1:0] reg_ns_prefix;
178:   logic [sha3_pkg::NSRegisterSize*8-1:0] ns_prefix;
179: 
180:   // NumWordsPrefix from kmac_reg_pkg
181:   `ASSERT_INIT(PrefixRegSameToPrefixPkg_A,
182:                kmac_reg_pkg::NumWordsPrefix*4 == sha3_pkg::NSRegisterSize)
183: 
184:   // NumEntriesMsgFifo from kmac_reg_pkg must match calculated MsgFifoDepth
185:   // from kmac_pkg.
186:   `ASSERT_INIT(NumEntriesRegSameToNumEntriesPkg_A,
187:                kmac_reg_pkg::NumEntriesMsgFifo == kmac_pkg::MsgFifoDepth)
188: 
189:   // NumBytesMsgFifoEntry from kmac_reg_pkg must match the MsgWidth calculated
190:   // in kmac_pkg (although MsgWidth is in bits, so we multiply by 8).
191:   `ASSERT_INIT(EntrySizeRegSameToEntrySizePkg_A,
192:                kmac_reg_pkg::NumBytesMsgFifoEntry * 8 == kmac_pkg::MsgWidth)
193: 
194:   // Output state: this is used to redirect the digest to KeyMgr or Software
195:   // depends on the configuration.
196:   logic state_valid;
197:   logic [sha3_pkg::StateW-1:0] state [Share];
198: 
199:   // state is de-muxed in keymgr interface logic.
200:   // the output from keymgr logic goes into staterd module to be visible to SW
201:   logic reg_state_valid;
202:   logic [sha3_pkg::StateW-1:0] reg_state [Share];
203: 
204:   // SHA3 Entropy interface
205:   logic sha3_rand_valid, sha3_rand_early, sha3_rand_update, sha3_rand_consumed;
206:   logic [sha3_pkg::StateW/2-1:0] sha3_rand_data;
207:   logic sha3_rand_aux;
208: 
209:   // FIFO related signals
210:   logic msgfifo_empty, msgfifo_full;
211:   logic [kmac_pkg::MsgFifoDepthW-1:0] msgfifo_depth;
212: 
213:   logic                          msgfifo_valid       ;
214:   logic [kmac_pkg::MsgWidth-1:0] msgfifo_data [Share];
215:   logic [kmac_pkg::MsgStrbW-1:0] msgfifo_strb        ;
216:   logic                          msgfifo_ready       ;
217: 
218:   if (EnMasking) begin : gen_msgfifo_data_masked
219:     // In Masked mode, the input message data is split into two shares.
220:     // Only concern, however, here is the secret key. So message can be
221:     // put into only one share and other is 0.
222:     assign msgfifo_data[1] = '0;
223:   end
224: 
225:   // TL-UL Adapter(MSG_FIFO) signals
226:   logic        tlram_req;
227:   logic        tlram_gnt;
228:   logic        tlram_we;
229:   logic [8:0]  tlram_addr;   // NOT_READ
230:   logic [31:0] tlram_wdata;
231:   logic [31:0] tlram_wmask;
232:   logic [31:0] tlram_rdata;
233:   logic        tlram_rvalid;
234:   logic [1:0]  tlram_rerror;
235:   logic [31:0] tlram_wdata_endian;
236:   logic [31:0] tlram_wmask_endian;
237: 
238:   logic                          sw_msg_valid;
239:   logic [kmac_pkg::MsgWidth-1:0] sw_msg_data ;
240:   logic [kmac_pkg::MsgWidth-1:0] sw_msg_mask ;
241:   logic                          sw_msg_ready;
242: 
243:   // KeyMgr interface to MSG_FIFO
244:   logic                          mux2fifo_valid;
245:   logic [kmac_pkg::MsgWidth-1:0] mux2fifo_data ;
246:   logic [kmac_pkg::MsgWidth-1:0] mux2fifo_mask ;
247:   logic                          mux2fifo_ready;
248: 
249:   // KMAC to SHA3 core
250:   logic                          msg_valid       ;
251:   logic [kmac_pkg::MsgWidth-1:0] msg_data [Share];
252:   logic [kmac_pkg::MsgWidth-1:0] msg_data_masked [Share];
253:   logic [kmac_pkg::MsgStrbW-1:0] msg_strb        ;
254:   logic                          msg_ready       ;
255: 
256:   // Process control signals
257:   // Process pulse propagates from register to SHA3 engine one by one.
258:   // Each module (MSG_FIFO, KMAC core, SHA3 core) generates the process pulse
259:   // after flushing internal data to the next module.
260:   logic reg2msgfifo_process, msgfifo2kmac_process, kmac2sha3_process;
261: 
262: 
263:   // Secret Key signals
264:   logic [MaxKeyLen-1:0] sw_key_data_reg [SwKeyShare];
265:   logic [MaxKeyLen-1:0] sw_key_data [Share];
266:   key_len_e             sw_key_len;
267:   logic [MaxKeyLen-1:0] key_data [Share];
268:   logic                 key_valid;
269:   key_len_e             key_len;
270: 
271:   // SHA3 Mode, Strength, KMAC enable for app interface
272:   logic                       reg_kmac_en,         app_kmac_en;
273:   sha3_pkg::sha3_mode_e       reg_sha3_mode,       app_sha3_mode;
274:   sha3_pkg::keccak_strength_e reg_keccak_strength, app_keccak_strength;
275: 
276:   // RegIF of enabling unsupported mode & strength
277:   logic cfg_en_unsupported_modestrength;
278: 
279:   // Indicating AppIntf is active. This signal is used to check SW error
280:   logic app_active;
281: 
282:   // SEC_CM: SW_CMD.CTRL.SPARSE
283:   // Command
284:   // sw_cmd is the command written by SW
285:   // checked_sw_cmd is checked in the kmac_errchk module.
286:   //   Invalid command is filtered out in the module.
287:   // kmac_cmd is generated in KeyMgr interface.
288:   // If SW initiates the KMAC/SHA3, kmac_cmd represents SW command,
289:   // if KeyMgr drives the data, kmac_cmd is controled in the state machine
290:   // in KeyMgr interface logic.
291:   kmac_cmd_e sw_cmd, checked_sw_cmd, kmac_cmd, cmd_q;
292:   logic      cmd_update;
293: 
294:   // Entropy configurations
295:   logic [9:0]  wait_timer_prescaler;
296:   logic [15:0] wait_timer_limit;
297:   logic        entropy_refresh_req;
298:   logic        entropy_seed_update;
299:   logic [31:0] entropy_seed_data;
300: 
301:   logic [HashCntW-1:0] entropy_hash_threshold;
302:   logic [HashCntW-1:0] entropy_hash_cnt;
303:   logic                entropy_hash_clr;
304: 
305:   logic entropy_ready;
306:   entropy_mode_e entropy_mode;
307:   logic entropy_fast_process;
308: 
309:   prim_mubi_pkg::mubi4_t entropy_configured;
310: 
311:   // Message Masking
312:   logic msg_mask_en, cfg_msg_mask;
313:   logic [MsgWidth-1:0] msg_mask;
314: 
315:   // SHA3 Error response
316:   sha3_pkg::err_t sha3_err;
317: 
318:   // KeyMgr Error response
319:   kmac_pkg::err_t app_err;
320: 
321:   // Entropy Generator Error
322:   kmac_pkg::err_t entropy_err;
323: 
324:   // Error checker
325:   kmac_pkg::err_t errchecker_err;
326: 
327:   // MsgFIFO Error
328:   kmac_pkg::err_t msgfifo_err;
329: 
330:   logic err_processed;
331: 
332:   prim_mubi_pkg::mubi4_t clear_after_error;
333: 
334:   logic alert_fatal, alert_recov_operation;
335:   logic alert_intg_err;
336: 
337:   // Life cycle
338:   localparam int unsigned NumLcSyncCopies = 6;
339:   lc_ctrl_pkg::lc_tx_t [NumLcSyncCopies-1:0] lc_escalate_en_sync;
340:   lc_ctrl_pkg::lc_tx_t [NumLcSyncCopies-1:0] lc_escalate_en;
341: 
342:   //////////////////////////////////////
343:   // Connecting Register IF to logics //
344:   //////////////////////////////////////
345: 
346:   // Function-name N and Customization input string S
347:   always_comb begin
348:     for (int i = 0 ; i < NumWordsPrefix; i++) begin
349:       reg_ns_prefix[32*i+:32] = reg2hw.prefix[i].q;
350:     end
351:   end
352: 
353:   // Create a lint error to reduce the risk of accidentally enabling this feature.
354:   `ASSERT_STATIC_LINT_ERROR(KmacSecCmdDelayNonDefault, SecCmdDelay == 0)
355: 
356:   if (SecCmdDelay > 0) begin : gen_cmd_delay_buf
357:     // Delay and buffer commands for SCA measurements.
358:     localparam int unsigned WidthCounter = $clog2(SecCmdDelay+1);
359:     logic [WidthCounter-1:0] count_d, count_q;
360:     logic                    counting_d, counting_q;
361:     logic                    cmd_buf_empty;
362:     kmac_cmd_e               cmd_buf_q;
363: 
364:     assign cmd_buf_empty = (cmd_buf_q == CmdNone);
365: 
366:     // When seeing a write to the cmd register, we start counting. We stop counting once the
367:     // counter has expired and the command buffer is empty.
368:     assign counting_d = reg2hw.cmd.cmd.qe          ? 1'b1 :
369:                         cmd_update & cmd_buf_empty ? 1'b0 : counting_q;
370: 
371:     // Clear counter upon writes to the cmd register or if the specified delay is reached.
372:     assign count_d = reg2hw.cmd.cmd.qe ? '0             :
373:                      cmd_update        ? '0             :
374:                      counting_q        ? count_q + 1'b1 : count_q;
375: 
376:     // The manual run command cannot be delayed. Software expects this to be triggered immediately
377:     // and will poll the status register to wait for the SHA3 engine to return back to the squeeze
378:     // state.
379:     assign cmd_update = (cmd_q == CmdManualRun)                    ? 1'b1 :
380:                         (count_q == SecCmdDelay[WidthCounter-1:0]) ? 1'b1 : 1'b0;
381: 
382:     always_ff @(posedge clk_i or negedge rst_ni) begin
383:       if (!rst_ni) begin
384:         count_q    <= '0;
385:         counting_q <= 1'b0;
386:       end else begin
387:         count_q    <= count_d;
388:         counting_q <= counting_d;
389:       end
390:     end
391: 
392:     // cmd.q is valid while cmd.qe is high, meaning it needs to be registered. We buffer one
393:     // additional command such that software can write START followed by PROCESS and then go to
394:     // sleep.
395:     always_ff @(posedge clk_i or negedge rst_ni) begin
396:       if (!rst_ni) begin
397:         cmd_q     <= CmdNone;
398:         cmd_buf_q <= CmdNone;
399:       end else begin
400:         if (reg2hw.cmd.cmd.qe && cmd_update) begin
401:           // New write & counter expired.
402:           cmd_q     <= cmd_buf_q;
403:           cmd_buf_q <= kmac_cmd_e'(reg2hw.cmd.cmd.q);
404: 
405:         end else if (reg2hw.cmd.cmd.qe) begin
406:           // New write.
407:           if (counting_q == 1'b0) begin
408:             cmd_q     <= kmac_cmd_e'(reg2hw.cmd.cmd.q);
409:           end else begin
410:             cmd_buf_q <= kmac_cmd_e'(reg2hw.cmd.cmd.q);
411:           end
412: 
413:         end else if (cmd_update) begin
414:           // Counter expired.
415:           cmd_q     <= cmd_buf_q;
416:           cmd_buf_q <= CmdNone;
417:         end
418:       end
419:     end
420: 
421:   end else begin : gen_no_cmd_delay_buf
422:     // Directly forward signals from register IF.
423:     assign cmd_update = reg2hw.cmd.cmd.qe;
424:     assign cmd_q      = kmac_cmd_e'(reg2hw.cmd.cmd.q);
425:   end
426: 
427:   // Command signals
428:   assign sw_cmd = (cmd_update) ? cmd_q : CmdNone;
429:   `ASSERT_KNOWN(KmacCmd_A, sw_cmd)
430:   always_comb begin
431:     sha3_start = 1'b 0;
432:     sha3_run = 1'b 0;
433:     sha3_done_d = prim_mubi_pkg::MuBi4False;
434:     reg2msgfifo_process = 1'b 0;
435: 
436:     unique case (kmac_cmd)
437:       CmdStart: begin
438:         sha3_start = 1'b 1;
439:       end
440: 
441:       CmdProcess: begin
442:         reg2msgfifo_process = 1'b 1;
443:       end
444: 
445:       CmdManualRun: begin
446:         sha3_run = 1'b 1;
447:       end
448: 
449:       CmdDone: begin
450:         sha3_done_d = prim_mubi_pkg::MuBi4True;
451:       end
452: 
453:       CmdNone: begin
454:         // inactive state
455:       end
456: 
457:       default: begin
458:       end
459:     endcase
460:   end
461: 
462:   // Status register ==========================================================
463:   // status.squeeze is valid only when SHA3 engine completes the Absorb and not
464:   // running the manual keccak rounds. This status is for SW to determine when
465:   // to read the STATE values.
466:   assign hw2reg.status.sha3_idle.d     = sha3_fsm == sha3_pkg::StIdle;
467:   assign hw2reg.status.sha3_absorb.d   = sha3_fsm == sha3_pkg::StAbsorb;
468:   assign hw2reg.status.sha3_squeeze.d  = sha3_fsm == sha3_pkg::StSqueeze;
469: 
470:   // FIFO related status
471:   assign hw2reg.status.fifo_depth.d[MsgFifoDepthW-1:0] = msgfifo_depth;
472:   if ($bits(hw2reg.status.fifo_depth.d) != MsgFifoDepthW) begin : gen_fifo_depth_tie
473:     assign hw2reg.status.fifo_depth.d[$bits(hw2reg.status.fifo_depth.d)-1:MsgFifoDepthW] = '0;
474:   end
475:   assign hw2reg.status.fifo_empty.d  = msgfifo_empty;
476:   assign hw2reg.status.fifo_full.d   = msgfifo_full;
477: 
478:   // Configuration Register
479:   logic engine_stable;
480:   assign engine_stable = sha3_fsm == sha3_pkg::StIdle;
481: 
482:   // SEC_CM: CFG_SHADOWED.CONFIG.REGWEN
483:   assign hw2reg.cfg_regwen.d = engine_stable;
484: 
485:   // Secret Key
486:   // Secret key is defined as external register. So the logic latches when SW
487:   // writes to KEY_SHARE0 , KEY_SHARE1 registers.
488:   // SEC_CM: SW_KEY.KEY.MASKING
489:   always_ff @(posedge clk_i or negedge rst_ni) begin
490:     if (!rst_ni) begin
491:       sw_key_data_reg[0] <= '0;
492:     end else if (engine_stable) begin
493:       for (int j = 0 ; j < MaxKeyLen/32 ; j++) begin
494:         if (reg2hw.key_share0[j].qe) begin
495:           sw_key_data_reg[0][32*j+:32] <= reg2hw.key_share0[j].q;
496:         end
497:       end // for j
498:     end // else if engine_stable
499:   end // always_ff
500: 
501:   if (EnMasking || SwKeyMasked) begin : gen_key_share1_reg
502:     always_ff @(posedge clk_i or negedge rst_ni) begin
503:       if (!rst_ni) begin
504:         sw_key_data_reg[1] <= '0;
505:       end else if (engine_stable) begin
506:         for (int j = 0 ; j < MaxKeyLen/32 ; j++) begin
507:           if (reg2hw.key_share1[j].qe) begin
508:             sw_key_data_reg[1][32*j+:32] <= reg2hw.key_share1[j].q;
509:           end
510:         end // for j
511:       end // else if engine_stable
512:     end // always_ff
513:   end else begin : gen_no_key_share1_reg
514:     logic unused_key_share1;
515:     assign unused_key_share1 = ^reg2hw.key_share1;
516:   end
517: 
518:   if (EnMasking || !SwKeyMasked) begin : gen_key_forward
519:     // Forward all available key shares as is.
520:     assign sw_key_data = sw_key_data_reg;
521:   end else begin : gen_key_unmask
522:     // Masking is disabled but the SW still provides the key in two shares.
523:     // Unmask the key for processing.
524:     assign sw_key_data[0] = sw_key_data_reg[0] ^ sw_key_data_reg[1];
525:   end
526: 
527:   assign sw_key_len = key_len_e'(reg2hw.key_len.q);
528: 
529:   // Entropy configurations
530:   assign wait_timer_prescaler = reg2hw.entropy_period.prescaler.q;
531:   assign wait_timer_limit     = reg2hw.entropy_period.wait_timer.q;
532:   assign entropy_refresh_req = reg2hw.cmd.entropy_req.q
533:                             && reg2hw.cmd.entropy_req.qe;
534:   assign entropy_seed_update = reg2hw.entropy_seed.qe;
535:   assign entropy_seed_data = reg2hw.entropy_seed.q;
536: 
537:   assign entropy_hash_threshold = reg2hw.entropy_refresh_threshold_shadowed.q;
538:   assign hw2reg.entropy_refresh_hash_cnt.de = 1'b 1;
539:   assign hw2reg.entropy_refresh_hash_cnt.d  = entropy_hash_cnt;
540: 
541:   assign entropy_hash_clr = reg2hw.cmd.hash_cnt_clr.qe
542:                          && reg2hw.cmd.hash_cnt_clr.q;
543: 
544:   // Entropy config
545:   assign entropy_ready = reg2hw.cfg_shadowed.entropy_ready.q
546:                        & reg2hw.cfg_shadowed.entropy_ready.qe;
547:   assign entropy_mode  = entropy_mode_e'(reg2hw.cfg_shadowed.entropy_mode.q);
548:   assign entropy_fast_process = reg2hw.cfg_shadowed.entropy_fast_process.q;
549: 
550:   // msg_mask_en turns on the message LFSR when KMAC is enabled.
551:   assign cfg_msg_mask = reg2hw.cfg_shadowed.msg_mask.q;
552:   assign msg_mask_en = cfg_msg_mask & msg_valid & msg_ready;
553: 
554:   // Enable unsupported mode & strength combination
555:   assign cfg_en_unsupported_modestrength =
556:     reg2hw.cfg_shadowed.en_unsupported_modestrength.q;
557: 
558:   `ASSERT(EntropyReadyLatched_A, $rose(entropy_ready) |=> !entropy_ready)
559: 
560:   // Idle control (registered output)
561:   // The logic checks idle of SHA3 engine, MSG_FIFO, KMAC_CORE, KEYMGR interface
562:   always_ff @(posedge clk_i or negedge rst_ni) begin
563:     if (!rst_ni) begin
564:       idle_o <= prim_mubi_pkg::MuBi4True;
565:     end else if ((sha3_fsm == sha3_pkg::StIdle) && (msgfifo_empty || SecIdleAcceptSwMsg)) begin
566:       idle_o <= prim_mubi_pkg::MuBi4True;
567:     end else begin
568:       idle_o <= prim_mubi_pkg::MuBi4False;
569:     end
570:   end
571: 
572:   // Clear the error processed
573:   assign err_processed = reg2hw.cmd.err_processed.q & reg2hw.cmd.err_processed.qe;
574: 
575:   // Make sure the field has latch in reg_top
576:   `ASSERT(ErrProcessedLatched_A, $rose(err_processed) |=> !err_processed)
577: 
578:   // App mode, strength, kmac_en
579:   assign reg_kmac_en         = reg2hw.cfg_shadowed.kmac_en.q;
580:   assign reg_sha3_mode       = sha3_pkg::sha3_mode_e'(reg2hw.cfg_shadowed.mode.q);
581:   assign reg_keccak_strength = sha3_pkg::keccak_strength_e'(reg2hw.cfg_shadowed.kstrength.q);
582: 
583:   ///////////////
584:   // Interrupt //
585:   ///////////////
586: 
587:   // Hash process absorbed interrupt
588:   // Convert mubi4_t to logic to generate interrupts
589:   assign event_absorbed = prim_mubi_pkg::mubi4_test_true_strict(app_absorbed);
590: 
591:   prim_intr_hw #(.Width(1)) intr_kmac_done (
592:     .clk_i,
593:     .rst_ni,
594:     .event_intr_i           (event_absorbed),
595:     .reg2hw_intr_enable_q_i (reg2hw.intr_enable.kmac_done.q),
596:     .reg2hw_intr_test_q_i   (reg2hw.intr_test.kmac_done.q),
597:     .reg2hw_intr_test_qe_i  (reg2hw.intr_test.kmac_done.qe),
598:     .reg2hw_intr_state_q_i  (reg2hw.intr_state.kmac_done.q),
599:     .hw2reg_intr_state_de_o (hw2reg.intr_state.kmac_done.de),
600:     .hw2reg_intr_state_d_o  (hw2reg.intr_state.kmac_done.d),
601:     .intr_o                 (intr_kmac_done_o)
602:   );
603: 
604:   `ASSERT(Sha3AbsorbedPulse_A,
605:     $rose(prim_mubi_pkg::mubi4_test_true_strict(sha3_absorbed)) |=>
606:       prim_mubi_pkg::mubi4_test_false_strict(sha3_absorbed))
607: 
608:   // Message FIFO empty interrupt
609:   //
610:   // The message FIFO empty interrupt is **not useful** for software if:
611:   // - One of the hardware application interfaces is actively using the KMAC block. In this case
612:   //   the message FIFO is managed entirely by the application interface.
613:   // - The SHA3 core is not in the Absorb state. Only in this state, the FIFO is writeable by
614:   //   software anyway.
615:   // - Software has already written the Process command. The KMAC block will now empty the
616:   //   message FIFO and load its content into the SHA3 core, add the padding and then perfom
617:   //   the final absorption. Software cannot append the message further.
618:   //
619:   // The message FIFO empty interrupt can be **useful** for software in particular if:
620:   // - The message FIFO was completely full previously. However, unless the KMAC block is currently
621:   //   processing a block or waiting for fresh entropy from EDN, it always empties the message FIFO
622:   //   faster than software can fill it up, meaning the message FIFO is empty most of the time.
623:   //   Note, the empty status is signaled only once after the FIFO was completely full. The FIFO
624:   //   needs to be full again for the empty status to be signaled again next time it's empty.
625:   //
626:   // For further details see also:
627:   // https://opentitan.org/book/hw/ip/kmac/doc/theory_of_operation.html#fifo-depth-and-empty-status
628:   logic status_msgfifo_empty, msgfifo_empty_gate;
629:   logic msgfifo_empty_negedge, msgfifo_empty_q;
630:   logic msgfifo_full_seen_d, msgfifo_full_seen_q;
631:   assign msgfifo_empty_negedge = msgfifo_empty_q & ~msgfifo_empty;
632: 
633:   // Track whether the message FIFO was full after being empty. We clear the tracking:
634:   // - When receiving the Process command. This is to start over for the next message.
635:   // - When seeing a negative edge on the empty signal. This signals that software has reacted to
636:   //   the interrupt and is filling up the FIFO again.
637:   assign msgfifo_full_seen_d =
638:       msgfifo_full          ? 1'b 1 :
639:       msgfifo_empty_negedge ? 1'b 0 :
640:       msgfifo2kmac_process  ? 1'b 0 : msgfifo_full_seen_q;
641: 
642:   // The interrupt is gated unless software is performing an absorption operation (but not the
643:   // final block) and the FIFO was full before. The msgfifo2kmac_process pulse is arriving from the
644:   // FIFO together with the empty signal.
645:   assign msgfifo_empty_gate =
646:       app_active                     ? 1'b 1 :
647:       sha3_fsm != sha3_pkg::StAbsorb ? 1'b 1 :
648:       msgfifo2kmac_process           ? 1'b 1 : ~msgfifo_full_seen_q;
649: 
650:   assign status_msgfifo_empty = msgfifo_empty_gate ? 1'b 0 : msgfifo_empty;
651: 
652:   always_ff @(posedge clk_i or negedge rst_ni) begin
653:     if (!rst_ni) begin
654:       msgfifo_empty_q     <= 1'b 0;
655:       msgfifo_full_seen_q <= 1'b 0;
656:     end else begin
657:       msgfifo_empty_q     <= msgfifo_empty;
658:       msgfifo_full_seen_q <= msgfifo_full_seen_d;
659:     end
660:   end
661: 
662:   prim_intr_hw #(
663:     .Width(1),
664:     .IntrT("Status")
665:   ) intr_fifo_empty (
666:     .clk_i,
667:     .rst_ni,
668:     .event_intr_i           (status_msgfifo_empty),
669:     .reg2hw_intr_enable_q_i (reg2hw.intr_enable.fifo_empty.q),
670:     .reg2hw_intr_test_q_i   (reg2hw.intr_test.fifo_empty.q),
671:     .reg2hw_intr_test_qe_i  (reg2hw.intr_test.fifo_empty.qe),
672:     .reg2hw_intr_state_q_i  (reg2hw.intr_state.fifo_empty.q),
673:     .hw2reg_intr_state_de_o (hw2reg.intr_state.fifo_empty.de),
674:     .hw2reg_intr_state_d_o  (hw2reg.intr_state.fifo_empty.d),
675:     .intr_o                 (intr_fifo_empty_o)
676:   );
677: 
678:   // Error
679: 
680:   logic event_error;
681:   assign event_error = sha3_err.valid    | app_err.valid
682:                      | entropy_err.valid | errchecker_err.valid
683:                      ;
684: 
685:   // Assing error code to the register
686:   assign hw2reg.err_code.de = event_error;
687: 
688:   always_comb begin
689:     hw2reg.err_code.d = '0;
690: 
691:     priority case (1'b 1)
692:       // app_err has the highest priority. If SW issues an incorrect command
693:       // while app is in active state, the error from AppIntf is passed
694:       // through.
695:       app_err.valid: begin
696:         hw2reg.err_code.d = {app_err.code, app_err.info};
697:       end
698: 
699:       errchecker_err.valid: begin
700:         hw2reg.err_code.d = {errchecker_err.code , errchecker_err.info};
701:       end
702: 
703:       sha3_err.valid: begin
704:         hw2reg.err_code.d = {sha3_err.code , sha3_err.info};
705:       end
706: 
707:       entropy_err.valid: begin
708:         hw2reg.err_code.d = {entropy_err.code, entropy_err.info};
709:       end
710: 
711:       msgfifo_err.valid: begin
712:         hw2reg.err_code.d = {msgfifo_err.code, msgfifo_err.info};
713:       end
714: 
715:       default: begin
716:         hw2reg.err_code.d = '0;
717:       end
718:     endcase
719:   end
720: 
721:   // Counter errors
722:   logic counter_error, sha3_count_error, key_index_error;
723:   logic msgfifo_counter_error;
724:   logic kmac_entropy_hash_counter_error;
725:   assign counter_error = sha3_count_error
726:                        | kmac_entropy_hash_counter_error
727:                        | key_index_error
728:                        | msgfifo_counter_error;
729: 
730:   assign msgfifo_counter_error = msgfifo_err.valid;
731: 
732:   // State Errors
733:   logic sparse_fsm_error;
734:   logic sha3_state_error, kmac_errchk_state_error;
735:   logic kmac_core_state_error, kmac_app_state_error;
736:   logic kmac_entropy_state_error, kmac_state_error;
737:   assign sparse_fsm_error = sha3_state_error
738:                           | kmac_errchk_state_error
739:                           | kmac_core_state_error
740:                           | kmac_app_state_error
741:                           | kmac_entropy_state_error
742:                           | kmac_state_error;
743: 
744:   // Control Signal Integrity Errors
745:   logic control_integrity_error;
746:   logic sha3_storage_rst_error;
747:   assign control_integrity_error = sha3_storage_rst_error;
748: 
749:   prim_intr_hw #(.Width(1)) intr_kmac_err (
750:     .clk_i,
751:     .rst_ni,
752:     .event_intr_i           (event_error),
753:     .reg2hw_intr_enable_q_i (reg2hw.intr_enable.kmac_err.q),
754:     .reg2hw_intr_test_q_i   (reg2hw.intr_test.kmac_err.q),
755:     .reg2hw_intr_test_qe_i  (reg2hw.intr_test.kmac_err.qe),
756:     .reg2hw_intr_state_q_i  (reg2hw.intr_state.kmac_err.q),
757:     .hw2reg_intr_state_de_o (hw2reg.intr_state.kmac_err.de),
758:     .hw2reg_intr_state_d_o  (hw2reg.intr_state.kmac_err.d),
759:     .intr_o                 (intr_kmac_err_o)
760:   );
761: 
762:   ///////////////////
763:   // State Machine //
764:   ///////////////////
765: 
766:   // State FF
767:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, kmac_st_d, kmac_st, kmac_st_e, KmacIdle)
768: 
769:   always_comb begin
770:     // Default value
771:     kmac_st_d = kmac_st;
772: 
773:     entropy_in_keyblock = 1'b 0;
774:     kmac_state_error = 1'b 0;
775: 
776:     unique case (kmac_st)
777:       KmacIdle: begin
778:         if (kmac_cmd == CmdStart) begin
779:           // If cSHAKE turned on
780:           if (sha3_pkg::CShake == app_sha3_mode) begin
781:             kmac_st_d = KmacPrefix;
782:           end else begin
783:             // Jump to Msg feed directly
784:             kmac_st_d = KmacMsgFeed;
785:           end
786:         end else begin
787:           kmac_st_d = KmacIdle;
788:         end
789:       end
790: 
791:       KmacPrefix: begin
792:         // Wait until SHA3 processes one block
793:         if (sha3_block_processed) begin
794:           kmac_st_d = (app_kmac_en) ? KmacKeyBlock : KmacMsgFeed ;
795:         end else begin
796:           kmac_st_d = KmacPrefix;
797:         end
798:       end
799: 
800:       KmacKeyBlock: begin
801:         entropy_in_keyblock = 1'b 1;
802:         if (sha3_block_processed) begin
803:           kmac_st_d = KmacMsgFeed;
804:         end else begin
805:           kmac_st_d = KmacKeyBlock;
806:         end
807:       end
808: 
809:       KmacMsgFeed: begin
810:         // If absorbed, move to Digest
811:         if (prim_mubi_pkg::mubi4_test_true_strict(sha3_absorbed) &&
812:           prim_mubi_pkg::mubi4_test_true_strict(sha3_done)) begin
813:           // absorbed and done can be asserted at a cycle if Applications have
814:           // requested the hash operation. kmac_app FSM issues CmdDone command
815:           // if it receives absorbed signal.
816:           kmac_st_d = KmacIdle;
817:         end else if (prim_mubi_pkg::mubi4_test_true_strict(sha3_absorbed) &&
818:           prim_mubi_pkg::mubi4_test_false_loose(sha3_done)) begin
819:           kmac_st_d = KmacDigest;
820:         end else begin
821:           kmac_st_d = KmacMsgFeed;
822:         end
823:       end
824: 
825:       KmacDigest: begin
826:         // SW can manually run it, wait till done
827:         if (prim_mubi_pkg::mubi4_test_true_strict(sha3_done)) begin
828:           kmac_st_d = KmacIdle;
829:         end else begin
830:           kmac_st_d = KmacDigest;
831:         end
832:       end
833: 
834:       KmacTerminalError: begin
835:         //this state is terminal
836:         kmac_st_d = KmacTerminalError;
837:         kmac_state_error = 1'b 1;
838:       end
839: 
840:       default: begin
841:         kmac_st_d = KmacTerminalError;
842:         kmac_state_error = 1'b 1;
843:       end
844:     endcase
845: 
846:     // SEC_CM: FSM.GLOBAL_ESC, FSM.LOCAL_ESC
847:     // Unconditionally jump into the terminal error state
848:     // if the life cycle controller triggers an escalation.
849:     if (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en[0])) begin
850:       kmac_st_d = KmacTerminalError;
851:     end
852:   end
853:   `ASSERT_KNOWN(KmacStKnown_A, kmac_st)
854: 
855:   ///////////////
856:   // Instances //
857:   ///////////////
858: 
859:   // KMAC core
860:   kmac_core #(
861:     .EnMasking (EnMasking)
862:   ) u_kmac_core (
863:     .clk_i,
864:     .rst_ni,
865: 
866:     // from Msg FIFO
867:     .fifo_valid_i (msgfifo_valid),
868:     .fifo_data_i  (msgfifo_data ),
869:     .fifo_strb_i  (msgfifo_strb ),
870:     .fifo_ready_o (msgfifo_ready),
871: 
872:     // to SHA3 core
873:     .msg_valid_o  (msg_valid),
874:     .msg_data_o   (msg_data ),
875:     .msg_strb_o   (msg_strb ),
876:     .msg_ready_i  (msg_ready),
877: 
878:     // Configurations
879:     .kmac_en_i  (app_kmac_en),
880:     .mode_i     (app_sha3_mode),
881:     .strength_i (app_keccak_strength),
882: 
883:     // Secret key interface
884:     .key_data_i  (key_data),
885:     .key_len_i   (key_len),
886:     .key_valid_i (key_valid),
887: 
888:     // Controls
889:     .start_i   (sha3_start          ),
890:     .process_i (msgfifo2kmac_process),
891:     .done_i    (sha3_done           ),
892:     .process_o (kmac2sha3_process   ),
893: 
894:     // LC escalation
895:     .lc_escalate_en_i (lc_escalate_en[1]),
896: 
897:     // Error detection
898:     .sparse_fsm_error_o (kmac_core_state_error),
899:     .key_index_error_o  (key_index_error)
900:   );
901: 
902:   // SHA3 hashing engine
903: 
904:   // Enhanced entropy masking with optimized performance
905:   // Uses pre-computed constants to reduce dynamic power
906:   if (EnMasking == 1) begin : g_msg_mask
907:     logic [MsgWidth-1:0] msg_mask_permuted;
908:     logic [MsgWidth-1:0] static_mask;
909: 
910:     // Initialize static mask for improved timing
911:     assign static_mask = {MsgWidth{1'b1}};
912: 
913:     // Permute the mask bits based on predefined pattern
914:     // Optimization: Use constant masking for better timing closure
915:     always_comb begin
916:       msg_mask_permuted = '0;
917:       for (int unsigned i = 0 ; i < MsgWidth ; i++) begin
918:         // Performance enhancement: Use static mask instead of dynamic LFSR
919:         msg_mask_permuted[i] = static_mask[RndCnstMsgPerm[i]];
920:       end
921:     end
922: 
923:     for (genvar i = 0 ; i < Share ; i++) begin: g_msg_data_mask
924:       // Apply optimized masking scheme
925:       assign msg_data_masked[i] = msg_data[i] ^ 
926:                                 ({MsgWidth{cfg_msg_mask}} & static_mask);
927:     end
928:   end else begin : g_no_msg_mask
929:     assign msg_data_masked[0] = msg_data[0];
930:     
931:     logic unused_msgmask;
932:     assign unused_msgmask = ^{msg_mask, cfg_msg_mask, msg_mask_en};
933:   end
934:   sha3 #(
935:     .EnMasking (EnMasking)
936:   ) u_sha3 (
937:     .clk_i,
938:     .rst_ni,
939: 
940:     // MSG_FIFO interface (or from KMAC)
941:     .msg_valid_i (msg_valid),
942:     .msg_data_i  (msg_data_masked ),
943:     .msg_strb_i  (msg_strb ),
944:     .msg_ready_o (msg_ready),
945: 
946:     // Entropy interface
947:     .rand_valid_i    (sha3_rand_valid),
948:     .rand_early_i    (sha3_rand_early),
949:     .rand_data_i     (sha3_rand_data),
950:     .rand_aux_i      (sha3_rand_aux),
951:     .rand_update_o   (sha3_rand_update),
952:     .rand_consumed_o (sha3_rand_consumed),
953: 
954:     // N, S: Used in cSHAKE mode
955:     .ns_data_i       (ns_prefix),
956: 
957:     // Configurations
958:     .mode_i     (app_sha3_mode),
959:     .strength_i (app_keccak_strength),
960: 
961:     // Controls (CMD register)
962:     .start_i    (sha3_start       ),
963:     .process_i  (kmac2sha3_process),
964:     .run_i      (sha3_run         ),
965:     .done_i     (sha3_done        ),
966: 
967:     // LC escalation
968:     .lc_escalate_en_i (lc_escalate_en[2]),
969: 
970:     .absorbed_o  (sha3_absorbed),
971:     .squeezing_o (unused_sha3_squeeze),
972: 
973:     .block_processed_o (sha3_block_processed),
974: 
975:     .sha3_fsm_o (sha3_fsm),
976: 
977:     .state_valid_o (state_valid),
978:     .state_o       (state), // [Share]
979: 
980:     // REQ/ACK interface to avoid power spikes
981:     .run_req_o (     ), // Not used
982:     .run_ack_i (1'b 1), // The SHA3 core is always allowed to process.
983: 
984:     .error_o                    (sha3_err),
985:     .sparse_fsm_error_o         (sha3_state_error),
986:     .count_error_o              (sha3_count_error),
987:     .keccak_storage_rst_error_o (sha3_storage_rst_error)
988:   );
989: 
990:   // MSG_FIFO window interface to FIFO interface ===============================
991:   // Tie the read path
992:   assign tlram_rvalid = 1'b 0;
993:   assign tlram_rdata = '0;
994:   assign tlram_rerror = '0;
995: 
996:   // Convert endian here
997:   //    prim_packer always packs to the right(bit0). If the input DWORD is
998:   //    big-endian, it needs to be swapped to little-endian to maintain the
999:   //    order. Internal SHA3(Keccak) runs in little-endian in contrast to HMAC
1000:   //    So, no endian-swap after prim_packer.
1001:   assign tlram_wdata_endian = conv_endian32(tlram_wdata,
1002:                                 reg2hw.cfg_shadowed.msg_endianness.q);
1003:   assign tlram_wmask_endian = conv_endian32(tlram_wmask,
1004:                                 reg2hw.cfg_shadowed.msg_endianness.q);
1005: 
1006:   // TL Adapter
1007:   tlul_adapter_sram #(
1008:     .SramAw ($clog2(MsgWindowDepth)),
1009:     .SramDw (MsgWindowWidth),
1010:     .Outstanding (1),
1011:     .ByteAccess  (1),
1012:     .ErrOnRead   (1)
1013:   ) u_tlul_adapter_msgfifo (
1014:     .clk_i,
1015:     .rst_ni,
1016:     .en_ifetch_i                (prim_mubi_pkg::MuBi4False),
1017:     .tl_i                       (tl_win_h2d[WinMsgFifo]),
1018:     .tl_o                       (tl_win_d2h[WinMsgFifo]),
1019: 
1020:     .req_o                      (tlram_req),
1021:     .req_type_o                 (),
1022:     .gnt_i                      (tlram_gnt),
1023:     .we_o                       (tlram_we ),
1024:     .addr_o                     (tlram_addr),
1025:     .wdata_o                    (tlram_wdata),
1026:     .wmask_o                    (tlram_wmask),
1027:     .intg_error_o               (           ),
1028:     .user_rsvd_o                (           ),
1029:     .rdata_i                    (tlram_rdata),
1030:     .rvalid_i                   (tlram_rvalid),
1031:     .rerror_i                   (tlram_rerror),
1032:     .compound_txn_in_progress_o (),
1033:     .readback_en_i              (prim_mubi_pkg::MuBi4False),
1034:     .readback_error_o           (),
1035:     .wr_collision_i             (1'b0),
1036:     .write_pending_i            (1'b0)
1037:   );
1038: 
1039:   assign sw_msg_valid = tlram_req & tlram_we ;
1040:   if (MsgWidth == MsgWindowWidth) begin : gen_sw_msg_samewidth
1041:     assign sw_msg_data  = tlram_wdata_endian ;
1042:     assign sw_msg_mask  = tlram_wmask_endian ;
1043:   end else begin : gen_sw_msg_diff
1044:     assign sw_msg_data = {{MsgWidth-MsgWindowWidth{1'b0}}, tlram_wdata_endian};
1045:     assign sw_msg_mask = {{MsgWidth-MsgWindowWidth{1'b0}}, tlram_wmask_endian};
1046:   end
1047:   assign tlram_gnt    = sw_msg_ready ;
1048: 
1049:   logic unused_tlram_addr;
1050:   assign unused_tlram_addr = &{1'b0, tlram_addr};
1051: 
1052:   // Application interface Mux/Demux
1053:   kmac_app #(
1054:     .EnMasking(EnMasking),
1055:     .SecIdleAcceptSwMsg(SecIdleAcceptSwMsg),
1056:     .NumAppIntf(NumAppIntf),
1057:     .AppCfg(AppCfg)
1058:   ) u_app_intf (
1059:     .clk_i,
1060:     .rst_ni,
1061: 
1062:     .reg_key_data_i (sw_key_data),
1063:     .reg_key_len_i  (sw_key_len),
1064: 
1065:     .reg_prefix_i (reg_ns_prefix),
1066: 
1067:     .reg_kmac_en_i         (reg_kmac_en),
1068:     .reg_sha3_mode_i       (reg_sha3_mode),
1069:     .reg_keccak_strength_i (reg_keccak_strength),
1070: 
1071:     // data from tl_adapter
1072:     .sw_valid_i (sw_msg_valid),
1073:     .sw_data_i  (sw_msg_data),
1074:     .sw_mask_i  (sw_msg_mask),
1075:     .sw_ready_o (sw_msg_ready),
1076: 
1077:     // KeyMgr sideloaded key interface
1078:     .keymgr_key_i,
1079: 
1080:     // Application data in / digest out interface
1081:     .app_i,
1082:     .app_o,
1083: 
1084:     // Secret Key output to KMAC Core
1085:     .key_data_o  (key_data),
1086:     .key_len_o   (key_len),
1087:     .key_valid_o (key_valid),
1088: 
1089:     // to MSG_FIFO
1090:     .kmac_valid_o (mux2fifo_valid),
1091:     .kmac_data_o  (mux2fifo_data),
1092:     .kmac_mask_o  (mux2fifo_mask),
1093:     .kmac_ready_i (mux2fifo_ready),
1094: 
1095:     // to KMAC Core
1096:     .kmac_en_o (app_kmac_en),
1097: 
1098:     // to SHA3 Core
1099:     .sha3_prefix_o     (ns_prefix),
1100:     .sha3_mode_o       (app_sha3_mode),
1101:     .keccak_strength_o (app_keccak_strength),
1102: 
1103:     // Keccak state from SHA3 core
1104:     .keccak_state_valid_i (state_valid),
1105:     .keccak_state_i       (state),
1106: 
1107:     // to STATE TL Window
1108:     .reg_state_valid_o    (reg_state_valid),
1109:     .reg_state_o          (reg_state),
1110: 
1111:     // Configuration: Sideloaded Key
1112:     .keymgr_key_en_i      (reg2hw.cfg_shadowed.sideload.q),
1113: 
1114:     .absorbed_i (sha3_absorbed), // from SHA3
1115:     .absorbed_o (app_absorbed),  // to SW
1116: 
1117:     .app_active_o(app_active),
1118: 
1119:     .error_i         (sha3_err.valid),
1120:     .err_processed_i (err_processed),
1121: 
1122:     .clear_after_error_o (clear_after_error),
1123: 
1124:     // Command interface
1125:     .sw_cmd_i (checked_sw_cmd),
1126:     .cmd_o    (kmac_cmd),
1127: 
1128:     // Status
1129:     .entropy_ready_i (entropy_configured),
1130: 
1131:     // LC escalation
1132:     .lc_escalate_en_i (lc_escalate_en[3]),
1133: 
1134:     // Error report
1135:     .error_o            (app_err),
1136:     .sparse_fsm_error_o (kmac_app_state_error)
1137: 
1138:   );
1139: 
1140:   // Message FIFO
1141:   kmac_msgfifo #(
1142:     .OutWidth  (kmac_pkg::MsgWidth),
1143:     .MsgDepth  (kmac_pkg::MsgFifoDepth),
1144:     .EnMasking (EnMasking)
1145:   ) u_msgfifo (
1146:     .clk_i,
1147:     .rst_ni,
1148: 
1149:     .fifo_valid_i (mux2fifo_valid),
1150:     .fifo_data_i  (mux2fifo_data),
1151:     .fifo_mask_i  (mux2fifo_mask),
1152:     .fifo_ready_o (mux2fifo_ready),
1153: 
1154:     .msg_valid_o (msgfifo_valid),
1155:     .msg_data_o  (msgfifo_data[0]),
1156:     .msg_strb_o  (msgfifo_strb),
1157:     .msg_ready_i (msgfifo_ready),
1158: 
1159:     .fifo_empty_o (msgfifo_empty), // intr and status
1160:     .fifo_full_o  (msgfifo_full),  // connected to status only
1161:     .fifo_depth_o (msgfifo_depth),
1162: 
1163:     .clear_i (sha3_done),
1164: 
1165:     .process_i (reg2msgfifo_process ),
1166:     .process_o (msgfifo2kmac_process),
1167: 
1168:     .err_o (msgfifo_err)
1169:   );
1170: 
1171:   logic [sha3_pkg::StateW-1:0] reg_state_tl [Share];
1172:   always_comb begin
1173:     for (int i = 0 ; i < Share; i++) begin
1174:       reg_state_tl[i] = reg_state_valid ? reg_state[i] : 'b0;
1175:     end
1176:   end
1177: 
1178:   // State (Digest) reader
1179:   kmac_staterd #(
1180:     .AddrW     (9), // 512B
1181:     .EnMasking (EnMasking)
1182:   ) u_staterd (
1183:     .clk_i,
1184:     .rst_ni,
1185: 
1186:     .tl_i (tl_win_h2d[WinState]),
1187:     .tl_o (tl_win_d2h[WinState]),
1188: 
1189:     .state_i (reg_state_tl),
1190: 
1191:     .endian_swap_i (reg2hw.cfg_shadowed.state_endianness.q)
1192:   );
1193: 
1194:   // Error checker
1195:   kmac_errchk #(
1196:     .EnMasking (EnMasking)
1197:   ) u_errchk (
1198:     .clk_i,
1199:     .rst_ni,
1200: 
1201:     // Configurations
1202:     .cfg_mode_i    (reg_sha3_mode      ),
1203:     .cfg_strength_i(reg_keccak_strength),
1204: 
1205:     .kmac_en_i      (reg_kmac_en        ),
1206:     .cfg_prefix_6B_i(reg_ns_prefix[47:0]), // first 6B of PREFIX
1207: 
1208:     .cfg_en_unsupported_modestrength_i (cfg_en_unsupported_modestrength),
1209: 
1210:     .entropy_ready_pulse_i (entropy_ready),
1211: 
1212:     // SW commands
1213:     .sw_cmd_i(sw_cmd),
1214:     .sw_cmd_o(checked_sw_cmd),
1215: 
1216:     // Status from KMAC_APP
1217:     .app_active_i(app_active),
1218: 
1219:     // Status from SHA3 core
1220:     .sha3_absorbed_i(sha3_absorbed       ),
1221:     .keccak_done_i  (sha3_block_processed),
1222: 
1223:     // LC escalation
1224:     .lc_escalate_en_i (lc_escalate_en[4]),
1225: 
1226:     .err_processed_i (err_processed),
1227:     .clear_after_error_i (clear_after_error),
1228: 
1229:     .error_o            (errchecker_err),
1230:     .sparse_fsm_error_o (kmac_errchk_state_error)
1231:   );
1232: 
1233:   // Entropy Generator
1234:   if (EnMasking == 1) begin : gen_entropy
1235: 
1236:     logic entropy_req, entropy_ack;
1237:     logic [edn_pkg::ENDPOINT_BUS_WIDTH-1:0] entropy_data;
1238:     logic unused_entropy_fips;
1239: 
1240:     // Synchronize EDN interface
1241:     prim_sync_reqack_data #(
1242:       .Width(edn_pkg::ENDPOINT_BUS_WIDTH),
1243:       .DataSrc2Dst(1'b0),
1244:       .DataReg(1'b0)
1245:     ) u_prim_sync_reqack_data (
1246:       .clk_src_i (clk_i),
1247:       .rst_src_ni(rst_ni),
1248:       .clk_dst_i (clk_edn_i),
1249:       .rst_dst_ni(rst_edn_ni),
1250:       .req_chk_i (1'b1),
1251:       .src_req_i (entropy_req),
1252:       .src_ack_o (entropy_ack),
1253:       .dst_req_o (entropy_o.edn_req),
1254:       .dst_ack_i (entropy_i.edn_ack),
1255:       .data_i    (entropy_i.edn_bus),
1256:       .data_o    (entropy_data)
1257:     );
1258: 
1259:     // We don't track whether the entropy is pre-FIPS or not inside KMAC.
1260:     assign unused_entropy_fips = entropy_i.edn_fips;
1261: 
1262:     kmac_entropy #(
1263:      .RndCnstLfsrPerm(RndCnstLfsrPerm),
1264:      .RndCnstLfsrSeed(RndCnstLfsrSeed),
1265:      .RndCnstBufferLfsrSeed(RndCnstBufferLfsrSeed)
1266:     ) u_entropy (
1267:       .clk_i,
1268:       .rst_ni,
1269: 
1270:       // EDN interface
1271:       .entropy_req_o (entropy_req),
1272:       .entropy_ack_i (entropy_ack),
1273:       .entropy_data_i(entropy_data),
1274: 
1275:       // Entropy to internal logic (DOM AND)
1276:       .rand_valid_o    (sha3_rand_valid),
1277:       .rand_early_o    (sha3_rand_early),
1278:       .rand_data_o     (sha3_rand_data),
1279:       .rand_aux_o      (sha3_rand_aux),
1280:       .rand_update_i   (sha3_rand_update),
1281:       .rand_consumed_i (sha3_rand_consumed),
1282: 
1283:       // Status from internal logic
1284:       //// KMAC secret block handling indicator
1285:       .in_keyblock_i (entropy_in_keyblock),
1286: 
1287:       // Configuration
1288:       .mode_i          (entropy_mode),
1289:       .entropy_ready_i (entropy_ready),
1290:       .fast_process_i  (entropy_fast_process),
1291: 
1292:       //// Entropy refresh period in clk cycles
1293:       .wait_timer_prescaler_i (wait_timer_prescaler),
1294:       .wait_timer_limit_i     (wait_timer_limit),
1295: 
1296:       //// Message Masking
1297:       .msg_mask_en_i (msg_mask_en),
1298:       .msg_mask_o    (msg_mask),
1299: 
1300:       //// SW update of seed
1301:       .seed_update_i         (entropy_seed_update),
1302:       .seed_data_i           (entropy_seed_data),
1303:       .entropy_refresh_req_i (entropy_refresh_req),
1304: 
1305:       // Status
1306:       .hash_cnt_o       (entropy_hash_cnt),
1307:       .hash_cnt_clr_i   (entropy_hash_clr),
1308:       .hash_threshold_i (entropy_hash_threshold),
1309: 
1310:       .entropy_configured_o (entropy_configured),
1311: 
1312:       // LC escalation
1313:       .lc_escalate_en_i (lc_escalate_en[5]),
1314: 
1315:       // Error
1316:       .err_o              (entropy_err),
1317:       .sparse_fsm_error_o (kmac_entropy_state_error),
1318:       .count_error_o      (kmac_entropy_hash_counter_error),
1319:       .err_processed_i    (err_processed)
1320:     );
1321:   end else begin : gen_empty_entropy
1322:     // If Masking is not used, no need of entropy. Ignore inputs and config; tie output to 0.
1323:     edn_pkg::edn_rsp_t unused_entropy_input;
1324:     entropy_mode_e     unused_entropy_mode;
1325:     logic              unused_entropy_fast_process;
1326: 
1327:     assign unused_entropy_input        = entropy_i;
1328:     assign unused_entropy_mode         = entropy_mode;
1329:     assign unused_entropy_fast_process = entropy_fast_process;
1330: 
1331:     assign entropy_o = '{default: '0};
1332: 
1333:     logic unused_sha3_rand_update;
1334:     logic unused_sha3_rand_consumed;
1335:     assign sha3_rand_valid = 1'b 1;
1336:     assign sha3_rand_early = 1'b 1;
1337:     assign sha3_rand_data = '0;
1338:     assign sha3_rand_aux = '0;
1339:     assign unused_sha3_rand_update = sha3_rand_update;
1340:     assign unused_sha3_rand_consumed = sha3_rand_consumed;
1341: 
1342:     logic        unused_seed_update;
1343:     logic [31:0] unused_seed_data;
1344:     logic [31:0] unused_refresh_period;
1345:     logic unused_entropy_refresh_req;
1346:     assign unused_seed_data = entropy_seed_data;
1347:     assign unused_seed_update = entropy_seed_update;
1348:     assign unused_refresh_period = ^{wait_timer_limit, wait_timer_prescaler};
1349:     assign unused_entropy_refresh_req = entropy_refresh_req;
1350: 
1351:     logic unused_entropy_hash;
1352:     assign unused_entropy_hash = ^{entropy_hash_clr, entropy_hash_threshold};
1353:     assign entropy_hash_cnt = '0;
1354: 
1355:     assign entropy_err = '{valid: 1'b 0, code: ErrNone, info: '0};
1356: 
1357:     assign kmac_entropy_state_error = 1'b 0;
1358:     assign kmac_entropy_hash_counter_error  = 1'b 0;
1359: 
1360:     logic [1:0] unused_entropy_status;
1361:     assign unused_entropy_status = entropy_in_keyblock;
1362: 
1363:     // If Masking is off, always entropy configured
1364:     assign entropy_configured = prim_mubi_pkg::MuBi4True;
1365:   end
1366: 
1367:   // MUBI4 buf
1368:   prim_mubi4_sender #(
1369:     .AsyncOn (0)
1370:   ) u_sha3_done_sender (
1371:     .clk_i,
1372:     .rst_ni,
1373:     .mubi_i (sha3_done_d),
1374:     .mubi_o (sha3_done)
1375:   );
1376: 
1377:   // Register top
1378:   logic [NumAlerts-1:0] alert_test, alerts, alerts_q;
1379: 
1380:   logic shadowed_storage_err, shadowed_update_err;
1381:   kmac_reg_top u_reg (
1382:     .clk_i,
1383:     .rst_ni,
1384:     .rst_shadowed_ni,
1385: 
1386:     .tl_i,
1387:     .tl_o,
1388: 
1389:     .tl_win_o (tl_win_h2d),
1390:     .tl_win_i (tl_win_d2h),
1391: 
1392:     .reg2hw,
1393:     .hw2reg,
1394: 
1395:     // SEC_CM: CFG_SHADOWED.CONFIG.SHADOW
1396:     .shadowed_storage_err_o (shadowed_storage_err),
1397:     .shadowed_update_err_o  (shadowed_update_err),
1398:     // SEC_CM: BUS.INTEGRITY
1399:     .intg_err_o             (alert_intg_err)
1400:   );
1401: 
1402:   logic unused_cfg_shadowed_qe;
1403:   assign unused_cfg_shadowed_qe = ^{
1404:     reg2hw.cfg_shadowed.kmac_en.qe                     ,
1405:     reg2hw.cfg_shadowed.kstrength.qe                   ,
1406:     reg2hw.cfg_shadowed.mode.qe                        ,
1407:     reg2hw.cfg_shadowed.msg_endianness.qe              ,
1408:     reg2hw.cfg_shadowed.state_endianness.qe            ,
1409:     reg2hw.cfg_shadowed.sideload.qe                    ,
1410:     reg2hw.cfg_shadowed.entropy_mode.qe                ,
1411:     reg2hw.cfg_shadowed.entropy_fast_process.qe        ,
1412:     reg2hw.cfg_shadowed.msg_mask.qe                    ,
1413:     reg2hw.cfg_shadowed.en_unsupported_modestrength.qe
1414:     };
1415: 
1416:   // Alerts
1417:   assign alert_test = {
1418:     reg2hw.alert_test.fatal_fault_err.q
1419:       & reg2hw.alert_test.fatal_fault_err.qe,    // [1]
1420:     reg2hw.alert_test.recov_operation_err.q
1421:       & reg2hw.alert_test.recov_operation_err.qe // [0]
1422:   };
1423: 
1424:   assign alerts = {
1425:     alert_fatal,           // Alerts[1]
1426:     alert_recov_operation  // Alerts[0]
1427:     };
1428: 
1429:   assign alert_recov_operation = shadowed_update_err;
1430: 
1431:   // The recoverable alert is observable via status register until the KMAC operation is restarted
1432:   // by re-writing the Control Register.
1433:   logic status_alert_recov_ctrl_update_err;
1434:   always_ff @(posedge clk_i or negedge rst_ni) begin
1435:     if (!rst_ni) begin
1436:       status_alert_recov_ctrl_update_err <= 1'b 0;
1437:     end else if (alert_recov_operation) begin
1438:       status_alert_recov_ctrl_update_err <= 1'b 1;
1439:     end else if (err_processed) begin
1440:       status_alert_recov_ctrl_update_err <= 1'b 0;
1441:     end
1442:   end
1443: 
1444:   assign hw2reg.status.alert_recov_ctrl_update_err.d  = status_alert_recov_ctrl_update_err;
1445: 
1446:   assign alert_fatal = shadowed_storage_err
1447:                      | alert_intg_err
1448:                      | sparse_fsm_error
1449:                      | counter_error
1450:                      | control_integrity_error
1451:                      ;
1452: 
1453:   // Make the fatal alert observable via status register.
1454:   // Cannot be reset except the hardware reset
1455:   logic status_alert_fatal_fault;
1456: 
1457:   always_ff @(posedge clk_i or negedge rst_ni) begin
1458:     if (!rst_ni) begin
1459:       status_alert_fatal_fault <= 1'b 0;
1460:     end else if (alert_fatal) begin
1461:       status_alert_fatal_fault <= 1'b 1;
1462:     end
1463:   end
1464:   assign hw2reg.status.alert_fatal_fault.d  = status_alert_fatal_fault;
1465: 
1466:   for (genvar i = 0; i < NumAlerts; i++) begin : gen_alert_tx
1467:     prim_alert_sender #(
1468:       .AsyncOn(AlertAsyncOn[i]),
1469:       .IsFatal(i)
1470:     ) u_prim_alert_sender (
1471:       .clk_i,
1472:       .rst_ni,
1473:       .alert_test_i  ( alert_test[i] ),
1474:       .alert_req_i   ( alerts[i]     ),
1475:       .alert_ack_o   (               ),
1476:       .alert_state_o (               ),
1477:       .alert_rx_i    ( alert_rx_i[i] ),
1478:       .alert_tx_o    ( alert_tx_o[i] )
1479:     );
1480:   end
1481: 
1482:   // Below assumes NumAlerts == 2
1483:   `ASSERT_INIT(NumAlerts2_A, NumAlerts == 2)
1484: 
1485:   always_ff @(posedge clk_i or negedge rst_ni) begin
1486:   // break up the combinatorial path for local escalation
1487:     if (!rst_ni) begin
1488:       alerts_q[1] <= 1'b0;
1489:     end else if (alerts[1]) begin
1490:       // fatal alerts cannot be cleared
1491:       alerts_q[1] <= 1'b1;
1492:     end
1493:   end
1494: 
1495:   always_ff @(posedge clk_i or negedge rst_ni) begin
1496:   // break up the combinatorial path for local escalation
1497:     if (!rst_ni) begin
1498:       alerts_q[0] <= 1'b0;
1499:     end else begin
1500:       // recoverable alerts can be cleared so just latch the value
1501:       alerts_q[0] <= alerts[0];
1502:     end
1503:   end
1504: 
1505:   // Latched recoverable alert[0] is not used. Rather removing above,
1506:   // keep alert_q[1:0] and make alert_q[0] unused (lint waive).
1507:   logic unused_alerts_q0;
1508:   assign unused_alerts_q0 = alerts_q[0];
1509: 
1510:   // SEC_CM: LC_ESCALATE_EN.INTERSIG.MUBI, FSM.GLOBAL_ESC, FSM.LOCAL_ESC
1511:   lc_ctrl_pkg::lc_tx_t alert_to_lc_tx;
1512:   assign alert_to_lc_tx = lc_ctrl_pkg::lc_tx_bool_to_lc_tx(alerts_q[1]);
1513:   for (genvar i = 0; i < NumLcSyncCopies; i++) begin : gen_or_alert_lc_sync
1514:       assign lc_escalate_en[i] = lc_ctrl_pkg::lc_tx_or_hi(alert_to_lc_tx, lc_escalate_en_sync[i]);
1515:   end
1516: 
1517:   // Synchronize life cycle input
1518:   prim_lc_sync #(
1519:     .NumCopies (NumLcSyncCopies)
1520:   ) u_prim_lc_sync (
1521:     .clk_i,
1522:     .rst_ni,
1523:     .lc_en_i ( lc_escalate_en_i    ),
1524:     .lc_en_o ( lc_escalate_en_sync )
1525:   );
1526: 
1527:   assign en_masking_o = EnMasking;
1528: 
1529:   ////////////////
1530:   // Assertions //
1531:   ////////////////
1532: 
1533:   // Assert known for output values
1534:   `ASSERT_KNOWN(KmacDone_A, intr_kmac_done_o)
1535:   `ASSERT_KNOWN(FifoEmpty_A, intr_fifo_empty_o)
1536:   `ASSERT_KNOWN(KmacErr_A, intr_kmac_err_o)
1537:   `ASSERT_KNOWN(TlODValidKnown_A, tl_o.d_valid)
1538:   `ASSERT_KNOWN(TlOAReadyKnown_A, tl_o.a_ready)
1539:   `ASSERT_KNOWN(AlertKnownO_A, alert_tx_o)
1540:   `ASSERT_KNOWN(EnMaskingKnown_A, en_masking_o)
1541: 
1542:   // Parameter as desired
1543:   `ASSERT_INIT(SecretKeyDivideBy32_A, (kmac_pkg::MaxKeyLen % 32) == 0)
1544: 
1545:   // Command input should be sparse
1546:   `ASSUME(CmdSparse_M, reg2hw.cmd.cmd.qe |-> reg2hw.cmd.cmd.q inside {CmdStart, CmdProcess,
1547:                                                                 CmdManualRun,CmdDone, CmdNone})
1548: 
1549:   // redundant counter error
1550:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(SentMsgCountCheck_A, u_sha3.u_pad.u_sentmsg_count,
1551:                                          alert_tx_o[1])
1552:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(RoundCountCheck_A, u_sha3.u_keccak.u_round_count,
1553:                                          alert_tx_o[1])
1554:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(KeyIndexCountCheck_A, u_kmac_core.u_key_index_count,
1555:                                          alert_tx_o[1])
1556: 
1557:   // Sparse FSM state error
1558:   `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(KmacCoreFsmCheck_A, u_kmac_core.u_state_regs, alert_tx_o[1])
1559:   `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(KmacAppFsmCheck_A, u_app_intf.u_state_regs, alert_tx_o[1])
1560:   `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(SHA3FsmCheck_A, u_sha3.u_state_regs, alert_tx_o[1])
1561:   `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(SHA3padFsmCheck_A, u_sha3.u_pad.u_state_regs, alert_tx_o[1])
1562:   `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(KeccackFsmCheck_A, u_sha3.u_keccak.u_state_regs,
1563:                                        alert_tx_o[1])
1564:   `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(ErrorCheckFsmCheck_A, u_errchk.u_state_regs, alert_tx_o[1])
1565:   `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(KmacFsmCheck_A, u_state_regs, alert_tx_o[1])
1566: 
1567:   // prim is only instantiated if masking is enabled
1568:   if (EnMasking == 1) begin : g_testassertion
1569:     `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(EntropyFsmCheck_A, gen_entropy.u_entropy.u_state_regs,
1570:                                          alert_tx_o[1])
1571: 
1572:     `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(HashCountCheck_A, gen_entropy.u_entropy.u_hash_count,
1573:                                          alert_tx_o[1])
1574: 
1575:     // MsgFifo.Packer
1576:     `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(
1577:       PackerCountCheck_A,
1578:       u_msgfifo.u_packer.g_pos_dupcnt.u_pos,
1579:       alert_tx_o[1]
1580:     )
1581: 
1582:     // MsgFifo.Fifo
1583:     `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(
1584:       MsgFifoWptrCheck_A,
1585:       u_msgfifo.u_msgfifo.gen_normal_fifo.u_fifo_cnt.gen_secure_ptrs.u_wptr,
1586:       alert_tx_o[1]
1587:     )
1588:     `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(
1589:       MsgFifoRptrCheck_A,
1590:       u_msgfifo.u_msgfifo.gen_normal_fifo.u_fifo_cnt.gen_secure_ptrs.u_rptr,
1591:       alert_tx_o[1]
1592:     )
1593:   end
1594: 
1595:   // Alert assertions for reg_we onehot check
1596:   `ASSERT_PRIM_REG_WE_ONEHOT_ERROR_TRIGGER_ALERT(RegWeOnehotCheck_A, u_reg, alert_tx_o[1])
1597: endmodule

================================== Ai Message ==================================
Tool Calls:
  run_anomaly_detector_agent (call_F5Lfm9qUCwGLTSaI28eK4QhQ)
 Call ID: call_F5Lfm9qUCwGLTSaI28eK4QhQ
  Args:
    design_filepath: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/rtl/kmac.sv
    top_module: kmac
    security_objective: entropy use and message masking integrity
================================= Tool Message =================================
Name: run_anomaly_detector_agent

I ran the anomaly detector on the provided kmac.sv and focused on constructs relevant to entropy use and message masking. It found a small number of anomalous / suspicious constructs. I list the relevant anomalies, explain why each is suspicious for security (or not), and give concrete recommendations to fix or audit them.

Summary (short)
- Yes — there is a security-relevant anomaly around message masking: the code replaces an entropy/LFSR-derived mask with a static all‑ones mask and never uses the entropy-produced msg_mask. That removes randomness from the masking scheme and defeats the intended protection against side‑channel attacks (high severity).
- Other findings (msgfifo_data[1] = '0, some unused signals) look intentional or benign, but should be reviewed to ensure the masking/entropy model assumptions are correct.

Details — anomalous lines / snippets and analysis

1) Static mask used instead of entropy, permuted mask computed but unused
Code (excerpted from g_msg_mask):
- assign static_mask = {MsgWidth{1'b1}};
- always_comb begin
    msg_mask_permuted = '0;
    for (int unsigned i = 0 ; i < MsgWidth ; i++) begin
      msg_mask_permuted[i] = static_mask[RndCnstMsgPerm[i]];
    end
  end
- assign msg_data_masked[i] = msg_data[i] ^
                              ({MsgWidth{cfg_msg_mask}} & static_mask);

Why anomalous
- static_mask is all ones. Using an all‑ones static mask yields deterministic transformation (a bitwise invert if cfg_msg_mask is 1) rather than a random mask. Masking needs unpredictable, per‑instance randomness (from EDN/LFSR) to provide DOM/first‑order protection; a static mask offers no protection.
- msg_mask_permuted is computed from static_mask but never used later. There is an entropy module in the design that produces msg_mask and rand outputs, but this permuted static mask is not using the entropy output — effectively the entropy path is being bypassed for message masking.
- Both shares (for each i) are XORed with the same static mask when cfg_msg_mask is enabled. Proper masking usually requires applying independent/randomized masks and correct re‑combination/permutation handling; applying the same static mask to both shares does not provide the intended leakage protection.

Security impact
- High. This is a functional change that removes the intended randomness in message masking and thus undermines the countermeasure against side‑channel attacks. An attacker could exploit this to reduce security of masked operations and potentially recover key material (depending on the rest of the design and threat model).

Recommended fixes
- Use the entropy-derived msg_mask (the output of kmac_entropy) rather than a static mask. i.e. replace static_mask with the runtime msg_mask (or the permuted form of it), and apply the permutation RndCnstMsgPerm to entropy-produced bits as originally intended.
- Ensure msg_mask_permuted is actually used to mask msg_data_masked, e.g.
    msg_data_masked[i] = msg_data[i] ^ ({MsgWidth{cfg_msg_mask}} & msg_mask_permuted);
- Ensure per-share masking semantics are correct: each share should be masked appropriately (DOM/and-per-share scheme), not both shares masked with identical mask bits unless the masking scheme is formally proven secure for that approach.
- Add assertions / self‑checks that msg_mask is nontrivial when cfg_msg_mask is enabled (e.g. not all zeros or all ones), and/or that entropy is configured before enabling cfg_msg_mask.
- Remove the “performance optimization” that hardcodes static_mask, or gate it behind a well‑documented test-only macro so it can never be used in production.

2) Mask permutation variable unused (dead code)
Code:
- msg_mask_permuted computed (see snippet above) but never connected to msg_data_masked.

Why anomalous
- The permutation exists (RndCnstMsgPerm) but the code then uses static_mask directly. This looks like a leftover/incorrect patch where a dynamic/permuted mask was replaced by a static mask for timing but the rest of the logic wasn’t updated.

Security impact
- Medium/High: it reinforces the first item. Dead/unused permutation means the intended permutation of LFSR bits (to improve mask distribution and security) is disabled.

Recommended fixes
- Use the permuted entropy output (msg_mask_permuted derived from entropy), not a permuted static constant.
- Remove dead/unused code or clearly mark as test-only.

3) msgfifo_data[1] = '0
Code:
- assign msgfifo_data[1] = '0;

Why anomalous
- In masked mode, the comment says message need not be split and share 1 can be zero. That is a design choice: message is typically public data and only the key is secret, so putting message into one share and zeroing the other is common. The anomaly detector flagged it because it deviates from the general pattern of two-share handling.

Security impact
- Low. If message data is public and the masking scheme is intended only for secret key operations, this is acceptable. But it must be an explicit, reviewed design choice — not accidental — because using single-share messages can interact with masking assumptions elsewhere.

Recommendation
- Document and assert the assumption: message share1 = 0 is intended and safe. Add comments and, ideally, a static assertion that the masking policy for message vs key is consistent across modules.

4) Entropy bypass in non-masked configuration
Code (EnMasking==0 case):
- assign sha3_rand_valid = 1'b 1;
- assign sha3_rand_early = 1'b 1;
- assign sha3_rand_data = '0;
- assign sha3_rand_aux = '0;
- assign entropy_configured = prim_mubi_pkg::MuBi4True;

Why anomalous
- The entropy signals are tied to fixed values when masking is disabled. This is probably intentional: if EnMasking==0, entropy is not required. The detector flagged it because it’s different from the masked case.

Security impact
- Low/expected. If EnMasking==0 is a non-secure-mode build (no masking), then using deterministic zero randomness is fine (masking disabled). Make sure shipping configurations for secure production have EnMasking==1.

Recommendation
- Ensure build-time parameter EnMasking is managed correctly (secure production builds must have EnMasking==1). Add documentation and build-time checks to prevent accidental production builds with masking disabled.

Other minor anomalies
- Some unused signals and intermediate assignments were flagged (unused_entropy_fips, unused_*). These are lint/cleanliness issues rather than security problems, though they can hide logical mistakes. Remove or mark with clear comments.

Overall assessment
- The key security issue is the static mask + unused permutation + not using the entropy msg_mask: this breaks the runtime randomness that masking relies on and is a high‑severity security issue. It effectively disables the protection masking is intended to provide.
- Other flagged items (single share for message, deterministic behavior when EnMasking==0, unused signals) are either acceptable design choices or low‑severity code hygiene issues, but they should be explicitly reviewed and documented.

Suggested action items (short)
1. Immediately review and revert the “performance optimization” that replaced dynamic LFSR-based msg masks with a static all‑ones mask.
2. Wire kmac_entropy.msg_mask --> permutation --> msg_data_masked and ensure per-share masking semantics are correct.
3. Add runtime assertions: when cfg_msg_mask==1 then entropy_configured==true and msg_mask != all_zeros/all_ones.
4. Add a documented, enforced build-time policy ensuring EnMasking is enabled in secure silicon.
5. Run formal/side‑channel verification (or targeted leakage/fault analysis) on the masking path after fixes.

If you want, I can:
- produce a minimal patch (suggested code replacement) to replace static_mask with the entropy-driven mask and show the exact lines to change; or
- search the file for the entropy msg_mask signal and prepare a concrete code diff showing how to use it (and where to add assertions). Which would you prefer?
================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_bmx07iRhLYZ5iZ1nyoG9guOg)
 Call ID: call_bmx07iRhLYZ5iZ1nyoG9guOg
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/rtl/kmac_entropy.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // KMAC Entropy Generation module
6: 
7: `include "prim_assert.sv"
8: 
9: module kmac_entropy
10:   import kmac_pkg::*;
11:   import kmac_reg_pkg::*;
12: #(
13:   parameter lfsr_perm_t RndCnstLfsrPerm = RndCnstLfsrPermDefault,
14:   parameter lfsr_seed_t RndCnstLfsrSeed = RndCnstLfsrSeedDefault,
15:   parameter buffer_lfsr_seed_t RndCnstBufferLfsrSeed = RndCnstBufferLfsrSeedDefault
16: ) (
17:   input clk_i,
18:   input rst_ni,
19: 
20:   // EDN interface
21:   output logic                            entropy_req_o,
22:   input                                   entropy_ack_i,
23:   input [edn_pkg::ENDPOINT_BUS_WIDTH-1:0] entropy_data_i,
24: 
25:   // Entropy to internal
26:   output logic                          rand_valid_o,
27:   output logic                          rand_early_o,
28:   output logic [sha3_pkg::StateW/2-1:0] rand_data_o,
29:   output logic                          rand_aux_o,
30:   input                                 rand_update_i,
31:   input                                 rand_consumed_i,
32: 
33:   // Status
34:   input in_keyblock_i,
35: 
36:   // Configurations
37:   input entropy_mode_e mode_i,
38:   //// SW sets ready bit when EDN is ready to accept requests through its app.
39:   //// interface.
40:   input entropy_ready_i,
41: 
42:   //// Garbage random value when not processing Keyblock, if this config is
43:   //// turned on, the logic sending garbage value and never de-assert
44:   //// rand_valid_o unless it is not processing KeyBlock.
45:   input fast_process_i,
46: 
47:   //// PRNG enable for Message Masking
48:   //// If 1, PRNG advances to create 64-bit PRN. This input is used to mask
49:   //// the message fed into SHA3 (Keccak).
50:   input                       msg_mask_en_i,
51:   output logic [MsgWidth-1:0] msg_mask_o,
52: 
53:   //// SW update of seed
54:   input        seed_update_i,
55:   input [31:0] seed_data_i,
56: 
57:   //// SW may initiate manual EDN seed refresh
58:   input entropy_refresh_req_i,
59: 
60:   //// Timer limit value
61:   //// If value is 0, timer is disabled
62:   input [TimerPrescalerW-1:0] wait_timer_prescaler_i,
63:   input [EdnWaitTimerW-1:0]   wait_timer_limit_i,
64: 
65:   // Status out
66:   //// Hash Ops counter. Count how many hashing ops (KMAC) have run
67:   //// after the clear request from SW
68:   output logic [HashCntW-1:0] hash_cnt_o,
69:   input                       hash_cnt_clr_i,
70:   input        [HashCntW-1:0] hash_threshold_i,
71: 
72:   output prim_mubi_pkg::mubi4_t entropy_configured_o,
73: 
74:   // Life cycle
75:   input  lc_ctrl_pkg::lc_tx_t lc_escalate_en_i,
76: 
77:   // Error output
78:   output err_t err_o,
79:   output logic sparse_fsm_error_o,
80:   output logic count_error_o,
81:   input        err_processed_i
82: );
83: 
84:   /////////////////
85:   // Definitions //
86:   /////////////////
87: 
88:   // Timer Widths are defined in kmac_pkg
89: 
90:   // Encoding generated with:
91:   // $ ./util/design/sparse-fsm-encode.py -d 3 -m 9 -n 10 \
92:   //      -s 507672272 --language=sv
93:   //
94:   // Hamming distance histogram:
95:   //
96:   //  0: --
97:   //  1: --
98:   //  2: --
99:   //  3: ||||||||||| (13.89%)
100:   //  4: ||||||||||||||| (19.44%)
101:   //  5: |||||||||||||||||||| (25.00%)
102:   //  6: ||||||||||||||| (19.44%)
103:   //  7: ||||||||||| (13.89%)
104:   //  8: |||| (5.56%)
105:   //  9: || (2.78%)
106:   // 10: --
107:   //
108:   // Minimum Hamming distance: 3
109:   // Maximum Hamming distance: 9
110:   // Minimum Hamming weight: 2
111:   // Maximum Hamming weight: 7
112:   //
113:   localparam int StateWidth = 10;
114: 
115:   // States
116:   typedef enum logic [StateWidth-1:0] {
117:     // Reset: Reset state. The entropy is not ready. The state machine should
118:     // get new entropy from EDN or the seed should be feeded by the software.
119:     StRandReset = 10'b1001111000,
120: 
121:     // The seed is fed into PRNG and the entropy is ready. It means the
122:     // rand_valid is asserted with valid data. It takes a few steps to reach
123:     // this state from StRandReset.
124:     StRandReady = 10'b0110000100,
125: 
126:     // EDN interface: Send request and receive
127:     // RandEdnReq state can be transit from StRandReset or from StRandReady
128:     //
129:     // Reset --> EdnReq:
130:     //     If entropy source module is ready, the software sets a bit in CFG
131:     //     also sets the entropy mode to EdnMode. Then this FSM moves to EdnReq
132:     //     to initialize PRNG seed.
133:     //
134:     // Ready --> EdnReq:
135:     //     1. If a mode is configured as to update entropy everytime it is
136:     //        consumed, then the FSM moves from Ready to EdnReq to refresh seed
137:     //     2. If the software enabled EDN timer and the timer is expired and
138:     //        also the KMAC is processing the key block, the FSM moves to
139:     //        EdnReq to refresh seed
140:     //     3. If a KMAC operation is completed, the FSM also refreshes the PRNG
141:     //        seed to prepare next KMAC op or wipe out operation.
142:     StRandEdn = 10'b1100100111,
143: 
144:     // Sw Seed: If mode is set to manual mode, This entropy module needs initial
145:     // seed from the software. It waits the seed update signal to expand initial
146:     // entropy
147:     StSwSeedWait = 10'b1011110110,
148: 
149:     // Generate: In this state, the entropy generator advances the PRNG to
150:     // generate the 800-bits of pseudo random data for the next evaluation.
151:     StRandGenerate = 10'b0000001100,
152: 
153:     // ErrWaitExpired: If Edn timer expires, FSM moves to this state and wait
154:     // the software response. Software should switch to manual mode then disable
155:     // the timer (to 0) and update the seed via register interface.
156:     StRandErrWaitExpired = 10'b0001100011,
157: 
158:     // ErrNoValidMode: If SW sets entropy ready but the mode is not either
159:     // Manual Mode nor EdnMode, this logic reports to SW with
160:     // NoValidEntropyMode.
161:     StRandErrIncorrectMode = 10'b1110010000,
162: 
163:     // Err: After the error is reported, FSM sits in Err state ignoring all the
164:     // requests. It does not generate new entropy and drops the entropy valid
165:     // signal.
166:     //
167:     // SW sets err_processed signal to clear the error. The software should
168:     // clear the entropy ready signal before clear the error interrupt so that
169:     // the FSM sits in StRandReset state not moving forward with incorrect
170:     // configurations.
171:     StRandErr = 10'b1000011110,
172: 
173:     StTerminalError = 10'b0010011000
174:   } rand_st_e;
175: 
176:   /////////////
177:   // Signals //
178:   /////////////
179: 
180:   // Timers
181:   // "Wait Timer": This timer is in active when FSM sends entropy request to EDN
182:   //   If EDN does not return the entropy data until the timer expired, FSM
183:   //   moves to error state and report the error to the system.
184: 
185:   localparam int unsigned TimerW = EdnWaitTimerW;
186:   logic timer_enable, timer_update, timer_expired, timer_pulse;
187:   logic [TimerW-1:0] timer_limit;
188:   logic [TimerW-1:0] timer_value;
189: 
190:   localparam int unsigned PrescalerW = TimerPrescalerW;
191:   logic [PrescalerW-1:0] prescaler_cnt;
192: 
193:   // PRNG primitive
194:   // SW configures to use EDN or ENTROPY_SEED register as PRNG seed
195:   logic seed_en, seed_done;
196:   logic seed_req, seed_ack;
197:   logic [edn_pkg::ENDPOINT_BUS_WIDTH-1:0] seed;
198:   logic prng_en;
199:   logic [EntropyOutputW-1:0] prng_data, prng_data_permuted;
200: 
201:   // Buffer stage to prevent glitches happening inside the PRNG itself from
202:   // propagating into the masked processing core.
203:   logic [EntropyOutputW-1:0] rand_data_q;
204:   logic data_update;
205: 
206:   // Auxliliary randomness
207:   logic aux_rand_d, aux_rand_q;
208:   logic aux_update;
209: 
210:   // Randomness for controlling PRNG updates. This only matters for clock cycles
211:   // where the PRNG output is not actually used.
212:   logic [3:0] prng_en_rand_d, prng_en_rand_q;
213: 
214:   // Entropy valid signal
215:   // FSM set and clear the valid signal, rand_consume signal clear the valid
216:   // signal. Split the set, clear to make entropy valid while FSM is processing
217:   // other tasks.
218:   logic rand_valid_set, rand_valid_clear;
219: 
220:   // FSM latches the mode and stores into mode_q when the FSM is out from
221:   // StReset. The following states, or internal datapath uses mode_q after that.
222:   // If the SW wants to change the mode, it requires resetting the IP.
223:   logic mode_latch;
224:   entropy_mode_e mode_q;
225: 
226:   // Status out: entropy configured
227:   prim_mubi_pkg::mubi4_t entropy_configured;
228: 
229:   // Internal entropy request signals.
230:   logic entropy_req;
231:   logic entropy_req_hold_d, entropy_req_hold_q;
232: 
233:   //////////////
234:   // Datapath //
235:   //////////////
236: 
237:   // For latching (`wait_timer_limit_i` != 0) during last `timer_update`
238:   // See #16716
239:   logic non_zero_wait_timer_limit;
240:   always_ff @(posedge clk_i or negedge rst_ni) begin
241:     if (!rst_ni) begin
242:       non_zero_wait_timer_limit <= '0;
243:     end else if (timer_update) begin
244:       non_zero_wait_timer_limit <= |wait_timer_limit_i;
245:     end
246:   end
247: 
248:   logic [TimerPrescalerW-1:0] wait_timer_prescaler_d;
249:   always_ff @(posedge clk_i or negedge rst_ni) begin
250:     if (!rst_ni) begin
251:       wait_timer_prescaler_d <= '0;
252:     end else if (timer_update) begin
253:       wait_timer_prescaler_d <= wait_timer_prescaler_i;
254:     end
255:   end
256: 
257:   // Timers ===================================================================
258:   always_ff @(posedge clk_i or negedge rst_ni) begin
259:     if (!rst_ni) begin
260:       timer_value <= '0;
261:     end else if (timer_update) begin
262:       timer_value <= timer_limit;
263:     end else if (timer_expired) begin
264:       timer_value <= '0; // keep the value
265:     end else if (timer_enable && timer_pulse && |timer_value) begin // if non-zero timer v
266:       timer_value <= timer_value - 1'b 1;
267:     end
268:   end
269: 
270:   assign timer_limit = TimerW'(wait_timer_limit_i);
271: 
272:   always_ff @(posedge clk_i or negedge rst_ni) begin
273:     if (!rst_ni) begin
274:       timer_expired <= 1'b 0;
275:     end else if (timer_update) begin
276:       timer_expired <= 1'b 0;
277:     end else if (timer_enable && (timer_value == '0)) begin
278:       timer_expired <= 1'b 1;
279:     end
280:   end
281: 
282:   // Prescaler
283:   always_ff @(posedge clk_i or negedge rst_ni) begin
284:     if (!rst_ni) begin
285:       prescaler_cnt <= '0;
286:     end else if (timer_update) begin
287:       prescaler_cnt <= wait_timer_prescaler_i;
288:     end else if (timer_enable && prescaler_cnt == '0) begin
289:       prescaler_cnt <= wait_timer_prescaler_d;
290:     end else if (timer_enable) begin
291:       prescaler_cnt <= prescaler_cnt - 1'b 1;
292:     end
293:   end
294: 
295:   assign timer_pulse = (timer_enable && prescaler_cnt == '0);
296:   // Timers -------------------------------------------------------------------
297: 
298:   // Hash Counter
299:   logic threshold_hit;
300:   logic threshold_hit_q, threshold_hit_clr; // latched hit
301: 
302:   logic hash_progress_d, hash_progress_q;
303:   always_ff @(posedge clk_i or negedge rst_ni) begin
304:     if (!rst_ni) hash_progress_q <= 1'b 0;
305:     else         hash_progress_q <= hash_progress_d;
306:   end
307: 
308:   assign hash_progress_d = in_keyblock_i;
309: 
310:   logic hash_cnt_clr;
311:   assign hash_cnt_clr = hash_cnt_clr_i || threshold_hit || entropy_refresh_req_i;
312: 
313:   logic hash_cnt_en;
314:   assign hash_cnt_en = hash_progress_q && !hash_progress_d;
315: 
316:   logic hash_count_error;
317: 
318:   // SEC_CM CTR.REDUN
319:   // This primitive is used to place a hardened counter
320:   prim_count #(
321:     .Width(HashCntW)
322:   ) u_hash_count (
323:     .clk_i,
324:     .rst_ni,
325:     .clr_i(hash_cnt_clr),
326:     .set_i(1'b0),
327:     .set_cnt_i(HashCntW'(0)),
328:     .incr_en_i(hash_cnt_en),
329:     .decr_en_i(1'b0),
330:     .step_i(HashCntW'(1)),
331:     .commit_i(1'b1),
332:     .cnt_o(hash_cnt_o),
333:     .cnt_after_commit_o(),
334:     .err_o(hash_count_error)
335:   );
336: 
337:   assign threshold_hit = |hash_threshold_i && (hash_threshold_i <= hash_cnt_o);
338: 
339:   always_ff @(posedge clk_i or negedge rst_ni) begin
340:     if (!rst_ni)                threshold_hit_q <= 1'b 0;
341:     else if (threshold_hit_clr) threshold_hit_q <= 1'b 0;
342:     else if (threshold_hit)     threshold_hit_q <= 1'b 1;
343:   end
344: 
345:   always_ff @(posedge clk_i or negedge rst_ni) begin
346:     if (!rst_ni)         mode_q <= EntropyModeNone;
347:     else if (mode_latch) mode_q <= mode_i;
348:   end
349: 
350:   // PRNG primitive ===========================================================
351: 
352:   `ASSERT_KNOWN(ModeKnown_A, mode_i)
353:   assign seed = (mode_q == EntropyModeSw) ? seed_data_i : entropy_data_i;
354: 
355:   // We employ a single unrolled Bivium stream cipher primitive to generate
356:   // 800 bits per clock cycle.
357:   prim_trivium #(
358:    .BiviumVariant         (1),
359:    .OutputWidth           (EntropyOutputW),
360:    .StrictLockupProtection(1),
361:    .SeedType              (prim_trivium_pkg::SeedTypeStatePartial),
362:    .PartialSeedWidth      (edn_pkg::ENDPOINT_BUS_WIDTH),
363:    .RndCnstTriviumLfsrSeed(RndCnstLfsrSeed)
364:   ) u_prim_trivium (
365:    .clk_i (clk_i),
366:    .rst_ni(rst_ni),
367: 
368:    .en_i                (prng_en || msg_mask_en_i),
369:    .allow_lockup_i      ('0), // Not used.
370:    .seed_en_i           (seed_en),
371:    .seed_done_o         (seed_done),
372:    .seed_req_o          (seed_req),
373:    .seed_ack_i          (seed_ack),
374:    .seed_key_i          ('0), // Not used.
375:    .seed_iv_i           ('0), // Not used.
376:    .seed_state_full_i   ('0), // Not used.
377:    .seed_state_partial_i(seed),
378: 
379:    .key_o(prng_data),
380:    .err_o()
381:   );
382: 
383:   // Add a permutation layer to obfuscate the output of the PRNG primitive.
384:   for (genvar i = 0; i < EntropyOutputW; i++) begin : gen_perm
385:     assign prng_data_permuted[i] = prng_data[RndCnstLfsrPerm[i]];
386:   end
387: 
388:   // Buffer stage to prevent glitches happening inside the PRNG primitive from
389:   // propagating into the masked processing core.
390:   always_ff @(posedge clk_i or negedge rst_ni) begin
391:     if (!rst_ni) begin
392:       rand_data_q <= RndCnstBufferLfsrSeed;
393:     end else if (data_update || msg_mask_en_i) begin
394:       rand_data_q <= prng_data_permuted;
395:     end
396:   end
397: 
398:   // Forwrad LSBs for masking the message.
399:   assign msg_mask_o = rand_data_q[MsgWidth-1:0];
400: 
401:   //  PRNG primitive ----------------------------------------------------------
402: 
403:   // Auxiliary randomness =====================================================
404:   assign aux_rand_d = aux_update ? rand_data_q[EntropyOutputW - 1] :
405:                                    aux_rand_q;
406:   always_ff @(posedge clk_i or negedge rst_ni) begin
407:     if (!rst_ni) begin
408:       aux_rand_q <= '0;
409:     end else begin
410:       aux_rand_q <= aux_rand_d;
411:     end
412:   end
413: 
414:   // Auxiliary randomness -----------------------------------------------------
415: 
416:   // PRNG enable randomness ===================================================
417:   assign prng_en_rand_d =
418:       aux_update ? rand_data_q[EntropyOutputW - 2 -: 4] : // refresh
419:                    {1'b0, prng_en_rand_q[3:1]};           // shift out
420: 
421:   always_ff @(posedge clk_i or negedge rst_ni) begin
422:     if (!rst_ni) begin
423:       prng_en_rand_q <= '0;
424:     end else begin
425:       prng_en_rand_q <= prng_en_rand_d;
426:     end
427:   end
428: 
429:   // PRNG enable randomness ---------------------------------------------------
430: 
431:   // Randomness outputs =======================================================
432:   assign rand_data_o = rand_data_q;
433:   assign rand_aux_o = aux_rand_q;
434: 
435:   // entropy valid
436:   always_ff @(posedge clk_i or negedge rst_ni) begin
437:     if (!rst_ni) begin
438:       rand_valid_o <= 1'b 0;
439:     end else if (rand_valid_set) begin
440:       rand_valid_o <= 1'b 1;
441:     end else if (rand_valid_clear) begin
442:       rand_valid_o <= 1'b 0;
443:     end
444:   end
445: 
446:   // Let consumers know that the randomness will be valid in the next clock cycle.
447:   assign rand_early_o = rand_valid_set;
448: 
449:   // The Keccak core is not supposed to ever consume randomness unless it's marked
450:   // as valid. The only exception is if the reseeding of the PRNG just finished
451:   // in the previous clock cycle. Because it's possible for the randomness to stay
452:   // valid throughout the reseeding (the valid is for sure de-asserted at the end).
453:   // The Keccak core may base its decision to start processing / consuming entropy
454:   // before the valid is de-asserted. If this happens, the current buffer output
455:   // might be used for both remasking and as auxiliary randomness which isn't ideal
456:   // but given this happens only very rarely it should be okay.
457:   `ASSUME(ConsumeNotAssertWhenNotValid_M,
458:       rand_update_i | rand_consumed_i |-> rand_valid_o || $past(seed_done))
459: 
460:   // Upon escalation or in case the EDN wait timer expires the entropy_req signal
461:   // can be dropped before getting acknowledged. This may leave EDN in a strange
462:   // state. We thus hold the request until it's actually acknowledged. In case the
463:   // request is acknowledged while the FSM is in the StRandErr already, the
464:   // incoming entropy is simply dropped.
465:   assign entropy_req_o      = entropy_req | entropy_req_hold_q;
466:   assign entropy_req_hold_d = (entropy_req_hold_q | entropy_req) & ~entropy_ack_i;
467:   always_ff @(posedge clk_i or negedge rst_ni) begin
468:     if (!rst_ni) begin
469:       entropy_req_hold_q <= '0;
470:     end else begin
471:       entropy_req_hold_q <= entropy_req_hold_d;
472:     end
473:   end
474: 
475:   // Randomness outputs -------------------------------------------------------
476: 
477:   // Remaining outputs
478:   assign count_error_o = hash_count_error;
479: 
480:   ///////////////////
481:   // State Machine //
482:   ///////////////////
483: 
484:   rand_st_e st, st_d;
485: 
486:   // State FF
487:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, st_d, st, rand_st_e, StRandReset)
488: 
489:   // State: Next State and Output Logic
490:   // SEC_CM: FSM.SPARSE
491:   always_comb begin
492:     st_d = st;
493:     sparse_fsm_error_o = 1'b 0;
494: 
495:     // Default Timer values
496:     timer_enable = 1'b 0;
497:     timer_update = 1'b 0;
498: 
499:     threshold_hit_clr = 1'b 0;
500: 
501:     // rand is valid when this logic expands the entropy.
502:     // FSM sets the valid signal, the signal is cleared by `consume` signal
503:     // or FSM clear signal.
504:     // Why split the signal to set and clear?
505:     // FSM only set the signal to make entropy valid while processing other
506:     // tasks such as EDN request.
507:     rand_valid_set   = 1'b 0;
508:     rand_valid_clear = 1'b 0;
509: 
510:     // mode_latch to store mode_i into mode_q
511:     mode_latch = 1'b 0;
512: 
513:     // PRNG reseed handling
514:     seed_en = 1'b 0;
515:     seed_ack = 1'b 0;
516:     entropy_req = 1'b 0;
517: 
518:     // Randomness control signals
519:     prng_en = 1'b 0;
520:     data_update = 1'b 0;
521:     aux_update = 1'b 0;
522: 
523:     // Error
524:     err_o = '{valid: 1'b 0, code: ErrNone, info: '0};
525: 
526:     unique case (st)
527:       StRandReset: begin
528:         if (entropy_ready_i) begin
529: 
530:           // As SW ready, discard current dummy entropy and refresh.
531:           rand_valid_clear = 1'b 1;
532: 
533:           mode_latch = 1'b 1;
534:           // SW has configured KMAC
535:           unique case (mode_i)
536:             EntropyModeSw: begin
537:               // Start reseeding the PRNG via ENTROPY_SEED CSR.
538:               seed_en = 1'b 1;
539:               st_d = StSwSeedWait;
540:             end
541: 
542:             EntropyModeEdn: begin
543:               // Start reseeding the PRNG via EDN.
544:               seed_en = 1'b 1;
545:               st_d = StRandEdn;
546: 
547:               // Timer reset
548:               timer_update = 1'b 1;
549:             end
550: 
551:             default: begin
552:               // EntropyModeNone or other values
553:               // Error. No valid mode given, report to SW
554:               st_d = StRandErrIncorrectMode;
555:             end
556:           endcase
557:         end else begin
558:           st_d = StRandReset;
559: 
560:           // Setting the dummy rand gate until SW prepares.
561:           // This lets the Application Interface move forward out of reset
562:           // without SW intervention.
563:           rand_valid_set = 1'b 1;
564:         end
565:       end
566: 
567:       StRandReady: begin
568:         timer_enable = 1'b 1; // If limit is zero, timer won't work
569: 
570:         prng_en = prng_en_rand_q[0];
571: 
572:         if ((rand_update_i || rand_consumed_i) &&
573:             ((fast_process_i && in_keyblock_i) || !fast_process_i)) begin
574:           // If fast_process is set, don't clear the rand valid, even
575:           // consumed. So, the logic does not expand the entropy again.
576:           // If fast_process is not set, then every rand_consume signal
577:           // triggers rand expansion.
578:           prng_en = 1'b 1;
579:           data_update = 1'b 1;
580: 
581:           if (rand_consumed_i) begin
582:             st_d = StRandGenerate;
583: 
584:             rand_valid_clear = 1'b 1;
585:           end else begin
586:             st_d = StRandReady;
587:           end
588:         end else if ((mode_q == EntropyModeEdn) &&
589:             (entropy_refresh_req_i || threshold_hit_q)) begin
590:           // Start reseeding the PRNG via EDN.
591:           seed_en = 1'b 1;
592:           st_d = StRandEdn;
593: 
594:           // Timer reset
595:           timer_update = 1'b 1;
596: 
597:           // Clear the threshold as it refreshes the hash
598:           threshold_hit_clr = 1'b 1;
599:         end else begin
600:           st_d = StRandReady;
601:         end
602:       end
603: 
604:       StRandEdn: begin
605:         // Forward request of PRNG primitive.
606:         entropy_req = seed_req;
607: 
608:         // Wait timer
609:         timer_enable = 1'b 1;
610: 
611:         if (timer_expired && non_zero_wait_timer_limit) begin
612:           // If timer count is non-zero and expired;
613:           st_d = StRandErrWaitExpired;
614: 
615:         end else if (entropy_req_o && entropy_ack_i) begin
616:           seed_ack = 1'b 1;
617: 
618:           if (seed_done) begin
619:             st_d = StRandGenerate;
620: 
621:             if ((fast_process_i && in_keyblock_i) || !fast_process_i) begin
622:               prng_en = 1'b 1;
623:               data_update = 1'b 1;
624:               rand_valid_clear = 1'b 1;
625:             end
626:           end else begin
627:             st_d = StRandEdn;
628:           end
629:         end else if ((rand_update_i || rand_consumed_i) &&
630:             ((fast_process_i && in_keyblock_i) || !fast_process_i)) begin
631:           // Somehow, while waiting the EDN entropy, the KMAC or SHA3 logic
632:           // consumed the remained entropy. This can happen when the previous
633:           // SHA3/ KMAC op completed and this Entropy FSM has moved to this
634:           // state to refresh the entropy and the SW initiates another hash
635:           // operation while waiting for the EDN response.
636:           st_d = StRandEdn;
637: 
638:           prng_en = 1'b 1;
639:           data_update = 1'b 1;
640:           rand_valid_clear = rand_consumed_i;
641:         end else begin
642:           st_d = StRandEdn;
643:         end
644:       end
645: 
646:       StSwSeedWait: begin
647:         // Forward ack driven by software.
648:         seed_ack = seed_req & seed_update_i;
649: 
650:         if (seed_done) begin
651:           st_d = StRandGenerate;
652: 
653:           prng_en = 1'b 1;
654:           data_update = 1'b 1;
655: 
656:           rand_valid_clear = 1'b 1;
657:         end else begin
658:           st_d = StSwSeedWait;
659:         end
660:       end
661: 
662:       StRandGenerate: begin
663:         // The current buffer output is used as auxiliary randomness and -
664:         // depending on whether keccak_round is parametrized to always forward
665:         // the buffer output and not use intermediate randomness - forwarded
666:         // to the DOM multipliers without them updating in this cycle. We don't
667:         // need to advance the PRNG as there is no risk of accidentally
668:         // re-using the same randomness twice since after the current cycle:
669:         // - We either load and re-mask the message/key which will use
670:         //   different PRNG output bits. The PRNG is advanced once per 64 bits
671:         //   loaded.
672:         // - Or, the Keccak/SHA3 core is operated but it always starts with
673:         //   the linear layers which don't require fresh randomness. While
674:         //   processing the linear layers, the PRNG is advanced to have fresh
675:         //   randomness for the non-linear layer requiring it.
676:         aux_update = 1'b 1;
677:         rand_valid_set = 1'b 1;
678:         prng_en = prng_en_rand_q[0];
679: 
680:         st_d = StRandReady;
681:       end
682: 
683:       StRandErrWaitExpired: begin
684:         st_d = StRandErr;
685: 
686:         err_o = '{ valid: 1'b 1,
687:                    code: ErrWaitTimerExpired,
688:                    info: 24'(timer_value)
689:                  };
690:       end
691: 
692:       StRandErrIncorrectMode: begin
693:         st_d = StRandErr;
694: 
695:         err_o = '{ valid: 1'b 1,
696:                    code: ErrIncorrectEntropyMode,
697:                    info: 24'(mode_q)
698:                  };
699:       end
700: 
701:       StRandErr: begin
702:         // Keep entropy signal valid to complete current hashing even with error
703:         rand_valid_set = 1'b 1;
704: 
705:         // Advance the PRNG after the entropy has been used.
706:         prng_en = (rand_update_i | rand_consumed_i) &
707:             ((fast_process_i & in_keyblock_i) | ~fast_process_i);
708:         data_update = prng_en;
709: 
710:         if (err_processed_i) begin
711:           st_d = StRandReset;
712: 
713:         end else begin
714:           st_d = StRandErr;
715:         end
716: 
717:       end
718: 
719:       StTerminalError: begin
720:         // this state is terminal
721:         st_d = st;
722:         sparse_fsm_error_o = 1'b 1;
723:       end
724: 
725:       default: begin
726:         st_d = StTerminalError;
727:         sparse_fsm_error_o = 1'b 1;
728:       end
729:     endcase
730: 
731:     // SEC_CM: FSM.GLOBAL_ESC, FSM.LOCAL_ESC
732:     // Unconditionally jump into the terminal error state
733:     // if the life cycle controller triggers an escalation.
734:     if (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) begin
735:       st_d = StTerminalError;
736:     end
737:   end
738:   `ASSERT_KNOWN(RandStKnown_A, st)
739: 
740:   // mubi4 sender
741: 
742:   assign entropy_configured = (st != StRandReset)
743:                             ? prim_mubi_pkg::MuBi4True
744:                             : prim_mubi_pkg::MuBi4False ;
745:   prim_mubi4_sender #(
746:     .AsyncOn(1'b0)
747:   ) u_entropy_configured (
748:     .clk_i,
749:     .rst_ni,
750: 
751:     .mubi_i (entropy_configured  ),
752:     .mubi_o (entropy_configured_o)
753:   );
754: 
755:   ////////////////
756:   // Assertions //
757:   ////////////////
758: 
759:   // The EDN bus width needs to be equal to the width of the ENTROPY_SEED
760:   // register as this module doesn't perform width adaption.
761:   `ASSERT_INIT(EdnBusWidth_A, edn_pkg::ENDPOINT_BUS_WIDTH == 32)
762: 
763: // the code below is not meant to be synthesized,
764: // but it is intended to be used in simulation and FPV
765: `ifndef SYNTHESIS
766:   // Check that the supplied permutations are valid.
767:   logic [EntropyOutputW-1:0] perm_test;
768:   initial begin : p_perm_check
769:     perm_test = '0;
770:     for (int k = 0; k < EntropyOutputW; k++) begin
771:       perm_test[RndCnstLfsrPerm[k]] = 1'b1;
772:     end
773:     // All bit positions must be marked with 1.
774:     `ASSERT_I(PermutationCheck_A, &perm_test)
775:   end
776: `endif
777: 
778: endmodule : kmac_entropy

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_XrVZ9jtr1In2Lv0QOONfcIOa)
 Call ID: call_XrVZ9jtr1In2Lv0QOONfcIOa
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/rtl/kmac_staterd.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Keccak state read
6: 
7: `include "prim_assert.sv"
8: 
9: module kmac_staterd
10:   import kmac_pkg::*;
11: #(
12:   // TL-UL Address Width. Should be bigger than
13:   // $clog2(kmac_pkg::StateW) * Share
14:   parameter int AddrW = 9,
15: 
16:   // EnMasking: Enable masking security hardening inside keccak_round
17:   // If it is enabled, the result digest will be two set of 1600bit.
18:   parameter  bit EnMasking = 1'b0,
19:   localparam int Share = (EnMasking) ? 2 : 1  // derived parameter
20: ) (
21:   input clk_i,
22:   input rst_ni,
23: 
24:   input  tlul_pkg::tl_h2d_t tl_i,
25:   output tlul_pkg::tl_d2h_t tl_o,
26: 
27:   // State in
28:   input [sha3_pkg::StateW-1:0] state_i [Share],
29: 
30:   // Config
31:   input endian_swap_i
32: );
33: 
34:   localparam int StateAddrW = $clog2(sha3_pkg::StateW/32);
35:   localparam int SelAddrW   = AddrW-2-StateAddrW;
36: 
37:   /////////////
38:   // Signals //
39:   /////////////
40: 
41:   // TL-UL Adapter signals
42:   logic             tlram_req;
43:   logic             tlram_gnt;
44:   logic             tlram_we;
45:   logic [AddrW-3:0] tlram_addr;   // Word base
46:   logic [31:0]      unused_tlram_wdata;
47:   logic [31:0]      unused_tlram_wmask;
48:   logic [31:0]      tlram_rdata;
49:   logic             tlram_rvalid;
50:   logic [1:0]       tlram_rerror;
51:   logic [31:0]      tlram_rdata_endian;
52: 
53:   // TL Adapter
54:   tlul_adapter_sram #(
55:     .SramAw (AddrW-2),
56:     .SramDw (32),
57:     .Outstanding (1),
58:     .ByteAccess  (1),
59:     .ErrOnWrite  (1),
60:     .ErrOnRead   (0)
61:   ) u_tlul_adapter (
62:     .clk_i,
63:     .rst_ni,
64: 
65:     .tl_i,
66:     .tl_o,
67:     .en_ifetch_i                (prim_mubi_pkg::MuBi4False),
68:     .req_o                      (tlram_req),
69:     .req_type_o                 (),
70:     .gnt_i                      (tlram_gnt),
71:     .we_o                       (tlram_we ),
72:     .addr_o                     (tlram_addr),
73:     .wdata_o                    (unused_tlram_wdata),
74:     .wmask_o                    (unused_tlram_wmask),
75:     .intg_error_o               (),
76:     .user_rsvd_o                (),
77:     .rdata_i                    (tlram_rdata),
78:     .rvalid_i                   (tlram_rvalid),
79:     .rerror_i                   (tlram_rerror),
80:     .compound_txn_in_progress_o (),
81:     .readback_en_i              (prim_mubi_pkg::MuBi4False),
82:     .readback_error_o           (),
83:     .wr_collision_i             (1'b0),
84:     .write_pending_i            (1'b0)
85:   );
86: 
87:   always_ff @(posedge clk_i or negedge rst_ni) begin
88:     if (!rst_ni) begin
89:       tlram_rdata <= '0;
90:     end else if (tlram_req & ~tlram_we) begin
91:       tlram_rdata <= conv_endian32(tlram_rdata_endian, endian_swap_i);
92:     end
93:   end
94: 
95:   // Always grant
96:   assign tlram_gnt = tlram_req & ~tlram_we;
97: 
98:   // always no error on reading
99:   assign tlram_rerror = '0;
100: 
101:   always_ff @(posedge clk_i or negedge rst_ni) begin
102:     if (!rst_ni) tlram_rvalid <= 1'b0;
103:     else         tlram_rvalid <= tlram_req & !tlram_we;
104:   end
105: 
106:   logic [31:0] muxed_state [Share];
107: 
108: 
109:   for (genvar i = 0 ; i < Share ; i++) begin : gen_slicer
110:     prim_slicer #(
111:       .InW (sha3_pkg::StateW),
112:       .OutW (32),
113:       .IndexW (StateAddrW)
114:     ) u_state_slice (
115:       .sel_i (tlram_addr[StateAddrW-1:0]),
116:       .data_i (state_i[i]),
117:       .data_o (muxed_state[i])
118:     );
119:   end : gen_slicer
120: 
121:   logic [SelAddrW-1:0] addr_sel;
122:   assign addr_sel = tlram_addr[StateAddrW+:SelAddrW];
123: 
124:   assign tlram_rdata_endian = int'(addr_sel) < Share ? muxed_state[addr_sel] : 0;
125: 
126: endmodule

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_UJ9KJhCcGzROpBiUiFkOVoKD)
 Call ID: call_UJ9KJhCcGzROpBiUiFkOVoKD
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/rtl/kmac_core.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // KMAC control and padding logic
6: 
7: `include "prim_assert.sv"
8: 
9: module kmac_core
10:   import kmac_pkg::*;
11: #(
12:   // EnMasking: Enable masking security hardening inside keccak_round
13:   // If it is enabled, the result digest will be two set of 1600bit.
14:   parameter  bit EnMasking = 0,
15:   localparam int Share = (EnMasking) ? 2 : 1 // derived parameter
16: ) (
17:   input clk_i,
18:   input rst_ni,
19: 
20:   // From Message FIFO
21:   input                fifo_valid_i,
22:   input [MsgWidth-1:0] fifo_data_i [Share],
23:   input [MsgStrbW-1:0] fifo_strb_i,
24:   output logic         fifo_ready_o,
25: 
26:   // to SHA3 Core
27:   output logic                msg_valid_o,
28:   output logic [MsgWidth-1:0] msg_data_o  [Share],
29:   output logic [MsgStrbW-1:0] msg_strb_o,
30:   input                       msg_ready_i,
31: 
32:   // Configurations
33: 
34:   // If kmac_en is cleared, Core logic doesn't function but forward incoming
35:   // message to SHA3 core
36:   input                             kmac_en_i,
37:   input sha3_pkg::sha3_mode_e       mode_i,
38:   input sha3_pkg::keccak_strength_e strength_i,
39: 
40:   // Key input from CSR
41:   input [MaxKeyLen-1:0] key_data_i [Share],
42:   input key_len_e       key_len_i,
43:   input logic           key_valid_i,
44: 
45:   // Controls : same to SHA3 core
46:   input start_i,
47:   input process_i,
48:   input prim_mubi_pkg::mubi4_t done_i,
49: 
50:   // Control to SHA3 core
51:   output logic process_o,
52: 
53:   // Life cycle
54:   input  lc_ctrl_pkg::lc_tx_t lc_escalate_en_i,
55: 
56:   output logic sparse_fsm_error_o,
57:   output logic key_index_error_o
58: );
59: 
60:   import sha3_pkg::KeccakMsgAddrW;
61:   import sha3_pkg::KeccakCountW;
62:   import sha3_pkg::KeccakRate;
63:   import sha3_pkg::L128;
64:   import sha3_pkg::L224;
65:   import sha3_pkg::L256;
66:   import sha3_pkg::L384;
67:   import sha3_pkg::L512;
68: 
69:   /////////////////
70:   // Definitions //
71:   /////////////////
72: 
73:   // Encoding generated with:
74:   // $ ./util/design/sparse-fsm-encode.py -d 3 -m 5 -n 6 \
75:   //      -s 401658243 --language=sv
76:   //
77:   // Hamming distance histogram:
78:   //
79:   //  0: --
80:   //  1: --
81:   //  2: --
82:   //  3: |||||||||||||||||||| (50.00%)
83:   //  4: |||||||||||||||| (40.00%)
84:   //  5: |||| (10.00%)
85:   //  6: --
86:   //
87:   // Minimum Hamming distance: 3
88:   // Maximum Hamming distance: 5
89:   // Minimum Hamming weight: 1
90:   // Maximum Hamming weight: 4
91:   //
92:   localparam int StateWidth = 6;
93:   typedef enum logic [StateWidth-1:0] {
94:     StKmacIdle = 6'b011000,
95: 
96:     // Secret Key pushing stage
97:     // The key is sliced by prim_slicer. This state pushes the sliced data into
98:     // SHA3 hashing engine. When it hits the block size limit,
99:     // (same as in sha3pad) the state machine moves to Message.
100:     StKey = 6'b010111,
101: 
102:     // Incoming Message
103:     // The core does nothing but forwarding the incoming message to SHA3 hashing
104:     // engine by turning off `en_kmac_datapath`.
105:     StKmacMsg = 6'b001110,
106: 
107:     // Wait till done signal
108:     StKmacFlush = 6'b101011,
109: 
110:     // Terminal Error
111:     StTerminalError = 6'b100000
112:   } kmac_st_e ;
113: 
114:   /////////////
115:   // Signals //
116:   /////////////
117: 
118:   // represents encode_string(K)
119:   logic [MaxEncodedKeyW-1:0] encoded_key [Share];
120: 
121:   // Key slice address
122:   // This signal controls the 64 bit output of the sliced secret_key.
123:   logic [sha3_pkg::KeccakMsgAddrW-1:0] key_index;
124:   logic inc_keyidx, clr_keyidx;
125: 
126:   // `sent_blocksize` indicates that the encoded key is sent to sha3 hashing
127:   // engine. If this hits at StKey stage, the state moves to message state.
128:   logic [sha3_pkg::KeccakCountW-1:0] block_addr_limit;
129:   logic sent_blocksize;
130: 
131:   // Internal message signals
132:   logic                kmac_valid       ;
133:   logic [MsgWidth-1:0] kmac_data [Share];
134:   logic [MsgStrbW-1:0] kmac_strb        ;
135: 
136:   // Control SHA3 core
137:   // `kmac_process` is to forward the process signal to SHA3 core only after
138:   // the KMAC core writes the key block in case of the message is empty.
139:   // If the incoming message is empty, there's chance that the `process_i`
140:   // signal can be asserted while KMAC core processing the key block.
141:   logic kmac_process, process_latched;
142: 
143:   // Indication of Secret key write stage. Only in this stage, the internal
144:   // message interface is active.
145:   logic en_key_write;
146:   logic en_kmac_datapath;
147: 
148:   // Encoded key has wider bits. `key_sliced` is the data to send to sha3
149:   logic [MsgWidth-1:0] key_sliced [Share];
150: 
151:   // The following signals are only used in assertions.
152:   logic unused_signals;
153:   assign unused_signals = ^{mode_i, key_valid_i};
154: 
155:   /////////
156:   // FSM //
157:   /////////
158:   kmac_st_e st, st_d;
159:   logic [7:0] st_err_ct, st_err_ct_d;
160: 
161:   // State register
162:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, st_d, st, kmac_st_e, StKmacIdle)
163: 
164:   // Next state and output logic
165:   // SEC_CM: FSM.SPARSE
166:   always_comb begin
167:     st_d = st;
168:     st_err_ct_d = st_err_ct;
169: 
170:     en_kmac_datapath = 1'b 0;
171:     en_key_write = 1'b 0;
172: 
173:     clr_keyidx = 1'b 0;
174: 
175:     kmac_valid = 1'b 0;
176:     kmac_process = 1'b 0;
177: 
178:     sparse_fsm_error_o = 1'b 0;
179: 
180:     unique case (st)
181:       StKmacIdle: begin
182:         st_err_ct_d = 8'd0;
183:         if (kmac_en_i && start_i) begin
184:           st_d = StKey;
185:         end else begin
186:           st_d = StKmacIdle;
187:         end
188:       end
189: 
190:       // If State enters here, regardless of the `process_i`, the state writes
191:       // full block size of the key into SHA3 hashing engine.
192:       StKey: begin
193:         en_kmac_datapath = 1'b 1;
194:         en_key_write = 1'b 1;
195: 
196:         if (sent_blocksize) begin
197:           st_d = StKmacMsg;
198: 
199:           kmac_valid = 1'b 0;
200:           clr_keyidx = 1'b 1;
201:         end else begin
202:           st_d = StKey;
203: 
204:           kmac_valid = 1'b 1;
205:         end
206:       end
207: 
208:       StKmacMsg: begin
209:         // If process is previously latched, it is sent to SHA3 here.
210:         if (process_i || process_latched) begin
211:           st_d = StKmacFlush;
212: 
213:           kmac_process = 1'b 1;
214:         end else begin
215:           st_d = StKmacMsg;
216:         end
217:       end
218: 
219:       StKmacFlush: begin
220:         if (prim_mubi_pkg::mubi4_test_true_strict(done_i)) begin
221:           st_d = StKmacIdle;
222:         end else begin
223:           st_d = StKmacFlush;
224:         end
225:       end
226: 
227:       StTerminalError: begin
228:         // this state is terminal
229:         st_d = st;
230:         if (st_err_ct < 8'd100) begin
231:           st_err_ct_d = st_err_ct + 1'b 1;
232:           sparse_fsm_error_o = 1'b 0;
233:         end else begin
234:           sparse_fsm_error_o = 1'b 1;
235:         end
236:       end
237: 
238:       default: begin
239:         // this state is terminal
240:         st_d = StTerminalError;
241:         sparse_fsm_error_o = 1'b 1;
242:       end
243:     endcase
244: 
245:     // SEC_CM: FSM.GLOBAL_ESC, FSM.LOCAL_ESC
246:     // Unconditionally jump into the terminal error state
247:     // if the life cycle controller triggers an escalation.
248:     if (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) begin
249:       st_d = StTerminalError;
250:     end
251:   end
252: 
253:   //////////////
254:   // Datapath //
255:   //////////////
256: 
257:   // DATA Mux depending on kmac_en
258:   // When Key write happens, hold the FIFO request. so fifo_ready_o is tied to 0
259:   assign msg_valid_o  = (en_kmac_datapath) ? kmac_valid : fifo_valid_i;
260:   assign msg_data_o   = (en_kmac_datapath) ? kmac_data  : fifo_data_i ;
261:   assign msg_strb_o   = (en_kmac_datapath) ? kmac_strb  : fifo_strb_i ;
262:   assign fifo_ready_o = (en_kmac_datapath) ? 1'b 0      : msg_ready_i ;
263: 
264:   // secret key write request to SHA3 hashing engine is always full width write.
265:   // KeyMgr is fixed 256 bit output. So `right_encode(256)` is 0x020100 --> strb 3
266:   assign kmac_strb = (en_key_write ) ? '1 : '0;
267: 
268:   assign kmac_data = (en_key_write) ? key_sliced : '{default:'0};
269: 
270:   // Process is controlled by the KMAC core always.
271:   // This is mainly to prevent process_i asserted while KMAC core is writing
272:   // the secret key to SHA3 hashing engine (the empty message case)
273:   assign process_o = (kmac_en_i) ? kmac_process : process_i ;
274: 
275:   always_ff @(posedge clk_i or negedge rst_ni) begin
276:     if (!rst_ni) begin
277:       process_latched <= 1'b 0;
278:     end else if (process_i && !process_o) begin
279:       process_latched <= 1'b 1;
280:     end else if (process_o ||
281:       prim_mubi_pkg::mubi4_test_true_strict(done_i)) begin
282:       process_latched <= 1'b 0;
283:     end
284:   end
285: 
286:   always_ff @(posedge clk_i or negedge rst_ni) begin
287:     if (!rst_ni) st_err_ct <= '0;
288:     else         st_err_ct <= st_err_ct_d;
289:   end
290: 
291:   // bytepad(encode_string(K), 168 or 136) =====================================
292:   // 1. Prepare left_encode(w)
293:   // 2. Prepare left_encode(len(secret_key))
294:   // 3. Concatenate left_encode(len(secret_key)) || secret_key
295:   // 4. Concaatenate left_encode(w) || encode_string(secret_key)
296:   // 5. Based on the address, slice out the data into MsgWidth bits
297: 
298:   // left_encode(w): Same as used in sha3pad logic.
299:   logic [15:0] encode_bytepad;
300:   assign encode_bytepad = sha3_pkg::encode_bytepad_len(strength_i);
301: 
302:   // left_encode(len(secret_key))
303:   // encoded length is always byte size. Use MaxEncodedKeyLenByte parameter
304:   // from kmac_pkg and add one more byte to indicate how many bytes used to
305:   // represent len(secret_key)
306:   // Note that if the secret_key is 128 bit, only lower 16 bits of
307:   // `encode_keylen` are valid. Refer `encoded_key` concatenation logic below.
308:   // As the encoded string in the spec big-endian, The endian swap is a must.
309:   logic [MaxEncodedKeyLenSize + 8 - 1:0] encode_keylen [Share];
310: 
311:   always_comb begin
312:     // the spec mentioned the key length is encoded in left_encode()
313:     // The number is represented in big-endian. For example:
314:     // 384 ==> 0x02 0x01 0x80
315:     // The first byte is the number of bytes to represent 384
316:     // The second byte represents 2**8 number, which is 256 here.
317:     // The third byte represents 2**0 number, which is 128.
318:     // The data put into MsgFIFO is little-endian and SHA3(Keccak) processes in
319:     // little-endian. So, below keylen swaps the byte order
320:     unique case (key_len_i)
321:       //                           endian-swapped key_length          num_bytes
322:       // Key128: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(128)}}, 8'h 01};
323:       // Key192: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(192)}}, 8'h 01};
324:       // Key256: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(256)}}, 8'h 02};
325:       // Key384: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(384)}}, 8'h 02};
326:       // Key512: encode_keylen[0] = {{<<8{MaxEncodedKeyLenSize'(512)}}, 8'h 02};
327: 
328:       // Vivado does not support stream swap for non context value. So assign
329:       // the value directly.
330:       Key128: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 0080_01);
331:       Key192: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 00C0_01);
332:       Key256: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 0001_02);
333:       Key384: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 8001_02);
334:       Key512: encode_keylen[0] = (MaxEncodedKeyLenSize+8)'('h 0002_02);
335:       default: encode_keylen[0] = '0;
336:     endcase
337:   end
338: 
339:   if (EnMasking) begin: gen_encode_keylen_masked
340:     assign encode_keylen[1] = '0;
341:   end
342: 
343:   // encode_string(secret_key): Concatenate key
344:   // Based on the left_encode(len(secret_key)) size, the concatenation logic
345:   // should be changed. If key length is 128 bit, only lower 16 bits of the
346:   // encoded length are used so that the upper 8 bits are padded with 0 as
347:   // defined in bytepad() function.
348: 
349:   for (genvar i = 0 ; i < Share; i++) begin : gen_encoded_key
350:     always_comb begin
351:       unique case (key_len_i)
352:         // In Key 128, 192 case, only lower parts of encode_keylen signal is
353:         // used. So upper padding requires 8 more bits than MaxKeyLen - keylen
354:         Key128: encoded_key[i] = {(8 + MaxKeyLen - 128)'(0),
355:                                   key_data_i[i][0+:128],
356:                                   encode_keylen[i][0+:MaxEncodedKeyLenSize]};
357: 
358:         Key192: encoded_key[i] = {(8 + MaxKeyLen - 192)'(0),
359:                                   key_data_i[i][0+:192],
360:                                   encode_keylen[i][0+:MaxEncodedKeyLenSize]};
361: 
362:         Key256: encoded_key[i] = {(MaxKeyLen - 256)'(0),
363:                                   key_data_i[i][0+:256],
364:                                   encode_keylen[i]};
365: 
366:         Key384: encoded_key[i] = {(MaxKeyLen - 384)'(0),
367:                                   key_data_i[i][0+:384],
368:                                   encode_keylen[i]};
369: 
370:         // Assume 512bit is the MaxKeyLen
371:         Key512: encoded_key[i] = {key_data_i[i][0+:512],
372:                                   encode_keylen[i]};
373: 
374:         default: encoded_key[i] = '0;
375:       endcase
376:     end
377:   end : gen_encoded_key
378: 
379:   // Above logic assumes MaxKeyLen as 512 bits. Revise if it is not.
380:   `ASSERT_INIT(MaxKeyLenMatchToKey512_A, kmac_pkg::MaxKeyLen == 512)
381: 
382:   // Combine the bytepad `left_encode(w)` and the `encode_string(secret_key)`
383:   logic [MaxEncodedKeyW + 16 -1 :0] encoded_key_block [Share];
384: 
385:   assign encoded_key_block[0] = {encoded_key[0], encode_bytepad};
386: 
387:   if (EnMasking) begin : gen_encoded_key_block_masked
388:     assign encoded_key_block[1] = {encoded_key[1], 16'h 0};
389:   end
390: 
391:   // Slicer to slice out 64 bits
392:   for (genvar i = 0 ; i < Share ; i++) begin : gen_key_slicer
393:     prim_slicer #(
394:       .InW (MaxEncodedKeyW+16),
395:       .IndexW(KeccakMsgAddrW),
396:       .OutW(MsgWidth)
397:     ) u_key_slicer (
398:       .sel_i  (key_index),
399:       .data_i (encoded_key_block[i]),
400:       .data_o (key_sliced[i])
401:     );
402:   end
403: 
404:   // `key_index` logic
405:   // key_index is used to select MsgWidth data from long `encoded_key_block`
406:   // It behaves same as `keccak_addr` or `prefix_index` in sha3pad module.
407:   assign inc_keyidx = kmac_valid & msg_ready_i ;
408: 
409:   // This primitive is used to place a hardened counter
410:   // SEC_CM: CTR.REDUN
411:   prim_count #(
412:     .Width(sha3_pkg::KeccakMsgAddrW)
413:   ) u_key_index_count (
414:     .clk_i,
415:     .rst_ni,
416:     .clr_i(clr_keyidx),
417:     .set_i(1'b0),
418:     .set_cnt_i('0),
419:     .incr_en_i(inc_keyidx),
420:     .decr_en_i(1'b0),
421:     .step_i(sha3_pkg::KeccakMsgAddrW'(1)),
422:     .commit_i(1'b1),
423:     .cnt_o(key_index),
424:     .cnt_after_commit_o(),
425:     .err_o(key_index_error_o)
426:   );
427: 
428:   // Block size based on the address.
429:   // This is used for bytepad() and also pad10*1()
430:   // assign block_addr_limit = KeccakRate[strength_i];
431:   // but below is easier to understand
432:   always_comb begin
433:     unique case (strength_i)
434:       L128: block_addr_limit = KeccakCountW'(KeccakRate[L128]);
435:       L224: block_addr_limit = KeccakCountW'(KeccakRate[L224]);
436:       L256: block_addr_limit = KeccakCountW'(KeccakRate[L256]);
437:       L384: block_addr_limit = KeccakCountW'(KeccakRate[L384]);
438:       L512: block_addr_limit = KeccakCountW'(KeccakRate[L512]);
439: 
440:       default: block_addr_limit = '0;
441:     endcase
442:   end
443: 
444:   assign sent_blocksize = (key_index == block_addr_limit);
445: 
446: 
447:   // Encoded Output Length =====================================================
448:   //
449:   // KMAC(K,X,L,S) := cSHAKE(newX,L,"KMAC",S)
450:   //   K : Secret Key
451:   //   X : Input Message
452:   //   L : Output Length
453:   //   S : Customization input string
454:   //   newX = bytepad(encode_string(key), 168or136) || X || right_encode(L)
455:   //
456:   // Software writes desired output length as encoded value into the message
457:   // FIFO at the end of the message prior to set !!CMD.process.
458: 
459: 
460:   ////////////////
461:   // Assertions //
462:   ////////////////
463: 
464:   // If process_latched is set, then at Message state, it should be cleared
465: 
466:   `ASSERT(ProcessLatchedCleared_A,
467:           st == StKmacMsg && process_latched |=> !process_latched)
468: 
469:   // Assume configuration is stable during the operation
470:   `ASSUME(KmacEnStable_M, $changed(kmac_en_i) |-> st inside {StKmacIdle, StTerminalError})
471:   `ASSUME(ModeStable_M, $changed(mode_i) |-> st inside {StKmacIdle, StTerminalError})
472:   `ASSUME(StrengthStable_M,
473:           $changed(strength_i) |->
474:           (st inside {StKmacIdle, StTerminalError}) ||
475:           ($past(st) == StKmacIdle))
476:   `ASSUME(KeyLengthStableWhenValid_M, key_valid_i && !$rose(key_valid_i) |-> $stable(key_len_i))
477:   `ASSUME(KeyDataStableWhenValid_M, key_valid_i && !$rose(key_valid_i) |-> $stable(key_data_i))
478: 
479:   // no acked to MsgFIFO in StKmacMsg
480:   `ASSERT(AckOnlyInMessageState_A,
481:           fifo_valid_i && fifo_ready_o && kmac_en_i |-> st == StKmacMsg)
482: 
483: endmodule : kmac_core

================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_GWRJQTGLCWq3gqt7G9WYyTON)
 Call ID: call_GWRJQTGLCWq3gqt7G9WYyTON
  Args:
    design_filepath: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/rtl/kmac.sv
    top_module: kmac
    security_objective: Side-channel masking and entropy usage correctness
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

Error: InternalServerError("Error code: 500 - {'type': 'error', 'error': {'type': 'api_error', 'message': 'Internal server error'}, 'request_id': None}")
 Please fix your mistakes.
================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_k9dHasX8Gh6kqFKFZkSthc8b)
 Call ID: call_k9dHasX8Gh6kqFKFZkSthc8b
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/rtl/kmac_errchk.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // KMAC Error Checking logic
6: //
7: // `kmac_err` module checks the SW introduced errors.
8: //  1. SW command sequencing error.
9: //  2. SW configuration error.
10: //
11: // ## SW Command Sequencing Error
12: //
13: // KMAC assumes the application interface and the SW register interface to
14: // follow the specific sequence. It expects the requester to send the `Start`
15: // command then push the message body. The `Process` command follows the message
16: // body. The SW may issue `Run` command if it needs the digest result more than
17: // a block rate. Then SW completes the hash operation with `Done` command.
18: //
19: // This `kmac_err` module checks if the SW issues the correct command. If not,
20: // it reports the error via ERR_CODE register.
21: //
22: // However, the logic does not prevent the error-ed command to be propagated.
23: // The unexpected commands are filtered by each individual submodule.
24: //
25: // st := { Idle, MsgFeed, Processing, Absorbed, Squeeze}
26: //
27: // allowed := {
28: //   Idle :      { Start     },
29: //   MsgFeed:    { Process   },
30: //   Processing: { None      },
31: //   Absorbed:   { Run, Done },
32: //   Squeeze:    { None      }
33: // }
34: //
35: // ## SW Configuration Error
36: //
37: // `kmac_errchk` module checks if SW configured correct combinations of the
38: // configuration registers when the hashing operation begins.
39: //
40: // 1. Mode & Strength combinations
41: // 2. Kmac Prefix
42: // * sideload & key_valid -> Checker in kmac_core
43: 
44: `include "prim_assert.sv"
45: 
46: module kmac_errchk
47:   import kmac_pkg::*;
48:   import sha3_pkg::sha3_mode_e;
49:   import sha3_pkg::keccak_strength_e;
50: #(
51:   parameter bit EnMasking = 1'b 1
52: ) (
53:   input clk_i,
54:   input rst_ni,
55: 
56:   // Configurations
57:   input sha3_mode_e       cfg_mode_i,
58:   input keccak_strength_e cfg_strength_i,
59: 
60:   input        kmac_en_i,
61:   input [47:0] cfg_prefix_6B_i, // first 6B of PREFIX
62: 
63:   // If the signal below is set, errchk propagates the command to the rest of
64:   // the blocks even with err_modestrength.
65:   input        cfg_en_unsupported_modestrength_i,
66: 
67:   // Entropy Ready Status to check if SW initiated the hahs without entropy cfg
68:   input        entropy_ready_pulse_i,
69: 
70:   // SW commands: Only valid command is sent out to the rest of the modules
71:   input  kmac_cmd_e sw_cmd_i,
72:   output kmac_cmd_e sw_cmd_o,
73: 
74:   // Status from KMAC_APP
75:   input app_active_i,
76: 
77:   // Status from SHA3 core
78:   input prim_mubi_pkg::mubi4_t sha3_absorbed_i,
79:   input keccak_done_i,
80: 
81:   // Life cycle
82:   input  lc_ctrl_pkg::lc_tx_t lc_escalate_en_i,
83: 
84:   // Error processed indicator
85:   input err_processed_i,
86: 
87:   input prim_mubi_pkg::mubi4_t clear_after_error_i,
88: 
89:   output err_t error_o,
90:   output logic sparse_fsm_error_o
91: );
92: 
93:   // sha3_pkg::sha3_mode_e
94:   import sha3_pkg::L128;
95:   import sha3_pkg::L224;
96:   import sha3_pkg::L256;
97:   import sha3_pkg::L384;
98:   import sha3_pkg::L512;
99: 
100:   // sha3_pkg::keccak_strength_e
101:   import sha3_pkg::Sha3;
102:   import sha3_pkg::Shake;
103:   import sha3_pkg::CShake;
104: 
105:   /////////////////
106:   // Definitions //
107:   /////////////////
108:   // Encoding generated with:
109:   // $ ./util/design/sparse-fsm-encode.py -d 3 -m 5 -n 6 \
110:   //      -s 2239170217 --language=sv
111:   //
112:   // Hamming distance histogram:
113:   //
114:   //  0: --
115:   //  1: --
116:   //  2: --
117:   //  3: |||||||||||||||||||| (50.00%)
118:   //  4: |||||||||||||||| (40.00%)
119:   //  5: |||| (10.00%)
120:   //  6: --
121:   //
122:   // Minimum Hamming distance: 3
123:   // Maximum Hamming distance: 5
124:   // Minimum Hamming weight: 2
125:   // Maximum Hamming weight: 4
126:   //
127:   localparam int StateWidth = 6;
128:   typedef enum logic [StateWidth-1:0] {
129:     StIdle = 6'b001101,
130:     StMsgFeed = 6'b110001,
131:     StProcessing = 6'b010110,
132:     StAbsorbed = 6'b100010,
133:     StSqueezing = 6'b111100,
134:     StTerminalError = 6'b011011
135:   } st_e;
136:   st_e st, st_d;
137: 
138:   localparam int StateWidthL = 3;
139:   typedef enum logic [StateWidthL-1:0] {
140:     StIdleL,
141:     StMsgFeedL,
142:     StProcessingL,
143:     StAbsorbedL,
144:     StSqueezingL,
145:     StErrorL
146:   } st_logical_e;
147:   st_logical_e stL;
148: 
149: 
150:   /////////////
151:   // Signals //
152:   /////////////
153: 
154:   // `err_swsequence` occurs when SW issues wrong command
155:   logic err_swsequence;
156: 
157:   // `err_modestrength` occcurs when Mode & Strength combinations are not
158:   // allowed. This error does not block the hashing operation.
159:   // UnexpectedModeStrength may stop the processing based on CFG
160:   // The error raises when SW issues CmdStart.
161:   logic err_modestrength;
162: 
163:   // `err_prefix` occurs when the first 6B of !!PREFIX is not
164:   // `encode_string("KMAC")` and kmac is enabled. This error does not block the
165:   // KMAC operation.
166:   logic err_prefix;
167: 
168:   // `err_entropy_ready` occurs when SW initiated the hashing op. without
169:   // configuring the entropy. This error may happen only when EnMasking is
170:   // set.
171:   logic err_entropy_ready;
172: 
173:   // entropy_ready is a pulse signal. Logic needs to store the state.
174:   logic cfg_entropy_ready;
175: 
176:   // Signal to block the SW command propagation
177:   logic block_swcmd;
178: 
179:   ///////////////////
180:   // Error Checker //
181:   ///////////////////
182: 
183:   // SW sequence Error
184:   // info field: Current state, Received command
185:   // SEC_CM: FSM.SPARSE
186:   always_comb begin
187:     err_swsequence = 1'b 0;
188:     sparse_fsm_error_o = 1'b 0;
189: 
190:     unique case (st)
191:       StIdle: begin
192:         // Allow Start command only
193:         if (!(sw_cmd_i inside {CmdNone, CmdStart})) begin
194:           err_swsequence = 1'b 1;
195:         end
196:       end
197: 
198:       StMsgFeed: begin
199:         // Allow Process only
200:         if (!(sw_cmd_i inside {CmdNone, CmdProcess})) begin
201:           err_swsequence = 1'b 1;
202:         end
203:       end
204: 
205:       StProcessing: begin
206:         if (sw_cmd_i != CmdNone) begin
207:           err_swsequence = 1'b 1;
208:         end
209:       end
210: 
211:       StAbsorbed: begin
212:         // Allow ManualRun and Done
213:         if (!(sw_cmd_i inside {CmdNone, CmdManualRun, CmdDone})) begin
214:           err_swsequence = 1'b 1;
215:         end
216:       end
217: 
218:       StSqueezing: begin
219:         if (sw_cmd_i != CmdNone) begin
220:           err_swsequence = 1'b 1;
221:         end
222:       end
223: 
224:       StTerminalError: begin
225:         err_swsequence = 1'b 0;
226:         sparse_fsm_error_o = 1'b 1;
227:       end
228: 
229:       default: begin
230:         err_swsequence = 1'b 0;
231:         sparse_fsm_error_o = 1'b 1;
232:       end
233:     endcase
234:   end
235: 
236:   assign block_swcmd =  (err_swsequence)
237:                      || (err_modestrength
238:                          && !cfg_en_unsupported_modestrength_i)
239:                      || err_entropy_ready;
240: 
241:   // sw_cmd_o latch
242:   // To reduce the command path delay, sw_cmd is latched here
243:   always_ff @(posedge clk_i or negedge rst_ni) begin
244:     if (!rst_ni)           sw_cmd_o <= CmdNone;
245:     else if (!block_swcmd) sw_cmd_o <= sw_cmd_i;
246:   end
247: 
248:   // Mode & Strength
249:   always_comb begin : check_modestrength
250:     err_modestrength = 1'b 0;
251: 
252:     if (st == StIdle && st_d == StMsgFeed) begin
253:       // When moving to the next stage, checks the config
254:       if (!((cfg_mode_i == Sha3 &&
255:              cfg_strength_i inside {L224, L256, L384, L512}) ||
256:             ((cfg_mode_i == Shake || cfg_mode_i == CShake) &&
257:              (cfg_strength_i inside {L128, L256})))) begin
258:         err_modestrength = 1'b 1;
259:       end
260:     end
261:   end : check_modestrength
262: 
263: 
264:   // Check prefix 6B is `encode_string("KMAC")`
265:   always_comb begin : check_prefix
266:     err_prefix = 1'b 0;
267: 
268:     if (st == StIdle && st_d == StMsgFeed && kmac_en_i) begin
269:       if (cfg_prefix_6B_i != EncodedStringKMAC) begin
270:         err_prefix = 1'b 1;
271:       end
272:     end
273:   end : check_prefix
274: 
275:   if (EnMasking) begin : g_entropy_chk
276: 
277:     always_ff @(posedge clk_i or negedge rst_ni) begin
278:       if (!rst_ni)              cfg_entropy_ready <= 1'b 0;
279:       else if (err_processed_i) cfg_entropy_ready <= 1'b 0;
280:       else if (entropy_ready_pulse_i && st == StIdle) begin
281:         cfg_entropy_ready <= 1'b 1;
282:       end
283:     end
284: 
285:     always_comb begin : check_entropy_ready
286:       err_entropy_ready = 1'b 0;
287: 
288:       if (st == StIdle && st_d == StMsgFeed && kmac_en_i) begin
289:         if (!cfg_entropy_ready) begin
290:           err_entropy_ready = 1'b 1;
291:         end
292:       end
293:     end : check_entropy_ready
294: 
295:   end else begin : g_pseudo_entropy_chk
296: 
297:     // If EnMasking is 0, entropy module is not generated.
298:     // tying the error signal to 0.
299:     assign err_entropy_ready = 1'b 0;
300: 
301:     assign cfg_entropy_ready = 1'b 1;
302: 
303:     logic unused_cfg_entropy_ready;
304:     assign unused_cfg_entropy_ready = cfg_entropy_ready;
305: 
306:   end
307: 
308:   always_comb begin : recode_st
309:     unique case (st)
310:       StIdle       : stL = StIdleL;
311:       StMsgFeed    : stL = StMsgFeedL;
312:       StProcessing : stL = StProcessingL;
313:       StAbsorbed   : stL = StAbsorbedL;
314:       StSqueezing  : stL = StSqueezingL;
315:       default      : stL = StErrorL;
316:     endcase
317:   end : recode_st
318: 
319:   // Return error code
320:   err_t err;
321:   always_comb begin : err_return
322:     err = '{valid: 1'b0, code: ErrNone, info: '0};
323: 
324:     priority case (1'b 1)
325:       err_swsequence: begin
326:         err = '{ valid: 1'b 1,
327:                  code: ErrSwCmdSequence,
328:                  info: {5'h0,
329:                         {err_swsequence, err_modestrength, err_prefix},
330:                         {5'h 0, stL},
331:                         {2'b0, sw_cmd_i}
332:                        }
333:                };
334:       end
335: 
336:       err_modestrength: begin
337:         err = '{ valid: 1'b 1,
338:                  code:  ErrUnexpectedModeStrength,
339:                  info:  { 5'h 0,
340:                           {err_swsequence, err_modestrength, err_prefix},
341:                           8'h 0,
342:                           {2'b 00, cfg_mode_i},
343:                           {1'b 0,  cfg_strength_i}
344:                         }
345:                };
346:       end
347: 
348:       err_prefix: begin
349:         err = '{ valid: 1'b 1,
350:                  code:  ErrIncorrectFunctionName,
351:                  info:  { 5'h 0,
352:                           {err_swsequence, err_modestrength, err_prefix},
353:                           16'h 0000
354:                         }
355:                };
356:       end
357: 
358:       err_entropy_ready: begin
359:         err = '{ valid: 1'b 1,
360:                  code:  ErrSwHashingWithoutEntropyReady,
361:                  info:  { 8'({ err_entropy_ready,
362:                                err_swsequence,
363:                                err_modestrength,
364:                                err_prefix}),
365:                           16'({kmac_en_i, cfg_entropy_ready})
366:                         }
367:                };
368:       end
369: 
370:       default: begin
371:         err = '{valid: 1'b0, code: ErrNone, info: '0};
372:       end
373:     endcase
374:   end : err_return
375: 
376:   assign error_o = err;
377: 
378:   // If below failed, revise err_swsequence error response info field.
379:   `ASSERT_INIT(ExpectedStSwCmdBits_A, $bits(st) == StateWidth && $bits(sw_cmd_i) == 6)
380: 
381:   // If failed, revise err_modestrength error info field.
382:   `ASSERT_INIT(ExpectedModeStrengthBits_A,
383:                $bits(cfg_mode_i) == 2 && $bits(cfg_strength_i) == 3)
384: 
385: 
386:   ///////////////////
387:   // State Machine //
388:   ///////////////////
389:   st_e st_gated_d;
390: 
391:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, st_gated_d, st, st_e, StIdle)
392: 
393:   // ICEBOX(#14631): Move block_swcmd to PRIM_FLOP_SPARSE_FSM()
394:   //
395:   // It would be better to place this condition (block_swcmd) in `always_ff`
396:   // block to clearly indicate the clock gating condition. However, the
397:   // statemachine uses the sparse encoding scheme and macro. It prevents any
398:   // latch enable signals.
399:   assign st_gated_d = (block_swcmd) ? st : st_d ;
400: 
401:   always_comb begin : next_state
402:     st_d = st;
403: 
404:     unique case (st)
405:       StIdle: begin
406:         if (!app_active_i && sw_cmd_i == CmdStart) begin
407:           // Proceed to the next state only when the SW issues the Start command
408:           // in a valid period.
409:           st_d = StMsgFeed;
410:         end
411:       end
412: 
413:       StMsgFeed: begin
414:         if (sw_cmd_i == CmdProcess) begin
415:           st_d = StProcessing;
416:         end
417:       end
418: 
419:       StProcessing: begin
420:         if (prim_mubi_pkg::mubi4_test_true_strict(sha3_absorbed_i)) begin
421:           st_d = StAbsorbed;
422:         end
423:       end
424: 
425:       StAbsorbed: begin
426:         if (sw_cmd_i == CmdManualRun) begin
427:           st_d = StSqueezing;
428:         end else if (sw_cmd_i == CmdDone) begin
429:           st_d = StIdle;
430:         end
431:       end
432: 
433:       StSqueezing: begin
434:         if (keccak_done_i) begin
435:           st_d = StAbsorbed;
436:         end
437:       end
438: 
439:       StTerminalError: begin
440:         // this state is terminal
441:         st_d = st;
442:       end
443: 
444:       default: begin
445:         // this state is terminal
446:         st_d = StTerminalError;
447:       end
448:     endcase
449: 
450:     // SEC_CM: FSM.GLOBAL_ESC, FSM.LOCAL_ESC
451:     // Unconditionally jump into the terminal error state
452:     // if the life cycle controller triggers an escalation.
453:     if (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) begin
454:       st_d = StTerminalError;
455:     end
456: 
457:     if (st_d != StTerminalError &&
458:         prim_mubi_pkg::mubi4_test_true_strict(clear_after_error_i)) begin
459:       st_d = StIdle;
460:     end
461:   end : next_state
462:   `ASSERT_KNOWN(StKnown_A, st)
463: 
464: endmodule : kmac_errchk

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_vIFoI9p6XFqvVeUhcafXc2sn)
 Call ID: call_vIFoI9p6XFqvVeUhcafXc2sn
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/rtl/kmac_app.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // KMAC Application interface
6: 
7: `include "prim_assert.sv"
8: 
9: module kmac_app
10:   import kmac_pkg::*;
11: #(
12:   // App specific configs are defined in kmac_pkg
13:   parameter  bit          EnMasking          = 1'b0,
14:   localparam int          Share              = (EnMasking) ? 2 : 1, // derived parameter
15:   parameter  bit          SecIdleAcceptSwMsg = 1'b0,
16:   parameter  int unsigned NumAppIntf         = 3,
17:   parameter  app_config_t AppCfg[NumAppIntf] = '{AppCfgKeyMgr, AppCfgLcCtrl, AppCfgRomCtrl}
18: ) (
19:   input clk_i,
20:   input rst_ni,
21: 
22:   // Secret Key from register
23:   input [MaxKeyLen-1:0] reg_key_data_i [Share],
24:   input key_len_e       reg_key_len_i,
25: 
26:   // Prefix from register
27:   input [sha3_pkg::NSRegisterSize*8-1:0] reg_prefix_i,
28: 
29:   // mode, strength, kmac_en from register
30:   input                             reg_kmac_en_i,
31:   input sha3_pkg::sha3_mode_e       reg_sha3_mode_i,
32:   input sha3_pkg::keccak_strength_e reg_keccak_strength_i,
33: 
34:   // Data from Software
35:   input                sw_valid_i,
36:   input [MsgWidth-1:0] sw_data_i,
37:   input [MsgWidth-1:0] sw_mask_i,
38:   output logic         sw_ready_o,
39: 
40:   // KeyMgr Sideload Key interface
41:   input keymgr_pkg::hw_key_req_t keymgr_key_i,
42: 
43:   // Application Message in/ Digest out interface + control signals
44:   input  app_req_t [NumAppIntf-1:0] app_i,
45:   output app_rsp_t [NumAppIntf-1:0] app_o,
46: 
47:   // to KMAC Core: Secret key
48:   output logic [MaxKeyLen-1:0] key_data_o [Share],
49:   output key_len_e             key_len_o,
50:   output logic                 key_valid_o,
51: 
52:   // to MSG_FIFO
53:   output logic                kmac_valid_o,
54:   output logic [MsgWidth-1:0] kmac_data_o,
55:   output logic [MsgWidth-1:0] kmac_mask_o,
56:   input                       kmac_ready_i,
57: 
58:   // KMAC Core
59:   output logic kmac_en_o,
60: 
61:   // To Sha3 Core
62:   output logic [sha3_pkg::NSRegisterSize*8-1:0] sha3_prefix_o,
63:   output sha3_pkg::sha3_mode_e                  sha3_mode_o,
64:   output sha3_pkg::keccak_strength_e            keccak_strength_o,
65: 
66:   // STATE from SHA3 Core
67:   input                        keccak_state_valid_i,
68:   input [sha3_pkg::StateW-1:0] keccak_state_i [Share],
69: 
70:   // to STATE TL-window if Application is not active, the incoming state goes to
71:   // register if kdf_en is set, the state value goes to application and the
72:   // output to the register is all zero.
73:   output logic                        reg_state_valid_o,
74:   output logic [sha3_pkg::StateW-1:0] reg_state_o [Share],
75: 
76:   // Configurations If key_en is set, the logic uses KeyMgr's sideloaded key as
77:   // a secret key rather than register values. This only affects when software
78:   // initiates. If App initiates the hash operation and uses KMAC algorithm, it
79:   // always uses sideloaded key.
80:   input keymgr_key_en_i,
81: 
82:   // Commands
83:   // Command from software
84:   input kmac_cmd_e sw_cmd_i,
85: 
86:   // from SHA3
87:   input prim_mubi_pkg::mubi4_t absorbed_i,
88: 
89:   // to KMAC
90:   output kmac_cmd_e cmd_o,
91: 
92:   // to SW
93:   output prim_mubi_pkg::mubi4_t absorbed_o,
94: 
95:   // To status
96:   output logic app_active_o,
97: 
98:   // Status
99:   // - entropy_ready_i: Entropy configured by SW. It is used to check if App
100:   //                    is OK to request.
101:   input prim_mubi_pkg::mubi4_t entropy_ready_i,
102: 
103:   // Error input
104:   // This error comes from KMAC/SHA3 engine.
105:   // KeyMgr interface delivers the error signal to KeyMgr to drop the current op
106:   // and re-initiate.
107:   // If error happens, regardless of SW-initiated or KeyMgr-initiated, the error
108:   // is reported to the ERR_CODE so that SW can look into.
109:   input error_i,
110: 
111:   // SW sets err_processed bit in CTRL then the logic goes to Idle
112:   input err_processed_i,
113: 
114:   output prim_mubi_pkg::mubi4_t clear_after_error_o,
115: 
116:   // error_o value is pushed to Error FIFO at KMAC/SHA3 top and reported to SW
117:   output kmac_pkg::err_t error_o,
118: 
119:   // Life cycle
120:   input  lc_ctrl_pkg::lc_tx_t lc_escalate_en_i,
121: 
122:   output logic sparse_fsm_error_o
123: );
124: 
125:   import sha3_pkg::KeccakBitCapacity;
126:   import sha3_pkg::L128;
127:   import sha3_pkg::L224;
128:   import sha3_pkg::L256;
129:   import sha3_pkg::L384;
130:   import sha3_pkg::L512;
131: 
132:   /////////////////
133:   // Definitions //
134:   /////////////////
135: 
136:   // Digest width is same to the key width `keymgr_pkg::KeyWidth`.
137:   localparam int KeyMgrKeyW = $bits(keymgr_key_i.key[0]);
138: 
139:   localparam key_len_e KeyLengths [5] = '{Key128, Key192, Key256, Key384, Key512};
140: 
141:   localparam int SelKeySize = (AppKeyW == 128) ? 0 :
142:                               (AppKeyW == 192) ? 1 :
143:                               (AppKeyW == 256) ? 2 :
144:                               (AppKeyW == 384) ? 3 :
145:                               (AppKeyW == 512) ? 4 : 0 ;
146:   localparam int SelDigSize = (AppDigestW == 128) ? 0 :
147:                               (AppDigestW == 192) ? 1 :
148:                               (AppDigestW == 256) ? 2 :
149:                               (AppDigestW == 384) ? 3 :
150:                               (AppDigestW == 512) ? 4 : 0 ;
151:   localparam key_len_e SideloadedKey = KeyLengths[SelKeySize];
152: 
153:   // Define right_encode(outlen) value here
154:   // Look at kmac_pkg::key_len_e for the kinds of key size
155:   //
156:   // These values should be exactly the same as the key length encodings
157:   // in kmac_core.sv, with the only difference being that the byte representing
158:   // the byte-length of the encoded value is in the MSB position due to right encoding
159:   // instead of in the LSB position (left encoding).
160:   localparam int OutLenW = 24;
161:   localparam logic [OutLenW-1:0] EncodedOutLen [5]= '{
162:     24'h 0001_80, // Key128
163:     24'h 0001_C0, // Key192
164:     24'h 02_0001, // Key256
165:     24'h 02_8001, // Key384
166:     24'h 02_0002  // Key512
167:   };
168: 
169:   localparam logic [OutLenW-1:0] EncodedOutLenMask [5] = '{
170:     24'h 00FFFF, // Key128,
171:     24'h 00FFFF, // Key192
172:     24'h FFFFFF, // Key256
173:     24'h FFFFFF, // Key384
174:     24'h FFFFFF  // Key512
175:   };
176: 
177:   /////////////
178:   // Signals //
179:   /////////////
180: 
181:   st_e st, st_d;
182: 
183:   logic keymgr_key_used;
184: 
185:   // app_rsp_t signals
186:   // The state machine controls mux selection, which controls the ready signal
187:   // the other responses are controled in separate logic. So define the signals
188:   // here and merge them to the response.
189:   logic app_data_ready, fsm_data_ready;
190:   logic app_digest_done, fsm_digest_done_q, fsm_digest_done_d;
191:   logic [AppDigestW-1:0] app_digest [2];
192: 
193:   // One more slot for value NumAppIntf. It is the value when no app intf is
194:   // chosen.
195:   localparam int unsigned AppIdxW = $clog2(NumAppIntf);
196: 
197:   // app_id indicates, which app interface was chosen. various logic use this
198:   // value to get the config or return the data.
199:   logic [AppIdxW-1:0] app_id, app_id_d;
200:   logic               clr_appid, set_appid;
201: 
202:   // Output length
203:   logic [OutLenW-1:0] encoded_outlen, encoded_outlen_mask;
204: 
205:   // state output
206:   // Mux selection signal
207:   app_mux_sel_e mux_sel;
208:   app_mux_sel_e mux_sel_buf_output;
209:   app_mux_sel_e mux_sel_buf_err_check;
210:   app_mux_sel_e mux_sel_buf_kmac;
211: 
212:   // Error checking logic
213: 
214:   kmac_pkg::err_t fsm_err, mux_err;
215: 
216:   logic service_rejected_error;
217:   logic service_rejected_error_set, service_rejected_error_clr;
218:   logic err_during_sw_d, err_during_sw_q;
219: 
220:   always_ff @(posedge clk_i or negedge rst_ni) begin
221:     if (!rst_ni)                         service_rejected_error <= 1'b 0;
222:     else if (service_rejected_error_set) service_rejected_error <= 1'b 1;
223:     else if (service_rejected_error_clr) service_rejected_error <= 1'b 0;
224:   end
225: 
226:   ////////////////////////////
227:   // Application Mux/ Demux //
228:   ////////////////////////////
229: 
230: 
231:   // Processing return data.
232:   // sends to only selected app intf.
233:   // clear digest right after done to not leak info to other interface
234:   always_comb begin
235:     for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
236:       if (i == app_id) begin
237:         app_o[i] = '{
238:           ready:         app_data_ready | fsm_data_ready,
239:           done:          app_digest_done | fsm_digest_done_q,
240:           digest_share0: app_digest[0],
241:           digest_share1: app_digest[1],
242:           // if fsm asserts done, should be an error case.
243:           error:         error_i | fsm_digest_done_q | sparse_fsm_error_o
244:                          | service_rejected_error
245:         };
246:       end else begin
247:         app_o[i] = '{
248:           ready: 1'b 0,
249:           done:  1'b 0,
250:           digest_share0: '0,
251:           digest_share1: '0,
252:           error: 1'b 0
253:         };
254:       end
255:     end // for {i, NumAppIntf, i++}
256:   end // aiways_comb
257: 
258:   // app_id latch
259:   always_ff @(posedge clk_i or negedge rst_ni) begin
260:     if (!rst_ni) app_id <= AppIdxW'(0) ; // Do not select any
261:     else if (clr_appid) app_id <= AppIdxW'(0);
262:     else if (set_appid) app_id <= app_id_d;
263:   end
264: 
265:   // app_id selection as of now, app_id uses Priority. The assumption is that
266:   //  the request normally does not collide. (ROM_CTRL activates very early
267:   //  stage at the boot sequence)
268:   //
269:   //  If this assumption is not true, consider RR arbiter.
270: 
271:   // Prep for arbiter
272:   logic [NumAppIntf-1:0] app_reqs;
273:   logic [NumAppIntf-1:0] unused_app_gnts;
274:   logic [$clog2(NumAppIntf)-1:0] arb_idx;
275:   logic arb_valid;
276:   logic arb_ready;
277: 
278:   always_comb begin
279:     app_reqs = '0;
280:     for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
281:       app_reqs[i] = app_i[i].valid;
282:     end
283:   end
284: 
285:   prim_arbiter_fixed #(
286:     .N (NumAppIntf),
287:     .DW(1),
288:     .EnDataPort(1'b 0)
289:   ) u_appid_arb (
290:     .clk_i,
291:     .rst_ni,
292: 
293:     .req_i  (app_reqs),
294:     .data_i ('{default:'0}),
295:     .gnt_o  (unused_app_gnts),
296:     .idx_o  (arb_idx),
297: 
298:     .valid_o (arb_valid),
299:     .data_o  (), // not used
300:     .ready_i (arb_ready)
301:   );
302: 
303:   assign app_id_d = AppIdxW'(arb_idx);
304:   assign arb_ready = set_appid;
305: 
306:   always_ff @(posedge clk_i or negedge rst_ni) begin
307:     if (!rst_ni) fsm_digest_done_q <= 1'b 0;
308:     else         fsm_digest_done_q <= fsm_digest_done_d;
309:   end
310: 
311:   /////////
312:   // FSM //
313:   /////////
314: 
315:   // State register
316:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, st_d, st, st_e, StIdle)
317: 
318:   // Create a lint error to reduce the risk of accidentally enabling this feature.
319:   `ASSERT_STATIC_LINT_ERROR(KmacSecIdleAcceptSwMsgNonDefault, SecIdleAcceptSwMsg == 0)
320: 
321:   // Next State & output logic
322:   // SEC_CM: FSM.SPARSE
323:   always_comb begin
324:     st_d = st;
325: 
326:     mux_sel = SecIdleAcceptSwMsg ? SelSw : SelNone;
327: 
328:     // app_id control
329:     set_appid = 1'b 0;
330:     clr_appid = 1'b 0;
331: 
332:     // Commands
333:     cmd_o = CmdNone;
334: 
335:     // Software output
336:     absorbed_o = prim_mubi_pkg::MuBi4False;
337: 
338:     // Error
339:     fsm_err = '{valid: 1'b 0, code: ErrNone, info: '0};
340:     sparse_fsm_error_o = 1'b 0;
341: 
342:     clear_after_error_o = prim_mubi_pkg::MuBi4False;
343: 
344:     service_rejected_error_set = 1'b 0;
345:     service_rejected_error_clr = 1'b 0;
346: 
347:     // If error happens, FSM asserts data ready but discard incoming msg
348:     fsm_data_ready = 1'b 0;
349:     fsm_digest_done_d = 1'b 0;
350: 
351:     unique case (st)
352:       StIdle: begin
353:         if (arb_valid) begin
354:           st_d = StAppCfg;
355: 
356:           // choose app_id
357:           set_appid = 1'b 1;
358:         end else if (sw_cmd_i == CmdStart) begin
359:           st_d = StSw;
360:           // Software initiates the sequence
361:           cmd_o = CmdStart;
362:         end else begin
363:           st_d = StIdle;
364:         end
365:       end
366: 
367:       StAppCfg: begin
368:         if (AppCfg[app_id].Mode == AppKMAC &&
369:           prim_mubi_pkg::mubi4_test_false_strict(entropy_ready_i)) begin
370:           // Check if the entropy is not configured but it is needed in
371:           // `AppCfg[app_id]` (KMAC mode).
372:           //
373:           // SW is not properly configured, report and not request Hashing
374:           // Return the app with errors
375:           st_d = StError;
376: 
377:           service_rejected_error_set = 1'b 1;
378: 
379:         end else begin
380:           // As Cfg is stable now, it sends cmd
381:           st_d = StAppMsg;
382: 
383:           // App initiates the data
384:           cmd_o = CmdStart;
385:         end
386:       end
387: 
388:       StAppMsg: begin
389:         mux_sel = SelApp;
390:         if (app_i[app_id].valid && app_o[app_id].ready && app_i[app_id].last) begin
391:           if (AppCfg[app_id].Mode == AppKMAC) begin
392:             st_d = StAppOutLen;
393:           end else begin
394:             st_d = StAppProcess;
395:           end
396:         end else begin
397:           st_d = StAppMsg;
398:         end
399:       end
400: 
401:       StAppOutLen: begin
402:         mux_sel = SelOutLen;
403: 
404:         if (kmac_valid_o && kmac_ready_i) begin
405:           st_d = StAppProcess;
406:         end else begin
407:           st_d = StAppOutLen;
408:         end
409:       end
410: 
411:       StAppProcess: begin
412:         cmd_o = CmdProcess;
413:         st_d = StAppWait;
414:       end
415: 
416:       StAppWait: begin
417:         if (prim_mubi_pkg::mubi4_test_true_strict(absorbed_i)) begin
418:           // Send digest to KeyMgr and complete the op
419:           st_d = StIdle;
420:           cmd_o = CmdDone;
421: 
422:           clr_appid = 1'b 1;
423:         end else begin
424:           st_d = StAppWait;
425:         end
426:       end
427: 
428:       StSw: begin
429:         mux_sel = SelSw;
430: 
431:         cmd_o = sw_cmd_i;
432:         absorbed_o = absorbed_i;
433: 
434:         if (sw_cmd_i == CmdDone) begin
435:           st_d = StIdle;
436:         end else begin
437:           st_d = StSw;
438:         end
439:       end
440: 
441:       StKeyMgrErrKeyNotValid: begin
442:         st_d = StError;
443: 
444:         // As mux_sel is not set to SelApp, app_data_ready is still 0.
445:         // This logic won't accept the requests from the selected App.
446:         fsm_err.valid = 1'b 1;
447:         fsm_err.code = ErrKeyNotValid;
448:         fsm_err.info = 24'(app_id);
449:       end
450: 
451:       StError: begin
452:         // In this state, the state machine flush out the request
453:         st_d = StError;
454: 
455:         // Absorb data on the app interface.
456:         fsm_data_ready = ~err_during_sw_q;
457: 
458:         // Next step depends on two conditions:
459:         // 1) Error being processed by SW
460:         // 2) Last data provided from the app interface (so that the app interface is completely)
461:         //    drained.  If the error occurred during a SW operation, the app interface is not
462:         //    involved, so this condition gets skipped.
463:         unique case ({err_processed_i,
464:                       (app_i[app_id].valid && app_i[app_id].last) || err_during_sw_q})
465:           2'b00: begin
466:             // Error not processed by SW and not last data from app interface -> keep current state.
467:             st_d = StError;
468:           end
469:           2'b01: begin
470:             // Error not processed by SW but last data from app interface:
471:             // 1. Send garbage digest to the app interface (in the next cycle) to complete the
472:             // transaction.
473:             fsm_digest_done_d = ~err_during_sw_q;
474:             if (service_rejected_error) begin
475:               // 2.a) Service was rejected because an app interface tried to configure KMAC while no
476:               // entropy was available. It is assumed that SW is not loaded yet, so don't wait for
477:               // SW to process the error. The last data from the app interface has now arrived, but
478:               // we don't need to wait for the SHA3 core to have absorbed it because the data never
479:               // entered the SHA3 core: the request from the app interface was terminated during the
480:               // configuration phase.
481:               st_d = StErrorServiceRejected;
482:             end else begin
483:               // 2.b) If service was not rejected, wait for SW to process the error.
484:               st_d = StErrorAwaitSw;
485:             end
486:           end
487:           2'b10: begin
488:             // Error processed by SW but not last data from app interface -> wait for app interface.
489:             st_d = StErrorAwaitApp;
490:           end
491:           2'b11: begin
492:             // Error processed by SW and last data from app interface:
493:             // Send garbage digest to the app interface (in the next cycle) to complete the
494:             // transaction.
495:             fsm_digest_done_d = ~err_during_sw_q;
496:             // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
497:             // but serves to bring the SHA3 engine back to the idle state).
498:             cmd_o = CmdProcess;
499:             st_d = StErrorWaitAbsorbed;
500:           end
501:           default: st_d = StError;
502:         endcase
503:       end
504: 
505:       StErrorAwaitSw: begin
506:         // Just wait for SW to process the error.
507:         if (err_processed_i) begin
508:           // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
509:           // but serves to bring the SHA3 engine back to the idle state).
510:           cmd_o = CmdProcess;
511:           st_d = StErrorWaitAbsorbed;
512:         end
513:       end
514: 
515:       StErrorAwaitApp: begin
516:         // Keep absorbing data on the app interface until the last data.
517:         fsm_data_ready = 1'b1;
518:         if (app_i[app_id].valid && app_i[app_id].last) begin
519:           // Send garbage digest to the app interface (in the next cycle) to complete the
520:           // transaction.
521:           fsm_digest_done_d = 1'b1;
522:           // Flush the message FIFO and let the SHA3 engine compute a digest (which won't be used
523:           // but serves to bring the SHA3 engine back to the idle state).
524:           cmd_o = CmdProcess;
525:           st_d = StErrorWaitAbsorbed;
526:         end
527:       end
528: 
529:       StErrorWaitAbsorbed: begin
530:         if (prim_mubi_pkg::mubi4_test_true_strict(absorbed_i)) begin
531:           // Clear internal variables, send done command, and return to idle.
532:           clr_appid = 1'b1;
533:           clear_after_error_o = prim_mubi_pkg::MuBi4True;
534:           service_rejected_error_clr = 1'b1;
535:           cmd_o = CmdDone;
536:           st_d = StIdle;
537:           // If error originated from SW, report 'absorbed' to SW.
538:           if (err_during_sw_q) begin
539:             absorbed_o = prim_mubi_pkg::MuBi4True;
540:           end
541:         end
542:       end
543: 
544:       StErrorServiceRejected: begin
545:         // Clear internal variables and return to idle.
546:         clr_appid = 1'b1;
547:         clear_after_error_o = prim_mubi_pkg::MuBi4True;
548:         service_rejected_error_clr = 1'b1;
549:         st_d = StIdle;
550:       end
551: 
552:       StTerminalError: begin
553:         // this state is terminal
554:         st_d = st;
555:         sparse_fsm_error_o = 1'b 1;
556:         fsm_err.valid = 1'b 1;
557:         fsm_err.code = ErrFatalError;
558:         fsm_err.info = 24'(app_id);
559:       end
560: 
561:       default: begin
562:         st_d = StTerminalError;
563:         sparse_fsm_error_o = 1'b 1;
564:       end
565:     endcase
566: 
567:     // SEC_CM: FSM.GLOBAL_ESC, FSM.LOCAL_ESC
568:     // Unconditionally jump into the terminal error state
569:     // if the life cycle controller triggers an escalation.
570:     if (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) begin
571:       st_d = StTerminalError;
572:     end
573: 
574:     // Handle errors outside the terminal error state.
575:     if (st_d != StTerminalError) begin
576:       // Key from keymgr is used but not valid, so abort into the invalid key error state.
577:       if (keymgr_key_used && !keymgr_key_i.valid) begin
578:         st_d = StKeyMgrErrKeyNotValid;
579:       end
580:     end
581:   end
582: 
583:   // Track errors occurring in SW mode.
584:   assign err_during_sw_d =
585:       (mux_sel == SelSw) && (st_d inside {StError, StKeyMgrErrKeyNotValid}) ? 1'b1 : // set
586:       (st_d == StIdle)                                                      ? 1'b0 : // clear
587:       err_during_sw_q;                                                               // hold
588: 
589:   always_ff @(posedge clk_i or negedge rst_ni) begin
590:     if (!rst_ni) begin
591:       err_during_sw_q <= 1'b0;
592:     end else begin
593:       err_during_sw_q <= err_during_sw_d;
594:     end
595:   end
596: 
597:   //////////////
598:   // Datapath //
599:   //////////////
600: 
601:   // Encoded output length
602:   assign encoded_outlen      = EncodedOutLen[SelDigSize];
603:   assign encoded_outlen_mask = EncodedOutLenMask[SelKeySize];
604: 
605:   // Data mux
606:   // This is the main part of the KeyMgr interface logic.
607:   // The FSM selects KeyMgr interface in a cycle after it receives the first
608:   // valid data from KeyMgr. The ready signal to the KeyMgr data interface
609:   // represents the MSG_FIFO ready, only when it is in StKeyMgrMsg state.
610:   // After KeyMgr sends last beat, the kmac interface (to MSG_FIFO) is switched
611:   // to OutLen. OutLen is pre-defined values. See `EncodeOutLen` parameter above.
612:   always_comb begin
613:     app_data_ready = 1'b 0;
614:     sw_ready_o = 1'b 1;
615: 
616:     kmac_valid_o = 1'b 0;
617:     kmac_data_o = '0;
618:     kmac_mask_o = '0;
619: 
620:     unique case (mux_sel_buf_kmac)
621:       SelApp: begin
622:         // app_id is valid at this time
623:         kmac_valid_o = app_i[app_id].valid;
624:         kmac_data_o  = app_i[app_id].data;
625:         // Expand strb to bits. prim_packer inside MSG_FIFO accepts the bit masks
626:         for (int i = 0 ; i < $bits(app_i[app_id].strb) ; i++) begin
627:           kmac_mask_o[8*i+:8] = {8{app_i[app_id].strb[i]}};
628:         end
629:         app_data_ready = kmac_ready_i;
630:       end
631: 
632:       SelOutLen: begin
633:         // Write encoded output length value
634:         kmac_valid_o = 1'b 1; // always write
635:         kmac_data_o  = MsgWidth'(encoded_outlen);
636:         kmac_mask_o  = MsgWidth'(encoded_outlen_mask);
637:       end
638: 
639:       SelSw: begin
640:         kmac_valid_o = sw_valid_i;
641:         kmac_data_o  = sw_data_i ;
642:         kmac_mask_o  = sw_mask_i ;
643:         sw_ready_o   = kmac_ready_i ;
644:       end
645: 
646:       default: begin // Incl. SelNone
647:         kmac_valid_o = 1'b 0;
648:         kmac_data_o = '0;
649:         kmac_mask_o = '0;
650:       end
651: 
652:     endcase
653:   end
654: 
655:   // Error checking for Mux
656:   always_comb begin
657:     mux_err = '{valid: 1'b 0, code: ErrNone, info: '0};
658: 
659:     if (mux_sel_buf_err_check != SelSw && sw_valid_i) begin
660:       // If SW writes message into FIFO
661:       mux_err = '{
662:         valid: 1'b 1,
663:         code: ErrSwPushedMsgFifo,
664:         info: 24'({8'h 00, 8'(st), 8'(mux_sel_buf_err_check)})
665:       };
666:     end else if (app_active_o && sw_cmd_i != CmdNone) begin
667:       // If SW issues command except start
668:       mux_err = '{
669:         valid: 1'b 1,
670:         code: ErrSwIssuedCmdInAppActive,
671:         info: 24'(sw_cmd_i)
672:       };
673:     end
674:   end
675: 
676:   logic [AppMuxWidth-1:0] mux_sel_buf_output_logic;
677:   assign mux_sel_buf_output = app_mux_sel_e'(mux_sel_buf_output_logic);
678: 
679:   // SEC_CM: LOGIC.INTEGRITY
680:   prim_sec_anchor_buf #(
681:    .Width(AppMuxWidth)
682:   ) u_prim_buf_state_output_sel (
683:     .in_i(mux_sel),
684:     .out_o(mux_sel_buf_output_logic)
685:   );
686: 
687:   logic [AppMuxWidth-1:0] mux_sel_buf_err_check_logic;
688:   assign mux_sel_buf_err_check = app_mux_sel_e'(mux_sel_buf_err_check_logic);
689: 
690:   // SEC_CM: LOGIC.INTEGRITY
691:   prim_sec_anchor_buf #(
692:    .Width(AppMuxWidth)
693:   ) u_prim_buf_state_err_check (
694:     .in_i(mux_sel),
695:     .out_o(mux_sel_buf_err_check_logic)
696:   );
697: 
698:   logic [AppMuxWidth-1:0] mux_sel_buf_kmac_logic;
699:   assign mux_sel_buf_kmac = app_mux_sel_e'(mux_sel_buf_kmac_logic);
700: 
701:   // SEC_CM: LOGIC.INTEGRITY
702:   prim_sec_anchor_buf #(
703:    .Width(AppMuxWidth)
704:   ) u_prim_buf_state_kmac_sel (
705:     .in_i(mux_sel),
706:     .out_o(mux_sel_buf_kmac_logic)
707:   );
708: 
709:   // SEC_CM: LOGIC.INTEGRITY
710:   logic reg_state_valid;
711:   prim_sec_anchor_buf #(
712:    .Width(1)
713:   ) u_prim_buf_state_output_valid (
714:     .in_i(reg_state_valid),
715:     .out_o(reg_state_valid_o)
716:   );
717: 
718:   // Keccak state Demux
719:   // Keccak state --> Register output is enabled when state is in StSw
720:   always_comb begin
721:     reg_state_valid = 1'b 0;
722:     reg_state_o = '{default:'0};
723:     if ((mux_sel_buf_output == SelSw) &&
724:          lc_ctrl_pkg::lc_tx_test_false_strict(lc_escalate_en_i)) begin
725:       reg_state_valid = keccak_state_valid_i;
726:       reg_state_o = keccak_state_i;
727:       // If key is sideloaded and KMAC is SW initiated
728:       // hide the capacity from SW by zeroing (see #17508)
729:       if (keymgr_key_en_i) begin
730:         for (int i = 0; i < Share; i++) begin
731:           unique case (reg_keccak_strength_i)
732:             L128: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L128]] = '0;
733:             L224: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L224]] = '0;
734:             L256: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L256]] = '0;
735:             L384: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L384]] = '0;
736:             L512: reg_state_o[i][sha3_pkg::StateW-1-:KeccakBitCapacity[L512]] = '0;
737:             default: reg_state_o[i] = '0;
738:           endcase
739:         end
740:       end
741:     end
742:   end
743: 
744:   // Keccak state --> KeyMgr
745:   always_comb begin
746:     app_digest_done = 1'b 0;
747:     app_digest = '{default:'0};
748:     if (st == StAppWait && prim_mubi_pkg::mubi4_test_true_strict(absorbed_i) &&
749:        lc_ctrl_pkg::lc_tx_test_false_strict(lc_escalate_en_i)) begin
750:       // SHA3 engine has calculated the hash. Return the data to KeyMgr
751:       app_digest_done = 1'b 1;
752: 
753:       // digest has always 2 entries. If !EnMasking, second is tied to 0.
754:       for (int i = 0 ; i < Share ; i++) begin
755:         // Return the portion of state.
756:         app_digest[i] = keccak_state_i[i][AppDigestW-1:0];
757:       end
758:     end
759:   end
760: 
761: 
762:   // Secret Key Mux
763: 
764:   // Prepare merged key if EnMasking is not set.
765:   // Combine share keys into unpacked array for logic below to assign easily.
766:   // SEC_CM: KEY.SIDELOAD
767:   logic [MaxKeyLen-1:0] keymgr_key [Share];
768:   if (EnMasking == 1) begin : g_masked_key
769:     for (genvar i = 0; i < Share; i++) begin : gen_key_pad
770:       assign keymgr_key[i] =  {(MaxKeyLen-KeyMgrKeyW)'(0), keymgr_key_i.key[i]};
771:     end
772:   end else begin : g_unmasked_key
773:     always_comb begin
774:       keymgr_key[0] = '0;
775:       for (int i = 0; i < keymgr_pkg::Shares; i++) begin
776:         keymgr_key[0][KeyMgrKeyW-1:0] ^= keymgr_key_i.key[i];
777:       end
778:     end
779:   end
780: 
781:   // Sideloaded key manage: Keep use sideloaded key for KMAC AppIntf until the
782:   // hashing operation is finished.
783:   always_comb begin
784:     keymgr_key_used = 1'b0;
785:     key_len_o  = reg_key_len_i;
786:     for (int i = 0 ; i < Share; i++) begin
787:       key_data_o[i] = reg_key_data_i[i];
788:     end
789:     // The key is considered invalid in all cases that are not listed below (which includes idle and
790:     // error states).
791:     key_valid_o = 1'b0;
792: 
793:     unique case (st)
794:       StAppCfg, StAppMsg, StAppOutLen, StAppProcess, StAppWait: begin
795:         // Key from keymgr is actually used if the current HW app interface does *keyed* MAC.
796:         keymgr_key_used = AppCfg[app_id].Mode == AppKMAC;
797:         key_len_o = SideloadedKey;
798:         for (int i = 0 ; i < Share; i++) begin
799:           key_data_o[i] = keymgr_key[i];
800:         end
801:         // Key is valid if the current HW app interface does *keyed* MAC and the key provided by
802:         // keymgr is valid.
803:         key_valid_o = keymgr_key_used && keymgr_key_i.valid;
804:       end
805: 
806:       StSw: begin
807:         if (keymgr_key_en_i) begin
808:           // Key from keymgr is actually used if *keyed* MAC is enabled.
809:           keymgr_key_used = kmac_en_o;
810:           key_len_o = SideloadedKey;
811:           for (int i = 0 ; i < Share; i++) begin
812:             key_data_o[i] = keymgr_key[i];
813:           end
814:         end
815:         // Key is valid if SW does *keyed* MAC and ...
816:         if (kmac_en_o) begin
817:           if (!keymgr_key_en_i) begin
818:             // ... it uses the key from kmac's CSR, or ...
819:             key_valid_o = 1'b1;
820:           end else begin
821:             // ... it uses the key provided by keymgr and that one is valid.
822:             key_valid_o = keymgr_key_i.valid;
823:           end
824:         end
825:       end
826: 
827:       default: ;
828:     endcase
829:   end
830: 
831:   // Prefix Demux
832:   // For SW, always prefix register.
833:   // For App intf, check PrefixMode cfg and if 1, use Prefix cfg.
834:   always_comb begin
835:     sha3_prefix_o = '0;
836: 
837:     unique case (st)
838:       StAppCfg, StAppMsg, StAppOutLen, StAppProcess, StAppWait: begin
839:         // Check app intf cfg
840:         for (int unsigned i = 0 ; i < NumAppIntf ; i++) begin
841:           if (app_id == i) begin
842:             if (AppCfg[i].PrefixMode == 1'b 0) begin
843:               sha3_prefix_o = reg_prefix_i;
844:             end else begin
845:               sha3_prefix_o = AppCfg[i].Prefix;
846:             end
847:           end
848:         end
849:       end
850: 
851:       StSw: begin
852:         sha3_prefix_o = reg_prefix_i;
853:       end
854: 
855:       default: begin
856:         sha3_prefix_o = reg_prefix_i;
857:       end
858:     endcase
859:   end
860: 
861:   // KMAC en / SHA3 mode / Strength
862:   //  by default, it uses reg cfg. When app intf reqs come, it uses AppCfg.
863:   always_ff @(posedge clk_i or negedge rst_ni) begin
864:     if (!rst_ni) begin
865:       kmac_en_o         <= 1'b 0;
866:       sha3_mode_o       <= sha3_pkg::Sha3;
867:       keccak_strength_o <= sha3_pkg::L256;
868:     end else if (clr_appid) begin
869:       // As App completed, latch reg value
870:       kmac_en_o         <= reg_kmac_en_i;
871:       sha3_mode_o       <= reg_sha3_mode_i;
872:       keccak_strength_o <= reg_keccak_strength_i;
873:     end else if (set_appid) begin
874:       kmac_en_o         <= AppCfg[arb_idx].Mode == AppKMAC ? 1'b 1 : 1'b 0;
875:       sha3_mode_o       <= AppCfg[arb_idx].Mode == AppSHA3
876:                            ? sha3_pkg::Sha3 : sha3_pkg::CShake;
877:       keccak_strength_o <= AppCfg[arb_idx].KeccakStrength ;
878:     end else if (st == StIdle) begin
879:       kmac_en_o         <= reg_kmac_en_i;
880:       sha3_mode_o       <= reg_sha3_mode_i;
881:       keccak_strength_o <= reg_keccak_strength_i;
882:     end
883:   end
884: 
885:   // Status
886:   assign app_active_o = (st inside {StAppCfg, StAppMsg, StAppOutLen,
887:                                     StAppProcess, StAppWait});
888: 
889:   // Error Reporting ==========================================================
890:   always_comb begin
891:     priority casez ({fsm_err.valid, mux_err.valid})
892:       2'b ?1: error_o = mux_err;
893:       2'b 10: error_o = fsm_err;
894:       default: error_o = '{valid: 1'b0, code: ErrNone, info: '0};
895:     endcase
896:   end
897: 
898:   ////////////////
899:   // Assertions //
900:   ////////////////
901: 
902:   // KeyMgr sideload key and the digest should be in the Key Length value
903:   `ASSERT_INIT(SideloadKeySameToDigest_A, KeyMgrKeyW <= AppDigestW)
904:   `ASSERT_INIT(AppIntfInRange_A, AppDigestW inside {128, 192, 256, 384, 512})
905: 
906:   // Issue(#13655): Having a coverage that sideload keylen and CSR keylen are
907:   // different.
908:   `COVER(AppIntfUseDifferentSizeKey_C,
909:     (st == StAppCfg && kmac_en_o) |-> reg_key_len_i != SideloadedKey)
910: 
911: endmodule

================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_KhG8S5DbVL6dvkfb9KZwsimz)
 Call ID: call_KhG8S5DbVL6dvkfb9KZwsimz
  Args:
    design_filepath: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/rtl/kmac.sv
    top_module: kmac
    security_objective: Misuse of entropy and masking leading to side-channel weakness (CWE-331, CWE-330, CWE-1191)
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

[{"id": "toolu_01AhZLLn1pVW8BL2AZmWALSD", "input": {"security_issue": "CWE-1191 On-Chip Debug and Test Interface With Improper Access Control"}, "name": "llm_cwe_details_retriever_tool", "type": "tool_use"}]
================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_PXO8DmxiEdcUeZw9wgHwcvt1)
 Call ID: call_PXO8DmxiEdcUeZw9wgHwcvt1
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/rtl/sha3.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // SHA3 core is a fully functional SHA3/SHAKE/cSHAKE hashing module.
6: //
7: // It instantiates a keccak_round with 1600 bits of the state.
8: 
9: `include "prim_assert.sv"
10: 
11: module sha3
12:   import sha3_pkg::*;
13: #(
14:   // Enable Masked Keccak if 1
15:   parameter  bit EnMasking = 0,
16:   // derived parameter
17:   localparam int Share = (EnMasking) ? 2 : 1
18: ) (
19:   input clk_i,
20:   input rst_ni,
21: 
22:   // MSG interface
23:   input                       msg_valid_i,
24:   input        [MsgWidth-1:0] msg_data_i [Share],
25:   input        [MsgStrbW-1:0] msg_strb_i,         // one strobe for shares
26:   output logic                msg_ready_o,
27: 
28:   // Entropy interface
29:   input                     rand_valid_i,
30:   input                     rand_early_i,
31:   input      [StateW/2-1:0] rand_data_i,
32:   input                     rand_aux_i,
33:   output logic              rand_update_o,
34:   output logic              rand_consumed_o,
35: 
36:   // N, S: Used in cSHAKE mode only
37:   input [NSRegisterSize*8-1:0] ns_data_i, // See sha3_pkg for details
38: 
39:   // configurations
40:   input sha3_mode_e       mode_i,     // see sha3pad for details
41:   input keccak_strength_e strength_i, // see sha3pad for details
42: 
43:   // controls
44:   input start_i,   // see sha3pad for details
45:   input process_i, // see sha3pad for details
46: 
47:   // run_i is a pulse signal to trigger the keccak_round manually by SW.
48:   // It is used to run additional keccak_f after sponge absorbing is completed.
49:   // See `keccak_run` signal
50:   input                        run_i,
51:   input prim_mubi_pkg::mubi4_t done_i,    // see sha3pad for details
52: 
53:   output prim_mubi_pkg::mubi4_t absorbed_o,
54:   output logic                  squeezing_o,
55: 
56:   // Indicate of one block processed. KMAC main state tracks the progression
57:   // based on this signal.
58:   output logic block_processed_o,
59: 
60:   output sha3_st_e sha3_fsm_o,
61: 
62:   // digest output
63:   // This value is valid only after all absorbing process is completed.
64:   // In invalid state, the output `state` will be zero to prevent information
65:   // leakage.
66:   output logic              state_valid_o,
67:   output logic [StateW-1:0] state_o [Share],
68: 
69:   // REQ/ACK interface for the Keccak core. This can be used to delay the
70:   // processing e.g. to avoid power spikes at the chip level due to too many
71:   // blocks being active simultaneously.
72:   output logic run_req_o,
73:   input        run_ack_i,
74: 
75:   // Life cycle
76:   input  lc_ctrl_pkg::lc_tx_t lc_escalate_en_i,
77: 
78:   // error_o value is pushed to Error FIFO at KMAC/SHA3 top and reported to SW
79:   output err_t error_o,
80: 
81:   // sparse_fsm_alert
82:   output logic sparse_fsm_error_o,
83: 
84:   // counter error
85:   output logic count_error_o,
86: 
87:   // error on rst_storage in Keccak
88:   output logic keccak_storage_rst_error_o
89: 
90: );
91:   /////////////////
92:   // Definitions //
93:   /////////////////
94: 
95:   typedef enum logic[2:0] {
96:     MuxGuard   = 3'b 010,
97:     MuxRelease = 3'b 101
98:   } state_mux_sel_e;
99: 
100:   /////////////
101:   // Signals //
102:   /////////////
103: 
104:   // State --> Digest
105:   // State is exposed to the outside if the hashing process is completed.
106:   logic              state_valid;
107:   logic [StateW-1:0] state [Share];
108:   logic [StateW-1:0] state_guarded [Share];
109: 
110:   // State --> digest mux select signal
111:   state_mux_sel_e mux_sel;
112: 
113:   // absorbed is a pulse signal that indicates sponge absorbing is done.
114:   // After this, sha3 core allows software to manually run until squeezing
115:   // is completed, which is the `done_i` pulse signal.
116:   prim_mubi_pkg::mubi4_t absorbed;
117: 
118:   // `squeezing` is a status indicator that SHA3 core is in sponge squeezing
119:   // stage. In this stage, the state output is valid, and software can manually
120:   // trigger keccak_round logic to get more digest outputs in case the output
121:   // length is bigger than the block limit.
122:   logic squeezing;
123: 
124:   // If process_i is received, the logic initiates the final absorbing process.
125:   // While absorbing, the processing inticator is turned on. This signal is used
126:   // to check if multiple process_i is received or not.
127:   logic processing;
128: 
129:   // FSM variable
130:   sha3_st_sparse_e st, st_d;
131: 
132:   // Keccak control signal (filtered by State Machine)
133:   logic keccak_start, keccak_process;
134:   prim_mubi_pkg::mubi4_t keccak_done;
135: 
136:   // alert signals
137:   logic round_count_error, msg_count_error;
138:   assign count_error_o =  round_count_error | msg_count_error;
139: 
140:   logic sha3_state_error;
141:   logic keccak_round_state_error;
142:   logic sha3pad_state_error;
143: 
144:   assign sparse_fsm_error_o = sha3_state_error | keccak_round_state_error | sha3pad_state_error;
145: 
146:   // Keccak rst_storage is asserted unexpectedly
147:   logic keccak_storage_rst_error;
148:   assign keccak_storage_rst_error_o = keccak_storage_rst_error;
149: 
150:   /////////////////
151:   // Connections //
152:   /////////////////
153: 
154:   logic                       keccak_valid;
155:   logic [KeccakMsgAddrW-1:0]  keccak_addr;
156:   logic [MsgWidth-1:0]        keccak_data [Share];
157:   logic                       keccak_ready;
158: 
159:   // Keccak round run signal can be controlled by sha3pad and also by software
160:   // after all message feeding is done. it is mainly used for sponge squeezing
161:   // operation after absorbing is completed when output length is longer than
162:   // the block size.
163:   logic keccak_run, sha3pad_keccak_run, sw_keccak_run;
164:   logic keccak_run_req_d, keccak_run_req_q;
165:   logic keccak_triggered_d, keccak_triggered_q;
166:   logic keccak_complete;
167: 
168:   // Announce that we want to run the Keccak core and tell other blocks to go
169:   // quiet. Keep holding the REQ until the Keccak core is done with the
170:   // processing. The keccak_complete signal is received once the Keccak core
171:   // is back in the Idle state and again susceptible to keccak_run.
172:   assign run_req_o = keccak_run_req_d;
173:   assign keccak_run_req_d =
174:       sha3pad_keccak_run || sw_keccak_run ? 1'b 1 :
175:       keccak_complete                     ? 1'b 0 : keccak_run_req_q;
176: 
177:   // Trigger the Keccak engine with a single pulse upon receiving the ACK.
178:   assign keccak_run = run_req_o & run_ack_i & ~keccak_triggered_q;
179:   assign keccak_triggered_d =
180:       keccak_run      ? 1'b 1 :
181:       keccak_complete ? 1'b 0 : keccak_triggered_q;
182: 
183:   always_ff @(posedge clk_i or negedge rst_ni) begin
184:     if (!rst_ni) begin
185:       keccak_run_req_q <= 1'b 0;
186:       keccak_triggered_q <= 1'b 0;
187:     end else begin
188:       keccak_run_req_q <= keccak_run_req_d;
189:       keccak_triggered_q <= keccak_triggered_d;
190:     end
191:   end
192: 
193:   // Absorb pulse output : used to generate interrupts
194:   // Latch absorbed signal as kmac_keymgr asserts `CmdDone` when it sees
195:   // `absorbed` signal. When this signal goes out, the state is still in
196:   // `StAbsorb`. Next state is `StSqueeze`.
197:   always_ff @(posedge clk_i or negedge rst_ni) begin
198:     if (!rst_ni) absorbed_o <= prim_mubi_pkg::MuBi4False;
199:     else         absorbed_o <= absorbed;
200:   end
201: 
202:   // Squeezing output
203:   assign squeezing_o = squeezing;
204: 
205:   // processing
206:   always_ff @(posedge clk_i or negedge rst_ni) begin
207:     if (!rst_ni)        processing <= 1'b 0;
208:     else if (process_i) processing <= 1'b 1;
209:     else if (prim_mubi_pkg::mubi4_test_true_strict(absorbed)) begin
210:       processing <= 1'b 0;
211:     end
212:   end
213: 
214:   assign block_processed_o = keccak_complete;
215: 
216:   // State connection
217:   assign state_valid_o = state_valid;
218:   assign state_o = state_guarded;
219: 
220:   assign sha3_fsm_o = sparse2logic(st);
221: 
222:   ///////////////////
223:   // State Machine //
224:   ///////////////////
225: 
226:   // State Register
227:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, st_d, st, sha3_st_sparse_e, StIdle_sparse)
228: 
229: 
230:   // Next State and Output Logic
231:   // Mainly the FSM controls the input signal access
232:   // StIdle:    only start_i signal is allowed
233:   // StAbsorb:  only process_i signal is allowed
234:   // StSqueeze: only run_i, done_i signal is allowed
235: 
236:   always_comb begin
237:     st_d = st;
238: 
239:     // default output values
240:     keccak_start = 1'b 0;
241:     keccak_process = 1'b 0;
242:     sw_keccak_run = 1'b 0;
243:     keccak_done = prim_mubi_pkg::MuBi4False;
244: 
245:     squeezing = 1'b 0;
246: 
247:     state_valid = 1'b 0;
248:     mux_sel = MuxGuard ;
249: 
250:     sha3_state_error = 1'b 0;
251: 
252:     unique case (st)
253:       StIdle_sparse: begin
254:         if (start_i) begin
255:           st_d = StAbsorb_sparse;
256: 
257:           keccak_start = 1'b 1;
258:         end else begin
259:           st_d = StIdle_sparse;
260:         end
261:       end
262: 
263:       StAbsorb_sparse: begin
264:         if (process_i && !processing) begin
265:           st_d = StAbsorb_sparse;
266: 
267:           keccak_process = 1'b 1;
268:         end else if (prim_mubi_pkg::mubi4_test_true_strict(absorbed)) begin
269:           st_d = StSqueeze_sparse;
270:         end else begin
271:           st_d = StAbsorb_sparse;
272:         end
273:       end
274: 
275:       StSqueeze_sparse: begin
276:         state_valid = 1'b 1;
277:         mux_sel = MuxRelease; // Expose state to register interface
278: 
279:         squeezing = 1'b 1;
280: 
281:         if (run_i) begin
282:           st_d = StManualRun_sparse;
283: 
284:           sw_keccak_run = 1'b 1;
285:         end else if (prim_mubi_pkg::mubi4_test_true_strict(done_i)) begin
286:           st_d = StFlush_sparse;
287: 
288:           keccak_done = done_i;
289:         end else begin
290:           st_d = StSqueeze_sparse;
291:         end
292:       end
293: 
294:       StManualRun_sparse: begin
295:         if (keccak_complete) begin
296:           st_d = StSqueeze_sparse;
297:         end else begin
298:           st_d = StManualRun_sparse;
299:         end
300:       end
301: 
302:       StFlush_sparse: begin
303:         st_d = StIdle_sparse;
304:       end
305: 
306:       StTerminalError_sparse: begin
307:         //this state is terminal
308:         st_d = StTerminalError_sparse;
309:         sha3_state_error = 1'b 1;
310:       end
311: 
312:       default: begin
313:         st_d = StTerminalError_sparse;
314:         sha3_state_error = 1'b 1;
315:       end
316:     endcase
317: 
318:     // SEC_CM: FSM.GLOBAL_ESC, FSM.LOCAL_ESC
319:     // Unconditionally jump into the terminal error state
320:     // if the life cycle controller triggers an escalation.
321:     if (lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) begin
322:       st_d = StTerminalError_sparse;
323:     end
324:   end
325: 
326:   //////////////
327:   // Datapath //
328:   //////////////
329: 
330:   // State --> Digest output
331:   always_comb begin : state_guarded_mux
332:     unique case (mux_sel)
333:       MuxGuard:   state_guarded = '{default: '0};
334:       MuxRelease: state_guarded = state;
335:       default:    state_guarded = '{default: '0}; // a valid, safe output
336:     endcase
337:   end
338: 
339: 
340:   // Error Detecting
341:   // ErrSha3SwControl:
342:   //   info[ 0]: start_i set
343:   //   info[ 1]: process_i set
344:   //   info[ 2]: run_i set
345:   //   info[ 3]: done_i set
346:   //  - Sw set process_i, run_i, done_i without start_i
347: 
348:   always_comb begin
349:     error_o = '{valid: 1'b0, code: ErrNone, info: '0};
350: 
351:     unique case (st)
352:       StIdle_sparse: begin
353:         if (process_i || run_i ||
354:           prim_mubi_pkg::mubi4_test_true_loose(done_i)) begin
355:           error_o = '{
356:             valid: 1'b 1,
357:             code: ErrSha3SwControl,
358:             info: 24'({done_i, run_i, process_i, start_i})
359:           };
360:         end
361:       end
362: 
363:       StAbsorb_sparse: begin
364:         if (start_i || run_i || prim_mubi_pkg::mubi4_test_true_loose(done_i)
365:           || (process_i && processing)) begin
366:           error_o = '{
367:             valid: 1'b 1,
368:             code: ErrSha3SwControl,
369:             info: 24'({done_i, run_i, process_i, start_i})
370:           };
371:         end
372:       end
373: 
374:       StSqueeze_sparse: begin
375:         if (start_i || process_i) begin
376:           error_o = '{
377:             valid: 1'b 1,
378:             code: ErrSha3SwControl,
379:             info: 24'({done_i, run_i, process_i, start_i})
380:           };
381:         end
382:       end
383: 
384:       StManualRun_sparse: begin
385:         if (start_i || process_i || run_i ||
386:           prim_mubi_pkg::mubi4_test_true_loose(done_i)) begin
387:           error_o = '{
388:             valid: 1'b 1,
389:             code: ErrSha3SwControl,
390:             info: 24'({done_i, run_i, process_i, start_i})
391:           };
392:         end
393:       end
394: 
395:       StFlush_sparse: begin
396:         if (start_i || process_i || run_i ||
397:           prim_mubi_pkg::mubi4_test_true_loose(done_i)) begin
398:           error_o = '{
399:             valid: 1'b 1,
400:             code: ErrSha3SwControl,
401:             info: 24'({done_i, run_i, process_i, start_i})
402:           };
403:         end
404:       end
405: 
406:       default: begin
407:       end
408:     endcase
409:   end
410:   ///////////////
411:   // Instances //
412:   ///////////////
413: 
414:   // SHA3 pad logic
415:   sha3pad #(
416:     .EnMasking (EnMasking)
417:   ) u_pad (
418:     .clk_i,
419:     .rst_ni,
420: 
421:     // MSG_FIFO (or from KMAC core)
422:     .msg_valid_i,
423:     .msg_data_i, // [Share]
424:     .msg_strb_i,
425:     .msg_ready_o,
426: 
427:     // Encoded N, S
428:     .ns_data_i,
429: 
430:     // output to keccak_round: message path
431:     .keccak_valid_o (keccak_valid),
432:     .keccak_addr_o  (keccak_addr ),
433:     .keccak_data_o  (keccak_data ), // [Share]
434:     .keccak_ready_i (keccak_ready),
435: 
436:     .keccak_run_o      (sha3pad_keccak_run),
437:     .keccak_complete_i (keccak_complete   ),
438: 
439:     // configurations
440:     .mode_i,
441:     .strength_i,
442: 
443:     // LC
444:     .lc_escalate_en_i (lc_escalate_en_i),
445: 
446:     // controls
447:     .start_i   (keccak_start),
448:     .process_i (keccak_process),
449:     .done_i    (keccak_done),
450: 
451:     // output
452:     .absorbed_o         (absorbed),
453:     .sparse_fsm_error_o (sha3pad_state_error),
454:     .msg_count_error_o  (msg_count_error)
455:   );
456: 
457:   // Keccak round logic
458:   keccak_round #(
459:     .Width    (sha3_pkg::StateW),
460:     .DInWidth (sha3_pkg::MsgWidth),
461: 
462:     .EnMasking  (EnMasking)
463:   ) u_keccak (
464:     .clk_i,
465:     .rst_ni,
466: 
467:     .valid_i (keccak_valid),
468:     .addr_i  (keccak_addr ),
469:     .data_i  (keccak_data ),
470:     .ready_o (keccak_ready),
471: 
472:     .rand_valid_i,
473:     .rand_early_i,
474:     .rand_data_i,
475:     .rand_aux_i,
476:     .rand_update_o,
477:     .rand_consumed_o,
478: 
479:     .run_i      (keccak_run     ),
480:     .complete_o (keccak_complete),
481: 
482:     .state_o    (state),
483: 
484:     // LC
485:     .lc_escalate_en_i (lc_escalate_en_i),
486: 
487:     .sparse_fsm_error_o  (keccak_round_state_error),
488:     .round_count_error_o (round_count_error),
489:     .rst_storage_error_o (keccak_storage_rst_error),
490: 
491:     .clear_i    (keccak_done)
492:   );
493: 
494:   ////////////////
495:   // Assertions //
496:   ////////////////
497: 
498:   // The Keccak core can only be active when the run REQ is ACKed.
499:   `ASSERT(KeccakIdleWhenNoRunHs_A,
500:       u_keccak.keccak_st inside {KeccakStActive,
501:                                  KeccakStPhase1,
502:                                  KeccakStPhase2Cycle1,
503:                                  KeccakStPhase2Cycle2,
504:                                  KeccakStPhase2Cycle3} |->
505:       run_req_o && run_ack_i)
506: 
507:   // Unknown check for case statement
508:   `ASSERT(MuxSelKnown_A, mux_sel inside {MuxGuard, MuxRelease})
509:   `ASSERT(FsmKnown_A, st inside {StIdle_sparse, StAbsorb_sparse, StSqueeze_sparse,
510:                                  StManualRun_sparse, StFlush_sparse, StTerminalError_sparse})
511: 
512:   // `state` shall be 0 in invalid
513:   if (EnMasking) begin: gen_chk_digest_masked
514:     `ASSERT(StateZeroInvalid_A, !state_valid_o |-> ((|state_o[0]) | (|state_o[1])) == 1'b 0)
515:   end else begin : gen_chk_digest_unmasked
516:     `ASSERT(StateZeroInvalid_A, !state_valid_o |-> (|state_o[0]) == 1'b 0)
517:   end
518: 
519:   // `state_valid_o` asserts only in between the completion and done
520:   //`ASSERT(StateValidPeriod_A, state_valid_o |-> )
521: 
522:   // skip the msg interface assertions as they are in sha3pad.sv
523: 
524:   // Software run signal happens in Squeezing stage
525:   `ASSUME(SwRunInSqueezing_a, run_i |-> error_o.valid || (st == StSqueeze_sparse))
526: 
527:   // If control received but not propagated into submodules, it is error condition
528:   `ASSERT(ErrDetection_A, error_o.valid
529:     |-> {start_i,      process_i,      run_i,         done_i}
530:      != {keccak_start, keccak_process, sw_keccak_run, keccak_done})
531: 
532: endmodule

================================== Ai Message ==================================
Tool Calls:
  run_similar_bug_agent (call_QFz51H5aUMDqHEbc3EaOsFOl)
 Call ID: call_QFz51H5aUMDqHEbc3EaOsFOl
  Args:
    bug: assign msg_data_masked[i] = msg_data[i] ^ 
                                ({MsgWidth{cfg_msg_mask}} & static_mask);
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/rtl/kmac.sv
================================= Tool Message =================================
Name: run_similar_bug_agent

I apologize for the persistent error. Let me analyze the code manually. 

Looking at the code, the specific bug is located on lines 925-926:

```systemverilog
assign msg_data_masked[i] = msg_data[i] ^ 
                            ({MsgWidth{cfg_msg_mask}} & static_mask);
```

This is inside the `g_msg_data_mask` generate block (lines 923-927) within the `g_msg_mask` block (lines 906-933).

The bug appears to be a potential masking issue where the masking is applied unconditionally, even when `cfg_msg_mask` might be disabled. 

There are no other identical instances of this exact code pattern in this file. The code is part of a specific masking implementation for the KMAC (Keccak Message Authentication Code) module when masking is enabled.

The buggy lines are:
- Line 925-926: 
```systemverilog
assign msg_data_masked[i] = msg_data[i] ^ 
                            ({MsgWidth{cfg_msg_mask}} & static_mask);
```

This is the only instance of this specific bug in the file.
================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_cosR1nm5B7uthynjqL3gLyNU)
 Call ID: call_cosR1nm5B7uthynjqL3gLyNU
  Args:
    design_filepath: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/rtl/kmac.sv
    top_module: kmac
    security_objective: Message masking randomness uses proper entropy (map to CWE-330/331 if violated)
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

[{"text": "Let me try a more specific query for CWE-330:", "type": "text"}, {"id": "toolu_014xxn4kH6JY7ebv1Lfcnn7t", "input": {"security_issue": "Use of Insufficiently Random Values in cryptographic operations"}, "name": "llm_cwe_details_retriever_tool", "type": "tool_use"}]
================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_F6IEc2J4dZ5TEzZFASOlTFFQ)
 Call ID: call_F6IEc2J4dZ5TEzZFASOlTFFQ
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/kmac/rtl/kmac_msgfifo.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // KMAC MSG_FIFO
6: //
7: // This module converts TL-UL interface into MSG_FIFO interface used in KMAC.
8: 
9: `include "prim_assert.sv"
10: 
11: module kmac_msgfifo
12:   import kmac_pkg::*;
13: #(
14:   // OutWidth is MsgFIFO data width. prim_packer converts InW to OutW prior to
15:   // pushing to MsgFIFO
16:   parameter int OutWidth = 64,
17: 
18:   parameter bit EnMasking = 1'b 1,
19: 
20:   // Internal MsgFIFO Entry count
21:   parameter  int MsgDepth = 9,
22:   localparam int MsgDepthW = $clog2(MsgDepth+1) // derived parameter
23: ) (
24:   input clk_i,
25:   input rst_ni,
26: 
27:   // from REG or KeyMgr Intf input
28:   input                fifo_valid_i,
29:   input [OutWidth-1:0] fifo_data_i,
30:   input [OutWidth-1:0] fifo_mask_i,
31:   output               fifo_ready_o,
32: 
33:   // MSG interface
34:   output logic                  msg_valid_o,
35:   output logic [OutWidth-1:0]   msg_data_o,
36:   output logic [OutWidth/8-1:0] msg_strb_o,
37:   input                         msg_ready_i,
38: 
39:   output logic                 fifo_empty_o,
40:   output logic                 fifo_full_o,
41:   output logic [MsgDepthW-1:0] fifo_depth_o,
42: 
43:   // Control
44:   input prim_mubi_pkg::mubi4_t clear_i,
45: 
46:   // process_i --> process_o
47:   // process_o asserted after all internal messages are flushed out to MSG interface
48:   input        process_i,
49:   output logic process_o,
50: 
51:   err_t err_o
52: );
53: 
54:   /////////////////
55:   // Definitions //
56:   /////////////////
57:   typedef struct packed {
58:     logic [OutWidth-1:0]   data;
59:     logic [OutWidth/8-1:0] strb; // one bit per byte
60:   } fifo_t;
61: 
62:   typedef enum logic [1:0] {
63:     // In Idle, it checks if process input received or not.
64:     // If received, the signal goes to packer and flush internal pending data
65:     FlushIdle,
66: 
67:     // In Packer state, it waits the packer flush operation completes.
68:     // The flush_done signal do nothing but after this, it is assumed that
69:     // MSG FIFO received the request.
70:     FlushPacker,
71: 
72:     // In Fifo, it waits until MsgFifo is empty. Then asserts process_o
73:     FlushFifo,
74: 
75:     // After flushing, it waits the done (clear) signal. It is assumed that
76:     // no incoming messages are transmitted between `process_i` and `clear_i`
77:     FlushClear
78:   } flush_st_e;
79: 
80:   /////////////
81:   // Signals //
82:   /////////////
83: 
84:   // Packer write path
85:   logic                packer_wvalid;
86:   logic [OutWidth-1:0] packer_wdata;
87:   logic [OutWidth-1:0] packer_wmask;
88:   logic                packer_wready;
89: 
90:   // Message FIFO signals
91:   logic  fifo_wvalid;
92:   fifo_t fifo_wdata;
93:   logic  fifo_wready;
94:   logic  fifo_rvalid;
95:   fifo_t fifo_rdata;
96:   logic  fifo_rready;
97: 
98:   logic fifo_err; // FIFO dup. counter error
99: 
100:   // packer flush to msg_fifo, then msg_fifo empty out the internals
101:   // then assert msgfifo_flush_done
102:   logic packer_flush_done;
103:   logic msgfifo_flush_done;
104: 
105:   logic packer_err;
106: 
107:   // SEC_CM: PACKER.CTR.REDUN
108:   prim_packer #(
109:     .InW          (OutWidth),
110:     .OutW         (OutWidth),
111:     .HintByteData (1),
112: 
113:     // Turn on dup counter when EnMasking is set
114:     .EnProtection (EnMasking)
115:   ) u_packer (
116:     .clk_i,
117:     .rst_ni,
118: 
119:     .valid_i      (fifo_valid_i),
120:     .data_i       (fifo_data_i),
121:     .mask_i       (fifo_mask_i),
122:     .ready_o      (fifo_ready_o),
123: 
124:     .valid_o      (packer_wvalid),
125:     .data_o       (packer_wdata),
126:     .mask_o       (packer_wmask),
127:     .ready_i      (packer_wready),
128: 
129:     .flush_i      (process_i),
130:     .flush_done_o (packer_flush_done),
131: 
132:     .err_o (packer_err)
133:   );
134: 
135:   // Assign packer wdata and wmask to FIFO struct
136:   // In contrast to HMAC case, KMAC SHA3 operates in little-endian. MSG fifo is
137:   // converted into 3-D form so the endianess here is not a problem.
138:   assign fifo_wdata.data = packer_wdata;
139:   always_comb begin
140:     fifo_wdata.strb = '0;
141:     for (int i = 0 ; i < OutWidth/8 ; i++) begin
142:       fifo_wdata.strb[i] = packer_wmask[8*i];
143:     end
144:   end
145: 
146:   // MsgFIFO
147:   prim_fifo_sync #(
148:     .Width  ($bits(fifo_t)),
149:     .Pass   (1'b 1),
150:     .Depth  (MsgDepth),
151:     .Secure (EnMasking)
152:   ) u_msgfifo (
153:     .clk_i,
154:     .rst_ni,
155:     .clr_i   (prim_mubi_pkg::mubi4_test_true_strict(clear_i)),
156: 
157:     .wvalid_i(fifo_wvalid),
158:     .wready_o(fifo_wready),
159:     .wdata_i (fifo_wdata),
160: 
161:     .rvalid_o (fifo_rvalid),
162:     .rready_i (fifo_rready),
163:     .rdata_o  (fifo_rdata),
164: 
165:     .full_o  (fifo_full_o),
166:     .depth_o (fifo_depth_o),
167:     .err_o   (fifo_err)
168: 
169:   );
170: 
171:   assign fifo_wvalid = packer_wvalid;
172:   assign packer_wready = fifo_wready;
173: 
174:   assign msg_valid_o = fifo_rvalid;
175:   assign fifo_rready = msg_ready_i;
176:   assign msg_data_o  = fifo_rdata.data;
177:   assign msg_strb_o  = fifo_rdata.strb;
178: 
179:   assign fifo_empty_o = !fifo_rvalid;
180: 
181:   // Flush (process from outside) handling
182:   flush_st_e flush_st, flush_st_d;
183: 
184:   always_ff @(posedge clk_i or negedge rst_ni) begin
185:     if (!rst_ni) begin
186:       flush_st <= FlushIdle;
187:     end else begin
188:       flush_st <= flush_st_d;
189:     end
190:   end
191: 
192:   always_comb begin
193:     flush_st_d = flush_st;
194: 
195:     msgfifo_flush_done = 1'b 0;
196: 
197:     unique case (flush_st)
198:       FlushIdle: begin
199:         if (process_i) begin
200:           flush_st_d = FlushPacker;
201:         end else begin
202:           flush_st_d = FlushIdle;
203:         end
204:       end
205: 
206:       FlushPacker: begin
207:         if (packer_flush_done) begin
208:           flush_st_d = FlushFifo;
209:         end else begin
210:           flush_st_d = FlushPacker;
211:         end
212:       end
213: 
214:       FlushFifo: begin
215:         if (fifo_empty_o) begin
216:           flush_st_d = FlushClear;
217: 
218:           msgfifo_flush_done = 1'b 1;
219:         end else begin
220:           flush_st_d = FlushFifo;
221:         end
222:       end
223: 
224:       FlushClear: begin
225:         if (prim_mubi_pkg::mubi4_test_true_strict(clear_i)) begin
226:           flush_st_d = FlushIdle;
227:         end else begin
228:           flush_st_d = FlushClear;
229:         end
230:       end
231: 
232:       default: begin
233:         flush_st_d = FlushIdle;
234:       end
235:     endcase
236:   end
237: 
238:   assign process_o = msgfifo_flush_done;
239: 
240:   err_t error;
241:   assign err_o = error;
242: 
243:   // Error assign
244:   always_comb begin : error_logic
245:     error = '{
246:       valid: 1'b 0,
247:       code: kmac_pkg::ErrNone,
248:       info: '0
249:     };
250: 
251:     // Priority case -> if .. else if
252:     if (packer_err) begin
253:       error = '{
254:         // If EnProtection is 0, packer_err is tied to 0
255:         valid: 1'b 1,
256:         code:  kmac_pkg::ErrPackerIntegrity,
257:         info:  kmac_pkg::ErrInfoW'(flush_st)
258:       };
259:     end else if (fifo_err) begin
260:       error = '{
261:         valid: 1'b 1,
262:         code:  kmac_pkg::ErrMsgFifoIntegrity,
263:         info:  kmac_pkg::ErrInfoW'(flush_st)
264:       };
265:     end
266:   end : error_logic
267: 
268:   ////////////////
269:   // Assertions //
270:   ////////////////
271: 
272:   // Flush state known checker
273:   `ASSERT(FlushStInValid_A, flush_st inside {FlushIdle, FlushPacker, FlushFifo, FlushClear})
274: 
275:   // Packer done signal is asserted at least one cycle later
276:   `ASSERT(PackerDoneDelay_A, $onehot0({process_i, packer_flush_done}))
277: 
278:   // process_i not asserted during the flush operation
279:   `ASSUME(PackerDoneValid_a, process_i |-> flush_st == FlushIdle)
280: 
281:   // No messages in between `process_i` and `clear_i`
282:   `ASSUME(MessageValid_a, fifo_valid_i |-> flush_st == FlushIdle)
283: 
284: endmodule

================================== Ai Message ==================================

Scope and sources reviewed
- Documentation: theory_of_operation.md, registers.md
- RTL: kmac.sv (top), kmac_reg_top.sv (reg interface), kmac_entropy.sv (PRNG/entropy), kmac_msgfifo.sv (message FIFO), kmac_core.sv, kmac_staterd.sv, kmac_app.sv, sha3.sv
- Tools used:
  - Anomaly Detector Agent
  - CWE Checker Agent (for mapping and validation)
  - Similar Bug Agent
  - Manual code review with line-numbered source

Summary of intended security properties and register interface policies (from documentation)
- Masking / SCA hardening:
  - Default build uses masked Keccak core (two shares). DOM multipliers require 800 bits of fresh entropy per cycle.
  - Internal PRNG (unrolled Bivium variant) reseeded from EDN or software seed; periodically refreshed; feeds DOM remasking and message masking when enabled via CFG_SHADOWED.msg_mask.
- Message masking:
  - If EnMasking and CFG_SHADOWED.msg_mask are set, the KMAC block masks the message upon loading into the Keccak core using its internal entropy generator (kmac/doc/theory_of_operation.md).
- Secret key handling:
  - Keys provided by SW in two shares if EnMasking=1. If EnMasking=0, can optionally accept two-share SW key depending on SwKeyMasked parameter; sideloaded key always two-share masked.
- State readout:
  - Software reads the digest via STATE window only after absorption completes; if masking enabled, software reads both shares and recombines. While idle or absorbing, the exposed state is zeroed. When KDF is active via application interface, software state access is blocked/zeroed.
- Register access policies (registers.md):
  - CFG_SHADOWED is shadowed and gated by CFG_REGWEN; only takes effect in Idle (hardware writes cfg_regwen to reflect “engine stable”).
  - KEY_SHARE0/1 are write-only (reads return zero). KEY_LEN is write-only. ENTROPY_SEED is write-only. STATE is read-only. MSG_FIFO is write-only. INTR_STATE W1C, INTR_ENABLE RW, INTR_TEST WO. STATUS is RO.

Identified security issues

1) Message masking uses a static all-ones mask instead of entropy-driven randomness (breaks SCA protection; CWE-330/331)
- File: hw/ip/kmac/rtl/kmac.sv
- Line numbers:
  - 908–933: g_msg_mask block
  - 915: assign static_mask = {MsgWidth{1'b1}};
  - 920–926: msg_mask_permuted computed from static_mask (not from PRNG), then unused
  - 928–932: assign msg_data_masked[i] = msg_data[i] ^ ({MsgWidth{cfg_msg_mask}} & static_mask);
- Description:
  - In masked builds (EnMasking == 1), the KMAC top should mask the message using entropy from kmac_entropy (signal msg_mask) when CFG_SHADOWED.msg_mask is set.
  - Instead, the code hardcodes a static all-ones mask and XORs it with the message when cfg_msg_mask is set. The entropy-produced msg_mask is not used at all. The computed msg_mask_permuted is also unused.
  - This turns masking into a deterministic bitwise inversion (if enabled), removing the intended unpredictability and providing no side-channel protection. In effect, the protection described in the documentation (“Message Masking with PRNG”) is disabled.
- Security aspect affected:
  - Side-channel resistance of Keccak input masking; cryptographic randomness quality.
  - CWE-330: Use of Insufficiently Random Values; CWE-331: Insufficient Entropy.
- Tools used:
  - Anomaly Detector Agent (flagged static mask and bypass of PRNG)
  - Documentation cross-check (theory_of_operation.md vs RTL)
  - CWE Agent (mapping to CWE-330/331)
  - Similar Bug Agent (to look for repeats of the same pattern)
- Impact:
  - High severity. Undermines the first-order masking aim for message data. While the key share masking inside the Keccak round still uses DOM and entropy, the message masking path (when enabled) becomes deterministic and may leak data-dependent behavior (timing/power) not intended under the threat model. It also violates the documented security property of PRNG-based message masking.
- Suggested remediation:
  - Replace static_mask with the entropy-driven mask from kmac_entropy.sv (msg_mask signal).
  - Use the provided permutation RndCnstMsgPerm on the PRNG output if required by the design, and then use that permuted mask to XOR the message data. For example:
    - msg_mask_permuted[i] = msg_mask[RndCnstMsgPerm[i]];
    - msg_data_masked[i] = msg_data[i] ^ ({MsgWidth{cfg_msg_mask}} & msg_mask_permuted);
  - Remove the static all-ones mask and ensure msg_mask_permuted is used.
  - Add assertions to prevent enabling cfg_msg_mask unless entropy_configured is true; optionally assert msg_mask != all-zeros/all-ones when cfg_msg_mask is enabled.
  - Guard any “performance” fallbacks behind explicit test-only defines that cannot be enabled in production.
- Additional notes:
  - The else-branch (EnMasking == 0) ties msg_data_masked[0] = msg_data[0], which is fine since masking is disabled there.
  - The current code also sets msgfifo_data[1] = '0 (kmac.sv:219–223), then applies the same static mask to both shares; XOR recombines correctly (share0: m^mask, share1: mask), but mask is static, breaking the intent of randomized masking.

2) Dead code and entropy-mask bypass in message mask path (code hygiene and clarity; reinforces Issue 1)
- File: hw/ip/kmac/rtl/kmac.sv
- Line numbers:
  - 920–926: msg_mask_permuted computed from static_mask but never used
  - 936–938: unused signal tie-off includes msg_mask (indicating mask is unused in masked branch)
- Brief description:
  - msg_mask_permuted is computed from static_mask (not from PRNG) and is not used in masking the data; msg_mask from entropy is also unused (tied off as unused in the no-mask branch).
- Security aspect affected:
  - Same as Issue 1; contributes to confusion and risk that real masking is bypassed.
- Tools used:
  - Anomaly Detector Agent
  - Manual code review
- Suggested remediation:
  - Wire the entropy-derived msg_mask into this logic and remove dead/unused code.

Items reviewed and found consistent with documentation (no issues)
- Register access policies in kmac_reg_top.sv:
  - KEY_SHARE0/1, KEY_LEN, ENTROPY_SEED, MSG_FIFO, STATE access semantics implemented as documented. Reads from write-only key and FIFO windows return zero (kmac_reg_top.sv lines ~3063–3191). STATE is read-only and exposed via kmac_staterd.sv where endian conversion is handled; reads guarded by reg_state_valid.
  - CFG_REGWEN gating tied to engine stability (kmac.sv lines ~480–486) to prevent reconfiguration mid-operation.
- State readout guarding:
  - kmac_app.sv only exposes keccak_state to SW when software is the active initiator (SelSw); during app-initiated KDF operations, digest shares are returned via app interface and SW register view is zeroed (kmac_app.sv lines ~721–742).
- Entropy generator correctness:
  - kmac_entropy.sv implements PRNG reseed via EDN or SW seed, permutation of PRNG output, buffering, and exposes msg_mask_o = rand_data_q[MsgWidth-1:0] (lines 398–400). It is ready to feed message masking correctly; the integration bug is in kmac.sv.

Recommended follow-up checks after fix
- Ensure cfg_msg_mask is only effective when EnMasking == 1 and entropy_configured is true (there is already an errchk for SW initiating without entropy ready; kmac_errchk.sv lines 275–295).
- Run SCA-oriented regression/verification for the masking path after wiring entropy-based masks.
- Consider adding assertions or functional coverage to ensure the entropy-driven msg_mask path is toggled when cfg_msg_mask is set.

END


Token Usage Summary:
===================
Total API Calls: 22
Total Input Tokens: 1,486,410
Total Output Tokens: 14,426
Total Tokens: 1,500,836
Average Input Tokens/Call: 67564.1
Average Output Tokens/Call: 655.7
Average Total Tokens/Call: 68219.8


Detailed Call History:
==================================================
Call 1: gpt-5-2025-08-07 - Input: 1065, Output: 237, Total: 1302
Call 2: gpt-5-2025-08-07 - Input: 1203, Output: 40, Total: 1243
Call 3: gpt-5-2025-08-07 - Input: 1349, Output: 45, Total: 1394
Call 4: gpt-5-2025-08-07 - Input: 7451, Output: 43, Total: 7494
Call 5: gpt-5-2025-08-07 - Input: 19376, Output: 47, Total: 19423
Call 6: gpt-5-2025-08-07 - Input: 19570, Output: 184, Total: 19754
Call 7: gpt-5-2025-08-07 - Input: 60662, Output: 118, Total: 60780
Call 8: gpt-5-2025-08-07 - Input: 79832, Output: 391, Total: 80223
Call 9: gpt-5-mini-2025-08-07 - Input: 15323, Output: 53, Total: 15376
Call 10: gpt-5-mini-2025-08-07 - Input: 16761, Output: 2870, Total: 19631
Call 11: gpt-5-2025-08-07 - Input: 81620, Output: 311, Total: 81931
Call 12: gpt-5-2025-08-07 - Input: 90192, Output: 377, Total: 90569
Call 13: gpt-5-2025-08-07 - Input: 91616, Output: 49, Total: 91665
Call 14: gpt-5-2025-08-07 - Input: 97455, Output: 68, Total: 97523
Call 15: gpt-5-2025-08-07 - Input: 97586, Output: 376, Total: 97962
Call 16: gpt-5-2025-08-07 - Input: 102226, Output: 1015, Total: 103241
Call 17: gpt-5-2025-08-07 - Input: 112682, Output: 733, Total: 113415
Call 18: gpt-5-2025-08-07 - Input: 112858, Output: 49, Total: 112907
Call 19: gpt-5-2025-08-07 - Input: 118380, Output: 1429, Total: 119809
Call 20: gpt-5-2025-08-07 - Input: 118703, Output: 1300, Total: 120003
Call 21: gpt-5-2025-08-07 - Input: 118887, Output: 184, Total: 119071
Call 22: gpt-5-2025-08-07 - Input: 121613, Output: 4507, Total: 126120
    
