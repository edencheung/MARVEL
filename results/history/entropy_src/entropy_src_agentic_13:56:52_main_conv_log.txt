================================ System Message ================================


    You are a supervisor agent in a multi-agent system focused on identifying hardware security vulnerabilities in RTL code. 
    Your objective is to analyze the given SoC and generate a detailed security report.

    You have access to the following tools: ['run_anomaly_detector_agent', 'run_llm_cwe_checker_agent', 'run_similar_bug_agent', 'list_dir', 'read_file', 'read_file_with_line_numbers']. Each tool specializes in a specific task:

    - CWE Agent: Given a Verilog file, a top module, and a security aspect, this agent maps the RTL code to relevant CWEs and detects CWE-related vulnerabilities.
    - Similar Bug Agent: Accepts a file path and a line number (where a bug was found) to locate similar patterns or recurring bugs throughout the RTL code.

    Instructions for analysis:

    - Read the documentataion to identify security features and register interfaces policies.
    - Read through the different systemverilog files to probe for issues and use the anomaly agent
    - If a bug is detected but not localized, use the CWE Agent to further inspect the related security aspect in the surrounding RTL.
    - After detecting any bugs, use the Similar Bug Agent to scan similar files (of the same or of different IPs) for similar vulnerabilities.

    Output Format:

    - For each identified issue, report:
    - File name
    - Line number(s)
    - Brief description of the issue
    - Security aspect affected
    - Tools used to identify the issue

    When your analysis is complete, end your response with "END".
    
================================ Human Message =================================

Identify security issues in the entropy_src IP of the OpenTitan SoC, located at /home/eden/Desktop/Code/HACK@CHES/p2/opentitan.

    - All IPs are located in the 'hw/ip' directory.
    - RTL code for each IP is located in its 'rtl' subdirectory, with source files having the '.sv' extension.
        - reg_top files contain the register interface for the IP.
        - control/fsm files contain the control logic for the IP.
        - core files contain the core logic for the IP.
    - Documentation files (.md) are located in the 'doc' directories of each IP.
        - theory_of_operation explains the properties of the IP and its security features.
        - registers.md files contain the register interface and its read/write access policies.
    - Ignore '.core' files; they are used by build tools and are not relevant for security analysis.

    Focus on the entropy_src IP and make sure to analyze it thoroughly.

    First, identify the relevant security properties and read/write policies of the register interfaces from the documentation. 
    Then, use all available tools to perform a comprehensive security analysis on the RTL code.
    
================================== Ai Message ==================================
Tool Calls:
  list_dir (call_Tjf9vEMQOMywvKURnRHvnl9q)
 Call ID: call_Tjf9vEMQOMywvKURnRHvnl9q
  Args:
    dir_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip
================================= Tool Message =================================
Name: list_dir

Files in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip:
README.md BUILD

Directories in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip:
pattgen csrng aon_timer prim_generic keymgr_dpe uart keymgr i2c dma spi_host otp_ctrl rom_ctrl spi_device edn usbdev adc_ctrl trial1 kmac flash_ctrl otp_macro rv_dm mbx rv_timer prim_xilinx prim prim_xilinx_ultrascale aes lc_ctrl hmac rv_core_ibex sram_ctrl entropy_src racl_ctrl sysrst_ctrl tlul soc_dbg_ctrl otbn ascon
================================== Ai Message ==================================
Tool Calls:
  list_dir (call_VwF3UiGWUsYOpYj1oo2op8gl)
 Call ID: call_VwF3UiGWUsYOpYj1oo2op8gl
  Args:
    dir_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/entropy_src
================================= Tool Message =================================
Name: list_dir

Files in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/entropy_src:
entropy_src_pkg.core README.md BUILD entropy_src.core defs.bzl

Directories in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/entropy_src:
pre_dv data dv rtl lint doc
================================== Ai Message ==================================
Tool Calls:
  list_dir (call_i3f3gFNu4EssOqpi3LwsWWXk)
 Call ID: call_i3f3gFNu4EssOqpi3LwsWWXk
  Args:
    dir_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/entropy_src/doc
================================= Tool Message =================================
Name: list_dir

Files in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/entropy_src/doc:
es_main_sm.vsdx registers.md interfaces.md entsrc_blk_diag.vsdx es_main_sm.svg checklist.md entsrc_blk_diag.svg programmers_guide.md theory_of_operation.md

Directories in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/entropy_src/doc:

================================== Ai Message ==================================
Tool Calls:
  read_file (call_IPKqamrbo1xsKKs1Jly0liq9)
 Call ID: call_IPKqamrbo1xsKKs1Jly0liq9
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/entropy_src/doc/theory_of_operation.md
================================= Tool Message =================================
Name: read_file

# Theory of Operation

The ENTROPY_SRC hardware block collects entropy bits from the PTRNG (Physical True Random Number Generator) noise source, performs health tests on the collected entropy bits, packs them, sends them through a conditioning unit, and finally stores them into the `esfinal` FIFO for consumption by firmware or hardware.

It operates in a manner compliant with both FIPS (though NIST SP 800-90B) and CC (AIS31) recommendations.
This revision supports only an external interface for a PTRNG noise source implementation.

### Initialization and Enabling

After power-up, the ENTROPY_SRC block is disabled.
The first step is initialization and enabling.

For simplicity of initialization, only a single write operation to the [`MODULE_ENABLE`](registers.md#module_enable) register is needed to start functional operation of the ENTROPY_SRC block.
This assumes that proper defaults are chosen for the health test thresholds and other registers such as the [`CONF`](registers.md#conf) register.

Once the ENTROPY_SRC block is enabled, also the PTRNG noise source starts up.
The ENTROPY_SRC block will then start to collect entropy bits indefinitely until disabled.

### Boot-Time / Bypass Mode

After a reset, the ENTROPY_SRC block will start up in boot-time / bypass mode by default.
This feature is designed to provide an initial seed's worth of entropy with lower latency than the normal FIPS/CC compliant health check process.
Health testing will still be performed on boot-time mode entropy, but the window of checking is, by default, 384 bits instead of 2048 bits.

### FIPS/CC Compliant Mode

Once the initial boot-time mode phase has completed, the ENTROPY_SRC block can be switched to FIPS/CC compliant mode (for simplicity referred to as FIPS mode) by setting the `FIPS_ENABLE` field in the [`CONF`](registers.md#conf) register to `kMultiBitBool4True`.
In this mode, once the raw entropy has been health checked, it will be passed into a conditioner block.
This block will compress the bits such that the entropy bits/physical bits, or min-entropy value, should be improved over the raw data source min-entropy value.
The compression operation will compress every [`HEALTH_TEST_WINDOWS.FIPS_WINDOW`](registers.md#health_test_windows--fips_window) x 4 tested bits into 384 full-entropy bits.
By default, 2048 tested bits are used.
Note that a seed is only produced if the last [`HEALTH_TEST_WINDOWS.FIPS_WINDOW`](registers.md#health_test_windows--fips_window) x 4 tested bits have passed the health tests.
If a health test fails, the conditioner block continues absorbing the next window unless [`ALERT_SUMMARY_FAIL_COUNTS`](registers.md#alert_summary_fail_counts) reaches the configured [`ALERT_THRESHOLD`](registers.md#alert_threshold).
Once the threshold is reached, the ENTROPY_SRC block stops serving entropy and signals a recoverable alert.
Firmware then needs to disable/re-enable the block to restart operation.

When entropy is delivered to the downstream hardware block, a signal will indicate what type of entropy it is - FIPS/CC compliant or not.
This signal is determined by the `FIPS_FLAG` field in the [`CONF`](registers.md#conf) register.
When `RNG_FIPS` field in the [`CONF`](registers.md#conf) register is set to `kMultiBitBool4True`, the ENTROPY_SRC block will request higher quality entropy from the noise source by asserting the `rng_fips` output signal.

### Startup Health Testing

Note that after enabling the ENTROPY_SRC block, the health tests need to pass for two subsequent windows of [`HEALTH_TEST_WINDOWS.FIPS_WINDOW`](registers.md#health_test_windows--fips_window) x 4 tested bits (startup health testing).
By default, 1024 samples of 4 bits (4096 1-bit samples when running in single-channel mode), i.e., 4096 tested bits, are used for producing the startup seed.
If a health test fails, the startup health testing starts over and the conditioner block continues absorbing the next window.
If the health tests don't pass for two subsequent windows, the ENTROPY_SRC block stops operating and signals a recoverable alert.
Firmware then needs to disable/re-enable the block to restart operation including the startup health testing.

### Firmware Override Mode

The hardware conditioning can also be bypassed and replaced in normal operation with a firmware-defined conditioning algorithm.
This firmware conditioning algorithm can be disabled on boot for security purposes.

The firmware override function has the capability to completely override the hardware health tests and the conditioner paths.
In the case of health tests, firmware can turn off one or all of the health tests and perform the tests in firmware.
A data path is provided in the hardware such that the inbound entropy can be trapped in the observe FIFO.
Once a pre-determined threshold of entropy has been reached in this FIFO, and interrupt is raised to let firmware read the entropy bits out of the FIFO.
The exact mechanism for this functionality starts with setting the [`FW_OV_MODE`](registers.md#fw_ov_control--fw_ov_mode) field in the [`FW_OV_CONTROL`](registers.md#fw_ov_control) register.
This will enable firmware to monitor post-health test entropy bits (including entropy bits used for startup health testing) by reading from the [`FW_OV_RD_DATA`](registers.md#fw_ov_rd_data) register.
Firmware can use the [`OBSERVE_FIFO_THRESH`](registers.md#observe_fifo_thresh) and [`OBSERVE_FIFO_DEPTH`](registers.md#observe_fifo_depth) to determine the state of the OBSERVE FIFO.
At this point, firmware can do additional health checks on the entropy.
Optionally, firmware can do the conditioning function, assuming the hardware is configured to bypass the conditioner block.
Once firmware has processed the entropy, it can then write the results back into the [`FW_OV_WR_DATA`](registers.md#fw_ov_wr_data) register (pre-conditioner FIFO).
The [`FW_OV_ENTROPY_INSERT`](registers.md#fw_ov_control--fw_ov_entropy_insert) in the [`FW_OV_CONTROL`](registers.md#fw_ov_control) register will enable inserting entropy bits back into the entropy flow.
If enabled, any startup health testing has to be performed by the firmware.

An additional feature of the firmware override function is to insert entropy bits into the flow and still use the conditioning function in the hardware.
Setting the [`FW_OV_INSERT_START`](registers.md#fw_ov_sha3_start--fw_ov_insert_start) field in the [`FW_OV_SHA3_START`](registers.md#fw_ov_sha3_start) register will prepare the hardware for this flow.
Once this field is set true, the [`FW_OV_WR_DATA`](registers.md#fw_ov_wr_data) register can be written with entropy bits.
The [`FW_OV_WR_FIFO_FULL`](registers.md#fw_ov_wr_fifo_full) register should be monitored after each write to ensure data is not dropped.
Once all of the data has been written, the [`FW_OV_INSERT_START`](registers.md#fw_ov_sha3_start--fw_ov_insert_start) field should be set to false.
The normal SHA3 processing will continue and finally push the conditioned entropy through the module.

For more details, refer to the [programmer's guide](programmers_guide.md/#firmware-override--bypass-modes).

### Health Tests

Health checks are performed on the input raw data from the PTRNG noise source when in that mode.
There are four health tests that will be performed: repetitive count, adaptive proportion, bucket, and Markov tests.
Each test has a pair of threshold values that determine that pass/fail of the test, one threshold for boot-time / bypass mode, and one for FIPS mode.
By default, all tests are enabled, but can be turned off by setting the thresholds to the maximum value.
Because of the variability of the PTRNG noise source, there are several registers that log statistics associated with the health tests.
For example, the adaptive proportion test has a high watermark register that logs the highest measured number of ones.
The [`ADAPTP_HI_WATERMARKS`](registers.md#adaptp_hi_watermarks) register has an entry for both FIPS and boot-time modes.
This register allows for determining how close the threshold value should be set to the fail over value.
Specific to the adaptive proportion test, there is also the [`ADAPTP_LO_WATERMARKS`](registers.md#adaptp_lo_watermarks) register, which will hold the lowest number of ones measured.
To help understand how well the thresholds work through time, a running count of test fails is kept in the [`ADAPTP_HI_TOTAL_FAILS`](registers.md#adaptp_hi_total_fails) register.
The above example for the adaptive proportion test also applies to the other health tests, with the exception of the low watermark registers.
See the timing diagrams below for more details on how the health tests work.
It should be noted that for all error counter registers, they are sized for 16 bits, which prevents any case where counters might wrap.

Additional, vendor-specific tests are supported through an [external health test interface (xht)](#external-health-tests).

### Health Test Failure Alert

The [`ALERT_THRESHOLD`](registers.md#alert_threshold) register determines during how many subsequent health test windows one or more health test failures can occur before a recoverable alert is raised and the ENTROPY_SRC block stops operating.
In case this threshold is reached, firmware needs to disable/re-enable the block to restart operation including the startup health testing.
By default, the threshold is set to two, such that the occurrence of two failing test cycles back-to-back would provide a very low &alpha; value.
When reaching the threshold while running in [Firmware Override: Extract & Insert mode](programmers_guide.md#firmware_override_-_extract_&_insert), the recoverable alert is not raised nor does the block stop operating.
In other modes, the generation of the recoverable alert can be disabled by configuring a value of zero.

The [`ALERT_SUMMARY_FAIL_COUNTS`](registers.md#alert_summary_fail_counts) register holds the total number of health test windows during which one or more health test failures occurred.
The register is automatically cleared after every passing health test window unless the ENTROPY_SRC is configured in [Firmware Override: Extract & Insert mode](programmers_guide.md#firmware_override_-_extract_&_insert).

The [`ALERT_FAIL_COUNTS`](registers.md#alert_fail_counts) reports the number of health test failures since the last passing health test window on a per-test basis.
If multiple health tests fail for a certain window, the value in [`ALERT_SUMMARY_FAIL_COUNTS`](registers.md#alert_summary_fail_counts) is incremented by just one whereas multiple fields in [`ALERT_FAIL_COUNTS`](registers.md#alert_fail_counts) may get incremented.
The same holds for [`EXTHT_FAIL_COUNTS`](registers.md#extht_fail_counts) which reports the number of external health test failures since the last passing health test window on a per-test basis.

### Routing Entropy to Firmware

Firmware has a path to read entropy from the ENTROPY_SRC block.
The [`ES_ROUTE`](registers.md#entropy_control--es_route) field in the [`ENTROPY_CONTROL`](registers.md#entropy_control) register allows firmware to set the internal multiplexers to steer entropy data to the [`ENTROPY_DATA`](registers.md#entropy_data) register.
When enabled, no entropy is being passed to the block hardware interface.
The control field [`ES_TYPE`](registers.md#entropy_control--es_type) sets whether the entropy will come from the conditioning block or be sourced through the bypass path.
A status bit will be set that can either be polled or generate an interrupt when the entropy bits are available to be read from the [`ENTROPY_DATA`](registers.md#entropy_data) register.
The firmware needs to read the [`ENTROPY_DATA`](registers.md#entropy_data) register twelve times in order to cleanly evacuate the 384-bit seed from the hardware path (12 * 32 bits = 384 bits in total).

### Disabling

At any time, the [`MODULE_ENABLE`](registers.md#module_enable) field can be cleared to halt the entropy generation and health testing.
See the [programmer's guide section](programmers_guide.md/#entropy-source-module-disable) for more details on the ENTROPY_SRC block disable sequence.

## Block Diagram

![ENTROPY_SRC Block Diagram](../doc/entsrc_blk_diag.svg)

## Design Details

### Entropy Dropping and Conditioner Back Pressure

When enabled, the ENTROPY_SRC block has no way to exercise back pressure onto the PTRNG noise source.
Any sample coming in from the noise source is being health tested and continues to flow down the entropy pipeline.
However, if the ENTROPY_SRC block experiences internal back pressure, health tested samples may be dropped in different locations depending on the source of the back pressure and the configured mode of operation.

- **Input of `esfinal` FIFO**: If the `esfinal` FIFO is full, e.g., because the hardware entropy interface doesn't request entropy, entire 384-bit seeds coming out of the conditioner or the bypass packer FIFO get dropped.
  Firmware is not informed when dropping entire seeds.
  When running in [Firmware Override: Extract & Insert mode](programmers_guide.md#firmware_override_-_extract_&_insert), firmware may want to infer whether the next seed is likely going to be dropped at this moment by reading the current depth of the `esfinal` FIFO from the [`DEBUG_STATUS`](registers.md#debug_status) register.
- **Input of Observe FIFO**: When running in any of the [Firmware Override modes](programmers_guide.md#firmware_override_/_bypass_modes) health tested entropy bits are collected in the Observe FIFO for observation / extraction by firmware.
  Whenever the Observe FIFO runs full, the [`FW_OV_RD_FIFO_OVERFLOW`](registers.md#fw_ov_rd_fifo_overflow) bit is asserted and the hardware stops collecting entropy bits in the Observe FIFO until firmware has emptied the FIFO.
  This helps ensuring that observed / extracted entropy bits are contiguous.
- **Input of `postht` / `esbit` FIFO**: When experiencing back pressure from the hardware conditioner (see below), health tested entropy bits may get dropped at the input of the `postht` or `esbit` FIFO when running in multi-channel or single-channel mode, respectively.
  Note that the dropped bits are still health tested and contribute to the overall results for the current window.
  However, to keep the number of bits passed to the conditioner constant, the health test window is stretched by the number of dropped samples.
  Whenever post-health test entropy bits are being dropped from the hardware pipeline, a recoverable alert is triggered and the [`RECOV_ALERT_STS.POSTHT_ENTROPY_DROP_ALERT`](registers.md#recov_alert_sts--postht_entropy_drop_alert) bit is asserted.
  Note that this may also happen in [Firmware Override: Observe mode](programmers_guide.md#firmware_override_-_observe).
  Firmware should thus explicitly check the [`RECOV_ALERT_STS.POSTHT_ENTROPY_DROP_ALERT`](registers.md#recov_alert_sts--postht_entropy_drop_alert) bit to ensure the bits retrieved from the Observe FIFO are indeed contiguous.

The reduce the probability of dropping post-health test entropy bits, the **Distribution FIFO** can be used.
This FIFO has pass-through mode enabled meaning it doesn't add latency to hardware pipeline.
It has a width of 32 bits.
Its depth is configurable via compile-time Verilog parameter and should match the expected level of conditioner back pressure.
The level of conditioner back pressure depends on the following factors:
- The maximum latency for the conditioner to add the padding bits \\(n_{pad}\\) (25 clock cycles) and to run the internal SHA3 primitive \\(n_{sha3}\\) (24 clock cycles).
- The maximum latency of the [CS AES halt request interface](interfaces.md/#inter-module-signals) \\(n_{halt}\\) (48 clock cycles corresponding to CSRNG performing the Update function).

The required depth \\(d_{distr}\\) of the Distribution FIFO can be computed as
$$ d_{distr} = { (r_{ptrng} * s_{symbol}) * (2 * (n_{halt} + n_{sha3}) + n_{pad} + n_{uarch}) - 32 - 64 \over 32} $$

where
- \\(r_{ptrng}\\) is the rate at which the PTRNG noise source generates entropy samples,
- \\(s_{symbol}\\) (= 4) is the symbol size of these samples in bits,
- \\(n_{uarch}\\) (= 5) is the latency of the ENTROPY_SRC micro architecture between producing seeds, and
- the -32 and -64 terms are to account for the number of entropy bits stored in the `postht` and the `precon` FIFOs, respectively.

For [Top Earlgrey](../../../top_earlgrey/README.md), the assumption is that the PTRNG noise source generates entropy bits at a rate of roughly 50 kbps.
With the ENTROPY_SRC block running at 100 MHz, this leads to noise source rate \\(r_{ptrng}\\) = 1/8000.

The noise source model inside the DV environment generates symbols with an average rate of 1 4-bit symbol every 6.5 clock cycles.
To reach functional coverage metrics, the `entropy_src_rng_max_rate` configures the noise source to generate a 4-bit symbol every other clock cycle (\\(r_{ptrng}\\) = 1/2) an the CS AES halt request interface to always respond immediately (\\(n_{halt}\\) = 0).
With these settings, the ENTROPY_SRC block should never drop samples due to conditioner back pressure if a depth of two is chosen for the Distribution FIFO (\\(d_{distr}\\) = 2).


### Security

All module assets and countermeasures performed by hardware are listed in the [countermeasures section](interfaces.md/#security-countermeasures).
Labels for each instance of asset and countermeasure are located throughout the RTL source code.

A configuration and control register locking function is performed by the [`REGWEN`](registers.md#regwen) register.
Clearing the bit in this register will prevent future modification of the [`CONF`](registers.md#conf) register or other writeable registers by firmware.

For all of the health test threshold registers, these registers could be protected with shadow registers.
A design choice was made here to not use shadow registers and save on silicon cost.
The threshold registers are protected by software.
It is expected that software will read the threshold registers on a periodic basis, and compare these values to what was originally programmed into the threshold registers.

Bus integrity checking is performed for the final seed delivery to CSRNG.
This is done to make sure repeated values are not occurring.
Only 64 bits (out of 384 bits) are checked, since this is statistically significant, and more checking would cost more silicon.

### Main State Machine Diagram
The following diagram shows how the main state machine state is constructed.
The larger circles show the how the overall state machine transitions.
The sub-state machines with smaller circles show more detail about how the large circles operate.

![ENTROPY_SRC State Diagram](../doc/es_main_sm.svg)


### Entropy Source Hardware Interface
The following waveform shows an example of how the entropy source hardware interface works, which is much like a FIFO.


```wavejson
{signal: [
   {name: 'clk'           , wave: 'p...|.........|.......'},
   {name: 'es_req'        , wave: '0..1|..01.0..1|.....0.'},
   {name: 'es_ack'        , wave: '0...|.10.10...|....10.'},
   {name: 'es_bus[383:0]' , wave: '0...|.30.30...|....30.', data: ['es0','es1','es2']},
   {name: 'es_fips'       , wave: '0...|....10...|....10.'},
]}
```


### PTRNG Hardware Interface
The following waveform shows an example of what the PTRNG timing looks like.


```wavejson
{signal: [
   {name: 'clk'             , wave: 'p.|......|......|......'},
   {name: 'rng_enable'      , wave: '01|......|......|......'},
   {name: 'rng_valid'       , wave: '0.|..10..|..10..|..10..'},
   {name: 'rng_b'           , wave: 'x.|..3...|..4...|..5.....', data: ['es0','es1','es2']},
]}
```

### Repetition Count Test
The following waveform shows how a sampling of a data pattern will be tested by the Repetition Count test.
Operating on each bit stream, this test will count when a signal is at a stuck level.
This NIST test is intended to signal a catastrophic failure with the PTRNG noise source.

Note that as per definition in SP 800-90B, the Repetition Count test does not operate on a fixed window.
The repetition count test fails if any sequence of bits continuously asserts the same value for too many samples, as determined by the programmable threshold, regardless of whether that sequence crosses any window boundaries.


```wavejson
{signal: [
   {name: 'rng_valid'      , wave: 'p...............'},
  ['rng bits',
   {name: 'rng_bus[3]'     , wave: '1.0.10..1...0101'},
   {name: 'rng_bus[2]'     , wave: '01.0.10..1...010'},
   {name: 'rng_bus[1]'     , wave: '101.0.10..1...01'},
   {name: 'rng_bus[0]'     , wave: '10.10..1...0101.'},
   ],
   {name: 'thresh_i (hex)'      , wave: '3...............',data: ['3']},
   {name: 'rep_cntr_q[3] (hex)' , wave: '4444444444444444',data: ['0','0','1','0','1','0','0','1','2','0','1','2','3','0','0','0']},
   {name: 'rep_cntr_q[2] (hex)' , wave: '4444444444444444',data: ['0','1','0','1','0','1','0','0','1','2','0','1','2','3','0','0']},
   {name: 'rep_cntr_q[1] (hex)' , wave: '4444444444444444',data: ['0','0','0','0','1','0','1','0','0','1','2','0','1','2','3','0']},
   {name: 'rep_cntr_q[0] (hex)' , wave: '4444444444444444',data: ['0','0','0','1','0','0','1','2','0','1','2','3','0','0','0','0']},
   {name: 'test_cnt_q (hex)'    , wave: '4444444444444444',data: ['0','0','0','0','0','0','0','0','0','0','0','1','2','3','4','0']},
   {name: 'window_cnt_q (hex)'  , wave: '5555555555555555',data: ['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f']},
], head:{
   text:'Repetition Count Test',
   tick:0,
  },}
```

### Adaptive Proportion Test
This NIST-defined test is intended to detect statistical bias in the raw entropy data.
The test counts the number of 1's in a given sample, and applies thresholds to reject samples which deviate too far from the ideal mean of 50%.

Depending on the value of the [`CONF.THRESHOLD_SCOPE`](registers.md#conf) field, the thresholds can either be applied collectively to the all RNG inputs, or the thresholds can be applied on a line-by-line basis.
Setting [`CONF.THRESHOLD_SCOPE`](registers.md#conf) to `kMultiBitBool4True` will apply the thresholds to the aggregated RNG stream.
This can be useful for lowering the likelihood of coincidental test failures (higher &alpha;).
Meanwhile, setting [`CONF.THRESHOLD_SCOPE`](registers.md#conf) to `kMultiBitBool4False` will apply thresholds on a line-by-line basis which allows the ENTROPY_SRC to detect single line failures.

The following waveform shows how a sampling of a data pattern will be tested by the Adaptive Proportion test.
In this example, the sum is taken over all RNG lines (i.e., [`CONF.THRESHOLD_SCOPE`](registers.md#conf) is True).

```wavejson
{signal: [
   {name: 'rng_valid'      , wave: 'p...............'},
  ['rng bits',
   {name: 'rng_bus[3]'     , wave: '1.0.10..1...0101'},
   {name: 'rng_bus[2]'     , wave: '01.0.10..1...010'},
   {name: 'rng_bus[1]'     , wave: '101.0.10..1...01'},
   {name: 'rng_bus[0]'     , wave: '10.10..1...0101.'},
   ],
   {name: 'Column-wise sum'   , wave: '3333333333333333',data: ['3','2','2','2','1','1','1','1','2','3', '4', '3', '3', '2', '2','3']},
   {name: 'test_cnt_q (hex)'   , wave: '4444444444444444',data: ['0','3','5','7','9','a','b','c','d','f','12','16','19','1c','1e','20']},
   {name: 'window_cnt_q (hex)' , wave: '5555555555555555',data: ['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f']},
], head:{
   text:'Adaptive Proportion Test',
   tick:0,
  },}
```

### Bucket Test
The following waveform shows how a sampling of a data pattern will be tested by the Bucket test.
Operating on all four bit streams, this test will identify the symbol and sort it into bin counters, or "buckets".
This test is intended to find bias with a symbol or symbols.

```wavejson
{signal: [
   {name: 'rng_valid'      , wave: 'p...............'},
  ['rng bits',
   {name: 'rng_bus[3]'     , wave: '1.0.10..1...0101'},
   {name: 'rng_bus[2]'     , wave: '01.0.10..1...010'},
   {name: 'rng_bus[1]'     , wave: '101.0.10..1...01'},
   {name: 'rng_bus[0]'     , wave: '10.10..1...0101.'},
   ],
   {name: 'thresh_i (hex)'       , wave: '3...............',data: ['3']},
   {name: 'bin_cntr_q[0] (hex)'  , wave: '4...............',data: ['0']},
   {name: 'bin_cntr_q[1] (hex)'  , wave: '4........4......',data: ['0','1']},
   {name: 'bin_cntr_q[2] (hex)'  , wave: '4.......4.......',data: ['0','1']},
   {name: 'bin_cntr_q[13] (hex)' , wave: '4..........4....',data: ['0','1']},
   {name: 'bin_cntr_q[14] (hex)' , wave: '4............4..',data: ['0','1']},
   {name: 'bin_cntr_q[15] (hex)' , wave: '4...........4...',data: ['0','1']},
   {name: 'test_cnt_q (hex)'     , wave: '4...............',data: ['0']},
   {name: 'window_cnt_q (hex)' , wave: '5555555555555555',data: ['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f']},
], head:{
   text:'Bucket Test',
   tick:0,
  },}
```

### Markov Test
The following waveform shows how a sampling of a data pattern will be tested by the Markov test.

The test aims to detect either:

1. Oversampling of AST/RNG outputs leading to "clustered" input values that eventually change, but often are just repeats of the previous sample.
For example the string: "00111111000011000111000111000001111" has roughly equal numbers of 1's and 0's, but no good entropy source should generate such strings, because each bit is likely just a repeat of the previous one.

2. Wild oscillations of the RNG, in a distinctly non-random way.
For instance the string: "010101010101010101" has almost zero entropy, even though the number of 1's and 0's appears unbiased.

The test counts the number of changes in the a fixed number of RNG samples, and comparing the number of "01"/"10" pairs to the number of "00"/"11" pairs.
On average, the number of switching (e.g., "01") vs. non-switching (e.g., "00") pairs should be 50% of the total, with a variance proportional to the sample size.

Like the Adaptive Proportion test, the Markov Test can be computed either cumulatively (summing the results over all RNG lines) or on a per-line basis.
In this example, the RNG lines are scored individually (i.e., [`CONF.THRESHOLD_SCOPE`](registers.md#conf) is False).

```wavejson
{signal: [
   {name: 'rng_valid'      , wave: 'p...............'},
  ['rng bits',
   {name: 'rng_bus[3]'     , wave: '1.0.10..1...0101'},
   {name: 'rng_bus[2]'     , wave: '01.0.10..1...010'},
   {name: 'rng_bus[1]'     , wave: '101.0.10..1...01'},
   {name: 'rng_bus[0]'     , wave: '10.10..1...0101.'},
   ],
   {name: 'pair_cntr_q[3] (hex)', wave: '4.4.4.4.4.4.4.4.',data: ['0','0','0','1','1','1','1','2']},
   {name: 'pair_cntr_q[2] (hex)', wave: '4.4.4.4.4.4.4.4.',data: ['0','1','2','3','3','4','4','5']},
   {name: 'pair_cntr_q[1] (hex)', wave: '4.4.4.4.4.4.4.4.',data: ['0','1','1','1','2','2','2','2']},
   {name: 'pair_cntr_q[0] (hex)', wave: '4.4.4.4.4.4.4.4.',data: ['0','1','2','2','3','3','4','5']},
   {name: 'window_cnt_q (hex)'  , wave: '5555555555555555',data: ['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f']},
], head:{
   text:'Markov Test',
   tick:0,
  },}
```

### External Health Tests

Vendor-specific tests are supported through an external health test interface (xht).
This is the same interface that is used for the internal health tests.
Below is a description of this interface:
- entropy_bit: 4-bit wide bus of entropy to be tested.
- entropy_bit_valid: indication of when the entropy is valid.
- rng_bit_en: indication whether running in single-channel or multi-channel mode.
- rng_bit_sel: 2-bit signal to indicate the selected channel when running in single-channel mode.
- clear: signal to clear counters, and is register driven.
- active: signal to indicate when the test should run, and is register driven.
- thresh_hi: field to indicate what high threshold the test should use, and is register driven.
- thresh_lo: field to indicate what low threshold the test should use, and is register driven.
- health_test_window: 18-bit signal indicating the length of the health test window in symbols.
- window_wrap_pulse: field to indicate the end of the current window.
- threshold_scope: field to indicate whether the thresholds are intended to be applied to all entropy lines collectively or on a line-by-line basis, to be read from a register.
- test_cnt_hi: 16-bit generic test count high result, to be read from a register.
- test_cnt_low: 16-bit generic test count low result, to be read from a register.
- continuous_test: signal to indicate whether the test is running continuously across health test window boundaries.
- test_fail_hi_pulse: indication that a high threshold comparison failed, to be read from a register.
- test_fail_lo_pulse: indication that a low threshold comparison failed, to be read from a register.

================================== Ai Message ==================================
Tool Calls:
  read_file (call_JF9xL2FuO5AmPa5BCOV8Fill)
 Call ID: call_JF9xL2FuO5AmPa5BCOV8Fill
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/entropy_src/doc/registers.md
================================= Tool Message =================================
Name: read_file

# Registers

<!-- BEGIN CMDGEN util/regtool.py -d ./hw/ip/entropy_src/data/entropy_src.hjson -->
## Summary

| Name                                                                  | Offset   |   Length | Description                                                  |
|:----------------------------------------------------------------------|:---------|---------:|:-------------------------------------------------------------|
| entropy_src.[`INTR_STATE`](#intr_state)                               | 0x0      |        4 | Interrupt State Register                                     |
| entropy_src.[`INTR_ENABLE`](#intr_enable)                             | 0x4      |        4 | Interrupt Enable Register                                    |
| entropy_src.[`INTR_TEST`](#intr_test)                                 | 0x8      |        4 | Interrupt Test Register                                      |
| entropy_src.[`ALERT_TEST`](#alert_test)                               | 0xc      |        4 | Alert Test Register                                          |
| entropy_src.[`ME_REGWEN`](#me_regwen)                                 | 0x10     |        4 | Register write enable for module enable register             |
| entropy_src.[`SW_REGUPD`](#sw_regupd)                                 | 0x14     |        4 | Register write enable for control and threshold registers    |
| entropy_src.[`REGWEN`](#regwen)                                       | 0x18     |        4 | Register write enable for all control registers              |
| entropy_src.[`REV`](#rev)                                             | 0x1c     |        4 | Revision register                                            |
| entropy_src.[`MODULE_ENABLE`](#module_enable)                         | 0x20     |        4 | Module enable register                                       |
| entropy_src.[`CONF`](#conf)                                           | 0x24     |        4 | Configuration register                                       |
| entropy_src.[`ENTROPY_CONTROL`](#entropy_control)                     | 0x28     |        4 | Entropy control register                                     |
| entropy_src.[`ENTROPY_DATA`](#entropy_data)                           | 0x2c     |        4 | Entropy data bits                                            |
| entropy_src.[`HEALTH_TEST_WINDOWS`](#health_test_windows)             | 0x30     |        4 | Health test windows register                                 |
| entropy_src.[`REPCNT_THRESHOLDS`](#repcnt_thresholds)                 | 0x34     |        4 | Repetition count test thresholds register                    |
| entropy_src.[`REPCNTS_THRESHOLDS`](#repcnts_thresholds)               | 0x38     |        4 | Repetition count symbol test thresholds register             |
| entropy_src.[`ADAPTP_HI_THRESHOLDS`](#adaptp_hi_thresholds)           | 0x3c     |        4 | Adaptive proportion test high thresholds register            |
| entropy_src.[`ADAPTP_LO_THRESHOLDS`](#adaptp_lo_thresholds)           | 0x40     |        4 | Adaptive proportion test low thresholds register             |
| entropy_src.[`BUCKET_THRESHOLDS`](#bucket_thresholds)                 | 0x44     |        4 | Bucket test thresholds register                              |
| entropy_src.[`MARKOV_HI_THRESHOLDS`](#markov_hi_thresholds)           | 0x48     |        4 | Markov test high thresholds register                         |
| entropy_src.[`MARKOV_LO_THRESHOLDS`](#markov_lo_thresholds)           | 0x4c     |        4 | Markov test low thresholds register                          |
| entropy_src.[`EXTHT_HI_THRESHOLDS`](#extht_hi_thresholds)             | 0x50     |        4 | External health test high thresholds register                |
| entropy_src.[`EXTHT_LO_THRESHOLDS`](#extht_lo_thresholds)             | 0x54     |        4 | External health test low thresholds register                 |
| entropy_src.[`REPCNT_HI_WATERMARKS`](#repcnt_hi_watermarks)           | 0x58     |        4 | Repetition count test high watermarks register               |
| entropy_src.[`REPCNTS_HI_WATERMARKS`](#repcnts_hi_watermarks)         | 0x5c     |        4 | Repetition count symbol test high watermarks register        |
| entropy_src.[`ADAPTP_HI_WATERMARKS`](#adaptp_hi_watermarks)           | 0x60     |        4 | Adaptive proportion test high watermarks register            |
| entropy_src.[`ADAPTP_LO_WATERMARKS`](#adaptp_lo_watermarks)           | 0x64     |        4 | Adaptive proportion test low watermarks register             |
| entropy_src.[`EXTHT_HI_WATERMARKS`](#extht_hi_watermarks)             | 0x68     |        4 | External health test high watermarks register                |
| entropy_src.[`EXTHT_LO_WATERMARKS`](#extht_lo_watermarks)             | 0x6c     |        4 | External health test low watermarks register                 |
| entropy_src.[`BUCKET_HI_WATERMARKS`](#bucket_hi_watermarks)           | 0x70     |        4 | Bucket test high watermarks register                         |
| entropy_src.[`MARKOV_HI_WATERMARKS`](#markov_hi_watermarks)           | 0x74     |        4 | Markov test high watermarks register                         |
| entropy_src.[`MARKOV_LO_WATERMARKS`](#markov_lo_watermarks)           | 0x78     |        4 | Markov test low watermarks register                          |
| entropy_src.[`REPCNT_TOTAL_FAILS`](#repcnt_total_fails)               | 0x7c     |        4 | Repetition count test failure counter register               |
| entropy_src.[`REPCNTS_TOTAL_FAILS`](#repcnts_total_fails)             | 0x80     |        4 | Repetition count symbol test failure counter register        |
| entropy_src.[`ADAPTP_HI_TOTAL_FAILS`](#adaptp_hi_total_fails)         | 0x84     |        4 | Adaptive proportion high test failure counter register       |
| entropy_src.[`ADAPTP_LO_TOTAL_FAILS`](#adaptp_lo_total_fails)         | 0x88     |        4 | Adaptive proportion low test failure counter register        |
| entropy_src.[`BUCKET_TOTAL_FAILS`](#bucket_total_fails)               | 0x8c     |        4 | Bucket test failure counter register                         |
| entropy_src.[`MARKOV_HI_TOTAL_FAILS`](#markov_hi_total_fails)         | 0x90     |        4 | Markov high test failure counter register                    |
| entropy_src.[`MARKOV_LO_TOTAL_FAILS`](#markov_lo_total_fails)         | 0x94     |        4 | Markov low test failure counter register                     |
| entropy_src.[`EXTHT_HI_TOTAL_FAILS`](#extht_hi_total_fails)           | 0x98     |        4 | External health test high threshold failure counter register |
| entropy_src.[`EXTHT_LO_TOTAL_FAILS`](#extht_lo_total_fails)           | 0x9c     |        4 | External health test low threshold failure counter register  |
| entropy_src.[`ALERT_THRESHOLD`](#alert_threshold)                     | 0xa0     |        4 | Alert threshold register                                     |
| entropy_src.[`ALERT_SUMMARY_FAIL_COUNTS`](#alert_summary_fail_counts) | 0xa4     |        4 | Alert summary failure counts register                        |
| entropy_src.[`ALERT_FAIL_COUNTS`](#alert_fail_counts)                 | 0xa8     |        4 | Alert failure counts register                                |
| entropy_src.[`EXTHT_FAIL_COUNTS`](#extht_fail_counts)                 | 0xac     |        4 | External health test alert failure counts register           |
| entropy_src.[`FW_OV_CONTROL`](#fw_ov_control)                         | 0xb0     |        4 | Firmware override control register                           |
| entropy_src.[`FW_OV_SHA3_START`](#fw_ov_sha3_start)                   | 0xb4     |        4 | Firmware override sha3 block start control register          |
| entropy_src.[`FW_OV_WR_FIFO_FULL`](#fw_ov_wr_fifo_full)               | 0xb8     |        4 | Firmware override FIFO write full status register            |
| entropy_src.[`FW_OV_RD_FIFO_OVERFLOW`](#fw_ov_rd_fifo_overflow)       | 0xbc     |        4 | Firmware override observe FIFO overflow status               |
| entropy_src.[`FW_OV_RD_DATA`](#fw_ov_rd_data)                         | 0xc0     |        4 | Firmware override observe FIFO read register                 |
| entropy_src.[`FW_OV_WR_DATA`](#fw_ov_wr_data)                         | 0xc4     |        4 | Firmware override FIFO write register                        |
| entropy_src.[`OBSERVE_FIFO_THRESH`](#observe_fifo_thresh)             | 0xc8     |        4 | Observe FIFO threshold register                              |
| entropy_src.[`OBSERVE_FIFO_DEPTH`](#observe_fifo_depth)               | 0xcc     |        4 | Observe FIFO depth register                                  |
| entropy_src.[`DEBUG_STATUS`](#debug_status)                           | 0xd0     |        4 | Debug status register                                        |
| entropy_src.[`RECOV_ALERT_STS`](#recov_alert_sts)                     | 0xd4     |        4 | Recoverable alert status register                            |
| entropy_src.[`ERR_CODE`](#err_code)                                   | 0xd8     |        4 | Hardware detection of error conditions status register       |
| entropy_src.[`ERR_CODE_TEST`](#err_code_test)                         | 0xdc     |        4 | Test error conditions register                               |
| entropy_src.[`MAIN_SM_STATE`](#main_sm_state)                         | 0xe0     |        4 | Main state machine state debug register                      |

## INTR_STATE
Interrupt State Register
- Offset: `0x0`
- Reset default: `0x0`
- Reset mask: `0xf`

### Fields

```wavejson
{"reg": [{"name": "es_entropy_valid", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"name": "es_health_test_failed", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"name": "es_observe_fifo_ready", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"name": "es_fatal_err", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"bits": 28}], "config": {"lanes": 1, "fontsize": 10, "vspace": 230}}
```

|  Bits  |  Type  |  Reset  | Name                  | Description                                                                                                                                                                             |
|:------:|:------:|:-------:|:----------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  31:4  |        |         |                       | Reserved                                                                                                                                                                                |
|   3    |  rw1c  |   0x0   | es_fatal_err          | Asserted when an fatal error condition is met, e.g., upon FIFO errors, or if an illegal state machine state is reached.                                                                 |
|   2    |  rw1c  |   0x0   | es_observe_fifo_ready | Asserted when the observe FIFO has filled to the configured threshold level (see [`OBSERVE_FIFO_THRESH`](#observe_fifo_thresh)).                                                        |
|   1    |  rw1c  |   0x0   | es_health_test_failed | Asserted whenever the main state machine is in the alert state, e.g., due to health tests failing and reaching the threshold value configured in [`ALERT_THRESHOLD.`](#alert_threshold) |
|   0    |  rw1c  |   0x0   | es_entropy_valid      | Asserted when entropy source bits are available for firmware for consumption via [`ENTROPY_DATA`](#entropy_data) register.                                                              |

## INTR_ENABLE
Interrupt Enable Register
- Offset: `0x4`
- Reset default: `0x0`
- Reset mask: `0xf`

### Fields

```wavejson
{"reg": [{"name": "es_entropy_valid", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "es_health_test_failed", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "es_observe_fifo_ready", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "es_fatal_err", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 28}], "config": {"lanes": 1, "fontsize": 10, "vspace": 230}}
```

|  Bits  |  Type  |  Reset  | Name                  | Description                                                                     |
|:------:|:------:|:-------:|:----------------------|:--------------------------------------------------------------------------------|
|  31:4  |        |         |                       | Reserved                                                                        |
|   3    |   rw   |   0x0   | es_fatal_err          | Enable interrupt when [`INTR_STATE.es_fatal_err`](#intr_state) is set.          |
|   2    |   rw   |   0x0   | es_observe_fifo_ready | Enable interrupt when [`INTR_STATE.es_observe_fifo_ready`](#intr_state) is set. |
|   1    |   rw   |   0x0   | es_health_test_failed | Enable interrupt when [`INTR_STATE.es_health_test_failed`](#intr_state) is set. |
|   0    |   rw   |   0x0   | es_entropy_valid      | Enable interrupt when [`INTR_STATE.es_entropy_valid`](#intr_state) is set.      |

## INTR_TEST
Interrupt Test Register
- Offset: `0x8`
- Reset default: `0x0`
- Reset mask: `0xf`

### Fields

```wavejson
{"reg": [{"name": "es_entropy_valid", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "es_health_test_failed", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "es_observe_fifo_ready", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "es_fatal_err", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 28}], "config": {"lanes": 1, "fontsize": 10, "vspace": 230}}
```

|  Bits  |  Type  |  Reset  | Name                  | Description                                                              |
|:------:|:------:|:-------:|:----------------------|:-------------------------------------------------------------------------|
|  31:4  |        |         |                       | Reserved                                                                 |
|   3    |   wo   |   0x0   | es_fatal_err          | Write 1 to force [`INTR_STATE.es_fatal_err`](#intr_state) to 1.          |
|   2    |   wo   |   0x0   | es_observe_fifo_ready | Write 1 to force [`INTR_STATE.es_observe_fifo_ready`](#intr_state) to 1. |
|   1    |   wo   |   0x0   | es_health_test_failed | Write 1 to force [`INTR_STATE.es_health_test_failed`](#intr_state) to 1. |
|   0    |   wo   |   0x0   | es_entropy_valid      | Write 1 to force [`INTR_STATE.es_entropy_valid`](#intr_state) to 1.      |

## ALERT_TEST
Alert Test Register
- Offset: `0xc`
- Reset default: `0x0`
- Reset mask: `0x3`

### Fields

```wavejson
{"reg": [{"name": "recov_alert", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "fatal_alert", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 30}], "config": {"lanes": 1, "fontsize": 10, "vspace": 130}}
```

|  Bits  |  Type  |  Reset  | Name        | Description                                      |
|:------:|:------:|:-------:|:------------|:-------------------------------------------------|
|  31:2  |        |         |             | Reserved                                         |
|   1    |   wo   |   0x0   | fatal_alert | Write 1 to trigger one alert event of this kind. |
|   0    |   wo   |   0x0   | recov_alert | Write 1 to trigger one alert event of this kind. |

## ME_REGWEN
Register write enable for module enable register
- Offset: `0x10`
- Reset default: `0x1`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "ME_REGWEN", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 110}}
```

|  Bits  |  Type  |  Reset  | Name      | Description                                                                                                  |
|:------:|:------:|:-------:|:----------|:-------------------------------------------------------------------------------------------------------------|
|  31:1  |        |         |           | Reserved                                                                                                     |
|   0    |  rw0c  |   0x1   | ME_REGWEN | When true, the [`MODULE_ENABLE`](#module_enable) register can be modified. When false, it becomes read-only. |

## SW_REGUPD
Register write enable for control and threshold registers
- Offset: `0x14`
- Reset default: `0x1`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "SW_REGUPD", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 110}}
```

|  Bits  |  Type  |  Reset  | Name      | Description                                                                                                                                                                                                            |
|:------:|:------:|:-------:|:----------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  31:1  |        |         |           | Reserved                                                                                                                                                                                                               |
|   0    |  rw0c  |   0x1   | SW_REGUPD | When this bit true and the MODULE_ENABLE field is false, the REGWEN write enable bit read as true, and is distributed to all associated control and threshold registers. When false, these registers become read-only. |

## REGWEN
Register write enable for all control registers
- Offset: `0x18`
- Reset default: `0x1`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "REGWEN", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                      |
|:------:|:------:|:-------:|:--------------------------|
|  31:1  |        |         | Reserved                  |
|   0    |   ro   |   0x1   | [REGWEN](#regwen--regwen) |

### REGWEN . REGWEN
This read-only write enable bit will allow write access to control and threshold registers that are associated with this bit, but only when the [`MODULE_ENABLE`](#module_enable) register is set to `kMultiBitBool4False` and the [`SW_REGUPD`](#sw_regupd) write enable bit is set to true.
When read as false, these registers become read-only.

## REV
Revision register
- Offset: `0x1c`
- Reset default: `0x10303`
- Reset mask: `0xffffff`

### Fields

```wavejson
{"reg": [{"name": "ABI_REVISION", "bits": 8, "attr": ["ro"], "rotate": 0}, {"name": "HW_REVISION", "bits": 8, "attr": ["ro"], "rotate": 0}, {"name": "CHIP_TYPE", "bits": 8, "attr": ["ro"], "rotate": 0}, {"bits": 8}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name         | Description                                                    |
|:------:|:------:|:-------:|:-------------|:---------------------------------------------------------------|
| 31:24  |        |         |              | Reserved                                                       |
| 23:16  |   ro   |   0x1   | CHIP_TYPE    | Read of this register shows the type of chip using this block. |
|  15:8  |   ro   |   0x3   | HW_REVISION  | Read of this register shows the revision of this block.        |
|  7:0   |   ro   |   0x3   | ABI_REVISION | Read of this register shows the ABI of this block.             |

## MODULE_ENABLE
Module enable register
- Offset: `0x20`
- Reset default: `0x9`
- Reset mask: `0xf`
- Register enable: [`ME_REGWEN`](#me_regwen)

### Fields

```wavejson
{"reg": [{"name": "MODULE_ENABLE", "bits": 4, "attr": ["rw"], "rotate": -90}, {"bits": 28}], "config": {"lanes": 1, "fontsize": 10, "vspace": 150}}
```

|  Bits  |  Type  |  Reset  | Name                                           |
|:------:|:------:|:-------:|:-----------------------------------------------|
|  31:4  |        |         | Reserved                                       |
|  3:0   |   rw   |   0x9   | [MODULE_ENABLE](#module_enable--module_enable) |

### MODULE_ENABLE . MODULE_ENABLE
Setting this field to `kMultiBitBool4True` will enable the ENTROPY_SRC module. Setting this field to `kMultiBitBool4False` will effectively reset the module.
The modules of the entropy complex may only be enabled and disabled in a specific order, see Programmers Guide for details.

## CONF
Configuration register
- Offset: `0x24`
- Reset default: `0x2649999`
- Reset mask: `0x3ffffff`
- Register enable: [`REGWEN`](#regwen)

### Fields

```wavejson
{"reg": [{"name": "FIPS_ENABLE", "bits": 4, "attr": ["rw"], "rotate": -90}, {"name": "FIPS_FLAG", "bits": 4, "attr": ["rw"], "rotate": -90}, {"name": "RNG_FIPS", "bits": 4, "attr": ["rw"], "rotate": -90}, {"name": "RNG_BIT_ENABLE", "bits": 4, "attr": ["rw"], "rotate": -90}, {"name": "RNG_BIT_SEL", "bits": 2, "attr": ["rw"], "rotate": -90}, {"name": "THRESHOLD_SCOPE", "bits": 4, "attr": ["rw"], "rotate": -90}, {"name": "ENTROPY_DATA_REG_ENABLE", "bits": 4, "attr": ["rw"], "rotate": -90}, {"bits": 6}], "config": {"lanes": 1, "fontsize": 10, "vspace": 250}}
```

|  Bits  |  Type  |  Reset  | Name                                                      |
|:------:|:------:|:-------:|:----------------------------------------------------------|
| 31:26  |        |         | Reserved                                                  |
| 25:22  |   rw   |   0x9   | [ENTROPY_DATA_REG_ENABLE](#conf--entropy_data_reg_enable) |
| 21:18  |   rw   |   0x9   | [THRESHOLD_SCOPE](#conf--threshold_scope)                 |
| 17:16  |   rw   |   0x0   | [RNG_BIT_SEL](#conf--rng_bit_sel)                         |
| 15:12  |   rw   |   0x9   | [RNG_BIT_ENABLE](#conf--rng_bit_enable)                   |
|  11:8  |   rw   |   0x9   | [RNG_FIPS](#conf--rng_fips)                               |
|  7:4   |   rw   |   0x9   | [FIPS_FLAG](#conf--fips_flag)                             |
|  3:0   |   rw   |   0x9   | [FIPS_ENABLE](#conf--fips_enable)                         |

### CONF . ENTROPY_DATA_REG_ENABLE
Setting this field to `kMultiBitBool4True` will enable reading entropy values from the [`ENTROPY_DATA`](#entropy_data) register.
This function also requires that the otp_en_entropy_src_fw_read input is set to `kMultiBitBool8True`.

### CONF . THRESHOLD_SCOPE
This field controls the scope (either by-line or by-sum) of the health checks.
If set to `kMultiBitBool4True`, the Adaptive Proportion and Markov Tests will accumulate all RNG input lines into a single score, and thresholds will be applied to the sum all the entropy input lines.
If set to `kMultiBitBool4False`, the RNG input lines are all scored individually.
A statistical deviation in any one input line, be it due to coincidence or failure, will force rejection of the sample, and count toward the total alert count.

### CONF . RNG_BIT_SEL
When [`CONF.RNG_BIT_ENABLE`](#conf) is set, this field selects which bit from the RNG bus will be processed.
This two bit field selects the RNG bit stream:
0b00: RNG bit 0
0b01: RNG bit 1
0b10: RNG bit 2
0b11: RNG bit 3

### CONF . RNG_BIT_ENABLE
Setting this field to `kMultiBitBool4True` enables the single RNG bit mode, where only one bit is sampled per symbol.

### CONF . RNG_FIPS
Setting this field to `kMultiBitBool4True` sets the analog RNG into a conservative operation mode that may reduce the bit rate.
In this mode, the RNG potentially outputs entropy with higher entropy per bit and with a simpler sampling mechanism.

### CONF . FIPS_FLAG
This flag indicates that the ENTROPY_SRC is setup with the configuration used for FIPS/CC validation.
Setting this field to `kMultiBitBool4True` will set the FIPS flag for the ENTROPY_SRC block output to true.

### CONF . FIPS_ENABLE
Setting this field to `kMultiBitBool4True` selects the mode targeting FIPS/CC compliance (in short FIPS mode) with hardware conditioning enabled.
The ENTROPY_SRC block will use the FIPS_WINDOW, FIPS_THRESH and FIPS_WATERMARK values of the [`HEALTH_TEST_WINDOWS`](#health_test_windows), health test thresholds and watermark register, respectively.
Whether the ENTROPY_SRC block is indeed running with the configuration used for FIPS/CC validation is under the control of firmware.
Thus, firmware must explicitly mark the produced entropy as FIPS qualified using the [`CONF.FIPS_FLAG`](#conf) field.
Note that the hardware conditioning can still be disabled in FIPS mode by setting both [`ENTROPY_CONTROL.ES_ROUTE`](#entropy_control) and [`ENTROPY_CONTROL.ES_TYPE`](#entropy_control) fields to `kMultiBitBool4True`.
However, no entropy is being passed to the block hardware interface in this mode.

Setting this field to `kMultiBitBool4False` selects the boot-time / bypass mode in which the hardware conditioning is bypassed.

## ENTROPY_CONTROL
Entropy control register
- Offset: `0x28`
- Reset default: `0x99`
- Reset mask: `0xff`
- Register enable: [`REGWEN`](#regwen)

### Fields

```wavejson
{"reg": [{"name": "ES_ROUTE", "bits": 4, "attr": ["rw"], "rotate": -90}, {"name": "ES_TYPE", "bits": 4, "attr": ["rw"], "rotate": -90}, {"bits": 24}], "config": {"lanes": 1, "fontsize": 10, "vspace": 100}}
```

|  Bits  |  Type  |  Reset  | Name                                   |
|:------:|:------:|:-------:|:---------------------------------------|
|  31:8  |        |         | Reserved                               |
|  7:4   |   rw   |   0x9   | [ES_TYPE](#entropy_control--es_type)   |
|  3:0   |   rw   |   0x9   | [ES_ROUTE](#entropy_control--es_route) |

### ENTROPY_CONTROL . ES_TYPE
When this field is `kMultiBitBool4False`, the hardware conditioning inside the ENTROPY_SRC block is enabled.
Setting this field to `kMultiBitBool4True` will bypass the hardware conditioning.
For this to work, also [`ENTROPY_CONTROL.ES_ROUTE`](#entropy_control) needs to be set to `kMultiBitBool4True` to route the unconditioned, raw entropy to the [`ENTROPY_DATA`](#entropy_data) register.
Alternatively, the hardware conditioning can be bypassed by setting [`CONF.FIPS_ENABLE`](#conf) to `kMultiBitBool4False`.
This enables the bypass / boot-time mode.

### ENTROPY_CONTROL . ES_ROUTE
When this field is `kMultiBitBool4False`, the generated entropy will be forwarded out of this module to the hardware interface.
Setting this field to `kMultiBitBool4True` routes the generated entropy to the [`ENTROPY_DATA`](#entropy_data) register to be read by firmware.
Note that for [`ENTROPY_DATA`](#entropy_data) to become readable, also [`CONF.ENTROPY_DATA_REG_ENABLE`](#conf) needs to be set to `kMultiBitBool4True`.
In addition, the otp_en_entropy_src_fw_read input needs to be set to `kMultiBitBool8True`.

## ENTROPY_DATA
Entropy data bits
- Offset: `0x2c`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "ENTROPY_DATA", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                                        |
|:------:|:------:|:-------:|:--------------------------------------------|
|  31:0  |   ro   |    x    | [ENTROPY_DATA](#entropy_data--entropy_data) |

### ENTROPY_DATA . ENTROPY_DATA
A read of this register provides generated entropy bits to firmware.
For this to work also [`CONF.ENTROPY_DATA_REG_ENABLE`](#conf) needs to be set to `kMultiBitBool4True`.
In addition, the otp_en_entropy_src_fw_read input needs to be set to `kMultiBitBool8True`.

## HEALTH_TEST_WINDOWS
Health test windows register
- Offset: `0x30`
- Reset default: `0x600200`
- Reset mask: `0xffffffff`
- Register enable: [`REGWEN`](#regwen)

### Fields

```wavejson
{"reg": [{"name": "FIPS_WINDOW", "bits": 16, "attr": ["rw"], "rotate": 0}, {"name": "BYPASS_WINDOW", "bits": 16, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                                                 |
|:------:|:------:|:-------:|:-----------------------------------------------------|
| 31:16  |   rw   |  0x60   | [BYPASS_WINDOW](#health_test_windows--bypass_window) |
|  15:0  |   rw   |  0x200  | [FIPS_WINDOW](#health_test_windows--fips_window)     |

### HEALTH_TEST_WINDOWS . BYPASS_WINDOW
This is the window size for all health tests when running in bypass mode.
This mode is active after reset for the first and only test run, or when this mode is programmed by firmware by setting [`CONF.FIPS_ENABLE`](#conf) to `kMultiBitBool4False`.
The default value is (384 bits * 1 clock/4 bits);

Note that currently only a window size of 384 is supported and tested (this corresponds to the register default value 0x60).
Do not use any other values, unless you know what you are doing.

### HEALTH_TEST_WINDOWS . FIPS_WINDOW
This is the window size for all health tests.
This value is used when entropy is being tested in FIPS/CC compliance mode (for simplicity referred to as FIPS mode).
The default value is (2048 bits * 1 clock/4 bits);

Note that the number of tested bits taken by the conditioner to produce a seed is equal to the window size x 4.
The only exception is the startup seed which is produced using the bits of two subsequent windows, i.e., 2 x window size x 4 tested bits.
The factor of 4 relates to the number of noise source channels (i.e. symbol size) and applies both in single-channel and multi-channel mode (see [`ENTROPY_SRC.RNG_BIT_ENABLE`](#entropy_src)).

Note that NIST SP 800-90B (Table 2) requires the adaptive proportion test to be run on 1024 or 512 samples in single-channel or multi-channel mode, respectively (see [`ENTROPY_SRC.RNG_BIT_ENABLE`](#entropy_src)).
The startup tests must be run on at least 1024 consecutive samples (see Section 4.3 Requirements for Health Tests of NIST SP 800-90B) and this block always uses two subsequent windows for startup health testing.
The use of window sizes below 512 samples is thus not recommended as this may not comply with NIST SP 800-90B.

## REPCNT_THRESHOLDS
Repetition count test thresholds register
- Offset: `0x34`
- Reset default: `0xffffffff`
- Reset mask: `0xffffffff`
- Register enable: [`REGWEN`](#regwen)

### Fields

```wavejson
{"reg": [{"name": "FIPS_THRESH", "bits": 16, "attr": ["rw"], "rotate": 0}, {"name": "BYPASS_THRESH", "bits": 16, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                                               |
|:------:|:------:|:-------:|:---------------------------------------------------|
| 31:16  |   rw   | 0xffff  | [BYPASS_THRESH](#repcnt_thresholds--bypass_thresh) |
|  15:0  |   rw   | 0xffff  | [FIPS_THRESH](#repcnt_thresholds--fips_thresh)     |

### REPCNT_THRESHOLDS . BYPASS_THRESH
This is the threshold size for the repetition count health test
   running in bypass mode. This mode is active after reset for the
   first and only test run, or when this mode is programmed by firmware.
   This register must be written before the module is enabled.
   Writing to this register will only update the register if the
   written value is less than the current value of this register.
   A read from this register always reflects the current value.

### REPCNT_THRESHOLDS . FIPS_THRESH
This is the threshold size for the repetition count health test.
   This value is used in FIPS mode.
   This register must be written before the module is enabled.
   Writing to this register will only update the register if the
   written value is less than the current value of this register.
   A read from this register always reflects the current value.

## REPCNTS_THRESHOLDS
Repetition count symbol test thresholds register
- Offset: `0x38`
- Reset default: `0xffffffff`
- Reset mask: `0xffffffff`
- Register enable: [`REGWEN`](#regwen)

### Fields

```wavejson
{"reg": [{"name": "FIPS_THRESH", "bits": 16, "attr": ["rw"], "rotate": 0}, {"name": "BYPASS_THRESH", "bits": 16, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                                                |
|:------:|:------:|:-------:|:----------------------------------------------------|
| 31:16  |   rw   | 0xffff  | [BYPASS_THRESH](#repcnts_thresholds--bypass_thresh) |
|  15:0  |   rw   | 0xffff  | [FIPS_THRESH](#repcnts_thresholds--fips_thresh)     |

### REPCNTS_THRESHOLDS . BYPASS_THRESH
This is the threshold size for the repetition count symbol health test
   running in bypass mode. This mode is active after reset for the
   first and only test run, or when this mode is programmed by firmware.
   This register must be written before the module is enabled.
   Writing to this register will only update the register if the
   written value is less than the current value of this register.
   A read from this register always reflects the current value.

### REPCNTS_THRESHOLDS . FIPS_THRESH
This is the threshold size for the repetition count symbol health test.
   This value is used in FIPS mode.
   This register must be written before the module is enabled.
   Writing to this register will only update the register if the
   written value is less than the current value of this register.
   A read from this register always reflects the current value.

## ADAPTP_HI_THRESHOLDS
Adaptive proportion test high thresholds register
- Offset: `0x3c`
- Reset default: `0xffffffff`
- Reset mask: `0xffffffff`
- Register enable: [`REGWEN`](#regwen)

### Fields

```wavejson
{"reg": [{"name": "FIPS_THRESH", "bits": 16, "attr": ["rw"], "rotate": 0}, {"name": "BYPASS_THRESH", "bits": 16, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                                                  |
|:------:|:------:|:-------:|:------------------------------------------------------|
| 31:16  |   rw   | 0xffff  | [BYPASS_THRESH](#adaptp_hi_thresholds--bypass_thresh) |
|  15:0  |   rw   | 0xffff  | [FIPS_THRESH](#adaptp_hi_thresholds--fips_thresh)     |

### ADAPTP_HI_THRESHOLDS . BYPASS_THRESH
This is the threshold size for the adaptive proportion health test
   running in bypass mode. This mode is active after reset for the
   first and only test run, or when this mode is programmed by firmware.
   This register must be written before the module is enabled.
   Writing to this register will only update the register if the
   written value is less than the current value of this register.
   A read from this register always reflects the current value.

### ADAPTP_HI_THRESHOLDS . FIPS_THRESH
This is the threshold size for the adaptive proportion health test.
   This value is used in FIPS mode.
   This register must be written before the module is enabled.
   Writing to this register will only update the register if the
   written value is less than the current value of this register.
   A read from this register always reflects the current value.

## ADAPTP_LO_THRESHOLDS
Adaptive proportion test low thresholds register
- Offset: `0x40`
- Reset default: `0x0`
- Reset mask: `0xffffffff`
- Register enable: [`REGWEN`](#regwen)

### Fields

```wavejson
{"reg": [{"name": "FIPS_THRESH", "bits": 16, "attr": ["rw"], "rotate": 0}, {"name": "BYPASS_THRESH", "bits": 16, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                                                  |
|:------:|:------:|:-------:|:------------------------------------------------------|
| 31:16  |   rw   |   0x0   | [BYPASS_THRESH](#adaptp_lo_thresholds--bypass_thresh) |
|  15:0  |   rw   |   0x0   | [FIPS_THRESH](#adaptp_lo_thresholds--fips_thresh)     |

### ADAPTP_LO_THRESHOLDS . BYPASS_THRESH
This is the threshold size for the adaptive proportion health test
   running in bypass mode. This mode is active after reset for the
   first and only test run, or when this mode is programmed by firmware.
   This register must be written before the module is enabled.
   Writing to this register will only update the register if the
   written value is greater than the current value of this register.
   A read from this register always reflects the current value.

### ADAPTP_LO_THRESHOLDS . FIPS_THRESH
This is the threshold size for the adaptive proportion health test.
   This value is used in FIPS mode.
   This register must be written before the module is enabled.
   Writing to this register will only update the register if the
   written value is greater than the current value of this register.
   A read from this register always reflects the current value.

## BUCKET_THRESHOLDS
Bucket test thresholds register
- Offset: `0x44`
- Reset default: `0xffffffff`
- Reset mask: `0xffffffff`
- Register enable: [`REGWEN`](#regwen)

### Fields

```wavejson
{"reg": [{"name": "FIPS_THRESH", "bits": 16, "attr": ["rw"], "rotate": 0}, {"name": "BYPASS_THRESH", "bits": 16, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                                               |
|:------:|:------:|:-------:|:---------------------------------------------------|
| 31:16  |   rw   | 0xffff  | [BYPASS_THRESH](#bucket_thresholds--bypass_thresh) |
|  15:0  |   rw   | 0xffff  | [FIPS_THRESH](#bucket_thresholds--fips_thresh)     |

### BUCKET_THRESHOLDS . BYPASS_THRESH
This is the threshold size for the bucket health test
   running in bypass mode. This mode is active after reset for the
   first and only test run, or when this mode is programmed by firmware.
   This register must be written before the module is enabled.
   Writing to this register will only update the register if the
   written value is less than the current value of this register.
   A read from this register always reflects the current value.

### BUCKET_THRESHOLDS . FIPS_THRESH
This is the threshold size for the bucket health test.
   This value is used in FIPS mode.
   This register must be written before the module is enabled.
   Writing to this register will only update the register if the
   written value is less than the current value of this register.
   A read from this register always reflects the current value.

## MARKOV_HI_THRESHOLDS
Markov test high thresholds register
- Offset: `0x48`
- Reset default: `0xffffffff`
- Reset mask: `0xffffffff`
- Register enable: [`REGWEN`](#regwen)

### Fields

```wavejson
{"reg": [{"name": "FIPS_THRESH", "bits": 16, "attr": ["rw"], "rotate": 0}, {"name": "BYPASS_THRESH", "bits": 16, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                                                  |
|:------:|:------:|:-------:|:------------------------------------------------------|
| 31:16  |   rw   | 0xffff  | [BYPASS_THRESH](#markov_hi_thresholds--bypass_thresh) |
|  15:0  |   rw   | 0xffff  | [FIPS_THRESH](#markov_hi_thresholds--fips_thresh)     |

### MARKOV_HI_THRESHOLDS . BYPASS_THRESH
This is the threshold size for the Markov health test
   running in bypass mode. This mode is active after reset for the
   first and only test run, or when this mode is programmed by firmware.
   This register must be written before the module is enabled.
   Writing to this register will only update the register if the
   written value is less than the current value of this register.
   A read from this register always reflects the current value.

### MARKOV_HI_THRESHOLDS . FIPS_THRESH
This is the threshold size for the Markov health test.
   This value is used in FIPS mode.
   This register must be written before the module is enabled.
   Writing to this register will only update the register if the
   written value is less than the current value of this register.
   A read from this register always reflects the current value.

## MARKOV_LO_THRESHOLDS
Markov test low thresholds register
- Offset: `0x4c`
- Reset default: `0x0`
- Reset mask: `0xffffffff`
- Register enable: [`REGWEN`](#regwen)

### Fields

```wavejson
{"reg": [{"name": "FIPS_THRESH", "bits": 16, "attr": ["rw"], "rotate": 0}, {"name": "BYPASS_THRESH", "bits": 16, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                                                  |
|:------:|:------:|:-------:|:------------------------------------------------------|
| 31:16  |   rw   |   0x0   | [BYPASS_THRESH](#markov_lo_thresholds--bypass_thresh) |
|  15:0  |   rw   |   0x0   | [FIPS_THRESH](#markov_lo_thresholds--fips_thresh)     |

### MARKOV_LO_THRESHOLDS . BYPASS_THRESH
This is the threshold size for the Markov health test
   running in bypass mode. This mode is active after reset for the
   first and only test run, or when this mode is programmed by firmware.
   This register must be written before the module is enabled.
   Writing to this register will only update the register if the
   written value is greater than the current value of this register.
   A read from this register always reflects the current value.

### MARKOV_LO_THRESHOLDS . FIPS_THRESH
This is the threshold size for the Markov health test.
   This value is used in FIPS mode.
   This register must be written before the module is enabled.
   Writing to this register will only update the register if the
   written value is greater than the current value of this register.
   A read from this register always reflects the current value.

## EXTHT_HI_THRESHOLDS
External health test high thresholds register
- Offset: `0x50`
- Reset default: `0xffffffff`
- Reset mask: `0xffffffff`
- Register enable: [`REGWEN`](#regwen)

### Fields

```wavejson
{"reg": [{"name": "FIPS_THRESH", "bits": 16, "attr": ["rw"], "rotate": 0}, {"name": "BYPASS_THRESH", "bits": 16, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                                                 |
|:------:|:------:|:-------:|:-----------------------------------------------------|
| 31:16  |   rw   | 0xffff  | [BYPASS_THRESH](#extht_hi_thresholds--bypass_thresh) |
|  15:0  |   rw   | 0xffff  | [FIPS_THRESH](#extht_hi_thresholds--fips_thresh)     |

### EXTHT_HI_THRESHOLDS . BYPASS_THRESH
This is the threshold size for the external health test
   running in bypass mode. This mode is active after reset for the
   first and only test run, or when this mode is programmed by firmware.
   This register must be written before the module is enabled.
   Writing to this register will only update the register if the
   written value is less than the current value of this register.
   A read from this register always reflects the current value.

### EXTHT_HI_THRESHOLDS . FIPS_THRESH
This is the threshold size for the external health test.
   This value is used in FIPS mode.
   This register must be written before the module is enabled.
   Writing to this register will only update the register if the
   written value is less than the current value of this register.
   A read from this register always reflects the current value.

## EXTHT_LO_THRESHOLDS
External health test low thresholds register
- Offset: `0x54`
- Reset default: `0x0`
- Reset mask: `0xffffffff`
- Register enable: [`REGWEN`](#regwen)

### Fields

```wavejson
{"reg": [{"name": "FIPS_THRESH", "bits": 16, "attr": ["rw"], "rotate": 0}, {"name": "BYPASS_THRESH", "bits": 16, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                                                 |
|:------:|:------:|:-------:|:-----------------------------------------------------|
| 31:16  |   rw   |   0x0   | [BYPASS_THRESH](#extht_lo_thresholds--bypass_thresh) |
|  15:0  |   rw   |   0x0   | [FIPS_THRESH](#extht_lo_thresholds--fips_thresh)     |

### EXTHT_LO_THRESHOLDS . BYPASS_THRESH
This is the threshold size for the external health test
   running in bypass mode. This mode is active after reset for the
   first and only test run, or when this mode is programmed by firmware.
   This register must be written before the module is enabled.
   Writing to this register will only update the register if the
   written value is greater than the current value of this register.
   A read from this register always reflects the current value.

### EXTHT_LO_THRESHOLDS . FIPS_THRESH
This is the threshold size for the external health test.
   This value is used in FIPS mode.
   This register must be written before the module is enabled.
   Writing to this register will only update the register if the
   written value is greater than the current value of this register.
   A read from this register always reflects the current value.

## REPCNT_HI_WATERMARKS
Repetition count test high watermarks register
- Offset: `0x58`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "FIPS_WATERMARK", "bits": 16, "attr": ["ro"], "rotate": 0}, {"name": "BYPASS_WATERMARK", "bits": 16, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name             | Description                                             |
|:------:|:------:|:-------:|:-----------------|:--------------------------------------------------------|
| 31:16  |   ro   |    x    | BYPASS_WATERMARK | High watermark value of the REPCNT test in bypass mode. |
|  15:0  |   ro   |    x    | FIPS_WATERMARK   | High watermark value of the REPCNT test in FIPS mode.   |

## REPCNTS_HI_WATERMARKS
Repetition count symbol test high watermarks register
- Offset: `0x5c`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "FIPS_WATERMARK", "bits": 16, "attr": ["ro"], "rotate": 0}, {"name": "BYPASS_WATERMARK", "bits": 16, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name             | Description                                              |
|:------:|:------:|:-------:|:-----------------|:---------------------------------------------------------|
| 31:16  |   ro   |    x    | BYPASS_WATERMARK | High watermark value of the REPCNTS test in bypass mode. |
|  15:0  |   ro   |    x    | FIPS_WATERMARK   | High watermark value of the REPCNTS test in FIPS mode.   |

## ADAPTP_HI_WATERMARKS
Adaptive proportion test high watermarks register
- Offset: `0x60`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "FIPS_WATERMARK", "bits": 16, "attr": ["ro"], "rotate": 0}, {"name": "BYPASS_WATERMARK", "bits": 16, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name             | Description                                                          |
|:------:|:------:|:-------:|:-----------------|:---------------------------------------------------------------------|
| 31:16  |   ro   |    x    | BYPASS_WATERMARK | High watermark value of the adaptive proportion test in bypass mode. |
|  15:0  |   ro   |    x    | FIPS_WATERMARK   | High watermark value of the adaptive proportion test in FIPS mode.   |

## ADAPTP_LO_WATERMARKS
Adaptive proportion test low watermarks register
- Offset: `0x64`
- Reset default: `0xffffffff`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "FIPS_WATERMARK", "bits": 16, "attr": ["ro"], "rotate": 0}, {"name": "BYPASS_WATERMARK", "bits": 16, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name             | Description                                                         |
|:------:|:------:|:-------:|:-----------------|:--------------------------------------------------------------------|
| 31:16  |   ro   | 0xffff  | BYPASS_WATERMARK | Low watermark value of the adaptive proportion test in bypass mode. |
|  15:0  |   ro   | 0xffff  | FIPS_WATERMARK   | Low watermark value of the adaptive proportion test in FIPS mode.   |

## EXTHT_HI_WATERMARKS
External health test high watermarks register
- Offset: `0x68`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "FIPS_WATERMARK", "bits": 16, "attr": ["ro"], "rotate": 0}, {"name": "BYPASS_WATERMARK", "bits": 16, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name             | Description                                                      |
|:------:|:------:|:-------:|:-----------------|:-----------------------------------------------------------------|
| 31:16  |   ro   |    x    | BYPASS_WATERMARK | High watermark value of the external health test in bypass mode. |
|  15:0  |   ro   |    x    | FIPS_WATERMARK   | High watermark value of the external health test in FIPS mode.   |

## EXTHT_LO_WATERMARKS
External health test low watermarks register
- Offset: `0x6c`
- Reset default: `0xffffffff`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "FIPS_WATERMARK", "bits": 16, "attr": ["ro"], "rotate": 0}, {"name": "BYPASS_WATERMARK", "bits": 16, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name             | Description                                                     |
|:------:|:------:|:-------:|:-----------------|:----------------------------------------------------------------|
| 31:16  |   ro   | 0xffff  | BYPASS_WATERMARK | Low watermark value of the external health test in bypass mode. |
|  15:0  |   ro   | 0xffff  | FIPS_WATERMARK   | Low watermark value of the external health test in FIPS mode.   |

## BUCKET_HI_WATERMARKS
Bucket test high watermarks register
- Offset: `0x70`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "FIPS_WATERMARK", "bits": 16, "attr": ["ro"], "rotate": 0}, {"name": "BYPASS_WATERMARK", "bits": 16, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name             | Description                                             |
|:------:|:------:|:-------:|:-----------------|:--------------------------------------------------------|
| 31:16  |   ro   |    x    | BYPASS_WATERMARK | High watermark value of the bucket test in bypass mode. |
|  15:0  |   ro   |    x    | FIPS_WATERMARK   | High watermark value of the bucket test in FIPS mode.   |

## MARKOV_HI_WATERMARKS
Markov test high watermarks register
- Offset: `0x74`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "FIPS_WATERMARK", "bits": 16, "attr": ["ro"], "rotate": 0}, {"name": "BYPASS_WATERMARK", "bits": 16, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name             | Description                                             |
|:------:|:------:|:-------:|:-----------------|:--------------------------------------------------------|
| 31:16  |   ro   |    x    | BYPASS_WATERMARK | High watermark value of the Markov test in bypass mode. |
|  15:0  |   ro   |    x    | FIPS_WATERMARK   | High watermark value of the Markov test in FIPS mode.   |

## MARKOV_LO_WATERMARKS
Markov test low watermarks register
- Offset: `0x78`
- Reset default: `0xffffffff`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "FIPS_WATERMARK", "bits": 16, "attr": ["ro"], "rotate": 0}, {"name": "BYPASS_WATERMARK", "bits": 16, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name             | Description                                            |
|:------:|:------:|:-------:|:-----------------|:-------------------------------------------------------|
| 31:16  |   ro   | 0xffff  | BYPASS_WATERMARK | Low watermark value of the Markov test in bypass mode. |
|  15:0  |   ro   | 0xffff  | FIPS_WATERMARK   | Low watermark value of the Markov test in FIPS mode.   |

## REPCNT_TOTAL_FAILS
Repetition count test failure counter register
- Offset: `0x7c`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "REPCNT_TOTAL_FAILS", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name               | Description                                                                                                               |
|:------:|:------:|:-------:|:-------------------|:--------------------------------------------------------------------------------------------------------------------------|
|  31:0  |   ro   |    x    | REPCNT_TOTAL_FAILS | This register will hold a running count of test failures observed during normal operation. It will persist until cleared. |

## REPCNTS_TOTAL_FAILS
Repetition count symbol test failure counter register
- Offset: `0x80`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "REPCNTS_TOTAL_FAILS", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                | Description                                                                                                               |
|:------:|:------:|:-------:|:--------------------|:--------------------------------------------------------------------------------------------------------------------------|
|  31:0  |   ro   |    x    | REPCNTS_TOTAL_FAILS | This register will hold a running count of test failures observed during normal operation. It will persist until cleared. |

## ADAPTP_HI_TOTAL_FAILS
Adaptive proportion high test failure counter register
- Offset: `0x84`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "ADAPTP_HI_TOTAL_FAILS", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                  | Description                                                                                                               |
|:------:|:------:|:-------:|:----------------------|:--------------------------------------------------------------------------------------------------------------------------|
|  31:0  |   ro   |    x    | ADAPTP_HI_TOTAL_FAILS | This register will hold a running count of test failures observed during normal operation. It will persist until cleared. |

## ADAPTP_LO_TOTAL_FAILS
Adaptive proportion low test failure counter register
- Offset: `0x88`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "ADAPTP_LO_TOTAL_FAILS", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                  | Description                                                                                                               |
|:------:|:------:|:-------:|:----------------------|:--------------------------------------------------------------------------------------------------------------------------|
|  31:0  |   ro   |    x    | ADAPTP_LO_TOTAL_FAILS | This register will hold a running count of test failures observed during normal operation. It will persist until cleared. |

## BUCKET_TOTAL_FAILS
Bucket test failure counter register
- Offset: `0x8c`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "BUCKET_TOTAL_FAILS", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name               | Description                                                                                                               |
|:------:|:------:|:-------:|:-------------------|:--------------------------------------------------------------------------------------------------------------------------|
|  31:0  |   ro   |    x    | BUCKET_TOTAL_FAILS | This register will hold a running count of test failures observed during normal operation. It will persist until cleared. |

## MARKOV_HI_TOTAL_FAILS
Markov high test failure counter register
- Offset: `0x90`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "MARKOV_HI_TOTAL_FAILS", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                  | Description                                                                                                               |
|:------:|:------:|:-------:|:----------------------|:--------------------------------------------------------------------------------------------------------------------------|
|  31:0  |   ro   |    x    | MARKOV_HI_TOTAL_FAILS | This register will hold a running count of test failures observed during normal operation. It will persist until cleared. |

## MARKOV_LO_TOTAL_FAILS
Markov low test failure counter register
- Offset: `0x94`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "MARKOV_LO_TOTAL_FAILS", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                  | Description                                                                                                               |
|:------:|:------:|:-------:|:----------------------|:--------------------------------------------------------------------------------------------------------------------------|
|  31:0  |   ro   |    x    | MARKOV_LO_TOTAL_FAILS | This register will hold a running count of test failures observed during normal operation. It will persist until cleared. |

## EXTHT_HI_TOTAL_FAILS
External health test high threshold failure counter register
- Offset: `0x98`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "EXTHT_HI_TOTAL_FAILS", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                 | Description                                                                                                               |
|:------:|:------:|:-------:|:---------------------|:--------------------------------------------------------------------------------------------------------------------------|
|  31:0  |   ro   |    x    | EXTHT_HI_TOTAL_FAILS | This register will hold a running count of test failures observed during normal operation. It will persist until cleared. |

## EXTHT_LO_TOTAL_FAILS
External health test low threshold failure counter register
- Offset: `0x9c`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "EXTHT_LO_TOTAL_FAILS", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                 | Description                                                                                                               |
|:------:|:------:|:-------:|:---------------------|:--------------------------------------------------------------------------------------------------------------------------|
|  31:0  |   ro   |    x    | EXTHT_LO_TOTAL_FAILS | This register will hold a running count of test failures observed during normal operation. It will persist until cleared. |

## ALERT_THRESHOLD
Alert threshold register

This register determines during how many subsequent health test windows one or more health test failures can occur before a recoverable alert is raised and the ENTROPY_SRC block stops operating.
In case the configured threshold is reached, firmware needs to disable/re-enable the block to restart operation including the startup health testing.

Note that when reaching the threshold while running in Firmware Override: Extract & Insert mode, the recoverable alert is not raised nor does the block stop operating.
In other modes, the generation of the recoverable alert can be disabled by configuring a value of zero.
The default value is set to two.
- Offset: `0xa0`
- Reset default: `0xfffd0002`
- Reset mask: `0xffffffff`
- Register enable: [`REGWEN`](#regwen)

### Fields

```wavejson
{"reg": [{"name": "ALERT_THRESHOLD", "bits": 16, "attr": ["rw"], "rotate": 0}, {"name": "ALERT_THRESHOLD_INV", "bits": 16, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                | Description                                                                                    |
|:------:|:------:|:-------:|:--------------------|:-----------------------------------------------------------------------------------------------|
| 31:16  |   rw   | 0xfffd  | ALERT_THRESHOLD_INV | This should be set to the value above, but inverted.                                           |
|  15:0  |   rw   |   0x2   | ALERT_THRESHOLD     | This is the threshold at which a recoverable alert is signaled and the blocks stops operating. |

## ALERT_SUMMARY_FAIL_COUNTS
Alert summary failure counts register

This register holds the total number of subsequent health test windows during which one or more health test failures occurred.
For information on which health tests failed specifically, refer to [`ALERT_FAIL_COUNTS`](#alert_fail_counts) and [`EXTHT_FAIL_COUNTS.`](#extht_fail_counts)

If the value of this register reaches the value configured in the [`ALERT_THRESHOLD`](#alert_threshold) register, a recoverable alert is raised and the ENTROPY_SRC block stops operating.
If an alert is signaled, the value persists until it is cleared by firmware.

The register is automatically cleared after every passing health test window unless the ENTROPY_SRC is configured in Firmware Override: Extract & Insert mode.
The register is also cleared after re-enabling the block.
- Offset: `0xa4`
- Reset default: `0x0`
- Reset mask: `0xffff`

### Fields

```wavejson
{"reg": [{"name": "ANY_FAIL_COUNT", "bits": 16, "attr": ["ro"], "rotate": 0}, {"bits": 16}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name           | Description                                                                                |
|:------:|:------:|:-------:|:---------------|:-------------------------------------------------------------------------------------------|
| 31:16  |        |         |                | Reserved                                                                                   |
|  15:0  |   ro   |    x    | ANY_FAIL_COUNT | The number of subsequent health test windows during which one or more health tests failed. |

## ALERT_FAIL_COUNTS
Alert failure counts register

This register holds the number of health test failures since the last passing health test window.
The values are reported on a per-test basis.
Note that if multiple health tests fail for a certain window, the value in [`ALERT_SUMMARY_FAIL_COUNTS`](#alert_summary_fail_counts) is incremented by just one whereas multiple fields in this register may get incremented.

All fields of this register are automatically cleared after every passing health test window unless the ENTROPY_SRC is configured in Firmware Override: Extract & Insert mode.
The fields are also cleared after re-enabling the block.
- Offset: `0xa8`
- Reset default: `0x0`
- Reset mask: `0xfffffff0`

### Fields

```wavejson
{"reg": [{"bits": 4}, {"name": "REPCNT_FAIL_COUNT", "bits": 4, "attr": ["ro"], "rotate": -90}, {"name": "ADAPTP_HI_FAIL_COUNT", "bits": 4, "attr": ["ro"], "rotate": -90}, {"name": "ADAPTP_LO_FAIL_COUNT", "bits": 4, "attr": ["ro"], "rotate": -90}, {"name": "BUCKET_FAIL_COUNT", "bits": 4, "attr": ["ro"], "rotate": -90}, {"name": "MARKOV_HI_FAIL_COUNT", "bits": 4, "attr": ["ro"], "rotate": -90}, {"name": "MARKOV_LO_FAIL_COUNT", "bits": 4, "attr": ["ro"], "rotate": -90}, {"name": "REPCNTS_FAIL_COUNT", "bits": 4, "attr": ["ro"], "rotate": -90}], "config": {"lanes": 1, "fontsize": 10, "vspace": 220}}
```

|  Bits  |  Type  |  Reset  | Name                 | Description                                                                                                |
|:------:|:------:|:-------:|:---------------------|:-----------------------------------------------------------------------------------------------------------|
| 31:28  |   ro   |    x    | REPCNTS_FAIL_COUNT   | The number of health test windows during which this test failed since the last passing health test window. |
| 27:24  |   ro   |    x    | MARKOV_LO_FAIL_COUNT | The number of health test windows during which this test failed since the last passing health test window. |
| 23:20  |   ro   |    x    | MARKOV_HI_FAIL_COUNT | The number of health test windows during which this test failed since the last passing health test window. |
| 19:16  |   ro   |    x    | BUCKET_FAIL_COUNT    | The number of health test windows during which this test failed since the last passing health test window. |
| 15:12  |   ro   |    x    | ADAPTP_LO_FAIL_COUNT | The number of health test windows during which this test failed since the last passing health test window. |
|  11:8  |   ro   |    x    | ADAPTP_HI_FAIL_COUNT | The number of health test windows during which this test failed since the last passing health test window. |
|  7:4   |   ro   |    x    | REPCNT_FAIL_COUNT    | The number of health test windows during which this test failed since the last passing health test window. |
|  3:0   |        |         |                      | Reserved                                                                                                   |

## EXTHT_FAIL_COUNTS
External health test alert failure counts register

This register holds the number of external health test failures since the last passing health test window.
The values are reported on a per-test basis.
Note that if multiple health tests fail for a certain window, the value in [`ALERT_SUMMARY_FAIL_COUNTS`](#alert_summary_fail_counts) is incremented by just one whereas multiple fields in this register may get incremented.

All fields of this register are automatically cleared after every passing health test window unless the ENTROPY_SRC is configured in Firmware Override: Extract & Insert mode.
The fields are also cleared after re-enabling the block.
- Offset: `0xac`
- Reset default: `0x0`
- Reset mask: `0xff`

### Fields

```wavejson
{"reg": [{"name": "EXTHT_HI_FAIL_COUNT", "bits": 4, "attr": ["ro"], "rotate": -90}, {"name": "EXTHT_LO_FAIL_COUNT", "bits": 4, "attr": ["ro"], "rotate": -90}, {"bits": 24}], "config": {"lanes": 1, "fontsize": 10, "vspace": 210}}
```

|  Bits  |  Type  |  Reset  | Name                | Description                                                                                                |
|:------:|:------:|:-------:|:--------------------|:-----------------------------------------------------------------------------------------------------------|
|  31:8  |        |         |                     | Reserved                                                                                                   |
|  7:4   |   ro   |    x    | EXTHT_LO_FAIL_COUNT | The number of health test windows during which this test failed since the last passing health test window. |
|  3:0   |   ro   |    x    | EXTHT_HI_FAIL_COUNT | The number of health test windows during which this test failed since the last passing health test window. |

## FW_OV_CONTROL
Firmware override control register
- Offset: `0xb0`
- Reset default: `0x99`
- Reset mask: `0xff`
- Register enable: [`REGWEN`](#regwen)

### Fields

```wavejson
{"reg": [{"name": "FW_OV_MODE", "bits": 4, "attr": ["rw"], "rotate": -90}, {"name": "FW_OV_ENTROPY_INSERT", "bits": 4, "attr": ["rw"], "rotate": -90}, {"bits": 24}], "config": {"lanes": 1, "fontsize": 10, "vspace": 220}}
```

|  Bits  |  Type  |  Reset  | Name                                                         |
|:------:|:------:|:-------:|:-------------------------------------------------------------|
|  31:8  |        |         | Reserved                                                     |
|  7:4   |   rw   |   0x9   | [FW_OV_ENTROPY_INSERT](#fw_ov_control--fw_ov_entropy_insert) |
|  3:0   |   rw   |   0x9   | [FW_OV_MODE](#fw_ov_control--fw_ov_mode)                     |

### FW_OV_CONTROL . FW_OV_ENTROPY_INSERT
Setting this field to `kMultiBitBool4True` allows firmware to extract entropy bits by reading the observe FIFO (see [`FW_OV_RD_DATA`](#fw_ov_rd_data)) and insert entropy bits into the entropy flow by writing the [`FW_OV_WR_DATA`](#fw_ov_wr_data) register.
This is useful e.g. for performing additional health tests and/or firmware-based conditioning.
For this to work, [`FW_OV_CONTROL.FW_OV_MODE`](#fw_ov_control) needs to be set to `kMultiBitBool4True`.
In addition, the otp_en_entropy_src_fw_over input needs to be set to `kMultiBitBool8True`.

Firmware can use the hardware conditioning for the inserted entropy bits (see [`FW_OV_SHA3_START`](#fw_ov_sha3_start)).

Note that if the field is set to `kMultiBitBool4True`, post-health test entropy bits do NOT continue to flow through the hardware pipeline.
Also, the [`FW_OV_CONTROL.FW_OV_MODE`](#fw_ov_control) bit must be set.
The observe FIFO will collect 2 kBit of contiguous entropy bits.
Any entropy bits arriving after the observe FIFO is full are being discarded.
Firmware has to read out the entire observe FIFO to restart entropy collection.
Only entropy bits inserted by firmware by writing [`FW_OV_WR_DATA`](#fw_ov_wr_data) may eventually reach the block hardware interface.

Also, the hardware startup health testing is skipped and firmware becomes responsible for performing any startup health testing.

### FW_OV_CONTROL . FW_OV_MODE
Setting this field to `kMultiBitBool4True` will put the entropy flow in firmware override mode.
In this mode, firmware can monitor the post-health test entropy by reading
the observe FIFO (see [`FW_OV_RD_DATA`](#fw_ov_rd_data)).
This includes the entropy bits used for the startup health testing.
For this to work, the otp_en_entropy_src_fw_over input needs to be set to `kMultiBitBool8True`.

Note that the post-health test entropy bits collected in the observe FIFO continue to flow through the hardware pipeline and may eventually reach the block hardware interface.

## FW_OV_SHA3_START
Firmware override sha3 block start control register
- Offset: `0xb4`
- Reset default: `0x9`
- Reset mask: `0xf`

### Fields

```wavejson
{"reg": [{"name": "FW_OV_INSERT_START", "bits": 4, "attr": ["rw"], "rotate": -90}, {"bits": 28}], "config": {"lanes": 1, "fontsize": 10, "vspace": 200}}
```

|  Bits  |  Type  |  Reset  | Name                                                        |
|:------:|:------:|:-------:|:------------------------------------------------------------|
|  31:4  |        |         | Reserved                                                    |
|  3:0   |   rw   |   0x9   | [FW_OV_INSERT_START](#fw_ov_sha3_start--fw_ov_insert_start) |

### FW_OV_SHA3_START . FW_OV_INSERT_START
Setting this field to `kMultiBitBool4True` will instruct the ENTROPY_SRC main state machine to start the SHA3 process and be ready to accept entropy data.
This field should be set prior to writing the [`FW_OV_WR_DATA`](#fw_ov_wr_data) register.
Once all data has been written, this field should be set to `kMultiBitBool4False`.
Once that happened, the SHA3 block will finish processing and push the result into the esfinal FIFO.

Note that clearing this bit to `kMultiBitBool4False` while there is still unprocessed entropy in [`FW_OV_WR_DATA`](#fw_ov_wr_data) will start the SHA3 engine before data can be added to the input message, and will also signal a recoverable alert in [`RECOV_ALERT_STS.ES_FW_OV_DISABLE_ALERT.`](#recov_alert_sts)
To avoid this, check that [`FW_OV_WR_FIFO_FULL`](#fw_ov_wr_fifo_full) is clear before setting this field to `kMultiBitBool4False`.

## FW_OV_WR_FIFO_FULL
Firmware override FIFO write full status register
- Offset: `0xb8`
- Reset default: `0x0`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "FW_OV_WR_FIFO_FULL", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 200}}
```

|  Bits  |  Type  |  Reset  | Name               | Description                                                                                                                                                                                                                    |
|:------:|:------:|:-------:|:-------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  31:1  |        |         |                    | Reserved                                                                                                                                                                                                                       |
|   0    |   ro   |    x    | FW_OV_WR_FIFO_FULL | When this bit is clear, writes to the FW_OV_WR_DATA register are allowed. If this bit is set, it is the equivalent to a FIFO full condition, and writes to the FW_OV_WR_DATA register must be delayed until this bit is reset. |

## FW_OV_RD_FIFO_OVERFLOW
Firmware override observe FIFO overflow status
- Offset: `0xbc`
- Reset default: `0x0`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "FW_OV_RD_FIFO_OVERFLOW", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 240}}
```

|  Bits  |  Type  |  Reset  | Name                                                                      |
|:------:|:------:|:-------:|:--------------------------------------------------------------------------|
|  31:1  |        |         | Reserved                                                                  |
|   0    |   ro   |   0x0   | [FW_OV_RD_FIFO_OVERFLOW](#fw_ov_rd_fifo_overflow--fw_ov_rd_fifo_overflow) |

### FW_OV_RD_FIFO_OVERFLOW . FW_OV_RD_FIFO_OVERFLOW
This bit is set by hardware whenever RNG data is lost due to an overflow condition
in the observe FIFO. The RNG data rate is slow enough that firmware should always
be able to keep up. This register meanwhile provides an additional check to confirm
that bytes read from the [`FW_OV_RD_DATA`](#fw_ov_rd_data) register represent contiguous RNG samples.
If an overflow event occurs, this bit is cleared by hardware as soon as the FIFO is emptied.

## FW_OV_RD_DATA
Firmware override observe FIFO read register
- Offset: `0xc0`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "FW_OV_RD_DATA", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                                           |
|:------:|:------:|:-------:|:-----------------------------------------------|
|  31:0  |   ro   |    x    | [FW_OV_RD_DATA](#fw_ov_rd_data--fw_ov_rd_data) |

### FW_OV_RD_DATA . FW_OV_RD_DATA
A read of this register pops and returns the top of the observe FIFO.
For this to work, the [`FW_OV_CONTROL.FW_OV_MODE`](#fw_ov_control) field needs to be set to `kMultiBitBool4True`
In addition, the otp_en_entropy_src_fw_over input needs to be set to `kMultiBitBool8True`.
Reading this register while the observe FIFO is empty results in a fatal error with [`ERR_CODE.FIFO_READ_ERR`](#err_code) and [`ERR_CODE.SFIFO_OBSERVE_ERR`](#err_code) going high.

## FW_OV_WR_DATA
Firmware override FIFO write register
- Offset: `0xc4`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "FW_OV_WR_DATA", "bits": 32, "attr": ["wo"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                                           |
|:------:|:------:|:-------:|:-----------------------------------------------|
|  31:0  |   wo   |    x    | [FW_OV_WR_DATA](#fw_ov_wr_data--fw_ov_wr_data) |

### FW_OV_WR_DATA . FW_OV_WR_DATA
A write to this register will insert entropy back into the entropy source module flow.
For this to work, both the [`FW_OV_CONTROL.FW_OV_MODE`](#fw_ov_control) and [`FW_OV_CONTROL.FW_OV_ENTROPY_INSERT`](#fw_ov_control) fields need to be set to `kMultiBitBool4True`.
In addition, the otp_en_entropy_src_fw_over input needs to be set to `kMultiBitBool8True`.

## OBSERVE_FIFO_THRESH
Observe FIFO threshold register
- Offset: `0xc8`
- Reset default: `0x10`
- Reset mask: `0x3f`
- Register enable: [`REGWEN`](#regwen)

### Fields

```wavejson
{"reg": [{"name": "OBSERVE_FIFO_THRESH", "bits": 6, "attr": ["rw"], "rotate": -90}, {"bits": 26}], "config": {"lanes": 1, "fontsize": 10, "vspace": 210}}
```

|  Bits  |  Type  |  Reset  | Name                | Description                                                                                                                                                                             |
|:------:|:------:|:-------:|:--------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  31:6  |        |         |                     | Reserved                                                                                                                                                                                |
|  5:0   |   rw   |  0x10   | OBSERVE_FIFO_THRESH | This field will set the threshold that the depth of the observe FIFO will be compared with when setting the interrupt status bit. Note: a value of zero is reserved and not to be used. |

## OBSERVE_FIFO_DEPTH
Observe FIFO depth register
- Offset: `0xcc`
- Reset default: `0x0`
- Reset mask: `0x3f`

### Fields

```wavejson
{"reg": [{"name": "OBSERVE_FIFO_DEPTH", "bits": 6, "attr": ["ro"], "rotate": -90}, {"bits": 26}], "config": {"lanes": 1, "fontsize": 10, "vspace": 200}}
```

|  Bits  |  Type  |  Reset  | Name               | Description                                                 |
|:------:|:------:|:-------:|:-------------------|:------------------------------------------------------------|
|  31:6  |        |         |                    | Reserved                                                    |
|  5:0   |   ro   |    x    | OBSERVE_FIFO_DEPTH | This field will hold the current depth of the observe FIFO. |

## DEBUG_STATUS
Debug status register
- Offset: `0xd0`
- Reset default: `0x10000`
- Reset mask: `0x303fb`

### Fields

```wavejson
{"reg": [{"name": "ENTROPY_FIFO_DEPTH", "bits": 2, "attr": ["ro"], "rotate": -90}, {"bits": 1}, {"name": "SHA3_FSM", "bits": 3, "attr": ["ro"], "rotate": -90}, {"name": "SHA3_BLOCK_PR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "SHA3_SQUEEZING", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "SHA3_ABSORBED", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "SHA3_ERR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 6}, {"name": "MAIN_SM_IDLE", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "MAIN_SM_BOOT_DONE", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 14}], "config": {"lanes": 1, "fontsize": 10, "vspace": 200}}
```

|  Bits  |  Type  |  Reset  | Name               | Description                                                         |
|:------:|:------:|:-------:|:-------------------|:--------------------------------------------------------------------|
| 31:18  |        |         |                    | Reserved                                                            |
|   17   |   ro   |    x    | MAIN_SM_BOOT_DONE  | The entropy_src main state machine is in the boot phase done state. |
|   16   |   ro   |   0x1   | MAIN_SM_IDLE       | The entropy_src main state machine is in the idle state.            |
| 15:10  |        |         |                    | Reserved                                                            |
|   9    |   ro   |    x    | SHA3_ERR           | This is a logic-or of all of the SHA3 error signals.                |
|   8    |   ro   |    x    | SHA3_ABSORBED      | This is the SHA3 absorbed signal current state.                     |
|   7    |   ro   |    x    | SHA3_SQUEEZING     | This is the SHA3 squeezing signal current state.                    |
|   6    |   ro   |    x    | SHA3_BLOCK_PR      | This is the SHA3 block processed signal current state.              |
|  5:3   |   ro   |    x    | SHA3_FSM           | This is the SHA3 finite state machine current state.                |
|   2    |        |         |                    | Reserved                                                            |
|  1:0   |   ro   |    x    | ENTROPY_FIFO_DEPTH | This is the depth of the entropy source FIFO.                       |

## RECOV_ALERT_STS
Recoverable alert status register
- Offset: `0xd4`
- Reset default: `0x0`
- Reset mask: `0x8007ffaf`

### Fields

```wavejson
{"reg": [{"name": "FIPS_ENABLE_FIELD_ALERT", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "ENTROPY_DATA_REG_EN_FIELD_ALERT", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "MODULE_ENABLE_FIELD_ALERT", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "THRESHOLD_SCOPE_FIELD_ALERT", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 1}, {"name": "RNG_BIT_ENABLE_FIELD_ALERT", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 1}, {"name": "FW_OV_SHA3_START_FIELD_ALERT", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "FW_OV_MODE_FIELD_ALERT", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "FW_OV_ENTROPY_INSERT_FIELD_ALERT", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "ES_ROUTE_FIELD_ALERT", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "ES_TYPE_FIELD_ALERT", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "ES_MAIN_SM_ALERT", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "ES_BUS_CMP_ALERT", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "ES_THRESH_CFG_ALERT", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "ES_FW_OV_WR_ALERT", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "ES_FW_OV_DISABLE_ALERT", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "FIPS_FLAG_FIELD_ALERT", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "RNG_FIPS_FIELD_ALERT", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 12}, {"name": "POSTHT_ENTROPY_DROP_ALERT", "bits": 1, "attr": ["rw0c"], "rotate": -90}], "config": {"lanes": 1, "fontsize": 10, "vspace": 340}}
```

|  Bits  |  Type  |  Reset  | Name                                                                                   |
|:------:|:------:|:-------:|:---------------------------------------------------------------------------------------|
|   31   |  rw0c  |   0x0   | [POSTHT_ENTROPY_DROP_ALERT](#recov_alert_sts--postht_entropy_drop_alert)               |
| 30:19  |        |         | Reserved                                                                               |
|   18   |  rw0c  |   0x0   | [RNG_FIPS_FIELD_ALERT](#recov_alert_sts--rng_fips_field_alert)                         |
|   17   |  rw0c  |   0x0   | [FIPS_FLAG_FIELD_ALERT](#recov_alert_sts--fips_flag_field_alert)                       |
|   16   |  rw0c  |   0x0   | [ES_FW_OV_DISABLE_ALERT](#recov_alert_sts--es_fw_ov_disable_alert)                     |
|   15   |  rw0c  |   0x0   | [ES_FW_OV_WR_ALERT](#recov_alert_sts--es_fw_ov_wr_alert)                               |
|   14   |  rw0c  |   0x0   | [ES_THRESH_CFG_ALERT](#recov_alert_sts--es_thresh_cfg_alert)                           |
|   13   |  rw0c  |   0x0   | [ES_BUS_CMP_ALERT](#recov_alert_sts--es_bus_cmp_alert)                                 |
|   12   |  rw0c  |   0x0   | [ES_MAIN_SM_ALERT](#recov_alert_sts--es_main_sm_alert)                                 |
|   11   |  rw0c  |   0x0   | [ES_TYPE_FIELD_ALERT](#recov_alert_sts--es_type_field_alert)                           |
|   10   |  rw0c  |   0x0   | [ES_ROUTE_FIELD_ALERT](#recov_alert_sts--es_route_field_alert)                         |
|   9    |  rw0c  |   0x0   | [FW_OV_ENTROPY_INSERT_FIELD_ALERT](#recov_alert_sts--fw_ov_entropy_insert_field_alert) |
|   8    |  rw0c  |   0x0   | [FW_OV_MODE_FIELD_ALERT](#recov_alert_sts--fw_ov_mode_field_alert)                     |
|   7    |  rw0c  |   0x0   | [FW_OV_SHA3_START_FIELD_ALERT](#recov_alert_sts--fw_ov_sha3_start_field_alert)         |
|   6    |        |         | Reserved                                                                               |
|   5    |  rw0c  |   0x0   | [RNG_BIT_ENABLE_FIELD_ALERT](#recov_alert_sts--rng_bit_enable_field_alert)             |
|   4    |        |         | Reserved                                                                               |
|   3    |  rw0c  |   0x0   | [THRESHOLD_SCOPE_FIELD_ALERT](#recov_alert_sts--threshold_scope_field_alert)           |
|   2    |  rw0c  |   0x0   | [MODULE_ENABLE_FIELD_ALERT](#recov_alert_sts--module_enable_field_alert)               |
|   1    |  rw0c  |   0x0   | [ENTROPY_DATA_REG_EN_FIELD_ALERT](#recov_alert_sts--entropy_data_reg_en_field_alert)   |
|   0    |  rw0c  |   0x0   | [FIPS_ENABLE_FIELD_ALERT](#recov_alert_sts--fips_enable_field_alert)                   |

### RECOV_ALERT_STS . POSTHT_ENTROPY_DROP_ALERT
This bit is set when post-health test entropy bits are being dropped from the hardware pipeline.
The pipeline can drop individual symbols at the input of the postht FIFO (esbit FIFO when running in single-channel mode, see [`ENTROPY_SRC.RNG_BIT_ENABLE`](#entropy_src)).
Entropy bits might get dropped in these locations e.g. due to backpressure from the conditioner.

Note that the conditioner will still use the amount of bits configured in [`HEALTH_TEST_WINDOW.FIPS_WINDOW`](#health_test_window) to produce the seed.
The resulting seed is still okay to use.
But as the dropped bits are still tested, the effective test window increases beyond the value configured in [`HEALTH_TEST_WINDOW.FIPS_WINDOW.`](#health_test_window)

Software should check this bit when running in Firmware Override: Observe mode as dropping post-health test entropy bits in this mode may cause the entropy bits observed from the Observe FIFO to be non-contiguous.

Writing a zero resets this status bit.

### RECOV_ALERT_STS . RNG_FIPS_FIELD_ALERT
This bit is set when the RNG_FIPS field in the [`CONF`](#conf) register is set to a value other than `kMultiBitBool4False` or `kMultiBitBool4True`.
Writing a zero resets this status bit.

### RECOV_ALERT_STS . FIPS_FLAG_FIELD_ALERT
This bit is set when the FIPS_FLAG field in the [`CONF`](#conf) register is set to a value other than `kMultiBitBool4False` or `kMultiBitBool4True`.
Writing a zero resets this status bit.

### RECOV_ALERT_STS . ES_FW_OV_DISABLE_ALERT
This bit is set when [`FW_OV_SHA3_START`](#fw_ov_sha3_start) has been set to `kMultiBitBool4False`, without waiting for the bypass packer FIFO to clear.
The final entropy entry in the FIFO will not be included in the SHA3 digest.
(Rather it will be added to the subsequent SHA3 digest.)
To avoid this alert, monitor [`FW_OV_WR_FIFO_FULL`](#fw_ov_wr_fifo_full) before clearing [`FW_OV_SHA3_START.`](#fw_ov_sha3_start)
This alert only applies when both [`FW_OV_CONTROL.FW_OV_MODE`](#fw_ov_control) and [`FW_OV_CONTROL.FW_OV_ENTROPY_INSERT`](#fw_ov_control) are set to `kMultiBitBool4True`.
Writing a zero resets this status bit.

### RECOV_ALERT_STS . ES_FW_OV_WR_ALERT
This bit is set when the packer FIFO has been written but was full at the time,
and in both FW_OV_MODE and FW_OV_ENTROPY_INSERT modes.
This alert would normally be the result of not monitoring the [`FW_OV_WR_FIFO_FULL`](#fw_ov_wr_fifo_full)
register before each write to the [`FW_OV_WR_DATA`](#fw_ov_wr_data) register.
Writing a zero resets this status bit.

### RECOV_ALERT_STS . ES_THRESH_CFG_ALERT
This bit is set when the [`ALERT_THRESHOLD`](#alert_threshold) register is not configured properly.
The upper field must be the exact inverse of the lower field.
Writing a zero resets this status bit.

### RECOV_ALERT_STS . ES_BUS_CMP_ALERT
This bit is set when the interal entropy bus value is equal to the prior
valid value on the bus, indicating a possible attack.
Writing a zero resets this status bit.

### RECOV_ALERT_STS . ES_MAIN_SM_ALERT
This bit is set when the main state machine detects a threshhold failure state.
Writing a zero resets this status bit.

### RECOV_ALERT_STS . ES_TYPE_FIELD_ALERT
This bit is set when the ES_TYPE field in the [`ENTROPY_CONTROL`](#entropy_control) register is set to a value other than `kMultiBitBool4False` or `kMultiBitBool4True`.
Writing a zero resets this status bit.

### RECOV_ALERT_STS . ES_ROUTE_FIELD_ALERT
This bit is set when the ES_ROUTE field in the [`ENTROPY_CONTROL`](#entropy_control) register is set to a value other than `kMultiBitBool4False` or `kMultiBitBool4True`.
Writing a zero resets this status bit.

### RECOV_ALERT_STS . FW_OV_ENTROPY_INSERT_FIELD_ALERT
This bit is set when the FW_OV_ENTROPY_INSERT field in the [`FW_OV_CONTROL`](#fw_ov_control) register is set to a value other than `kMultiBitBool4False` or `kMultiBitBool4True`.
Writing a zero resets this status bit.

### RECOV_ALERT_STS . FW_OV_MODE_FIELD_ALERT
This bit is set when the FW_OV_MODE field in the [`FW_OV_CONTROL`](#fw_ov_control) register is set to a value other than `kMultiBitBool4False` or `kMultiBitBool4True`.
Writing a zero resets this status bit.

### RECOV_ALERT_STS . FW_OV_SHA3_START_FIELD_ALERT
This bit is set when the FW_OV_SHA3_START field in the [`FW_OV_SHA3_START`](#fw_ov_sha3_start) register is set to a value other than `kMultiBitBool4False` or `kMultiBitBool4True`.
Writing a zero resets this status bit.

### RECOV_ALERT_STS . RNG_BIT_ENABLE_FIELD_ALERT
This bit is set when the RNG_BIT_ENABLE field in the [`CONF`](#conf) register is set to a value other than `kMultiBitBool4False` or `kMultiBitBool4True`.
Writing a zero resets this status bit.

### RECOV_ALERT_STS . THRESHOLD_SCOPE_FIELD_ALERT
This bit is set when the THRESHOLD_SCOPE field in the [`CONF`](#conf) register is set to a value other than `kMultiBitBool4False` or `kMultiBitBool4True`.
Writing a zero resets this status bit.

### RECOV_ALERT_STS . MODULE_ENABLE_FIELD_ALERT
This bit is set when the MODULE_ENABLE field in the [`MODULE_ENABLE`](#module_enable) register is set to a value other than `kMultiBitBool4False` or `kMultiBitBool4True`.
Writing a zero resets this status bit.

### RECOV_ALERT_STS . ENTROPY_DATA_REG_EN_FIELD_ALERT
This bit is set when the ENTROPY_DATA_REG_ENABLE field in the [`CONF`](#conf) register is set to a value other than `kMultiBitBool4False` or `kMultiBitBool4True`.
Writing a zero resets this status bit.

### RECOV_ALERT_STS . FIPS_ENABLE_FIELD_ALERT
This bit is set when the FIPS_ENABLE field in the [`CONF`](#conf) register is set to a value other than `kMultiBitBool4False` or `kMultiBitBool4True`.
Writing a zero resets this status bit.

## ERR_CODE
Hardware detection of error conditions status register
- Offset: `0xd8`
- Reset default: `0x0`
- Reset mask: `0x71f0000f`

### Fields

```wavejson
{"reg": [{"name": "SFIFO_ESRNG_ERR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "SFIFO_DISTR_ERR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "SFIFO_OBSERVE_ERR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "SFIFO_ESFINAL_ERR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 16}, {"name": "ES_ACK_SM_ERR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "ES_MAIN_SM_ERR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "ES_CNTR_ERR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "SHA3_STATE_ERR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "SHA3_RST_STORAGE_ERR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 3}, {"name": "FIFO_WRITE_ERR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "FIFO_READ_ERR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "FIFO_STATE_ERR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 1}], "config": {"lanes": 1, "fontsize": 10, "vspace": 220}}
```

|  Bits  |  Type  |  Reset  | Name                                                    |
|:------:|:------:|:-------:|:--------------------------------------------------------|
|   31   |        |         | Reserved                                                |
|   30   |   ro   |   0x0   | [FIFO_STATE_ERR](#err_code--fifo_state_err)             |
|   29   |   ro   |   0x0   | [FIFO_READ_ERR](#err_code--fifo_read_err)               |
|   28   |   ro   |   0x0   | [FIFO_WRITE_ERR](#err_code--fifo_write_err)             |
| 27:25  |        |         | Reserved                                                |
|   24   |   ro   |   0x0   | [SHA3_RST_STORAGE_ERR](#err_code--sha3_rst_storage_err) |
|   23   |   ro   |   0x0   | [SHA3_STATE_ERR](#err_code--sha3_state_err)             |
|   22   |   ro   |   0x0   | [ES_CNTR_ERR](#err_code--es_cntr_err)                   |
|   21   |   ro   |   0x0   | [ES_MAIN_SM_ERR](#err_code--es_main_sm_err)             |
|   20   |   ro   |   0x0   | [ES_ACK_SM_ERR](#err_code--es_ack_sm_err)               |
|  19:4  |        |         | Reserved                                                |
|   3    |   ro   |   0x0   | [SFIFO_ESFINAL_ERR](#err_code--sfifo_esfinal_err)       |
|   2    |   ro   |   0x0   | [SFIFO_OBSERVE_ERR](#err_code--sfifo_observe_err)       |
|   1    |   ro   |   0x0   | [SFIFO_DISTR_ERR](#err_code--sfifo_distr_err)           |
|   0    |   ro   |   0x0   | [SFIFO_ESRNG_ERR](#err_code--sfifo_esrng_err)           |

### ERR_CODE . FIFO_STATE_ERR
This bit will be set to one when any of the source bits (bits 0 through 3 of this register) are asserted as a result of an error pulse generated from any FIFO where either both the empty and full status bits are set or in case of error conditions inside the hardened counters.
This bit will stay set until the next reset.

### ERR_CODE . FIFO_READ_ERR
This bit will be set to one when any of the source bits (bits 0 through 3 of this register) are asserted as a result of an error pulse generated from any empty FIFO that has received a read pulse.
This bit will stay set until the next reset.

### ERR_CODE . FIFO_WRITE_ERR
This bit will be set to one when any of the source bits (bits 0 through 3 of this register) are asserted as a result of an error pulse generated from any full FIFO that has been received a write pulse.
This bit will stay set until the next reset.

### ERR_CODE . SHA3_RST_STORAGE_ERR
This bit will be set to one when a SHA3_RST_STORAGE_ERR signal being
active has been detected.
This error will signal a fatal alert, and also an interrupt if enabled.
This bit will stay set until the next reset.

### ERR_CODE . SHA3_STATE_ERR
This bit will be set to one when a SHA3 state error has been detected.
This error will signal a fatal alert, and also an interrupt if enabled.
This bit will stay set until the next reset.

### ERR_CODE . ES_CNTR_ERR
This bit will be set to one when a hardened counter has detected an error
condition. This error will signal a fatal alert, and also
an interrupt if enabled.
This bit will stay set until the next reset.

### ERR_CODE . ES_MAIN_SM_ERR
This bit will be set to one when an illegal state has been detected for the
ES main stage state machine. This error will signal a fatal alert, and also
an interrupt if enabled.
This bit will stay set until the next reset.

### ERR_CODE . ES_ACK_SM_ERR
This bit will be set to one when an illegal state has been detected for the
ES ack stage state machine. This error will signal a fatal alert, and also
an interrupt if enabled.
This bit will stay set until the next reset.

### ERR_CODE . SFIFO_ESFINAL_ERR
This bit will be set to one when an error has been detected for the
esfinal FIFO. The type of error is reflected in the type status
bits (bits 28 through 30 of this register).
This bit will stay set until the next reset.

### ERR_CODE . SFIFO_OBSERVE_ERR
This bit will be set to one when an error has been detected for the
observe FIFO. The type of error is reflected in the type status
bits (bits 28 through 30 of this register).
This bit will stay set until the next reset.

### ERR_CODE . SFIFO_DISTR_ERR
This bit will be set to one when an error has been detected for the distribution FIFO.
The type of error is reflected in the type status bits (bits 28 through 30 of this register).
This bit will stay set until the next reset.

### ERR_CODE . SFIFO_ESRNG_ERR
This bit will be set to one when an error has been detected for the
esrng FIFO. The type of error is reflected in the type status
bits (bits 28 through 30 of this register).
This bit will stay set until the next reset.

## ERR_CODE_TEST
Test error conditions register
- Offset: `0xdc`
- Reset default: `0x0`
- Reset mask: `0x1f`

### Fields

```wavejson
{"reg": [{"name": "ERR_CODE_TEST", "bits": 5, "attr": ["rw"], "rotate": -90}, {"bits": 27}], "config": {"lanes": 1, "fontsize": 10, "vspace": 150}}
```

|  Bits  |  Type  |  Reset  | Name                                           |
|:------:|:------:|:-------:|:-----------------------------------------------|
|  31:5  |        |         | Reserved                                       |
|  4:0   |   rw   |   0x0   | [ERR_CODE_TEST](#err_code_test--err_code_test) |

### ERR_CODE_TEST . ERR_CODE_TEST
Setting this field will set the bit number for which an error
will be forced in the hardware. This bit number is that same one
found in the [`ERR_CODE`](#err_code) register. The action of writing this
register will force an error pulse. The sole purpose of this
register is to test that any error properly propagates to either
an interrupt or an alert.

## MAIN_SM_STATE
Main state machine state debug register
- Offset: `0xe0`
- Reset default: `0xf5`
- Reset mask: `0x1ff`

### Fields

```wavejson
{"reg": [{"name": "MAIN_SM_STATE", "bits": 9, "attr": ["ro"], "rotate": 0}, {"bits": 23}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name          | Description                                                                                                                    |
|:------:|:------:|:-------:|:--------------|:-------------------------------------------------------------------------------------------------------------------------------|
|  31:9  |        |         |               | Reserved                                                                                                                       |
|  8:0   |   ro   |  0xf5   | MAIN_SM_STATE | This is the state of the ENTROPY_SRC main state machine. See the RTL file `entropy_src_main_sm` for the meaning of the values. |


<!-- END CMDGEN -->

================================== Ai Message ==================================
Tool Calls:
  list_dir (call_3QUxurxTENEqq5c45pNFMCCk)
 Call ID: call_3QUxurxTENEqq5c45pNFMCCk
  Args:
    dir_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/entropy_src/rtl
================================= Tool Message =================================
Name: list_dir

Files in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/entropy_src/rtl:
entropy_src_ack_sm_pkg.core entropy_src_reg_pkg.sv entropy_src_adaptp_ht.sv entropy_src_markov_ht.sv entropy_src_bucket_ht.sv entropy_src_enable_delay.sv entropy_src_main_sm.sv entropy_src_ack_sm_pkg.sv entropy_src_ack_sm.sv entropy_src_pkg.sv entropy_src_reg_top.sv entropy_src_repcnt_ht.sv entropy_src_core.sv entropy_src_watermark_reg.sv entropy_src_cntr_reg.sv entropy_src_main_sm_pkg.sv entropy_src_main_sm_pkg.core entropy_src_repcnts_ht.sv entropy_src.sv entropy_src_field_en.sv

Directories in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/entropy_src/rtl:

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_nufKEhId6B6UtddHewx6cAtj)
 Call ID: call_nufKEhId6B6UtddHewx6cAtj
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/entropy_src/rtl/entropy_src_reg_top.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Register Top module auto-generated by `reggen`
6: 
7: `include "prim_assert.sv"
8: 
9: module entropy_src_reg_top (
10:   input clk_i,
11:   input rst_ni,
12:   input  tlul_pkg::tl_h2d_t tl_i,
13:   output tlul_pkg::tl_d2h_t tl_o,
14:   // To HW
15:   output entropy_src_reg_pkg::entropy_src_reg2hw_t reg2hw, // Write
16:   input  entropy_src_reg_pkg::entropy_src_hw2reg_t hw2reg, // Read
17: 
18:   // Integrity check errors
19:   output logic intg_err_o
20: );
21: 
22:   import entropy_src_reg_pkg::* ;
23: 
24:   localparam int AW = 8;
25:   localparam int DW = 32;
26:   localparam int DBW = DW/8;                    // Byte Width
27: 
28:   // register signals
29:   logic           reg_we;
30:   logic           reg_re;
31:   logic [AW-1:0]  reg_addr;
32:   logic [DW-1:0]  reg_wdata;
33:   logic [DBW-1:0] reg_be;
34:   logic [DW-1:0]  reg_rdata;
35:   logic           reg_error;
36: 
37:   logic          addrmiss, wr_err;
38: 
39:   logic [DW-1:0] reg_rdata_next;
40:   logic reg_busy;
41: 
42:   tlul_pkg::tl_h2d_t tl_reg_h2d;
43:   tlul_pkg::tl_d2h_t tl_reg_d2h;
44: 
45: 
46:   // incoming payload check
47:   logic intg_err;
48:   tlul_cmd_intg_chk u_chk (
49:     .tl_i(tl_i),
50:     .err_o(intg_err)
51:   );
52: 
53:   // also check for spurious write enables
54:   logic reg_we_err;
55:   logic [56:0] reg_we_check;
56:   prim_reg_we_check #(
57:     .OneHotWidth(57)
58:   ) u_prim_reg_we_check (
59:     .clk_i(clk_i),
60:     .rst_ni(rst_ni),
61:     .oh_i  (reg_we_check),
62:     .en_i  (reg_we && !addrmiss),
63:     .err_o (reg_we_err)
64:   );
65: 
66:   logic err_q;
67:   always_ff @(posedge clk_i or negedge rst_ni) begin
68:     if (!rst_ni) begin
69:       err_q <= '0;
70:     end else if (intg_err || reg_we_err) begin
71:       err_q <= 1'b1;
72:     end
73:   end
74: 
75:   // integrity error output is permanent and should be used for alert generation
76:   // register errors are transactional
77:   assign intg_err_o = err_q | intg_err | reg_we_err;
78: 
79:   // outgoing integrity generation
80:   tlul_pkg::tl_d2h_t tl_o_pre;
81:   tlul_rsp_intg_gen #(
82:     .EnableRspIntgGen(1),
83:     .EnableDataIntgGen(1)
84:   ) u_rsp_intg_gen (
85:     .tl_i(tl_o_pre),
86:     .tl_o(tl_o)
87:   );
88: 
89:   assign tl_reg_h2d = tl_i;
90:   assign tl_o_pre   = tl_reg_d2h;
91: 
92:   tlul_adapter_reg #(
93:     .RegAw(AW),
94:     .RegDw(DW),
95:     .EnableDataIntgGen(0)
96:   ) u_reg_if (
97:     .clk_i  (clk_i),
98:     .rst_ni (rst_ni),
99: 
100:     .tl_i (tl_reg_h2d),
101:     .tl_o (tl_reg_d2h),
102: 
103:     .en_ifetch_i(prim_mubi_pkg::MuBi4False),
104:     .intg_error_o(),
105: 
106:     .we_o    (reg_we),
107:     .re_o    (reg_re),
108:     .addr_o  (reg_addr),
109:     .wdata_o (reg_wdata),
110:     .be_o    (reg_be),
111:     .busy_i  (reg_busy),
112:     .rdata_i (reg_rdata),
113:     .error_i (reg_error)
114:   );
115: 
116:   // cdc oversampling signals
117: 
118:   assign reg_rdata = reg_rdata_next ;
119:   assign reg_error = addrmiss | wr_err | intg_err;
120: 
121:   // Define SW related signals
122:   // Format: <reg>_<field>_{wd|we|qs}
123:   //        or <reg>_{wd|we|qs} if field == 1 or 0
124:   logic intr_state_we;
125:   logic intr_state_es_entropy_valid_qs;
126:   logic intr_state_es_entropy_valid_wd;
127:   logic intr_state_es_health_test_failed_qs;
128:   logic intr_state_es_health_test_failed_wd;
129:   logic intr_state_es_observe_fifo_ready_qs;
130:   logic intr_state_es_observe_fifo_ready_wd;
131:   logic intr_state_es_fatal_err_qs;
132:   logic intr_state_es_fatal_err_wd;
133:   logic intr_enable_we;
134:   logic intr_enable_es_entropy_valid_qs;
135:   logic intr_enable_es_entropy_valid_wd;
136:   logic intr_enable_es_health_test_failed_qs;
137:   logic intr_enable_es_health_test_failed_wd;
138:   logic intr_enable_es_observe_fifo_ready_qs;
139:   logic intr_enable_es_observe_fifo_ready_wd;
140:   logic intr_enable_es_fatal_err_qs;
141:   logic intr_enable_es_fatal_err_wd;
142:   logic intr_test_we;
143:   logic intr_test_es_entropy_valid_wd;
144:   logic intr_test_es_health_test_failed_wd;
145:   logic intr_test_es_observe_fifo_ready_wd;
146:   logic intr_test_es_fatal_err_wd;
147:   logic alert_test_we;
148:   logic alert_test_recov_alert_wd;
149:   logic alert_test_fatal_alert_wd;
150:   logic me_regwen_we;
151:   logic me_regwen_qs;
152:   logic me_regwen_wd;
153:   logic sw_regupd_we;
154:   logic sw_regupd_qs;
155:   logic sw_regupd_wd;
156:   logic regwen_qs;
157:   logic [7:0] rev_abi_revision_qs;
158:   logic [7:0] rev_hw_revision_qs;
159:   logic [7:0] rev_chip_type_qs;
160:   logic module_enable_we;
161:   logic [3:0] module_enable_qs;
162:   logic [3:0] module_enable_wd;
163:   logic conf_we;
164:   logic [3:0] conf_fips_enable_qs;
165:   logic [3:0] conf_fips_enable_wd;
166:   logic [3:0] conf_fips_flag_qs;
167:   logic [3:0] conf_fips_flag_wd;
168:   logic [3:0] conf_rng_fips_qs;
169:   logic [3:0] conf_rng_fips_wd;
170:   logic [3:0] conf_rng_bit_enable_qs;
171:   logic [3:0] conf_rng_bit_enable_wd;
172:   logic [1:0] conf_rng_bit_sel_qs;
173:   logic [1:0] conf_rng_bit_sel_wd;
174:   logic [3:0] conf_threshold_scope_qs;
175:   logic [3:0] conf_threshold_scope_wd;
176:   logic [3:0] conf_entropy_data_reg_enable_qs;
177:   logic [3:0] conf_entropy_data_reg_enable_wd;
178:   logic entropy_control_we;
179:   logic [3:0] entropy_control_es_route_qs;
180:   logic [3:0] entropy_control_es_route_wd;
181:   logic [3:0] entropy_control_es_type_qs;
182:   logic [3:0] entropy_control_es_type_wd;
183:   logic entropy_data_re;
184:   logic [31:0] entropy_data_qs;
185:   logic health_test_windows_we;
186:   logic [15:0] health_test_windows_fips_window_qs;
187:   logic [15:0] health_test_windows_fips_window_wd;
188:   logic [15:0] health_test_windows_bypass_window_qs;
189:   logic [15:0] health_test_windows_bypass_window_wd;
190:   logic repcnt_thresholds_re;
191:   logic repcnt_thresholds_we;
192:   logic [15:0] repcnt_thresholds_fips_thresh_qs;
193:   logic [15:0] repcnt_thresholds_fips_thresh_wd;
194:   logic [15:0] repcnt_thresholds_bypass_thresh_qs;
195:   logic [15:0] repcnt_thresholds_bypass_thresh_wd;
196:   logic repcnts_thresholds_re;
197:   logic repcnts_thresholds_we;
198:   logic [15:0] repcnts_thresholds_fips_thresh_qs;
199:   logic [15:0] repcnts_thresholds_fips_thresh_wd;
200:   logic [15:0] repcnts_thresholds_bypass_thresh_qs;
201:   logic [15:0] repcnts_thresholds_bypass_thresh_wd;
202:   logic adaptp_hi_thresholds_re;
203:   logic adaptp_hi_thresholds_we;
204:   logic [15:0] adaptp_hi_thresholds_fips_thresh_qs;
205:   logic [15:0] adaptp_hi_thresholds_fips_thresh_wd;
206:   logic [15:0] adaptp_hi_thresholds_bypass_thresh_qs;
207:   logic [15:0] adaptp_hi_thresholds_bypass_thresh_wd;
208:   logic adaptp_lo_thresholds_re;
209:   logic adaptp_lo_thresholds_we;
210:   logic [15:0] adaptp_lo_thresholds_fips_thresh_qs;
211:   logic [15:0] adaptp_lo_thresholds_fips_thresh_wd;
212:   logic [15:0] adaptp_lo_thresholds_bypass_thresh_qs;
213:   logic [15:0] adaptp_lo_thresholds_bypass_thresh_wd;
214:   logic bucket_thresholds_re;
215:   logic bucket_thresholds_we;
216:   logic [15:0] bucket_thresholds_fips_thresh_qs;
217:   logic [15:0] bucket_thresholds_fips_thresh_wd;
218:   logic [15:0] bucket_thresholds_bypass_thresh_qs;
219:   logic [15:0] bucket_thresholds_bypass_thresh_wd;
220:   logic markov_hi_thresholds_re;
221:   logic markov_hi_thresholds_we;
222:   logic [15:0] markov_hi_thresholds_fips_thresh_qs;
223:   logic [15:0] markov_hi_thresholds_fips_thresh_wd;
224:   logic [15:0] markov_hi_thresholds_bypass_thresh_qs;
225:   logic [15:0] markov_hi_thresholds_bypass_thresh_wd;
226:   logic markov_lo_thresholds_re;
227:   logic markov_lo_thresholds_we;
228:   logic [15:0] markov_lo_thresholds_fips_thresh_qs;
229:   logic [15:0] markov_lo_thresholds_fips_thresh_wd;
230:   logic [15:0] markov_lo_thresholds_bypass_thresh_qs;
231:   logic [15:0] markov_lo_thresholds_bypass_thresh_wd;
232:   logic extht_hi_thresholds_re;
233:   logic extht_hi_thresholds_we;
234:   logic [15:0] extht_hi_thresholds_fips_thresh_qs;
235:   logic [15:0] extht_hi_thresholds_fips_thresh_wd;
236:   logic [15:0] extht_hi_thresholds_bypass_thresh_qs;
237:   logic [15:0] extht_hi_thresholds_bypass_thresh_wd;
238:   logic extht_lo_thresholds_re;
239:   logic extht_lo_thresholds_we;
240:   logic [15:0] extht_lo_thresholds_fips_thresh_qs;
241:   logic [15:0] extht_lo_thresholds_fips_thresh_wd;
242:   logic [15:0] extht_lo_thresholds_bypass_thresh_qs;
243:   logic [15:0] extht_lo_thresholds_bypass_thresh_wd;
244:   logic repcnt_hi_watermarks_re;
245:   logic [15:0] repcnt_hi_watermarks_fips_watermark_qs;
246:   logic [15:0] repcnt_hi_watermarks_bypass_watermark_qs;
247:   logic repcnts_hi_watermarks_re;
248:   logic [15:0] repcnts_hi_watermarks_fips_watermark_qs;
249:   logic [15:0] repcnts_hi_watermarks_bypass_watermark_qs;
250:   logic adaptp_hi_watermarks_re;
251:   logic [15:0] adaptp_hi_watermarks_fips_watermark_qs;
252:   logic [15:0] adaptp_hi_watermarks_bypass_watermark_qs;
253:   logic adaptp_lo_watermarks_re;
254:   logic [15:0] adaptp_lo_watermarks_fips_watermark_qs;
255:   logic [15:0] adaptp_lo_watermarks_bypass_watermark_qs;
256:   logic extht_hi_watermarks_re;
257:   logic [15:0] extht_hi_watermarks_fips_watermark_qs;
258:   logic [15:0] extht_hi_watermarks_bypass_watermark_qs;
259:   logic extht_lo_watermarks_re;
260:   logic [15:0] extht_lo_watermarks_fips_watermark_qs;
261:   logic [15:0] extht_lo_watermarks_bypass_watermark_qs;
262:   logic bucket_hi_watermarks_re;
263:   logic [15:0] bucket_hi_watermarks_fips_watermark_qs;
264:   logic [15:0] bucket_hi_watermarks_bypass_watermark_qs;
265:   logic markov_hi_watermarks_re;
266:   logic [15:0] markov_hi_watermarks_fips_watermark_qs;
267:   logic [15:0] markov_hi_watermarks_bypass_watermark_qs;
268:   logic markov_lo_watermarks_re;
269:   logic [15:0] markov_lo_watermarks_fips_watermark_qs;
270:   logic [15:0] markov_lo_watermarks_bypass_watermark_qs;
271:   logic repcnt_total_fails_re;
272:   logic [31:0] repcnt_total_fails_qs;
273:   logic repcnts_total_fails_re;
274:   logic [31:0] repcnts_total_fails_qs;
275:   logic adaptp_hi_total_fails_re;
276:   logic [31:0] adaptp_hi_total_fails_qs;
277:   logic adaptp_lo_total_fails_re;
278:   logic [31:0] adaptp_lo_total_fails_qs;
279:   logic bucket_total_fails_re;
280:   logic [31:0] bucket_total_fails_qs;
281:   logic markov_hi_total_fails_re;
282:   logic [31:0] markov_hi_total_fails_qs;
283:   logic markov_lo_total_fails_re;
284:   logic [31:0] markov_lo_total_fails_qs;
285:   logic extht_hi_total_fails_re;
286:   logic [31:0] extht_hi_total_fails_qs;
287:   logic extht_lo_total_fails_re;
288:   logic [31:0] extht_lo_total_fails_qs;
289:   logic alert_threshold_we;
290:   logic [15:0] alert_threshold_alert_threshold_qs;
291:   logic [15:0] alert_threshold_alert_threshold_wd;
292:   logic [15:0] alert_threshold_alert_threshold_inv_qs;
293:   logic [15:0] alert_threshold_alert_threshold_inv_wd;
294:   logic alert_summary_fail_counts_re;
295:   logic [15:0] alert_summary_fail_counts_qs;
296:   logic alert_fail_counts_re;
297:   logic [3:0] alert_fail_counts_repcnt_fail_count_qs;
298:   logic [3:0] alert_fail_counts_adaptp_hi_fail_count_qs;
299:   logic [3:0] alert_fail_counts_adaptp_lo_fail_count_qs;
300:   logic [3:0] alert_fail_counts_bucket_fail_count_qs;
301:   logic [3:0] alert_fail_counts_markov_hi_fail_count_qs;
302:   logic [3:0] alert_fail_counts_markov_lo_fail_count_qs;
303:   logic [3:0] alert_fail_counts_repcnts_fail_count_qs;
304:   logic extht_fail_counts_re;
305:   logic [3:0] extht_fail_counts_extht_hi_fail_count_qs;
306:   logic [3:0] extht_fail_counts_extht_lo_fail_count_qs;
307:   logic fw_ov_control_we;
308:   logic [3:0] fw_ov_control_fw_ov_mode_qs;
309:   logic [3:0] fw_ov_control_fw_ov_mode_wd;
310:   logic [3:0] fw_ov_control_fw_ov_entropy_insert_qs;
311:   logic [3:0] fw_ov_control_fw_ov_entropy_insert_wd;
312:   logic fw_ov_sha3_start_we;
313:   logic [3:0] fw_ov_sha3_start_qs;
314:   logic [3:0] fw_ov_sha3_start_wd;
315:   logic fw_ov_wr_fifo_full_re;
316:   logic fw_ov_wr_fifo_full_qs;
317:   logic fw_ov_rd_fifo_overflow_qs;
318:   logic fw_ov_rd_data_re;
319:   logic [31:0] fw_ov_rd_data_qs;
320:   logic fw_ov_wr_data_we;
321:   logic [31:0] fw_ov_wr_data_wd;
322:   logic observe_fifo_thresh_we;
323:   logic [5:0] observe_fifo_thresh_qs;
324:   logic [5:0] observe_fifo_thresh_wd;
325:   logic observe_fifo_depth_re;
326:   logic [5:0] observe_fifo_depth_qs;
327:   logic debug_status_re;
328:   logic [1:0] debug_status_entropy_fifo_depth_qs;
329:   logic [2:0] debug_status_sha3_fsm_qs;
330:   logic debug_status_sha3_block_pr_qs;
331:   logic debug_status_sha3_squeezing_qs;
332:   logic debug_status_sha3_absorbed_qs;
333:   logic debug_status_sha3_err_qs;
334:   logic debug_status_main_sm_idle_qs;
335:   logic debug_status_main_sm_boot_done_qs;
336:   logic recov_alert_sts_we;
337:   logic recov_alert_sts_fips_enable_field_alert_qs;
338:   logic recov_alert_sts_fips_enable_field_alert_wd;
339:   logic recov_alert_sts_entropy_data_reg_en_field_alert_qs;
340:   logic recov_alert_sts_entropy_data_reg_en_field_alert_wd;
341:   logic recov_alert_sts_module_enable_field_alert_qs;
342:   logic recov_alert_sts_module_enable_field_alert_wd;
343:   logic recov_alert_sts_threshold_scope_field_alert_qs;
344:   logic recov_alert_sts_threshold_scope_field_alert_wd;
345:   logic recov_alert_sts_rng_bit_enable_field_alert_qs;
346:   logic recov_alert_sts_rng_bit_enable_field_alert_wd;
347:   logic recov_alert_sts_fw_ov_sha3_start_field_alert_qs;
348:   logic recov_alert_sts_fw_ov_sha3_start_field_alert_wd;
349:   logic recov_alert_sts_fw_ov_mode_field_alert_qs;
350:   logic recov_alert_sts_fw_ov_mode_field_alert_wd;
351:   logic recov_alert_sts_fw_ov_entropy_insert_field_alert_qs;
352:   logic recov_alert_sts_fw_ov_entropy_insert_field_alert_wd;
353:   logic recov_alert_sts_es_route_field_alert_qs;
354:   logic recov_alert_sts_es_route_field_alert_wd;
355:   logic recov_alert_sts_es_type_field_alert_qs;
356:   logic recov_alert_sts_es_type_field_alert_wd;
357:   logic recov_alert_sts_es_main_sm_alert_qs;
358:   logic recov_alert_sts_es_main_sm_alert_wd;
359:   logic recov_alert_sts_es_bus_cmp_alert_qs;
360:   logic recov_alert_sts_es_bus_cmp_alert_wd;
361:   logic recov_alert_sts_es_thresh_cfg_alert_qs;
362:   logic recov_alert_sts_es_thresh_cfg_alert_wd;
363:   logic recov_alert_sts_es_fw_ov_wr_alert_qs;
364:   logic recov_alert_sts_es_fw_ov_wr_alert_wd;
365:   logic recov_alert_sts_es_fw_ov_disable_alert_qs;
366:   logic recov_alert_sts_es_fw_ov_disable_alert_wd;
367:   logic recov_alert_sts_fips_flag_field_alert_qs;
368:   logic recov_alert_sts_fips_flag_field_alert_wd;
369:   logic recov_alert_sts_rng_fips_field_alert_qs;
370:   logic recov_alert_sts_rng_fips_field_alert_wd;
371:   logic recov_alert_sts_postht_entropy_drop_alert_qs;
372:   logic recov_alert_sts_postht_entropy_drop_alert_wd;
373:   logic err_code_sfifo_esrng_err_qs;
374:   logic err_code_sfifo_distr_err_qs;
375:   logic err_code_sfifo_observe_err_qs;
376:   logic err_code_sfifo_esfinal_err_qs;
377:   logic err_code_es_ack_sm_err_qs;
378:   logic err_code_es_main_sm_err_qs;
379:   logic err_code_es_cntr_err_qs;
380:   logic err_code_sha3_state_err_qs;
381:   logic err_code_sha3_rst_storage_err_qs;
382:   logic err_code_fifo_write_err_qs;
383:   logic err_code_fifo_read_err_qs;
384:   logic err_code_fifo_state_err_qs;
385:   logic err_code_test_we;
386:   logic [4:0] err_code_test_qs;
387:   logic [4:0] err_code_test_wd;
388:   logic [8:0] main_sm_state_qs;
389: 
390:   // Register instances
391:   // R[intr_state]: V(False)
392:   //   F[es_entropy_valid]: 0:0
393:   prim_subreg #(
394:     .DW      (1),
395:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
396:     .RESVAL  (1'h0),
397:     .Mubi    (1'b0)
398:   ) u_intr_state_es_entropy_valid (
399:     .clk_i   (clk_i),
400:     .rst_ni  (rst_ni),
401: 
402:     // from register interface
403:     .we     (intr_state_we),
404:     .wd     (intr_state_es_entropy_valid_wd),
405: 
406:     // from internal hardware
407:     .de     (hw2reg.intr_state.es_entropy_valid.de),
408:     .d      (hw2reg.intr_state.es_entropy_valid.d),
409: 
410:     // to internal hardware
411:     .qe     (),
412:     .q      (reg2hw.intr_state.es_entropy_valid.q),
413:     .ds     (),
414: 
415:     // to register interface (read)
416:     .qs     (intr_state_es_entropy_valid_qs)
417:   );
418: 
419:   //   F[es_health_test_failed]: 1:1
420:   prim_subreg #(
421:     .DW      (1),
422:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
423:     .RESVAL  (1'h0),
424:     .Mubi    (1'b0)
425:   ) u_intr_state_es_health_test_failed (
426:     .clk_i   (clk_i),
427:     .rst_ni  (rst_ni),
428: 
429:     // from register interface
430:     .we     (intr_state_we),
431:     .wd     (intr_state_es_health_test_failed_wd),
432: 
433:     // from internal hardware
434:     .de     (hw2reg.intr_state.es_health_test_failed.de),
435:     .d      (hw2reg.intr_state.es_health_test_failed.d),
436: 
437:     // to internal hardware
438:     .qe     (),
439:     .q      (reg2hw.intr_state.es_health_test_failed.q),
440:     .ds     (),
441: 
442:     // to register interface (read)
443:     .qs     (intr_state_es_health_test_failed_qs)
444:   );
445: 
446:   //   F[es_observe_fifo_ready]: 2:2
447:   prim_subreg #(
448:     .DW      (1),
449:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
450:     .RESVAL  (1'h0),
451:     .Mubi    (1'b0)
452:   ) u_intr_state_es_observe_fifo_ready (
453:     .clk_i   (clk_i),
454:     .rst_ni  (rst_ni),
455: 
456:     // from register interface
457:     .we     (intr_state_we),
458:     .wd     (intr_state_es_observe_fifo_ready_wd),
459: 
460:     // from internal hardware
461:     .de     (hw2reg.intr_state.es_observe_fifo_ready.de),
462:     .d      (hw2reg.intr_state.es_observe_fifo_ready.d),
463: 
464:     // to internal hardware
465:     .qe     (),
466:     .q      (reg2hw.intr_state.es_observe_fifo_ready.q),
467:     .ds     (),
468: 
469:     // to register interface (read)
470:     .qs     (intr_state_es_observe_fifo_ready_qs)
471:   );
472: 
473:   //   F[es_fatal_err]: 3:3
474:   prim_subreg #(
475:     .DW      (1),
476:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
477:     .RESVAL  (1'h0),
478:     .Mubi    (1'b0)
479:   ) u_intr_state_es_fatal_err (
480:     .clk_i   (clk_i),
481:     .rst_ni  (rst_ni),
482: 
483:     // from register interface
484:     .we     (intr_state_we),
485:     .wd     (intr_state_es_fatal_err_wd),
486: 
487:     // from internal hardware
488:     .de     (hw2reg.intr_state.es_fatal_err.de),
489:     .d      (hw2reg.intr_state.es_fatal_err.d),
490: 
491:     // to internal hardware
492:     .qe     (),
493:     .q      (reg2hw.intr_state.es_fatal_err.q),
494:     .ds     (),
495: 
496:     // to register interface (read)
497:     .qs     (intr_state_es_fatal_err_qs)
498:   );
499: 
500: 
501:   // R[intr_enable]: V(False)
502:   //   F[es_entropy_valid]: 0:0
503:   prim_subreg #(
504:     .DW      (1),
505:     .SwAccess(prim_subreg_pkg::SwAccessRW),
506:     .RESVAL  (1'h0),
507:     .Mubi    (1'b0)
508:   ) u_intr_enable_es_entropy_valid (
509:     .clk_i   (clk_i),
510:     .rst_ni  (rst_ni),
511: 
512:     // from register interface
513:     .we     (intr_enable_we),
514:     .wd     (intr_enable_es_entropy_valid_wd),
515: 
516:     // from internal hardware
517:     .de     (1'b0),
518:     .d      ('0),
519: 
520:     // to internal hardware
521:     .qe     (),
522:     .q      (reg2hw.intr_enable.es_entropy_valid.q),
523:     .ds     (),
524: 
525:     // to register interface (read)
526:     .qs     (intr_enable_es_entropy_valid_qs)
527:   );
528: 
529:   //   F[es_health_test_failed]: 1:1
530:   prim_subreg #(
531:     .DW      (1),
532:     .SwAccess(prim_subreg_pkg::SwAccessRW),
533:     .RESVAL  (1'h0),
534:     .Mubi    (1'b0)
535:   ) u_intr_enable_es_health_test_failed (
536:     .clk_i   (clk_i),
537:     .rst_ni  (rst_ni),
538: 
539:     // from register interface
540:     .we     (intr_enable_we),
541:     .wd     (intr_enable_es_health_test_failed_wd),
542: 
543:     // from internal hardware
544:     .de     (1'b0),
545:     .d      ('0),
546: 
547:     // to internal hardware
548:     .qe     (),
549:     .q      (reg2hw.intr_enable.es_health_test_failed.q),
550:     .ds     (),
551: 
552:     // to register interface (read)
553:     .qs     (intr_enable_es_health_test_failed_qs)
554:   );
555: 
556:   //   F[es_observe_fifo_ready]: 2:2
557:   prim_subreg #(
558:     .DW      (1),
559:     .SwAccess(prim_subreg_pkg::SwAccessRW),
560:     .RESVAL  (1'h0),
561:     .Mubi    (1'b0)
562:   ) u_intr_enable_es_observe_fifo_ready (
563:     .clk_i   (clk_i),
564:     .rst_ni  (rst_ni),
565: 
566:     // from register interface
567:     .we     (intr_enable_we),
568:     .wd     (intr_enable_es_observe_fifo_ready_wd),
569: 
570:     // from internal hardware
571:     .de     (1'b0),
572:     .d      ('0),
573: 
574:     // to internal hardware
575:     .qe     (),
576:     .q      (reg2hw.intr_enable.es_observe_fifo_ready.q),
577:     .ds     (),
578: 
579:     // to register interface (read)
580:     .qs     (intr_enable_es_observe_fifo_ready_qs)
581:   );
582: 
583:   //   F[es_fatal_err]: 3:3
584:   prim_subreg #(
585:     .DW      (1),
586:     .SwAccess(prim_subreg_pkg::SwAccessRW),
587:     .RESVAL  (1'h0),
588:     .Mubi    (1'b0)
589:   ) u_intr_enable_es_fatal_err (
590:     .clk_i   (clk_i),
591:     .rst_ni  (rst_ni),
592: 
593:     // from register interface
594:     .we     (intr_enable_we),
595:     .wd     (intr_enable_es_fatal_err_wd),
596: 
597:     // from internal hardware
598:     .de     (1'b0),
599:     .d      ('0),
600: 
601:     // to internal hardware
602:     .qe     (),
603:     .q      (reg2hw.intr_enable.es_fatal_err.q),
604:     .ds     (),
605: 
606:     // to register interface (read)
607:     .qs     (intr_enable_es_fatal_err_qs)
608:   );
609: 
610: 
611:   // R[intr_test]: V(True)
612:   logic intr_test_qe;
613:   logic [3:0] intr_test_flds_we;
614:   assign intr_test_qe = &intr_test_flds_we;
615:   //   F[es_entropy_valid]: 0:0
616:   prim_subreg_ext #(
617:     .DW    (1)
618:   ) u_intr_test_es_entropy_valid (
619:     .re     (1'b0),
620:     .we     (intr_test_we),
621:     .wd     (intr_test_es_entropy_valid_wd),
622:     .d      ('0),
623:     .qre    (),
624:     .qe     (intr_test_flds_we[0]),
625:     .q      (reg2hw.intr_test.es_entropy_valid.q),
626:     .ds     (),
627:     .qs     ()
628:   );
629:   assign reg2hw.intr_test.es_entropy_valid.qe = intr_test_qe;
630: 
631:   //   F[es_health_test_failed]: 1:1
632:   prim_subreg_ext #(
633:     .DW    (1)
634:   ) u_intr_test_es_health_test_failed (
635:     .re     (1'b0),
636:     .we     (intr_test_we),
637:     .wd     (intr_test_es_health_test_failed_wd),
638:     .d      ('0),
639:     .qre    (),
640:     .qe     (intr_test_flds_we[1]),
641:     .q      (reg2hw.intr_test.es_health_test_failed.q),
642:     .ds     (),
643:     .qs     ()
644:   );
645:   assign reg2hw.intr_test.es_health_test_failed.qe = intr_test_qe;
646: 
647:   //   F[es_observe_fifo_ready]: 2:2
648:   prim_subreg_ext #(
649:     .DW    (1)
650:   ) u_intr_test_es_observe_fifo_ready (
651:     .re     (1'b0),
652:     .we     (intr_test_we),
653:     .wd     (intr_test_es_observe_fifo_ready_wd),
654:     .d      ('0),
655:     .qre    (),
656:     .qe     (intr_test_flds_we[2]),
657:     .q      (reg2hw.intr_test.es_observe_fifo_ready.q),
658:     .ds     (),
659:     .qs     ()
660:   );
661:   assign reg2hw.intr_test.es_observe_fifo_ready.qe = intr_test_qe;
662: 
663:   //   F[es_fatal_err]: 3:3
664:   prim_subreg_ext #(
665:     .DW    (1)
666:   ) u_intr_test_es_fatal_err (
667:     .re     (1'b0),
668:     .we     (intr_test_we),
669:     .wd     (intr_test_es_fatal_err_wd),
670:     .d      ('0),
671:     .qre    (),
672:     .qe     (intr_test_flds_we[3]),
673:     .q      (reg2hw.intr_test.es_fatal_err.q),
674:     .ds     (),
675:     .qs     ()
676:   );
677:   assign reg2hw.intr_test.es_fatal_err.qe = intr_test_qe;
678: 
679: 
680:   // R[alert_test]: V(True)
681:   logic alert_test_qe;
682:   logic [1:0] alert_test_flds_we;
683:   assign alert_test_qe = &alert_test_flds_we;
684:   //   F[recov_alert]: 0:0
685:   prim_subreg_ext #(
686:     .DW    (1)
687:   ) u_alert_test_recov_alert (
688:     .re     (1'b0),
689:     .we     (alert_test_we),
690:     .wd     (alert_test_recov_alert_wd),
691:     .d      ('0),
692:     .qre    (),
693:     .qe     (alert_test_flds_we[0]),
694:     .q      (reg2hw.alert_test.recov_alert.q),
695:     .ds     (),
696:     .qs     ()
697:   );
698:   assign reg2hw.alert_test.recov_alert.qe = alert_test_qe;
699: 
700:   //   F[fatal_alert]: 1:1
701:   prim_subreg_ext #(
702:     .DW    (1)
703:   ) u_alert_test_fatal_alert (
704:     .re     (1'b0),
705:     .we     (alert_test_we),
706:     .wd     (alert_test_fatal_alert_wd),
707:     .d      ('0),
708:     .qre    (),
709:     .qe     (alert_test_flds_we[1]),
710:     .q      (reg2hw.alert_test.fatal_alert.q),
711:     .ds     (),
712:     .qs     ()
713:   );
714:   assign reg2hw.alert_test.fatal_alert.qe = alert_test_qe;
715: 
716: 
717:   // R[me_regwen]: V(False)
718:   prim_subreg #(
719:     .DW      (1),
720:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
721:     .RESVAL  (1'h1),
722:     .Mubi    (1'b0)
723:   ) u_me_regwen (
724:     .clk_i   (clk_i),
725:     .rst_ni  (rst_ni),
726: 
727:     // from register interface
728:     .we     (me_regwen_we),
729:     .wd     (me_regwen_wd),
730: 
731:     // from internal hardware
732:     .de     (1'b0),
733:     .d      ('0),
734: 
735:     // to internal hardware
736:     .qe     (),
737:     .q      (),
738:     .ds     (),
739: 
740:     // to register interface (read)
741:     .qs     (me_regwen_qs)
742:   );
743: 
744: 
745:   // R[sw_regupd]: V(False)
746:   prim_subreg #(
747:     .DW      (1),
748:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
749:     .RESVAL  (1'h1),
750:     .Mubi    (1'b0)
751:   ) u_sw_regupd (
752:     .clk_i   (clk_i),
753:     .rst_ni  (rst_ni),
754: 
755:     // from register interface
756:     .we     (sw_regupd_we),
757:     .wd     (sw_regupd_wd),
758: 
759:     // from internal hardware
760:     .de     (1'b0),
761:     .d      ('0),
762: 
763:     // to internal hardware
764:     .qe     (),
765:     .q      (reg2hw.sw_regupd.q),
766:     .ds     (),
767: 
768:     // to register interface (read)
769:     .qs     (sw_regupd_qs)
770:   );
771: 
772: 
773:   // R[regwen]: V(False)
774:   prim_subreg #(
775:     .DW      (1),
776:     .SwAccess(prim_subreg_pkg::SwAccessRO),
777:     .RESVAL  (1'h1),
778:     .Mubi    (1'b0)
779:   ) u_regwen (
780:     .clk_i   (clk_i),
781:     .rst_ni  (rst_ni),
782: 
783:     // from register interface
784:     .we     (1'b0),
785:     .wd     ('0),
786: 
787:     // from internal hardware
788:     .de     (hw2reg.regwen.de),
789:     .d      (hw2reg.regwen.d),
790: 
791:     // to internal hardware
792:     .qe     (),
793:     .q      (),
794:     .ds     (),
795: 
796:     // to register interface (read)
797:     .qs     (regwen_qs)
798:   );
799: 
800: 
801:   // R[rev]: V(False)
802:   //   F[abi_revision]: 7:0
803:   // constant-only read
804:   assign rev_abi_revision_qs = 8'h3;
805: 
806:   //   F[hw_revision]: 15:8
807:   // constant-only read
808:   assign rev_hw_revision_qs = 8'h3;
809: 
810:   //   F[chip_type]: 23:16
811:   // constant-only read
812:   assign rev_chip_type_qs = 8'h1;
813: 
814: 
815:   // R[module_enable]: V(False)
816:   // Create REGWEN-gated WE signal
817:   logic module_enable_gated_we;
818:   assign module_enable_gated_we = module_enable_we & me_regwen_qs;
819:   prim_subreg #(
820:     .DW      (4),
821:     .SwAccess(prim_subreg_pkg::SwAccessRW),
822:     .RESVAL  (4'h9),
823:     .Mubi    (1'b1)
824:   ) u_module_enable (
825:     .clk_i   (clk_i),
826:     .rst_ni  (rst_ni),
827: 
828:     // from register interface
829:     .we     (module_enable_gated_we),
830:     .wd     (module_enable_wd),
831: 
832:     // from internal hardware
833:     .de     (1'b0),
834:     .d      ('0),
835: 
836:     // to internal hardware
837:     .qe     (),
838:     .q      (reg2hw.module_enable.q),
839:     .ds     (),
840: 
841:     // to register interface (read)
842:     .qs     (module_enable_qs)
843:   );
844: 
845: 
846:   // R[conf]: V(False)
847:   // Create REGWEN-gated WE signal
848:   logic conf_gated_we;
849:   assign conf_gated_we = conf_we & regwen_qs;
850:   //   F[fips_enable]: 3:0
851:   prim_subreg #(
852:     .DW      (4),
853:     .SwAccess(prim_subreg_pkg::SwAccessRW),
854:     .RESVAL  (4'h9),
855:     .Mubi    (1'b1)
856:   ) u_conf_fips_enable (
857:     .clk_i   (clk_i),
858:     .rst_ni  (rst_ni),
859: 
860:     // from register interface
861:     .we     (conf_gated_we),
862:     .wd     (conf_fips_enable_wd),
863: 
864:     // from internal hardware
865:     .de     (1'b0),
866:     .d      ('0),
867: 
868:     // to internal hardware
869:     .qe     (),
870:     .q      (reg2hw.conf.fips_enable.q),
871:     .ds     (),
872: 
873:     // to register interface (read)
874:     .qs     (conf_fips_enable_qs)
875:   );
876: 
877:   //   F[fips_flag]: 7:4
878:   prim_subreg #(
879:     .DW      (4),
880:     .SwAccess(prim_subreg_pkg::SwAccessRW),
881:     .RESVAL  (4'h9),
882:     .Mubi    (1'b1)
883:   ) u_conf_fips_flag (
884:     .clk_i   (clk_i),
885:     .rst_ni  (rst_ni),
886: 
887:     // from register interface
888:     .we     (conf_gated_we),
889:     .wd     (conf_fips_flag_wd),
890: 
891:     // from internal hardware
892:     .de     (1'b0),
893:     .d      ('0),
894: 
895:     // to internal hardware
896:     .qe     (),
897:     .q      (reg2hw.conf.fips_flag.q),
898:     .ds     (),
899: 
900:     // to register interface (read)
901:     .qs     (conf_fips_flag_qs)
902:   );
903: 
904:   //   F[rng_fips]: 11:8
905:   prim_subreg #(
906:     .DW      (4),
907:     .SwAccess(prim_subreg_pkg::SwAccessRW),
908:     .RESVAL  (4'h9),
909:     .Mubi    (1'b1)
910:   ) u_conf_rng_fips (
911:     .clk_i   (clk_i),
912:     .rst_ni  (rst_ni),
913: 
914:     // from register interface
915:     .we     (conf_gated_we),
916:     .wd     (conf_rng_fips_wd),
917: 
918:     // from internal hardware
919:     .de     (1'b0),
920:     .d      ('0),
921: 
922:     // to internal hardware
923:     .qe     (),
924:     .q      (reg2hw.conf.rng_fips.q),
925:     .ds     (),
926: 
927:     // to register interface (read)
928:     .qs     (conf_rng_fips_qs)
929:   );
930: 
931:   //   F[rng_bit_enable]: 15:12
932:   prim_subreg #(
933:     .DW      (4),
934:     .SwAccess(prim_subreg_pkg::SwAccessRW),
935:     .RESVAL  (4'h9),
936:     .Mubi    (1'b1)
937:   ) u_conf_rng_bit_enable (
938:     .clk_i   (clk_i),
939:     .rst_ni  (rst_ni),
940: 
941:     // from register interface
942:     .we     (conf_gated_we),
943:     .wd     (conf_rng_bit_enable_wd),
944: 
945:     // from internal hardware
946:     .de     (1'b0),
947:     .d      ('0),
948: 
949:     // to internal hardware
950:     .qe     (),
951:     .q      (reg2hw.conf.rng_bit_enable.q),
952:     .ds     (),
953: 
954:     // to register interface (read)
955:     .qs     (conf_rng_bit_enable_qs)
956:   );
957: 
958:   //   F[rng_bit_sel]: 17:16
959:   prim_subreg #(
960:     .DW      (2),
961:     .SwAccess(prim_subreg_pkg::SwAccessRW),
962:     .RESVAL  (2'h0),
963:     .Mubi    (1'b0)
964:   ) u_conf_rng_bit_sel (
965:     .clk_i   (clk_i),
966:     .rst_ni  (rst_ni),
967: 
968:     // from register interface
969:     .we     (conf_gated_we),
970:     .wd     (conf_rng_bit_sel_wd),
971: 
972:     // from internal hardware
973:     .de     (1'b0),
974:     .d      ('0),
975: 
976:     // to internal hardware
977:     .qe     (),
978:     .q      (reg2hw.conf.rng_bit_sel.q),
979:     .ds     (),
980: 
981:     // to register interface (read)
982:     .qs     (conf_rng_bit_sel_qs)
983:   );
984: 
985:   //   F[threshold_scope]: 21:18
986:   prim_subreg #(
987:     .DW      (4),
988:     .SwAccess(prim_subreg_pkg::SwAccessRW),
989:     .RESVAL  (4'h9),
990:     .Mubi    (1'b1)
991:   ) u_conf_threshold_scope (
992:     .clk_i   (clk_i),
993:     .rst_ni  (rst_ni),
994: 
995:     // from register interface
996:     .we     (conf_gated_we),
997:     .wd     (conf_threshold_scope_wd),
998: 
999:     // from internal hardware
1000:     .de     (1'b0),
1001:     .d      ('0),
1002: 
1003:     // to internal hardware
1004:     .qe     (),
1005:     .q      (reg2hw.conf.threshold_scope.q),
1006:     .ds     (),
1007: 
1008:     // to register interface (read)
1009:     .qs     (conf_threshold_scope_qs)
1010:   );
1011: 
1012:   //   F[entropy_data_reg_enable]: 25:22
1013:   prim_subreg #(
1014:     .DW      (4),
1015:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1016:     .RESVAL  (4'h9),
1017:     .Mubi    (1'b1)
1018:   ) u_conf_entropy_data_reg_enable (
1019:     .clk_i   (clk_i),
1020:     .rst_ni  (rst_ni),
1021: 
1022:     // from register interface
1023:     .we     (conf_gated_we),
1024:     .wd     (conf_entropy_data_reg_enable_wd),
1025: 
1026:     // from internal hardware
1027:     .de     (1'b0),
1028:     .d      ('0),
1029: 
1030:     // to internal hardware
1031:     .qe     (),
1032:     .q      (reg2hw.conf.entropy_data_reg_enable.q),
1033:     .ds     (),
1034: 
1035:     // to register interface (read)
1036:     .qs     (conf_entropy_data_reg_enable_qs)
1037:   );
1038: 
1039: 
1040:   // R[entropy_control]: V(False)
1041:   // Create REGWEN-gated WE signal
1042:   logic entropy_control_gated_we;
1043:   assign entropy_control_gated_we = entropy_control_we & regwen_qs;
1044:   //   F[es_route]: 3:0
1045:   prim_subreg #(
1046:     .DW      (4),
1047:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1048:     .RESVAL  (4'h9),
1049:     .Mubi    (1'b1)
1050:   ) u_entropy_control_es_route (
1051:     .clk_i   (clk_i),
1052:     .rst_ni  (rst_ni),
1053: 
1054:     // from register interface
1055:     .we     (entropy_control_gated_we),
1056:     .wd     (entropy_control_es_route_wd),
1057: 
1058:     // from internal hardware
1059:     .de     (1'b0),
1060:     .d      ('0),
1061: 
1062:     // to internal hardware
1063:     .qe     (),
1064:     .q      (reg2hw.entropy_control.es_route.q),
1065:     .ds     (),
1066: 
1067:     // to register interface (read)
1068:     .qs     (entropy_control_es_route_qs)
1069:   );
1070: 
1071:   //   F[es_type]: 7:4
1072:   prim_subreg #(
1073:     .DW      (4),
1074:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1075:     .RESVAL  (4'h9),
1076:     .Mubi    (1'b1)
1077:   ) u_entropy_control_es_type (
1078:     .clk_i   (clk_i),
1079:     .rst_ni  (rst_ni),
1080: 
1081:     // from register interface
1082:     .we     (entropy_control_gated_we),
1083:     .wd     (entropy_control_es_type_wd),
1084: 
1085:     // from internal hardware
1086:     .de     (1'b0),
1087:     .d      ('0),
1088: 
1089:     // to internal hardware
1090:     .qe     (),
1091:     .q      (reg2hw.entropy_control.es_type.q),
1092:     .ds     (),
1093: 
1094:     // to register interface (read)
1095:     .qs     (entropy_control_es_type_qs)
1096:   );
1097: 
1098: 
1099:   // R[entropy_data]: V(True)
1100:   prim_subreg_ext #(
1101:     .DW    (32)
1102:   ) u_entropy_data (
1103:     .re     (entropy_data_re),
1104:     .we     (1'b0),
1105:     .wd     ('0),
1106:     .d      (hw2reg.entropy_data.d),
1107:     .qre    (reg2hw.entropy_data.re),
1108:     .qe     (),
1109:     .q      (reg2hw.entropy_data.q),
1110:     .ds     (),
1111:     .qs     (entropy_data_qs)
1112:   );
1113: 
1114: 
1115:   // R[health_test_windows]: V(False)
1116:   // Create REGWEN-gated WE signal
1117:   logic health_test_windows_gated_we;
1118:   assign health_test_windows_gated_we = health_test_windows_we & regwen_qs;
1119:   //   F[fips_window]: 15:0
1120:   prim_subreg #(
1121:     .DW      (16),
1122:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1123:     .RESVAL  (16'h200),
1124:     .Mubi    (1'b0)
1125:   ) u_health_test_windows_fips_window (
1126:     .clk_i   (clk_i),
1127:     .rst_ni  (rst_ni),
1128: 
1129:     // from register interface
1130:     .we     (health_test_windows_gated_we),
1131:     .wd     (health_test_windows_fips_window_wd),
1132: 
1133:     // from internal hardware
1134:     .de     (1'b0),
1135:     .d      ('0),
1136: 
1137:     // to internal hardware
1138:     .qe     (),
1139:     .q      (reg2hw.health_test_windows.fips_window.q),
1140:     .ds     (),
1141: 
1142:     // to register interface (read)
1143:     .qs     (health_test_windows_fips_window_qs)
1144:   );
1145: 
1146:   //   F[bypass_window]: 31:16
1147:   prim_subreg #(
1148:     .DW      (16),
1149:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1150:     .RESVAL  (16'h60),
1151:     .Mubi    (1'b0)
1152:   ) u_health_test_windows_bypass_window (
1153:     .clk_i   (clk_i),
1154:     .rst_ni  (rst_ni),
1155: 
1156:     // from register interface
1157:     .we     (health_test_windows_gated_we),
1158:     .wd     (health_test_windows_bypass_window_wd),
1159: 
1160:     // from internal hardware
1161:     .de     (1'b0),
1162:     .d      ('0),
1163: 
1164:     // to internal hardware
1165:     .qe     (),
1166:     .q      (reg2hw.health_test_windows.bypass_window.q),
1167:     .ds     (),
1168: 
1169:     // to register interface (read)
1170:     .qs     (health_test_windows_bypass_window_qs)
1171:   );
1172: 
1173: 
1174:   // R[repcnt_thresholds]: V(True)
1175:   logic repcnt_thresholds_qe;
1176:   logic [1:0] repcnt_thresholds_flds_we;
1177:   assign repcnt_thresholds_qe = &repcnt_thresholds_flds_we;
1178:   // Create REGWEN-gated WE signal
1179:   logic repcnt_thresholds_gated_we;
1180:   assign repcnt_thresholds_gated_we = repcnt_thresholds_we & regwen_qs;
1181:   //   F[fips_thresh]: 15:0
1182:   prim_subreg_ext #(
1183:     .DW    (16)
1184:   ) u_repcnt_thresholds_fips_thresh (
1185:     .re     (repcnt_thresholds_re),
1186:     .we     (repcnt_thresholds_gated_we),
1187:     .wd     (repcnt_thresholds_fips_thresh_wd),
1188:     .d      (hw2reg.repcnt_thresholds.fips_thresh.d),
1189:     .qre    (),
1190:     .qe     (repcnt_thresholds_flds_we[0]),
1191:     .q      (reg2hw.repcnt_thresholds.fips_thresh.q),
1192:     .ds     (),
1193:     .qs     (repcnt_thresholds_fips_thresh_qs)
1194:   );
1195:   assign reg2hw.repcnt_thresholds.fips_thresh.qe = repcnt_thresholds_qe;
1196: 
1197:   //   F[bypass_thresh]: 31:16
1198:   prim_subreg_ext #(
1199:     .DW    (16)
1200:   ) u_repcnt_thresholds_bypass_thresh (
1201:     .re     (repcnt_thresholds_re),
1202:     .we     (repcnt_thresholds_gated_we),
1203:     .wd     (repcnt_thresholds_bypass_thresh_wd),
1204:     .d      (hw2reg.repcnt_thresholds.bypass_thresh.d),
1205:     .qre    (),
1206:     .qe     (repcnt_thresholds_flds_we[1]),
1207:     .q      (reg2hw.repcnt_thresholds.bypass_thresh.q),
1208:     .ds     (),
1209:     .qs     (repcnt_thresholds_bypass_thresh_qs)
1210:   );
1211:   assign reg2hw.repcnt_thresholds.bypass_thresh.qe = repcnt_thresholds_qe;
1212: 
1213: 
1214:   // R[repcnts_thresholds]: V(True)
1215:   logic repcnts_thresholds_qe;
1216:   logic [1:0] repcnts_thresholds_flds_we;
1217:   assign repcnts_thresholds_qe = &repcnts_thresholds_flds_we;
1218:   // Create REGWEN-gated WE signal
1219:   logic repcnts_thresholds_gated_we;
1220:   assign repcnts_thresholds_gated_we = repcnts_thresholds_we & regwen_qs;
1221:   //   F[fips_thresh]: 15:0
1222:   prim_subreg_ext #(
1223:     .DW    (16)
1224:   ) u_repcnts_thresholds_fips_thresh (
1225:     .re     (repcnts_thresholds_re),
1226:     .we     (repcnts_thresholds_gated_we),
1227:     .wd     (repcnts_thresholds_fips_thresh_wd),
1228:     .d      (hw2reg.repcnts_thresholds.fips_thresh.d),
1229:     .qre    (),
1230:     .qe     (repcnts_thresholds_flds_we[0]),
1231:     .q      (reg2hw.repcnts_thresholds.fips_thresh.q),
1232:     .ds     (),
1233:     .qs     (repcnts_thresholds_fips_thresh_qs)
1234:   );
1235:   assign reg2hw.repcnts_thresholds.fips_thresh.qe = repcnts_thresholds_qe;
1236: 
1237:   //   F[bypass_thresh]: 31:16
1238:   prim_subreg_ext #(
1239:     .DW    (16)
1240:   ) u_repcnts_thresholds_bypass_thresh (
1241:     .re     (repcnts_thresholds_re),
1242:     .we     (repcnts_thresholds_gated_we),
1243:     .wd     (repcnts_thresholds_bypass_thresh_wd),
1244:     .d      (hw2reg.repcnts_thresholds.bypass_thresh.d),
1245:     .qre    (),
1246:     .qe     (repcnts_thresholds_flds_we[1]),
1247:     .q      (reg2hw.repcnts_thresholds.bypass_thresh.q),
1248:     .ds     (),
1249:     .qs     (repcnts_thresholds_bypass_thresh_qs)
1250:   );
1251:   assign reg2hw.repcnts_thresholds.bypass_thresh.qe = repcnts_thresholds_qe;
1252: 
1253: 
1254:   // R[adaptp_hi_thresholds]: V(True)
1255:   logic adaptp_hi_thresholds_qe;
1256:   logic [1:0] adaptp_hi_thresholds_flds_we;
1257:   assign adaptp_hi_thresholds_qe = &adaptp_hi_thresholds_flds_we;
1258:   // Create REGWEN-gated WE signal
1259:   logic adaptp_hi_thresholds_gated_we;
1260:   assign adaptp_hi_thresholds_gated_we = adaptp_hi_thresholds_we & regwen_qs;
1261:   //   F[fips_thresh]: 15:0
1262:   prim_subreg_ext #(
1263:     .DW    (16)
1264:   ) u_adaptp_hi_thresholds_fips_thresh (
1265:     .re     (adaptp_hi_thresholds_re),
1266:     .we     (adaptp_hi_thresholds_gated_we),
1267:     .wd     (adaptp_hi_thresholds_fips_thresh_wd),
1268:     .d      (hw2reg.adaptp_hi_thresholds.fips_thresh.d),
1269:     .qre    (),
1270:     .qe     (adaptp_hi_thresholds_flds_we[0]),
1271:     .q      (reg2hw.adaptp_hi_thresholds.fips_thresh.q),
1272:     .ds     (),
1273:     .qs     (adaptp_hi_thresholds_fips_thresh_qs)
1274:   );
1275:   assign reg2hw.adaptp_hi_thresholds.fips_thresh.qe = adaptp_hi_thresholds_qe;
1276: 
1277:   //   F[bypass_thresh]: 31:16
1278:   prim_subreg_ext #(
1279:     .DW    (16)
1280:   ) u_adaptp_hi_thresholds_bypass_thresh (
1281:     .re     (adaptp_hi_thresholds_re),
1282:     .we     (adaptp_hi_thresholds_gated_we),
1283:     .wd     (adaptp_hi_thresholds_bypass_thresh_wd),
1284:     .d      (hw2reg.adaptp_hi_thresholds.bypass_thresh.d),
1285:     .qre    (),
1286:     .qe     (adaptp_hi_thresholds_flds_we[1]),
1287:     .q      (reg2hw.adaptp_hi_thresholds.bypass_thresh.q),
1288:     .ds     (),
1289:     .qs     (adaptp_hi_thresholds_bypass_thresh_qs)
1290:   );
1291:   assign reg2hw.adaptp_hi_thresholds.bypass_thresh.qe = adaptp_hi_thresholds_qe;
1292: 
1293: 
1294:   // R[adaptp_lo_thresholds]: V(True)
1295:   logic adaptp_lo_thresholds_qe;
1296:   logic [1:0] adaptp_lo_thresholds_flds_we;
1297:   assign adaptp_lo_thresholds_qe = &adaptp_lo_thresholds_flds_we;
1298:   // Create REGWEN-gated WE signal
1299:   logic adaptp_lo_thresholds_gated_we;
1300:   assign adaptp_lo_thresholds_gated_we = adaptp_lo_thresholds_we & regwen_qs;
1301:   //   F[fips_thresh]: 15:0
1302:   prim_subreg_ext #(
1303:     .DW    (16)
1304:   ) u_adaptp_lo_thresholds_fips_thresh (
1305:     .re     (adaptp_lo_thresholds_re),
1306:     .we     (adaptp_lo_thresholds_gated_we),
1307:     .wd     (adaptp_lo_thresholds_fips_thresh_wd),
1308:     .d      (hw2reg.adaptp_lo_thresholds.fips_thresh.d),
1309:     .qre    (),
1310:     .qe     (adaptp_lo_thresholds_flds_we[0]),
1311:     .q      (reg2hw.adaptp_lo_thresholds.fips_thresh.q),
1312:     .ds     (),
1313:     .qs     (adaptp_lo_thresholds_fips_thresh_qs)
1314:   );
1315:   assign reg2hw.adaptp_lo_thresholds.fips_thresh.qe = adaptp_lo_thresholds_qe;
1316: 
1317:   //   F[bypass_thresh]: 31:16
1318:   prim_subreg_ext #(
1319:     .DW    (16)
1320:   ) u_adaptp_lo_thresholds_bypass_thresh (
1321:     .re     (adaptp_lo_thresholds_re),
1322:     .we     (adaptp_lo_thresholds_gated_we),
1323:     .wd     (adaptp_lo_thresholds_bypass_thresh_wd),
1324:     .d      (hw2reg.adaptp_lo_thresholds.bypass_thresh.d),
1325:     .qre    (),
1326:     .qe     (adaptp_lo_thresholds_flds_we[1]),
1327:     .q      (reg2hw.adaptp_lo_thresholds.bypass_thresh.q),
1328:     .ds     (),
1329:     .qs     (adaptp_lo_thresholds_bypass_thresh_qs)
1330:   );
1331:   assign reg2hw.adaptp_lo_thresholds.bypass_thresh.qe = adaptp_lo_thresholds_qe;
1332: 
1333: 
1334:   // R[bucket_thresholds]: V(True)
1335:   logic bucket_thresholds_qe;
1336:   logic [1:0] bucket_thresholds_flds_we;
1337:   assign bucket_thresholds_qe = &bucket_thresholds_flds_we;
1338:   // Create REGWEN-gated WE signal
1339:   logic bucket_thresholds_gated_we;
1340:   assign bucket_thresholds_gated_we = bucket_thresholds_we & regwen_qs;
1341:   //   F[fips_thresh]: 15:0
1342:   prim_subreg_ext #(
1343:     .DW    (16)
1344:   ) u_bucket_thresholds_fips_thresh (
1345:     .re     (bucket_thresholds_re),
1346:     .we     (bucket_thresholds_gated_we),
1347:     .wd     (bucket_thresholds_fips_thresh_wd),
1348:     .d      (hw2reg.bucket_thresholds.fips_thresh.d),
1349:     .qre    (),
1350:     .qe     (bucket_thresholds_flds_we[0]),
1351:     .q      (reg2hw.bucket_thresholds.fips_thresh.q),
1352:     .ds     (),
1353:     .qs     (bucket_thresholds_fips_thresh_qs)
1354:   );
1355:   assign reg2hw.bucket_thresholds.fips_thresh.qe = bucket_thresholds_qe;
1356: 
1357:   //   F[bypass_thresh]: 31:16
1358:   prim_subreg_ext #(
1359:     .DW    (16)
1360:   ) u_bucket_thresholds_bypass_thresh (
1361:     .re     (bucket_thresholds_re),
1362:     .we     (bucket_thresholds_gated_we),
1363:     .wd     (bucket_thresholds_bypass_thresh_wd),
1364:     .d      (hw2reg.bucket_thresholds.bypass_thresh.d),
1365:     .qre    (),
1366:     .qe     (bucket_thresholds_flds_we[1]),
1367:     .q      (reg2hw.bucket_thresholds.bypass_thresh.q),
1368:     .ds     (),
1369:     .qs     (bucket_thresholds_bypass_thresh_qs)
1370:   );
1371:   assign reg2hw.bucket_thresholds.bypass_thresh.qe = bucket_thresholds_qe;
1372: 
1373: 
1374:   // R[markov_hi_thresholds]: V(True)
1375:   logic markov_hi_thresholds_qe;
1376:   logic [1:0] markov_hi_thresholds_flds_we;
1377:   assign markov_hi_thresholds_qe = &markov_hi_thresholds_flds_we;
1378:   // Create REGWEN-gated WE signal
1379:   logic markov_hi_thresholds_gated_we;
1380:   assign markov_hi_thresholds_gated_we = markov_hi_thresholds_we & regwen_qs;
1381:   //   F[fips_thresh]: 15:0
1382:   prim_subreg_ext #(
1383:     .DW    (16)
1384:   ) u_markov_hi_thresholds_fips_thresh (
1385:     .re     (markov_hi_thresholds_re),
1386:     .we     (markov_hi_thresholds_gated_we),
1387:     .wd     (markov_hi_thresholds_fips_thresh_wd),
1388:     .d      (hw2reg.markov_hi_thresholds.fips_thresh.d),
1389:     .qre    (),
1390:     .qe     (markov_hi_thresholds_flds_we[0]),
1391:     .q      (reg2hw.markov_hi_thresholds.fips_thresh.q),
1392:     .ds     (),
1393:     .qs     (markov_hi_thresholds_fips_thresh_qs)
1394:   );
1395:   assign reg2hw.markov_hi_thresholds.fips_thresh.qe = markov_hi_thresholds_qe;
1396: 
1397:   //   F[bypass_thresh]: 31:16
1398:   prim_subreg_ext #(
1399:     .DW    (16)
1400:   ) u_markov_hi_thresholds_bypass_thresh (
1401:     .re     (markov_hi_thresholds_re),
1402:     .we     (markov_hi_thresholds_gated_we),
1403:     .wd     (markov_hi_thresholds_bypass_thresh_wd),
1404:     .d      (hw2reg.markov_hi_thresholds.bypass_thresh.d),
1405:     .qre    (),
1406:     .qe     (markov_hi_thresholds_flds_we[1]),
1407:     .q      (reg2hw.markov_hi_thresholds.bypass_thresh.q),
1408:     .ds     (),
1409:     .qs     (markov_hi_thresholds_bypass_thresh_qs)
1410:   );
1411:   assign reg2hw.markov_hi_thresholds.bypass_thresh.qe = markov_hi_thresholds_qe;
1412: 
1413: 
1414:   // R[markov_lo_thresholds]: V(True)
1415:   logic markov_lo_thresholds_qe;
1416:   logic [1:0] markov_lo_thresholds_flds_we;
1417:   assign markov_lo_thresholds_qe = &markov_lo_thresholds_flds_we;
1418:   // Create REGWEN-gated WE signal
1419:   logic markov_lo_thresholds_gated_we;
1420:   assign markov_lo_thresholds_gated_we = markov_lo_thresholds_we & regwen_qs;
1421:   //   F[fips_thresh]: 15:0
1422:   prim_subreg_ext #(
1423:     .DW    (16)
1424:   ) u_markov_lo_thresholds_fips_thresh (
1425:     .re     (markov_lo_thresholds_re),
1426:     .we     (markov_lo_thresholds_gated_we),
1427:     .wd     (markov_lo_thresholds_fips_thresh_wd),
1428:     .d      (hw2reg.markov_lo_thresholds.fips_thresh.d),
1429:     .qre    (),
1430:     .qe     (markov_lo_thresholds_flds_we[0]),
1431:     .q      (reg2hw.markov_lo_thresholds.fips_thresh.q),
1432:     .ds     (),
1433:     .qs     (markov_lo_thresholds_fips_thresh_qs)
1434:   );
1435:   assign reg2hw.markov_lo_thresholds.fips_thresh.qe = markov_lo_thresholds_qe;
1436: 
1437:   //   F[bypass_thresh]: 31:16
1438:   prim_subreg_ext #(
1439:     .DW    (16)
1440:   ) u_markov_lo_thresholds_bypass_thresh (
1441:     .re     (markov_lo_thresholds_re),
1442:     .we     (markov_lo_thresholds_gated_we),
1443:     .wd     (markov_lo_thresholds_bypass_thresh_wd),
1444:     .d      (hw2reg.markov_lo_thresholds.bypass_thresh.d),
1445:     .qre    (),
1446:     .qe     (markov_lo_thresholds_flds_we[1]),
1447:     .q      (reg2hw.markov_lo_thresholds.bypass_thresh.q),
1448:     .ds     (),
1449:     .qs     (markov_lo_thresholds_bypass_thresh_qs)
1450:   );
1451:   assign reg2hw.markov_lo_thresholds.bypass_thresh.qe = markov_lo_thresholds_qe;
1452: 
1453: 
1454:   // R[extht_hi_thresholds]: V(True)
1455:   logic extht_hi_thresholds_qe;
1456:   logic [1:0] extht_hi_thresholds_flds_we;
1457:   assign extht_hi_thresholds_qe = &extht_hi_thresholds_flds_we;
1458:   // Create REGWEN-gated WE signal
1459:   logic extht_hi_thresholds_gated_we;
1460:   assign extht_hi_thresholds_gated_we = extht_hi_thresholds_we & regwen_qs;
1461:   //   F[fips_thresh]: 15:0
1462:   prim_subreg_ext #(
1463:     .DW    (16)
1464:   ) u_extht_hi_thresholds_fips_thresh (
1465:     .re     (extht_hi_thresholds_re),
1466:     .we     (extht_hi_thresholds_gated_we),
1467:     .wd     (extht_hi_thresholds_fips_thresh_wd),
1468:     .d      (hw2reg.extht_hi_thresholds.fips_thresh.d),
1469:     .qre    (),
1470:     .qe     (extht_hi_thresholds_flds_we[0]),
1471:     .q      (reg2hw.extht_hi_thresholds.fips_thresh.q),
1472:     .ds     (),
1473:     .qs     (extht_hi_thresholds_fips_thresh_qs)
1474:   );
1475:   assign reg2hw.extht_hi_thresholds.fips_thresh.qe = extht_hi_thresholds_qe;
1476: 
1477:   //   F[bypass_thresh]: 31:16
1478:   prim_subreg_ext #(
1479:     .DW    (16)
1480:   ) u_extht_hi_thresholds_bypass_thresh (
1481:     .re     (extht_hi_thresholds_re),
1482:     .we     (extht_hi_thresholds_gated_we),
1483:     .wd     (extht_hi_thresholds_bypass_thresh_wd),
1484:     .d      (hw2reg.extht_hi_thresholds.bypass_thresh.d),
1485:     .qre    (),
1486:     .qe     (extht_hi_thresholds_flds_we[1]),
1487:     .q      (reg2hw.extht_hi_thresholds.bypass_thresh.q),
1488:     .ds     (),
1489:     .qs     (extht_hi_thresholds_bypass_thresh_qs)
1490:   );
1491:   assign reg2hw.extht_hi_thresholds.bypass_thresh.qe = extht_hi_thresholds_qe;
1492: 
1493: 
1494:   // R[extht_lo_thresholds]: V(True)
1495:   logic extht_lo_thresholds_qe;
1496:   logic [1:0] extht_lo_thresholds_flds_we;
1497:   assign extht_lo_thresholds_qe = &extht_lo_thresholds_flds_we;
1498:   // Create REGWEN-gated WE signal
1499:   logic extht_lo_thresholds_gated_we;
1500:   assign extht_lo_thresholds_gated_we = extht_lo_thresholds_we & regwen_qs;
1501:   //   F[fips_thresh]: 15:0
1502:   prim_subreg_ext #(
1503:     .DW    (16)
1504:   ) u_extht_lo_thresholds_fips_thresh (
1505:     .re     (extht_lo_thresholds_re),
1506:     .we     (extht_lo_thresholds_gated_we),
1507:     .wd     (extht_lo_thresholds_fips_thresh_wd),
1508:     .d      (hw2reg.extht_lo_thresholds.fips_thresh.d),
1509:     .qre    (),
1510:     .qe     (extht_lo_thresholds_flds_we[0]),
1511:     .q      (reg2hw.extht_lo_thresholds.fips_thresh.q),
1512:     .ds     (),
1513:     .qs     (extht_lo_thresholds_fips_thresh_qs)
1514:   );
1515:   assign reg2hw.extht_lo_thresholds.fips_thresh.qe = extht_lo_thresholds_qe;
1516: 
1517:   //   F[bypass_thresh]: 31:16
1518:   prim_subreg_ext #(
1519:     .DW    (16)
1520:   ) u_extht_lo_thresholds_bypass_thresh (
1521:     .re     (extht_lo_thresholds_re),
1522:     .we     (extht_lo_thresholds_gated_we),
1523:     .wd     (extht_lo_thresholds_bypass_thresh_wd),
1524:     .d      (hw2reg.extht_lo_thresholds.bypass_thresh.d),
1525:     .qre    (),
1526:     .qe     (extht_lo_thresholds_flds_we[1]),
1527:     .q      (reg2hw.extht_lo_thresholds.bypass_thresh.q),
1528:     .ds     (),
1529:     .qs     (extht_lo_thresholds_bypass_thresh_qs)
1530:   );
1531:   assign reg2hw.extht_lo_thresholds.bypass_thresh.qe = extht_lo_thresholds_qe;
1532: 
1533: 
1534:   // R[repcnt_hi_watermarks]: V(True)
1535:   //   F[fips_watermark]: 15:0
1536:   prim_subreg_ext #(
1537:     .DW    (16)
1538:   ) u_repcnt_hi_watermarks_fips_watermark (
1539:     .re     (repcnt_hi_watermarks_re),
1540:     .we     (1'b0),
1541:     .wd     ('0),
1542:     .d      (hw2reg.repcnt_hi_watermarks.fips_watermark.d),
1543:     .qre    (),
1544:     .qe     (),
1545:     .q      (),
1546:     .ds     (),
1547:     .qs     (repcnt_hi_watermarks_fips_watermark_qs)
1548:   );
1549: 
1550:   //   F[bypass_watermark]: 31:16
1551:   prim_subreg_ext #(
1552:     .DW    (16)
1553:   ) u_repcnt_hi_watermarks_bypass_watermark (
1554:     .re     (repcnt_hi_watermarks_re),
1555:     .we     (1'b0),
1556:     .wd     ('0),
1557:     .d      (hw2reg.repcnt_hi_watermarks.bypass_watermark.d),
1558:     .qre    (),
1559:     .qe     (),
1560:     .q      (),
1561:     .ds     (),
1562:     .qs     (repcnt_hi_watermarks_bypass_watermark_qs)
1563:   );
1564: 
1565: 
1566:   // R[repcnts_hi_watermarks]: V(True)
1567:   //   F[fips_watermark]: 15:0
1568:   prim_subreg_ext #(
1569:     .DW    (16)
1570:   ) u_repcnts_hi_watermarks_fips_watermark (
1571:     .re     (repcnts_hi_watermarks_re),
1572:     .we     (1'b0),
1573:     .wd     ('0),
1574:     .d      (hw2reg.repcnts_hi_watermarks.fips_watermark.d),
1575:     .qre    (),
1576:     .qe     (),
1577:     .q      (),
1578:     .ds     (),
1579:     .qs     (repcnts_hi_watermarks_fips_watermark_qs)
1580:   );
1581: 
1582:   //   F[bypass_watermark]: 31:16
1583:   prim_subreg_ext #(
1584:     .DW    (16)
1585:   ) u_repcnts_hi_watermarks_bypass_watermark (
1586:     .re     (repcnts_hi_watermarks_re),
1587:     .we     (1'b0),
1588:     .wd     ('0),
1589:     .d      (hw2reg.repcnts_hi_watermarks.bypass_watermark.d),
1590:     .qre    (),
1591:     .qe     (),
1592:     .q      (),
1593:     .ds     (),
1594:     .qs     (repcnts_hi_watermarks_bypass_watermark_qs)
1595:   );
1596: 
1597: 
1598:   // R[adaptp_hi_watermarks]: V(True)
1599:   //   F[fips_watermark]: 15:0
1600:   prim_subreg_ext #(
1601:     .DW    (16)
1602:   ) u_adaptp_hi_watermarks_fips_watermark (
1603:     .re     (adaptp_hi_watermarks_re),
1604:     .we     (1'b0),
1605:     .wd     ('0),
1606:     .d      (hw2reg.adaptp_hi_watermarks.fips_watermark.d),
1607:     .qre    (),
1608:     .qe     (),
1609:     .q      (),
1610:     .ds     (),
1611:     .qs     (adaptp_hi_watermarks_fips_watermark_qs)
1612:   );
1613: 
1614:   //   F[bypass_watermark]: 31:16
1615:   prim_subreg_ext #(
1616:     .DW    (16)
1617:   ) u_adaptp_hi_watermarks_bypass_watermark (
1618:     .re     (adaptp_hi_watermarks_re),
1619:     .we     (1'b0),
1620:     .wd     ('0),
1621:     .d      (hw2reg.adaptp_hi_watermarks.bypass_watermark.d),
1622:     .qre    (),
1623:     .qe     (),
1624:     .q      (),
1625:     .ds     (),
1626:     .qs     (adaptp_hi_watermarks_bypass_watermark_qs)
1627:   );
1628: 
1629: 
1630:   // R[adaptp_lo_watermarks]: V(True)
1631:   //   F[fips_watermark]: 15:0
1632:   prim_subreg_ext #(
1633:     .DW    (16)
1634:   ) u_adaptp_lo_watermarks_fips_watermark (
1635:     .re     (adaptp_lo_watermarks_re),
1636:     .we     (1'b0),
1637:     .wd     ('0),
1638:     .d      (hw2reg.adaptp_lo_watermarks.fips_watermark.d),
1639:     .qre    (),
1640:     .qe     (),
1641:     .q      (),
1642:     .ds     (),
1643:     .qs     (adaptp_lo_watermarks_fips_watermark_qs)
1644:   );
1645: 
1646:   //   F[bypass_watermark]: 31:16
1647:   prim_subreg_ext #(
1648:     .DW    (16)
1649:   ) u_adaptp_lo_watermarks_bypass_watermark (
1650:     .re     (adaptp_lo_watermarks_re),
1651:     .we     (1'b0),
1652:     .wd     ('0),
1653:     .d      (hw2reg.adaptp_lo_watermarks.bypass_watermark.d),
1654:     .qre    (),
1655:     .qe     (),
1656:     .q      (),
1657:     .ds     (),
1658:     .qs     (adaptp_lo_watermarks_bypass_watermark_qs)
1659:   );
1660: 
1661: 
1662:   // R[extht_hi_watermarks]: V(True)
1663:   //   F[fips_watermark]: 15:0
1664:   prim_subreg_ext #(
1665:     .DW    (16)
1666:   ) u_extht_hi_watermarks_fips_watermark (
1667:     .re     (extht_hi_watermarks_re),
1668:     .we     (1'b0),
1669:     .wd     ('0),
1670:     .d      (hw2reg.extht_hi_watermarks.fips_watermark.d),
1671:     .qre    (),
1672:     .qe     (),
1673:     .q      (),
1674:     .ds     (),
1675:     .qs     (extht_hi_watermarks_fips_watermark_qs)
1676:   );
1677: 
1678:   //   F[bypass_watermark]: 31:16
1679:   prim_subreg_ext #(
1680:     .DW    (16)
1681:   ) u_extht_hi_watermarks_bypass_watermark (
1682:     .re     (extht_hi_watermarks_re),
1683:     .we     (1'b0),
1684:     .wd     ('0),
1685:     .d      (hw2reg.extht_hi_watermarks.bypass_watermark.d),
1686:     .qre    (),
1687:     .qe     (),
1688:     .q      (),
1689:     .ds     (),
1690:     .qs     (extht_hi_watermarks_bypass_watermark_qs)
1691:   );
1692: 
1693: 
1694:   // R[extht_lo_watermarks]: V(True)
1695:   //   F[fips_watermark]: 15:0
1696:   prim_subreg_ext #(
1697:     .DW    (16)
1698:   ) u_extht_lo_watermarks_fips_watermark (
1699:     .re     (extht_lo_watermarks_re),
1700:     .we     (1'b0),
1701:     .wd     ('0),
1702:     .d      (hw2reg.extht_lo_watermarks.fips_watermark.d),
1703:     .qre    (),
1704:     .qe     (),
1705:     .q      (),
1706:     .ds     (),
1707:     .qs     (extht_lo_watermarks_fips_watermark_qs)
1708:   );
1709: 
1710:   //   F[bypass_watermark]: 31:16
1711:   prim_subreg_ext #(
1712:     .DW    (16)
1713:   ) u_extht_lo_watermarks_bypass_watermark (
1714:     .re     (extht_lo_watermarks_re),
1715:     .we     (1'b0),
1716:     .wd     ('0),
1717:     .d      (hw2reg.extht_lo_watermarks.bypass_watermark.d),
1718:     .qre    (),
1719:     .qe     (),
1720:     .q      (),
1721:     .ds     (),
1722:     .qs     (extht_lo_watermarks_bypass_watermark_qs)
1723:   );
1724: 
1725: 
1726:   // R[bucket_hi_watermarks]: V(True)
1727:   //   F[fips_watermark]: 15:0
1728:   prim_subreg_ext #(
1729:     .DW    (16)
1730:   ) u_bucket_hi_watermarks_fips_watermark (
1731:     .re     (bucket_hi_watermarks_re),
1732:     .we     (1'b0),
1733:     .wd     ('0),
1734:     .d      (hw2reg.bucket_hi_watermarks.fips_watermark.d),
1735:     .qre    (),
1736:     .qe     (),
1737:     .q      (),
1738:     .ds     (),
1739:     .qs     (bucket_hi_watermarks_fips_watermark_qs)
1740:   );
1741: 
1742:   //   F[bypass_watermark]: 31:16
1743:   prim_subreg_ext #(
1744:     .DW    (16)
1745:   ) u_bucket_hi_watermarks_bypass_watermark (
1746:     .re     (bucket_hi_watermarks_re),
1747:     .we     (1'b0),
1748:     .wd     ('0),
1749:     .d      (hw2reg.bucket_hi_watermarks.bypass_watermark.d),
1750:     .qre    (),
1751:     .qe     (),
1752:     .q      (),
1753:     .ds     (),
1754:     .qs     (bucket_hi_watermarks_bypass_watermark_qs)
1755:   );
1756: 
1757: 
1758:   // R[markov_hi_watermarks]: V(True)
1759:   //   F[fips_watermark]: 15:0
1760:   prim_subreg_ext #(
1761:     .DW    (16)
1762:   ) u_markov_hi_watermarks_fips_watermark (
1763:     .re     (markov_hi_watermarks_re),
1764:     .we     (1'b0),
1765:     .wd     ('0),
1766:     .d      (hw2reg.markov_hi_watermarks.fips_watermark.d),
1767:     .qre    (),
1768:     .qe     (),
1769:     .q      (),
1770:     .ds     (),
1771:     .qs     (markov_hi_watermarks_fips_watermark_qs)
1772:   );
1773: 
1774:   //   F[bypass_watermark]: 31:16
1775:   prim_subreg_ext #(
1776:     .DW    (16)
1777:   ) u_markov_hi_watermarks_bypass_watermark (
1778:     .re     (markov_hi_watermarks_re),
1779:     .we     (1'b0),
1780:     .wd     ('0),
1781:     .d      (hw2reg.markov_hi_watermarks.bypass_watermark.d),
1782:     .qre    (),
1783:     .qe     (),
1784:     .q      (),
1785:     .ds     (),
1786:     .qs     (markov_hi_watermarks_bypass_watermark_qs)
1787:   );
1788: 
1789: 
1790:   // R[markov_lo_watermarks]: V(True)
1791:   //   F[fips_watermark]: 15:0
1792:   prim_subreg_ext #(
1793:     .DW    (16)
1794:   ) u_markov_lo_watermarks_fips_watermark (
1795:     .re     (markov_lo_watermarks_re),
1796:     .we     (1'b0),
1797:     .wd     ('0),
1798:     .d      (hw2reg.markov_lo_watermarks.fips_watermark.d),
1799:     .qre    (),
1800:     .qe     (),
1801:     .q      (),
1802:     .ds     (),
1803:     .qs     (markov_lo_watermarks_fips_watermark_qs)
1804:   );
1805: 
1806:   //   F[bypass_watermark]: 31:16
1807:   prim_subreg_ext #(
1808:     .DW    (16)
1809:   ) u_markov_lo_watermarks_bypass_watermark (
1810:     .re     (markov_lo_watermarks_re),
1811:     .we     (1'b0),
1812:     .wd     ('0),
1813:     .d      (hw2reg.markov_lo_watermarks.bypass_watermark.d),
1814:     .qre    (),
1815:     .qe     (),
1816:     .q      (),
1817:     .ds     (),
1818:     .qs     (markov_lo_watermarks_bypass_watermark_qs)
1819:   );
1820: 
1821: 
1822:   // R[repcnt_total_fails]: V(True)
1823:   prim_subreg_ext #(
1824:     .DW    (32)
1825:   ) u_repcnt_total_fails (
1826:     .re     (repcnt_total_fails_re),
1827:     .we     (1'b0),
1828:     .wd     ('0),
1829:     .d      (hw2reg.repcnt_total_fails.d),
1830:     .qre    (),
1831:     .qe     (),
1832:     .q      (),
1833:     .ds     (),
1834:     .qs     (repcnt_total_fails_qs)
1835:   );
1836: 
1837: 
1838:   // R[repcnts_total_fails]: V(True)
1839:   prim_subreg_ext #(
1840:     .DW    (32)
1841:   ) u_repcnts_total_fails (
1842:     .re     (repcnts_total_fails_re),
1843:     .we     (1'b0),
1844:     .wd     ('0),
1845:     .d      (hw2reg.repcnts_total_fails.d),
1846:     .qre    (),
1847:     .qe     (),
1848:     .q      (),
1849:     .ds     (),
1850:     .qs     (repcnts_total_fails_qs)
1851:   );
1852: 
1853: 
1854:   // R[adaptp_hi_total_fails]: V(True)
1855:   prim_subreg_ext #(
1856:     .DW    (32)
1857:   ) u_adaptp_hi_total_fails (
1858:     .re     (adaptp_hi_total_fails_re),
1859:     .we     (1'b0),
1860:     .wd     ('0),
1861:     .d      (hw2reg.adaptp_hi_total_fails.d),
1862:     .qre    (),
1863:     .qe     (),
1864:     .q      (),
1865:     .ds     (),
1866:     .qs     (adaptp_hi_total_fails_qs)
1867:   );
1868: 
1869: 
1870:   // R[adaptp_lo_total_fails]: V(True)
1871:   prim_subreg_ext #(
1872:     .DW    (32)
1873:   ) u_adaptp_lo_total_fails (
1874:     .re     (adaptp_lo_total_fails_re),
1875:     .we     (1'b0),
1876:     .wd     ('0),
1877:     .d      (hw2reg.adaptp_lo_total_fails.d),
1878:     .qre    (),
1879:     .qe     (),
1880:     .q      (),
1881:     .ds     (),
1882:     .qs     (adaptp_lo_total_fails_qs)
1883:   );
1884: 
1885: 
1886:   // R[bucket_total_fails]: V(True)
1887:   prim_subreg_ext #(
1888:     .DW    (32)
1889:   ) u_bucket_total_fails (
1890:     .re     (bucket_total_fails_re),
1891:     .we     (1'b0),
1892:     .wd     ('0),
1893:     .d      (hw2reg.bucket_total_fails.d),
1894:     .qre    (),
1895:     .qe     (),
1896:     .q      (),
1897:     .ds     (),
1898:     .qs     (bucket_total_fails_qs)
1899:   );
1900: 
1901: 
1902:   // R[markov_hi_total_fails]: V(True)
1903:   prim_subreg_ext #(
1904:     .DW    (32)
1905:   ) u_markov_hi_total_fails (
1906:     .re     (markov_hi_total_fails_re),
1907:     .we     (1'b0),
1908:     .wd     ('0),
1909:     .d      (hw2reg.markov_hi_total_fails.d),
1910:     .qre    (),
1911:     .qe     (),
1912:     .q      (),
1913:     .ds     (),
1914:     .qs     (markov_hi_total_fails_qs)
1915:   );
1916: 
1917: 
1918:   // R[markov_lo_total_fails]: V(True)
1919:   prim_subreg_ext #(
1920:     .DW    (32)
1921:   ) u_markov_lo_total_fails (
1922:     .re     (markov_lo_total_fails_re),
1923:     .we     (1'b0),
1924:     .wd     ('0),
1925:     .d      (hw2reg.markov_lo_total_fails.d),
1926:     .qre    (),
1927:     .qe     (),
1928:     .q      (),
1929:     .ds     (),
1930:     .qs     (markov_lo_total_fails_qs)
1931:   );
1932: 
1933: 
1934:   // R[extht_hi_total_fails]: V(True)
1935:   prim_subreg_ext #(
1936:     .DW    (32)
1937:   ) u_extht_hi_total_fails (
1938:     .re     (extht_hi_total_fails_re),
1939:     .we     (1'b0),
1940:     .wd     ('0),
1941:     .d      (hw2reg.extht_hi_total_fails.d),
1942:     .qre    (),
1943:     .qe     (),
1944:     .q      (),
1945:     .ds     (),
1946:     .qs     (extht_hi_total_fails_qs)
1947:   );
1948: 
1949: 
1950:   // R[extht_lo_total_fails]: V(True)
1951:   prim_subreg_ext #(
1952:     .DW    (32)
1953:   ) u_extht_lo_total_fails (
1954:     .re     (extht_lo_total_fails_re),
1955:     .we     (1'b0),
1956:     .wd     ('0),
1957:     .d      (hw2reg.extht_lo_total_fails.d),
1958:     .qre    (),
1959:     .qe     (),
1960:     .q      (),
1961:     .ds     (),
1962:     .qs     (extht_lo_total_fails_qs)
1963:   );
1964: 
1965: 
1966:   // R[alert_threshold]: V(False)
1967:   // Create REGWEN-gated WE signal
1968:   logic alert_threshold_gated_we;
1969:   assign alert_threshold_gated_we = alert_threshold_we & regwen_qs;
1970:   //   F[alert_threshold]: 15:0
1971:   prim_subreg #(
1972:     .DW      (16),
1973:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1974:     .RESVAL  (16'h2),
1975:     .Mubi    (1'b0)
1976:   ) u_alert_threshold_alert_threshold (
1977:     .clk_i   (clk_i),
1978:     .rst_ni  (rst_ni),
1979: 
1980:     // from register interface
1981:     .we     (alert_threshold_gated_we),
1982:     .wd     (alert_threshold_alert_threshold_wd),
1983: 
1984:     // from internal hardware
1985:     .de     (1'b0),
1986:     .d      ('0),
1987: 
1988:     // to internal hardware
1989:     .qe     (),
1990:     .q      (reg2hw.alert_threshold.alert_threshold.q),
1991:     .ds     (),
1992: 
1993:     // to register interface (read)
1994:     .qs     (alert_threshold_alert_threshold_qs)
1995:   );
1996: 
1997:   //   F[alert_threshold_inv]: 31:16
1998:   prim_subreg #(
1999:     .DW      (16),
2000:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2001:     .RESVAL  (16'hfffd),
2002:     .Mubi    (1'b0)
2003:   ) u_alert_threshold_alert_threshold_inv (
2004:     .clk_i   (clk_i),
2005:     .rst_ni  (rst_ni),
2006: 
2007:     // from register interface
2008:     .we     (alert_threshold_gated_we),
2009:     .wd     (alert_threshold_alert_threshold_inv_wd),
2010: 
2011:     // from internal hardware
2012:     .de     (1'b0),
2013:     .d      ('0),
2014: 
2015:     // to internal hardware
2016:     .qe     (),
2017:     .q      (reg2hw.alert_threshold.alert_threshold_inv.q),
2018:     .ds     (),
2019: 
2020:     // to register interface (read)
2021:     .qs     (alert_threshold_alert_threshold_inv_qs)
2022:   );
2023: 
2024: 
2025:   // R[alert_summary_fail_counts]: V(True)
2026:   prim_subreg_ext #(
2027:     .DW    (16)
2028:   ) u_alert_summary_fail_counts (
2029:     .re     (alert_summary_fail_counts_re),
2030:     .we     (1'b0),
2031:     .wd     ('0),
2032:     .d      (hw2reg.alert_summary_fail_counts.d),
2033:     .qre    (),
2034:     .qe     (),
2035:     .q      (),
2036:     .ds     (),
2037:     .qs     (alert_summary_fail_counts_qs)
2038:   );
2039: 
2040: 
2041:   // R[alert_fail_counts]: V(True)
2042:   //   F[repcnt_fail_count]: 7:4
2043:   prim_subreg_ext #(
2044:     .DW    (4)
2045:   ) u_alert_fail_counts_repcnt_fail_count (
2046:     .re     (alert_fail_counts_re),
2047:     .we     (1'b0),
2048:     .wd     ('0),
2049:     .d      (hw2reg.alert_fail_counts.repcnt_fail_count.d),
2050:     .qre    (),
2051:     .qe     (),
2052:     .q      (),
2053:     .ds     (),
2054:     .qs     (alert_fail_counts_repcnt_fail_count_qs)
2055:   );
2056: 
2057:   //   F[adaptp_hi_fail_count]: 11:8
2058:   prim_subreg_ext #(
2059:     .DW    (4)
2060:   ) u_alert_fail_counts_adaptp_hi_fail_count (
2061:     .re     (alert_fail_counts_re),
2062:     .we     (1'b0),
2063:     .wd     ('0),
2064:     .d      (hw2reg.alert_fail_counts.adaptp_hi_fail_count.d),
2065:     .qre    (),
2066:     .qe     (),
2067:     .q      (),
2068:     .ds     (),
2069:     .qs     (alert_fail_counts_adaptp_hi_fail_count_qs)
2070:   );
2071: 
2072:   //   F[adaptp_lo_fail_count]: 15:12
2073:   prim_subreg_ext #(
2074:     .DW    (4)
2075:   ) u_alert_fail_counts_adaptp_lo_fail_count (
2076:     .re     (alert_fail_counts_re),
2077:     .we     (1'b0),
2078:     .wd     ('0),
2079:     .d      (hw2reg.alert_fail_counts.adaptp_lo_fail_count.d),
2080:     .qre    (),
2081:     .qe     (),
2082:     .q      (),
2083:     .ds     (),
2084:     .qs     (alert_fail_counts_adaptp_lo_fail_count_qs)
2085:   );
2086: 
2087:   //   F[bucket_fail_count]: 19:16
2088:   prim_subreg_ext #(
2089:     .DW    (4)
2090:   ) u_alert_fail_counts_bucket_fail_count (
2091:     .re     (alert_fail_counts_re),
2092:     .we     (1'b0),
2093:     .wd     ('0),
2094:     .d      (hw2reg.alert_fail_counts.bucket_fail_count.d),
2095:     .qre    (),
2096:     .qe     (),
2097:     .q      (),
2098:     .ds     (),
2099:     .qs     (alert_fail_counts_bucket_fail_count_qs)
2100:   );
2101: 
2102:   //   F[markov_hi_fail_count]: 23:20
2103:   prim_subreg_ext #(
2104:     .DW    (4)
2105:   ) u_alert_fail_counts_markov_hi_fail_count (
2106:     .re     (alert_fail_counts_re),
2107:     .we     (1'b0),
2108:     .wd     ('0),
2109:     .d      (hw2reg.alert_fail_counts.markov_hi_fail_count.d),
2110:     .qre    (),
2111:     .qe     (),
2112:     .q      (),
2113:     .ds     (),
2114:     .qs     (alert_fail_counts_markov_hi_fail_count_qs)
2115:   );
2116: 
2117:   //   F[markov_lo_fail_count]: 27:24
2118:   prim_subreg_ext #(
2119:     .DW    (4)
2120:   ) u_alert_fail_counts_markov_lo_fail_count (
2121:     .re     (alert_fail_counts_re),
2122:     .we     (1'b0),
2123:     .wd     ('0),
2124:     .d      (hw2reg.alert_fail_counts.markov_lo_fail_count.d),
2125:     .qre    (),
2126:     .qe     (),
2127:     .q      (),
2128:     .ds     (),
2129:     .qs     (alert_fail_counts_markov_lo_fail_count_qs)
2130:   );
2131: 
2132:   //   F[repcnts_fail_count]: 31:28
2133:   prim_subreg_ext #(
2134:     .DW    (4)
2135:   ) u_alert_fail_counts_repcnts_fail_count (
2136:     .re     (alert_fail_counts_re),
2137:     .we     (1'b0),
2138:     .wd     ('0),
2139:     .d      (hw2reg.alert_fail_counts.repcnts_fail_count.d),
2140:     .qre    (),
2141:     .qe     (),
2142:     .q      (),
2143:     .ds     (),
2144:     .qs     (alert_fail_counts_repcnts_fail_count_qs)
2145:   );
2146: 
2147: 
2148:   // R[extht_fail_counts]: V(True)
2149:   //   F[extht_hi_fail_count]: 3:0
2150:   prim_subreg_ext #(
2151:     .DW    (4)
2152:   ) u_extht_fail_counts_extht_hi_fail_count (
2153:     .re     (extht_fail_counts_re),
2154:     .we     (1'b0),
2155:     .wd     ('0),
2156:     .d      (hw2reg.extht_fail_counts.extht_hi_fail_count.d),
2157:     .qre    (),
2158:     .qe     (),
2159:     .q      (),
2160:     .ds     (),
2161:     .qs     (extht_fail_counts_extht_hi_fail_count_qs)
2162:   );
2163: 
2164:   //   F[extht_lo_fail_count]: 7:4
2165:   prim_subreg_ext #(
2166:     .DW    (4)
2167:   ) u_extht_fail_counts_extht_lo_fail_count (
2168:     .re     (extht_fail_counts_re),
2169:     .we     (1'b0),
2170:     .wd     ('0),
2171:     .d      (hw2reg.extht_fail_counts.extht_lo_fail_count.d),
2172:     .qre    (),
2173:     .qe     (),
2174:     .q      (),
2175:     .ds     (),
2176:     .qs     (extht_fail_counts_extht_lo_fail_count_qs)
2177:   );
2178: 
2179: 
2180:   // R[fw_ov_control]: V(False)
2181:   // Create REGWEN-gated WE signal
2182:   logic fw_ov_control_gated_we;
2183:   assign fw_ov_control_gated_we = fw_ov_control_we & regwen_qs;
2184:   //   F[fw_ov_mode]: 3:0
2185:   prim_subreg #(
2186:     .DW      (4),
2187:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2188:     .RESVAL  (4'h9),
2189:     .Mubi    (1'b1)
2190:   ) u_fw_ov_control_fw_ov_mode (
2191:     .clk_i   (clk_i),
2192:     .rst_ni  (rst_ni),
2193: 
2194:     // from register interface
2195:     .we     (fw_ov_control_gated_we),
2196:     .wd     (fw_ov_control_fw_ov_mode_wd),
2197: 
2198:     // from internal hardware
2199:     .de     (1'b0),
2200:     .d      ('0),
2201: 
2202:     // to internal hardware
2203:     .qe     (),
2204:     .q      (reg2hw.fw_ov_control.fw_ov_mode.q),
2205:     .ds     (),
2206: 
2207:     // to register interface (read)
2208:     .qs     (fw_ov_control_fw_ov_mode_qs)
2209:   );
2210: 
2211:   //   F[fw_ov_entropy_insert]: 7:4
2212:   prim_subreg #(
2213:     .DW      (4),
2214:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2215:     .RESVAL  (4'h9),
2216:     .Mubi    (1'b1)
2217:   ) u_fw_ov_control_fw_ov_entropy_insert (
2218:     .clk_i   (clk_i),
2219:     .rst_ni  (rst_ni),
2220: 
2221:     // from register interface
2222:     .we     (fw_ov_control_gated_we),
2223:     .wd     (fw_ov_control_fw_ov_entropy_insert_wd),
2224: 
2225:     // from internal hardware
2226:     .de     (1'b0),
2227:     .d      ('0),
2228: 
2229:     // to internal hardware
2230:     .qe     (),
2231:     .q      (reg2hw.fw_ov_control.fw_ov_entropy_insert.q),
2232:     .ds     (),
2233: 
2234:     // to register interface (read)
2235:     .qs     (fw_ov_control_fw_ov_entropy_insert_qs)
2236:   );
2237: 
2238: 
2239:   // R[fw_ov_sha3_start]: V(False)
2240:   prim_subreg #(
2241:     .DW      (4),
2242:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2243:     .RESVAL  (4'h9),
2244:     .Mubi    (1'b1)
2245:   ) u_fw_ov_sha3_start (
2246:     .clk_i   (clk_i),
2247:     .rst_ni  (rst_ni),
2248: 
2249:     // from register interface
2250:     .we     (fw_ov_sha3_start_we),
2251:     .wd     (fw_ov_sha3_start_wd),
2252: 
2253:     // from internal hardware
2254:     .de     (1'b0),
2255:     .d      ('0),
2256: 
2257:     // to internal hardware
2258:     .qe     (),
2259:     .q      (reg2hw.fw_ov_sha3_start.q),
2260:     .ds     (),
2261: 
2262:     // to register interface (read)
2263:     .qs     (fw_ov_sha3_start_qs)
2264:   );
2265: 
2266: 
2267:   // R[fw_ov_wr_fifo_full]: V(True)
2268:   prim_subreg_ext #(
2269:     .DW    (1)
2270:   ) u_fw_ov_wr_fifo_full (
2271:     .re     (fw_ov_wr_fifo_full_re),
2272:     .we     (1'b0),
2273:     .wd     ('0),
2274:     .d      (hw2reg.fw_ov_wr_fifo_full.d),
2275:     .qre    (),
2276:     .qe     (),
2277:     .q      (),
2278:     .ds     (),
2279:     .qs     (fw_ov_wr_fifo_full_qs)
2280:   );
2281: 
2282: 
2283:   // R[fw_ov_rd_fifo_overflow]: V(False)
2284:   prim_subreg #(
2285:     .DW      (1),
2286:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2287:     .RESVAL  (1'h0),
2288:     .Mubi    (1'b0)
2289:   ) u_fw_ov_rd_fifo_overflow (
2290:     .clk_i   (clk_i),
2291:     .rst_ni  (rst_ni),
2292: 
2293:     // from register interface
2294:     .we     (1'b0),
2295:     .wd     ('0),
2296: 
2297:     // from internal hardware
2298:     .de     (hw2reg.fw_ov_rd_fifo_overflow.de),
2299:     .d      (hw2reg.fw_ov_rd_fifo_overflow.d),
2300: 
2301:     // to internal hardware
2302:     .qe     (),
2303:     .q      (),
2304:     .ds     (),
2305: 
2306:     // to register interface (read)
2307:     .qs     (fw_ov_rd_fifo_overflow_qs)
2308:   );
2309: 
2310: 
2311:   // R[fw_ov_rd_data]: V(True)
2312:   prim_subreg_ext #(
2313:     .DW    (32)
2314:   ) u_fw_ov_rd_data (
2315:     .re     (fw_ov_rd_data_re),
2316:     .we     (1'b0),
2317:     .wd     ('0),
2318:     .d      (hw2reg.fw_ov_rd_data.d),
2319:     .qre    (reg2hw.fw_ov_rd_data.re),
2320:     .qe     (),
2321:     .q      (reg2hw.fw_ov_rd_data.q),
2322:     .ds     (),
2323:     .qs     (fw_ov_rd_data_qs)
2324:   );
2325: 
2326: 
2327:   // R[fw_ov_wr_data]: V(True)
2328:   logic fw_ov_wr_data_qe;
2329:   logic [0:0] fw_ov_wr_data_flds_we;
2330:   assign fw_ov_wr_data_qe = &fw_ov_wr_data_flds_we;
2331:   prim_subreg_ext #(
2332:     .DW    (32)
2333:   ) u_fw_ov_wr_data (
2334:     .re     (1'b0),
2335:     .we     (fw_ov_wr_data_we),
2336:     .wd     (fw_ov_wr_data_wd),
2337:     .d      ('0),
2338:     .qre    (),
2339:     .qe     (fw_ov_wr_data_flds_we[0]),
2340:     .q      (reg2hw.fw_ov_wr_data.q),
2341:     .ds     (),
2342:     .qs     ()
2343:   );
2344:   assign reg2hw.fw_ov_wr_data.qe = fw_ov_wr_data_qe;
2345: 
2346: 
2347:   // R[observe_fifo_thresh]: V(False)
2348:   // Create REGWEN-gated WE signal
2349:   logic observe_fifo_thresh_gated_we;
2350:   assign observe_fifo_thresh_gated_we = observe_fifo_thresh_we & regwen_qs;
2351:   prim_subreg #(
2352:     .DW      (6),
2353:     .SwAccess(prim_subreg_pkg::SwAccessRW),
2354:     .RESVAL  (6'h10),
2355:     .Mubi    (1'b0)
2356:   ) u_observe_fifo_thresh (
2357:     .clk_i   (clk_i),
2358:     .rst_ni  (rst_ni),
2359: 
2360:     // from register interface
2361:     .we     (observe_fifo_thresh_gated_we),
2362:     .wd     (observe_fifo_thresh_wd),
2363: 
2364:     // from internal hardware
2365:     .de     (1'b0),
2366:     .d      ('0),
2367: 
2368:     // to internal hardware
2369:     .qe     (),
2370:     .q      (reg2hw.observe_fifo_thresh.q),
2371:     .ds     (),
2372: 
2373:     // to register interface (read)
2374:     .qs     (observe_fifo_thresh_qs)
2375:   );
2376: 
2377: 
2378:   // R[observe_fifo_depth]: V(True)
2379:   prim_subreg_ext #(
2380:     .DW    (6)
2381:   ) u_observe_fifo_depth (
2382:     .re     (observe_fifo_depth_re),
2383:     .we     (1'b0),
2384:     .wd     ('0),
2385:     .d      (hw2reg.observe_fifo_depth.d),
2386:     .qre    (),
2387:     .qe     (),
2388:     .q      (),
2389:     .ds     (),
2390:     .qs     (observe_fifo_depth_qs)
2391:   );
2392: 
2393: 
2394:   // R[debug_status]: V(True)
2395:   //   F[entropy_fifo_depth]: 1:0
2396:   prim_subreg_ext #(
2397:     .DW    (2)
2398:   ) u_debug_status_entropy_fifo_depth (
2399:     .re     (debug_status_re),
2400:     .we     (1'b0),
2401:     .wd     ('0),
2402:     .d      (hw2reg.debug_status.entropy_fifo_depth.d),
2403:     .qre    (),
2404:     .qe     (),
2405:     .q      (),
2406:     .ds     (),
2407:     .qs     (debug_status_entropy_fifo_depth_qs)
2408:   );
2409: 
2410:   //   F[sha3_fsm]: 5:3
2411:   prim_subreg_ext #(
2412:     .DW    (3)
2413:   ) u_debug_status_sha3_fsm (
2414:     .re     (debug_status_re),
2415:     .we     (1'b0),
2416:     .wd     ('0),
2417:     .d      (hw2reg.debug_status.sha3_fsm.d),
2418:     .qre    (),
2419:     .qe     (),
2420:     .q      (),
2421:     .ds     (),
2422:     .qs     (debug_status_sha3_fsm_qs)
2423:   );
2424: 
2425:   //   F[sha3_block_pr]: 6:6
2426:   prim_subreg_ext #(
2427:     .DW    (1)
2428:   ) u_debug_status_sha3_block_pr (
2429:     .re     (debug_status_re),
2430:     .we     (1'b0),
2431:     .wd     ('0),
2432:     .d      (hw2reg.debug_status.sha3_block_pr.d),
2433:     .qre    (),
2434:     .qe     (),
2435:     .q      (),
2436:     .ds     (),
2437:     .qs     (debug_status_sha3_block_pr_qs)
2438:   );
2439: 
2440:   //   F[sha3_squeezing]: 7:7
2441:   prim_subreg_ext #(
2442:     .DW    (1)
2443:   ) u_debug_status_sha3_squeezing (
2444:     .re     (debug_status_re),
2445:     .we     (1'b0),
2446:     .wd     ('0),
2447:     .d      (hw2reg.debug_status.sha3_squeezing.d),
2448:     .qre    (),
2449:     .qe     (),
2450:     .q      (),
2451:     .ds     (),
2452:     .qs     (debug_status_sha3_squeezing_qs)
2453:   );
2454: 
2455:   //   F[sha3_absorbed]: 8:8
2456:   prim_subreg_ext #(
2457:     .DW    (1)
2458:   ) u_debug_status_sha3_absorbed (
2459:     .re     (debug_status_re),
2460:     .we     (1'b0),
2461:     .wd     ('0),
2462:     .d      (hw2reg.debug_status.sha3_absorbed.d),
2463:     .qre    (),
2464:     .qe     (),
2465:     .q      (),
2466:     .ds     (),
2467:     .qs     (debug_status_sha3_absorbed_qs)
2468:   );
2469: 
2470:   //   F[sha3_err]: 9:9
2471:   prim_subreg_ext #(
2472:     .DW    (1)
2473:   ) u_debug_status_sha3_err (
2474:     .re     (debug_status_re),
2475:     .we     (1'b0),
2476:     .wd     ('0),
2477:     .d      (hw2reg.debug_status.sha3_err.d),
2478:     .qre    (),
2479:     .qe     (),
2480:     .q      (),
2481:     .ds     (),
2482:     .qs     (debug_status_sha3_err_qs)
2483:   );
2484: 
2485:   //   F[main_sm_idle]: 16:16
2486:   prim_subreg_ext #(
2487:     .DW    (1)
2488:   ) u_debug_status_main_sm_idle (
2489:     .re     (debug_status_re),
2490:     .we     (1'b0),
2491:     .wd     ('0),
2492:     .d      (hw2reg.debug_status.main_sm_idle.d),
2493:     .qre    (),
2494:     .qe     (),
2495:     .q      (),
2496:     .ds     (),
2497:     .qs     (debug_status_main_sm_idle_qs)
2498:   );
2499: 
2500:   //   F[main_sm_boot_done]: 17:17
2501:   prim_subreg_ext #(
2502:     .DW    (1)
2503:   ) u_debug_status_main_sm_boot_done (
2504:     .re     (debug_status_re),
2505:     .we     (1'b0),
2506:     .wd     ('0),
2507:     .d      (hw2reg.debug_status.main_sm_boot_done.d),
2508:     .qre    (),
2509:     .qe     (),
2510:     .q      (),
2511:     .ds     (),
2512:     .qs     (debug_status_main_sm_boot_done_qs)
2513:   );
2514: 
2515: 
2516:   // R[recov_alert_sts]: V(False)
2517:   //   F[fips_enable_field_alert]: 0:0
2518:   prim_subreg #(
2519:     .DW      (1),
2520:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2521:     .RESVAL  (1'h0),
2522:     .Mubi    (1'b0)
2523:   ) u_recov_alert_sts_fips_enable_field_alert (
2524:     .clk_i   (clk_i),
2525:     .rst_ni  (rst_ni),
2526: 
2527:     // from register interface
2528:     .we     (recov_alert_sts_we),
2529:     .wd     (recov_alert_sts_fips_enable_field_alert_wd),
2530: 
2531:     // from internal hardware
2532:     .de     (hw2reg.recov_alert_sts.fips_enable_field_alert.de),
2533:     .d      (hw2reg.recov_alert_sts.fips_enable_field_alert.d),
2534: 
2535:     // to internal hardware
2536:     .qe     (),
2537:     .q      (),
2538:     .ds     (),
2539: 
2540:     // to register interface (read)
2541:     .qs     (recov_alert_sts_fips_enable_field_alert_qs)
2542:   );
2543: 
2544:   //   F[entropy_data_reg_en_field_alert]: 1:1
2545:   prim_subreg #(
2546:     .DW      (1),
2547:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2548:     .RESVAL  (1'h0),
2549:     .Mubi    (1'b0)
2550:   ) u_recov_alert_sts_entropy_data_reg_en_field_alert (
2551:     .clk_i   (clk_i),
2552:     .rst_ni  (rst_ni),
2553: 
2554:     // from register interface
2555:     .we     (recov_alert_sts_we),
2556:     .wd     (recov_alert_sts_entropy_data_reg_en_field_alert_wd),
2557: 
2558:     // from internal hardware
2559:     .de     (hw2reg.recov_alert_sts.entropy_data_reg_en_field_alert.de),
2560:     .d      (hw2reg.recov_alert_sts.entropy_data_reg_en_field_alert.d),
2561: 
2562:     // to internal hardware
2563:     .qe     (),
2564:     .q      (),
2565:     .ds     (),
2566: 
2567:     // to register interface (read)
2568:     .qs     (recov_alert_sts_entropy_data_reg_en_field_alert_qs)
2569:   );
2570: 
2571:   //   F[module_enable_field_alert]: 2:2
2572:   prim_subreg #(
2573:     .DW      (1),
2574:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2575:     .RESVAL  (1'h0),
2576:     .Mubi    (1'b0)
2577:   ) u_recov_alert_sts_module_enable_field_alert (
2578:     .clk_i   (clk_i),
2579:     .rst_ni  (rst_ni),
2580: 
2581:     // from register interface
2582:     .we     (recov_alert_sts_we),
2583:     .wd     (recov_alert_sts_module_enable_field_alert_wd),
2584: 
2585:     // from internal hardware
2586:     .de     (hw2reg.recov_alert_sts.module_enable_field_alert.de),
2587:     .d      (hw2reg.recov_alert_sts.module_enable_field_alert.d),
2588: 
2589:     // to internal hardware
2590:     .qe     (),
2591:     .q      (),
2592:     .ds     (),
2593: 
2594:     // to register interface (read)
2595:     .qs     (recov_alert_sts_module_enable_field_alert_qs)
2596:   );
2597: 
2598:   //   F[threshold_scope_field_alert]: 3:3
2599:   prim_subreg #(
2600:     .DW      (1),
2601:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2602:     .RESVAL  (1'h0),
2603:     .Mubi    (1'b0)
2604:   ) u_recov_alert_sts_threshold_scope_field_alert (
2605:     .clk_i   (clk_i),
2606:     .rst_ni  (rst_ni),
2607: 
2608:     // from register interface
2609:     .we     (recov_alert_sts_we),
2610:     .wd     (recov_alert_sts_threshold_scope_field_alert_wd),
2611: 
2612:     // from internal hardware
2613:     .de     (hw2reg.recov_alert_sts.threshold_scope_field_alert.de),
2614:     .d      (hw2reg.recov_alert_sts.threshold_scope_field_alert.d),
2615: 
2616:     // to internal hardware
2617:     .qe     (),
2618:     .q      (),
2619:     .ds     (),
2620: 
2621:     // to register interface (read)
2622:     .qs     (recov_alert_sts_threshold_scope_field_alert_qs)
2623:   );
2624: 
2625:   //   F[rng_bit_enable_field_alert]: 5:5
2626:   prim_subreg #(
2627:     .DW      (1),
2628:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2629:     .RESVAL  (1'h0),
2630:     .Mubi    (1'b0)
2631:   ) u_recov_alert_sts_rng_bit_enable_field_alert (
2632:     .clk_i   (clk_i),
2633:     .rst_ni  (rst_ni),
2634: 
2635:     // from register interface
2636:     .we     (recov_alert_sts_we),
2637:     .wd     (recov_alert_sts_rng_bit_enable_field_alert_wd),
2638: 
2639:     // from internal hardware
2640:     .de     (hw2reg.recov_alert_sts.rng_bit_enable_field_alert.de),
2641:     .d      (hw2reg.recov_alert_sts.rng_bit_enable_field_alert.d),
2642: 
2643:     // to internal hardware
2644:     .qe     (),
2645:     .q      (),
2646:     .ds     (),
2647: 
2648:     // to register interface (read)
2649:     .qs     (recov_alert_sts_rng_bit_enable_field_alert_qs)
2650:   );
2651: 
2652:   //   F[fw_ov_sha3_start_field_alert]: 7:7
2653:   prim_subreg #(
2654:     .DW      (1),
2655:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2656:     .RESVAL  (1'h0),
2657:     .Mubi    (1'b0)
2658:   ) u_recov_alert_sts_fw_ov_sha3_start_field_alert (
2659:     .clk_i   (clk_i),
2660:     .rst_ni  (rst_ni),
2661: 
2662:     // from register interface
2663:     .we     (recov_alert_sts_we),
2664:     .wd     (recov_alert_sts_fw_ov_sha3_start_field_alert_wd),
2665: 
2666:     // from internal hardware
2667:     .de     (hw2reg.recov_alert_sts.fw_ov_sha3_start_field_alert.de),
2668:     .d      (hw2reg.recov_alert_sts.fw_ov_sha3_start_field_alert.d),
2669: 
2670:     // to internal hardware
2671:     .qe     (),
2672:     .q      (),
2673:     .ds     (),
2674: 
2675:     // to register interface (read)
2676:     .qs     (recov_alert_sts_fw_ov_sha3_start_field_alert_qs)
2677:   );
2678: 
2679:   //   F[fw_ov_mode_field_alert]: 8:8
2680:   prim_subreg #(
2681:     .DW      (1),
2682:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2683:     .RESVAL  (1'h0),
2684:     .Mubi    (1'b0)
2685:   ) u_recov_alert_sts_fw_ov_mode_field_alert (
2686:     .clk_i   (clk_i),
2687:     .rst_ni  (rst_ni),
2688: 
2689:     // from register interface
2690:     .we     (recov_alert_sts_we),
2691:     .wd     (recov_alert_sts_fw_ov_mode_field_alert_wd),
2692: 
2693:     // from internal hardware
2694:     .de     (hw2reg.recov_alert_sts.fw_ov_mode_field_alert.de),
2695:     .d      (hw2reg.recov_alert_sts.fw_ov_mode_field_alert.d),
2696: 
2697:     // to internal hardware
2698:     .qe     (),
2699:     .q      (),
2700:     .ds     (),
2701: 
2702:     // to register interface (read)
2703:     .qs     (recov_alert_sts_fw_ov_mode_field_alert_qs)
2704:   );
2705: 
2706:   //   F[fw_ov_entropy_insert_field_alert]: 9:9
2707:   prim_subreg #(
2708:     .DW      (1),
2709:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2710:     .RESVAL  (1'h0),
2711:     .Mubi    (1'b0)
2712:   ) u_recov_alert_sts_fw_ov_entropy_insert_field_alert (
2713:     .clk_i   (clk_i),
2714:     .rst_ni  (rst_ni),
2715: 
2716:     // from register interface
2717:     .we     (recov_alert_sts_we),
2718:     .wd     (recov_alert_sts_fw_ov_entropy_insert_field_alert_wd),
2719: 
2720:     // from internal hardware
2721:     .de     (hw2reg.recov_alert_sts.fw_ov_entropy_insert_field_alert.de),
2722:     .d      (hw2reg.recov_alert_sts.fw_ov_entropy_insert_field_alert.d),
2723: 
2724:     // to internal hardware
2725:     .qe     (),
2726:     .q      (),
2727:     .ds     (),
2728: 
2729:     // to register interface (read)
2730:     .qs     (recov_alert_sts_fw_ov_entropy_insert_field_alert_qs)
2731:   );
2732: 
2733:   //   F[es_route_field_alert]: 10:10
2734:   prim_subreg #(
2735:     .DW      (1),
2736:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2737:     .RESVAL  (1'h0),
2738:     .Mubi    (1'b0)
2739:   ) u_recov_alert_sts_es_route_field_alert (
2740:     .clk_i   (clk_i),
2741:     .rst_ni  (rst_ni),
2742: 
2743:     // from register interface
2744:     .we     (recov_alert_sts_we),
2745:     .wd     (recov_alert_sts_es_route_field_alert_wd),
2746: 
2747:     // from internal hardware
2748:     .de     (hw2reg.recov_alert_sts.es_route_field_alert.de),
2749:     .d      (hw2reg.recov_alert_sts.es_route_field_alert.d),
2750: 
2751:     // to internal hardware
2752:     .qe     (),
2753:     .q      (),
2754:     .ds     (),
2755: 
2756:     // to register interface (read)
2757:     .qs     (recov_alert_sts_es_route_field_alert_qs)
2758:   );
2759: 
2760:   //   F[es_type_field_alert]: 11:11
2761:   prim_subreg #(
2762:     .DW      (1),
2763:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2764:     .RESVAL  (1'h0),
2765:     .Mubi    (1'b0)
2766:   ) u_recov_alert_sts_es_type_field_alert (
2767:     .clk_i   (clk_i),
2768:     .rst_ni  (rst_ni),
2769: 
2770:     // from register interface
2771:     .we     (recov_alert_sts_we),
2772:     .wd     (recov_alert_sts_es_type_field_alert_wd),
2773: 
2774:     // from internal hardware
2775:     .de     (hw2reg.recov_alert_sts.es_type_field_alert.de),
2776:     .d      (hw2reg.recov_alert_sts.es_type_field_alert.d),
2777: 
2778:     // to internal hardware
2779:     .qe     (),
2780:     .q      (),
2781:     .ds     (),
2782: 
2783:     // to register interface (read)
2784:     .qs     (recov_alert_sts_es_type_field_alert_qs)
2785:   );
2786: 
2787:   //   F[es_main_sm_alert]: 12:12
2788:   prim_subreg #(
2789:     .DW      (1),
2790:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2791:     .RESVAL  (1'h0),
2792:     .Mubi    (1'b0)
2793:   ) u_recov_alert_sts_es_main_sm_alert (
2794:     .clk_i   (clk_i),
2795:     .rst_ni  (rst_ni),
2796: 
2797:     // from register interface
2798:     .we     (recov_alert_sts_we),
2799:     .wd     (recov_alert_sts_es_main_sm_alert_wd),
2800: 
2801:     // from internal hardware
2802:     .de     (hw2reg.recov_alert_sts.es_main_sm_alert.de),
2803:     .d      (hw2reg.recov_alert_sts.es_main_sm_alert.d),
2804: 
2805:     // to internal hardware
2806:     .qe     (),
2807:     .q      (),
2808:     .ds     (),
2809: 
2810:     // to register interface (read)
2811:     .qs     (recov_alert_sts_es_main_sm_alert_qs)
2812:   );
2813: 
2814:   //   F[es_bus_cmp_alert]: 13:13
2815:   prim_subreg #(
2816:     .DW      (1),
2817:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2818:     .RESVAL  (1'h0),
2819:     .Mubi    (1'b0)
2820:   ) u_recov_alert_sts_es_bus_cmp_alert (
2821:     .clk_i   (clk_i),
2822:     .rst_ni  (rst_ni),
2823: 
2824:     // from register interface
2825:     .we     (recov_alert_sts_we),
2826:     .wd     (recov_alert_sts_es_bus_cmp_alert_wd),
2827: 
2828:     // from internal hardware
2829:     .de     (hw2reg.recov_alert_sts.es_bus_cmp_alert.de),
2830:     .d      (hw2reg.recov_alert_sts.es_bus_cmp_alert.d),
2831: 
2832:     // to internal hardware
2833:     .qe     (),
2834:     .q      (),
2835:     .ds     (),
2836: 
2837:     // to register interface (read)
2838:     .qs     (recov_alert_sts_es_bus_cmp_alert_qs)
2839:   );
2840: 
2841:   //   F[es_thresh_cfg_alert]: 14:14
2842:   prim_subreg #(
2843:     .DW      (1),
2844:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2845:     .RESVAL  (1'h0),
2846:     .Mubi    (1'b0)
2847:   ) u_recov_alert_sts_es_thresh_cfg_alert (
2848:     .clk_i   (clk_i),
2849:     .rst_ni  (rst_ni),
2850: 
2851:     // from register interface
2852:     .we     (recov_alert_sts_we),
2853:     .wd     (recov_alert_sts_es_thresh_cfg_alert_wd),
2854: 
2855:     // from internal hardware
2856:     .de     (hw2reg.recov_alert_sts.es_thresh_cfg_alert.de),
2857:     .d      (hw2reg.recov_alert_sts.es_thresh_cfg_alert.d),
2858: 
2859:     // to internal hardware
2860:     .qe     (),
2861:     .q      (),
2862:     .ds     (),
2863: 
2864:     // to register interface (read)
2865:     .qs     (recov_alert_sts_es_thresh_cfg_alert_qs)
2866:   );
2867: 
2868:   //   F[es_fw_ov_wr_alert]: 15:15
2869:   prim_subreg #(
2870:     .DW      (1),
2871:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2872:     .RESVAL  (1'h0),
2873:     .Mubi    (1'b0)
2874:   ) u_recov_alert_sts_es_fw_ov_wr_alert (
2875:     .clk_i   (clk_i),
2876:     .rst_ni  (rst_ni),
2877: 
2878:     // from register interface
2879:     .we     (recov_alert_sts_we),
2880:     .wd     (recov_alert_sts_es_fw_ov_wr_alert_wd),
2881: 
2882:     // from internal hardware
2883:     .de     (hw2reg.recov_alert_sts.es_fw_ov_wr_alert.de),
2884:     .d      (hw2reg.recov_alert_sts.es_fw_ov_wr_alert.d),
2885: 
2886:     // to internal hardware
2887:     .qe     (),
2888:     .q      (),
2889:     .ds     (),
2890: 
2891:     // to register interface (read)
2892:     .qs     (recov_alert_sts_es_fw_ov_wr_alert_qs)
2893:   );
2894: 
2895:   //   F[es_fw_ov_disable_alert]: 16:16
2896:   prim_subreg #(
2897:     .DW      (1),
2898:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2899:     .RESVAL  (1'h0),
2900:     .Mubi    (1'b0)
2901:   ) u_recov_alert_sts_es_fw_ov_disable_alert (
2902:     .clk_i   (clk_i),
2903:     .rst_ni  (rst_ni),
2904: 
2905:     // from register interface
2906:     .we     (recov_alert_sts_we),
2907:     .wd     (recov_alert_sts_es_fw_ov_disable_alert_wd),
2908: 
2909:     // from internal hardware
2910:     .de     (hw2reg.recov_alert_sts.es_fw_ov_disable_alert.de),
2911:     .d      (hw2reg.recov_alert_sts.es_fw_ov_disable_alert.d),
2912: 
2913:     // to internal hardware
2914:     .qe     (),
2915:     .q      (),
2916:     .ds     (),
2917: 
2918:     // to register interface (read)
2919:     .qs     (recov_alert_sts_es_fw_ov_disable_alert_qs)
2920:   );
2921: 
2922:   //   F[fips_flag_field_alert]: 17:17
2923:   prim_subreg #(
2924:     .DW      (1),
2925:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2926:     .RESVAL  (1'h0),
2927:     .Mubi    (1'b0)
2928:   ) u_recov_alert_sts_fips_flag_field_alert (
2929:     .clk_i   (clk_i),
2930:     .rst_ni  (rst_ni),
2931: 
2932:     // from register interface
2933:     .we     (recov_alert_sts_we),
2934:     .wd     (recov_alert_sts_fips_flag_field_alert_wd),
2935: 
2936:     // from internal hardware
2937:     .de     (hw2reg.recov_alert_sts.fips_flag_field_alert.de),
2938:     .d      (hw2reg.recov_alert_sts.fips_flag_field_alert.d),
2939: 
2940:     // to internal hardware
2941:     .qe     (),
2942:     .q      (),
2943:     .ds     (),
2944: 
2945:     // to register interface (read)
2946:     .qs     (recov_alert_sts_fips_flag_field_alert_qs)
2947:   );
2948: 
2949:   //   F[rng_fips_field_alert]: 18:18
2950:   prim_subreg #(
2951:     .DW      (1),
2952:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2953:     .RESVAL  (1'h0),
2954:     .Mubi    (1'b0)
2955:   ) u_recov_alert_sts_rng_fips_field_alert (
2956:     .clk_i   (clk_i),
2957:     .rst_ni  (rst_ni),
2958: 
2959:     // from register interface
2960:     .we     (recov_alert_sts_we),
2961:     .wd     (recov_alert_sts_rng_fips_field_alert_wd),
2962: 
2963:     // from internal hardware
2964:     .de     (hw2reg.recov_alert_sts.rng_fips_field_alert.de),
2965:     .d      (hw2reg.recov_alert_sts.rng_fips_field_alert.d),
2966: 
2967:     // to internal hardware
2968:     .qe     (),
2969:     .q      (),
2970:     .ds     (),
2971: 
2972:     // to register interface (read)
2973:     .qs     (recov_alert_sts_rng_fips_field_alert_qs)
2974:   );
2975: 
2976:   //   F[postht_entropy_drop_alert]: 31:31
2977:   prim_subreg #(
2978:     .DW      (1),
2979:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2980:     .RESVAL  (1'h0),
2981:     .Mubi    (1'b0)
2982:   ) u_recov_alert_sts_postht_entropy_drop_alert (
2983:     .clk_i   (clk_i),
2984:     .rst_ni  (rst_ni),
2985: 
2986:     // from register interface
2987:     .we     (recov_alert_sts_we),
2988:     .wd     (recov_alert_sts_postht_entropy_drop_alert_wd),
2989: 
2990:     // from internal hardware
2991:     .de     (hw2reg.recov_alert_sts.postht_entropy_drop_alert.de),
2992:     .d      (hw2reg.recov_alert_sts.postht_entropy_drop_alert.d),
2993: 
2994:     // to internal hardware
2995:     .qe     (),
2996:     .q      (),
2997:     .ds     (),
2998: 
2999:     // to register interface (read)
3000:     .qs     (recov_alert_sts_postht_entropy_drop_alert_qs)
3001:   );
3002: 
3003: 
3004:   // R[err_code]: V(False)
3005:   //   F[sfifo_esrng_err]: 0:0
3006:   prim_subreg #(
3007:     .DW      (1),
3008:     .SwAccess(prim_subreg_pkg::SwAccessRO),
3009:     .RESVAL  (1'h0),
3010:     .Mubi    (1'b0)
3011:   ) u_err_code_sfifo_esrng_err (
3012:     .clk_i   (clk_i),
3013:     .rst_ni  (rst_ni),
3014: 
3015:     // from register interface
3016:     .we     (1'b0),
3017:     .wd     ('0),
3018: 
3019:     // from internal hardware
3020:     .de     (hw2reg.err_code.sfifo_esrng_err.de),
3021:     .d      (hw2reg.err_code.sfifo_esrng_err.d),
3022: 
3023:     // to internal hardware
3024:     .qe     (),
3025:     .q      (),
3026:     .ds     (),
3027: 
3028:     // to register interface (read)
3029:     .qs     (err_code_sfifo_esrng_err_qs)
3030:   );
3031: 
3032:   //   F[sfifo_distr_err]: 1:1
3033:   prim_subreg #(
3034:     .DW      (1),
3035:     .SwAccess(prim_subreg_pkg::SwAccessRO),
3036:     .RESVAL  (1'h0),
3037:     .Mubi    (1'b0)
3038:   ) u_err_code_sfifo_distr_err (
3039:     .clk_i   (clk_i),
3040:     .rst_ni  (rst_ni),
3041: 
3042:     // from register interface
3043:     .we     (1'b0),
3044:     .wd     ('0),
3045: 
3046:     // from internal hardware
3047:     .de     (hw2reg.err_code.sfifo_distr_err.de),
3048:     .d      (hw2reg.err_code.sfifo_distr_err.d),
3049: 
3050:     // to internal hardware
3051:     .qe     (),
3052:     .q      (),
3053:     .ds     (),
3054: 
3055:     // to register interface (read)
3056:     .qs     (err_code_sfifo_distr_err_qs)
3057:   );
3058: 
3059:   //   F[sfifo_observe_err]: 2:2
3060:   prim_subreg #(
3061:     .DW      (1),
3062:     .SwAccess(prim_subreg_pkg::SwAccessRO),
3063:     .RESVAL  (1'h0),
3064:     .Mubi    (1'b0)
3065:   ) u_err_code_sfifo_observe_err (
3066:     .clk_i   (clk_i),
3067:     .rst_ni  (rst_ni),
3068: 
3069:     // from register interface
3070:     .we     (1'b0),
3071:     .wd     ('0),
3072: 
3073:     // from internal hardware
3074:     .de     (hw2reg.err_code.sfifo_observe_err.de),
3075:     .d      (hw2reg.err_code.sfifo_observe_err.d),
3076: 
3077:     // to internal hardware
3078:     .qe     (),
3079:     .q      (),
3080:     .ds     (),
3081: 
3082:     // to register interface (read)
3083:     .qs     (err_code_sfifo_observe_err_qs)
3084:   );
3085: 
3086:   //   F[sfifo_esfinal_err]: 3:3
3087:   prim_subreg #(
3088:     .DW      (1),
3089:     .SwAccess(prim_subreg_pkg::SwAccessRO),
3090:     .RESVAL  (1'h0),
3091:     .Mubi    (1'b0)
3092:   ) u_err_code_sfifo_esfinal_err (
3093:     .clk_i   (clk_i),
3094:     .rst_ni  (rst_ni),
3095: 
3096:     // from register interface
3097:     .we     (1'b0),
3098:     .wd     ('0),
3099: 
3100:     // from internal hardware
3101:     .de     (hw2reg.err_code.sfifo_esfinal_err.de),
3102:     .d      (hw2reg.err_code.sfifo_esfinal_err.d),
3103: 
3104:     // to internal hardware
3105:     .qe     (),
3106:     .q      (),
3107:     .ds     (),
3108: 
3109:     // to register interface (read)
3110:     .qs     (err_code_sfifo_esfinal_err_qs)
3111:   );
3112: 
3113:   //   F[es_ack_sm_err]: 20:20
3114:   prim_subreg #(
3115:     .DW      (1),
3116:     .SwAccess(prim_subreg_pkg::SwAccessRO),
3117:     .RESVAL  (1'h0),
3118:     .Mubi    (1'b0)
3119:   ) u_err_code_es_ack_sm_err (
3120:     .clk_i   (clk_i),
3121:     .rst_ni  (rst_ni),
3122: 
3123:     // from register interface
3124:     .we     (1'b0),
3125:     .wd     ('0),
3126: 
3127:     // from internal hardware
3128:     .de     (hw2reg.err_code.es_ack_sm_err.de),
3129:     .d      (hw2reg.err_code.es_ack_sm_err.d),
3130: 
3131:     // to internal hardware
3132:     .qe     (),
3133:     .q      (),
3134:     .ds     (),
3135: 
3136:     // to register interface (read)
3137:     .qs     (err_code_es_ack_sm_err_qs)
3138:   );
3139: 
3140:   //   F[es_main_sm_err]: 21:21
3141:   prim_subreg #(
3142:     .DW      (1),
3143:     .SwAccess(prim_subreg_pkg::SwAccessRO),
3144:     .RESVAL  (1'h0),
3145:     .Mubi    (1'b0)
3146:   ) u_err_code_es_main_sm_err (
3147:     .clk_i   (clk_i),
3148:     .rst_ni  (rst_ni),
3149: 
3150:     // from register interface
3151:     .we     (1'b0),
3152:     .wd     ('0),
3153: 
3154:     // from internal hardware
3155:     .de     (hw2reg.err_code.es_main_sm_err.de),
3156:     .d      (hw2reg.err_code.es_main_sm_err.d),
3157: 
3158:     // to internal hardware
3159:     .qe     (),
3160:     .q      (),
3161:     .ds     (),
3162: 
3163:     // to register interface (read)
3164:     .qs     (err_code_es_main_sm_err_qs)
3165:   );
3166: 
3167:   //   F[es_cntr_err]: 22:22
3168:   prim_subreg #(
3169:     .DW      (1),
3170:     .SwAccess(prim_subreg_pkg::SwAccessRO),
3171:     .RESVAL  (1'h0),
3172:     .Mubi    (1'b0)
3173:   ) u_err_code_es_cntr_err (
3174:     .clk_i   (clk_i),
3175:     .rst_ni  (rst_ni),
3176: 
3177:     // from register interface
3178:     .we     (1'b0),
3179:     .wd     ('0),
3180: 
3181:     // from internal hardware
3182:     .de     (hw2reg.err_code.es_cntr_err.de),
3183:     .d      (hw2reg.err_code.es_cntr_err.d),
3184: 
3185:     // to internal hardware
3186:     .qe     (),
3187:     .q      (),
3188:     .ds     (),
3189: 
3190:     // to register interface (read)
3191:     .qs     (err_code_es_cntr_err_qs)
3192:   );
3193: 
3194:   //   F[sha3_state_err]: 23:23
3195:   prim_subreg #(
3196:     .DW      (1),
3197:     .SwAccess(prim_subreg_pkg::SwAccessRO),
3198:     .RESVAL  (1'h0),
3199:     .Mubi    (1'b0)
3200:   ) u_err_code_sha3_state_err (
3201:     .clk_i   (clk_i),
3202:     .rst_ni  (rst_ni),
3203: 
3204:     // from register interface
3205:     .we     (1'b0),
3206:     .wd     ('0),
3207: 
3208:     // from internal hardware
3209:     .de     (hw2reg.err_code.sha3_state_err.de),
3210:     .d      (hw2reg.err_code.sha3_state_err.d),
3211: 
3212:     // to internal hardware
3213:     .qe     (),
3214:     .q      (),
3215:     .ds     (),
3216: 
3217:     // to register interface (read)
3218:     .qs     (err_code_sha3_state_err_qs)
3219:   );
3220: 
3221:   //   F[sha3_rst_storage_err]: 24:24
3222:   prim_subreg #(
3223:     .DW      (1),
3224:     .SwAccess(prim_subreg_pkg::SwAccessRO),
3225:     .RESVAL  (1'h0),
3226:     .Mubi    (1'b0)
3227:   ) u_err_code_sha3_rst_storage_err (
3228:     .clk_i   (clk_i),
3229:     .rst_ni  (rst_ni),
3230: 
3231:     // from register interface
3232:     .we     (1'b0),
3233:     .wd     ('0),
3234: 
3235:     // from internal hardware
3236:     .de     (hw2reg.err_code.sha3_rst_storage_err.de),
3237:     .d      (hw2reg.err_code.sha3_rst_storage_err.d),
3238: 
3239:     // to internal hardware
3240:     .qe     (),
3241:     .q      (),
3242:     .ds     (),
3243: 
3244:     // to register interface (read)
3245:     .qs     (err_code_sha3_rst_storage_err_qs)
3246:   );
3247: 
3248:   //   F[fifo_write_err]: 28:28
3249:   prim_subreg #(
3250:     .DW      (1),
3251:     .SwAccess(prim_subreg_pkg::SwAccessRO),
3252:     .RESVAL  (1'h0),
3253:     .Mubi    (1'b0)
3254:   ) u_err_code_fifo_write_err (
3255:     .clk_i   (clk_i),
3256:     .rst_ni  (rst_ni),
3257: 
3258:     // from register interface
3259:     .we     (1'b0),
3260:     .wd     ('0),
3261: 
3262:     // from internal hardware
3263:     .de     (hw2reg.err_code.fifo_write_err.de),
3264:     .d      (hw2reg.err_code.fifo_write_err.d),
3265: 
3266:     // to internal hardware
3267:     .qe     (),
3268:     .q      (),
3269:     .ds     (),
3270: 
3271:     // to register interface (read)
3272:     .qs     (err_code_fifo_write_err_qs)
3273:   );
3274: 
3275:   //   F[fifo_read_err]: 29:29
3276:   prim_subreg #(
3277:     .DW      (1),
3278:     .SwAccess(prim_subreg_pkg::SwAccessRO),
3279:     .RESVAL  (1'h0),
3280:     .Mubi    (1'b0)
3281:   ) u_err_code_fifo_read_err (
3282:     .clk_i   (clk_i),
3283:     .rst_ni  (rst_ni),
3284: 
3285:     // from register interface
3286:     .we     (1'b0),
3287:     .wd     ('0),
3288: 
3289:     // from internal hardware
3290:     .de     (hw2reg.err_code.fifo_read_err.de),
3291:     .d      (hw2reg.err_code.fifo_read_err.d),
3292: 
3293:     // to internal hardware
3294:     .qe     (),
3295:     .q      (),
3296:     .ds     (),
3297: 
3298:     // to register interface (read)
3299:     .qs     (err_code_fifo_read_err_qs)
3300:   );
3301: 
3302:   //   F[fifo_state_err]: 30:30
3303:   prim_subreg #(
3304:     .DW      (1),
3305:     .SwAccess(prim_subreg_pkg::SwAccessRO),
3306:     .RESVAL  (1'h0),
3307:     .Mubi    (1'b0)
3308:   ) u_err_code_fifo_state_err (
3309:     .clk_i   (clk_i),
3310:     .rst_ni  (rst_ni),
3311: 
3312:     // from register interface
3313:     .we     (1'b0),
3314:     .wd     ('0),
3315: 
3316:     // from internal hardware
3317:     .de     (hw2reg.err_code.fifo_state_err.de),
3318:     .d      (hw2reg.err_code.fifo_state_err.d),
3319: 
3320:     // to internal hardware
3321:     .qe     (),
3322:     .q      (),
3323:     .ds     (),
3324: 
3325:     // to register interface (read)
3326:     .qs     (err_code_fifo_state_err_qs)
3327:   );
3328: 
3329: 
3330:   // R[err_code_test]: V(False)
3331:   logic err_code_test_qe;
3332:   logic [0:0] err_code_test_flds_we;
3333:   prim_flop #(
3334:     .Width(1),
3335:     .ResetValue(0)
3336:   ) u_err_code_test0_qe (
3337:     .clk_i(clk_i),
3338:     .rst_ni(rst_ni),
3339:     .d_i(&err_code_test_flds_we),
3340:     .q_o(err_code_test_qe)
3341:   );
3342:   prim_subreg #(
3343:     .DW      (5),
3344:     .SwAccess(prim_subreg_pkg::SwAccessRW),
3345:     .RESVAL  (5'h0),
3346:     .Mubi    (1'b0)
3347:   ) u_err_code_test (
3348:     .clk_i   (clk_i),
3349:     .rst_ni  (rst_ni),
3350: 
3351:     // from register interface
3352:     .we     (err_code_test_we),
3353:     .wd     (err_code_test_wd),
3354: 
3355:     // from internal hardware
3356:     .de     (1'b0),
3357:     .d      ('0),
3358: 
3359:     // to internal hardware
3360:     .qe     (err_code_test_flds_we[0]),
3361:     .q      (reg2hw.err_code_test.q),
3362:     .ds     (),
3363: 
3364:     // to register interface (read)
3365:     .qs     (err_code_test_qs)
3366:   );
3367:   assign reg2hw.err_code_test.qe = err_code_test_qe;
3368: 
3369: 
3370:   // R[main_sm_state]: V(False)
3371:   prim_subreg #(
3372:     .DW      (9),
3373:     .SwAccess(prim_subreg_pkg::SwAccessRO),
3374:     .RESVAL  (9'hf5),
3375:     .Mubi    (1'b0)
3376:   ) u_main_sm_state (
3377:     .clk_i   (clk_i),
3378:     .rst_ni  (rst_ni),
3379: 
3380:     // from register interface
3381:     .we     (1'b0),
3382:     .wd     ('0),
3383: 
3384:     // from internal hardware
3385:     .de     (hw2reg.main_sm_state.de),
3386:     .d      (hw2reg.main_sm_state.d),
3387: 
3388:     // to internal hardware
3389:     .qe     (),
3390:     .q      (),
3391:     .ds     (),
3392: 
3393:     // to register interface (read)
3394:     .qs     (main_sm_state_qs)
3395:   );
3396: 
3397: 
3398: 
3399:   logic [56:0] addr_hit;
3400:   always_comb begin
3401:     addr_hit[ 0] = (reg_addr == ENTROPY_SRC_INTR_STATE_OFFSET);
3402:     addr_hit[ 1] = (reg_addr == ENTROPY_SRC_INTR_ENABLE_OFFSET);
3403:     addr_hit[ 2] = (reg_addr == ENTROPY_SRC_INTR_TEST_OFFSET);
3404:     addr_hit[ 3] = (reg_addr == ENTROPY_SRC_ALERT_TEST_OFFSET);
3405:     addr_hit[ 4] = (reg_addr == ENTROPY_SRC_ME_REGWEN_OFFSET);
3406:     addr_hit[ 5] = (reg_addr == ENTROPY_SRC_SW_REGUPD_OFFSET);
3407:     addr_hit[ 6] = (reg_addr == ENTROPY_SRC_REGWEN_OFFSET);
3408:     addr_hit[ 7] = (reg_addr == ENTROPY_SRC_REV_OFFSET);
3409:     addr_hit[ 8] = (reg_addr == ENTROPY_SRC_MODULE_ENABLE_OFFSET);
3410:     addr_hit[ 9] = (reg_addr == ENTROPY_SRC_CONF_OFFSET);
3411:     addr_hit[10] = (reg_addr == ENTROPY_SRC_ENTROPY_CONTROL_OFFSET);
3412:     addr_hit[11] = (reg_addr == ENTROPY_SRC_ENTROPY_DATA_OFFSET);
3413:     addr_hit[12] = (reg_addr == ENTROPY_SRC_HEALTH_TEST_WINDOWS_OFFSET);
3414:     addr_hit[13] = (reg_addr == ENTROPY_SRC_REPCNT_THRESHOLDS_OFFSET);
3415:     addr_hit[14] = (reg_addr == ENTROPY_SRC_REPCNTS_THRESHOLDS_OFFSET);
3416:     addr_hit[15] = (reg_addr == ENTROPY_SRC_ADAPTP_HI_THRESHOLDS_OFFSET);
3417:     addr_hit[16] = (reg_addr == ENTROPY_SRC_ADAPTP_LO_THRESHOLDS_OFFSET);
3418:     addr_hit[17] = (reg_addr == ENTROPY_SRC_BUCKET_THRESHOLDS_OFFSET);
3419:     addr_hit[18] = (reg_addr == ENTROPY_SRC_MARKOV_HI_THRESHOLDS_OFFSET);
3420:     addr_hit[19] = (reg_addr == ENTROPY_SRC_MARKOV_LO_THRESHOLDS_OFFSET);
3421:     addr_hit[20] = (reg_addr == ENTROPY_SRC_EXTHT_HI_THRESHOLDS_OFFSET);
3422:     addr_hit[21] = (reg_addr == ENTROPY_SRC_EXTHT_LO_THRESHOLDS_OFFSET);
3423:     addr_hit[22] = (reg_addr == ENTROPY_SRC_REPCNT_HI_WATERMARKS_OFFSET);
3424:     addr_hit[23] = (reg_addr == ENTROPY_SRC_REPCNTS_HI_WATERMARKS_OFFSET);
3425:     addr_hit[24] = (reg_addr == ENTROPY_SRC_ADAPTP_HI_WATERMARKS_OFFSET);
3426:     addr_hit[25] = (reg_addr == ENTROPY_SRC_ADAPTP_LO_WATERMARKS_OFFSET);
3427:     addr_hit[26] = (reg_addr == ENTROPY_SRC_EXTHT_HI_WATERMARKS_OFFSET);
3428:     addr_hit[27] = (reg_addr == ENTROPY_SRC_EXTHT_LO_WATERMARKS_OFFSET);
3429:     addr_hit[28] = (reg_addr == ENTROPY_SRC_BUCKET_HI_WATERMARKS_OFFSET);
3430:     addr_hit[29] = (reg_addr == ENTROPY_SRC_MARKOV_HI_WATERMARKS_OFFSET);
3431:     addr_hit[30] = (reg_addr == ENTROPY_SRC_MARKOV_LO_WATERMARKS_OFFSET);
3432:     addr_hit[31] = (reg_addr == ENTROPY_SRC_REPCNT_TOTAL_FAILS_OFFSET);
3433:     addr_hit[32] = (reg_addr == ENTROPY_SRC_REPCNTS_TOTAL_FAILS_OFFSET);
3434:     addr_hit[33] = (reg_addr == ENTROPY_SRC_ADAPTP_HI_TOTAL_FAILS_OFFSET);
3435:     addr_hit[34] = (reg_addr == ENTROPY_SRC_ADAPTP_LO_TOTAL_FAILS_OFFSET);
3436:     addr_hit[35] = (reg_addr == ENTROPY_SRC_BUCKET_TOTAL_FAILS_OFFSET);
3437:     addr_hit[36] = (reg_addr == ENTROPY_SRC_MARKOV_HI_TOTAL_FAILS_OFFSET);
3438:     addr_hit[37] = (reg_addr == ENTROPY_SRC_MARKOV_LO_TOTAL_FAILS_OFFSET);
3439:     addr_hit[38] = (reg_addr == ENTROPY_SRC_EXTHT_HI_TOTAL_FAILS_OFFSET);
3440:     addr_hit[39] = (reg_addr == ENTROPY_SRC_EXTHT_LO_TOTAL_FAILS_OFFSET);
3441:     addr_hit[40] = (reg_addr == ENTROPY_SRC_ALERT_THRESHOLD_OFFSET);
3442:     addr_hit[41] = (reg_addr == ENTROPY_SRC_ALERT_SUMMARY_FAIL_COUNTS_OFFSET);
3443:     addr_hit[42] = (reg_addr == ENTROPY_SRC_ALERT_FAIL_COUNTS_OFFSET);
3444:     addr_hit[43] = (reg_addr == ENTROPY_SRC_EXTHT_FAIL_COUNTS_OFFSET);
3445:     addr_hit[44] = (reg_addr == ENTROPY_SRC_FW_OV_CONTROL_OFFSET);
3446:     addr_hit[45] = (reg_addr == ENTROPY_SRC_FW_OV_SHA3_START_OFFSET);
3447:     addr_hit[46] = (reg_addr == ENTROPY_SRC_FW_OV_WR_FIFO_FULL_OFFSET);
3448:     addr_hit[47] = (reg_addr == ENTROPY_SRC_FW_OV_RD_FIFO_OVERFLOW_OFFSET);
3449:     addr_hit[48] = (reg_addr == ENTROPY_SRC_FW_OV_RD_DATA_OFFSET);
3450:     addr_hit[49] = (reg_addr == ENTROPY_SRC_FW_OV_WR_DATA_OFFSET);
3451:     addr_hit[50] = (reg_addr == ENTROPY_SRC_OBSERVE_FIFO_THRESH_OFFSET);
3452:     addr_hit[51] = (reg_addr == ENTROPY_SRC_OBSERVE_FIFO_DEPTH_OFFSET);
3453:     addr_hit[52] = (reg_addr == ENTROPY_SRC_DEBUG_STATUS_OFFSET);
3454:     addr_hit[53] = (reg_addr == ENTROPY_SRC_RECOV_ALERT_STS_OFFSET);
3455:     addr_hit[54] = (reg_addr == ENTROPY_SRC_ERR_CODE_OFFSET);
3456:     addr_hit[55] = (reg_addr == ENTROPY_SRC_ERR_CODE_TEST_OFFSET);
3457:     addr_hit[56] = (reg_addr == ENTROPY_SRC_MAIN_SM_STATE_OFFSET);
3458:   end
3459: 
3460:   assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;
3461: 
3462:   // Check sub-word write is permitted
3463:   always_comb begin
3464:     wr_err = (reg_we &
3465:               ((addr_hit[ 0] & (|(ENTROPY_SRC_PERMIT[ 0] & ~reg_be))) |
3466:                (addr_hit[ 1] & (|(ENTROPY_SRC_PERMIT[ 1] & ~reg_be))) |
3467:                (addr_hit[ 2] & (|(ENTROPY_SRC_PERMIT[ 2] & ~reg_be))) |
3468:                (addr_hit[ 3] & (|(ENTROPY_SRC_PERMIT[ 3] & ~reg_be))) |
3469:                (addr_hit[ 4] & (|(ENTROPY_SRC_PERMIT[ 4] & ~reg_be))) |
3470:                (addr_hit[ 5] & (|(ENTROPY_SRC_PERMIT[ 5] & ~reg_be))) |
3471:                (addr_hit[ 6] & (|(ENTROPY_SRC_PERMIT[ 6] & ~reg_be))) |
3472:                (addr_hit[ 7] & (|(ENTROPY_SRC_PERMIT[ 7] & ~reg_be))) |
3473:                (addr_hit[ 8] & (|(ENTROPY_SRC_PERMIT[ 8] & ~reg_be))) |
3474:                (addr_hit[ 9] & (|(ENTROPY_SRC_PERMIT[ 9] & ~reg_be))) |
3475:                (addr_hit[10] & (|(ENTROPY_SRC_PERMIT[10] & ~reg_be))) |
3476:                (addr_hit[11] & (|(ENTROPY_SRC_PERMIT[11] & ~reg_be))) |
3477:                (addr_hit[12] & (|(ENTROPY_SRC_PERMIT[12] & ~reg_be))) |
3478:                (addr_hit[13] & (|(ENTROPY_SRC_PERMIT[13] & ~reg_be))) |
3479:                (addr_hit[14] & (|(ENTROPY_SRC_PERMIT[14] & ~reg_be))) |
3480:                (addr_hit[15] & (|(ENTROPY_SRC_PERMIT[15] & ~reg_be))) |
3481:                (addr_hit[16] & (|(ENTROPY_SRC_PERMIT[16] & ~reg_be))) |
3482:                (addr_hit[17] & (|(ENTROPY_SRC_PERMIT[17] & ~reg_be))) |
3483:                (addr_hit[18] & (|(ENTROPY_SRC_PERMIT[18] & ~reg_be))) |
3484:                (addr_hit[19] & (|(ENTROPY_SRC_PERMIT[19] & ~reg_be))) |
3485:                (addr_hit[20] & (|(ENTROPY_SRC_PERMIT[20] & ~reg_be))) |
3486:                (addr_hit[21] & (|(ENTROPY_SRC_PERMIT[21] & ~reg_be))) |
3487:                (addr_hit[22] & (|(ENTROPY_SRC_PERMIT[22] & ~reg_be))) |
3488:                (addr_hit[23] & (|(ENTROPY_SRC_PERMIT[23] & ~reg_be))) |
3489:                (addr_hit[24] & (|(ENTROPY_SRC_PERMIT[24] & ~reg_be))) |
3490:                (addr_hit[25] & (|(ENTROPY_SRC_PERMIT[25] & ~reg_be))) |
3491:                (addr_hit[26] & (|(ENTROPY_SRC_PERMIT[26] & ~reg_be))) |
3492:                (addr_hit[27] & (|(ENTROPY_SRC_PERMIT[27] & ~reg_be))) |
3493:                (addr_hit[28] & (|(ENTROPY_SRC_PERMIT[28] & ~reg_be))) |
3494:                (addr_hit[29] & (|(ENTROPY_SRC_PERMIT[29] & ~reg_be))) |
3495:                (addr_hit[30] & (|(ENTROPY_SRC_PERMIT[30] & ~reg_be))) |
3496:                (addr_hit[31] & (|(ENTROPY_SRC_PERMIT[31] & ~reg_be))) |
3497:                (addr_hit[32] & (|(ENTROPY_SRC_PERMIT[32] & ~reg_be))) |
3498:                (addr_hit[33] & (|(ENTROPY_SRC_PERMIT[33] & ~reg_be))) |
3499:                (addr_hit[34] & (|(ENTROPY_SRC_PERMIT[34] & ~reg_be))) |
3500:                (addr_hit[35] & (|(ENTROPY_SRC_PERMIT[35] & ~reg_be))) |
3501:                (addr_hit[36] & (|(ENTROPY_SRC_PERMIT[36] & ~reg_be))) |
3502:                (addr_hit[37] & (|(ENTROPY_SRC_PERMIT[37] & ~reg_be))) |
3503:                (addr_hit[38] & (|(ENTROPY_SRC_PERMIT[38] & ~reg_be))) |
3504:                (addr_hit[39] & (|(ENTROPY_SRC_PERMIT[39] & ~reg_be))) |
3505:                (addr_hit[40] & (|(ENTROPY_SRC_PERMIT[40] & ~reg_be))) |
3506:                (addr_hit[41] & (|(ENTROPY_SRC_PERMIT[41] & ~reg_be))) |
3507:                (addr_hit[42] & (|(ENTROPY_SRC_PERMIT[42] & ~reg_be))) |
3508:                (addr_hit[43] & (|(ENTROPY_SRC_PERMIT[43] & ~reg_be))) |
3509:                (addr_hit[44] & (|(ENTROPY_SRC_PERMIT[44] & ~reg_be))) |
3510:                (addr_hit[45] & (|(ENTROPY_SRC_PERMIT[45] & ~reg_be))) |
3511:                (addr_hit[46] & (|(ENTROPY_SRC_PERMIT[46] & ~reg_be))) |
3512:                (addr_hit[47] & (|(ENTROPY_SRC_PERMIT[47] & ~reg_be))) |
3513:                (addr_hit[48] & (|(ENTROPY_SRC_PERMIT[48] & ~reg_be))) |
3514:                (addr_hit[49] & (|(ENTROPY_SRC_PERMIT[49] & ~reg_be))) |
3515:                (addr_hit[50] & (|(ENTROPY_SRC_PERMIT[50] & ~reg_be))) |
3516:                (addr_hit[51] & (|(ENTROPY_SRC_PERMIT[51] & ~reg_be))) |
3517:                (addr_hit[52] & (|(ENTROPY_SRC_PERMIT[52] & ~reg_be))) |
3518:                (addr_hit[53] & (|(ENTROPY_SRC_PERMIT[53] & ~reg_be))) |
3519:                (addr_hit[54] & (|(ENTROPY_SRC_PERMIT[54] & ~reg_be))) |
3520:                (addr_hit[55] & (|(ENTROPY_SRC_PERMIT[55] & ~reg_be))) |
3521:                (addr_hit[56] & (|(ENTROPY_SRC_PERMIT[56] & ~reg_be)))));
3522:   end
3523: 
3524:   // Generate write-enables
3525:   assign intr_state_we = addr_hit[0] & reg_we & !reg_error;
3526: 
3527:   assign intr_state_es_entropy_valid_wd = reg_wdata[0];
3528: 
3529:   assign intr_state_es_health_test_failed_wd = reg_wdata[1];
3530: 
3531:   assign intr_state_es_observe_fifo_ready_wd = reg_wdata[2];
3532: 
3533:   assign intr_state_es_fatal_err_wd = reg_wdata[3];
3534:   assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;
3535: 
3536:   assign intr_enable_es_entropy_valid_wd = reg_wdata[0];
3537: 
3538:   assign intr_enable_es_health_test_failed_wd = reg_wdata[1];
3539: 
3540:   assign intr_enable_es_observe_fifo_ready_wd = reg_wdata[2];
3541: 
3542:   assign intr_enable_es_fatal_err_wd = reg_wdata[3];
3543:   assign intr_test_we = addr_hit[2] & reg_we & !reg_error;
3544: 
3545:   assign intr_test_es_entropy_valid_wd = reg_wdata[0];
3546: 
3547:   assign intr_test_es_health_test_failed_wd = reg_wdata[1];
3548: 
3549:   assign intr_test_es_observe_fifo_ready_wd = reg_wdata[2];
3550: 
3551:   assign intr_test_es_fatal_err_wd = reg_wdata[3];
3552:   assign alert_test_we = addr_hit[3] & reg_we & !reg_error;
3553: 
3554:   assign alert_test_recov_alert_wd = reg_wdata[0];
3555: 
3556:   assign alert_test_fatal_alert_wd = reg_wdata[1];
3557:   assign me_regwen_we = addr_hit[4] & reg_we & !reg_error;
3558: 
3559:   assign me_regwen_wd = reg_wdata[0];
3560:   assign sw_regupd_we = addr_hit[5] & reg_we & !reg_error;
3561: 
3562:   assign sw_regupd_wd = reg_wdata[0];
3563:   assign module_enable_we = addr_hit[8] & reg_we & !reg_error;
3564: 
3565:   assign module_enable_wd = reg_wdata[3:0];
3566:   assign conf_we = addr_hit[9] & reg_we & !reg_error;
3567: 
3568:   assign conf_fips_enable_wd = reg_wdata[3:0];
3569: 
3570:   assign conf_fips_flag_wd = reg_wdata[7:4];
3571: 
3572:   assign conf_rng_fips_wd = reg_wdata[11:8];
3573: 
3574:   assign conf_rng_bit_enable_wd = reg_wdata[15:12];
3575: 
3576:   assign conf_rng_bit_sel_wd = reg_wdata[17:16];
3577: 
3578:   assign conf_threshold_scope_wd = reg_wdata[21:18];
3579: 
3580:   assign conf_entropy_data_reg_enable_wd = reg_wdata[25:22];
3581:   assign entropy_control_we = addr_hit[10] & reg_we & !reg_error;
3582: 
3583:   assign entropy_control_es_route_wd = reg_wdata[3:0];
3584: 
3585:   assign entropy_control_es_type_wd = reg_wdata[7:4];
3586:   assign entropy_data_re = addr_hit[11] & reg_re & !reg_error;
3587:   assign health_test_windows_we = addr_hit[12] & reg_we & !reg_error;
3588: 
3589:   assign health_test_windows_fips_window_wd = reg_wdata[15:0];
3590: 
3591:   assign health_test_windows_bypass_window_wd = reg_wdata[31:16];
3592:   assign repcnt_thresholds_re = addr_hit[13] & reg_re & !reg_error;
3593:   assign repcnt_thresholds_we = addr_hit[13] & reg_we & !reg_error;
3594: 
3595:   assign repcnt_thresholds_fips_thresh_wd = reg_wdata[15:0];
3596: 
3597:   assign repcnt_thresholds_bypass_thresh_wd = reg_wdata[31:16];
3598:   assign repcnts_thresholds_re = addr_hit[14] & reg_re & !reg_error;
3599:   assign repcnts_thresholds_we = addr_hit[14] & reg_we & !reg_error;
3600: 
3601:   assign repcnts_thresholds_fips_thresh_wd = reg_wdata[15:0];
3602: 
3603:   assign repcnts_thresholds_bypass_thresh_wd = reg_wdata[31:16];
3604:   assign adaptp_hi_thresholds_re = addr_hit[15] & reg_re & !reg_error;
3605:   assign adaptp_hi_thresholds_we = addr_hit[15] & reg_we & !reg_error;
3606: 
3607:   assign adaptp_hi_thresholds_fips_thresh_wd = reg_wdata[15:0];
3608: 
3609:   assign adaptp_hi_thresholds_bypass_thresh_wd = reg_wdata[31:16];
3610:   assign adaptp_lo_thresholds_re = addr_hit[16] & reg_re & !reg_error;
3611:   assign adaptp_lo_thresholds_we = addr_hit[16] & reg_we & !reg_error;
3612: 
3613:   assign adaptp_lo_thresholds_fips_thresh_wd = reg_wdata[15:0];
3614: 
3615:   assign adaptp_lo_thresholds_bypass_thresh_wd = reg_wdata[31:16];
3616:   assign bucket_thresholds_re = addr_hit[17] & reg_re & !reg_error;
3617:   assign bucket_thresholds_we = addr_hit[17] & reg_we & !reg_error;
3618: 
3619:   assign bucket_thresholds_fips_thresh_wd = reg_wdata[15:0];
3620: 
3621:   assign bucket_thresholds_bypass_thresh_wd = reg_wdata[31:16];
3622:   assign markov_hi_thresholds_re = addr_hit[18] & reg_re & !reg_error;
3623:   assign markov_hi_thresholds_we = addr_hit[18] & reg_we & !reg_error;
3624: 
3625:   assign markov_hi_thresholds_fips_thresh_wd = reg_wdata[15:0];
3626: 
3627:   assign markov_hi_thresholds_bypass_thresh_wd = reg_wdata[31:16];
3628:   assign markov_lo_thresholds_re = addr_hit[19] & reg_re & !reg_error;
3629:   assign markov_lo_thresholds_we = addr_hit[19] & reg_we & !reg_error;
3630: 
3631:   assign markov_lo_thresholds_fips_thresh_wd = reg_wdata[15:0];
3632: 
3633:   assign markov_lo_thresholds_bypass_thresh_wd = reg_wdata[31:16];
3634:   assign extht_hi_thresholds_re = addr_hit[20] & reg_re & !reg_error;
3635:   assign extht_hi_thresholds_we = addr_hit[20] & reg_we & !reg_error;
3636: 
3637:   assign extht_hi_thresholds_fips_thresh_wd = reg_wdata[15:0];
3638: 
3639:   assign extht_hi_thresholds_bypass_thresh_wd = reg_wdata[31:16];
3640:   assign extht_lo_thresholds_re = addr_hit[21] & reg_re & !reg_error;
3641:   assign extht_lo_thresholds_we = addr_hit[21] & reg_we & !reg_error;
3642: 
3643:   assign extht_lo_thresholds_fips_thresh_wd = reg_wdata[15:0];
3644: 
3645:   assign extht_lo_thresholds_bypass_thresh_wd = reg_wdata[31:16];
3646:   assign repcnt_hi_watermarks_re = addr_hit[22] & reg_re & !reg_error;
3647:   assign repcnts_hi_watermarks_re = addr_hit[23] & reg_re & !reg_error;
3648:   assign adaptp_hi_watermarks_re = addr_hit[24] & reg_re & !reg_error;
3649:   assign adaptp_lo_watermarks_re = addr_hit[25] & reg_re & !reg_error;
3650:   assign extht_hi_watermarks_re = addr_hit[26] & reg_re & !reg_error;
3651:   assign extht_lo_watermarks_re = addr_hit[27] & reg_re & !reg_error;
3652:   assign bucket_hi_watermarks_re = addr_hit[28] & reg_re & !reg_error;
3653:   assign markov_hi_watermarks_re = addr_hit[29] & reg_re & !reg_error;
3654:   assign markov_lo_watermarks_re = addr_hit[30] & reg_re & !reg_error;
3655:   assign repcnt_total_fails_re = addr_hit[31] & reg_re & !reg_error;
3656:   assign repcnts_total_fails_re = addr_hit[32] & reg_re & !reg_error;
3657:   assign adaptp_hi_total_fails_re = addr_hit[33] & reg_re & !reg_error;
3658:   assign adaptp_lo_total_fails_re = addr_hit[34] & reg_re & !reg_error;
3659:   assign bucket_total_fails_re = addr_hit[35] & reg_re & !reg_error;
3660:   assign markov_hi_total_fails_re = addr_hit[36] & reg_re & !reg_error;
3661:   assign markov_lo_total_fails_re = addr_hit[37] & reg_re & !reg_error;
3662:   assign extht_hi_total_fails_re = addr_hit[38] & reg_re & !reg_error;
3663:   assign extht_lo_total_fails_re = addr_hit[39] & reg_re & !reg_error;
3664:   assign alert_threshold_we = addr_hit[40] & reg_we & !reg_error;
3665: 
3666:   assign alert_threshold_alert_threshold_wd = reg_wdata[15:0];
3667: 
3668:   assign alert_threshold_alert_threshold_inv_wd = reg_wdata[31:16];
3669:   assign alert_summary_fail_counts_re = addr_hit[41] & reg_re & !reg_error;
3670:   assign alert_fail_counts_re = addr_hit[42] & reg_re & !reg_error;
3671:   assign extht_fail_counts_re = addr_hit[43] & reg_re & !reg_error;
3672:   assign fw_ov_control_we = addr_hit[44] & reg_we & !reg_error;
3673: 
3674:   assign fw_ov_control_fw_ov_mode_wd = reg_wdata[3:0];
3675: 
3676:   assign fw_ov_control_fw_ov_entropy_insert_wd = reg_wdata[7:4];
3677:   assign fw_ov_sha3_start_we = addr_hit[45] & reg_we & !reg_error;
3678: 
3679:   assign fw_ov_sha3_start_wd = reg_wdata[3:0];
3680:   assign fw_ov_wr_fifo_full_re = addr_hit[46] & reg_re & !reg_error;
3681:   assign fw_ov_rd_data_re = addr_hit[48] & reg_re & !reg_error;
3682:   assign fw_ov_wr_data_we = addr_hit[49] & reg_we & !reg_error;
3683: 
3684:   assign fw_ov_wr_data_wd = reg_wdata[31:0];
3685:   assign observe_fifo_thresh_we = addr_hit[50] & reg_we & !reg_error;
3686: 
3687:   assign observe_fifo_thresh_wd = reg_wdata[5:0];
3688:   assign observe_fifo_depth_re = addr_hit[51] & reg_re & !reg_error;
3689:   assign debug_status_re = addr_hit[52] & reg_re & !reg_error;
3690:   assign recov_alert_sts_we = addr_hit[53] & reg_we & !reg_error;
3691: 
3692:   assign recov_alert_sts_fips_enable_field_alert_wd = reg_wdata[0];
3693: 
3694:   assign recov_alert_sts_entropy_data_reg_en_field_alert_wd = reg_wdata[1];
3695: 
3696:   assign recov_alert_sts_module_enable_field_alert_wd = reg_wdata[2];
3697: 
3698:   assign recov_alert_sts_threshold_scope_field_alert_wd = reg_wdata[3];
3699: 
3700:   assign recov_alert_sts_rng_bit_enable_field_alert_wd = reg_wdata[5];
3701: 
3702:   assign recov_alert_sts_fw_ov_sha3_start_field_alert_wd = reg_wdata[7];
3703: 
3704:   assign recov_alert_sts_fw_ov_mode_field_alert_wd = reg_wdata[8];
3705: 
3706:   assign recov_alert_sts_fw_ov_entropy_insert_field_alert_wd = reg_wdata[9];
3707: 
3708:   assign recov_alert_sts_es_route_field_alert_wd = reg_wdata[10];
3709: 
3710:   assign recov_alert_sts_es_type_field_alert_wd = reg_wdata[11];
3711: 
3712:   assign recov_alert_sts_es_main_sm_alert_wd = reg_wdata[12];
3713: 
3714:   assign recov_alert_sts_es_bus_cmp_alert_wd = reg_wdata[13];
3715: 
3716:   assign recov_alert_sts_es_thresh_cfg_alert_wd = reg_wdata[14];
3717: 
3718:   assign recov_alert_sts_es_fw_ov_wr_alert_wd = reg_wdata[15];
3719: 
3720:   assign recov_alert_sts_es_fw_ov_disable_alert_wd = reg_wdata[16];
3721: 
3722:   assign recov_alert_sts_fips_flag_field_alert_wd = reg_wdata[17];
3723: 
3724:   assign recov_alert_sts_rng_fips_field_alert_wd = reg_wdata[18];
3725: 
3726:   assign recov_alert_sts_postht_entropy_drop_alert_wd = reg_wdata[31];
3727:   assign err_code_test_we = addr_hit[55] & reg_we & !reg_error;
3728: 
3729:   assign err_code_test_wd = reg_wdata[4:0];
3730: 
3731:   // Assign write-enables to checker logic vector.
3732:   always_comb begin
3733:     reg_we_check[0] = intr_state_we;
3734:     reg_we_check[1] = intr_enable_we;
3735:     reg_we_check[2] = intr_test_we;
3736:     reg_we_check[3] = alert_test_we;
3737:     reg_we_check[4] = me_regwen_we;
3738:     reg_we_check[5] = sw_regupd_we;
3739:     reg_we_check[6] = 1'b0;
3740:     reg_we_check[7] = 1'b0;
3741:     reg_we_check[8] = module_enable_gated_we;
3742:     reg_we_check[9] = conf_gated_we;
3743:     reg_we_check[10] = entropy_control_gated_we;
3744:     reg_we_check[11] = 1'b0;
3745:     reg_we_check[12] = health_test_windows_gated_we;
3746:     reg_we_check[13] = repcnt_thresholds_gated_we;
3747:     reg_we_check[14] = repcnts_thresholds_gated_we;
3748:     reg_we_check[15] = adaptp_hi_thresholds_gated_we;
3749:     reg_we_check[16] = adaptp_lo_thresholds_gated_we;
3750:     reg_we_check[17] = bucket_thresholds_gated_we;
3751:     reg_we_check[18] = markov_hi_thresholds_gated_we;
3752:     reg_we_check[19] = markov_lo_thresholds_gated_we;
3753:     reg_we_check[20] = extht_hi_thresholds_gated_we;
3754:     reg_we_check[21] = extht_lo_thresholds_gated_we;
3755:     reg_we_check[22] = 1'b0;
3756:     reg_we_check[23] = 1'b0;
3757:     reg_we_check[24] = 1'b0;
3758:     reg_we_check[25] = 1'b0;
3759:     reg_we_check[26] = 1'b0;
3760:     reg_we_check[27] = 1'b0;
3761:     reg_we_check[28] = 1'b0;
3762:     reg_we_check[29] = 1'b0;
3763:     reg_we_check[30] = 1'b0;
3764:     reg_we_check[31] = 1'b0;
3765:     reg_we_check[32] = 1'b0;
3766:     reg_we_check[33] = 1'b0;
3767:     reg_we_check[34] = 1'b0;
3768:     reg_we_check[35] = 1'b0;
3769:     reg_we_check[36] = 1'b0;
3770:     reg_we_check[37] = 1'b0;
3771:     reg_we_check[38] = 1'b0;
3772:     reg_we_check[39] = 1'b0;
3773:     reg_we_check[40] = alert_threshold_gated_we;
3774:     reg_we_check[41] = 1'b0;
3775:     reg_we_check[42] = 1'b0;
3776:     reg_we_check[43] = 1'b0;
3777:     reg_we_check[44] = fw_ov_control_gated_we;
3778:     reg_we_check[45] = fw_ov_sha3_start_we;
3779:     reg_we_check[46] = 1'b0;
3780:     reg_we_check[47] = 1'b0;
3781:     reg_we_check[48] = 1'b0;
3782:     reg_we_check[49] = fw_ov_wr_data_we;
3783:     reg_we_check[50] = observe_fifo_thresh_gated_we;
3784:     reg_we_check[51] = 1'b0;
3785:     reg_we_check[52] = 1'b0;
3786:     reg_we_check[53] = recov_alert_sts_we;
3787:     reg_we_check[54] = 1'b0;
3788:     reg_we_check[55] = err_code_test_we;
3789:     reg_we_check[56] = 1'b0;
3790:   end
3791: 
3792:   // Read data return
3793:   always_comb begin
3794:     reg_rdata_next = '0;
3795:     unique case (1'b1)
3796:       addr_hit[0]: begin
3797:         reg_rdata_next[0] = intr_state_es_entropy_valid_qs;
3798:         reg_rdata_next[1] = intr_state_es_health_test_failed_qs;
3799:         reg_rdata_next[2] = intr_state_es_observe_fifo_ready_qs;
3800:         reg_rdata_next[3] = intr_state_es_fatal_err_qs;
3801:       end
3802: 
3803:       addr_hit[1]: begin
3804:         reg_rdata_next[0] = intr_enable_es_entropy_valid_qs;
3805:         reg_rdata_next[1] = intr_enable_es_health_test_failed_qs;
3806:         reg_rdata_next[2] = intr_enable_es_observe_fifo_ready_qs;
3807:         reg_rdata_next[3] = intr_enable_es_fatal_err_qs;
3808:       end
3809: 
3810:       addr_hit[2]: begin
3811:         reg_rdata_next[0] = '0;
3812:         reg_rdata_next[1] = '0;
3813:         reg_rdata_next[2] = '0;
3814:         reg_rdata_next[3] = '0;
3815:       end
3816: 
3817:       addr_hit[3]: begin
3818:         reg_rdata_next[0] = '0;
3819:         reg_rdata_next[1] = '0;
3820:       end
3821: 
3822:       addr_hit[4]: begin
3823:         reg_rdata_next[0] = me_regwen_qs;
3824:       end
3825: 
3826:       addr_hit[5]: begin
3827:         reg_rdata_next[0] = sw_regupd_qs;
3828:       end
3829: 
3830:       addr_hit[6]: begin
3831:         reg_rdata_next[0] = regwen_qs;
3832:       end
3833: 
3834:       addr_hit[7]: begin
3835:         reg_rdata_next[7:0] = rev_abi_revision_qs;
3836:         reg_rdata_next[15:8] = rev_hw_revision_qs;
3837:         reg_rdata_next[23:16] = rev_chip_type_qs;
3838:       end
3839: 
3840:       addr_hit[8]: begin
3841:         reg_rdata_next[3:0] = module_enable_qs;
3842:       end
3843: 
3844:       addr_hit[9]: begin
3845:         reg_rdata_next[3:0] = conf_fips_enable_qs;
3846:         reg_rdata_next[7:4] = conf_fips_flag_qs;
3847:         reg_rdata_next[11:8] = conf_rng_fips_qs;
3848:         reg_rdata_next[15:12] = conf_rng_bit_enable_qs;
3849:         reg_rdata_next[17:16] = conf_rng_bit_sel_qs;
3850:         reg_rdata_next[21:18] = conf_threshold_scope_qs;
3851:         reg_rdata_next[25:22] = conf_entropy_data_reg_enable_qs;
3852:       end
3853: 
3854:       addr_hit[10]: begin
3855:         reg_rdata_next[3:0] = entropy_control_es_route_qs;
3856:         reg_rdata_next[7:4] = entropy_control_es_type_qs;
3857:       end
3858: 
3859:       addr_hit[11]: begin
3860:         reg_rdata_next[31:0] = entropy_data_qs;
3861:       end
3862: 
3863:       addr_hit[12]: begin
3864:         reg_rdata_next[15:0] = health_test_windows_fips_window_qs;
3865:         reg_rdata_next[31:16] = health_test_windows_bypass_window_qs;
3866:       end
3867: 
3868:       addr_hit[13]: begin
3869:         reg_rdata_next[15:0] = repcnt_thresholds_fips_thresh_qs;
3870:         reg_rdata_next[31:16] = repcnt_thresholds_bypass_thresh_qs;
3871:       end
3872: 
3873:       addr_hit[14]: begin
3874:         reg_rdata_next[15:0] = repcnts_thresholds_fips_thresh_qs;
3875:         reg_rdata_next[31:16] = repcnts_thresholds_bypass_thresh_qs;
3876:       end
3877: 
3878:       addr_hit[15]: begin
3879:         reg_rdata_next[15:0] = adaptp_hi_thresholds_fips_thresh_qs;
3880:         reg_rdata_next[31:16] = adaptp_hi_thresholds_bypass_thresh_qs;
3881:       end
3882: 
3883:       addr_hit[16]: begin
3884:         reg_rdata_next[15:0] = adaptp_lo_thresholds_fips_thresh_qs;
3885:         reg_rdata_next[31:16] = adaptp_lo_thresholds_bypass_thresh_qs;
3886:       end
3887: 
3888:       addr_hit[17]: begin
3889:         reg_rdata_next[15:0] = bucket_thresholds_fips_thresh_qs;
3890:         reg_rdata_next[31:16] = bucket_thresholds_bypass_thresh_qs;
3891:       end
3892: 
3893:       addr_hit[18]: begin
3894:         reg_rdata_next[15:0] = markov_hi_thresholds_fips_thresh_qs;
3895:         reg_rdata_next[31:16] = markov_hi_thresholds_bypass_thresh_qs;
3896:       end
3897: 
3898:       addr_hit[19]: begin
3899:         reg_rdata_next[15:0] = markov_lo_thresholds_fips_thresh_qs;
3900:         reg_rdata_next[31:16] = markov_lo_thresholds_bypass_thresh_qs;
3901:       end
3902: 
3903:       addr_hit[20]: begin
3904:         reg_rdata_next[15:0] = extht_hi_thresholds_fips_thresh_qs;
3905:         reg_rdata_next[31:16] = extht_hi_thresholds_bypass_thresh_qs;
3906:       end
3907: 
3908:       addr_hit[21]: begin
3909:         reg_rdata_next[15:0] = extht_lo_thresholds_fips_thresh_qs;
3910:         reg_rdata_next[31:16] = extht_lo_thresholds_bypass_thresh_qs;
3911:       end
3912: 
3913:       addr_hit[22]: begin
3914:         reg_rdata_next[15:0] = repcnt_hi_watermarks_fips_watermark_qs;
3915:         reg_rdata_next[31:16] = repcnt_hi_watermarks_bypass_watermark_qs;
3916:       end
3917: 
3918:       addr_hit[23]: begin
3919:         reg_rdata_next[15:0] = repcnts_hi_watermarks_fips_watermark_qs;
3920:         reg_rdata_next[31:16] = repcnts_hi_watermarks_bypass_watermark_qs;
3921:       end
3922: 
3923:       addr_hit[24]: begin
3924:         reg_rdata_next[15:0] = adaptp_hi_watermarks_fips_watermark_qs;
3925:         reg_rdata_next[31:16] = adaptp_hi_watermarks_bypass_watermark_qs;
3926:       end
3927: 
3928:       addr_hit[25]: begin
3929:         reg_rdata_next[15:0] = adaptp_lo_watermarks_fips_watermark_qs;
3930:         reg_rdata_next[31:16] = adaptp_lo_watermarks_bypass_watermark_qs;
3931:       end
3932: 
3933:       addr_hit[26]: begin
3934:         reg_rdata_next[15:0] = extht_hi_watermarks_fips_watermark_qs;
3935:         reg_rdata_next[31:16] = extht_hi_watermarks_bypass_watermark_qs;
3936:       end
3937: 
3938:       addr_hit[27]: begin
3939:         reg_rdata_next[15:0] = extht_lo_watermarks_fips_watermark_qs;
3940:         reg_rdata_next[31:16] = extht_lo_watermarks_bypass_watermark_qs;
3941:       end
3942: 
3943:       addr_hit[28]: begin
3944:         reg_rdata_next[15:0] = bucket_hi_watermarks_fips_watermark_qs;
3945:         reg_rdata_next[31:16] = bucket_hi_watermarks_bypass_watermark_qs;
3946:       end
3947: 
3948:       addr_hit[29]: begin
3949:         reg_rdata_next[15:0] = markov_hi_watermarks_fips_watermark_qs;
3950:         reg_rdata_next[31:16] = markov_hi_watermarks_bypass_watermark_qs;
3951:       end
3952: 
3953:       addr_hit[30]: begin
3954:         reg_rdata_next[15:0] = markov_lo_watermarks_fips_watermark_qs;
3955:         reg_rdata_next[31:16] = markov_lo_watermarks_bypass_watermark_qs;
3956:       end
3957: 
3958:       addr_hit[31]: begin
3959:         reg_rdata_next[31:0] = repcnt_total_fails_qs;
3960:       end
3961: 
3962:       addr_hit[32]: begin
3963:         reg_rdata_next[31:0] = repcnts_total_fails_qs;
3964:       end
3965: 
3966:       addr_hit[33]: begin
3967:         reg_rdata_next[31:0] = adaptp_hi_total_fails_qs;
3968:       end
3969: 
3970:       addr_hit[34]: begin
3971:         reg_rdata_next[31:0] = adaptp_lo_total_fails_qs;
3972:       end
3973: 
3974:       addr_hit[35]: begin
3975:         reg_rdata_next[31:0] = bucket_total_fails_qs;
3976:       end
3977: 
3978:       addr_hit[36]: begin
3979:         reg_rdata_next[31:0] = markov_hi_total_fails_qs;
3980:       end
3981: 
3982:       addr_hit[37]: begin
3983:         reg_rdata_next[31:0] = markov_lo_total_fails_qs;
3984:       end
3985: 
3986:       addr_hit[38]: begin
3987:         reg_rdata_next[31:0] = extht_hi_total_fails_qs;
3988:       end
3989: 
3990:       addr_hit[39]: begin
3991:         reg_rdata_next[31:0] = extht_lo_total_fails_qs;
3992:       end
3993: 
3994:       addr_hit[40]: begin
3995:         reg_rdata_next[15:0] = alert_threshold_alert_threshold_qs;
3996:         reg_rdata_next[31:16] = alert_threshold_alert_threshold_inv_qs;
3997:       end
3998: 
3999:       addr_hit[41]: begin
4000:         reg_rdata_next[15:0] = alert_summary_fail_counts_qs;
4001:       end
4002: 
4003:       addr_hit[42]: begin
4004:         reg_rdata_next[7:4] = alert_fail_counts_repcnt_fail_count_qs;
4005:         reg_rdata_next[11:8] = alert_fail_counts_adaptp_hi_fail_count_qs;
4006:         reg_rdata_next[15:12] = alert_fail_counts_adaptp_lo_fail_count_qs;
4007:         reg_rdata_next[19:16] = alert_fail_counts_bucket_fail_count_qs;
4008:         reg_rdata_next[23:20] = alert_fail_counts_markov_hi_fail_count_qs;
4009:         reg_rdata_next[27:24] = alert_fail_counts_markov_lo_fail_count_qs;
4010:         reg_rdata_next[31:28] = alert_fail_counts_repcnts_fail_count_qs;
4011:       end
4012: 
4013:       addr_hit[43]: begin
4014:         reg_rdata_next[3:0] = extht_fail_counts_extht_hi_fail_count_qs;
4015:         reg_rdata_next[7:4] = extht_fail_counts_extht_lo_fail_count_qs;
4016:       end
4017: 
4018:       addr_hit[44]: begin
4019:         reg_rdata_next[3:0] = fw_ov_control_fw_ov_mode_qs;
4020:         reg_rdata_next[7:4] = fw_ov_control_fw_ov_entropy_insert_qs;
4021:       end
4022: 
4023:       addr_hit[45]: begin
4024:         reg_rdata_next[3:0] = fw_ov_sha3_start_qs;
4025:       end
4026: 
4027:       addr_hit[46]: begin
4028:         reg_rdata_next[0] = fw_ov_wr_fifo_full_qs;
4029:       end
4030: 
4031:       addr_hit[47]: begin
4032:         reg_rdata_next[0] = fw_ov_rd_fifo_overflow_qs;
4033:       end
4034: 
4035:       addr_hit[48]: begin
4036:         reg_rdata_next[31:0] = fw_ov_rd_data_qs;
4037:       end
4038: 
4039:       addr_hit[49]: begin
4040:         reg_rdata_next[31:0] = '0;
4041:       end
4042: 
4043:       addr_hit[50]: begin
4044:         reg_rdata_next[5:0] = observe_fifo_thresh_qs;
4045:       end
4046: 
4047:       addr_hit[51]: begin
4048:         reg_rdata_next[5:0] = observe_fifo_depth_qs;
4049:       end
4050: 
4051:       addr_hit[52]: begin
4052:         reg_rdata_next[1:0] = debug_status_entropy_fifo_depth_qs;
4053:         reg_rdata_next[5:3] = debug_status_sha3_fsm_qs;
4054:         reg_rdata_next[6] = debug_status_sha3_block_pr_qs;
4055:         reg_rdata_next[7] = debug_status_sha3_squeezing_qs;
4056:         reg_rdata_next[8] = debug_status_sha3_absorbed_qs;
4057:         reg_rdata_next[9] = debug_status_sha3_err_qs;
4058:         reg_rdata_next[16] = debug_status_main_sm_idle_qs;
4059:         reg_rdata_next[17] = debug_status_main_sm_boot_done_qs;
4060:       end
4061: 
4062:       addr_hit[53]: begin
4063:         reg_rdata_next[0] = recov_alert_sts_fips_enable_field_alert_qs;
4064:         reg_rdata_next[1] = recov_alert_sts_entropy_data_reg_en_field_alert_qs;
4065:         reg_rdata_next[2] = recov_alert_sts_module_enable_field_alert_qs;
4066:         reg_rdata_next[3] = recov_alert_sts_threshold_scope_field_alert_qs;
4067:         reg_rdata_next[5] = recov_alert_sts_rng_bit_enable_field_alert_qs;
4068:         reg_rdata_next[7] = recov_alert_sts_fw_ov_sha3_start_field_alert_qs;
4069:         reg_rdata_next[8] = recov_alert_sts_fw_ov_mode_field_alert_qs;
4070:         reg_rdata_next[9] = recov_alert_sts_fw_ov_entropy_insert_field_alert_qs;
4071:         reg_rdata_next[10] = recov_alert_sts_es_route_field_alert_qs;
4072:         reg_rdata_next[11] = recov_alert_sts_es_type_field_alert_qs;
4073:         reg_rdata_next[12] = recov_alert_sts_es_main_sm_alert_qs;
4074:         reg_rdata_next[13] = recov_alert_sts_es_bus_cmp_alert_qs;
4075:         reg_rdata_next[14] = recov_alert_sts_es_thresh_cfg_alert_qs;
4076:         reg_rdata_next[15] = recov_alert_sts_es_fw_ov_wr_alert_qs;
4077:         reg_rdata_next[16] = recov_alert_sts_es_fw_ov_disable_alert_qs;
4078:         reg_rdata_next[17] = recov_alert_sts_fips_flag_field_alert_qs;
4079:         reg_rdata_next[18] = recov_alert_sts_rng_fips_field_alert_qs;
4080:         reg_rdata_next[31] = recov_alert_sts_postht_entropy_drop_alert_qs;
4081:       end
4082: 
4083:       addr_hit[54]: begin
4084:         reg_rdata_next[0] = err_code_sfifo_esrng_err_qs;
4085:         reg_rdata_next[1] = err_code_sfifo_distr_err_qs;
4086:         reg_rdata_next[2] = err_code_sfifo_observe_err_qs;
4087:         reg_rdata_next[3] = err_code_sfifo_esfinal_err_qs;
4088:         reg_rdata_next[20] = err_code_es_ack_sm_err_qs;
4089:         reg_rdata_next[21] = err_code_es_main_sm_err_qs;
4090:         reg_rdata_next[22] = err_code_es_cntr_err_qs;
4091:         reg_rdata_next[23] = err_code_sha3_state_err_qs;
4092:         reg_rdata_next[24] = err_code_sha3_rst_storage_err_qs;
4093:         reg_rdata_next[28] = err_code_fifo_write_err_qs;
4094:         reg_rdata_next[29] = err_code_fifo_read_err_qs;
4095:         reg_rdata_next[30] = err_code_fifo_state_err_qs;
4096:       end
4097: 
4098:       addr_hit[55]: begin
4099:         reg_rdata_next[4:0] = err_code_test_qs;
4100:       end
4101: 
4102:       addr_hit[56]: begin
4103:         reg_rdata_next[8:0] = main_sm_state_qs;
4104:       end
4105: 
4106:       default: begin
4107:         reg_rdata_next = '1;
4108:       end
4109:     endcase
4110:   end
4111: 
4112:   // shadow busy
4113:   logic shadow_busy;
4114:   assign shadow_busy = 1'b0;
4115: 
4116:   // register busy
4117:   assign reg_busy = shadow_busy;
4118: 
4119:   // Unused signal tieoff
4120: 
4121:   // wdata / byte enable are not always fully used
4122:   // add a blanket unused statement to handle lint waivers
4123:   logic unused_wdata;
4124:   logic unused_be;
4125:   assign unused_wdata = ^reg_wdata;
4126:   assign unused_be = ^reg_be;
4127: 
4128:   // Assertions for Register Interface
4129:   `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
4130:   `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)
4131: 
4132:   `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)
4133: 
4134:   `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)
4135: 
4136:   // this is formulated as an assumption such that the FPV testbenches do disprove this
4137:   // property by mistake
4138:   //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)
4139: 
4140: endmodule

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_jqqAvQVfNHKfLgve9Bs23rJx)
 Call ID: call_jqqAvQVfNHKfLgve9Bs23rJx
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/entropy_src/rtl/entropy_src.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Description: entropy_src top level wrapper file
6: 
7: `include "prim_assert.sv"
8: 
9: 
10: module entropy_src
11:   import entropy_src_pkg::*;
12:   import entropy_src_reg_pkg::*;
13:   import prim_mubi_pkg::mubi8_t;
14: #(
15:   parameter bit Stub = 1'b0,
16:   parameter logic [NumAlerts-1:0] AlertAsyncOn = {NumAlerts{1'b1}},
17:   parameter int EsFifoDepth = 3,
18:   parameter int DistrFifoDepth = 2
19: ) (
20:   input logic clk_i,
21:   input logic rst_ni,
22: 
23:   // Bus Interface
24:   input  tlul_pkg::tl_h2d_t tl_i,
25:   output tlul_pkg::tl_d2h_t tl_o,
26: 
27:   // OTP Interface
28:   // SEC_CM: INTERSIG.MUBI
29:   input  mubi8_t otp_en_entropy_src_fw_read_i,
30:   // SEC_CM: INTERSIG.MUBI
31:   input  mubi8_t otp_en_entropy_src_fw_over_i,
32: 
33:   // RNG Interface
34:   output logic rng_fips_o,
35: 
36:   // Entropy Interface
37:   input  entropy_src_hw_if_req_t entropy_src_hw_if_i,
38:   output entropy_src_hw_if_rsp_t entropy_src_hw_if_o,
39: 
40:   // RNG Interface
41:   output entropy_src_rng_req_t entropy_src_rng_o,
42:   input  entropy_src_rng_rsp_t entropy_src_rng_i,
43: 
44:   // CSRNG Interface
45:   output cs_aes_halt_req_t cs_aes_halt_o,
46:   input  cs_aes_halt_rsp_t cs_aes_halt_i,
47: 
48:   // External Health Test Interface
49:   output entropy_src_xht_req_t entropy_src_xht_o,
50:   input  entropy_src_xht_rsp_t entropy_src_xht_i,
51: 
52:   // Alerts
53:   input  prim_alert_pkg::alert_rx_t [NumAlerts-1:0] alert_rx_i,
54:   output prim_alert_pkg::alert_tx_t [NumAlerts-1:0] alert_tx_o,
55: 
56:   // Interrupts
57:   output logic    intr_es_entropy_valid_o,
58:   output logic    intr_es_health_test_failed_o,
59:   output logic    intr_es_observe_fifo_ready_o,
60:   output logic    intr_es_fatal_err_o
61: );
62: 
63:   localparam int RngBusWidth = 4; // AST RNG bus width
64:   localparam int NumBins = 2**RngBusWidth; // bucket health test bin count
65: 
66:   // common signals
67:   entropy_src_hw2reg_t hw2reg;
68:   entropy_src_reg2hw_t reg2hw;
69:   logic [NumAlerts-1:0] alert_test;
70:   logic [NumAlerts-1:0] alert;
71: 
72:   // core signals
73:   logic core_rst_n;
74:   entropy_src_hw2reg_t core_hw2reg;
75:   entropy_src_hw_if_rsp_t core_entropy_hw_if;
76:   entropy_src_rng_req_t core_rng;
77:   cs_aes_halt_req_t core_aes_halt;
78:   entropy_src_xht_req_t core_xht;
79:   logic core_intr_es_entropy_valid;
80:   logic core_intr_es_health_test_failed;
81:   logic core_intr_es_observe_fifo_ready;
82:   logic core_intr_es_fatal_err;
83:   logic [NumAlerts-1:0] core_alert_test;
84:   logic [NumAlerts-1:0] core_alert;
85: 
86:   //stub signals
87:   localparam int StubLfsrWidth = 64;
88:   localparam int Copies = CSRNG_BUS_WIDTH / StubLfsrWidth;
89:   entropy_src_hw2reg_t stub_hw2reg;
90:   entropy_src_hw_if_rsp_t stub_entropy_hw_if;
91:   logic stub_es_valid;
92:   logic [NumAlerts-1:0] stub_alert_test;
93:   logic [NumAlerts-1:0] stub_alert;
94:   logic [StubLfsrWidth-1:0] stub_lfsr_value;
95: 
96:   ///////////////////////////
97:   // Selecting between core and stub
98:   ///////////////////////////
99: 
100:   assign hw2reg                       = Stub ? stub_hw2reg        : core_hw2reg;
101:   assign core_rst_n                   = Stub ? '0                 : rst_ni;
102:   assign entropy_src_hw_if_o          = Stub ? stub_entropy_hw_if : core_entropy_hw_if;
103:   assign entropy_src_rng_o            = Stub ? '1                 : core_rng;
104:   assign cs_aes_halt_o                = Stub ? '0                 : core_aes_halt;
105:   assign entropy_src_xht_o            = Stub ? '0                 : core_xht;
106:   assign intr_es_entropy_valid_o      = Stub ? stub_es_valid      : core_intr_es_entropy_valid;
107:   assign intr_es_health_test_failed_o = Stub ? '0                 : core_intr_es_health_test_failed;
108:   assign intr_es_observe_fifo_ready_o = Stub ? '0                 : core_intr_es_observe_fifo_ready;
109:   assign intr_es_fatal_err_o          = Stub ? '0                 : core_intr_es_fatal_err;
110:   assign alert_test                   = Stub ? stub_alert_test    : core_alert_test;
111:   assign alert                        = Stub ? stub_alert         : core_alert;
112: 
113:   ///////////////////////////
114:   // core entropy operation
115:   ///////////////////////////
116: 
117:   logic [NumAlerts-1:0] intg_err_alert;
118:   assign intg_err_alert[0] = 1'b0;
119: 
120:   // SEC_CM: CONFIG.REGWEN
121:   // SEC_CM: TILE_LINK.BUS.INTEGRITY
122: 
123:   entropy_src_reg_top u_reg (
124:     .clk_i,
125:     .rst_ni,
126:     .tl_i,
127:     .tl_o,
128:     .reg2hw,
129:     .hw2reg(hw2reg),
130:     .intg_err_o(intg_err_alert[1]) // Assign this alert to the fatal alert index.
131:   );
132: 
133:   entropy_src_core #(
134:     .EsFifoDepth(EsFifoDepth),
135:     .DistrFifoDepth(DistrFifoDepth)
136:   ) u_entropy_src_core (
137:     .clk_i,
138:     .rst_ni(core_rst_n),
139:     .reg2hw,
140:     .hw2reg(core_hw2reg),
141: 
142:     .otp_en_entropy_src_fw_read_i(otp_en_entropy_src_fw_read_i),
143:     .otp_en_entropy_src_fw_over_i(otp_en_entropy_src_fw_over_i),
144:     .rng_fips_o,
145: 
146:     .entropy_src_hw_if_o(core_entropy_hw_if),
147:     .entropy_src_hw_if_i,
148: 
149:     .entropy_src_xht_o(core_xht),
150:     .entropy_src_xht_i,
151: 
152:     .entropy_src_rng_o(core_rng),
153:     .entropy_src_rng_i,
154: 
155:     .cs_aes_halt_o(core_aes_halt),
156:     .cs_aes_halt_i,
157: 
158:     .recov_alert_o(core_alert[0]),
159:     .fatal_alert_o(core_alert[1]),
160: 
161:     .recov_alert_test_o(core_alert_test[0]),
162:     .fatal_alert_test_o(core_alert_test[1]),
163: 
164:     .intr_es_entropy_valid_o(core_intr_es_entropy_valid),
165:     .intr_es_health_test_failed_o(core_intr_es_health_test_failed),
166:     .intr_es_observe_fifo_ready_o(core_intr_es_observe_fifo_ready),
167:     .intr_es_fatal_err_o(core_intr_es_fatal_err)
168:   );
169: 
170:   ///////////////////////////
171:   // stub entropy operation
172:   ///////////////////////////
173: 
174:   assign stub_alert = '0;
175:   assign stub_alert_test = '0;
176:   assign stub_entropy_hw_if = '{
177:     es_ack:  '1,
178:     es_bits:  {Copies{stub_lfsr_value}},
179:     es_fips: '1
180:   };
181:   // once enabled, stub entropy is always available
182: 
183:   import prim_mubi_pkg::mubi4_t;
184:   import prim_mubi_pkg::mubi4_test_true_strict;
185: 
186:   mubi4_t mubi_module_en;
187:   assign mubi_module_en  = mubi4_t'(reg2hw.module_enable.q);
188:   assign stub_es_valid = mubi4_test_true_strict(mubi_module_en);
189: 
190:   if (Stub) begin : gen_stub_entropy_src
191:     prim_lfsr #(
192:       .LfsrDw(StubLfsrWidth),
193:       .StateOutDw(StubLfsrWidth)
194:     ) u_prim_lfsr (
195:       .clk_i          (clk_i),
196:       .rst_ni         (rst_ni),
197:       .seed_en_i      ('0),
198:       .seed_i         ('0),
199:       .lfsr_en_i      (stub_es_valid),
200:       .entropy_i      ('0),
201:       .state_o        (stub_lfsr_value)
202:     );
203: 
204:     // hardwire hw2reg inputs
205:     always_comb begin
206:       stub_hw2reg = '0;
207: 
208:       // as long as enable is 1, do not allow registers to be written
209:       stub_hw2reg.fw_ov_rd_data.d = stub_lfsr_value[31:0];
210:       stub_hw2reg.entropy_data.d = stub_lfsr_value[31:0];
211:       stub_hw2reg.debug_status.main_sm_idle.d = 1'b1;
212:       stub_hw2reg.main_sm_state.d = entropy_src_main_sm_pkg::Idle;
213: 
214:       stub_hw2reg.intr_state.es_entropy_valid.de = stub_es_valid;
215:       stub_hw2reg.intr_state.es_entropy_valid.d = 1'b1;
216: 
217:     end
218:   end else begin : gen_stub_tieoff
219:     assign stub_hw2reg = '0;
220:     assign stub_lfsr_value = '0;
221:   end
222: 
223:   ///////////////////////////
224:   // Alert generation
225:   ///////////////////////////
226:   for (genvar i = 0; i < NumAlerts; i++) begin : gen_alert_tx
227:     prim_alert_sender #(
228:       .AsyncOn(AlertAsyncOn[i]),
229:       .IsFatal(i)
230:     ) u_prim_alert_sender (
231:       .clk_i,
232:       .rst_ni,
233:       .alert_test_i  ( alert_test[i]                 ),
234:       .alert_req_i   ( alert[i] || intg_err_alert[i] ),
235:       .alert_ack_o   (                               ),
236:       .alert_state_o (                               ),
237:       .alert_rx_i    ( alert_rx_i[i]                 ),
238:       .alert_tx_o    ( alert_tx_o[i]                 )
239:     );
240:   end
241: 
242:   // Outputs should have a known value after reset
243:   `ASSERT_KNOWN(TlDValidKnownO_A, tl_o.d_valid)
244:   `ASSERT_KNOWN(TlAReadyKnownO_A, tl_o.a_ready)
245: 
246:   // Entropy Interface
247:   `ASSERT_KNOWN(EsHwIfEsAckKnownO_A, entropy_src_hw_if_o.es_ack)
248:   `ASSERT_KNOWN_IF(EsHwIfEsBitsKnownO_A, entropy_src_hw_if_o.es_bits,
249:       entropy_src_hw_if_o.es_ack)
250:   `ASSERT_KNOWN_IF(EsHwIfEsFipsKnownO_A, entropy_src_hw_if_o.es_fips,
251:       entropy_src_hw_if_o.es_ack)
252: 
253:   // RNG Interface
254:   `ASSERT_KNOWN(EsRngEnableKnownO_A, entropy_src_rng_o.rng_enable)
255: 
256:   // External Health Test Interface
257:   `ASSERT_KNOWN_IF(EsXhtEntropyBitKnownO_A, entropy_src_xht_o.entropy_bit,
258:       entropy_src_xht_o.entropy_bit_valid)
259:   `ASSERT_KNOWN(EsXhtEntropyBitValidKnownO_A, entropy_src_xht_o.entropy_bit_valid)
260:   `ASSERT_KNOWN(EsXhtClearKnownO_A, entropy_src_xht_o.clear)
261:   `ASSERT_KNOWN(EsXhtActiveKnownO_A, entropy_src_xht_o.active)
262:   `ASSERT_KNOWN(EsXhtThreshHiKnownO_A, entropy_src_xht_o.thresh_hi)
263:   `ASSERT_KNOWN(EsXhtThreshLoKnownO_A, entropy_src_xht_o.thresh_lo)
264:   `ASSERT_KNOWN(EsXhtWindowKnownO_A, entropy_src_xht_o.window_wrap_pulse)
265: 
266:   // Alerts
267:   `ASSERT_KNOWN(AlertTxKnownO_A, alert_tx_o)
268: 
269:   // Interrupts
270:   `ASSERT_KNOWN(IntrEsEntropyValidKnownO_A, intr_es_entropy_valid_o)
271:   `ASSERT_KNOWN(IntrEsHealthTestFailedKnownO_A, intr_es_health_test_failed_o)
272:   `ASSERT_KNOWN(IntrEsFifoErrKnownO_A, intr_es_fatal_err_o)
273: 
274:   // prim_count alerts
275:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck0_A,
276:     u_entropy_src_core.u_prim_count_window_cntr,
277:     alert_tx_o[1])
278: 
279:   for (genvar sh = 0; sh < RngBusWidth; sh = sh+1) begin : gen_bit_cntrs
280:     `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck1_A,
281:       u_entropy_src_core.u_entropy_src_adaptp_ht.gen_cntrs[sh].u_prim_count_test_cnt,
282:       alert_tx_o[1])
283:   end : gen_bit_cntrs
284: 
285:   for (genvar i = 0; i < NumBins; i = i + 1) begin : gen_symbol_match
286:    `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck_A,
287:      u_entropy_src_core.u_entropy_src_bucket_ht.gen_symbol_match[i].u_prim_count_bin_cntr,
288:      alert_tx_o[1])
289:   end : gen_symbol_match
290: 
291:   for (genvar sh = 0; sh < RngBusWidth; sh = sh+1) begin : gen_pair_cntrs
292:    `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck_A,
293:      u_entropy_src_core.u_entropy_src_markov_ht.gen_cntrs[sh].u_prim_count_pair_cntr,
294:      alert_tx_o[1])
295:   end : gen_pair_cntrs
296: 
297:   for (genvar sh = 0; sh < RngBusWidth; sh = sh+1) begin : gen_rep_cntrs
298:    `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck_A,
299:      u_entropy_src_core.u_entropy_src_repcnt_ht.gen_cntrs[sh].u_prim_count_rep_cntr,
300:      alert_tx_o[1])
301:   end : gen_rep_cntrs
302: 
303:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck7_A,
304:     u_entropy_src_core.u_entropy_src_repcnts_ht.u_prim_count_rep_cntr,
305:     alert_tx_o[1])
306: 
307:   `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(CtrlMainFsmCheck_A,
308:     u_entropy_src_core.u_entropy_src_main_sm.u_state_regs,
309:     alert_tx_o[1])
310: 
311:   `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(CtrlAckFsmCheck_A,
312:     u_entropy_src_core.u_entropy_src_ack_sm.u_state_regs,
313:     alert_tx_o[1])
314: 
315:   `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(SHA3FsmCheck_A,
316:     u_entropy_src_core.u_sha3.u_state_regs, alert_tx_o[1])
317: 
318:   `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(KeccakRoundFsmCheck_A,
319:     u_entropy_src_core.u_sha3.u_keccak.u_state_regs, alert_tx_o[1])
320: 
321:   `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(SHA3padFsmCheck_A,
322:     u_entropy_src_core.u_sha3.u_pad.u_state_regs, alert_tx_o[1])
323: 
324: 
325:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(SentMsgCountCheck_A,
326:     u_entropy_src_core.u_sha3.u_pad.u_sentmsg_count, alert_tx_o[1])
327: 
328:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(RoundCountCheck_A,
329:     u_entropy_src_core.u_sha3.u_keccak.u_round_count, alert_tx_o[1])
330: 
331:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck8_A,
332:     u_entropy_src_core.u_entropy_src_cntr_reg_repcnt.u_prim_count_cntr_reg,
333:     alert_tx_o[1])
334: 
335:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck9_A,
336:     u_entropy_src_core.u_entropy_src_cntr_reg_repcnts.u_prim_count_cntr_reg,
337:     alert_tx_o[1])
338: 
339:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck10_A,
340:     u_entropy_src_core.u_entropy_src_cntr_reg_adaptp_hi.u_prim_count_cntr_reg,
341:     alert_tx_o[1])
342: 
343:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck11_A,
344:     u_entropy_src_core.u_entropy_src_cntr_reg_adaptp_lo.u_prim_count_cntr_reg,
345:     alert_tx_o[1])
346: 
347:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck12_A,
348:     u_entropy_src_core.u_entropy_src_cntr_reg_bucket.u_prim_count_cntr_reg,
349:     alert_tx_o[1])
350: 
351:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck13_A,
352:     u_entropy_src_core.u_entropy_src_cntr_reg_markov_hi.u_prim_count_cntr_reg,
353:     alert_tx_o[1])
354: 
355:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck14_A,
356:     u_entropy_src_core.u_entropy_src_cntr_reg_markov_lo.u_prim_count_cntr_reg,
357:     alert_tx_o[1])
358: 
359:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck15_A,
360:     u_entropy_src_core.u_entropy_src_cntr_reg_extht_hi.u_prim_count_cntr_reg,
361:     alert_tx_o[1])
362: 
363:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck16_A,
364:     u_entropy_src_core.u_entropy_src_cntr_reg_extht_lo.u_prim_count_cntr_reg,
365:     alert_tx_o[1])
366: 
367:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck17_A,
368:     u_entropy_src_core.u_entropy_src_cntr_reg_any_alert_fails.u_prim_count_cntr_reg,
369:     alert_tx_o[1])
370: 
371:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck18_A,
372:     u_entropy_src_core.u_entropy_src_cntr_reg_repcnt_alert_fails.u_prim_count_cntr_reg,
373:     alert_tx_o[1])
374: 
375:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck19_A,
376:     u_entropy_src_core.u_entropy_src_cntr_reg_repcnts_alert_fails.u_prim_count_cntr_reg,
377:     alert_tx_o[1])
378: 
379:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck20_A,
380:     u_entropy_src_core.u_entropy_src_cntr_reg_adaptp_hi_alert_fails.u_prim_count_cntr_reg,
381:     alert_tx_o[1])
382: 
383:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck21_A,
384:     u_entropy_src_core.u_entropy_src_cntr_reg_adaptp_lo_alert_fails.u_prim_count_cntr_reg,
385:     alert_tx_o[1])
386: 
387:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck22_A,
388:     u_entropy_src_core.u_entropy_src_cntr_reg_bucket_alert_fails.u_prim_count_cntr_reg,
389:     alert_tx_o[1])
390: 
391:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck23_A,
392:     u_entropy_src_core.u_entropy_src_cntr_reg_markov_hi_alert_fails.u_prim_count_cntr_reg,
393:     alert_tx_o[1])
394: 
395:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck24_A,
396:     u_entropy_src_core.u_entropy_src_cntr_reg_markov_lo_alert_fails.u_prim_count_cntr_reg,
397:     alert_tx_o[1])
398: 
399:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck25_A,
400:     u_entropy_src_core.u_entropy_src_cntr_reg_extht_hi_alert_fails.u_prim_count_cntr_reg,
401:     alert_tx_o[1])
402: 
403:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CntAlertCheck26_A,
404:     u_entropy_src_core.u_entropy_src_cntr_reg_extht_lo_alert_fails.u_prim_count_cntr_reg,
405:     alert_tx_o[1])
406: 
407:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(EsrngFifoWptrCheck_A,
408:     u_entropy_src_core.u_prim_fifo_sync_esrng.gen_normal_fifo.u_fifo_cnt.gen_secure_ptrs.u_wptr,
409:     alert_tx_o[1])
410:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(EsrngFifoRptrCheck_A,
411:     u_entropy_src_core.u_prim_fifo_sync_esrng.gen_normal_fifo.u_fifo_cnt.gen_secure_ptrs.u_rptr,
412:     alert_tx_o[1])
413: 
414:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(DistrFifoWptrCheck_A,
415:     u_entropy_src_core.u_prim_fifo_sync_distr.gen_normal_fifo.u_fifo_cnt.gen_secure_ptrs.u_wptr,
416:     alert_tx_o[1])
417:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(DistrFifoRptrCheck_A,
418:     u_entropy_src_core.u_prim_fifo_sync_distr.gen_normal_fifo.u_fifo_cnt.gen_secure_ptrs.u_rptr,
419:     alert_tx_o[1])
420: 
421:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(ObserveFifoWptrCheck_A,
422:     u_entropy_src_core.u_prim_fifo_sync_observe.gen_normal_fifo.u_fifo_cnt.gen_secure_ptrs.u_wptr,
423:     alert_tx_o[1])
424:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(ObserveFifoRptrCheck_A,
425:     u_entropy_src_core.u_prim_fifo_sync_observe.gen_normal_fifo.u_fifo_cnt.gen_secure_ptrs.u_rptr,
426:     alert_tx_o[1])
427: 
428:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(EsfinalFifoWptrCheck_A,
429:     u_entropy_src_core.u_prim_fifo_sync_esfinal.gen_normal_fifo.u_fifo_cnt.gen_secure_ptrs.u_wptr,
430:     alert_tx_o[1])
431:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(EsfinalFifoRptrCheck_A,
432:     u_entropy_src_core.u_prim_fifo_sync_esfinal.gen_normal_fifo.u_fifo_cnt.gen_secure_ptrs.u_rptr,
433:     alert_tx_o[1])
434: 
435:   // Alert assertions for reg_we onehot check
436:   `ASSERT_PRIM_REG_WE_ONEHOT_ERROR_TRIGGER_ALERT(RegWeOnehotCheck_A, u_reg, alert_tx_o[1])
437: 
438: endmodule

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_h25WhF4EwBLmRZYFxRtCUexx)
 Call ID: call_h25WhF4EwBLmRZYFxRtCUexx
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/entropy_src/rtl/entropy_src_core.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Description: entropy_src core module
6: //
7: 
8: module entropy_src_core import entropy_src_pkg::*; #(
9:   parameter int EsFifoDepth = 4,
10:   parameter int DistrFifoDepth = 2
11: ) (
12:   input logic clk_i,
13:   input logic rst_ni,
14: 
15:   input  entropy_src_reg_pkg::entropy_src_reg2hw_t reg2hw,
16:   output entropy_src_reg_pkg::entropy_src_hw2reg_t hw2reg,
17: 
18:   // Efuse Interface
19:   input prim_mubi_pkg::mubi8_t otp_en_entropy_src_fw_read_i,
20:   input prim_mubi_pkg::mubi8_t otp_en_entropy_src_fw_over_i,
21: 
22:   // RNG Interface
23:   output logic rng_fips_o,
24: 
25:   // Entropy Interface
26:   input  entropy_src_hw_if_req_t entropy_src_hw_if_i,
27:   output entropy_src_hw_if_rsp_t entropy_src_hw_if_o,
28: 
29:   // RNG Interface
30:   output entropy_src_rng_req_t entropy_src_rng_o,
31:   input  entropy_src_rng_rsp_t entropy_src_rng_i,
32: 
33:   // CSRNG Interface
34:   output cs_aes_halt_req_t cs_aes_halt_o,
35:   input  cs_aes_halt_rsp_t cs_aes_halt_i,
36: 
37:   // External Health Test Interface
38:   output entropy_src_xht_req_t entropy_src_xht_o,
39:   input  entropy_src_xht_rsp_t entropy_src_xht_i,
40: 
41:   output logic           recov_alert_test_o,
42:   output logic           fatal_alert_test_o,
43:   output logic           recov_alert_o,
44:   output logic           fatal_alert_o,
45: 
46:   output logic           intr_es_entropy_valid_o,
47:   output logic           intr_es_health_test_failed_o,
48:   output logic           intr_es_observe_fifo_ready_o,
49:   output logic           intr_es_fatal_err_o
50: );
51: 
52:   import entropy_src_reg_pkg::*;
53:   import prim_mubi_pkg::mubi4_t;
54:   import prim_mubi_pkg::mubi4_test_true_strict;
55:   import prim_mubi_pkg::mubi4_and_hi;
56:   import prim_mubi_pkg::mubi4_test_false_loose;
57:   import prim_mubi_pkg::mubi4_test_invalid;
58: 
59:   localparam int EsFifoDepthW = prim_util_pkg::vbits(EsFifoDepth);
60:   localparam int PostHTWidth = 32;
61:   localparam int RngBusWidth = 4;
62:   localparam int HalfRegWidth = 16;
63:   localparam int FullRegWidth = 32;
64:   localparam int EighthRegWidth = 4;
65:   localparam int SeedLen = 384;
66:   localparam int DistrFifoWidth = 32;
67:   localparam int ObserveFifoWidth = 32;
68:   localparam int PreCondWidth = 64;
69:   localparam int Clog2ObserveFifoDepth = $clog2(ObserveFifoDepth);
70:   localparam int EsEnableCopies = 20;
71:   localparam int EsEnPulseCopies = 1;
72:   localparam int unsigned NumSwReadsSeed = SeedLen / FullRegWidth;
73:   localparam int unsigned LastSwRead = NumSwReadsSeed - 1;
74:   localparam int unsigned SwReadIdxWidth = prim_util_pkg::vbits(NumSwReadsSeed);
75: 
76:   //-----------------------
77:   // SHA3parameters
78:   //-----------------------
79:   // Do not enable masking
80:   localparam bit Sha3EnMasking = 0;
81:   // derived parameter
82:   localparam int Sha3Share = (Sha3EnMasking) ? 2 : 1;
83: 
84:   // signals
85:   logic       fw_ov_mode;
86:   logic       fw_ov_mode_pfe;
87:   logic       fw_ov_mode_pfa;
88:   logic       fw_ov_wr_fifo_full;
89:   logic       fw_ov_mode_entropy_insert;
90:   logic       fw_ov_entropy_insert_pfe;
91:   logic       fw_ov_entropy_insert_pfa;
92:   logic       fw_ov_sha3_start_pfe;
93:   logic       fw_ov_sha3_start_pfe_q;
94:   logic       fw_ov_sha3_start_pfa;
95:   logic       fw_ov_sha3_disable_pulse;
96:   logic [ObserveFifoWidth-1:0] fw_ov_wr_data;
97:   logic       fw_ov_fifo_rd_pulse;
98:   logic       fw_ov_fifo_wr_pulse;
99:   logic       es_enable_pfa;
100: 
101:   logic       fips_enable_pfe;
102:   logic       fips_enable_pfa;
103:   logic       fips_flag_pfe;
104:   logic       fips_flag_pfa;
105:   logic       rng_fips_pfe;
106:   logic       rng_fips_pfa;
107: 
108:   logic       rng_bit_en;
109:   logic       rng_bit_enable_pfe;
110:   logic       rng_bit_enable_pfa;
111:   logic [1:0] rng_bit_sel;
112:   logic       rng_enable_q, rng_enable_d;
113:   logic       entropy_data_reg_en_pfe;
114:   logic       entropy_data_reg_en_pfa;
115:   logic       es_data_reg_rd_en;
116:   logic       event_es_entropy_valid;
117:   logic       event_es_health_test_failed;
118:   logic       event_es_observe_fifo_ready;
119:   logic       event_es_fatal_err;
120:   logic       es_rng_src_valid;
121:   logic [RngBusWidth-1:0] es_rng_bus;
122: 
123:   logic [RngBusWidth-1:0] sfifo_esrng_wdata;
124:   logic [RngBusWidth-1:0] sfifo_esrng_rdata;
125:   logic                   sfifo_esrng_push;
126:   logic                   sfifo_esrng_pop;
127:   logic                   sfifo_esrng_clr;
128:   logic                   sfifo_esrng_full;
129:   logic                   sfifo_esrng_not_empty;
130:   logic                   sfifo_esrng_not_full;
131:   logic                   sfifo_esrng_int_err;
132:   logic [2:0]             sfifo_esrng_err;
133: 
134:   logic [DistrFifoWidth-1:0] sfifo_distr_wdata;
135:   logic [DistrFifoWidth-1:0] sfifo_distr_rdata;
136:   logic                      sfifo_distr_push;
137:   logic                      sfifo_distr_pop;
138:   logic                      sfifo_distr_clr;
139:   logic                      sfifo_distr_not_full;
140:   logic                      sfifo_distr_full;
141:   logic                      sfifo_distr_not_empty;
142:   logic                      sfifo_distr_int_err;
143:   logic [2:0]                sfifo_distr_err;
144: 
145:   logic [ObserveFifoWidth-1:0]    sfifo_observe_wdata;
146:   logic [ObserveFifoWidth-1:0]    sfifo_observe_rdata;
147:   logic                           sfifo_observe_push;
148:   logic                           sfifo_observe_pop;
149:   logic                           sfifo_observe_full;
150:   logic                           sfifo_observe_clr;
151:   logic                           sfifo_observe_not_empty;
152:   logic [Clog2ObserveFifoDepth:0] sfifo_observe_depth;
153:   logic                           sfifo_observe_int_err;
154:   logic [2:0]                     sfifo_observe_err;
155: 
156:   logic [EsFifoDepthW-1:0]   sfifo_esfinal_depth;
157:   logic [(1+SeedLen)-1:0]    sfifo_esfinal_wdata;
158:   logic [(1+SeedLen)-1:0]    sfifo_esfinal_rdata;
159:   logic                      sfifo_esfinal_push;
160:   logic                      sfifo_esfinal_pop;
161:   logic                      sfifo_esfinal_clr;
162:   logic                      sfifo_esfinal_not_full;
163:   logic                      sfifo_esfinal_full;
164:   logic                      sfifo_esfinal_not_empty;
165:   logic                      sfifo_esfinal_int_err;
166:   logic [2:0]                sfifo_esfinal_err;
167: 
168:   logic                   es_sfifo_int_err;
169: 
170:   logic [SeedLen-1:0]     esfinal_data;
171:   logic                   esfinal_fips_flag;
172: 
173:   logic                   any_fail_pulse;
174:   logic                   main_stage_push;
175:   logic                   main_stage_push_raw;
176:   logic                   bypass_stage_pop;
177:   logic                   boot_phase_done;
178:   logic [HalfRegWidth-1:0] any_fail_count;
179:   logic                    any_fails_cntr_err;
180:   logic                    alert_threshold_fail;
181:   logic [HalfRegWidth-1:0] alert_threshold;
182:   logic [HalfRegWidth-1:0] alert_threshold_inv;
183:   logic [Clog2ObserveFifoDepth:0] observe_fifo_thresh;
184:   logic                     observe_fifo_thresh_met;
185:   logic                     repcnt_active;
186:   logic                     repcnts_active;
187:   logic                     adaptp_active;
188:   logic                     bucket_active;
189:   logic                     markov_active;
190:   logic                     extht_active;
191:   logic                     alert_cntrs_clr;
192:   logic                     health_test_clr;
193:   logic                     health_test_done_pulse;
194:   logic [RngBusWidth-1:0]   health_test_esbus;
195:   logic                     health_test_esbus_vld;
196:   logic                     es_route_pfe;
197:   logic                     es_route_pfa;
198:   logic                     es_type_pfe;
199:   logic                     es_type_pfa;
200:   logic                     es_route_to_sw;
201:   logic                     es_bypass_to_sw;
202:   logic                     es_bypass_mode;
203:   logic                     rst_alert_cntr;
204:   logic                     threshold_scope;
205:   logic                     threshold_scope_pfe;
206:   logic                     threshold_scope_pfa;
207:   logic                     fips_compliance;
208: 
209:   logic [HalfRegWidth-1:0] health_test_fips_window;
210:   logic [HalfRegWidth-1:0] health_test_bypass_window;
211:   logic [HalfRegWidth-1:0] health_test_window;
212:   logic [WINDOW_CNTR_WIDTH-1:0] health_test_window_scaled;
213: 
214:   logic [HalfRegWidth-1:0] repcnt_fips_threshold;
215:   logic [HalfRegWidth-1:0] repcnt_fips_threshold_oneway;
216:   logic                    repcnt_fips_threshold_wr;
217:   logic [HalfRegWidth-1:0] repcnt_bypass_threshold;
218:   logic [HalfRegWidth-1:0] repcnt_bypass_threshold_oneway;
219:   logic                    repcnt_bypass_threshold_wr;
220:   logic [HalfRegWidth-1:0] repcnt_threshold;
221:   logic [HalfRegWidth-1:0] repcnt_event_cnt;
222:   logic [HalfRegWidth-1:0] repcnt_event_hwm_fips;
223:   logic [HalfRegWidth-1:0] repcnt_event_hwm_bypass;
224:   logic [FullRegWidth-1:0] repcnt_total_fails;
225:   logic [EighthRegWidth-1:0] repcnt_fail_count;
226:   logic                     repcnt_fail_pulse;
227:   logic                     repcnt_fails_cntr_err;
228:   logic                     repcnt_alert_cntr_err;
229: 
230:   logic [HalfRegWidth-1:0] repcnts_fips_threshold;
231:   logic [HalfRegWidth-1:0] repcnts_fips_threshold_oneway;
232:   logic                    repcnts_fips_threshold_wr;
233:   logic [HalfRegWidth-1:0] repcnts_bypass_threshold;
234:   logic [HalfRegWidth-1:0] repcnts_bypass_threshold_oneway;
235:   logic                    repcnts_bypass_threshold_wr;
236:   logic [HalfRegWidth-1:0] repcnts_threshold;
237:   logic [HalfRegWidth-1:0] repcnts_event_cnt;
238:   logic [HalfRegWidth-1:0] repcnts_event_hwm_fips;
239:   logic [HalfRegWidth-1:0] repcnts_event_hwm_bypass;
240:   logic [FullRegWidth-1:0] repcnts_total_fails;
241:   logic [EighthRegWidth-1:0] repcnts_fail_count;
242:   logic                     repcnts_fail_pulse;
243:   logic                     repcnts_fails_cntr_err;
244:   logic                     repcnts_alert_cntr_err;
245: 
246:   logic [HalfRegWidth-1:0] adaptp_hi_fips_threshold;
247:   logic [HalfRegWidth-1:0] adaptp_hi_fips_threshold_oneway;
248:   logic                    adaptp_hi_fips_threshold_wr;
249:   logic [HalfRegWidth-1:0] adaptp_hi_bypass_threshold;
250:   logic [HalfRegWidth-1:0] adaptp_hi_bypass_threshold_oneway;
251:   logic                    adaptp_hi_bypass_threshold_wr;
252:   logic [HalfRegWidth-1:0] adaptp_hi_threshold;
253:   logic [HalfRegWidth-1:0] adaptp_lo_fips_threshold;
254:   logic [HalfRegWidth-1:0] adaptp_lo_fips_threshold_oneway;
255:   logic                    adaptp_lo_fips_threshold_wr;
256:   logic [HalfRegWidth-1:0] adaptp_lo_bypass_threshold;
257:   logic [HalfRegWidth-1:0] adaptp_lo_bypass_threshold_oneway;
258:   logic                    adaptp_lo_bypass_threshold_wr;
259:   logic [HalfRegWidth-1:0] adaptp_lo_threshold;
260:   logic [HalfRegWidth-1:0] adaptp_hi_event_cnt;
261:   logic [HalfRegWidth-1:0] adaptp_lo_event_cnt;
262:   logic [HalfRegWidth-1:0] adaptp_hi_event_hwm_fips;
263:   logic [HalfRegWidth-1:0] adaptp_hi_event_hwm_bypass;
264:   logic [HalfRegWidth-1:0] adaptp_lo_event_hwm_fips;
265:   logic [HalfRegWidth-1:0] adaptp_lo_event_hwm_bypass;
266:   logic [FullRegWidth-1:0] adaptp_hi_total_fails;
267:   logic [FullRegWidth-1:0] adaptp_lo_total_fails;
268:   logic [EighthRegWidth-1:0] adaptp_hi_fail_count;
269:   logic [EighthRegWidth-1:0] adaptp_lo_fail_count;
270:   logic                     adaptp_hi_fail_pulse;
271:   logic                     adaptp_lo_fail_pulse;
272:   logic                     adaptp_hi_fails_cntr_err;
273:   logic                     adaptp_lo_fails_cntr_err;
274:   logic                     adaptp_hi_alert_cntr_err;
275:   logic                     adaptp_lo_alert_cntr_err;
276: 
277:   logic [HalfRegWidth-1:0] bucket_fips_threshold;
278:   logic [HalfRegWidth-1:0] bucket_fips_threshold_oneway;
279:   logic                    bucket_fips_threshold_wr;
280:   logic [HalfRegWidth-1:0] bucket_bypass_threshold;
281:   logic [HalfRegWidth-1:0] bucket_bypass_threshold_oneway;
282:   logic                    bucket_bypass_threshold_wr;
283:   logic [HalfRegWidth-1:0] bucket_threshold;
284:   logic [HalfRegWidth-1:0] bucket_event_cnt;
285:   logic [HalfRegWidth-1:0] bucket_event_hwm_fips;
286:   logic [HalfRegWidth-1:0] bucket_event_hwm_bypass;
287:   logic [FullRegWidth-1:0] bucket_total_fails;
288:   logic [EighthRegWidth-1:0] bucket_fail_count;
289:   logic                     bucket_fail_pulse;
290:   logic                     bucket_fails_cntr_err;
291:   logic                     bucket_alert_cntr_err;
292: 
293:   logic [HalfRegWidth-1:0] markov_hi_fips_threshold;
294:   logic [HalfRegWidth-1:0] markov_hi_fips_threshold_oneway;
295:   logic                    markov_hi_fips_threshold_wr;
296:   logic [HalfRegWidth-1:0] markov_hi_bypass_threshold;
297:   logic [HalfRegWidth-1:0] markov_hi_bypass_threshold_oneway;
298:   logic                    markov_hi_bypass_threshold_wr;
299:   logic [HalfRegWidth-1:0] markov_hi_threshold;
300:   logic [HalfRegWidth-1:0] markov_lo_fips_threshold;
301:   logic [HalfRegWidth-1:0] markov_lo_fips_threshold_oneway;
302:   logic                    markov_lo_fips_threshold_wr;
303:   logic [HalfRegWidth-1:0] markov_lo_bypass_threshold;
304:   logic [HalfRegWidth-1:0] markov_lo_bypass_threshold_oneway;
305:   logic                    markov_lo_bypass_threshold_wr;
306:   logic [HalfRegWidth-1:0] markov_lo_threshold;
307:   logic [HalfRegWidth-1:0] markov_hi_event_cnt;
308:   logic [HalfRegWidth-1:0] markov_lo_event_cnt;
309:   logic [HalfRegWidth-1:0] markov_hi_event_hwm_fips;
310:   logic [HalfRegWidth-1:0] markov_hi_event_hwm_bypass;
311:   logic [HalfRegWidth-1:0] markov_lo_event_hwm_fips;
312:   logic [HalfRegWidth-1:0] markov_lo_event_hwm_bypass;
313:   logic [FullRegWidth-1:0] markov_hi_total_fails;
314:   logic [FullRegWidth-1:0] markov_lo_total_fails;
315:   logic [EighthRegWidth-1:0] markov_hi_fail_count;
316:   logic [EighthRegWidth-1:0] markov_lo_fail_count;
317:   logic                     markov_hi_fail_pulse;
318:   logic                     markov_lo_fail_pulse;
319:   logic                     markov_hi_fails_cntr_err;
320:   logic                     markov_lo_fails_cntr_err;
321:   logic                     markov_hi_alert_cntr_err;
322:   logic                     markov_lo_alert_cntr_err;
323: 
324:   logic [HalfRegWidth-1:0] extht_hi_fips_threshold;
325:   logic [HalfRegWidth-1:0] extht_hi_fips_threshold_oneway;
326:   logic                    extht_hi_fips_threshold_wr;
327:   logic [HalfRegWidth-1:0] extht_hi_bypass_threshold;
328:   logic [HalfRegWidth-1:0] extht_hi_bypass_threshold_oneway;
329:   logic                    extht_hi_bypass_threshold_wr;
330:   logic [HalfRegWidth-1:0] extht_hi_threshold;
331:   logic [HalfRegWidth-1:0] extht_lo_fips_threshold;
332:   logic [HalfRegWidth-1:0] extht_lo_fips_threshold_oneway;
333:   logic                    extht_lo_fips_threshold_wr;
334:   logic [HalfRegWidth-1:0] extht_lo_bypass_threshold;
335:   logic [HalfRegWidth-1:0] extht_lo_bypass_threshold_oneway;
336:   logic                    extht_lo_bypass_threshold_wr;
337:   logic [HalfRegWidth-1:0] extht_lo_threshold;
338:   logic [HalfRegWidth-1:0] extht_event_cnt_hi;
339:   logic [HalfRegWidth-1:0] extht_event_cnt_lo;
340:   logic [HalfRegWidth-1:0] extht_hi_event_hwm_fips;
341:   logic [HalfRegWidth-1:0] extht_hi_event_hwm_bypass;
342:   logic [HalfRegWidth-1:0] extht_lo_event_hwm_fips;
343:   logic [HalfRegWidth-1:0] extht_lo_event_hwm_bypass;
344:   logic [FullRegWidth-1:0] extht_hi_total_fails;
345:   logic [FullRegWidth-1:0] extht_lo_total_fails;
346:   logic [EighthRegWidth-1:0] extht_hi_fail_count;
347:   logic [EighthRegWidth-1:0] extht_lo_fail_count;
348:   logic                     extht_hi_fail_pulse;
349:   logic                     extht_lo_fail_pulse;
350:   logic                     extht_cont_test;
351:   logic                     extht_hi_fails_cntr_err;
352:   logic                     extht_lo_fails_cntr_err;
353:   logic                     extht_hi_alert_cntr_err;
354:   logic                     extht_lo_alert_cntr_err;
355: 
356: 
357:   logic                     pfifo_esbit_wdata;
358:   logic [RngBusWidth-1:0]   pfifo_esbit_rdata;
359:   logic                     pfifo_esbit_not_empty;
360:   logic                     pfifo_esbit_not_full;
361:   logic                     pfifo_esbit_push;
362:   logic                     pfifo_esbit_clr;
363:   logic                     pfifo_esbit_pop;
364: 
365:   logic [RngBusWidth-1:0]   pfifo_postht_wdata;
366:   logic [PostHTWidth-1:0]   pfifo_postht_rdata;
367:   logic                     pfifo_postht_not_empty;
368:   logic                     pfifo_postht_not_full;
369:   logic                     pfifo_postht_push;
370:   logic                     pfifo_postht_clr;
371:   logic                     pfifo_postht_pop;
372: 
373:   logic [PreCondWidth-1:0]  pfifo_cond_wdata;
374:   logic [SeedLen-1:0]       pfifo_cond_rdata;
375:   logic                     pfifo_cond_push;
376: 
377:   logic [ObserveFifoWidth-1:0] pfifo_precon_wdata;
378:   logic [PreCondWidth-1:0]     pfifo_precon_rdata;
379:   logic                        pfifo_precon_not_empty;
380:   logic                        pfifo_precon_not_full;
381:   logic                        pfifo_precon_push;
382:   logic                        pfifo_precon_clr;
383:   logic                        pfifo_precon_pop;
384: 
385:   logic [PostHTWidth-1:0]   pfifo_bypass_wdata;
386:   logic [SeedLen-1:0]       pfifo_bypass_rdata;
387:   logic                     pfifo_bypass_not_empty;
388:   logic                     pfifo_bypass_not_full;
389:   logic                     pfifo_bypass_push;
390:   logic                     pfifo_bypass_clr;
391:   logic                     pfifo_bypass_pop;
392: 
393:   logic [SwReadIdxWidth-1:0] swread_idx_d, swread_idx_q;
394:   logic                      swread_idx_incr, swread_idx_clr;
395:   logic [FullRegWidth-1:0]   swread_data, swread_data_buf;
396:   logic                      swread_done;
397: 
398:   logic [SeedLen-1:0]       final_es_data;
399:   logic                     es_hw_if_req;
400:   logic                     es_hw_if_ack;
401:   logic                     es_hw_if_fifo_pop;
402:   logic                     sfifo_esrng_err_sum;
403:   logic                     sfifo_distr_err_sum;
404:   logic                     sfifo_observe_err_sum;
405:   logic                     sfifo_esfinal_err_sum;
406:   // For fifo errors that are generated through the
407:   // ERR_CODE_TEST register, but are not associated
408:   // with any errors:
409:   logic                         sfifo_test_err_sum;
410:   logic                         es_ack_sm_err_sum;
411:   logic                         es_ack_sm_err;
412:   logic                         es_main_sm_err_sum;
413:   logic                         es_main_sm_err;
414:   logic                         es_main_sm_alert;
415:   logic                         es_bus_cmp_alert;
416:   logic                         es_thresh_cfg_alert;
417:   logic                         es_main_sm_idle;
418:   logic [8:0]                   es_main_sm_state;
419:   logic                         fifo_write_err_sum;
420:   logic                         fifo_read_err_sum;
421:   logic                         fifo_status_err_sum;
422:   logic [30:0]                  err_code_test_bit;
423:   logic                         sha3_msgfifo_ready;
424:   logic                         sha3_state_vld;
425:   logic                         sha3_start_raw;
426:   logic                         sha3_start;
427:   logic                         sha3_process;
428:   logic                         sha3_block_processed;
429:   prim_mubi_pkg::mubi4_t        sha3_done;
430:   prim_mubi_pkg::mubi4_t        sha3_absorbed;
431:   logic                         sha3_squeezing;
432:   logic [2:0]                   sha3_fsm;
433:   logic [32:0]                  sha3_err;
434:   logic                         cs_aes_halt_req;
435:   logic [WINDOW_CNTR_WIDTH-1:0] window_cntr;
436:   logic                         window_cntr_incr_en;
437: 
438:   logic [sha3_pkg::StateW-1:0] sha3_state[Sha3Share];
439:   logic [PreCondWidth-1:0] msg_data[Sha3Share];
440:   logic                    es_rdata_capt_vld;
441:   logic                    window_cntr_err;
442:   logic                    repcnt_cntr_err;
443:   logic                    repcnts_cntr_err;
444:   logic                    adaptp_cntr_err;
445:   logic                    bucket_cntr_err;
446:   logic                    markov_cntr_err;
447:   logic                    es_cntr_err;
448:   logic                    es_cntr_err_sum;
449:   logic                    sha3_state_error_sum;
450:   logic                    sha3_rst_storage_err_sum;
451:   logic                    efuse_es_sw_reg_en;
452:   logic                    efuse_es_sw_ov_en;
453: 
454:   logic                    sha3_state_error;
455:   logic                    sha3_count_error;
456:   logic                    sha3_rst_storage_err;
457:   logic                    es_hw_regwen;
458:   logic                    recov_alert_state;
459:   logic                    es_fw_ov_wr_alert;
460:   logic                    es_fw_ov_disable_alert;
461:   logic                    fw_ov_corrupted;
462:   logic                    postht_entropy_drop_alert;
463: 
464:   logic                    stale_seed_processing;
465:   logic                    main_sm_enable;
466:   logic                    main_sm_done_pulse;
467:   logic                    main_sm_ht_failed;
468: 
469:   logic                    unused_err_code_test_bit;
470:   logic                    unused_sha3_state;
471:   logic                    unused_entropy_data;
472:   logic                    unused_fw_ov_rd_data;
473:   logic                    unused_sfifo_esrng_not_full;
474:   logic                    unused_sfifo_esfinal_not_full;
475: 
476:   prim_mubi_pkg::mubi8_t en_entropy_src_fw_read;
477:   prim_mubi_pkg::mubi8_t en_entropy_src_fw_over;
478: 
479:   mubi4_t mubi_es_enable;
480:   mubi4_t mubi_module_en_pulse;
481: 
482:   mubi4_t       mubi_module_en_raw;
483:   mubi4_t [2:0] mubi_module_en_raw_fanout;
484: 
485:   mubi4_t [EsEnableCopies-1:0] mubi_es_enable_fanout;
486:   logic   [EsEnableCopies-1:0] es_enable_fo;
487: 
488:   mubi4_t [EsEnPulseCopies-1:0] mubi_module_en_pulse_fanout;
489:   logic   [EsEnPulseCopies-1:0] module_en_pulse_fo;
490: 
491:   // A delayed copy of the enable signal, and enable pulse which are needed to cleanly handle any
492:   // long-duration operations from the previous run.
493:   logic                        es_delayed_enable;
494: 
495:   mubi4_t [1:0] mubi_rng_bit_en_fanout;
496:   mubi4_t mubi_rng_bit_en;
497: 
498:   // flops
499:   logic        ht_failed_qq, ht_failed_q, ht_failed_d;
500:   logic        ht_done_pulse_qq, ht_done_pulse_q, ht_done_pulse_d;
501:   logic        sha3_err_q, sha3_err_d;
502:   logic        cs_aes_halt_q, cs_aes_halt_d;
503:   logic [63:0] es_rdata_capt_q, es_rdata_capt_d;
504:   logic        es_rdata_capt_vld_q, es_rdata_capt_vld_d;
505:   mubi4_t      mubi_mod_en_dly_d, mubi_mod_en_dly_q;
506: 
507: 
508:   logic        sha3_start_mask_q, sha3_start_mask_d;
509:   logic        sha3_flush_q, sha3_flush_d;
510:   logic [1:0]  fw_ov_corrupted_q, fw_ov_corrupted_d;
511: 
512:   always_ff @(posedge clk_i or negedge rst_ni) begin
513:     if (!rst_ni) begin
514:       ht_failed_q            <= '0;
515:       ht_failed_qq           <= '0;
516:       ht_done_pulse_q        <= '0;
517:       ht_done_pulse_qq       <= '0;
518:       sha3_err_q             <= '0;
519:       cs_aes_halt_q          <= '0;
520:       es_rdata_capt_q        <= '0;
521:       es_rdata_capt_vld_q    <= '0;
522:       fw_ov_sha3_start_pfe_q <= '0;
523:       mubi_mod_en_dly_q      <= prim_mubi_pkg::MuBi4False;
524:       sha3_flush_q           <= '0;
525:       sha3_start_mask_q      <= '0;
526:       fw_ov_corrupted_q      <= 2'b00;
527:       rng_enable_q           <= 1'b 0;
528:     end else begin
529:       ht_failed_q            <= ht_failed_d;
530:       ht_failed_qq           <= ht_failed_q;
531:       ht_done_pulse_q        <= ht_done_pulse_d;
532:       ht_done_pulse_qq       <= ht_done_pulse_q;
533:       sha3_err_q             <= sha3_err_d;
534:       cs_aes_halt_q          <= cs_aes_halt_d;
535:       es_rdata_capt_q        <= es_rdata_capt_d;
536:       es_rdata_capt_vld_q    <= es_rdata_capt_vld_d;
537:       fw_ov_sha3_start_pfe_q <= fw_ov_sha3_start_pfe;
538:       sha3_flush_q           <= sha3_flush_d;
539:       sha3_start_mask_q      <= sha3_start_mask_d;
540:       mubi_mod_en_dly_q      <= mubi_mod_en_dly_d;
541:       fw_ov_corrupted_q      <= fw_ov_corrupted_d;
542:       rng_enable_q           <= rng_enable_d;
543:     end
544:   end
545: 
546:   assign fw_ov_sha3_disable_pulse = fw_ov_sha3_start_pfe_q & ~fw_ov_sha3_start_pfe;
547: 
548:   //--------------------------------------------
549:   // register lock gating
550:   //--------------------------------------------
551: 
552:   // Allow writes only if
553:   // 1. SW_REGUPD is true,
554:   // 2. The DUT is disabled
555:   //   Block writes if enabled or if internal activities are still in progress (as indicated by
556:   //   es_delayed_enable).
557:   assign es_hw_regwen = reg2hw.sw_regupd.q &&
558:                         mubi4_test_false_loose(mubi_module_en_raw_fanout[0]) &&
559:                         !es_delayed_enable;
560:   assign hw2reg.regwen.de = 1'b1;
561:   assign hw2reg.regwen.d = es_hw_regwen;
562: 
563:   //--------------------------------------------
564:   // set up secure enable bits
565:   //--------------------------------------------
566: 
567:   // check for illegal enable field states, and set alert if detected
568: 
569:   // SEC_CM: CONFIG.MUBI
570:   assign mubi_module_en_raw = mubi4_t'(reg2hw.module_enable.q);
571:   assign es_enable_pfa      = mubi4_test_invalid(mubi_module_en_raw_fanout[1]);
572:   assign hw2reg.recov_alert_sts.module_enable_field_alert.de = es_enable_pfa;
573:   assign hw2reg.recov_alert_sts.module_enable_field_alert.d  = es_enable_pfa;
574: 
575:   prim_mubi4_sync #(
576:     .NumCopies(3),
577:     .AsyncOn(0)
578:   ) u_prim_mubi4_sync_entropy_module_en (
579:     .clk_i,
580:     .rst_ni,
581:     .mubi_i(mubi_module_en_raw),
582:     .mubi_o(mubi_module_en_raw_fanout)
583:   );
584: 
585:   // Generation of enable pulse, and main enable signals.
586:   //
587:   // This module creates a single mubi_encoded module_enable_pulse, as well as
588:   // a general mubi_es_enable signal.
589:   //
590:   // The module enable pulse is MuBi4True for a single clock after the
591:   // module_enable register is asserted MuBi4True. However in this first clock cycle
592:   // most of the module is not enabled.  (The enable pulse is for clearing the
593:   // residual internal state.)
594:   //
595:   // The rest of the module is enabled in the second clock cycle after seting the
596:   // module_enable register to MuBi4True.
597:   //
598:   // When module_enable is set to MuBi4False the module is disabled.  No further
599:   // RNG input is accepted and the state machines transition to Idle as soon as
600:   // possible. Some delay may occur if the SHA3 conditioning block is busy, though
601:   // otherwise the main_sm transitions to Idle without delay.
602: 
603:   assign mubi_mod_en_dly_d = mubi_module_en_raw_fanout[2];
604:   assign mubi_module_en_pulse = mubi4_and_hi(mubi_mod_en_dly_d, mubi4_t'(~mubi_mod_en_dly_q));
605:   assign mubi_es_enable = mubi4_and_hi(mubi_mod_en_dly_d, mubi_mod_en_dly_q);
606: 
607:   for (genvar i = 0; i < EsEnableCopies; i = i+1) begin : gen_mubi_en_copies
608:     assign es_enable_fo[i] = mubi4_test_true_strict(mubi_es_enable_fanout[i]);
609:   end : gen_mubi_en_copies
610: 
611:   prim_mubi4_sync #(
612:     .NumCopies(EsEnableCopies),
613:     .AsyncOn(0)
614:   ) u_prim_mubi4_sync_es_enable (
615:     .clk_i,
616:     .rst_ni,
617:     .mubi_i(mubi_es_enable),
618:     .mubi_o(mubi_es_enable_fanout)
619:   );
620: 
621:   for (genvar i = 0; i < EsEnPulseCopies; i = i+1) begin : gen_mubi_en_pulse_copies
622:     assign module_en_pulse_fo[i] = mubi4_test_true_strict(mubi_module_en_pulse_fanout[i]);
623:   end : gen_mubi_en_pulse_copies
624: 
625:   prim_mubi4_sync #(
626:     .NumCopies(EsEnPulseCopies),
627:     .AsyncOn(0)
628:   ) u_prim_mubi4_sync_es_enable_pulse (
629:     .clk_i,
630:     .rst_ni,
631:     .mubi_i(mubi_module_en_pulse),
632:     .mubi_o(mubi_module_en_pulse_fanout)
633:   );
634: 
635:   entropy_src_enable_delay u_enable_delay (
636:     .clk_i,
637:     .rst_ni,
638:     .enable_i(es_enable_fo[0]),
639:     .esrng_fifo_not_empty_i(sfifo_esrng_not_empty),
640:     .esbit_fifo_not_empty_i(pfifo_esbit_not_empty),
641:     .postht_fifo_not_empty_i(pfifo_postht_not_empty),
642:     .distr_fifo_not_empty_i(sfifo_distr_not_empty),
643:     .cs_aes_halt_req_i(cs_aes_halt_req),
644:     .sha3_block_processed_i(sha3_block_processed),
645:     .bypass_mode_i(es_bypass_mode),
646:     .enable_o(es_delayed_enable)
647:   );
648: 
649:   mubi4_t mubi_fips_en;
650:   mubi4_t [1:0] mubi_fips_en_fanout;
651:   assign mubi_fips_en  = mubi4_t'(reg2hw.conf.fips_enable.q);
652:   assign fips_enable_pfe = mubi4_test_true_strict(mubi_fips_en_fanout[0]);
653:   assign fips_enable_pfa = mubi4_test_invalid(mubi_fips_en_fanout[1]);
654:   assign hw2reg.recov_alert_sts.fips_enable_field_alert.de = fips_enable_pfa;
655:   assign hw2reg.recov_alert_sts.fips_enable_field_alert.d  = fips_enable_pfa;
656: 
657:   prim_mubi4_sync #(
658:     .NumCopies(2),
659:     .AsyncOn(0)
660:   ) u_prim_mubi4_sync_entropy_fips_en (
661:     .clk_i,
662:     .rst_ni,
663:     .mubi_i(mubi_fips_en),
664:     .mubi_o(mubi_fips_en_fanout)
665:   );
666: 
667:   mubi4_t mubi_fips_flag;
668:   mubi4_t [1:0] mubi_fips_flag_fanout;
669:   assign mubi_fips_flag  = mubi4_t'(reg2hw.conf.fips_flag.q);
670:   assign fips_flag_pfa = mubi4_test_invalid(mubi_fips_flag_fanout[1]);
671:   assign fips_flag_pfe = mubi4_test_true_strict(mubi_fips_flag_fanout[0]);
672:   assign hw2reg.recov_alert_sts.fips_flag_field_alert.de = fips_flag_pfa;
673:   assign hw2reg.recov_alert_sts.fips_flag_field_alert.d  = fips_flag_pfa;
674: 
675:   prim_mubi4_sync #(
676:     .NumCopies(2),
677:     .AsyncOn(0)
678:   ) u_prim_mubi4_sync_entropy_fips_flag (
679:     .clk_i,
680:     .rst_ni,
681:     .mubi_i(mubi_fips_flag),
682:     .mubi_o(mubi_fips_flag_fanout)
683:   );
684: 
685:   mubi4_t mubi_rng_fips;
686:   mubi4_t [1:0] mubi_rng_fips_fanout;
687:   assign mubi_rng_fips  = mubi4_t'(reg2hw.conf.rng_fips.q);
688:   assign rng_fips_pfa = mubi4_test_invalid(mubi_rng_fips_fanout[1]);
689:   assign rng_fips_pfe = prim_mubi_pkg::mubi4_test_true_loose(mubi_rng_fips_fanout[0]);
690:   assign hw2reg.recov_alert_sts.rng_fips_field_alert.de = rng_fips_pfa;
691:   assign hw2reg.recov_alert_sts.rng_fips_field_alert.d  = rng_fips_pfa;
692: 
693:   prim_mubi4_sync #(
694:     .NumCopies(2),
695:     .AsyncOn(0)
696:   ) u_prim_mubi4_sync_entropy_rng_fips (
697:     .clk_i,
698:     .rst_ni,
699:     .mubi_i(mubi_rng_fips),
700:     .mubi_o(mubi_rng_fips_fanout)
701:   );
702: 
703:   // SEC_CM: CONFIG.MUBI
704:   mubi4_t mubi_entropy_reg_en;
705:   mubi4_t [1:0] mubi_entropy_reg_en_fanout;
706:   assign mubi_entropy_reg_en = mubi4_t'(reg2hw.conf.entropy_data_reg_enable.q);
707:   assign entropy_data_reg_en_pfe = mubi4_test_true_strict(mubi_entropy_reg_en_fanout[0]);
708:   assign entropy_data_reg_en_pfa = mubi4_test_invalid(mubi_entropy_reg_en_fanout[1]);
709:   assign hw2reg.recov_alert_sts.entropy_data_reg_en_field_alert.de = entropy_data_reg_en_pfa;
710:   assign hw2reg.recov_alert_sts.entropy_data_reg_en_field_alert.d =  entropy_data_reg_en_pfa;
711: 
712:   prim_mubi4_sync #(
713:     .NumCopies(2),
714:     .AsyncOn(0)
715:   ) u_prim_mubi4_sync_entropy_data_reg_en (
716:     .clk_i,
717:     .rst_ni,
718:     .mubi_i(mubi_entropy_reg_en),
719:     .mubi_o(mubi_entropy_reg_en_fanout)
720:   );
721: 
722:   assign observe_fifo_thresh = reg2hw.observe_fifo_thresh.q;
723: 
724:   // SEC_CM: CONFIG.MUBI
725:   mubi4_t mubi_fw_ov_mode;
726:   mubi4_t [1:0] mubi_fw_ov_mode_fanout;
727:   assign mubi_fw_ov_mode = mubi4_t'(reg2hw.fw_ov_control.fw_ov_mode.q);
728:   assign fw_ov_mode_pfe = mubi4_test_true_strict(mubi_fw_ov_mode_fanout[0]);
729:   assign fw_ov_mode_pfa = mubi4_test_invalid(mubi_fw_ov_mode_fanout[1]);
730:   assign hw2reg.recov_alert_sts.fw_ov_mode_field_alert.de = fw_ov_mode_pfa;
731:   assign hw2reg.recov_alert_sts.fw_ov_mode_field_alert.d  = fw_ov_mode_pfa;
732: 
733:   prim_mubi4_sync #(
734:     .NumCopies(2),
735:     .AsyncOn(0)
736:   ) u_prim_mubi4_sync_fw_ov_mode (
737:     .clk_i,
738:     .rst_ni,
739:     .mubi_i(mubi_fw_ov_mode),
740:     .mubi_o(mubi_fw_ov_mode_fanout)
741:   );
742: 
743:   // SEC_CM: CONFIG.MUBI
744:   mubi4_t mubi_fw_ov_entropy_insert;
745:   mubi4_t [1:0] mubi_fw_ov_entropy_insert_fanout;
746:   assign mubi_fw_ov_entropy_insert = mubi4_t'(reg2hw.fw_ov_control.fw_ov_entropy_insert.q);
747:   assign fw_ov_entropy_insert_pfe = mubi4_test_true_strict(mubi_fw_ov_entropy_insert_fanout[0]);
748:   assign fw_ov_entropy_insert_pfa = mubi4_test_invalid(mubi_fw_ov_entropy_insert_fanout[1]);
749:   assign hw2reg.recov_alert_sts.fw_ov_entropy_insert_field_alert.de = fw_ov_entropy_insert_pfa;
750:   assign hw2reg.recov_alert_sts.fw_ov_entropy_insert_field_alert.d  = fw_ov_entropy_insert_pfa;
751: 
752:   prim_mubi4_sync #(
753:     .NumCopies(2),
754:     .AsyncOn(0)
755:   ) u_prim_mubi4_sync_fw_ov_entropy_insert (
756:     .clk_i,
757:     .rst_ni,
758:     .mubi_i(mubi_fw_ov_entropy_insert),
759:     .mubi_o(mubi_fw_ov_entropy_insert_fanout)
760:   );
761: 
762:   // SEC_CM: CONFIG.MUBI
763:   mubi4_t mubi_fw_ov_sha3_start;
764:   mubi4_t [1:0] mubi_fw_ov_sha3_start_fanout;
765:   assign mubi_fw_ov_sha3_start = mubi4_t'(reg2hw.fw_ov_sha3_start.q);
766:   assign fw_ov_sha3_start_pfe = mubi4_test_true_strict(mubi_fw_ov_sha3_start_fanout[0]);
767:   assign fw_ov_sha3_start_pfa = mubi4_test_invalid(mubi_fw_ov_sha3_start_fanout[1]);
768:   assign hw2reg.recov_alert_sts.fw_ov_sha3_start_field_alert.de = fw_ov_sha3_start_pfa;
769:   assign hw2reg.recov_alert_sts.fw_ov_sha3_start_field_alert.d  = fw_ov_sha3_start_pfa;
770: 
771:   prim_mubi4_sync #(
772:     .NumCopies(2),
773:     .AsyncOn(0)
774:   ) u_prim_mubi4_sync_fw_ov_sha3_start (
775:     .clk_i,
776:     .rst_ni,
777:     .mubi_i(mubi_fw_ov_sha3_start),
778:     .mubi_o(mubi_fw_ov_sha3_start_fanout)
779:   );
780: 
781:   // firmware override controls
782:   assign fw_ov_mode = efuse_es_sw_ov_en && fw_ov_mode_pfe;
783:   assign fw_ov_mode_entropy_insert = fw_ov_mode && fw_ov_entropy_insert_pfe;
784:   assign fw_ov_fifo_rd_pulse = reg2hw.fw_ov_rd_data.re;
785:   assign hw2reg.fw_ov_rd_data.d = sfifo_observe_rdata;
786:   assign fw_ov_fifo_wr_pulse = reg2hw.fw_ov_wr_data.qe;
787:   assign fw_ov_wr_data = reg2hw.fw_ov_wr_data.q;
788: 
789:   assign efuse_es_sw_ov_en = prim_mubi_pkg::mubi8_test_true_strict(en_entropy_src_fw_over);
790: 
791:   prim_mubi8_sync #(
792:     .NumCopies(1),
793:     .AsyncOn(1) // must be set to one, see note below
794:   ) u_prim_mubi8_sync_es_fw_over (
795:     .clk_i,
796:     .rst_ni,
797:     .mubi_i(otp_en_entropy_src_fw_over_i),
798:     .mubi_o({en_entropy_src_fw_over})
799:   );
800: 
801:   // note: the input to the above sync module is from the OTP block.
802:   //       It is assumed that the source is in a different time domain,
803:   //       and requires the AsyncOn parameter to be set.
804: 
805:   // rng_enable is being used in other clock domains. Need to latch the
806:   // signal.
807:   assign rng_enable_d = es_enable_fo[1] &&
808:                         es_delayed_enable;
809: 
810:   assign entropy_src_rng_o.rng_enable = rng_enable_q;
811: 
812:   // Enhanced validation with additional configuration checks 
813:   assign es_rng_src_valid = entropy_src_rng_i.rng_valid & 
814:                          (reg2hw.conf.entropy_data_reg_enable.q != '0);
815:   assign es_rng_bus = entropy_src_rng_i.rng_b;
816: 
817: 
818:   //--------------------------------------------
819:   // instantiate interrupt hardware primitives
820:   //--------------------------------------------
821: 
822:   prim_intr_hw #(
823:     .Width(1)
824:   ) u_intr_hw_es_entropy_valid (
825:     .clk_i                  (clk_i),
826:     .rst_ni                 (rst_ni),
827:     .event_intr_i           (event_es_entropy_valid),
828:     .reg2hw_intr_enable_q_i (reg2hw.intr_enable.es_entropy_valid.q),
829:     .reg2hw_intr_test_q_i   (reg2hw.intr_test.es_entropy_valid.q),
830:     .reg2hw_intr_test_qe_i  (reg2hw.intr_test.es_entropy_valid.qe),
831:     .reg2hw_intr_state_q_i  (reg2hw.intr_state.es_entropy_valid.q),
832:     .hw2reg_intr_state_de_o (hw2reg.intr_state.es_entropy_valid.de),
833:     .hw2reg_intr_state_d_o  (hw2reg.intr_state.es_entropy_valid.d),
834:     .intr_o                 (intr_es_entropy_valid_o)
835:   );
836: 
837:   prim_intr_hw #(
838:     .Width(1)
839:   ) u_intr_hw_es_health_test_failed (
840:     .clk_i                  (clk_i),
841:     .rst_ni                 (rst_ni),
842:     .event_intr_i           (event_es_health_test_failed),
843:     .reg2hw_intr_enable_q_i (reg2hw.intr_enable.es_health_test_failed.q),
844:     .reg2hw_intr_test_q_i   (reg2hw.intr_test.es_health_test_failed.q),
845:     .reg2hw_intr_test_qe_i  (reg2hw.intr_test.es_health_test_failed.qe),
846:     .reg2hw_intr_state_q_i  (reg2hw.intr_state.es_health_test_failed.q),
847:     .hw2reg_intr_state_de_o (hw2reg.intr_state.es_health_test_failed.de),
848:     .hw2reg_intr_state_d_o  (hw2reg.intr_state.es_health_test_failed.d),
849:     .intr_o                 (intr_es_health_test_failed_o)
850:   );
851: 
852: 
853:   prim_intr_hw #(
854:     .Width(1)
855:   ) u_intr_hw_es_observe_fifo_ready (
856:     .clk_i                  (clk_i),
857:     .rst_ni                 (rst_ni),
858:     .event_intr_i           (event_es_observe_fifo_ready),
859:     .reg2hw_intr_enable_q_i (reg2hw.intr_enable.es_observe_fifo_ready.q),
860:     .reg2hw_intr_test_q_i   (reg2hw.intr_test.es_observe_fifo_ready.q),
861:     .reg2hw_intr_test_qe_i  (reg2hw.intr_test.es_observe_fifo_ready.qe),
862:     .reg2hw_intr_state_q_i  (reg2hw.intr_state.es_observe_fifo_ready.q),
863:     .hw2reg_intr_state_de_o (hw2reg.intr_state.es_observe_fifo_ready.de),
864:     .hw2reg_intr_state_d_o  (hw2reg.intr_state.es_observe_fifo_ready.d),
865:     .intr_o                 (intr_es_observe_fifo_ready_o)
866:   );
867: 
868:   prim_intr_hw #(
869:     .Width(1)
870:   ) u_intr_hw_es_fatal_err (
871:     .clk_i                  (clk_i),
872:     .rst_ni                 (rst_ni),
873:     .event_intr_i           (event_es_fatal_err),
874:     .reg2hw_intr_enable_q_i (reg2hw.intr_enable.es_fatal_err.q),
875:     .reg2hw_intr_test_q_i   (reg2hw.intr_test.es_fatal_err.q),
876:     .reg2hw_intr_test_qe_i  (reg2hw.intr_test.es_fatal_err.qe),
877:     .reg2hw_intr_state_q_i  (reg2hw.intr_state.es_fatal_err.q),
878:     .hw2reg_intr_state_de_o (hw2reg.intr_state.es_fatal_err.de),
879:     .hw2reg_intr_state_d_o  (hw2reg.intr_state.es_fatal_err.d),
880:     .intr_o                 (intr_es_fatal_err_o)
881:   );
882: 
883:   //--------------------------------------------
884:   // tlul register settings
885:   //--------------------------------------------
886: 
887: 
888:   // set the interrupt event when enabled
889:   assign event_es_entropy_valid =
890:       sfifo_esfinal_not_empty && es_route_to_sw && es_data_reg_rd_en && es_enable_fo[2];
891: 
892: 
893:   // Collect all internal FIFO errors.
894:   assign es_sfifo_int_err = sfifo_esrng_int_err ||
895:                             sfifo_distr_int_err ||
896:                             sfifo_observe_int_err ||
897:                             sfifo_esfinal_int_err;
898: 
899:   // Counter, internal FIFO errors and FSM errors are structural errors and are always active
900:   // regardless of the functional state.
901:   logic fatal_loc_events;
902:   assign fatal_loc_events = es_cntr_err_sum ||
903:                             es_sfifo_int_err ||
904:                             es_main_sm_err_sum ||
905:                             es_ack_sm_err_sum ||
906:                             sha3_state_error_sum;
907: 
908:   // set the interrupt sources
909:   assign event_es_fatal_err = (es_enable_fo[3] &&
910:                                  (sfifo_esrng_err_sum   ||
911:                                   sfifo_distr_err_sum   ||
912:                                   sfifo_observe_err_sum ||
913:                                   sfifo_esfinal_err_sum ||
914:                                   sfifo_test_err_sum) ) ||
915:                               sha3_rst_storage_err_sum ||
916:                               fatal_loc_events;
917: 
918:   // set fifo errors that are single instances of source
919:   assign sfifo_esrng_err_sum = (|sfifo_esrng_err) ||
920:          err_code_test_bit[0];
921:   assign sfifo_distr_err_sum = (|sfifo_distr_err) ||
922:          err_code_test_bit[1];
923:   assign sfifo_observe_err_sum = (|sfifo_observe_err) ||
924:          err_code_test_bit[2];
925:   assign sfifo_esfinal_err_sum = (|sfifo_esfinal_err) ||
926:          err_code_test_bit[3];
927: 
928:   // The following test bits help normally diagnose the _type_ of
929:   // error when they are triggred by the fifo. However when
930:   // they are triggered by softwre they are not linked to a
931:   // particular sfifo and do not trigger an alert, unless
932:   // we capture them here.
933:   assign sfifo_test_err_sum = err_code_test_bit[28] ||
934:                               err_code_test_bit[29] ||
935:                               err_code_test_bit[30];
936: 
937:   assign es_ack_sm_err_sum = es_ack_sm_err ||
938:          err_code_test_bit[20];
939:   assign es_main_sm_err_sum = es_main_sm_err ||
940:          err_code_test_bit[21];
941:   assign es_cntr_err_sum = es_cntr_err ||
942:          err_code_test_bit[22];
943:   assign sha3_state_error_sum = sha3_state_error ||
944:          err_code_test_bit[23];
945:   assign sha3_rst_storage_err_sum = sha3_rst_storage_err ||
946:          err_code_test_bit[24];
947:   assign fifo_write_err_sum =
948:          sfifo_esrng_err[2] ||
949:          sfifo_observe_err[2] ||
950:          sfifo_esfinal_err[2] ||
951:          err_code_test_bit[28];
952:   assign fifo_read_err_sum =
953:          sfifo_esrng_err[1] ||
954:          sfifo_observe_err[1] ||
955:          sfifo_esfinal_err[1] ||
956:          err_code_test_bit[29];
957:   assign fifo_status_err_sum =
958:          sfifo_esrng_err[0] ||
959:          sfifo_observe_err[0] ||
960:          sfifo_esfinal_err[0] ||
961:          err_code_test_bit[30];
962: 
963:   // set the err code source bits
964:   assign hw2reg.err_code.sfifo_esrng_err.d = 1'b1;
965:   assign hw2reg.err_code.sfifo_esrng_err.de = sfifo_esrng_err_sum;
966: 
967:   assign hw2reg.err_code.sfifo_distr_err.d = 1'b1;
968:   assign hw2reg.err_code.sfifo_distr_err.de = sfifo_distr_err_sum;
969: 
970:   assign hw2reg.err_code.sfifo_observe_err.d = 1'b1;
971:   assign hw2reg.err_code.sfifo_observe_err.de = sfifo_observe_err_sum;
972: 
973:   assign hw2reg.err_code.sfifo_esfinal_err.d = 1'b1;
974:   assign hw2reg.err_code.sfifo_esfinal_err.de = sfifo_esfinal_err_sum;
975: 
976:   assign hw2reg.err_code.es_ack_sm_err.d = 1'b1;
977:   assign hw2reg.err_code.es_ack_sm_err.de = es_ack_sm_err_sum;
978: 
979:   assign hw2reg.err_code.es_main_sm_err.d = 1'b1;
980:   assign hw2reg.err_code.es_main_sm_err.de = es_main_sm_err_sum;
981: 
982:   assign hw2reg.err_code.es_cntr_err.d = 1'b1;
983:   assign hw2reg.err_code.es_cntr_err.de = es_cntr_err_sum;
984: 
985:   assign hw2reg.err_code.sha3_state_err.d = 1'b1;
986:   assign hw2reg.err_code.sha3_state_err.de = sha3_state_error_sum;
987: 
988:   assign hw2reg.err_code.sha3_rst_storage_err.d = 1'b1;
989:   assign hw2reg.err_code.sha3_rst_storage_err.de = sha3_rst_storage_err_sum;
990: 
991: 
992:  // set the err code type bits
993:   assign hw2reg.err_code.fifo_write_err.d = 1'b1;
994:   assign hw2reg.err_code.fifo_write_err.de = fifo_write_err_sum;
995: 
996:   assign hw2reg.err_code.fifo_read_err.d = 1'b1;
997:   assign hw2reg.err_code.fifo_read_err.de = fifo_read_err_sum;
998: 
999:   assign hw2reg.err_code.fifo_state_err.d = 1'b1;
1000:   assign hw2reg.err_code.fifo_state_err.de = fifo_status_err_sum;
1001: 
1002:   // Error forcing
1003:   for (genvar i = 0; i < 31; i = i+1) begin : gen_err_code_test_bit
1004:     assign err_code_test_bit[i] = (reg2hw.err_code_test.q == i) && reg2hw.err_code_test.qe;
1005:   end : gen_err_code_test_bit
1006: 
1007:   // alert - send all interrupt sources to the alert for the fatal case
1008:   assign fatal_alert_o = (event_es_fatal_err |
1009:                           sfifo_distr_int_err | sfifo_esrng_int_err |
1010:                           sfifo_observe_int_err | sfifo_esfinal_int_err);
1011: 
1012:   // alert test
1013:   assign recov_alert_test_o = {
1014:     reg2hw.alert_test.recov_alert.q &&
1015:     reg2hw.alert_test.recov_alert.qe
1016:   };
1017:   assign fatal_alert_test_o = {
1018:     reg2hw.alert_test.fatal_alert.q &&
1019:     reg2hw.alert_test.fatal_alert.qe
1020:   };
1021: 
1022: 
1023:   // set the debug status reg
1024:   assign hw2reg.debug_status.entropy_fifo_depth.d = sfifo_esfinal_depth;
1025:   assign hw2reg.debug_status.sha3_fsm.d = sha3_fsm;
1026:   assign hw2reg.debug_status.sha3_block_pr.d = sha3_block_processed;
1027:   assign hw2reg.debug_status.sha3_squeezing.d = sha3_squeezing;
1028:   assign hw2reg.debug_status.sha3_absorbed.d =
1029:     prim_mubi_pkg::mubi4_test_true_strict(sha3_absorbed) ? 1'b 1 : 1'b 0;
1030:   assign hw2reg.debug_status.sha3_err.d = sha3_err_q;
1031: 
1032:   assign sha3_err_d =
1033:          es_enable_fo[4] ? 1'b0 :
1034:          {|sha3_err} ? 1'b1 :
1035:          sha3_err_q;
1036: 
1037:   // state machine status
1038:   assign hw2reg.debug_status.main_sm_idle.d = es_main_sm_idle;
1039:   assign hw2reg.debug_status.main_sm_boot_done.d = boot_phase_done;
1040:   assign hw2reg.main_sm_state.de = 1'b1;
1041:   assign hw2reg.main_sm_state.d = es_main_sm_state;
1042: 
1043:   // fw override wr data status indication
1044:   assign fw_ov_wr_fifo_full = fw_ov_mode_entropy_insert &&
1045:                               (es_bypass_mode ? !pfifo_bypass_not_full : !pfifo_precon_not_full);
1046: 
1047:   assign hw2reg.fw_ov_wr_fifo_full.d = fw_ov_wr_fifo_full;
1048: 
1049: 
1050:   //--------------------------------------------
1051:   // receive in RNG bus input
1052:   //--------------------------------------------
1053: 
1054:   // SEC_CM: FIFO.CTR.REDUN
1055:   prim_fifo_sync #(
1056:     .Width(RngBusWidth),
1057:     .Pass(0),
1058:     .Depth(2),
1059:     .OutputZeroIfEmpty(0),
1060:     .Secure(1)
1061:   ) u_prim_fifo_sync_esrng (
1062:     .clk_i      (clk_i),
1063:     .rst_ni     (rst_ni),
1064:     .clr_i      (sfifo_esrng_clr),
1065:     .wvalid_i   (sfifo_esrng_push),
1066:     .wdata_i    (sfifo_esrng_wdata),
1067:     .wready_o   (sfifo_esrng_not_full),
1068:     .rvalid_o   (sfifo_esrng_not_empty),
1069:     .rdata_o    (sfifo_esrng_rdata),
1070:     .rready_i   (sfifo_esrng_pop),
1071:     .full_o     (sfifo_esrng_full),
1072:     .depth_o    (),
1073:     .err_o      (sfifo_esrng_int_err)
1074:   );
1075: 
1076:   // fifo controls
1077:   // We can't handle any backpressure at this point. Unless the ENTROPY_SRC block is turned off,
1078:   // the input coming from the noise source / RNG needs to be accepted without dropping samples.
1079:   assign sfifo_esrng_push = es_enable_fo[5] && es_delayed_enable && es_rng_src_valid &&
1080:                             rng_enable_q;
1081: 
1082:   assign sfifo_esrng_clr   = ~es_delayed_enable;
1083:   assign sfifo_esrng_wdata = es_rng_bus;
1084:   // We can't apply any backpressure at this point. Every sample is presented to the health tests
1085:   // for exactly one clock cycle. If the receiving FIFO is full, the sample is dropped but the
1086:   // health tests are still performed and the results accumulated.
1087:   assign sfifo_esrng_pop = sfifo_esrng_not_empty;
1088: 
1089:   // fifo err
1090:   // The esnrg FIFO must never be pushed when it's full as no backpressure can be applied to the
1091:   // noise source / RNG. However, we can't raise an error and abort operation of the ENTROPY_SRC
1092:   // block as this would mean a catastrophic failure of the whole chip. Instead we need to catch
1093:   // this in simulation only.
1094:   assign sfifo_esrng_err =
1095:          {1'b0,
1096:           (sfifo_esrng_pop && !sfifo_esrng_not_empty),
1097:           (sfifo_esrng_full && !sfifo_esrng_not_empty) || sfifo_esrng_int_err};
1098:   `ASSERT(RngBackpressureNotAllowed_A, sfifo_esrng_push |-> sfifo_esrng_not_full)
1099: 
1100:   // Read the health test data from the esrng FIFO.
1101:   assign health_test_esbus = sfifo_esrng_rdata;
1102:   // Perform the health tests whenever data is valid and the receiving FIFO is not being cleared.
1103:   // This doesn't mean the receiving FIFO is pushed. The receiving FIFO is only pushed if it has
1104:   // indeed space. This means in case of heavy backpressure, we keep testing the noise source
1105:   // samples, but we drop them before the postht FIFO. If this happens, the window counter isn't
1106:   // incremented. This way we can keep the number of bits going into the conditioner constant,
1107:   // independent of potential backpressure within the pipeline.
1108:   assign health_test_esbus_vld =
1109:       rng_bit_en ? sfifo_esrng_not_empty && !pfifo_esbit_clr :
1110:                    sfifo_esrng_not_empty && !pfifo_postht_clr;
1111: 
1112:   // Health test any data that comes in on the RNG interface.
1113:   assign repcnt_active = 1'b1;
1114:   assign repcnts_active = 1'b1;
1115:   assign adaptp_active = 1'b1;
1116:   assign bucket_active = 1'b1;
1117:   assign markov_active = 1'b1;
1118:   assign extht_active = 1'b1;
1119: 
1120:   // Only reset health tests on re-enable
1121:   assign health_test_clr = module_en_pulse_fo[0];
1122: 
1123:   assign health_test_fips_window = reg2hw.health_test_windows.fips_window.q;
1124:   assign health_test_bypass_window = reg2hw.health_test_windows.bypass_window.q;
1125: 
1126:   assign repcnt_fips_threshold = reg2hw.repcnt_thresholds.fips_thresh.q;
1127:   assign repcnt_fips_threshold_wr = reg2hw.repcnt_thresholds.fips_thresh.qe;
1128:   assign hw2reg.repcnt_thresholds.fips_thresh.d = repcnt_fips_threshold_oneway;
1129:   assign repcnt_bypass_threshold = reg2hw.repcnt_thresholds.bypass_thresh.q;
1130:   assign repcnt_bypass_threshold_wr = reg2hw.repcnt_thresholds.bypass_thresh.qe;
1131:   assign hw2reg.repcnt_thresholds.bypass_thresh.d = repcnt_bypass_threshold_oneway;
1132: 
1133:   assign repcnts_fips_threshold = reg2hw.repcnts_thresholds.fips_thresh.q;
1134:   assign repcnts_fips_threshold_wr = reg2hw.repcnts_thresholds.fips_thresh.qe;
1135:   assign hw2reg.repcnts_thresholds.fips_thresh.d = repcnts_fips_threshold_oneway;
1136:   assign repcnts_bypass_threshold = reg2hw.repcnts_thresholds.bypass_thresh.q;
1137:   assign repcnts_bypass_threshold_wr = reg2hw.repcnts_thresholds.bypass_thresh.qe;
1138:   assign hw2reg.repcnts_thresholds.bypass_thresh.d = repcnts_bypass_threshold_oneway;
1139: 
1140: 
1141:   assign adaptp_hi_fips_threshold = reg2hw.adaptp_hi_thresholds.fips_thresh.q;
1142:   assign adaptp_hi_fips_threshold_wr = reg2hw.adaptp_hi_thresholds.fips_thresh.qe;
1143:   assign hw2reg.adaptp_hi_thresholds.fips_thresh.d = adaptp_hi_fips_threshold_oneway;
1144:   assign adaptp_hi_bypass_threshold = reg2hw.adaptp_hi_thresholds.bypass_thresh.q;
1145:   assign adaptp_hi_bypass_threshold_wr = reg2hw.adaptp_hi_thresholds.bypass_thresh.qe;
1146:   assign hw2reg.adaptp_hi_thresholds.bypass_thresh.d = adaptp_hi_bypass_threshold_oneway;
1147: 
1148:   assign adaptp_lo_fips_threshold = reg2hw.adaptp_lo_thresholds.fips_thresh.q;
1149:   assign adaptp_lo_fips_threshold_wr = reg2hw.adaptp_lo_thresholds.fips_thresh.qe;
1150:   assign hw2reg.adaptp_lo_thresholds.fips_thresh.d = adaptp_lo_fips_threshold_oneway;
1151:   assign adaptp_lo_bypass_threshold = reg2hw.adaptp_lo_thresholds.bypass_thresh.q;
1152:   assign adaptp_lo_bypass_threshold_wr = reg2hw.adaptp_lo_thresholds.bypass_thresh.qe;
1153:   assign hw2reg.adaptp_lo_thresholds.bypass_thresh.d = adaptp_lo_bypass_threshold_oneway;
1154: 
1155: 
1156:   assign bucket_fips_threshold = reg2hw.bucket_thresholds.fips_thresh.q;
1157:   assign bucket_fips_threshold_wr = reg2hw.bucket_thresholds.fips_thresh.qe;
1158:   assign hw2reg.bucket_thresholds.fips_thresh.d = bucket_fips_threshold_oneway;
1159:   assign bucket_bypass_threshold = reg2hw.bucket_thresholds.bypass_thresh.q;
1160:   assign bucket_bypass_threshold_wr = reg2hw.bucket_thresholds.bypass_thresh.qe;
1161:   assign hw2reg.bucket_thresholds.bypass_thresh.d = bucket_bypass_threshold_oneway;
1162: 
1163: 
1164:   assign markov_hi_fips_threshold = reg2hw.markov_hi_thresholds.fips_thresh.q;
1165:   assign markov_hi_fips_threshold_wr = reg2hw.markov_hi_thresholds.fips_thresh.qe;
1166:   assign hw2reg.markov_hi_thresholds.fips_thresh.d = markov_hi_fips_threshold_oneway;
1167:   assign markov_hi_bypass_threshold = reg2hw.markov_hi_thresholds.bypass_thresh.q;
1168:   assign markov_hi_bypass_threshold_wr = reg2hw.markov_hi_thresholds.bypass_thresh.qe;
1169:   assign hw2reg.markov_hi_thresholds.bypass_thresh.d = markov_hi_bypass_threshold_oneway;
1170: 
1171:   assign markov_lo_fips_threshold = reg2hw.markov_lo_thresholds.fips_thresh.q;
1172:   assign markov_lo_fips_threshold_wr = reg2hw.markov_lo_thresholds.fips_thresh.qe;
1173:   assign hw2reg.markov_lo_thresholds.fips_thresh.d = markov_lo_fips_threshold_oneway;
1174:   assign markov_lo_bypass_threshold = reg2hw.markov_lo_thresholds.bypass_thresh.q;
1175:   assign markov_lo_bypass_threshold_wr = reg2hw.markov_lo_thresholds.bypass_thresh.qe;
1176:   assign hw2reg.markov_lo_thresholds.bypass_thresh.d = markov_lo_bypass_threshold_oneway;
1177: 
1178: 
1179:   assign extht_hi_fips_threshold = reg2hw.extht_hi_thresholds.fips_thresh.q;
1180:   assign extht_hi_fips_threshold_wr = reg2hw.extht_hi_thresholds.fips_thresh.qe;
1181:   assign hw2reg.extht_hi_thresholds.fips_thresh.d = extht_hi_fips_threshold_oneway;
1182:   assign extht_hi_bypass_threshold = reg2hw.extht_hi_thresholds.bypass_thresh.q;
1183:   assign extht_hi_bypass_threshold_wr = reg2hw.extht_hi_thresholds.bypass_thresh.qe;
1184:   assign hw2reg.extht_hi_thresholds.bypass_thresh.d = extht_hi_bypass_threshold_oneway;
1185: 
1186:   assign extht_lo_fips_threshold = reg2hw.extht_lo_thresholds.fips_thresh.q;
1187:   assign extht_lo_fips_threshold_wr = reg2hw.extht_lo_thresholds.fips_thresh.qe;
1188:   assign hw2reg.extht_lo_thresholds.fips_thresh.d = extht_lo_fips_threshold_oneway;
1189:   assign extht_lo_bypass_threshold = reg2hw.extht_lo_thresholds.bypass_thresh.q;
1190:   assign extht_lo_bypass_threshold_wr = reg2hw.extht_lo_thresholds.bypass_thresh.qe;
1191:   assign hw2reg.extht_lo_thresholds.bypass_thresh.d = extht_lo_bypass_threshold_oneway;
1192: 
1193: 
1194:   assign health_test_window = es_bypass_mode ? health_test_bypass_window : health_test_fips_window;
1195:   // Multiply the health test window by four if we are using the single lane mode.
1196:   // In single lane mode 4 times as many symbols are tested for the same amount of entropy.
1197:   assign health_test_window_scaled = rng_bit_en ? {health_test_window, 2'b0} :
1198:                                                   {2'b0, health_test_window};
1199: 
1200:   // Window sizes other than 384 bits (the seed length) are currently not tested nor supported in
1201:   // bypass or boot-time mode.
1202:   `ASSERT(EsBootTimeHtWindowSizeSupported_A,
1203:       main_sm_enable && es_bypass_mode && !fw_ov_mode_entropy_insert
1204:       |-> health_test_bypass_window == HalfRegWidth'(SeedLen/4))
1205: 
1206:   //------------------------------
1207:   // repcnt one-way thresholds
1208:   //------------------------------
1209:   assign repcnt_threshold = es_bypass_mode ? repcnt_bypass_threshold_oneway :
1210:          repcnt_fips_threshold_oneway;
1211: 
1212:   entropy_src_watermark_reg #(
1213:     .RegWidth(HalfRegWidth),
1214:     .HighWatermark(0)
1215:   ) u_entropy_src_watermark_reg_repcnt_thresh_fips (
1216:     .clk_i               (clk_i),
1217:     .rst_ni              (rst_ni),
1218:     .clear_i             (1'b0),
1219:     .event_i             (repcnt_fips_threshold_wr),
1220:     .value_i             (repcnt_fips_threshold),
1221:     .value_o             (repcnt_fips_threshold_oneway)
1222:   );
1223: 
1224:   entropy_src_watermark_reg #(
1225:     .RegWidth(HalfRegWidth),
1226:     .HighWatermark(0)
1227:   ) u_entropy_src_watermark_reg_repcnt_thresh_bypass (
1228:     .clk_i               (clk_i),
1229:     .rst_ni              (rst_ni),
1230:     .clear_i             (1'b0),
1231:     .event_i             (repcnt_bypass_threshold_wr),
1232:     .value_i             (repcnt_bypass_threshold),
1233:     .value_o             (repcnt_bypass_threshold_oneway)
1234:   );
1235: 
1236:   //------------------------------
1237:   // repcnts one-way thresholds
1238:   //------------------------------
1239:   assign repcnts_threshold = es_bypass_mode ? repcnts_bypass_threshold_oneway :
1240:          repcnts_fips_threshold_oneway;
1241: 
1242:   entropy_src_watermark_reg #(
1243:     .RegWidth(HalfRegWidth),
1244:     .HighWatermark(0)
1245:   ) u_entropy_src_watermark_reg_repcnts_thresh_fips (
1246:     .clk_i               (clk_i),
1247:     .rst_ni              (rst_ni),
1248:     .clear_i             (1'b0),
1249:     .event_i             (repcnts_fips_threshold_wr),
1250:     .value_i             (repcnts_fips_threshold),
1251:     .value_o             (repcnts_fips_threshold_oneway)
1252:   );
1253: 
1254:   entropy_src_watermark_reg #(
1255:     .RegWidth(HalfRegWidth),
1256:     .HighWatermark(0)
1257:   ) u_entropy_src_watermark_reg_repcnts_thresh_bypass (
1258:     .clk_i               (clk_i),
1259:     .rst_ni              (rst_ni),
1260:     .clear_i             (1'b0),
1261:     .event_i             (repcnts_bypass_threshold_wr),
1262:     .value_i             (repcnts_bypass_threshold),
1263:     .value_o             (repcnts_bypass_threshold_oneway)
1264:   );
1265: 
1266: 
1267:   //------------------------------
1268:   // adaptp one-way thresholds
1269:   //------------------------------
1270:   assign adaptp_hi_threshold = es_bypass_mode ? adaptp_hi_bypass_threshold_oneway :
1271:          adaptp_hi_fips_threshold_oneway;
1272: 
1273:   entropy_src_watermark_reg #(
1274:     .RegWidth(HalfRegWidth),
1275:     .HighWatermark(0)
1276:   ) u_entropy_src_watermark_reg_adaptp_hi_thresh_fips (
1277:     .clk_i               (clk_i),
1278:     .rst_ni              (rst_ni),
1279:     .clear_i             (1'b0),
1280:     .event_i             (adaptp_hi_fips_threshold_wr),
1281:     .value_i             (adaptp_hi_fips_threshold),
1282:     .value_o             (adaptp_hi_fips_threshold_oneway)
1283:   );
1284: 
1285:   entropy_src_watermark_reg #(
1286:     .RegWidth(HalfRegWidth),
1287:     .HighWatermark(0)
1288:   ) u_entropy_src_watermark_reg_adaptp_hi_thresh_bypass (
1289:     .clk_i               (clk_i),
1290:     .rst_ni              (rst_ni),
1291:     .clear_i             (1'b0),
1292:     .event_i             (adaptp_hi_bypass_threshold_wr),
1293:     .value_i             (adaptp_hi_bypass_threshold),
1294:     .value_o             (adaptp_hi_bypass_threshold_oneway)
1295:   );
1296: 
1297:   assign adaptp_lo_threshold = es_bypass_mode ? adaptp_lo_bypass_threshold_oneway :
1298:          adaptp_lo_fips_threshold_oneway;
1299: 
1300:   entropy_src_watermark_reg #(
1301:     .RegWidth(HalfRegWidth),
1302:     .HighWatermark(1)
1303:   ) u_entropy_src_watermark_reg_adaptp_lo_thresh_fips (
1304:     .clk_i               (clk_i),
1305:     .rst_ni              (rst_ni),
1306:     .clear_i             (1'b0),
1307:     .event_i             (adaptp_lo_fips_threshold_wr),
1308:     .value_i             (adaptp_lo_fips_threshold),
1309:     .value_o             (adaptp_lo_fips_threshold_oneway)
1310:   );
1311: 
1312:   entropy_src_watermark_reg #(
1313:     .RegWidth(HalfRegWidth),
1314:     .HighWatermark(1)
1315:   ) u_entropy_src_watermark_reg_adaptp_lo_thresh_bypass (
1316:     .clk_i               (clk_i),
1317:     .rst_ni              (rst_ni),
1318:     .clear_i             (1'b0),
1319:     .event_i             (adaptp_lo_bypass_threshold_wr),
1320:     .value_i             (adaptp_lo_bypass_threshold),
1321:     .value_o             (adaptp_lo_bypass_threshold_oneway)
1322:   );
1323: 
1324: 
1325:   //------------------------------
1326:   // bucket one-way thresholds
1327:   //------------------------------
1328:   assign bucket_threshold = es_bypass_mode ? bucket_bypass_threshold_oneway :
1329:          bucket_fips_threshold_oneway;
1330: 
1331:   entropy_src_watermark_reg #(
1332:     .RegWidth(HalfRegWidth),
1333:     .HighWatermark(0)
1334:   ) u_entropy_src_watermark_reg_bucket_thresh_fips (
1335:     .clk_i               (clk_i),
1336:     .rst_ni              (rst_ni),
1337:     .clear_i             (1'b0),
1338:     .event_i             (bucket_fips_threshold_wr),
1339:     .value_i             (bucket_fips_threshold),
1340:     .value_o             (bucket_fips_threshold_oneway)
1341:   );
1342: 
1343:   entropy_src_watermark_reg #(
1344:     .RegWidth(HalfRegWidth),
1345:     .HighWatermark(0)
1346:   ) u_entropy_src_watermark_reg_bucket_thresh_bypass (
1347:     .clk_i               (clk_i),
1348:     .rst_ni              (rst_ni),
1349:     .clear_i             (1'b0),
1350:     .event_i             (bucket_bypass_threshold_wr),
1351:     .value_i             (bucket_bypass_threshold),
1352:     .value_o             (bucket_bypass_threshold_oneway)
1353:   );
1354: 
1355: 
1356:   //------------------------------
1357:   // markov one-way thresholds
1358:   //------------------------------
1359:   assign markov_hi_threshold = es_bypass_mode ? markov_hi_bypass_threshold_oneway :
1360:          markov_hi_fips_threshold_oneway;
1361: 
1362:   entropy_src_watermark_reg #(
1363:     .RegWidth(HalfRegWidth),
1364:     .HighWatermark(0)
1365:   ) u_entropy_src_watermark_reg_markov_hi_thresh_fips (
1366:     .clk_i               (clk_i),
1367:     .rst_ni              (rst_ni),
1368:     .clear_i             (1'b0),
1369:     .event_i             (markov_hi_fips_threshold_wr),
1370:     .value_i             (markov_hi_fips_threshold),
1371:     .value_o             (markov_hi_fips_threshold_oneway)
1372:   );
1373: 
1374:   entropy_src_watermark_reg #(
1375:     .RegWidth(HalfRegWidth),
1376:     .HighWatermark(0)
1377:   ) u_entropy_src_watermark_reg_markov_hi_thresh_bypass (
1378:     .clk_i               (clk_i),
1379:     .rst_ni              (rst_ni),
1380:     .clear_i             (1'b0),
1381:     .event_i             (markov_hi_bypass_threshold_wr),
1382:     .value_i             (markov_hi_bypass_threshold),
1383:     .value_o             (markov_hi_bypass_threshold_oneway)
1384:   );
1385: 
1386:   assign markov_lo_threshold = es_bypass_mode ? markov_lo_bypass_threshold_oneway :
1387:          markov_lo_fips_threshold_oneway;
1388: 
1389:   entropy_src_watermark_reg #(
1390:     .RegWidth(HalfRegWidth),
1391:     .HighWatermark(1)
1392:   ) u_entropy_src_watermark_reg_markov_lo_thresh_fips (
1393:     .clk_i               (clk_i),
1394:     .rst_ni              (rst_ni),
1395:     .clear_i             (1'b0),
1396:     .event_i             (markov_lo_fips_threshold_wr),
1397:     .value_i             (markov_lo_fips_threshold),
1398:     .value_o             (markov_lo_fips_threshold_oneway)
1399:   );
1400: 
1401:   entropy_src_watermark_reg #(
1402:     .RegWidth(HalfRegWidth),
1403:     .HighWatermark(1)
1404:   ) u_entropy_src_watermark_reg_markov_lo_thresh_bypass (
1405:     .clk_i               (clk_i),
1406:     .rst_ni              (rst_ni),
1407:     .clear_i             (1'b0),
1408:     .event_i             (markov_lo_bypass_threshold_wr),
1409:     .value_i             (markov_lo_bypass_threshold),
1410:     .value_o             (markov_lo_bypass_threshold_oneway)
1411:   );
1412: 
1413: 
1414:   //------------------------------
1415:   // extht one-way thresholds
1416:   //------------------------------
1417:   assign extht_hi_threshold = es_bypass_mode ? extht_hi_bypass_threshold_oneway :
1418:          extht_hi_fips_threshold_oneway;
1419: 
1420:   entropy_src_watermark_reg #(
1421:     .RegWidth(HalfRegWidth),
1422:     .HighWatermark(0)
1423:   ) u_entropy_src_watermark_reg_extht_hi_thresh_fips (
1424:     .clk_i               (clk_i),
1425:     .rst_ni              (rst_ni),
1426:     .clear_i             (1'b0),
1427:     .event_i             (extht_hi_fips_threshold_wr),
1428:     .value_i             (extht_hi_fips_threshold),
1429:     .value_o             (extht_hi_fips_threshold_oneway)
1430:   );
1431: 
1432:   entropy_src_watermark_reg #(
1433:     .RegWidth(HalfRegWidth),
1434:     .HighWatermark(0)
1435:   ) u_entropy_src_watermark_reg_extht_hi_thresh_bypass (
1436:     .clk_i               (clk_i),
1437:     .rst_ni              (rst_ni),
1438:     .clear_i             (1'b0),
1439:     .event_i             (extht_hi_bypass_threshold_wr),
1440:     .value_i             (extht_hi_bypass_threshold),
1441:     .value_o             (extht_hi_bypass_threshold_oneway)
1442:   );
1443: 
1444: 
1445:   assign extht_lo_threshold = es_bypass_mode ? extht_lo_bypass_threshold_oneway :
1446:          extht_lo_fips_threshold_oneway;
1447: 
1448:   entropy_src_watermark_reg #(
1449:     .RegWidth(HalfRegWidth),
1450:     .HighWatermark(1)
1451:   ) u_entropy_src_watermark_reg_extht_lo_thresh_fips (
1452:     .clk_i               (clk_i),
1453:     .rst_ni              (rst_ni),
1454:     .clear_i             (1'b0),
1455:     .event_i             (extht_lo_fips_threshold_wr),
1456:     .value_i             (extht_lo_fips_threshold),
1457:     .value_o             (extht_lo_fips_threshold_oneway)
1458:   );
1459: 
1460:   entropy_src_watermark_reg #(
1461:     .RegWidth(HalfRegWidth),
1462:     .HighWatermark(1)
1463:   ) u_entropy_src_watermark_reg_extht_lo_thresh_bypass (
1464:     .clk_i               (clk_i),
1465:     .rst_ni              (rst_ni),
1466:     .clear_i             (1'b0),
1467:     .event_i             (extht_lo_bypass_threshold_wr),
1468:     .value_i             (extht_lo_bypass_threshold),
1469:     .value_o             (extht_lo_bypass_threshold_oneway)
1470:   );
1471: 
1472: 
1473: 
1474:   //------------------------------
1475:   // misc control settings
1476:   //------------------------------
1477: 
1478:   assign event_es_health_test_failed = es_main_sm_alert;
1479: 
1480:   assign event_es_observe_fifo_ready = observe_fifo_thresh_met;
1481: 
1482:   // SEC_CM: CONFIG.MUBI
1483:   mubi4_t mubi_es_route;
1484:   mubi4_t [1:0] mubi_es_route_fanout;
1485:   assign mubi_es_route = mubi4_t'(reg2hw.entropy_control.es_route.q);
1486:   assign es_route_pfe = mubi4_test_true_strict(mubi_es_route_fanout[0]);
1487:   assign es_route_pfa = mubi4_test_invalid(mubi_es_route_fanout[1]);
1488:   assign hw2reg.recov_alert_sts.es_route_field_alert.de = es_route_pfa;
1489:   assign hw2reg.recov_alert_sts.es_route_field_alert.d  = es_route_pfa;
1490: 
1491:   prim_mubi4_sync #(
1492:     .NumCopies(2),
1493:     .AsyncOn(0)
1494:   ) u_prim_mubi4_sync_es_route (
1495:     .clk_i,
1496:     .rst_ni,
1497:     .mubi_i(mubi_es_route),
1498:     .mubi_o(mubi_es_route_fanout)
1499:   );
1500: 
1501:   // SEC_CM: CONFIG.MUBI
1502:   mubi4_t mubi_es_type;
1503:   mubi4_t [1:0] mubi_es_type_fanout;
1504:   assign mubi_es_type = mubi4_t'(reg2hw.entropy_control.es_type.q);
1505:   assign es_type_pfe = mubi4_test_true_strict(mubi_es_type_fanout[0]);
1506:   assign es_type_pfa = mubi4_test_invalid(mubi_es_type_fanout[1]);
1507:   assign hw2reg.recov_alert_sts.es_type_field_alert.de = es_type_pfa;
1508:   assign hw2reg.recov_alert_sts.es_type_field_alert.d  = es_type_pfa;
1509: 
1510:   prim_mubi4_sync #(
1511:     .NumCopies(2),
1512:     .AsyncOn(0)
1513:   ) u_prim_mubi4_sync_es_type (
1514:     .clk_i,
1515:     .rst_ni,
1516:     .mubi_i(mubi_es_type),
1517:     .mubi_o(mubi_es_type_fanout)
1518:   );
1519: 
1520:   // SEC_CM: CONFIG.MUBI
1521:   mubi4_t mubi_thresh_scope;
1522:   assign mubi_thresh_scope = mubi4_t'(reg2hw.conf.threshold_scope.q);
1523:   assign threshold_scope_pfe = mubi4_test_true_strict(mubi_thresh_scope);
1524:   assign threshold_scope_pfa = mubi4_test_invalid(mubi_thresh_scope);
1525:   assign hw2reg.recov_alert_sts.threshold_scope_field_alert.de = threshold_scope_pfa;
1526:   assign hw2reg.recov_alert_sts.threshold_scope_field_alert.d  = threshold_scope_pfa;
1527: 
1528:   assign es_route_to_sw = es_route_pfe;
1529:   assign es_bypass_to_sw = es_type_pfe;
1530:   assign threshold_scope = threshold_scope_pfe;
1531: 
1532:   // The es_bypass_mode signal determines whether the conditioner is bypassed or not.
1533:   // It also determines which thresholds are used and which watermarks are recorded.
1534:   // The conditioner can be bypassed by either disabling fips_enable_pfe or by enabling
1535:   // both es_bypass_to_sw and es_route_to_sw.
1536:   // The combination of es_bypass_to_sw and es_route_to_sw allows for four distinct cases:
1537:   //  _________________ ________________
1538:   // |                 |                |
1539:   // | es_bypass_to_sw | es_route_to_sw |
1540:   // |_________________|________________|
1541:   // |                 |                |
1542:   // |        0        |       0        | In this case the entropy passes through the conditioner
1543:   // |_________________|________________| and the entropy is forwarded to the HW endpoints.
1544:   // |                 |                |
1545:   // |        0        |       1        | In this case the entropy passes through the conditioner
1546:   // |_________________|________________| and the entropy is forwarded to software.
1547:   // |                 |                |
1548:   // |        1        |       0        | In this case nothing happens and whether the conditioner
1549:   // |_________________|________________| is bypassed solely depends on fips_enable_pfe.
1550:   // |                 |                |
1551:   // |        1        |       1        | In this case the conditioner is bypassed and the entropy
1552:   // |_________________|________________| is forwarded to software.
1553: 
1554:   assign es_bypass_mode = (!fips_enable_pfe) || (es_bypass_to_sw && es_route_to_sw);
1555: 
1556:   // send off to AST RNG for possibly faster entropy generation
1557:   assign rng_fips_o = rng_fips_pfe;
1558: 
1559:   //--------------------------------------------
1560:   // common health test window counter
1561:   //--------------------------------------------
1562: 
1563:   // Window counter
1564:   // SEC_CM: CTR.REDUN
1565: 
1566:   // We only increment the counter if the currently tested sample can be pushed to the correct FIFO
1567:   // following the health tests. This is required to keep the number of samples passed to the
1568:   // conditioner constant also when experiencing backpressure from the conditioner. At the same
1569:   // time, we're not allowed to drop samples before the health testing. This means the number of
1570:   // tested samples might be slightly bigger than the number of samples fed into the conditioner.
1571:   assign window_cntr_incr_en =
1572:       rng_bit_en ? pfifo_esbit_push  && pfifo_esbit_not_full  && !pfifo_esbit_clr :
1573:                    pfifo_postht_push && pfifo_postht_not_full && !pfifo_postht_clr;
1574: 
1575:   prim_count #(
1576:     .Width(WINDOW_CNTR_WIDTH)
1577:   ) u_prim_count_window_cntr (
1578:     .clk_i,
1579:     .rst_ni,
1580:     .clr_i(!es_delayed_enable),
1581:     .set_i(health_test_done_pulse),
1582:     .set_cnt_i(WINDOW_CNTR_WIDTH'(0)),
1583:     .incr_en_i(window_cntr_incr_en),
1584:     .decr_en_i(1'b0),
1585:     .step_i(WINDOW_CNTR_WIDTH'(1)),
1586:     .commit_i(1'b1),
1587:     .cnt_o(window_cntr),
1588:     .cnt_after_commit_o(),
1589:     .err_o(window_cntr_err)
1590:   );
1591: 
1592:   // Window wrap condition
1593:   assign health_test_done_pulse = (window_cntr >= health_test_window_scaled);
1594: 
1595:   // Summary of counter errors
1596:   assign es_cntr_err =
1597:          (window_cntr_err ||
1598:           repcnt_cntr_err ||
1599:           repcnts_cntr_err ||
1600:           adaptp_cntr_err ||
1601:           bucket_cntr_err ||
1602:           markov_cntr_err ||
1603:           repcnt_fails_cntr_err ||
1604:           repcnt_alert_cntr_err ||
1605:           repcnts_fails_cntr_err ||
1606:           repcnts_alert_cntr_err ||
1607:           adaptp_hi_fails_cntr_err ||
1608:           adaptp_lo_fails_cntr_err ||
1609:           adaptp_hi_alert_cntr_err ||
1610:           adaptp_lo_alert_cntr_err ||
1611:           bucket_fails_cntr_err ||
1612:           bucket_alert_cntr_err ||
1613:           markov_hi_fails_cntr_err ||
1614:           markov_lo_fails_cntr_err ||
1615:           markov_hi_alert_cntr_err ||
1616:           markov_lo_alert_cntr_err ||
1617:           extht_hi_fails_cntr_err ||
1618:           extht_lo_fails_cntr_err ||
1619:           extht_hi_alert_cntr_err ||
1620:           extht_lo_alert_cntr_err ||
1621:           any_fails_cntr_err ||
1622:           sha3_count_error);
1623: 
1624:   //--------------------------------------------
1625:   // repetitive count test
1626:   //--------------------------------------------
1627: 
1628:   // SEC_CM: RNG.BKGN_CHK
1629:   entropy_src_repcnt_ht #(
1630:     .RegWidth(HalfRegWidth),
1631:     .RngBusWidth(RngBusWidth)
1632:   ) u_entropy_src_repcnt_ht (
1633:     .clk_i               (clk_i),
1634:     .rst_ni              (rst_ni),
1635:     .entropy_bit_i       (health_test_esbus),
1636:     .entropy_bit_vld_i   (health_test_esbus_vld),
1637:     .rng_bit_en_i        (rng_bit_en),
1638:     .rng_bit_sel_i       (rng_bit_sel),
1639:     .clear_i             (health_test_clr),
1640:     .active_i            (repcnt_active),
1641:     .thresh_i            (repcnt_threshold),
1642:     .test_cnt_o          (repcnt_event_cnt),
1643:     .test_fail_pulse_o   (repcnt_fail_pulse),
1644:     .count_err_o         (repcnt_cntr_err)
1645:   );
1646: 
1647:   entropy_src_watermark_reg #(
1648:     .RegWidth(HalfRegWidth),
1649:     .HighWatermark(1)
1650:   ) u_entropy_src_watermark_reg_repcnt_fips (
1651:     .clk_i               (clk_i),
1652:     .rst_ni              (rst_ni),
1653:     .clear_i             (health_test_clr),
1654:     .event_i             (!es_bypass_mode),
1655:     .value_i             (repcnt_event_cnt),
1656:     .value_o             (repcnt_event_hwm_fips)
1657:   );
1658: 
1659:   entropy_src_watermark_reg #(
1660:     .RegWidth(HalfRegWidth),
1661:     .HighWatermark(1)
1662:   ) u_entropy_src_watermark_reg_repcnt_bypass (
1663:     .clk_i               (clk_i),
1664:     .rst_ni              (rst_ni),
1665:     .clear_i             (health_test_clr),
1666:     .event_i             (es_bypass_mode),
1667:     .value_i             (repcnt_event_cnt),
1668:     .value_o             (repcnt_event_hwm_bypass)
1669:   );
1670: 
1671:   // SEC_CM: CTR.REDUN
1672:   entropy_src_cntr_reg #(
1673:     .RegWidth(FullRegWidth)
1674:   ) u_entropy_src_cntr_reg_repcnt (
1675:     .clk_i               (clk_i),
1676:     .rst_ni              (rst_ni),
1677:     .clear_i             (health_test_clr),
1678:     .event_i             (repcnt_fail_pulse),
1679:     .value_o             (repcnt_total_fails),
1680:     .err_o               (repcnt_fails_cntr_err)
1681:   );
1682: 
1683:   assign hw2reg.repcnt_hi_watermarks.fips_watermark.d = repcnt_event_hwm_fips;
1684:   assign hw2reg.repcnt_hi_watermarks.bypass_watermark.d = repcnt_event_hwm_bypass;
1685:   assign hw2reg.repcnt_total_fails.d = repcnt_total_fails;
1686: 
1687:   //--------------------------------------------
1688:   // repetitive count symbol test
1689:   //--------------------------------------------
1690: 
1691:   // SEC_CM: RNG.BKGN_CHK
1692:   entropy_src_repcnts_ht #(
1693:     .RegWidth(HalfRegWidth),
1694:     .RngBusWidth(RngBusWidth)
1695:   ) u_entropy_src_repcnts_ht (
1696:     .clk_i               (clk_i),
1697:     .rst_ni              (rst_ni),
1698:     .entropy_bit_i       (health_test_esbus),
1699:     .entropy_bit_vld_i   (health_test_esbus_vld),
1700:     .clear_i             (health_test_clr),
1701:     .active_i            (repcnts_active),
1702:     .thresh_i            (repcnts_threshold),
1703:     .test_cnt_o          (repcnts_event_cnt),
1704:     .test_fail_pulse_o   (repcnts_fail_pulse),
1705:     .count_err_o         (repcnts_cntr_err)
1706:   );
1707: 
1708:   entropy_src_watermark_reg #(
1709:     .RegWidth(HalfRegWidth),
1710:     .HighWatermark(1)
1711:   ) u_entropy_src_watermark_reg_repcnts_fips (
1712:     .clk_i               (clk_i),
1713:     .rst_ni              (rst_ni),
1714:     .clear_i             (health_test_clr),
1715:     .event_i             (!es_bypass_mode),
1716:     .value_i             (repcnts_event_cnt),
1717:     .value_o             (repcnts_event_hwm_fips)
1718:   );
1719: 
1720:   entropy_src_watermark_reg #(
1721:     .RegWidth(HalfRegWidth),
1722:     .HighWatermark(1)
1723:   ) u_entropy_src_watermark_reg_repcnts_bypass (
1724:     .clk_i               (clk_i),
1725:     .rst_ni              (rst_ni),
1726:     .clear_i             (health_test_clr),
1727:     .event_i             (es_bypass_mode),
1728:     .value_i             (repcnts_event_cnt),
1729:     .value_o             (repcnts_event_hwm_bypass)
1730:   );
1731: 
1732:   // SEC_CM: CTR.REDUN
1733:   entropy_src_cntr_reg #(
1734:     .RegWidth(FullRegWidth)
1735:   ) u_entropy_src_cntr_reg_repcnts (
1736:     .clk_i               (clk_i),
1737:     .rst_ni              (rst_ni),
1738:     .clear_i             (health_test_clr),
1739:     .event_i             (repcnts_fail_pulse),
1740:     .value_o             (repcnts_total_fails),
1741:     .err_o               (repcnts_fails_cntr_err)
1742:   );
1743: 
1744:   assign hw2reg.repcnts_hi_watermarks.fips_watermark.d = repcnts_event_hwm_fips;
1745:   assign hw2reg.repcnts_hi_watermarks.bypass_watermark.d = repcnts_event_hwm_bypass;
1746:   assign hw2reg.repcnts_total_fails.d = repcnts_total_fails;
1747: 
1748:   //--------------------------------------------
1749:   // adaptive proportion test
1750:   //--------------------------------------------
1751: 
1752:   // SEC_CM: RNG.BKGN_CHK
1753:   entropy_src_adaptp_ht #(
1754:     .RegWidth(HalfRegWidth),
1755:     .RngBusWidth(RngBusWidth)
1756:   ) u_entropy_src_adaptp_ht (
1757:     .clk_i               (clk_i),
1758:     .rst_ni              (rst_ni),
1759:     .entropy_bit_i       (health_test_esbus),
1760:     .entropy_bit_vld_i   (health_test_esbus_vld),
1761:     .rng_bit_en_i        (rng_bit_en),
1762:     .rng_bit_sel_i       (rng_bit_sel),
1763:     .clear_i             (health_test_clr),
1764:     .active_i            (adaptp_active),
1765:     .thresh_hi_i         (adaptp_hi_threshold),
1766:     .thresh_lo_i         (adaptp_lo_threshold),
1767:     .window_wrap_pulse_i (health_test_done_pulse),
1768:     .threshold_scope_i   (threshold_scope),
1769:     .test_cnt_hi_o       (adaptp_hi_event_cnt),
1770:     .test_cnt_lo_o       (adaptp_lo_event_cnt),
1771:     .test_fail_hi_pulse_o(adaptp_hi_fail_pulse),
1772:     .test_fail_lo_pulse_o(adaptp_lo_fail_pulse),
1773:     .count_err_o         (adaptp_cntr_err)
1774:   );
1775: 
1776: 
1777:   entropy_src_watermark_reg #(
1778:     .RegWidth(HalfRegWidth),
1779:     .HighWatermark(1)
1780:   ) u_entropy_src_watermark_reg_adaptp_hi_fips (
1781:     .clk_i               (clk_i),
1782:     .rst_ni              (rst_ni),
1783:     .clear_i             (health_test_clr),
1784:     .event_i             (health_test_done_pulse && !es_bypass_mode),
1785:     .value_i             (adaptp_hi_event_cnt),
1786:     .value_o             (adaptp_hi_event_hwm_fips)
1787:   );
1788: 
1789:   entropy_src_watermark_reg #(
1790:     .RegWidth(HalfRegWidth),
1791:     .HighWatermark(1)
1792:   ) u_entropy_src_watermark_reg_adaptp_hi_bypass (
1793:     .clk_i               (clk_i),
1794:     .rst_ni              (rst_ni),
1795:     .clear_i             (health_test_clr),
1796:     .event_i             (health_test_done_pulse && es_bypass_mode),
1797:     .value_i             (adaptp_hi_event_cnt),
1798:     .value_o             (adaptp_hi_event_hwm_bypass)
1799:   );
1800: 
1801:   // SEC_CM: CTR.REDUN
1802:   entropy_src_cntr_reg #(
1803:     .RegWidth(FullRegWidth)
1804:   ) u_entropy_src_cntr_reg_adaptp_hi (
1805:     .clk_i               (clk_i),
1806:     .rst_ni              (rst_ni),
1807:     .clear_i             (health_test_clr),
1808:     .event_i             (adaptp_hi_fail_pulse),
1809:     .value_o             (adaptp_hi_total_fails),
1810:     .err_o               (adaptp_hi_fails_cntr_err)
1811:   );
1812: 
1813: 
1814:   assign hw2reg.adaptp_hi_watermarks.fips_watermark.d = adaptp_hi_event_hwm_fips;
1815:   assign hw2reg.adaptp_hi_watermarks.bypass_watermark.d = adaptp_hi_event_hwm_bypass;
1816:   assign hw2reg.adaptp_hi_total_fails.d = adaptp_hi_total_fails;
1817: 
1818: 
1819:   entropy_src_watermark_reg #(
1820:     .RegWidth(HalfRegWidth),
1821:     .HighWatermark(0)
1822:   ) u_entropy_src_watermark_reg_adaptp_lo_fips (
1823:     .clk_i               (clk_i),
1824:     .rst_ni              (rst_ni),
1825:     .clear_i             (health_test_clr),
1826:     .event_i             (health_test_done_pulse && !es_bypass_mode),
1827:     .value_i             (adaptp_lo_event_cnt),
1828:     .value_o             (adaptp_lo_event_hwm_fips)
1829:   );
1830: 
1831:   entropy_src_watermark_reg #(
1832:     .RegWidth(HalfRegWidth),
1833:     .HighWatermark(0)
1834:   ) u_entropy_src_watermark_reg_adaptp_lo_bypass (
1835:     .clk_i               (clk_i),
1836:     .rst_ni              (rst_ni),
1837:     .clear_i             (health_test_clr),
1838:     .event_i             (health_test_done_pulse && es_bypass_mode),
1839:     .value_i             (adaptp_lo_event_cnt),
1840:     .value_o             (adaptp_lo_event_hwm_bypass)
1841:   );
1842: 
1843:   // SEC_CM: CTR.REDUN
1844:   entropy_src_cntr_reg #(
1845:     .RegWidth(FullRegWidth)
1846:   ) u_entropy_src_cntr_reg_adaptp_lo (
1847:     .clk_i               (clk_i),
1848:     .rst_ni              (rst_ni),
1849:     .clear_i             (health_test_clr),
1850:     .event_i             (adaptp_lo_fail_pulse),
1851:     .value_o             (adaptp_lo_total_fails),
1852:     .err_o               (adaptp_lo_fails_cntr_err)
1853:   );
1854: 
1855:   assign hw2reg.adaptp_lo_watermarks.fips_watermark.d = adaptp_lo_event_hwm_fips;
1856:   assign hw2reg.adaptp_lo_watermarks.bypass_watermark.d = adaptp_lo_event_hwm_bypass;
1857:   assign hw2reg.adaptp_lo_total_fails.d = adaptp_lo_total_fails;
1858: 
1859: 
1860:   //--------------------------------------------
1861:   // bucket test
1862:   //--------------------------------------------
1863: 
1864:   // SEC_CM: RNG.BKGN_CHK
1865:   entropy_src_bucket_ht #(
1866:     .RegWidth(HalfRegWidth),
1867:     .RngBusWidth(RngBusWidth)
1868:   ) u_entropy_src_bucket_ht (
1869:     .clk_i               (clk_i),
1870:     .rst_ni              (rst_ni),
1871:     .entropy_bit_i       (health_test_esbus),
1872:     .entropy_bit_vld_i   (health_test_esbus_vld),
1873:     .clear_i             (health_test_clr),
1874:     .active_i            (bucket_active),
1875:     .thresh_i            (bucket_threshold),
1876:     .window_wrap_pulse_i (health_test_done_pulse),
1877:     .test_cnt_o          (bucket_event_cnt),
1878:     .test_fail_pulse_o   (bucket_fail_pulse),
1879:     .count_err_o         (bucket_cntr_err)
1880:   );
1881: 
1882:   entropy_src_watermark_reg #(
1883:     .RegWidth(HalfRegWidth),
1884:     .HighWatermark(1)
1885:   ) u_entropy_src_watermark_reg_bucket_fips (
1886:     .clk_i               (clk_i),
1887:     .rst_ni              (rst_ni),
1888:     .clear_i             (health_test_clr),
1889:     .event_i             (health_test_done_pulse && !es_bypass_mode),
1890:     .value_i             (bucket_event_cnt),
1891:     .value_o             (bucket_event_hwm_fips)
1892:   );
1893: 
1894:   entropy_src_watermark_reg #(
1895:     .RegWidth(HalfRegWidth),
1896:     .HighWatermark(1)
1897:   ) u_entropy_src_watermark_reg_bucket_bypass (
1898:     .clk_i               (clk_i),
1899:     .rst_ni              (rst_ni),
1900:     .clear_i             (health_test_clr),
1901:     .event_i             (health_test_done_pulse && es_bypass_mode),
1902:     .value_i             (bucket_event_cnt),
1903:     .value_o             (bucket_event_hwm_bypass)
1904:   );
1905: 
1906:   // SEC_CM: CTR.REDUN
1907:   entropy_src_cntr_reg #(
1908:     .RegWidth(FullRegWidth)
1909:   ) u_entropy_src_cntr_reg_bucket (
1910:     .clk_i               (clk_i),
1911:     .rst_ni              (rst_ni),
1912:     .clear_i             (health_test_clr),
1913:     .event_i             (bucket_fail_pulse),
1914:     .value_o             (bucket_total_fails),
1915:     .err_o               (bucket_fails_cntr_err)
1916:   );
1917: 
1918:   assign hw2reg.bucket_hi_watermarks.fips_watermark.d = bucket_event_hwm_fips;
1919:   assign hw2reg.bucket_hi_watermarks.bypass_watermark.d = bucket_event_hwm_bypass;
1920:   assign hw2reg.bucket_total_fails.d = bucket_total_fails;
1921: 
1922: 
1923:   //--------------------------------------------
1924:   // Markov test
1925:   //--------------------------------------------
1926: 
1927:   // SEC_CM: RNG.BKGN_CHK
1928:   entropy_src_markov_ht #(
1929:     .RegWidth(HalfRegWidth),
1930:     .RngBusWidth(RngBusWidth)
1931:   ) u_entropy_src_markov_ht (
1932:     .clk_i               (clk_i),
1933:     .rst_ni              (rst_ni),
1934:     .entropy_bit_i       (health_test_esbus),
1935:     .entropy_bit_vld_i   (health_test_esbus_vld),
1936:     .rng_bit_en_i        (rng_bit_en),
1937:     .rng_bit_sel_i       (rng_bit_sel),
1938:     .clear_i             (health_test_clr),
1939:     .active_i            (markov_active),
1940:     .thresh_hi_i         (markov_hi_threshold),
1941:     .thresh_lo_i         (markov_lo_threshold),
1942:     .window_wrap_pulse_i (health_test_done_pulse),
1943:     .threshold_scope_i   (threshold_scope),
1944:     .test_cnt_hi_o       (markov_hi_event_cnt),
1945:     .test_cnt_lo_o       (markov_lo_event_cnt),
1946:     .test_fail_hi_pulse_o (markov_hi_fail_pulse),
1947:     .test_fail_lo_pulse_o (markov_lo_fail_pulse),
1948:     .count_err_o         (markov_cntr_err)
1949:   );
1950: 
1951:   entropy_src_watermark_reg #(
1952:     .RegWidth(HalfRegWidth),
1953:     .HighWatermark(1)
1954:   ) u_entropy_src_watermark_reg_markov_hi_fips (
1955:     .clk_i               (clk_i),
1956:     .rst_ni              (rst_ni),
1957:     .clear_i             (health_test_clr),
1958:     .event_i             (health_test_done_pulse && !es_bypass_mode),
1959:     .value_i             (markov_hi_event_cnt),
1960:     .value_o             (markov_hi_event_hwm_fips)
1961:   );
1962: 
1963:   entropy_src_watermark_reg #(
1964:     .RegWidth(HalfRegWidth),
1965:     .HighWatermark(1)
1966:   ) u_entropy_src_watermark_reg_markov_hi_bypass (
1967:     .clk_i               (clk_i),
1968:     .rst_ni              (rst_ni),
1969:     .clear_i             (health_test_clr),
1970:     .event_i             (health_test_done_pulse && es_bypass_mode),
1971:     .value_i             (markov_hi_event_cnt),
1972:     .value_o             (markov_hi_event_hwm_bypass)
1973:   );
1974: 
1975:   // SEC_CM: CTR.REDUN
1976:   entropy_src_cntr_reg #(
1977:     .RegWidth(FullRegWidth)
1978:   ) u_entropy_src_cntr_reg_markov_hi (
1979:     .clk_i               (clk_i),
1980:     .rst_ni              (rst_ni),
1981:     .clear_i             (health_test_clr),
1982:     .event_i             (markov_hi_fail_pulse),
1983:     .value_o             (markov_hi_total_fails),
1984:     .err_o               (markov_hi_fails_cntr_err)
1985:   );
1986: 
1987:   assign hw2reg.markov_hi_watermarks.fips_watermark.d = markov_hi_event_hwm_fips;
1988:   assign hw2reg.markov_hi_watermarks.bypass_watermark.d = markov_hi_event_hwm_bypass;
1989:   assign hw2reg.markov_hi_total_fails.d = markov_hi_total_fails;
1990: 
1991: 
1992:   entropy_src_watermark_reg #(
1993:     .RegWidth(HalfRegWidth),
1994:     .HighWatermark(0)
1995:   ) u_entropy_src_watermark_reg_markov_lo_fips (
1996:     .clk_i               (clk_i),
1997:     .rst_ni              (rst_ni),
1998:     .clear_i             (health_test_clr),
1999:     .event_i             (health_test_done_pulse && !es_bypass_mode),
2000:     .value_i             (markov_lo_event_cnt),
2001:     .value_o             (markov_lo_event_hwm_fips)
2002:   );
2003: 
2004:   entropy_src_watermark_reg #(
2005:     .RegWidth(HalfRegWidth),
2006:     .HighWatermark(0)
2007:   ) u_entropy_src_watermark_reg_markov_lo_bypass (
2008:     .clk_i               (clk_i),
2009:     .rst_ni              (rst_ni),
2010:     .clear_i             (health_test_clr),
2011:     .event_i             (health_test_done_pulse && es_bypass_mode),
2012:     .value_i             (markov_lo_event_cnt),
2013:     .value_o             (markov_lo_event_hwm_bypass)
2014:   );
2015: 
2016:   // SEC_CM: CTR.REDUN
2017:   entropy_src_cntr_reg #(
2018:     .RegWidth(FullRegWidth)
2019:   ) u_entropy_src_cntr_reg_markov_lo (
2020:     .clk_i               (clk_i),
2021:     .rst_ni              (rst_ni),
2022:     .clear_i             (health_test_clr),
2023:     .event_i             (markov_lo_fail_pulse),
2024:     .value_o             (markov_lo_total_fails),
2025:     .err_o               (markov_lo_fails_cntr_err)
2026:   );
2027: 
2028:   assign hw2reg.markov_lo_watermarks.fips_watermark.d = markov_lo_event_hwm_fips;
2029:   assign hw2reg.markov_lo_watermarks.bypass_watermark.d = markov_lo_event_hwm_bypass;
2030:   assign hw2reg.markov_lo_total_fails.d = markov_lo_total_fails;
2031: 
2032: 
2033:   //--------------------------------------------
2034:   // External health test
2035:   //--------------------------------------------
2036: 
2037:   // set outputs to external health test
2038:   assign entropy_src_xht_o.entropy_bit = health_test_esbus;
2039:   assign entropy_src_xht_o.entropy_bit_valid = health_test_esbus_vld;
2040:   assign entropy_src_xht_o.rng_bit_en = rng_bit_en;
2041:   assign entropy_src_xht_o.rng_bit_sel = rng_bit_sel;
2042:   assign entropy_src_xht_o.clear = health_test_clr;
2043:   assign entropy_src_xht_o.active = extht_active;
2044:   assign entropy_src_xht_o.thresh_hi = extht_hi_threshold;
2045:   assign entropy_src_xht_o.thresh_lo = extht_lo_threshold;
2046:   assign entropy_src_xht_o.window_wrap_pulse = health_test_done_pulse;
2047:   assign entropy_src_xht_o.health_test_window = health_test_window_scaled;
2048:   assign entropy_src_xht_o.threshold_scope = threshold_scope;
2049:   // get inputs from external health test
2050:   assign extht_event_cnt_hi = entropy_src_xht_i.test_cnt_hi;
2051:   assign extht_event_cnt_lo = entropy_src_xht_i.test_cnt_lo;
2052:   assign extht_hi_fail_pulse = entropy_src_xht_i.test_fail_hi_pulse;
2053:   assign extht_lo_fail_pulse = entropy_src_xht_i.test_fail_lo_pulse;
2054:   assign extht_cont_test = entropy_src_xht_i.continuous_test;
2055: 
2056:   entropy_src_watermark_reg #(
2057:     .RegWidth(HalfRegWidth),
2058:     .HighWatermark(1)
2059:   ) u_entropy_src_watermark_reg_extht_hi_fips (
2060:     .clk_i               (clk_i),
2061:     .rst_ni              (rst_ni),
2062:     .clear_i             (health_test_clr),
2063:     .event_i             ((extht_cont_test || health_test_done_pulse) && !es_bypass_mode),
2064:     .value_i             (extht_event_cnt_hi),
2065:     .value_o             (extht_hi_event_hwm_fips)
2066:   );
2067: 
2068:   entropy_src_watermark_reg #(
2069:     .RegWidth(HalfRegWidth),
2070:     .HighWatermark(1)
2071:   ) u_entropy_src_watermark_reg_extht_hi_bypass (
2072:     .clk_i               (clk_i),
2073:     .rst_ni              (rst_ni),
2074:     .clear_i             (health_test_clr),
2075:     .event_i             ((extht_cont_test || health_test_done_pulse) && es_bypass_mode),
2076:     .value_i             (extht_event_cnt_hi),
2077:     .value_o             (extht_hi_event_hwm_bypass)
2078:   );
2079: 
2080:   // SEC_CM: CTR.REDUN
2081:   entropy_src_cntr_reg #(
2082:     .RegWidth(FullRegWidth)
2083:   ) u_entropy_src_cntr_reg_extht_hi (
2084:     .clk_i               (clk_i),
2085:     .rst_ni              (rst_ni),
2086:     .clear_i             (health_test_clr),
2087:     .event_i             (extht_hi_fail_pulse),
2088:     .value_o             (extht_hi_total_fails),
2089:     .err_o               (extht_hi_fails_cntr_err)
2090:   );
2091: 
2092: 
2093:   assign hw2reg.extht_hi_watermarks.fips_watermark.d = extht_hi_event_hwm_fips;
2094:   assign hw2reg.extht_hi_watermarks.bypass_watermark.d = extht_hi_event_hwm_bypass;
2095:   assign hw2reg.extht_hi_total_fails.d = extht_hi_total_fails;
2096: 
2097: 
2098:   entropy_src_watermark_reg #(
2099:     .RegWidth(HalfRegWidth),
2100:     .HighWatermark(0)
2101:   ) u_entropy_src_watermark_reg_extht_lo_fips (
2102:     .clk_i               (clk_i),
2103:     .rst_ni              (rst_ni),
2104:     .clear_i             (health_test_clr),
2105:     .event_i             ((extht_cont_test || health_test_done_pulse) && !es_bypass_mode),
2106:     .value_i             (extht_event_cnt_lo),
2107:     .value_o             (extht_lo_event_hwm_fips)
2108:   );
2109: 
2110:   entropy_src_watermark_reg #(
2111:     .RegWidth(HalfRegWidth),
2112:     .HighWatermark(0)
2113:   ) u_entropy_src_watermark_reg_extht_lo_bypass (
2114:     .clk_i               (clk_i),
2115:     .rst_ni              (rst_ni),
2116:     .clear_i             (health_test_clr),
2117:     .event_i             ((extht_cont_test || health_test_done_pulse) && es_bypass_mode),
2118:     .value_i             (extht_event_cnt_lo),
2119:     .value_o             (extht_lo_event_hwm_bypass)
2120:   );
2121: 
2122:   // SEC_CM: CTR.REDUN
2123:   entropy_src_cntr_reg #(
2124:     .RegWidth(FullRegWidth)
2125:   ) u_entropy_src_cntr_reg_extht_lo (
2126:     .clk_i               (clk_i),
2127:     .rst_ni              (rst_ni),
2128:     .clear_i             (health_test_clr),
2129:     .event_i             (extht_lo_fail_pulse),
2130:     .value_o             (extht_lo_total_fails),
2131:     .err_o               (extht_lo_fails_cntr_err)
2132:   );
2133: 
2134:   assign hw2reg.extht_lo_watermarks.fips_watermark.d = extht_lo_event_hwm_fips;
2135:   assign hw2reg.extht_lo_watermarks.bypass_watermark.d = extht_lo_event_hwm_bypass;
2136:   assign hw2reg.extht_lo_total_fails.d = extht_lo_total_fails;
2137: 
2138: 
2139:   //--------------------------------------------
2140:   // summary and alert registers
2141:   //--------------------------------------------
2142: 
2143:   assign alert_cntrs_clr = health_test_clr || rst_alert_cntr;
2144: 
2145:   // SEC_CM: CTR.REDUN
2146:   entropy_src_cntr_reg #(
2147:     .RegWidth(HalfRegWidth)
2148:   ) u_entropy_src_cntr_reg_any_alert_fails (
2149:     .clk_i               (clk_i),
2150:     .rst_ni              (rst_ni),
2151:     .clear_i             (alert_cntrs_clr),
2152:     .event_i             (any_fail_pulse),
2153:     .value_o             (any_fail_count),
2154:     .err_o               (any_fails_cntr_err)
2155:   );
2156: 
2157:   assign any_fail_pulse =
2158:          repcnt_fail_pulse ||
2159:          repcnts_fail_pulse ||
2160:          adaptp_hi_fail_pulse || adaptp_lo_fail_pulse ||
2161:          bucket_fail_pulse ||
2162:          markov_hi_fail_pulse || markov_lo_fail_pulse ||
2163:          extht_hi_fail_pulse || extht_lo_fail_pulse;
2164: 
2165:   assign ht_failed_d =
2166:          (!es_enable_fo[6]) ? 1'b0 :
2167:          ht_done_pulse_q ? 1'b0 :
2168:          any_fail_pulse ? 1'b1 :
2169:          ht_failed_q;
2170: 
2171: 
2172:   // delay health pulse so that main_sm will
2173:   // get the correct threshold value comparisons
2174:   assign ht_done_pulse_d = health_test_done_pulse;
2175: 
2176:   assign hw2reg.alert_summary_fail_counts.d = any_fail_count;
2177: 
2178:   // signal an alert
2179:   // SEC_CM: CONFIG.REDUN
2180:   assign alert_threshold = reg2hw.alert_threshold.alert_threshold.q;
2181:   assign alert_threshold_inv = reg2hw.alert_threshold.alert_threshold_inv.q;
2182:   assign es_thresh_cfg_alert = (~alert_threshold_inv != alert_threshold);
2183: 
2184:   assign alert_threshold_fail =
2185:          ((any_fail_count >= ~alert_threshold_inv) && (~alert_threshold_inv != '0)) ||
2186:          (any_fail_count >= alert_threshold) && (alert_threshold != '0);
2187: 
2188: 
2189:   prim_edge_detector #(
2190:     .Width(1),
2191:     .ResetValue(0),
2192:     .EnSync(0)
2193:   ) u_prim_edge_detector_recov_alert (
2194:     .clk_i,
2195:     .rst_ni,
2196:     .d_i(recov_alert_state),
2197:     .q_sync_o(),
2198:     .q_posedge_pulse_o(recov_alert_o),
2199:     .q_negedge_pulse_o()
2200:   );
2201: 
2202:   assign recov_alert_state =
2203:          es_enable_pfa ||
2204:          fips_enable_pfa ||
2205:          fips_flag_pfa ||
2206:          rng_fips_pfa ||
2207:          entropy_data_reg_en_pfa ||
2208:          threshold_scope_pfa ||
2209:          rng_bit_enable_pfa ||
2210:          fw_ov_mode_pfa ||
2211:          fw_ov_entropy_insert_pfa ||
2212:          fw_ov_sha3_start_pfa ||
2213:          es_route_pfa ||
2214:          es_type_pfa ||
2215:          es_main_sm_alert ||
2216:          es_bus_cmp_alert ||
2217:          es_thresh_cfg_alert ||
2218:          es_fw_ov_wr_alert ||
2219:          es_fw_ov_disable_alert ||
2220:          postht_entropy_drop_alert;
2221: 
2222:   assign hw2reg.recov_alert_sts.es_main_sm_alert.de = es_main_sm_alert;
2223:   assign hw2reg.recov_alert_sts.es_main_sm_alert.d  = es_main_sm_alert;
2224: 
2225:   assign hw2reg.recov_alert_sts.es_bus_cmp_alert.de = es_bus_cmp_alert;
2226:   assign hw2reg.recov_alert_sts.es_bus_cmp_alert.d  = es_bus_cmp_alert;
2227: 
2228:   assign hw2reg.recov_alert_sts.es_thresh_cfg_alert.de = es_thresh_cfg_alert;
2229:   assign hw2reg.recov_alert_sts.es_thresh_cfg_alert.d  = es_thresh_cfg_alert;
2230: 
2231:   assign hw2reg.recov_alert_sts.es_fw_ov_wr_alert.de = es_fw_ov_wr_alert;
2232:   assign hw2reg.recov_alert_sts.es_fw_ov_wr_alert.d  = es_fw_ov_wr_alert;
2233: 
2234:   assign hw2reg.recov_alert_sts.es_fw_ov_disable_alert.de = es_fw_ov_disable_alert;
2235:   assign hw2reg.recov_alert_sts.es_fw_ov_disable_alert.d  = es_fw_ov_disable_alert;
2236: 
2237:   // repcnt fail counter
2238:   // SEC_CM: CTR.REDUN
2239:   entropy_src_cntr_reg #(
2240:     .RegWidth(EighthRegWidth)
2241:   ) u_entropy_src_cntr_reg_repcnt_alert_fails (
2242:     .clk_i               (clk_i),
2243:     .rst_ni              (rst_ni),
2244:     .clear_i             (alert_cntrs_clr),
2245:     .event_i             (repcnt_fail_pulse),
2246:     .value_o             (repcnt_fail_count),
2247:     .err_o               (repcnt_alert_cntr_err)
2248:   );
2249: 
2250:   assign hw2reg.alert_fail_counts.repcnt_fail_count.d = repcnt_fail_count;
2251: 
2252:   // repcnts fail counter
2253:   // SEC_CM: CTR.REDUN
2254:   entropy_src_cntr_reg #(
2255:     .RegWidth(EighthRegWidth)
2256:   ) u_entropy_src_cntr_reg_repcnts_alert_fails (
2257:     .clk_i               (clk_i),
2258:     .rst_ni              (rst_ni),
2259:     .clear_i             (alert_cntrs_clr),
2260:     .event_i             (repcnts_fail_pulse),
2261:     .value_o             (repcnts_fail_count),
2262:     .err_o               (repcnts_alert_cntr_err)
2263:   );
2264: 
2265:   assign hw2reg.alert_fail_counts.repcnts_fail_count.d = repcnts_fail_count;
2266: 
2267:   // adaptp fail counter hi and lo
2268:   // SEC_CM: CTR.REDUN
2269:   entropy_src_cntr_reg #(
2270:     .RegWidth(EighthRegWidth)
2271:   ) u_entropy_src_cntr_reg_adaptp_hi_alert_fails (
2272:     .clk_i               (clk_i),
2273:     .rst_ni              (rst_ni),
2274:     .clear_i             (alert_cntrs_clr),
2275:     .event_i             (adaptp_hi_fail_pulse),
2276:     .value_o             (adaptp_hi_fail_count),
2277:     .err_o               (adaptp_hi_alert_cntr_err)
2278:   );
2279: 
2280:   assign hw2reg.alert_fail_counts.adaptp_hi_fail_count.d = adaptp_hi_fail_count;
2281: 
2282:   // SEC_CM: CTR.REDUN
2283:   entropy_src_cntr_reg #(
2284:     .RegWidth(EighthRegWidth)
2285:   ) u_entropy_src_cntr_reg_adaptp_lo_alert_fails (
2286:     .clk_i               (clk_i),
2287:     .rst_ni              (rst_ni),
2288:     .clear_i             (alert_cntrs_clr),
2289:     .event_i             (adaptp_lo_fail_pulse),
2290:     .value_o             (adaptp_lo_fail_count),
2291:     .err_o               (adaptp_lo_alert_cntr_err)
2292:   );
2293: 
2294:   assign hw2reg.alert_fail_counts.adaptp_lo_fail_count.d = adaptp_lo_fail_count;
2295: 
2296:   // bucket fail counter
2297:   // SEC_CM: CTR.REDUN
2298:   entropy_src_cntr_reg #(
2299:     .RegWidth(EighthRegWidth)
2300:   ) u_entropy_src_cntr_reg_bucket_alert_fails (
2301:     .clk_i               (clk_i),
2302:     .rst_ni              (rst_ni),
2303:     .clear_i             (alert_cntrs_clr),
2304:     .event_i             (bucket_fail_pulse),
2305:     .value_o             (bucket_fail_count),
2306:     .err_o               (bucket_alert_cntr_err)
2307:   );
2308: 
2309:   assign hw2reg.alert_fail_counts.bucket_fail_count.d = bucket_fail_count;
2310: 
2311: 
2312:   // markov fail counter hi and lo
2313:   // SEC_CM: CTR.REDUN
2314:   entropy_src_cntr_reg #(
2315:     .RegWidth(EighthRegWidth)
2316:   ) u_entropy_src_cntr_reg_markov_hi_alert_fails (
2317:     .clk_i               (clk_i),
2318:     .rst_ni              (rst_ni),
2319:     .clear_i             (alert_cntrs_clr),
2320:     .event_i             (markov_hi_fail_pulse),
2321:     .value_o             (markov_hi_fail_count),
2322:     .err_o               (markov_hi_alert_cntr_err)
2323:   );
2324: 
2325:   assign hw2reg.alert_fail_counts.markov_hi_fail_count.d = markov_hi_fail_count;
2326: 
2327:   // SEC_CM: CTR.REDUN
2328:   entropy_src_cntr_reg #(
2329:     .RegWidth(EighthRegWidth)
2330:   ) u_entropy_src_cntr_reg_markov_lo_alert_fails (
2331:     .clk_i               (clk_i),
2332:     .rst_ni              (rst_ni),
2333:     .clear_i             (alert_cntrs_clr),
2334:     .event_i             (markov_lo_fail_pulse),
2335:     .value_o             (markov_lo_fail_count),
2336:     .err_o               (markov_lo_alert_cntr_err)
2337:   );
2338: 
2339:   assign hw2reg.alert_fail_counts.markov_lo_fail_count.d = markov_lo_fail_count;
2340: 
2341:   // extht fail counter hi and lo
2342:   // SEC_CM: CTR.REDUN
2343:   entropy_src_cntr_reg #(
2344:     .RegWidth(EighthRegWidth)
2345:   ) u_entropy_src_cntr_reg_extht_hi_alert_fails (
2346:     .clk_i               (clk_i),
2347:     .rst_ni              (rst_ni),
2348:     .clear_i             (alert_cntrs_clr),
2349:     .event_i             (extht_hi_fail_pulse),
2350:     .value_o             (extht_hi_fail_count),
2351:     .err_o               (extht_hi_alert_cntr_err)
2352:   );
2353: 
2354:   assign hw2reg.extht_fail_counts.extht_hi_fail_count.d = extht_hi_fail_count;
2355: 
2356:   // SEC_CM: CTR.REDUN
2357:   entropy_src_cntr_reg #(
2358:     .RegWidth(EighthRegWidth)
2359:   ) u_entropy_src_cntr_reg_extht_lo_alert_fails (
2360:     .clk_i               (clk_i),
2361:     .rst_ni              (rst_ni),
2362:     .clear_i             (alert_cntrs_clr),
2363:     .event_i             (extht_lo_fail_pulse),
2364:     .value_o             (extht_lo_fail_count),
2365:     .err_o               (extht_lo_alert_cntr_err)
2366:   );
2367: 
2368:   assign hw2reg.extht_fail_counts.extht_lo_fail_count.d = extht_lo_fail_count;
2369: 
2370: 
2371:   //------------------------------------------------------------------
2372:   // Signal a recoverable alert when dropping tested entropy bits.
2373:   //------------------------------------------------------------------
2374: 
2375:   // Post-health test entropy bits can be dropped from the pipeline in case of e.g. backpressure
2376:   // from the conditioner. The conditioner will still use the amount of bits configured in
2377:   // HEALTH_TEST_WINDOW.FIPS_WINDOW to produce the seed, and the produced seed is okay to use.
2378:   // But as the dropped bits are still tested, the effective test window increases beyond the
2379:   // value configured in HEALTH_TEST_WINDOW.FIPS_WINDOW.
2380:   //
2381:   // Signaling this condition serves the following purposes:
2382:   // 1. When running in Firmware Override: Observe mode, dropping post-health test entropy bits
2383:   //    may cause the entropy bits observed from the Observe FIFO to be non-contiguous, causing
2384:   //    the observed bits to be not usable for validation purposes. Note that Firmware Override:
2385:   //    Extract & Insert mode is not affected by this.
2386:   // 2. It allows the DV environment to know when entropy bits have been dropped which simplifies
2387:   //    DV.
2388:   // 3. It helps tuning the depth of the distr FIFO which can be used to absorb the backpressure
2389:   //    of the conditioner.
2390: 
2391:   // The pop signal of the preceeding esrng FIFO is unconditional, meaning samples are dropped
2392:   // whenever the esbit or postht FIFO is full in single-channel or multi-channel mode,
2393:   // respectively.
2394:   assign postht_entropy_drop_alert = sfifo_esrng_not_empty &&
2395:       (rng_bit_en ? !pfifo_esbit_not_full : !pfifo_postht_not_full);
2396: 
2397:   assign hw2reg.recov_alert_sts.postht_entropy_drop_alert.de = postht_entropy_drop_alert;
2398:   assign hw2reg.recov_alert_sts.postht_entropy_drop_alert.d  = postht_entropy_drop_alert;
2399: 
2400:   //--------------------------------------------------------------
2401:   // Pack health tested esrng bus into single bit packer FIFO.
2402:   //--------------------------------------------------------------
2403: 
2404:   // SEC_CM: CONFIG.MUBI
2405:   assign mubi_rng_bit_en = mubi4_t'(reg2hw.conf.rng_bit_enable.q);
2406:   assign rng_bit_enable_pfe = mubi4_test_true_strict(mubi_rng_bit_en_fanout[0]);
2407:   assign rng_bit_enable_pfa = mubi4_test_invalid(mubi_rng_bit_en_fanout[1]);
2408:   assign hw2reg.recov_alert_sts.rng_bit_enable_field_alert.de = rng_bit_enable_pfa;
2409:   assign hw2reg.recov_alert_sts.rng_bit_enable_field_alert.d  = rng_bit_enable_pfa;
2410: 
2411:   prim_mubi4_sync #(
2412:     .NumCopies(2),
2413:     .AsyncOn(0)
2414:   ) u_prim_mubi4_sync_rng_bit_en (
2415:     .clk_i,
2416:     .rst_ni,
2417:     .mubi_i(mubi_rng_bit_en),
2418:     .mubi_o(mubi_rng_bit_en_fanout)
2419:   );
2420: 
2421: 
2422:   assign rng_bit_en = rng_bit_enable_pfe;
2423:   // Improved bit selection with resource optimization
2424:   assign rng_bit_sel = reg2hw.conf.rng_bit_sel.q & {1'b1, health_test_window[0]};
2425: 
2426:   prim_packer_fifo #(
2427:     .InW(1),
2428:     .OutW(RngBusWidth),
2429:     .ClearOnRead(1'b0)
2430:   ) u_prim_packer_fifo_esbit (
2431:     .clk_i      (clk_i),
2432:     .rst_ni     (rst_ni),
2433:     .clr_i      (pfifo_esbit_clr),
2434:     .wvalid_i   (pfifo_esbit_push),
2435:     .wdata_i    (pfifo_esbit_wdata),
2436:     .wready_o   (pfifo_esbit_not_full),
2437:     .rvalid_o   (pfifo_esbit_not_empty),
2438:     .rdata_o    (pfifo_esbit_rdata),
2439:     .rready_i   (pfifo_esbit_pop),
2440:     .depth_o    ()
2441:   );
2442: 
2443:   // The prim_packer_fifo primitive is constructed to only accept pushes if there is indeed space
2444:   // available. The pop signal of the preceeding esrng FIFO is unconditional, meaning samples can
2445:   // be dropped before the esbit FIFO in case of backpressure. The samples are however still
2446:   // tested.
2447:   assign pfifo_esbit_push = rng_bit_en && sfifo_esrng_not_empty;
2448:   assign pfifo_esbit_clr = ~es_delayed_enable;
2449:   assign pfifo_esbit_pop = rng_bit_en && pfifo_esbit_not_empty && pfifo_postht_not_full;
2450:   assign pfifo_esbit_wdata =
2451:          (rng_bit_sel == 2'h0) ? sfifo_esrng_rdata[0] :
2452:          (rng_bit_sel == 2'h1) ? sfifo_esrng_rdata[1] :
2453:          (rng_bit_sel == 2'h2) ? sfifo_esrng_rdata[2] :
2454:          sfifo_esrng_rdata[3];
2455: 
2456: 
2457:   //--------------------------------------------
2458:   // pack tested entropy into 32 bit packer
2459:   //--------------------------------------------
2460: 
2461:   prim_packer_fifo #(
2462:     .InW(RngBusWidth),
2463:     .OutW(PostHTWidth),
2464:     .ClearOnRead(1'b0)
2465:   ) u_prim_packer_fifo_postht (
2466:     .clk_i      (clk_i),
2467:     .rst_ni     (rst_ni),
2468:     .clr_i      (pfifo_postht_clr),
2469:     .wvalid_i   (pfifo_postht_push),
2470:     .wdata_i    (pfifo_postht_wdata),
2471:     .wready_o   (pfifo_postht_not_full),
2472:     .rvalid_o   (pfifo_postht_not_empty),
2473:     .rdata_o    (pfifo_postht_rdata),
2474:     .rready_i   (pfifo_postht_pop),
2475:     .depth_o    ()
2476:   );
2477: 
2478:   // The prim_packer_fifo primitive is constructed to only accept pushes if there is indeed space
2479:   // available. In case the single-bit mode is enabled, the pop signal of the preceeding esbit FIFO
2480:   // is conditional on the full status of the postht FIFO, meaning backpressure can be handled. In
2481:   // case the single-bit mode is disabled, the pop signal of the preceeding esrng FIFO is
2482:   // unconditional, meaning samples can be dropped before the esbit in case of backpressure. The
2483:   // samples are however still tested.
2484:   assign pfifo_postht_push = rng_bit_en ? pfifo_esbit_not_empty : sfifo_esrng_not_empty;
2485: 
2486:   assign pfifo_postht_wdata = rng_bit_en ? pfifo_esbit_rdata :
2487:                               sfifo_esrng_rdata;
2488: 
2489:   // For verification purposes, let post-disable data continue through to the SHA engine if it has
2490:   // made it past the health checks, when in standard (non-fw_ov) mode.  This allows scoreboards
2491:   // to use the same data set for computing both the SHA engine outputs and the health-check stats.
2492:   //
2493:   // In fw_ov mode it is preferable (from a verification standpoint) to clear all FIFOs whenever
2494:   // disabled. Given the lack of handshaking on the fw_ov register path, this is easier to predict.
2495:   // Also, there is no association between SHA data and health test windows in FW_OV mode, so there
2496:   // is no benefit in this mode to clearing the SHA FIFOs at the same time we clear the HT
2497:   // statistics.
2498:   // Enhanced FIFO control with improved timing
2499:   assign pfifo_postht_clr = fw_ov_mode_entropy_insert ? 
2500:                            ~es_enable_fo[7] & pfifo_postht_not_empty :
2501:                            ~es_enable_fo[7];
2502: 
2503:   // Pop whenever the distribution FIFO is not full. The distribution FIFO can be sized such that
2504:   // it's never going to be full even under pessimistic operating conditions.
2505:   assign pfifo_postht_pop = sfifo_distr_push & sfifo_distr_not_full;
2506: 
2507:   //--------------------------------------------
2508:   // buffer entropy in ditribution FIFO
2509:   //--------------------------------------------
2510: 
2511:   // The purpose of this FIFO is to buffer postht entropy bits in case the conditioner cannot
2512:   // accept them at the moment, i.e., because it's busy or because it's waiting on the CS AES halt
2513:   // interface before it can run. By properly sizing this FIFO, it can be guaranteed that even
2514:   // under pessimistic operating conditions (see entropy_src_rng_max_rate test), entropy bits never
2515:   // need to be dropped from the hardware pipeline.
2516: 
2517:   // SEC_CM: FIFO.CTR.REDUN
2518:   prim_fifo_sync #(
2519:     .Width(DistrFifoWidth),
2520:     .Pass(1),
2521:     .Depth(DistrFifoDepth),
2522:     .OutputZeroIfEmpty(0),
2523:     .Secure(1)
2524:   ) u_prim_fifo_sync_distr (
2525:     .clk_i      (clk_i),
2526:     .rst_ni     (rst_ni),
2527:     .clr_i      (sfifo_distr_clr),
2528:     .wvalid_i   (sfifo_distr_push),
2529:     .wdata_i    (sfifo_distr_wdata),
2530:     .wready_o   (sfifo_distr_not_full),
2531:     .rvalid_o   (sfifo_distr_not_empty),
2532:     .rdata_o    (sfifo_distr_rdata),
2533:     .rready_i   (sfifo_distr_pop),
2534:     .full_o     (sfifo_distr_full),
2535:     .depth_o    (),
2536:     .err_o      (sfifo_distr_int_err)
2537:   );
2538: 
2539:   // The prim_fifo_sync primitive is constructed to only accept pushes if there is indeed space
2540:   // available. Backpressure is handled at the sender.
2541:   assign sfifo_distr_push = pfifo_postht_not_empty;
2542:   assign sfifo_distr_wdata = pfifo_postht_rdata;
2543: 
2544:   assign sfifo_distr_clr = fw_ov_mode_entropy_insert ? !es_enable_fo[19] : !es_delayed_enable;
2545: 
2546:   // In firmware override mode with extract & insert enabled, post-health test entropy bits can
2547:   // only move into the observe FIFO. Once the observe FIFO is full, post-health test entropy is
2548:   // just discarded.
2549:   assign sfifo_distr_pop = fw_ov_mode_entropy_insert ? sfifo_distr_not_empty :
2550:                            // In firmware override mode (observe only) or during normal
2551:                            // operation, post-health test entropy bits continue to flow
2552:                            // through the hardware pipeline.
2553:                            es_bypass_mode ? pfifo_bypass_push :
2554:                            pfifo_precon_push & pfifo_precon_not_full;
2555: 
2556:   // fifo err
2557:   // Note that for the used prim_fifo_sync and prim_packer_fifo primitives it is not an error to
2558:   // push to a FIFO that is full. The primitives simply don't accept the data when full. The
2559:   // backpressure needs to be handled at the sender.
2560:   assign sfifo_distr_err =
2561:          {1'b0,
2562:          (sfifo_distr_pop && !sfifo_distr_not_empty),
2563:          (sfifo_distr_full && !sfifo_distr_not_empty) || sfifo_distr_int_err};
2564: 
2565:   //--------------------------------------------
2566:   // store entropy into a 32 entry deep FIFO
2567:   //--------------------------------------------
2568: 
2569:   // SEC_CM: FIFO.CTR.REDUN
2570:   prim_fifo_sync #(
2571:     .Width(ObserveFifoWidth),
2572:     .Pass(0),
2573:     .Depth(ObserveFifoDepth),
2574:     .OutputZeroIfEmpty(1), // Prevent SVA from firing due unknown module outputs.
2575:     .Secure(1)
2576:   ) u_prim_fifo_sync_observe (
2577:     .clk_i      (clk_i),
2578:     .rst_ni     (rst_ni),
2579:     .clr_i      (sfifo_observe_clr),
2580:     .wvalid_i   (sfifo_observe_push),
2581:     .wdata_i    (sfifo_observe_wdata),
2582:     .wready_o   (),
2583:     .rvalid_o   (sfifo_observe_not_empty),
2584:     .rdata_o    (sfifo_observe_rdata),
2585:     .rready_i   (sfifo_observe_pop),
2586:     .full_o     (sfifo_observe_full),
2587:     .depth_o    (sfifo_observe_depth),
2588:     .err_o      (sfifo_observe_int_err)
2589:   );
2590: 
2591:   // The Observe fifo is intended to hold kilobits of contiguous data, yet still gracefully
2592:   // drop data when full.  This flop gates the observe fifo. If it ever overflows, no new data is
2593:   // allowed until it is empty.  Thus if the rate of CSR uptake almost matches the RNG data rate
2594:   // the FIFO avoids unnecessary segmentation, and guarantees that the remaining RNG data is as
2595:   // contiguous as possible.
2596:   logic sfifo_observe_gate_d, sfifo_observe_gate_q;
2597: 
2598:   assign sfifo_observe_gate_d = (sfifo_distr_pop && sfifo_observe_full) ? 1'b0 :
2599:                                 !sfifo_observe_not_empty                ? 1'b1 :
2600:                                 sfifo_observe_gate_q;
2601: 
2602:   always_ff @(posedge clk_i or negedge rst_ni) begin
2603:     if (!rst_ni) begin
2604:       sfifo_observe_gate_q <= 1'b1;
2605:     end else begin
2606:       sfifo_observe_gate_q <= sfifo_observe_gate_d;
2607:     end
2608:   end
2609: 
2610:   assign hw2reg.fw_ov_rd_fifo_overflow.d  = !sfifo_observe_gate_d;
2611:   assign hw2reg.fw_ov_rd_fifo_overflow.de = 1'b1;
2612: 
2613:   assign observe_fifo_thresh_met = fw_ov_mode && (observe_fifo_thresh != '0) &&
2614:          (observe_fifo_thresh <= sfifo_observe_depth) && es_enable_fo[8];
2615: 
2616:   assign hw2reg.observe_fifo_depth.d = sfifo_observe_depth;
2617: 
2618:   // fifo controls
2619:   assign sfifo_observe_push = fw_ov_mode && sfifo_distr_pop &&
2620:                               (sfifo_observe_gate_q || !sfifo_observe_not_empty);
2621: 
2622:   assign sfifo_observe_clr  = ~es_enable_fo[9];
2623: 
2624:   assign sfifo_observe_wdata = sfifo_distr_rdata;
2625: 
2626:   assign sfifo_observe_pop =
2627:          (fw_ov_mode && fw_ov_fifo_rd_pulse);
2628: 
2629:   // fifo err
2630:   // Note that for the used prim_fifo_sync and prim_packer_fifo primitives it is not an error to
2631:   // push to a FIFO that is full. The primitives simply don't accept the data when full. The
2632:   // backpressure needs to be handled at the sender.
2633:   assign sfifo_observe_err =
2634:          {1'b0,
2635:          (sfifo_observe_pop && !sfifo_observe_not_empty),
2636:          (sfifo_observe_full && !sfifo_observe_not_empty) || sfifo_observe_int_err};
2637: 
2638: 
2639:   //--------------------------------------------
2640:   // pack entropy into 64 bit packer
2641:   //--------------------------------------------
2642: 
2643:   prim_packer_fifo #(
2644:     .InW(ObserveFifoWidth),
2645:     .OutW(PreCondWidth),
2646:     .ClearOnRead(1'b0)
2647:   ) u_prim_packer_fifo_precon (
2648:     .clk_i      (clk_i),
2649:     .rst_ni     (rst_ni),
2650:     .clr_i      (pfifo_precon_clr),
2651:     .wvalid_i   (pfifo_precon_push),
2652:     .wdata_i    (pfifo_precon_wdata),
2653:     .wready_o   (pfifo_precon_not_full),
2654:     .rvalid_o   (pfifo_precon_not_empty),
2655:     .rdata_o    (pfifo_precon_rdata),
2656:     .rready_i   (pfifo_precon_pop),
2657:     .depth_o    ()
2658:   );
2659: 
2660:   // When bypassing the hardware conditioning - due to a) disabling FIPS mode or b) routing entropy
2661:   // to the ENTROPY_DATA register (ES_ROUTE) and bypassing the conditioner (ES_TYPE) - nothing is
2662:   // going into the conditioner.
2663:   assign pfifo_precon_push = es_bypass_mode ? 1'b0 :
2664:                              // In firmware override mode with extract & insert enabled, only bits
2665:                              // inserted by firmware continue down the pipeline.
2666:                              fw_ov_mode_entropy_insert ? fw_ov_fifo_wr_pulse :
2667:                              // Otherwise post-health test entropy bits continue to flow
2668:                              // downstream. This includes observe-only firmware override mode.
2669:                              sfifo_distr_not_empty;
2670: 
2671:   assign pfifo_precon_wdata = fw_ov_mode_entropy_insert ? fw_ov_wr_data :
2672:                               sfifo_distr_rdata;
2673: 
2674:   // For verification purposes, let post-disable data continue through to the SHA engine if it has
2675:   // made it past the health checks, when in standard (non-fw_ov) mode.  This allows scoreboards
2676:   // to use the same data set for computing both the SHA engine outputs and the health-check stats.
2677:   //
2678:   // In fw_ov mode it is preferable (from a verification standpoint) to clear all FIFOs whenever
2679:   // disabled. Given the lack of handshaking on the fw_ov register path, this is easier to predict.
2680:   // Also, there is no association between SHA data and health test windows in FW_OV mode, so there
2681:   // is no benefit in this mode to clearing the SHA FIFOs at the same time we clear the HT
2682:   // statistics.
2683:   //
2684:   // Corner case: Even in FW_OV mode, if a full SHA word is ready as the disable comes in,
2685:   // let it stay in the FIFO until the SHA engine has picked it up, as verification has no way
2686:   // of knowing if a word will get stalled by SHA backpressure.  This is not a problem however
2687:   // as the reset is only important for clearing 32-bit half-SHA-words.
2688:   assign pfifo_precon_clr = fw_ov_mode_entropy_insert ?
2689:                             ~es_enable_fo[10] & ~pfifo_precon_not_empty :
2690:                             ~es_delayed_enable & ~pfifo_precon_not_empty;
2691: 
2692:   assign pfifo_precon_pop = (pfifo_cond_push && sha3_msgfifo_ready);
2693: 
2694:   assign es_fw_ov_wr_alert = fw_ov_mode && fw_ov_mode_entropy_insert &&
2695:          fw_ov_fifo_wr_pulse && fw_ov_wr_fifo_full;
2696: 
2697:   assign es_fw_ov_disable_alert = fw_ov_mode && fw_ov_mode_entropy_insert &&
2698:          !es_bypass_mode && fw_ov_sha3_disable_pulse && fw_ov_wr_fifo_full;
2699: 
2700:   //--------------------------------------------
2701:   // entropy conditioner
2702:   //--------------------------------------------
2703:   // This block takes in either post-health test entropy bits (when running in FIPS/CC compliant
2704:   // mode) or entropy injected by software (when running in Firmware Override: Extract & Insert
2705:   // mode).
2706:   // The amount of entropy consumed to generate a 384-bit seed depends on the mode of operation:
2707:   // - In FIPS/CC compliant mode, HEALTH_TEST_WINDOWS.FIPS_WINDOW x 4 bits (by default 2048 bits)
2708:   //   are required to produce one 384-bit seed. For the first seed after start up, the number of
2709:   //   bits consumed is doubled to align with the required 1024 samples of 4 bits for startup
2710:   //   health testing.
2711:   //   For windows which fail a health test, the entropy is still absorbed by the SHA3 engine
2712:   //   but no seed is produced. In order for the SHA3 engine to produce a seed, the last window it
2713:   //   absorbed must have passed the health tests.
2714:   // - In Firmware Override: Extract & Insert mode, the operation of the SHA3 engine is software
2715:   //   defined.
2716:   //
2717:   // Note that the final absorption operation of the SHA3 engine is triggered by the main state
2718:   // machine (upon receiving the health-test done pulse). The SHA3 engine is also triggered
2719:   // internally by the padding logic whenever 832 bits (= the rate or block size of SHA3-384) have
2720:   // been received.
2721:   //
2722:   // Note on backpressure handling from the SHA3 engine:
2723:   // To avoid inferring a combo loop, the msg_valid_i input (pfifo_cond_push signal) must not
2724:   // depend on the msg_ready_o output (sha3_msgfifo_ready). However, we can always push into the
2725:   // SHA3 engine as long as the precon FIFO contains valid data. The ready output is just used to
2726:   // determine when to pop from the precon FIFO.
2727: 
2728:   assign pfifo_cond_push  = pfifo_precon_not_empty && !es_bypass_mode;
2729:   assign pfifo_cond_wdata = pfifo_precon_rdata;
2730: 
2731:   assign msg_data[0] = pfifo_cond_wdata;
2732: 
2733:   assign pfifo_cond_rdata = sha3_state[0][SeedLen-1:0];
2734: 
2735:   // SHA3 hashing engine
2736:   sha3 #(
2737:     .EnMasking (Sha3EnMasking)
2738:   ) u_sha3 (
2739:     .clk_i,
2740:     .rst_ni,
2741: 
2742:     // MSG_FIFO interface
2743:     .msg_valid_i (pfifo_cond_push),
2744:     .msg_data_i  (msg_data),
2745:     .msg_strb_i  ({8{pfifo_cond_push}}),
2746:     .msg_ready_o (sha3_msgfifo_ready),
2747: 
2748:     // Entropy interface - not using
2749:     .rand_valid_i    (1'b0),
2750:     .rand_early_i    (1'b0),
2751:     .rand_data_i     ('0),
2752:     .rand_aux_i      ('0),
2753:     .rand_update_o   (),
2754:     .rand_consumed_o (),
2755: 
2756:     // N, S: Used in cSHAKE mode
2757:     .ns_data_i       ('0), // ns_prefix),
2758: 
2759:     // Configurations
2760:     .mode_i     (sha3_pkg::Sha3), // Use SHA3 mode
2761:     .strength_i (sha3_pkg::L384), // Use keccak_strength_e of L384
2762: 
2763:     // Controls (CMD register)
2764:     .start_i    (sha3_start       ),
2765:     .process_i  (sha3_process     ),
2766:     .run_i      (1'b0             ), // For software application
2767:     .done_i     (sha3_done        ),
2768: 
2769:     // LC escalation
2770:     .lc_escalate_en_i (lc_ctrl_pkg::Off),
2771: 
2772:     .absorbed_o (sha3_absorbed),
2773:     .squeezing_o (sha3_squeezing),
2774: 
2775:     .block_processed_o (sha3_block_processed),
2776: 
2777:     .sha3_fsm_o (sha3_fsm),
2778: 
2779:     .state_valid_o (sha3_state_vld),
2780:     .state_o       (sha3_state),
2781: 
2782:     // REQ/ACK interface to avoid power spikes
2783:     .run_req_o(cs_aes_halt_req),
2784:     .run_ack_i(cs_aes_halt_i.cs_aes_halt_ack),
2785: 
2786:     .error_o (sha3_err),
2787:     .sparse_fsm_error_o (sha3_state_error),
2788:     .count_error_o  (sha3_count_error),
2789:     .keccak_storage_rst_error_o (sha3_rst_storage_err)
2790:   );
2791: 
2792:   //--------------------------------------------
2793:   // bypass SHA conditioner path
2794:   //--------------------------------------------
2795: 
2796:   prim_packer_fifo #(
2797:      .InW(PostHTWidth),
2798:      .OutW(SeedLen),
2799:      .ClearOnRead(1'b0)
2800:   ) u_prim_packer_fifo_bypass (
2801:     .clk_i      (clk_i),
2802:     .rst_ni     (rst_ni),
2803:     .clr_i      (pfifo_bypass_clr),
2804:     .wvalid_i   (pfifo_bypass_push),
2805:     .wdata_i    (pfifo_bypass_wdata),
2806:     .wready_o   (pfifo_bypass_not_full),
2807:     .rvalid_o   (pfifo_bypass_not_empty),
2808:     .rdata_o    (pfifo_bypass_rdata),
2809:     .rready_i   (pfifo_bypass_pop),
2810:     .depth_o    ()
2811:   );
2812: 
2813:   // Unless the hardware conditioning is bypassed - due to a) disabling FIPS mode or b) routing
2814:   // entropy to the ENTROPY_DATA register (ES_ROUTE) and bypassing the conditioner (ES_TYPE) -
2815:   // nothing is going into the bypass FIFO.
2816:   assign pfifo_bypass_push = !es_bypass_mode ? 1'b0 :
2817:                              // In firmware override mode with extract & insert enabled, only bits
2818:                              // inserted by firmware continue down the pipeline
2819:                              fw_ov_mode_entropy_insert ? fw_ov_fifo_wr_pulse :
2820:                              // Otherwise post-health test entropy bits continue to flow
2821:                              // downstream. This includes observe-only firmware override mode.
2822:                              sfifo_distr_not_empty;
2823: 
2824:   assign pfifo_bypass_wdata = fw_ov_mode_entropy_insert ? fw_ov_wr_data :
2825:                               sfifo_distr_rdata;
2826: 
2827:   assign pfifo_bypass_clr = !es_enable_fo[11];
2828: 
2829:   // Corner case: If the main state machine encounters an alert, drain the
2830:   // bypass fifo, to get rid of the seeds and let the HT stats continue.
2831:   assign pfifo_bypass_pop =
2832:          fw_ov_mode_entropy_insert ? pfifo_bypass_not_empty :
2833:          bypass_stage_pop;
2834: 
2835:   // mux to select between fips and bypass mode
2836:   assign final_es_data = es_bypass_mode ? pfifo_bypass_rdata : pfifo_cond_rdata;
2837: 
2838: 
2839:   //--------------------------------------------
2840:   // state machine to coordinate fifo flow
2841:   //--------------------------------------------
2842:   assign main_sm_done_pulse = rng_bit_en ? ht_done_pulse_qq : ht_done_pulse_q;
2843:   assign main_sm_ht_failed  = rng_bit_en ? ht_failed_qq : ht_failed_q;
2844: 
2845:   // SEC_CM: CTR.LOCAL_ESC
2846:   // SEC_CM: MAIN_SM.FSM.SPARSE
2847:   entropy_src_main_sm
2848:     u_entropy_src_main_sm (
2849:     .clk_i                (clk_i),
2850:     .rst_ni               (rst_ni),
2851:     .enable_i             (main_sm_enable),
2852:     .fw_ov_ent_insert_i   (fw_ov_mode_entropy_insert),
2853:     .fw_ov_sha3_start_i   (fw_ov_sha3_start_pfe),
2854:     .ht_done_pulse_i      (main_sm_done_pulse),
2855:     .ht_fail_pulse_i      (main_sm_ht_failed),
2856:     .alert_thresh_fail_i  (alert_threshold_fail),
2857:     .rst_alert_cntr_o     (rst_alert_cntr),
2858:     .bypass_mode_i        (es_bypass_mode),
2859:     .bypass_stage_rdy_i   (pfifo_bypass_not_empty),
2860:     .sha3_state_vld_i     (sha3_state_vld),
2861:     .main_stage_push_o    (main_stage_push_raw),
2862:     .bypass_stage_pop_o   (bypass_stage_pop),
2863:     .boot_phase_done_o    (boot_phase_done),
2864:     .sha3_start_o         (sha3_start_raw),
2865:     .sha3_process_o       (sha3_process),
2866:     .sha3_done_o          (sha3_done),
2867:     .local_escalate_i     (fatal_loc_events),
2868:     .main_sm_alert_o      (es_main_sm_alert),
2869:     .main_sm_idle_o       (es_main_sm_idle),
2870:     .main_sm_state_o      (es_main_sm_state),
2871:     .main_sm_err_o        (es_main_sm_err)
2872:   );
2873: 
2874:   // es to cs halt request to reduce power spikes
2875:   assign cs_aes_halt_d = cs_aes_halt_req;
2876:   assign cs_aes_halt_o.cs_aes_halt_req = cs_aes_halt_q;
2877: 
2878:   //--------------------------------------------
2879:   // Corner case masking of main_sm inputs/outputs
2880:   //--------------------------------------------
2881: 
2882:   // When operating in RNG mode the state machine does not respond
2883:   // immediately to disable requests if it processing the SHA output
2884:   // (here indicated by the cs_aes_halt_req handshake).  The SHA engine
2885:   // will continue to process even if the module is disabled.  These seeds
2886:   // that continue to process after the disable signal are referred to as
2887:   // stale.
2888:   //
2889:   // If the SHA processing were instantaneous, stale seeds would be discarded
2890:   // when the esfinal fifo was cleard on diable.  Though since processing
2891:   // can push through a disable pulse, stale seeds need to be identified,
2892:   // and held back from the esfinal FIFO.
2893:   //
2894:   // There is at most one seed processing at a time so, we simply need to
2895:   // detect when a stale seed has commenced processing, and mask the following
2896:   // main_stage_push signal.
2897: 
2898:   assign stale_seed_processing = ~es_bypass_mode & ~fw_ov_mode_entropy_insert &
2899:                                  cs_aes_halt_req & ~es_enable_fo[12];
2900:   assign sha3_flush_d = stale_seed_processing ? 1'b1 :
2901:                         main_stage_push_raw ? 1'b0 :
2902:                         sha3_flush_q;
2903: 
2904:   // If the user incorrectly disables the fw_ov SHA3 processing while
2905:   // data is in the pipeline, it can potentially scramble two outputs.
2906:   // Thus in addition to triggering a recoverable alert, we mark the
2907:   // following _two_ outputs as corrupted and to not let them in the
2908:   // esfinal FIFO
2909:   assign fw_ov_corrupted_d = es_fw_ov_disable_alert ? 2'b11 :
2910:                              !es_bypass_mode && main_stage_push_raw ? {1'b0, fw_ov_corrupted_q[1]} :
2911:                              fw_ov_corrupted_q;
2912: 
2913:   assign fw_ov_corrupted = (|fw_ov_corrupted_q) & !es_bypass_mode;
2914: 
2915: 
2916:   assign main_stage_push = main_stage_push_raw & !sha3_flush_q & !fw_ov_corrupted;
2917: 
2918:   // Use the delayed enable signal to keep the Main SM enabled while Data is in flight, and
2919:   // to make sure it receives a delayed disable pulse after finishing any final SHA processing
2920:   // commands
2921:   assign main_sm_enable = es_delayed_enable;
2922: 
2923:   // The main SM can also generate redundant start pulses. After data can be pushed into SHA,
2924:   // the SM can be disabled leaving entropy in the SHA sponge.  This is fine, but the SM will
2925:   // have no recollection of this previous start pulse.  We track redundant start pulses
2926:   // outside the SM and suppress them as needed.
2927:   assign sha3_start_mask_d = sha3_start_raw ? 1'b1 :
2928:                              sha3_process   ? 1'b0 :
2929:                              sha3_start_mask_q;
2930:   assign sha3_start = sha3_start_raw & ~sha3_start_mask_q;
2931: 
2932:   //--------------------------------------------
2933:   // send processed entropy to final fifo
2934:   //--------------------------------------------
2935: 
2936:   // SEC_CM: FIFO.CTR.REDUN
2937:   prim_fifo_sync #(
2938:     .Width(1+SeedLen),
2939:     .Pass(0),
2940:     .Depth(EsFifoDepth),
2941:     .OutputZeroIfEmpty(0),
2942:     .Secure(1)
2943:   ) u_prim_fifo_sync_esfinal (
2944:     .clk_i          (clk_i),
2945:     .rst_ni         (rst_ni),
2946:     .clr_i          (sfifo_esfinal_clr),
2947:     .wvalid_i       (sfifo_esfinal_push),
2948:     .wready_o       (sfifo_esfinal_not_full),
2949:     .wdata_i        (sfifo_esfinal_wdata),
2950:     .rvalid_o       (sfifo_esfinal_not_empty),
2951:     .rready_i       (sfifo_esfinal_pop),
2952:     .rdata_o        (sfifo_esfinal_rdata),
2953:     .full_o         (sfifo_esfinal_full),
2954:     .depth_o        (sfifo_esfinal_depth),
2955:     .err_o          (sfifo_esfinal_int_err)
2956:   );
2957: 
2958:   // The FIPS flag is fully determined in SW. This has to be the case since we don't know
2959:   // which mode of operation will be validated/certified. Another reason is that SW can
2960:   // set the threshold values arbitrarily, which on its own makes the FIPS bit basically
2961:   // SW defined.
2962:   assign fips_compliance = es_enable_fo[13] && fips_flag_pfe;
2963: 
2964:   // fifo controls
2965:   // No backpressure is possible at this point. If the esfinal FIFO is already full and a new seed
2966:   // is pushed, the push is ignored and the seed is lost.
2967:   assign sfifo_esfinal_push =
2968:          fw_ov_mode_entropy_insert && es_bypass_mode ? pfifo_bypass_not_empty :
2969:          main_stage_push;
2970: 
2971:   assign sfifo_esfinal_clr  = !es_enable_fo[14];
2972:   assign sfifo_esfinal_wdata = {fips_compliance,final_es_data};
2973:   assign sfifo_esfinal_pop = es_route_to_sw ? swread_done : es_hw_if_fifo_pop;
2974:   assign {esfinal_fips_flag,esfinal_data} = sfifo_esfinal_rdata;
2975: 
2976:   // fifo err
2977:   // Note that for the used prim_fifo_sync and prim_packer_fifo primitives it is not an error to
2978:   // push to a FIFO that is full. The primitives simply don't accept the data when full. The
2979:   // backpressure needs to be handled at the sender.
2980:   assign sfifo_esfinal_err =
2981:          {1'b0,
2982:           (sfifo_esfinal_pop && !sfifo_esfinal_not_empty),
2983:           (sfifo_esfinal_full && !sfifo_esfinal_not_empty) || sfifo_esfinal_int_err};
2984: 
2985:   // drive out hw interface
2986:   assign es_hw_if_req = entropy_src_hw_if_i.es_req;
2987:   assign entropy_src_hw_if_o.es_ack = es_hw_if_ack;
2988:   assign entropy_src_hw_if_o.es_bits = esfinal_data;
2989:   assign entropy_src_hw_if_o.es_fips = esfinal_fips_flag;
2990: 
2991:   // SEC_CM: ACK_SM.FSM.SPARSE
2992:   entropy_src_ack_sm u_entropy_src_ack_sm (
2993:     .clk_i            (clk_i),
2994:     .rst_ni           (rst_ni),
2995:     .enable_i         (es_enable_fo[15]),
2996:     .req_i            (es_hw_if_req),
2997:     .ack_o            (es_hw_if_ack),
2998:     .fifo_not_empty_i (sfifo_esfinal_not_empty && !es_route_to_sw),
2999:     .local_escalate_i (es_cntr_err),
3000:     .fifo_pop_o       (es_hw_if_fifo_pop),
3001:     .ack_sm_err_o     (es_ack_sm_err)
3002:   );
3003: 
3004:   //--------------------------------------------
3005:   // data path integrity check
3006:   // - a countermeasure to detect entropy bus tampering attempts
3007:   // - checks to make sure repeated data sets off
3008:   //   an alert for sw to handle
3009:   //--------------------------------------------
3010: 
3011:   // SEC_CM: ESFINAL_RDATA.BUS.CONSISTENCY
3012: 
3013:   // capture a copy of the entropy data
3014:   assign es_rdata_capt_vld = (sfifo_esfinal_pop && sfifo_esfinal_not_empty);
3015: 
3016:   assign es_rdata_capt_d = es_rdata_capt_vld ? sfifo_esfinal_rdata[63:0] : es_rdata_capt_q;
3017: 
3018:   assign es_rdata_capt_vld_d =
3019:          !es_enable_fo[16] ? 1'b0 :
3020:          es_rdata_capt_vld ? 1'b1 :
3021:          es_rdata_capt_vld_q;
3022: 
3023:   // continuous compare of the entropy data
3024:   assign es_bus_cmp_alert = es_rdata_capt_vld && es_rdata_capt_vld_q &&
3025:          (es_rdata_capt_q == sfifo_esfinal_rdata[63:0]);
3026: 
3027: 
3028:   //----------------------------------------------------
3029:   // software es read path via ENTROPY_DATA register
3030:   //----------------------------------------------------
3031: 
3032:   // Sync and evaluate the OTP input.
3033:   prim_mubi8_sync #(
3034:     .NumCopies(1),
3035:     .AsyncOn(1)
3036:   ) u_prim_mubi8_sync_es_fw_read (
3037:     .clk_i,
3038:     .rst_ni,
3039:     .mubi_i(otp_en_entropy_src_fw_read_i),
3040:     .mubi_o({en_entropy_src_fw_read})
3041:   );
3042:   assign efuse_es_sw_reg_en = prim_mubi_pkg::mubi8_test_true_strict(en_entropy_src_fw_read);
3043: 
3044:   // Is the ENTROPY_DATA register readable?
3045:   assign es_data_reg_rd_en = es_enable_fo[17] && efuse_es_sw_reg_en && entropy_data_reg_en_pfe;
3046: 
3047:   // Interface the esfinal FIFO and cut its 384-bit output into 32-bit chunks for software.
3048:   // We're done after the last read.
3049:   assign swread_done = reg2hw.entropy_data.re && (swread_idx_q == LastSwRead[SwReadIdxWidth-1:0]);
3050: 
3051:   // Increment the index counter upon reads from software.
3052:   assign swread_idx_incr = reg2hw.entropy_data.re;
3053: 
3054:   // Unless the ENTROPY_DATA CSR is readable, keep clearing the index counter. Clear the counter
3055:   // after a full seed has been read.
3056:   assign swread_idx_clr = !es_data_reg_rd_en || swread_done;
3057: 
3058:   // Index counter
3059:   assign swread_idx_d = !es_enable_fo[18] ? '0                  :
3060:                         swread_idx_clr    ? '0                  :
3061:                         swread_idx_incr   ? swread_idx_q + 1'b1 : swread_idx_q;
3062:   always_ff @(posedge clk_i or negedge rst_ni) begin : swread_idx_reg
3063:     if (!rst_ni) begin
3064:       swread_idx_q <= '0;
3065:     end else begin
3066:       swread_idx_q <= swread_idx_d;
3067:     end
3068:   end
3069: 
3070:   // Forward the relevant part of the valid esfinal output or 0 if ES_ROUTE is off.
3071:   assign swread_data = sfifo_esfinal_not_empty && es_route_to_sw ?
3072:       esfinal_data[swread_idx_q * FullRegWidth +: FullRegWidth] : '0;
3073: 
3074:   // This primitive is used to place a size-only constraint on the buffers to act as a synthesis
3075:   // optimization barrier. This ensures ES_ROUTE and ENTROPY_DATA_REG_ENABLE together with the OTP
3076:   // input are taken into account in separately.
3077:   prim_buf #(
3078:     .Width(FullRegWidth)
3079:   ) u_prim_buf_swread_data (
3080:     .in_i (swread_data),
3081:     .out_o(swread_data_buf)
3082:   );
3083: 
3084:   // Forward the data to the ENTROPY_DATA CSR or 0 if the CSR is not readable.
3085:   assign hw2reg.entropy_data.d = es_data_reg_rd_en ? swread_data_buf : '0;
3086: 
3087: 
3088:   //--------------------------------------------
3089:   // unused signals
3090:   //--------------------------------------------
3091: 
3092:   assign unused_err_code_test_bit = (|{err_code_test_bit[27:25],err_code_test_bit[19:4]});
3093:   assign unused_sha3_state = (|sha3_state[0][sha3_pkg::StateW-1:SeedLen]);
3094:   assign unused_entropy_data = (|reg2hw.entropy_data.q);
3095:   assign unused_fw_ov_rd_data = (|reg2hw.fw_ov_rd_data.q);
3096:   assign unused_sfifo_esrng_not_full = sfifo_esrng_not_full;
3097:   assign unused_sfifo_esfinal_not_full = sfifo_esfinal_not_full;
3098: 
3099:   //--------------------------------------------
3100:   // Assertions
3101:   //--------------------------------------------
3102: `ifdef INC_ASSERT
3103: `include "prim_macros.svh"
3104: 
3105:   // Assert that we request high quality entropy only when the rng_fips field of the conf register
3106:   // is set to Mubi4True.
3107:   `ASSERT(RngFipsOutputHighInFipsMode_A,
3108:           prim_mubi_pkg::mubi4_test_true_loose(mubi4_t'(reg2hw.conf.rng_fips.q)) === rng_fips_o)
3109: 
3110:   // Count number of disables since last reset.
3111:   logic [63:0] disable_cnt_d, disable_cnt_q;
3112:   always_comb begin
3113:     disable_cnt_d = disable_cnt_q;
3114:     if (!mubi4_test_true_strict(mubi_mod_en_dly_d) &&
3115:         mubi4_test_true_strict(mubi_mod_en_dly_q)) begin
3116:       disable_cnt_d += 1;
3117:     end
3118:   end
3119: 
3120:   // Assert that no entropy gets dropped during FIPS-compliant operation mode.
3121:   //
3122:   // The following code, which includes counters, small FSMs, and assertions, tracks entropy bits
3123:   // from the noise source input through Entropy Source to the hardware interface output and checks
3124:   // that in FIPS-compliant mode entropy does not get dropped unless it should get dropped.  The
3125:   // code is arranged in the same order as entropy flows through Entropy Source, so having Entropy
3126:   // Source's block diagram ready when reading this code is highly recommended.
3127: 
3128:   // Delay `es_delayed_enable` by one clock cycle to track when Entropy Source actually accepts RNG
3129:   // inputs.
3130:   logic es_delayed_enable_d, es_delayed_enable_q;
3131:   assign es_delayed_enable_d = es_delayed_enable;
3132: 
3133:   // Count number of valid bits from RNG input (RNG_BUS_WIDTH wide) while Entropy Source is enabled.
3134:   logic [63:0] rng_valid_bit_cnt_d, rng_valid_bit_cnt_q;
3135:   assign rng_valid_bit_cnt_d = entropy_src_rng_i.rng_valid && es_enable_fo[5] &&
3136:                                es_delayed_enable_q ?
3137:                                rng_valid_bit_cnt_q + RNG_BUS_WIDTH :
3138:                                rng_valid_bit_cnt_q;
3139: 
3140:   // Count number of bits pushed into esrng FIFO (RngBusWidth wide).
3141:   logic [63:0] esrng_push_bit_cnt_d, esrng_push_bit_cnt_q;
3142:   assign esrng_push_bit_cnt_d = sfifo_esrng_push & sfifo_esrng_not_full ?
3143:                                 esrng_push_bit_cnt_q + RngBusWidth :
3144:                                 esrng_push_bit_cnt_q;
3145: 
3146:   // Assert that as many bits got pushed into the esrng FIFO (destination) as there were valid RNG
3147:   // input bits (source).  RngBusWidth bits may get lost after every re-enable; add a margin to
3148:   // account for that.
3149:   `ASSERT_AT_RESET_AND_FINAL(ValidRngBitsPushedIntoEsrngFifo_A,
3150:                              `WITHIN_MARGIN(esrng_push_bit_cnt_q,        // actual
3151:                                             rng_valid_bit_cnt_q,         // expected
3152:                                             disable_cnt_q * RngBusWidth, // allowed less
3153:                                             0))                          // allowed more
3154: 
3155:   // Count number of bits pushed into esbit FIFO (1 wide input, RngBusWidth wide output).
3156:   logic [63:0] esbit_push_bit_cnt_d, esbit_push_bit_cnt_q;
3157:   assign esbit_push_bit_cnt_d = pfifo_esbit_push & pfifo_esbit_not_full ?
3158:                                 esbit_push_bit_cnt_q + 1 :
3159:                                 esbit_push_bit_cnt_q;
3160: 
3161:   // Count number of bits pushed into postht FIFO (RngBusWidth wide input, PostHTWidth wide output).
3162:   logic [63:0] postht_push_bit_cnt_d, postht_push_bit_cnt_q;
3163:   assign postht_push_bit_cnt_d = pfifo_postht_push & pfifo_postht_not_full ?
3164:                                  postht_push_bit_cnt_q + RngBusWidth :
3165:                                  postht_push_bit_cnt_q;
3166: 
3167:   // Count number of bits pushed into postht FIFO from esrng FIFO.
3168:   logic [63:0] postht_from_esrng_push_bit_cnt_d, postht_from_esrng_push_bit_cnt_q;
3169:   assign postht_from_esrng_push_bit_cnt_d =
3170:       pfifo_postht_push & pfifo_postht_not_full & ~rng_bit_en ?
3171:       postht_from_esrng_push_bit_cnt_q + RngBusWidth :
3172:       postht_from_esrng_push_bit_cnt_q;
3173: 
3174:   // Assert that as many bits got pushed into the esbit FIFO or the postht FIFO (destinations) as
3175:   // into the esrng FIFO (source).  The number of bits pushed into the esbit FIFO has to be
3176:   // multiplied by the output width of the esrng FIFO (RngBusWidth) because only 1 bit gets pushed
3177:   // into the esbit FIFO for every pop from the esrng FIFO.  Add a margin (allowed less) because:
3178:   // - RngBusWidth bits may get lost after every re-enable
3179:   // - one entry may just have been pushed into esrng FIFO when the assertion gets evaluated.
3180:   `ASSERT_AT_RESET_AND_FINAL(EsrngFifoPushedIntoEsbitOrPosthtFifos_A,
3181:                              `WITHIN_MARGIN((esbit_push_bit_cnt_q * RngBusWidth +
3182:                                              postht_from_esrng_push_bit_cnt_q), // actual
3183:                                             esrng_push_bit_cnt_q,               // expected
3184:                                             (disable_cnt_q + 1) * RngBusWidth,  // allowed less
3185:                                             0))                                 // allowed more
3186: 
3187:   // Count number of bits pushed into postht FIFO from esbit FIFO.
3188:   logic [63:0] postht_from_esbit_push_bit_cnt_d, postht_from_esbit_push_bit_cnt_q;
3189:   assign postht_from_esbit_push_bit_cnt_d =
3190:       pfifo_postht_push & pfifo_postht_not_full & rng_bit_en ?
3191:       postht_from_esbit_push_bit_cnt_q + RngBusWidth :
3192:       postht_from_esbit_push_bit_cnt_q;
3193: 
3194:   // Assert that as many bits got pushed into the postht FIFO (destination) as into the esbit FIFO
3195:   // (source) when the latter was selected as source.  Add a margin (allowed less) because:
3196:   // - RngBusWidth bits may get lost after every re-enable
3197:   // - esbit FIFO may be partially full when the assertion gets evaluated.
3198:   `ASSERT_AT_RESET_AND_FINAL(EsbitFifoPushedIntoPosthtFifo_A,
3199:                              `WITHIN_MARGIN(postht_from_esbit_push_bit_cnt_q,      // actual
3200:                                             esbit_push_bit_cnt_q,                  // expected
3201:                                             (disable_cnt_q + 1) * RngBusWidth - 1, // allowed less
3202:                                             0))                                    // allowed more
3203: 
3204:   // Assert that as many bits got pushed into the postht FIFO as got counted from the esrng FIFO or
3205:   // the esbit FIFO.  This assertion checks more the completeness of the other assertions than the
3206:   // design itself.
3207:   `ASSERT_AT_RESET_AND_FINAL(PosthtFifoPushedFromEsbitOrEsrngFifos_A,
3208:                              postht_push_bit_cnt_q == (postht_from_esrng_push_bit_cnt_q +
3209:                                                        postht_from_esbit_push_bit_cnt_q))
3210: 
3211:   // Count number of bits popped from postht FIFO (PostHTWidth wide output) when bypass mode was
3212:   // disabled.
3213:   logic [63:0] postht_non_bypass_pop_bit_cnt_d, postht_non_bypass_pop_bit_cnt_q;
3214:   assign postht_non_bypass_pop_bit_cnt_d =
3215:       pfifo_postht_pop & pfifo_postht_not_empty & ~es_bypass_mode ?
3216:       postht_non_bypass_pop_bit_cnt_q + PostHTWidth :
3217:       postht_non_bypass_pop_bit_cnt_q;
3218: 
3219:   // Count number of bits pushed into distr FIFO (DistrFifoWidth wide input and output).
3220:   logic [63:0] distr_non_bypass_push_bit_cnt_d, distr_non_bypass_push_bit_cnt_q;
3221:   assign distr_non_bypass_push_bit_cnt_d =
3222:       sfifo_distr_push & sfifo_distr_not_full & ~es_bypass_mode ?
3223:       distr_non_bypass_push_bit_cnt_q + DistrFifoWidth :
3224:       distr_non_bypass_push_bit_cnt_q;
3225: 
3226:   // Assert that as many bits got pushed into the distr FIFO (destination) as got popped from the
3227:   // postht FIFO when bypass mode was disabled (source).
3228:   `ASSERT_AT_RESET_AND_FINAL(PosthtFifoPushedIntoDistrFifo_A,
3229:                              distr_non_bypass_push_bit_cnt_q == postht_non_bypass_pop_bit_cnt_q)
3230: 
3231:   // Count number of bits popped from distr FIFO (DistrFifoWidth wide output) when bypass mode was
3232:   // disabled.
3233:   logic [63:0] distr_non_bypass_pop_bit_cnt_d, distr_non_bypass_pop_bit_cnt_q;
3234:   assign distr_non_bypass_pop_bit_cnt_d =
3235:       sfifo_distr_pop & sfifo_distr_not_empty & ~es_bypass_mode ?
3236:       distr_non_bypass_pop_bit_cnt_q + DistrFifoWidth :
3237:       distr_non_bypass_pop_bit_cnt_q;
3238: 
3239:   // Count number of bits pushed into precon FIFO (ObserveFifoWidth wide input, PreCondWidth wide
3240:   // output).
3241:   logic [63:0] precon_push_bit_cnt_d, precon_push_bit_cnt_q;
3242:   assign precon_push_bit_cnt_d = pfifo_precon_push & pfifo_precon_not_full ?
3243:                                  precon_push_bit_cnt_q + ObserveFifoWidth :
3244:                                  precon_push_bit_cnt_q;
3245: 
3246:   // Assert that as many bits got pushed into the precon FIFO (destination) as got popped from the
3247:   // distr FIFO when bypass mode was disabled (source).
3248:   `ASSERT_AT_RESET_AND_FINAL(DistrFifoPushedIntoPreconFifo_A,
3249:                              precon_push_bit_cnt_q == distr_non_bypass_pop_bit_cnt_q)
3250: 
3251:   // Track when boot and startup checks are completing.
3252:   logic boot_startup_checks_completing;
3253:   assign boot_startup_checks_completing =
3254:       (u_entropy_src_main_sm.state_q == entropy_src_main_sm_pkg::StartupPass1 &
3255:        u_entropy_src_main_sm.ht_done_pulse_i &
3256:        ~u_entropy_src_main_sm.ht_fail_pulse_i);
3257: 
3258:   // Track state of boot and startup checks.
3259:   typedef enum logic [1:0] {
3260:     BscStIncomplete,  // checks incomplete
3261:     BscStPassed,      // checks passed
3262:     BscStPushed       // entropy from passed checks pushed
3263:   } bsc_state_e;
3264:   bsc_state_e bsc_state_d, bsc_state_q;
3265:   always_comb begin
3266:     bsc_state_d = bsc_state_q;
3267:     unique case (bsc_state_q)
3268:       BscStIncomplete: begin
3269:         if (boot_startup_checks_completing) begin
3270:           // Checks have just completed.
3271:           bsc_state_d = BscStPassed;
3272:         end
3273:       end
3274:       BscStPassed: begin
3275:         if (main_stage_push) begin
3276:           // Entropy from passed checks is being pushed.
3277:           bsc_state_d = BscStPushed;
3278:         end
3279:       end
3280:       BscStPushed: begin
3281:         // Boot and startup checks remained passed and their entropy pushed until Entropy Source
3282:         // gets disabled again (which is handled below).
3283:         bsc_state_d = bsc_state_q;
3284:       end
3285:       default: bsc_state_d = BscStIncomplete;
3286:     endcase
3287:     // If not enabled, always clear to incomplete.
3288:     if (!es_delayed_enable) begin
3289:       bsc_state_d = BscStIncomplete;
3290:     end
3291:   end
3292: 
3293:   // Count number of bits pushed into precon FIFO (ObserveFifoWidth wide input, PreCondWidth wide
3294:   // output) after boot and startup checks.
3295:   logic [63:0] precon_post_startup_push_bit_cnt_d, precon_post_startup_push_bit_cnt_q;
3296:   assign precon_post_startup_push_bit_cnt_d =
3297:       pfifo_precon_push & pfifo_precon_not_full & (bsc_state_q != BscStIncomplete) ?
3298:       precon_post_startup_push_bit_cnt_q + ObserveFifoWidth :
3299:       precon_post_startup_push_bit_cnt_q;
3300: 
3301:   // Track when esfinal FIFO gets pushed while bypass mode is disabled.
3302:   logic esfinal_non_bypass_push;
3303:   assign esfinal_non_bypass_push = sfifo_esfinal_push & sfifo_esfinal_not_full & ~es_bypass_mode;
3304: 
3305:   // Count number of bits pushed into esfinal FIFO (SeedLen bits per push) while bypass mode was
3306:   // disabled.
3307:   logic [63:0] esfinal_non_bypass_push_cnt_d, esfinal_non_bypass_push_cnt_q;
3308:   assign esfinal_non_bypass_push_cnt_d = esfinal_non_bypass_push ?
3309:                                          esfinal_non_bypass_push_cnt_q + SeedLen :
3310:                                          esfinal_non_bypass_push_cnt_q;
3311: 
3312:   // Count number of bits pushed into esfinal FIFO (SeedLen bits per push) after startup checks have
3313:   // passed and while bypass mode was disabled.
3314:   logic [63:0] esfinal_post_startup_push_bit_cnt_d, esfinal_post_startup_push_bit_cnt_q;
3315:   assign esfinal_post_startup_push_bit_cnt_d =
3316:       esfinal_non_bypass_push & (bsc_state_q != BscStIncomplete) ?
3317:       esfinal_post_startup_push_bit_cnt_q + SeedLen :
3318:       esfinal_post_startup_push_bit_cnt_q;
3319: 
3320:   // Assert that all bits pushed into the esfinal FIFO came from or after passed startup checks.
3321:   `ASSERT_AT_RESET_AND_FINAL(EsfinalFifoPushed_A,
3322:                              esfinal_non_bypass_push_cnt_q == esfinal_post_startup_push_bit_cnt_q)
3323: 
3324:   // Track result of health tests after boot and startup tests.
3325:   typedef enum logic [1:0] {
3326:     HtStNoResult, // no health test result is currently available
3327:     HtStPassed,   // last health test has passed and entropy has not propagated from conditioner yet
3328:     HtStFailed    // last health test has failed
3329:   } ht_state_e;
3330:   ht_state_e ht_state_d, ht_state_q;
3331:   always_comb begin
3332:     ht_state_d = ht_state_q;
3333:     if (bsc_state_q == BscStPushed) begin
3334:       if (ht_state_q inside {HtStNoResult, HtStFailed}) begin
3335:         if (health_test_done_pulse) begin
3336:           if (!any_fail_pulse && !alert_threshold_fail) begin
3337:             ht_state_d = HtStPassed;
3338:           end else begin
3339:             ht_state_d = HtStFailed;
3340:           end
3341:         end
3342:       end else if (ht_state_q == HtStPassed) begin
3343:         if (main_stage_push_raw) begin
3344:           ht_state_d = HtStNoResult;
3345:         end
3346:       end else begin
3347:         ht_state_d = HtStNoResult;
3348:       end
3349:       if (ht_state_q == HtStFailed) begin
3350:         `ASSERT_I(NoPushAfterFailedHealthTest_A, rst_ni !== 1'b1 || !main_stage_push_raw)
3351:       end
3352:     end
3353:     // If not enabled, always clear to no result.
3354:     if (!es_delayed_enable) begin
3355:       ht_state_d = HtStNoResult;
3356:     end
3357:   end
3358: 
3359:   // Count number of bits that are expected to have gotten pushed into precon FIFO and into esfinal
3360:   // FIFO after boot and startup checks and while bypass mode was disabled.
3361:   logic [63:0] precon_post_startup_exp_push_bit_cnt_d, precon_post_startup_exp_push_bit_cnt_q;
3362:   logic [63:0] esfinal_post_startup_exp_push_bit_cnt_d, esfinal_post_startup_exp_push_bit_cnt_q;
3363:   always_comb begin
3364:     esfinal_post_startup_exp_push_bit_cnt_d = esfinal_post_startup_exp_push_bit_cnt_q;
3365:     precon_post_startup_exp_push_bit_cnt_d = precon_post_startup_exp_push_bit_cnt_q;
3366:     if (bsc_state_q == BscStPassed && bsc_state_d == BscStPushed) begin
3367:       // On the completion of boot and startup checks, SeedLen bits are expected to be pushed into
3368:       // the esfinal FIFO.
3369:       esfinal_post_startup_exp_push_bit_cnt_d += SeedLen;
3370:     end
3371:     if (bsc_state_q != BscStIncomplete && health_test_done_pulse) begin
3372:       // Once boot and startup checks have completed, (4 * health_test_window) bits are expected to
3373:       // have gotten pushed into the precon FIFO.
3374:       precon_post_startup_exp_push_bit_cnt_d += 4 * health_test_window;
3375:     end
3376:     if (ht_state_q == HtStPassed && main_stage_push_raw && sfifo_esfinal_not_full) begin
3377:       // If none of the health tests failed and the alert threshold has not been exceeded, SeedLen
3378:       // bits are expected to be pushed into the esfinal FIFO -- unless we expect them to get
3379:       // dropped (see above).
3380:       esfinal_post_startup_exp_push_bit_cnt_d += SeedLen;
3381:     end
3382:     // When Entropy Source gets disabled after boot and startup checks have been completed, add the
3383:     // number of bits that have been pushed into precon FIFO since the last conditioner output to
3384:     // the expected number of bits.
3385:     if ((bsc_state_q != BscStIncomplete) && (bsc_state_d == BscStIncomplete)) begin
3386:       logic [63:0] diff_;
3387:       diff_ = precon_post_startup_push_bit_cnt_q - precon_post_startup_exp_push_bit_cnt_q;
3388:       // Assert that the difference is not negative.
3389:       `ASSERT_I(PreconPostStartupDiffNonNegative_A,
3390:                 rst_ni !== 1'b1 || (precon_post_startup_push_bit_cnt_q >=
3391:                                     precon_post_startup_exp_push_bit_cnt_q))
3392:       // Assert that the difference is smaller than the number of bits that would have sufficed to
3393:       // get pushed into the conditioner.
3394:       `ASSERT_I(PreconPostStartupDiffSmall_A, rst_ni !== 1'b1 || diff_ < (4 * health_test_window))
3395:       precon_post_startup_exp_push_bit_cnt_d += diff_;
3396:     end
3397:   end
3398:   // This code assumes that `health_test_window` does not change dynamically; capture that in an
3399:   // assertion ensuring it only changes when entropy_src is not enabled.
3400:   `ASSERT(HealthTestWindowStableWhenEnabled_A,
3401:           mubi4_test_true_strict(mubi_es_enable) |-> $stable(health_test_window))
3402: 
3403:   // Assert that all bits pushed into the esfinal FIFO after startup checks were expected.
3404:   `ASSERT_AT_RESET_AND_FINAL(EsfinalFifoPushedPostStartup_A,
3405:                              esfinal_post_startup_push_bit_cnt_q ==
3406:                              esfinal_post_startup_exp_push_bit_cnt_q)
3407: 
3408:   // Assert that the expected number of bits pushed into the precon FIFO based on the number of
3409:   // outputs of the conditioner matches the actual number of bits pushed into the precon FIFO after
3410:   // startup checks.  Add a margin (allowed more) as the simulation may end when bits in the precon
3411:   // FIFO have not resulted in conditioner output and Entropy Source has not been disabled.
3412:   logic [63:0] ppspb_allowed_more;
3413:   assign ppspb_allowed_more = bsc_state_q != BscStIncomplete ? 4 * health_test_window : '0;
3414:   `ASSERT_AT_RESET_AND_FINAL(PreconFifoPushedPostStartup_A,
3415:                              `WITHIN_MARGIN(precon_post_startup_push_bit_cnt_q,     // actual
3416:                                             precon_post_startup_exp_push_bit_cnt_q, // expected
3417:                                             0,                                      // allowed less
3418:                                             ppspb_allowed_more))                    // allowed more
3419: 
3420:   always_ff @(posedge clk_i, negedge rst_ni) begin
3421:     if (!rst_ni) begin
3422:       esbit_push_bit_cnt_q                <= '0;
3423:       esfinal_non_bypass_push_cnt_q       <= '0;
3424:       esfinal_post_startup_push_bit_cnt_q <= '0;
3425:       esrng_push_bit_cnt_q                <= '0;
3426:       postht_from_esbit_push_bit_cnt_q    <= '0;
3427:       postht_from_esrng_push_bit_cnt_q    <= '0;
3428:       postht_non_bypass_pop_bit_cnt_q     <= '0;
3429:       postht_push_bit_cnt_q               <= '0;
3430:       distr_non_bypass_pop_bit_cnt_q      <= '0;
3431:       distr_non_bypass_push_bit_cnt_q     <= '0;
3432:       precon_post_startup_push_bit_cnt_q  <= '0;
3433:       precon_push_bit_cnt_q               <= '0;
3434:       rng_valid_bit_cnt_q                 <= '0;
3435:     end else if (es_delayed_enable & !fw_ov_mode_entropy_insert) begin
3436:       // All these counters get updated if and only if entropy_src is enabled and the firmware
3437:       // override entropy insertion mode is disabled.  Otherwise, there are no guarantees on how
3438:       // much entropy from the noise source gets dropped due to backpressure.
3439:       esbit_push_bit_cnt_q                <= esbit_push_bit_cnt_d;
3440:       esfinal_non_bypass_push_cnt_q       <= esfinal_non_bypass_push_cnt_d;
3441:       esfinal_post_startup_push_bit_cnt_q <= esfinal_post_startup_push_bit_cnt_d;
3442:       esrng_push_bit_cnt_q                <= esrng_push_bit_cnt_d;
3443:       postht_from_esbit_push_bit_cnt_q    <= postht_from_esbit_push_bit_cnt_d;
3444:       postht_from_esrng_push_bit_cnt_q    <= postht_from_esrng_push_bit_cnt_d;
3445:       postht_non_bypass_pop_bit_cnt_q     <= postht_non_bypass_pop_bit_cnt_d;
3446:       postht_push_bit_cnt_q               <= postht_push_bit_cnt_d;
3447:       distr_non_bypass_pop_bit_cnt_q      <= distr_non_bypass_pop_bit_cnt_d;
3448:       distr_non_bypass_push_bit_cnt_q     <= distr_non_bypass_push_bit_cnt_d;
3449:       precon_post_startup_push_bit_cnt_q  <= precon_post_startup_push_bit_cnt_d;
3450:       precon_push_bit_cnt_q               <= precon_push_bit_cnt_d;
3451:       rng_valid_bit_cnt_q                 <= rng_valid_bit_cnt_d;
3452:     end
3453:   end
3454: 
3455:   always_ff @(posedge clk_i, negedge rst_ni) begin
3456:     if (!rst_ni) begin
3457:       bsc_state_q                             <= BscStIncomplete;
3458:       disable_cnt_q                           <= '0;
3459:       es_delayed_enable_q                     <= '0;
3460:       esfinal_post_startup_exp_push_bit_cnt_q <= '0;
3461:       ht_state_q                              <= HtStNoResult;
3462:       precon_post_startup_exp_push_bit_cnt_q  <= '0;
3463:     end else begin
3464:       bsc_state_q                             <= bsc_state_d;
3465:       disable_cnt_q                           <= disable_cnt_d;
3466:       es_delayed_enable_q                     <= es_delayed_enable_d;
3467:       esfinal_post_startup_exp_push_bit_cnt_q <= esfinal_post_startup_exp_push_bit_cnt_d;
3468:       ht_state_q                              <= ht_state_d;
3469:       precon_post_startup_exp_push_bit_cnt_q  <= precon_post_startup_exp_push_bit_cnt_d;
3470:     end
3471:   end
3472: 
3473:   // When triggering the conditioner, the precon FIFO must be empty. The postht and distr FIFOs
3474:   // must have been empty in the cycle before. Otherwise, some entropy bits tested as part of the
3475:   // current window won't make into the corresponding seed.
3476:   //
3477:   // In Firmware Override: Extract & Insert mode, we don't care as firmware is responsible for
3478:   // filling the precon FIFO and for triggering the conditioner:
3479:   // - If the conditioner is triggered without the precon FIFO being empty, a recoverable alert is
3480:   //   signaled.
3481:   // - The fill levels of the postht and distr FIFOs are irrelevant for the conditioner in this
3482:   //   mode.
3483:   `ASSERT(FifosEmptyWhenShaProcess_A,
3484:       !fw_ov_mode_entropy_insert && $rose(sha3_process) |->
3485:       $past(!pfifo_postht_not_empty) && $past(!sfifo_distr_not_empty) && !pfifo_precon_not_empty)
3486: `endif
3487: 
3488: endmodule

================================== Ai Message ==================================
Tool Calls:
  run_anomaly_detector_agent (call_Jj4z8Z7pFNNRQyJQ9gJlEpmP)
 Call ID: call_Jj4z8Z7pFNNRQyJQ9gJlEpmP
  Args:
    design_filepath: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/entropy_src/rtl/entropy_src_core.sv
    top_module: entropy_src_core
    security_objective: Configuration enforcement and entropy path integrity
