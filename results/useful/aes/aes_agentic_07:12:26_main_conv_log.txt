================================ System Message ================================


    You are a supervisor agent in a multi-agent system focused on identifying hardware security vulnerabilities in RTL code. 
    Your objective is to analyze the given SoC and generate a detailed security report.

    You have access to the following tools: ['run_anomaly_detector_agent', 'run_llm_cwe_checker_agent', 'run_similar_bug_agent', 'list_dir', 'read_file', 'read_file_with_line_numbers']. Each tool specializes in a specific task:

    - CWE Agent: Given a Verilog file, a top module, and a security aspect, this agent maps the RTL code to relevant CWEs and detects CWE-related vulnerabilities.
    - Similar Bug Agent: Accepts a file path and a line number (where a bug was found) to locate similar patterns or recurring bugs throughout the RTL code.

    Instructions for analysis:

    - Read the documentataion to identify security features and register interfaces policies.
    - Read through the different systemverilog files to probe for issues and use the anomaly agent
    - If a bug is detected but not localized, use the CWE Agent to further inspect the related security aspect in the surrounding RTL.
    - After detecting any bugs, use the Similar Bug Agent to scan similar files (of the same or of different IPs) for similar vulnerabilities.

    Output Format:

    - For each identified issue, report:
    - File name
    - Line number(s)
    - Brief description of the issue
    - Security aspect affected
    - Tools used to identify the issue

    When your analysis is complete, end your response with "END".
    
================================ Human Message =================================

Identify security issues in the aes IP of the OpenTitan SoC, located at /home/eden/Desktop/Code/HACK@CHES/p2/opentitan.

    - All IPs are located in the 'hw/ip' directory.
    - RTL code for each IP is located in its 'rtl' subdirectory, with source files having the '.sv' extension.
        - reg_top files contain the register interface for the IP.
        - control/fsm files contain the control logic for the IP.
        - core files contain the core logic for the IP.
    - Documentation files (.md) are located in the 'doc' directories of each IP.
        - theory_of_operation explains the properties of the IP and its security features.
        - registers.md files contain the register interface and its read/write access policies.
    - Ignore '.core' files; they are used by build tools and are not relevant for security analysis.

    Focus on the aes IP and make sure to analyze it thoroughly.

    First, identify the relevant security properties and read/write policies of the register interfaces from the documentation. 
    Then, use all available tools to perform a comprehensive security analysis on the RTL code.
    
================================== Ai Message ==================================
Tool Calls:
  list_dir (call_B3jCmGgC4v9i9vDBG6bCl82J)
 Call ID: call_B3jCmGgC4v9i9vDBG6bCl82J
  Args:
    dir_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip
================================= Tool Message =================================
Name: list_dir

Files in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip:
README.md BUILD

Directories in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip:
pattgen csrng aon_timer prim_generic keymgr_dpe uart keymgr i2c dma spi_host otp_ctrl rom_ctrl spi_device edn usbdev adc_ctrl trial1 kmac flash_ctrl otp_macro rv_dm mbx rv_timer prim_xilinx prim prim_xilinx_ultrascale aes lc_ctrl hmac rv_core_ibex sram_ctrl entropy_src racl_ctrl sysrst_ctrl tlul soc_dbg_ctrl otbn ascon
================================== Ai Message ==================================
Tool Calls:
  list_dir (call_wsnHcUHb8PwhpxpytB5gDPqv)
 Call ID: call_wsnHcUHb8PwhpxpytB5gDPqv
  Args:
    dir_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes
================================= Tool Message =================================
Name: list_dir

Files in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes:
aes.core aes_wrap.core README.md BUILD defs.bzl

Directories in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes:
pre_dv data model pre_syn syn dv rtl lint doc pre_sca
================================== Ai Message ==================================
Tool Calls:
  list_dir (call_vhJg4EkZJtIxTxK4AOuSGGCZ)
 Call ID: call_vhJg4EkZJtIxTxK4AOuSGGCZ
  Args:
    dir_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes/doc
================================= Tool Message =================================
Name: list_dir

Files in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes/doc:
registers.md interfaces.md checklist.md programmers_guide.md aes_block_diagram_cipher_core_masked.svg aes_block_diagram.svg theory_of_operation.md

Directories in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes/doc:

================================== Ai Message ==================================
Tool Calls:
  read_file (call_NnaU6Dft9hJJxEkSn3mpPAWw)
 Call ID: call_NnaU6Dft9hJJxEkSn3mpPAWw
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes/doc/theory_of_operation.md
================================= Tool Message =================================
Name: read_file

# Theory of Operation

The AES unit supports both encryption and decryption for AES-128/192/256 in ECB, CBC, CFB, OFB and CTR modes using a single, shared data path.
That is, it can either do encryption or decryption but not both at the same time.

The AES unit features a key expanding mechanism to generate the required round keys on-the-fly from a single initial key provided through the register interface.
This means the processor needs to provide just the initial encryption key to the AES unit via register interface.
The AES unit then uses this key to generate all round keys as they are needed in parallel to the actual encryption/decryption.
The benefits of this design compared to passing all round keys via register interface include:

- Reduced storage requirements and smaller circuit area: Instead of storing 15 128-bit round keys, only 3 256-bit key registers are required for AES-256:
  - one set of registers to which the processor writes the initial key, i.e., the start key for encryption,
  - one set of registers to hold the current full key, and
  - one set of registers to hold the full key of the last encryption round, i.e., the start key for decryption.
- Faster re-configuration and key switching: The core just needs to perform 8 write operations instead of 60 write operations for AES-256.

On-the-fly round-key generation comes however at the price of an initial delay whenever the key is changed by the processor before the AES unit can perform ECB/CBC **decryption** using this new key.
During this phase, the key expanding mechanism iteratively computes the start key for the decryption.
The duration of this delay phase corresponds to the latency required for encrypting one 16B block (i.e., 12/14/16 cycles for AES-128/192/256).
Once the start key for decryption has been computed, it is stored in a dedicated internal register for later use.
The AES unit can then switch between decryption and encryption without additional overhead.

For encryption or if the mode is set to CFB, OFB or CTR, there is no such initial delay upon changing the key.
If the next operation after a key switch is ECB or CBC **decryption**, the AES unit automatically initiates a key expansion using the key schedule first (to generate the start key for decryption, the actual data path remains idle during that phase).

The AES unit uses a status register to indicate to the processor when ready to receive the next input data block via the register interface.
While the AES unit is performing encryption/decryption of a data block, it is safe for the processor to provide the next input data block.
The AES unit automatically starts the encryption/decryption of the next data block once the previous encryption/decryption is finished and new input data is available.
The order in which the input registers are written does not matter.
Every input register must be written at least once for the AES unit to automatically start encryption/decryption.
This is the default behavior.
It can be disabled by setting the MANUAL_OPERATION bit in [`CTRL_SHADOWED`](registers.md#ctrl_shadowed) to `1`.
In this case, the AES unit only starts the encryption/decryption once the START bit in [`TRIGGER`](registers.md#trigger) is set to `1` (automatically cleared to `0` once the next encryption/decryption is started).

Similarly, the AES unit indicates via a status register when having new output data available to be read by the processor.
Also, there is a back-pressure mechanism for the output data.
If the AES unit wants to finish the encryption/decryption of a data block but the previous output data has not yet been read by the processor, the AES unit is stalled.
It hangs and does not drop data.
It only continues once the previous output data has been read and the corresponding registers can be safely overwritten.
The order in which the output registers are read does not matter.
Every output register must be read at least once for the AES unit to continue.
This is the default behavior.
It can be disabled by setting the MANUAL_OPERATION bit in [`CTRL_SHADOWED`](registers.md#ctrl_shadowed) to `1`.
In this case, the AES unit never stalls and just overwrites previous output data, independent of whether it has been read or not.


## Block Diagram

This AES unit targets medium performance (\~1 cycle per round for the unmasked implementation).
High-speed, single-cycle operation for high-bandwidth data streaming is not required.

Therefore, the AES unit uses an iterative cipher core architecture with a 128-bit wide data path as shown in the figure below.
Note that for the sake of simplicity, the figure shows the unmasked implementation.
For details on the masked implementation of the cipher core refer to [Security Hardening below](#security-hardening)).
Using an iterative architecture allows for a smaller circuit area at the cost of throughput.
Employing a 128-bit wide data path allows to achieve the latency requirements of 12/14/16 clock cycles per 16B data block in AES-128/192/256 mode in the unmasked implementation, respectively.

![AES unit block diagram (unmasked implementation) with shared data paths for encryption and decryption (using the Equivalent Inverse Cipher).](../doc/aes_block_diagram.svg)

Inside the cipher core, both the data paths for the actual cipher (left) and the round key generation (right) are shared between encryption and decryption.
Consequently, the blocks shown in the diagram always implement the forward and backward (inverse) version of the corresponding operation.
For example, SubBytes implements both SubBytes and InvSubBytes.

Besides the actual AES cipher core, the AES unit features a set of control and status registers (CSRs) accessible by the processor via TL-UL bus interface, and a counter module (used in CTR mode only).
This counter module implements the Standard Incrementing Function according to [Recommendation for Block Cipher Modes of Operation (Appendix B.1)](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf) with a fixed parameter m = 128.
Note that for AES, parameter b = 128 and the counter increment is big-endian.
CFB mode is supported with a fixed parameter s = 128 (CFB-128).
Support for data segment sizes other than 128 bits would require a substantial amount of additional muxing resources and is thus not provided.
The initialization vector (IV) register and the register to hold the previous input data are used in CBC, CFB, OFB and CTR modes only.


## Design Details

This section discusses different design details of the AES module.


### Datapath Architecture and Operation

The AES unit implements the Equivalent Inverse Cipher described in the [AES specification](https://csrc.nist.gov/csrc/media/publications/fips/197/final/documents/fips-197.pdf).
This allows for more efficient cipher data path sharing between encryption/decryption as the operations are applied in the same order (less muxes, simpler control), but requires the round key during decryption to be transformed using an inverse MixColumns in all rounds except for the first and the last one.

This architectural choice targets at efficient cipher data path sharing and low area footprint.
Depending on the application scenario, other architectures might offer a more suitable area/performance tradeoff.
For example if only CFB, OFB or CTR modes are ever used, the inverse cipher is not used at all.
Moreover, if the key is changed extremely rarely (as for example in the case of bulk decryption), it may pay off to store all round keys instead of generating them on the fly.
Future versions of the AES unit might offer compile-time parameters to selectively instantiate the forward/inverse cipher part only to allow for dedicated encryption/decryption-only units.

All submodules in the data path are purely combinational.
The only sequential logic in the cipher and round key generation are the State, Full Key and Decryption Key registers.

The following description explains how the AES unit operates, i.e., how the operation of the AES cipher is mapped to the datapath architecture of the AES unit.
Phrases in italics apply to peculiarities of different block cipher modes.
For a general introduction into these cipher modes, refer to [Recommendation for Block Cipher Modes of Operation](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf).

1. The configuration and initial key is provided to the AES unit via a set of control and status registers (CSRs) accessible by the processor via TL-UL bus interface.
   The processor must first provide the configuration to the [`CTRL_SHADOWED`](registers.md#ctrl_shadowed) register.
   Then follows the initial key.
   Each key register must be written at least once.
   The order in which the registers are written does not matter.
1. _The processor provides the initialization vector (IV) or initial counter value to the four IV registers via TL-UL bus interface in CBC, CFB and OFB modes, or CTR mode, respectively.
   Each IV register must be written at least once.
   The order in which the registers are written does not matter.
   Note that while operating, the AES unit automatically updates the IV registers after having consumed the current IV value.
   Whenever a new message is started, the processor must provide the corresponding IV value via TL-UL bus interface.
   In ECB mode, no IV needs to be provided.
   The content of the IV registers is ignored in ECB mode._
1. The input data is provided to the AES unit via four CSRs.
   Each input register must be written at least once.
   The order in which the registers are written does not matter.
1. If new input data is available, the AES unit automatically starts encryption/decryption by performing the following actions.
    1. The AES unit loads initial state into the State register inside the cipher core.

       _Depending on the cipher mode, the initial state is a combination of input data as well as IV._
       _Note, if CBC decryption is performed, or if running in CFB, OFB or CTR mode, the input data is also registered (Data In Prev in the block diagram)._
    2. The initial key is loaded into the Full Key register inside the cipher core.

       _Note, if the ECB/CBC decryption is performed, the Full Key register is loaded with the value stored in the Decryption Key register._

    _Note, for the AES unit to automatically start in CBC, CFB, OFB or CTR mode, also the IV must be ready.
    The IV is ready if -- since the last IV update (either done by the processor or the AES unit itself) -- all IV registers have been written at least once or none of them.
    The AES unit will not automatically start the next encryption/decryption with a partially updated IV._

    By setting the MANUAL_OPERATION bit in [`CTRL_SHADOWED`](registers.md#ctrl_shadowed) to `1`, the AES unit can be operated in manual mode.
    In manual mode, the AES unit starts encryption/decryption whenever the START bit in [`TRIGGER`](registers.md#trigger) is set to `1`, irrespective of the status of the IV and input data registers.

1. Once the State and Full Key registers have been loaded, the AES cipher core starts the encryption/decryption by adding the first round key to the initial state (all blocks in both data paths are bypassed).
   The result is stored back in the State register.
1. Then, the AES cipher core performs 9/11/13 rounds of encryption/decryption when using a 128/192/256-bit key, respectively.
   In every round, the cipher data path performs the four following transformations.
   For more details, refer to the [AES specification](https://csrc.nist.gov/csrc/media/publications/fips/197/final/documents/fips-197.pdf).
    1. SubBytes Transformation: A non-linear byte substitution that operates independently on each byte of the state using a substitution table (S-Box).
    2. ShiftRows Transformation: The bytes of the last three rows of the state are cyclically shifted over different offsets.
    3. MixColumns Transformation: Each of the four columns of the state are considered as polynomials over GF(2^8) and individually multiplied with another fixed polynomial.
    4. AddRoundKey Transformation: The round key is XORed with the output of the MixColumns operation and stored back into the State register.
       The 128-bit round key itself is extracted from the current value in the Full Key register.

    In parallel, the full key used for the next round is computed on the fly using the key expand module.

    _If running in CTR mode, the counter module iteratively updates the IV in parallel to the cipher core performing encryption/decryption.
    Internally, the counter module uses one 16-bit counter, meaning it requires 8 clock cycles to increment the 128-bit counter value stored in the IV register.
    Since the counter value is used in the first round only, and since the encryption/decryption of a single block takes 12/14/16 cycles, the iterative counter implementation does not affect the throughput of the AES unit._
1. Finally, the AES cipher core performs the final encryption/decryption round in which the MixColumns operation is skipped.
   The output is forwarded to the output register in the CSRs but not stored back into the State register.
   The internal State register is cleared with pseudo-random data.

   _Depending on the cipher mode, the output of the final round is potentially XORed with either the value in the IV registers (CBC decryption) or the value stored in the previous input data register (CFB, OFB, CTR modes), before being forwarded to the output register in the CSRs.
   If running in CBC mode, the IV registers are updated with the output data (encryption) or the value stored in the previous input data register (decryption).
   If running in CFB or OFB mode, the IV registers are updated with the output data or the output of the final cipher round (before XORing with the previous input data), respectively._

Having separate registers for input, output and internal state prevents the extraction of intermediate state via TL-UL bus interface and allows to overlap reconfiguration with operation.
While the AES unit is performing encryption/decryption, the processor can safely write the next input data block into the CSRs or read the previous output data block from the CSRs.
The State register is internal to the AES unit and not exposed via the TL-UL bus interface.
If the AES unit wants to finish the encryption/decryption of an output data block but the previous one has not yet been read by the processor, the AES unit is stalled.
It hangs and does not drop data.
It only continues once the previous output data has been read and the corresponding registers can be safely overwritten.
The order in which the output registers are read does not matter.
Every output register must be read at least once for the AES unit to continue.
In contrast, the initial key, and control register can only be updated if the AES unit is idle, which eases design verification (DV).
Similarly, the initialization vector (IV) register can only be updated by the processor if the AES unit is idle.
If the AES unit is busy and running in CBC or CTR mode, the AES unit itself updates the IV register.

The cipher core architecture of the AES unit is derived from the architecture proposed by Satoh et al.: ["A compact Rijndael Hardware Architecture with S-Box Optimization"](https://link.springer.com/chapter/10.1007%2F3-540-45682-1_15).
The expected circuit area in a 110nm CMOS technology is in the order of 12 - 22 kGE (unmasked implementation, AES-128 only).
The expected circuit area of the entire AES unit with masking enabled is around 112 kGE.

For a description of the various sub modules, see the following sections.


### SubBytes / S-Box

The SubBytes operation is a non-linear byte substitution that operates independently on each byte of the state using a substitution table (S-Box).
It is both used for the cipher data path and the key expand data path.
In total, the AES unit instantiates 20 S-Boxes in parallel (16 for SubBytes, 4 for KeyExpand), each having 8-bit input and output.
In combination with the 128-bit wide data path, this allows to perform one AES round per iteration.

The design of this S-Box and its inverse can have a big impact on circuit area, timing critical path, robustness and power leakage, and is itself its own research topic.

The S-Boxes are decoupled from the rest of the AES unit with a handshake protocol, allowing them to be easily replaced by different implementations if required.
The AES unit comes with the following S-Box implementations that can be selected by a compile-time Verilog parameter:
- Domain-oriented masking (DOM) S-Box: default, see [Gross et al.: "Domain-Oriented Masking: Compact Masked Hardware Implementations with Arbitrary Protection Order"](https://eprint.iacr.org/2016/486.pdf)
- Masked Canright S-Box: provided for reference, usage discouraged, a version w/ and w/o mask re-use is provided, see [Canright and Batina: "A very compact "perfectly masked" S-Box for AES (corrected)"](https://eprint.iacr.org/2009/011.pdf)
- Canright S-Box: only use when disabling masking, recommended when targeting ASIC implementation, see [Canright: "A very compact Rijndael S-Box"](https://hdl.handle.net/10945/25608)
- LUT-based S-Box: only use when disabling masking, recommended when targeting FPGA implementation

The DOM S-Box has a latency of 5 clock cycles.
All other implementations are fully combinational (one S-Box evaluation every clock cycle).
See also [Security Hardening below.](#1st-order-masking-of-the-cipher-core)

### ShiftRows

The ShiftRows operation simply performs a cyclic shift of Rows 1, 2 and 3 of the state matrix.
Consequently, it can be implemented using 3\*4 32-bit 2-input muxes (encryption/decryption).


### MixColumns

Each of the four columns of the state are considered as polynomials over GF(2^8) and individually multiplied with another fixed polynomial.
The whole operation can be implemented using 36 2-input XORs and 16 4-input XORs (all 8-bit), 8 2-input muxes (8-bit), as well as 78 2-input and 24 3-input XOR gates.


### KeyExpand

The key expand module (KEM) integrated in the AES unit is responsible for generating the various round keys from the initial key for both encryption and decryption.
The KEM generates the next 128/192/256-bit full key in parallel to the actual encryption/decryption based on the current full key or the initial key (for the first encryption round).
The actual 128-bit round key is then extracted from this full key.

Generating the keys on-the-fly allows for lower storage requirements and smaller circuit area but comes at the price of an initial delay before doing ECB/CBC **decryption** whenever the key is changed.
During this phase, the KEM cycles through all full keys to obtain the start key for decryption (equals the key for final round of encryption).
The duration of this delay phase corresponds to the latency required for encrypting one 16B block.
During this initial phase, the cipher data path is kept idle.

The timing diagram below visualizes this process.

```wavejson
{
  signal: [
    {    name: 'clk',       wave: 'p........|.......'},
    ['TL-UL IF',
      {  name: 'write',     wave: '01...0...|.......'},
      {  name: 'addr',      wave: 'x2345xxxx|xxxxxxx', data: 'K0 K1 K2 K3'},
      {  name: 'wdata',     wave: 'x2345xxxx|xxxxxxx', data: 'K0 K1 K2 K3'},
    ],
    {},
    ['AES Unit',
      {  name: 'Config op', wave: 'x4...............', data: 'DECRYPT'},
      {  name: 'AES op',    wave: '2........|.4.....', data: 'IDLE DECRYPT'},
      {  name: 'KEM op',    wave: '2....3...|.4.....', data: 'IDLE ENCRYPT DECRYPT'},
      {  name: 'round',     wave: 'xxxxx2.22|22.2222', data: '0 1 2 9 0 1 2 3 4'},
      {  name: 'key_init',  wave: 'xxxx5....|.......', data: 'K0-3'},
      {  name: 'key_full',  wave: 'xxxxx5222|4.22222', data: 'K0-3 f(K) f(K) f(K) K0-3\' f(K) f(K) f(K) f(K) f(K)'},
      {  name: 'key_dec',   wave: 'xxxxxxxxx|4......', data: 'K0-3\''},
    ]
  ]
}
```

The AES unit is configured to do decryption (`Config op` = DECRYPT).
Once the new key has been provided via the control and status registers (top), this new key is loaded into the Full Key register (`key_full` = K0-3) and the KEM starts performing encryption (`KEM op`=ENCRYPT).
The cipher data path remains idle (`AES op`=IDLE).
In every round, the value in `key_full` is updated.
After 10 encryption rounds, the value in `key_full` equals the start key for decryption.
This value is stored into the Decryption Key register (`key_dec` = K0-3' at the very bottom).
Now the AES unit can switch between encryption/decryption without overhead as both the start key for encryption (`key_init`) and decryption (`key_dec`) can be loaded into `full_key`.

For details on the KeyExpand operation refer to the [AES specification, Section 5.2](https://csrc.nist.gov/csrc/media/publications/fips/197/final/documents/fips-197.pdf).

Key expanding is the only operation in the AES unit for which the functionality depends on the selected key length.
Having a KEM that supports 128-bit key expansion, support for the 256-bit mode can be added at low overhead.
In contrast, the 192-bit mode requires much larger muxes.
Support for this mode is thus optional and can be enabled/disabled via a design-time parameter.

Once we have cost estimates in terms of gate count increase for 192-bit mode, we can decide on whether or not to use it in OpenTitan.
Typically, systems requiring security above AES-128 go directly for AES-256.

### System Key-Manager Interface

By default, the AES unit is controlled entirely by the processor.
The processor writes both input data as well as the initial key to dedicated registers via the system bus interconnect.

Alternatively, the processor can configure the AES unit to use an initial key provided by the [key manager](../../keymgr/README.md) via key sideload interface without exposing the key to the processor or other hosts attached to the system bus interconnect.
To this end, the processor has to set the SIDELOAD bit in [`CTRL_SHADOWED`](registers.md#ctrl_shadowed) to `1`.
Any write operations of the processor to the Initial Key registers [`KEY_SHARE0_0`](registers.md#key_share0) - [`KEY_SHARE1_7`](registers.md#key_share1) are then ignored.
In normal/automatic mode, the AES unit only starts encryption/decryption if the sideload key is marked as valid.
To update the sideload key, the processor has to 1) wait for the AES unit to become idle, 2) wait for the key manager to update the sideload key and assert the valid signal, and 3) write to the [`CTRL_SHADOWED`](registers.md#ctrl_shadowed) register to start a new message.
After using a sideload key, the processor has to trigger the clearing of all key registers inside the AES unit (see [De-Initialization](programmers_guide.md#de-initialization) below).


# Security Hardening

The AES unit employs different means at architectural, micro-architectural and physical levels for security hardening against side-channel analysis and fault injection.

## Side-Channel Analysis

To deter side-channel analysis (SCA), the AES unit implements the following countermeasures.

### 1st-order Masking of the Cipher Core

The AES unit employs 1st-order masking of the AES cipher core.
More precisely, both the cipher and the key expand data path use two shares.
As shown in the block diagram below, the width of all registers and data paths basically doubles.

![Block diagram of the masked AES cipher core.](../doc/aes_block_diagram_cipher_core_masked.svg)

The initial key is provided in two shares via the register interface.
The input data is provided in unmasked form and masked outside of the cipher core to obtain the two shares of the initial state.
The pseudo-random data (PRD) required for masking the input data is provided by the pseudo-random number generator (PRNG) of the cipher core.
Similarly, the two shares of the output state are combined outside the cipher core to obtain the output data.

The same PRNG also generates the fresh randomness required by the masked SubBytes (16 masked S-Boxes) and the masked KeyExpand (4 masked S-Boxes).
The masking scheme selected for the S-Box can have a high impact on SCA resistance, circuit area, number of PRD bits consumed per cycle and per S-Box evaluation, and throughput.
The selection of the masked S-Box implementation can be controlled via compile-time Verilog parameter.
By default, the AES unit uses domain-oriented masking (DOM) for the S-Boxes as proposed by [Gross et al.: "Domain-Oriented Masking: Compact Masked Hardware Implementations with Arbitrary Protection Order".](https://eprint.iacr.org/2016/486.pdf)
The provided implementation has a latency of 5 clock cycles per S-Box evaluation.
As a result, the overall latency for processing a 16-byte data block increases from 12/14/16 to 56/66/72 clock cycles in AES-128/192/256 mode, respectively.
The provided implementation further forwards partial, intermediate results among DOM S-Box instances for remasking purposes.
This allows to reduce circuit area related to generating, buffering and applying PRD without impacting SCA resistance.
Alternatively, the two original versions of the masked Canright S-Box can be chosen as proposed by [Canright and Batina: "A very compact "perfectly masked" S-Box for AES (corrected)".](https://eprint.iacr.org/2009/011.pdf)
These are fully combinational (one S-Box evaluation every cycle) and have lower area footprint, but they are significantly less resistant to SCA.
They are mainly included for reference but their usage is discouraged due to potential vulnerabilities to the correlation-enhanced collision attack as described by [Moradi et al.: "Correlation-Enhanced Power Analysis Collision Attack".](https://eprint.iacr.org/2010/297.pdf)

The masking PRNG is reseeded with fresh entropy via [EDN](../../edn/README.md) automatically 1) whenever a new key is provided (see [`CTRL_AUX_SHADOWED.KEY_TOUCH_FORCES_RESEED`](registers.md#ctrl_aux_shadowed)) and 2) based on a block counter.
The rate at which this block counter initiates automatic reseed operations can be configured via [`CTRL_SHADOWED.PRNG_RESEED_RATE`](registers.md#ctrl_shadowed--prng_reseed_rate).
In addition software can manually initiate a reseed operation via [`TRIGGER.PRNG_RESEED`](registers.md#trigger--prng_reseed).

Note that the masking can be enabled/disabled via compile-time Verilog parameter.
It may be acceptable to disable the masking when using the AES cipher core for random number generation e.g. inside [CSRNG.](../../csrng/README.md)
When disabling the masking, also an unmasked S-Box implementation needs to be selected using the corresponding compile-time Verilog parameter.
When disabling masking, it is recommended to use the unmasked Canright or LUT S-Box implementation for ASIC or FPGA targets, respectively.
Both are fully combinational and allow for one S-Box evaluation every clock cycle.

It's worth noting that since input/output data are provided/retrieved via register interface in unmasked form, the AES unit should not be used to form an identity ladder where the output of one AES operation is used to form the key for the next AES operation in the ladder.
In OpenTitan, the [Keccak Message Authentication Code (KMAC) unit](../../kmac/README.md) is used for that purpose.

### Fully-Parallel Data Path

Any 1st-order masking scheme primarily protects against 1st-order SCA.
Vulnerabilities against higher-order SCA might still be present.
A common technique to impede higher-order attacks is to increase the noise in the system e.g. by leveraging parallel architectures.
To this end, the AES cipher core uses a 128-bit parallel data path with a total of up to 20 S-Boxes (16 inside SubBytes, 4 inside KeyExpand) that are evaluated in parallel.

Besides more noise for increased resistance against higher-order SCA, the fully-parallel architecture also enables for higher performance and flexibility.
It allows users to seamlessly switch out the S-Box implementation in order to experiment with different masking schemes.
To interface the data paths with the S-Boxes, a handshake protocol is used.

### Note on Reset vs. Non-Reset Flip-Flops

The choice of flip-flop type for registering sensitive assets such as keys can have implications on the vulnerability against e.g. combined reset glitch attacks and SCA.
Following the [OpenTitan non-reset vs. reset flops rationale](https://github.com/lowRISC/opentitan/issues/2603), the following observations can be made:
- If masking is enabled, key and state values are stored in two shares inside the AES unit.
  Neither the Hamming weights of the individual shares nor the summed Hamming weight are proportional to the Hamming weight of the secret asset.
- Input/output data and IV values are (currently) not stored in multiple shares but these are less critical as they are used only once.
  Further, they are stored in banks of 32 bits leaving a larger hypothesis space compared to when glitching e.g. an 8-bit register into reset.
  In addition, they could potentially also be extracted when being transferred over the TL-UL bus interface.

For this reason, the AES unit uses reset flops only.
However, all major key and data registers are cleared with pseudo-random data upon reset.

### Clearing Registers with Pseudo-Random Data

Upon reset or if initiated by software, all major key and data registers inside the AES module are cleared with pseudo-random data (PRD).
This helps to reduce SCA leakage when both writing these registers for reconfiguration and when clearing the registers after use.

In addition, the state registers inside the cipher core are cleared with PRD during the last round of every encryption/decryption.
This prevents Hamming distance leakage between the states of the last two rounds as well as between output and input data.

## Fault Injection

Fault injection (FI) attacks can be distinguished based on the FI target.

### Control Path

In cryptographic devices, fault attacks on the control path usually aim to disturb the control flow in a way to facilitate SCA or other attacks.
Example targets for AES include: switch to less secure mode of operation (ECB), keep processing the same input data, reduce the number of rounds/early termination, skip particular rounds, skip individual operations in a round.

To protect against FI attacks on the control path, the AES unit implements the following countermeasures.

- Shadowed Control Register:
  The main control register is implemented as a shadow register.
  This means software has to perform two subsequent write operations to perform an update.
  Internally, a shadow copy is used that is constantly compared with the actual register.
  For further details, refer to the [Register Tool documentation.](../../../../util/reggen/README.md#shadow-registers)

- Sparse encodings of FSM states:
  All FSMs inside the AES unit use sparse state encodings.

- Sparse encodings for mux selector signals:
  All main muxes use sparsely encoded selector signals.

- Sparse encodings for handshake and other important control signals.

- Multi-rail control logic:
  All FSMs inside the AES unit are implemented using multiple independent and redundant logic rails.
  Every rail evaluates and drives exactly one bit of sparsely encoded handshake or other important control signals.
  The outputs of the different rails are constantly compared to detect potential faults.
  The number of logic rails can be scaled up by means of relatively easy RTL modifications.
  By default, three independent logic rails are used.

- Hardened round counter:
  Similar to the cipher core FSM, the internal round counter is protected against FI through a multi-rail implementation.
  The outputs of the different rails are constantly compared to detect potential faults in the round counter.

If any of these countermeasures detects a fault, a fatal alert is triggered, the internal FSMs go into a terminal error state, the AES unit does not release further data and locks up until reset.
Since the AES unit has no ability to reset itself, a system-supplied reset is required before the AES unit can become operational again.
Such a condition is reported in [`STATUS.ALERT_FATAL_FAULT`](registers.md#status--alert_fatal_fault).
Details on where the fault has been detected are not provided.

### Data Path

The aim of fault attacks on the data path is typically to extract information on the key by means of statistical analysis.
The current version of the AES unit does not employ countermeasures against such attacks, but future versions most likely will.

================================== Ai Message ==================================
Tool Calls:
  read_file (call_itsB0qesQd635NxpX6iw7cwb)
 Call ID: call_itsB0qesQd635NxpX6iw7cwb
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes/doc/registers.md
================================= Tool Message =================================
Name: read_file

# Registers

The AES unit uses 8 and 2x4 separate write-only registers for the initial key, initialization vector, and input data, as well as 4 separate read-only registers for the output data.
All registers are little-endian.
Compared to first-in, first-out (FIFO) interfaces, having separate registers has a couple of advantages:

- Supported out-of-the-box by the register tool (the FIFO would have to be implemented separately).
- Usability: critical corner cases where software updates input data or the key partially only are easier to avoid using separate registers and the `hwqe`-signals provided by the Register Tool.
- Easier interaction with DMA engines

Also, using a FIFO interface for something that is not actually FIFO (internally, 16B of input/output data are consumed/produced at once) is less natural.

For a detailed overview of the register tool, please refer to the [Register Tool documentation.](../../../../util/reggen/README.md)

<!-- BEGIN CMDGEN util/regtool.py -d ./hw/ip/aes/data/aes.hjson -->
## Summary

| Name                                          | Offset   |   Length | Description                              |
|:----------------------------------------------|:---------|---------:|:-----------------------------------------|
| aes.[`ALERT_TEST`](#alert_test)               | 0x0      |        4 | Alert Test Register                      |
| aes.[`KEY_SHARE0_0`](#key_share0)             | 0x4      |        4 | Initial Key Registers Share 0.           |
| aes.[`KEY_SHARE0_1`](#key_share0)             | 0x8      |        4 | Initial Key Registers Share 0.           |
| aes.[`KEY_SHARE0_2`](#key_share0)             | 0xc      |        4 | Initial Key Registers Share 0.           |
| aes.[`KEY_SHARE0_3`](#key_share0)             | 0x10     |        4 | Initial Key Registers Share 0.           |
| aes.[`KEY_SHARE0_4`](#key_share0)             | 0x14     |        4 | Initial Key Registers Share 0.           |
| aes.[`KEY_SHARE0_5`](#key_share0)             | 0x18     |        4 | Initial Key Registers Share 0.           |
| aes.[`KEY_SHARE0_6`](#key_share0)             | 0x1c     |        4 | Initial Key Registers Share 0.           |
| aes.[`KEY_SHARE0_7`](#key_share0)             | 0x20     |        4 | Initial Key Registers Share 0.           |
| aes.[`KEY_SHARE1_0`](#key_share1)             | 0x24     |        4 | Initial Key Registers Share 1.           |
| aes.[`KEY_SHARE1_1`](#key_share1)             | 0x28     |        4 | Initial Key Registers Share 1.           |
| aes.[`KEY_SHARE1_2`](#key_share1)             | 0x2c     |        4 | Initial Key Registers Share 1.           |
| aes.[`KEY_SHARE1_3`](#key_share1)             | 0x30     |        4 | Initial Key Registers Share 1.           |
| aes.[`KEY_SHARE1_4`](#key_share1)             | 0x34     |        4 | Initial Key Registers Share 1.           |
| aes.[`KEY_SHARE1_5`](#key_share1)             | 0x38     |        4 | Initial Key Registers Share 1.           |
| aes.[`KEY_SHARE1_6`](#key_share1)             | 0x3c     |        4 | Initial Key Registers Share 1.           |
| aes.[`KEY_SHARE1_7`](#key_share1)             | 0x40     |        4 | Initial Key Registers Share 1.           |
| aes.[`IV_0`](#iv)                             | 0x44     |        4 | Initialization Vector Registers.         |
| aes.[`IV_1`](#iv)                             | 0x48     |        4 | Initialization Vector Registers.         |
| aes.[`IV_2`](#iv)                             | 0x4c     |        4 | Initialization Vector Registers.         |
| aes.[`IV_3`](#iv)                             | 0x50     |        4 | Initialization Vector Registers.         |
| aes.[`DATA_IN_0`](#data_in)                   | 0x54     |        4 | Input Data Registers.                    |
| aes.[`DATA_IN_1`](#data_in)                   | 0x58     |        4 | Input Data Registers.                    |
| aes.[`DATA_IN_2`](#data_in)                   | 0x5c     |        4 | Input Data Registers.                    |
| aes.[`DATA_IN_3`](#data_in)                   | 0x60     |        4 | Input Data Registers.                    |
| aes.[`DATA_OUT_0`](#data_out)                 | 0x64     |        4 | Output Data Register.                    |
| aes.[`DATA_OUT_1`](#data_out)                 | 0x68     |        4 | Output Data Register.                    |
| aes.[`DATA_OUT_2`](#data_out)                 | 0x6c     |        4 | Output Data Register.                    |
| aes.[`DATA_OUT_3`](#data_out)                 | 0x70     |        4 | Output Data Register.                    |
| aes.[`CTRL_SHADOWED`](#ctrl_shadowed)         | 0x74     |        4 | Control Register.                        |
| aes.[`CTRL_AUX_SHADOWED`](#ctrl_aux_shadowed) | 0x78     |        4 | Auxiliary Control Register.              |
| aes.[`CTRL_AUX_REGWEN`](#ctrl_aux_regwen)     | 0x7c     |        4 | Lock bit for Auxiliary Control Register. |
| aes.[`TRIGGER`](#trigger)                     | 0x80     |        4 | Trigger Register.                        |
| aes.[`STATUS`](#status)                       | 0x84     |        4 | Status Register                          |

## ALERT_TEST
Alert Test Register
- Offset: `0x0`
- Reset default: `0x0`
- Reset mask: `0x3`

### Fields

```wavejson
{"reg": [{"name": "recov_ctrl_update_err", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "fatal_fault", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 30}], "config": {"lanes": 1, "fontsize": 10, "vspace": 230}}
```

|  Bits  |  Type  |  Reset  | Name                  | Description                                      |
|:------:|:------:|:-------:|:----------------------|:-------------------------------------------------|
|  31:2  |        |         |                       | Reserved                                         |
|   1    |   wo   |   0x0   | fatal_fault           | Write 1 to trigger one alert event of this kind. |
|   0    |   wo   |   0x0   | recov_ctrl_update_err | Write 1 to trigger one alert event of this kind. |

## KEY_SHARE0
Initial Key Registers Share 0.

The actual initial key corresponds to Initial Key Registers Share 0 XORed with Initial Key Registers Share 1.
Loaded into the internal Full Key register upon starting encryption/decryption of the next block.
All key registers (Share 0 and Share 1) must be written at least once when the key is changed, regardless of key length (write random data for unused bits).
The order in which the registers are updated does not matter.
Can only be updated when the AES unit is idle.
If the AES unit is non-idle, writes to these registers are ignored.
Upon reset, these registers are cleared with pseudo-random data.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name         | Offset   |
|:-------------|:---------|
| KEY_SHARE0_0 | 0x4      |
| KEY_SHARE0_1 | 0x8      |
| KEY_SHARE0_2 | 0xc      |
| KEY_SHARE0_3 | 0x10     |
| KEY_SHARE0_4 | 0x14     |
| KEY_SHARE0_5 | 0x18     |
| KEY_SHARE0_6 | 0x1c     |
| KEY_SHARE0_7 | 0x20     |


### Fields

```wavejson
{"reg": [{"name": "key_share0", "bits": 32, "attr": ["wo"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name       | Description         |
|:------:|:------:|:-------:|:-----------|:--------------------|
|  31:0  |   wo   |   0x0   | key_share0 | Initial Key Share 0 |

## KEY_SHARE1
Initial Key Registers Share 1.

The actual initial key corresponds to Initial Key Registers Share 0 XORed with Initial Key Registers Share 1.
Loaded into the internal Full Key register upon starting encryption/decryption of the next block.
All key registers (Share 0 and Share 1) must be written at least once when the key is changed, regardless of key length (write random data for unused bits).
The order in which the registers are updated does not matter.
Can only be updated when the AES unit is idle.
If the AES unit is non-idle, writes to these registers are ignored.
Upon reset, these registers are cleared with pseudo-random data.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name         | Offset   |
|:-------------|:---------|
| KEY_SHARE1_0 | 0x24     |
| KEY_SHARE1_1 | 0x28     |
| KEY_SHARE1_2 | 0x2c     |
| KEY_SHARE1_3 | 0x30     |
| KEY_SHARE1_4 | 0x34     |
| KEY_SHARE1_5 | 0x38     |
| KEY_SHARE1_6 | 0x3c     |
| KEY_SHARE1_7 | 0x40     |


### Fields

```wavejson
{"reg": [{"name": "key_share1", "bits": 32, "attr": ["wo"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name       | Description         |
|:------:|:------:|:-------:|:-----------|:--------------------|
|  31:0  |   wo   |   0x0   | key_share1 | Initial Key Share 1 |

## IV
Initialization Vector Registers.

The initialization vector (IV) or initial counter value must be written to these registers when starting a new message in CBC or CTR mode (see Control Register), respectively.
In CBC and CTR modes, the AES unit does not start encryption/decryption with a partially updated IV.
Each register has to be written at least once.
The order in which the registers are written does not matter.
If the AES unit is non-idle, writes to these registers are ignored.
Whenever starting a new message, the corresponding IV value must be provided by the processor.
Once started, the AES unit automatically updates the contents of these registers.
In ECB mode, the IV registers are not used and do not need to be configured.
Upon reset, these registers are cleared with pseudo-random data.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name   | Offset   |
|:-------|:---------|
| IV_0   | 0x44     |
| IV_1   | 0x48     |
| IV_2   | 0x4c     |
| IV_3   | 0x50     |


### Fields

```wavejson
{"reg": [{"name": "iv", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description           |
|:------:|:------:|:-------:|:-------|:----------------------|
|  31:0  |   rw   |   0x0   | iv     | Initialization Vector |

## DATA_IN
Input Data Registers.

If MANUAL_OPERATION=0 (see Control Register), the AES unit automatically starts encryption/decryption after all Input Data registers have been written.
Each register has to be written at least once.
The order in which the registers are written does not matter.
Loaded into the internal State register upon starting encryption/decryption of the next block.
After that, the processor can update the Input Data registers (See INPUT_READY field of Status Register).
Upon reset, these registers are cleared with pseudo-random data.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name      | Offset   |
|:----------|:---------|
| DATA_IN_0 | 0x54     |
| DATA_IN_1 | 0x58     |
| DATA_IN_2 | 0x5c     |
| DATA_IN_3 | 0x60     |


### Fields

```wavejson
{"reg": [{"name": "data_in", "bits": 32, "attr": ["wo"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name    | Description   |
|:------:|:------:|:-------:|:--------|:--------------|
|  31:0  |   wo   |   0x0   | data_in | Input Data    |

## DATA_OUT
Output Data Register.

Holds the output data produced by the AES unit during the last encryption/decryption operation.
If MANUAL_OPERATION=0 (see Control Register), the AES unit is stalled when the previous output data has not yet been read and is about to be overwritten.
Each register has to be read at least once.
The order in which the registers are read does not matter.
Upon reset, these registers are cleared with pseudo-random data.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name       | Offset   |
|:-----------|:---------|
| DATA_OUT_0 | 0x64     |
| DATA_OUT_1 | 0x68     |
| DATA_OUT_2 | 0x6c     |
| DATA_OUT_3 | 0x70     |


### Fields

```wavejson
{"reg": [{"name": "data_out", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name     | Description   |
|:------:|:------:|:-------:|:---------|:--------------|
|  31:0  |   ro   |   0x0   | data_out | Output Data   |

## CTRL_SHADOWED
Control Register.

Can only be updated when the AES unit is idle.
If the AES unit is non-idle, writes to this register are ignored.
This register is shadowed, meaning two subsequent write operations are required to change its content.
If the two write operations try to set a different value, a recoverable alert is triggered (See Status Register).
A read operation clears the internal phase tracking: The next write operation is always considered a first write operation of an update sequence.
Any write operation to this register will clear the status tracking required for automatic mode (See MANUAL_OPERATION field).
A write to the Control Register is considered the start of a new message.
Hence, software needs to provide new key, IV and input data afterwards.
- Offset: `0x74`
- Reset default: `0x1181`
- Reset mask: `0xffff`

### Fields

```wavejson
{"reg": [{"name": "OPERATION", "bits": 2, "attr": ["rw"], "rotate": -90}, {"name": "MODE", "bits": 6, "attr": ["rw"], "rotate": 0}, {"name": "KEY_LEN", "bits": 3, "attr": ["rw"], "rotate": -90}, {"name": "SIDELOAD", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "PRNG_RESEED_RATE", "bits": 3, "attr": ["rw"], "rotate": -90}, {"name": "MANUAL_OPERATION", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 16}], "config": {"lanes": 1, "fontsize": 10, "vspace": 180}}
```

|  Bits  |  Type  |  Reset  | Name                                                 |
|:------:|:------:|:-------:|:-----------------------------------------------------|
| 31:16  |        |         | Reserved                                             |
|   15   |   rw   |   0x0   | [MANUAL_OPERATION](#ctrl_shadowed--manual_operation) |
| 14:12  |   rw   |   0x1   | [PRNG_RESEED_RATE](#ctrl_shadowed--prng_reseed_rate) |
|   11   |   rw   |   0x0   | [SIDELOAD](#ctrl_shadowed--sideload)                 |
|  10:8  |   rw   |   0x1   | [KEY_LEN](#ctrl_shadowed--key_len)                   |
|  7:2   |   rw   |  0x20   | [MODE](#ctrl_shadowed--mode)                         |
|  1:0   |   rw   |   0x1   | [OPERATION](#ctrl_shadowed--operation)               |

### CTRL_SHADOWED . MANUAL_OPERATION
Controls whether the AES unit is operated in normal/automatic mode (0) or fully manual mode (1).
In automatic mode (0), the AES unit automatically i) starts to encrypt/decrypt when it receives new input data, and ii) stalls during the last encryption/decryption cycle if the previous output data has not yet been read.
This is the most efficient mode to operate in.
Note that the corresponding status tracking is automatically cleared upon a write to the Control Register.
In manual mode (1), the AES unit i) only starts to encrypt/decrypt after receiving a start trigger (see Trigger Register), and ii) overwrites previous output data irrespective of whether it has been read out or not.
This mode is useful if software needs full control over the AES unit.

### CTRL_SHADOWED . PRNG_RESEED_RATE
3-bit one-hot field to control the reseeding rate of the internal pseudo-random number generator (PRNG) used for masking.
Invalid input values, i.e., values with multiple bits set and value 3'b000 are mapped to the highest reseeding rate PER_1 (3'b001).

| Value   | Name   | Description                                                                                                                                                                                                             |
|:--------|:-------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0x1     | PER_1  | 3'b001: Reseed the masking PRNG once per block. Invalid input values, i.e., values with multiple bits set and value 3'b000 are mapped to PER_1 (3'b001). This results in a max entropy consumption rate of ~343 Mbit/s. |
| 0x2     | PER_64 | 3'b010: Reseed the masking PRNG approximately once per every 64 blocks. This results in a max entropy consumption rate of ~5.4 Mbit/s.                                                                                  |
| 0x4     | PER_8K | 3'b100: Reseed the masking PRNG approximately once per every 8192 blocks. This results in a max entropy consumption rate of ~0.042 Mbit/s.                                                                              |

Other values are reserved.

### CTRL_SHADOWED . SIDELOAD
Controls whether the AES unit uses the key provided by the key manager via key sideload interface (1) or the key provided by software via Initial Key Registers KEY_SHARE1_0 - KEY_SHARE1_7 (0).

### CTRL_SHADOWED . KEY_LEN
3-bit one-hot field to select AES key length.
Invalid input values, i.e., values with multiple bits set, value 3'b000, and value 3'b010 in case 192-bit keys are not supported (because disabled at compile time) are mapped to AES_256 (3'b100).

| Value   | Name    | Description                                                                                                                                                                                                            |
|:--------|:--------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0x1     | AES_128 | 3'b001: 128-bit key length.                                                                                                                                                                                            |
| 0x2     | AES_192 | 3'b010: 192-bit key length. In case support for 192-bit keys has been disabled at compile time, setting this value results in configuring AES_256 (3'b100).                                                            |
| 0x4     | AES_256 | 3'b100: 256-bit key length. Invalid input values, i.e., values with multiple bits set, value 3'b000, and value 3'b010 in case 192-bit keys are not supported (because disabled at compile time) are mapped to AES_256. |

Other values are reserved.

### CTRL_SHADOWED . MODE
6-bit one-hot field to select AES block cipher mode.
Invalid input values, i.e., values with multiple bits set and value 6'b00_0000, are mapped to AES_NONE (6'b10_0000).

| Value   | Name     | Description                                                                                                        |
|:--------|:---------|:-------------------------------------------------------------------------------------------------------------------|
| 0x01    | AES_ECB  | 6'b00_0001: Electronic Codebook (ECB) mode.                                                                        |
| 0x02    | AES_CBC  | 6'b00_0010: Cipher Block Chaining (CBC) mode.                                                                      |
| 0x04    | AES_CFB  | 6'b00_0100: Cipher Feedback (CFB) mode.                                                                            |
| 0x08    | AES_OFB  | 6'b00_1000: Output Feedback (OFB) mode.                                                                            |
| 0x10    | AES_CTR  | 6'b01_0000: Counter (CTR) mode.                                                                                    |
| 0x20    | AES_NONE | 6'b10_0000: Invalid input values, i.e., value with multiple bits set and value 6'b00_0000, are mapped to AES_NONE. |

Other values are reserved.

### CTRL_SHADOWED . OPERATION
2-bit one-hot field to select the operation of AES unit.
Invalid input values, i.e., values with multiple bits set and value 2'b00, are mapped to AES_ENC (2'b01).

| Value   | Name    | Description                                                                            |
|:--------|:--------|:---------------------------------------------------------------------------------------|
| 0x1     | AES_ENC | 2'b01: Encryption. Invalid input values, i.e., 2'b00 and 2'b11, are mapped to AES_ENC. |
| 0x2     | AES_DEC | 2'b10: Decryption.                                                                     |

Other values are reserved.

## CTRL_AUX_SHADOWED
Auxiliary Control Register.

This register is shadowed, meaning two subsequent write operations are required to change its content.
If the two write operations try to set a different value, a recoverable alert is triggered (See Status Register).
A read operation clears the internal phase tracking: The next write operation is always considered a first write operation of an update sequence.
- Offset: `0x78`
- Reset default: `0x1`
- Reset mask: `0x3`
- Register enable: [`CTRL_AUX_REGWEN`](#ctrl_aux_regwen)

### Fields

```wavejson
{"reg": [{"name": "KEY_TOUCH_FORCES_RESEED", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "FORCE_MASKS", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 30}], "config": {"lanes": 1, "fontsize": 10, "vspace": 250}}
```

|  Bits  |  Type  |  Reset  | Name                                                                   |
|:------:|:------:|:-------:|:-----------------------------------------------------------------------|
|  31:2  |        |         | Reserved                                                               |
|   1    |   rw   |   0x0   | [FORCE_MASKS](#ctrl_aux_shadowed--force_masks)                         |
|   0    |   rw   |   0x1   | [KEY_TOUCH_FORCES_RESEED](#ctrl_aux_shadowed--key_touch_forces_reseed) |

### CTRL_AUX_SHADOWED . FORCE_MASKS
Allow the internal masking PRNG to advance (0) or force its internal state (1) leading to constant masks.
Setting all masks to constant value can be useful when performing SCA.
To completely disable the masking, the second key share (KEY_SHARE1_0 - KEY_SHARE1_7) must be zero as well.
In addition, a special seed needs to be loaded into the masking PRNG using the EDN interface.
Only applicable if both the Masking parameter and the SecAllowForcingMasks parameter are set to one.

### CTRL_AUX_SHADOWED . KEY_TOUCH_FORCES_RESEED
Controls whether providing a new key triggers the reseeding of internal pseudo-random number generators used for clearing and masking (1) or not (0).

## CTRL_AUX_REGWEN
Lock bit for Auxiliary Control Register.
- Offset: `0x7c`
- Reset default: `0x1`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "CTRL_AUX_REGWEN", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 170}}
```

|  Bits  |  Type  |  Reset  | Name            | Description                                                                                                                             |
|:------:|:------:|:-------:|:----------------|:----------------------------------------------------------------------------------------------------------------------------------------|
|  31:1  |        |         |                 | Reserved                                                                                                                                |
|   0    |  rw0c  |   0x1   | CTRL_AUX_REGWEN | Auxiliary Control Register configuration enable bit. If this is cleared to 0, the Auxiliary Control Register cannot be written anymore. |

## TRIGGER
Trigger Register.

Each bit is individually cleared to zero when executing the corresponding trigger.
While executing any of the triggered operations, the AES unit will set the IDLE bit in the Status Register to zero.
The processor must check the Status Register before triggering further actions.
For example, writes to Initial Key and IV Registers are ignored while the AES unit is busy.
Writes to the Input Data Registers are not ignored but the data will be cleared if a KEY_IV_DATA_IN_CLEAR operation is pending.
- Offset: `0x80`
- Reset default: `0xe`
- Reset mask: `0xf`

### Fields

```wavejson
{"reg": [{"name": "START", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "KEY_IV_DATA_IN_CLEAR", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "DATA_OUT_CLEAR", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "PRNG_RESEED", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 28}], "config": {"lanes": 1, "fontsize": 10, "vspace": 220}}
```

|  Bits  |  Type  |  Reset  | Name                                                   |
|:------:|:------:|:-------:|:-------------------------------------------------------|
|  31:4  |        |         | Reserved                                               |
|   3    |   wo   |   0x1   | [PRNG_RESEED](#trigger--prng_reseed)                   |
|   2    |   wo   |   0x1   | [DATA_OUT_CLEAR](#trigger--data_out_clear)             |
|   1    |   wo   |   0x1   | [KEY_IV_DATA_IN_CLEAR](#trigger--key_iv_data_in_clear) |
|   0    |   wo   |   0x0   | [START](#trigger--start)                               |

### TRIGGER . PRNG_RESEED
Keep continuing with the current states of the internal pseudo-random number generators used for register clearing and masking (0) or perform a reseed of the internal states from the connected entropy source (1).
If the KEY_TOUCH_FORCES_RESEED bit in the Auxiliary Control Register is set to one, this trigger will automatically get set after providing a new initial key.

### TRIGGER . DATA_OUT_CLEAR
Keep current values in Output Data registers (0) or clear those registers with pseudo-random data (1).

### TRIGGER . KEY_IV_DATA_IN_CLEAR
Keep current values in Initial Key, internal Full Key and Decryption Key registers, IV registers and Input Data registers (0) or clear all those registers with pseudo-random data (1).

### TRIGGER . START
Keep AES unit paused (0) or trigger the encryption/decryption of one data block (1).
This trigger is cleared to `0` if MANUAL_OPERATION=0 or if MODE=AES_NONE (see Control Register).

## STATUS
Status Register
- Offset: `0x84`
- Reset default: `0x0`
- Reset mask: `0x7f`

### Fields

```wavejson
{"reg": [{"name": "IDLE", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "STALL", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "OUTPUT_LOST", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "OUTPUT_VALID", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "INPUT_READY", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "ALERT_RECOV_CTRL_UPDATE_ERR", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "ALERT_FATAL_FAULT", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 25}], "config": {"lanes": 1, "fontsize": 10, "vspace": 290}}
```

|  Bits  |  Type  |  Reset  | Name                                                                |
|:------:|:------:|:-------:|:--------------------------------------------------------------------|
|  31:7  |        |         | Reserved                                                            |
|   6    |   ro   |   0x0   | [ALERT_FATAL_FAULT](#status--alert_fatal_fault)                     |
|   5    |   ro   |   0x0   | [ALERT_RECOV_CTRL_UPDATE_ERR](#status--alert_recov_ctrl_update_err) |
|   4    |   ro   |   0x0   | [INPUT_READY](#status--input_ready)                                 |
|   3    |   ro   |   0x0   | [OUTPUT_VALID](#status--output_valid)                               |
|   2    |   ro   |   0x0   | [OUTPUT_LOST](#status--output_lost)                                 |
|   1    |   ro   |   0x0   | [STALL](#status--stall)                                             |
|   0    |   ro   |   0x0   | [IDLE](#status--idle)                                               |

### STATUS . ALERT_FATAL_FAULT
No fatal fault has occurred inside the AES unit (0).
A fatal fault has occurred and the AES unit needs to be reset (1).
Examples for fatal faults include
i) storage errors in the Control Register,
ii) if any internal FSM enters an invalid state,
iii) if any sparsely encoded signal takes on an invalid value,
iv) errors in the internal round counter,
v) escalations triggered by the life cycle controller, and
vi) fatal integrity failures on the TL-UL bus.

### STATUS . ALERT_RECOV_CTRL_UPDATE_ERR
An update error has not occurred (0) or has occurred (1) in the shadowed Control Register.
AES operation needs to be restarted by re-writing the Control Register.

### STATUS . INPUT_READY
The AES unit is ready (1) or not ready (0) to receive new data input via the DATA_IN registers.
If the present values in the DATA_IN registers have not yet been loaded into the
module this flag is `0` (not ready).

### STATUS . OUTPUT_VALID
The AES unit has no valid output (0) or has valid output data (1).

### STATUS . OUTPUT_LOST
All previous output data has been fully read by the processor (0) or at least one previous output data block has been lost (1).
It has been overwritten by the AES unit before the processor could fully read it.
Once set to `1`, this flag remains set until AES operation is restarted by re-writing the Control Register.
The primary use of this flag is for design verification.
This flag is not meaningful if MANUAL_OPERATION=0 (see Control Register).

### STATUS . STALL
The AES unit is not stalled (0) or stalled (1) because there is previous
output data that must be read by the processor before the AES unit can
overwrite this data.
This flag is not meaningful if MANUAL_OPERATION=1 (see Control Register).

### STATUS . IDLE
The AES unit is idle (1) or busy (0).
This flag is `0` if one of the following operations is currently running: i) encryption/decryption, ii) register clearing or iii) PRNG reseeding.
This flag is also `0` if an encryption/decryption is running but the AES unit is stalled.


<!-- END CMDGEN -->

================================== Ai Message ==================================
Tool Calls:
  list_dir (call_7I3PaVb2TMbBKf5NNEIXXtIe)
 Call ID: call_7I3PaVb2TMbBKf5NNEIXXtIe
  Args:
    dir_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes/rtl
================================= Tool Message =================================
Name: list_dir

Files in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes/rtl:
aes_sbox_canright_pkg.sv aes_sbox.sv aes_prng_masking.sv aes_cipher_control_fsm_p.sv aes_ctr_fsm.sv aes_cipher_control.sv aes_sbox_dom.sv aes_sel_buf_chk.sv aes_control_fsm_p.sv aes_prng_clearing.sv aes_control.sv aes_ctr_fsm_p.sv aes_control_fsm_n.sv aes_ctr.sv aes_sbox_canright_masked.sv aes_reduced_round.sv aes_shift_rows.sv aes_reg_status.sv aes_reg_pkg.sv aes_sbox_canright_masked_noreuse.sv aes_control_fsm.sv aes_mix_columns.sv aes_sub_bytes.sv aes_ctr_fsm_n.sv aes_sbox_canright.sv aes_cipher_control_fsm_n.sv aes_pkg.sv aes.sv aes_cipher_core.sv aes_cipher_control_fsm.sv aes_ctrl_reg_shadowed.sv aes_sbox_lut.sv aes_mix_single_column.sv aes_key_expand.sv aes_core.sv aes_reg_top.sv aes_wrap.sv

Directories in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes/rtl:

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_zGLQMl2M1Hkz2MyiALqMU6T5)
 Call ID: call_zGLQMl2M1Hkz2MyiALqMU6T5
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes/rtl/aes_reg_top.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Register Top module auto-generated by `reggen`
6: 
7: `include "prim_assert.sv"
8: 
9: module aes_reg_top (
10:   input clk_i,
11:   input rst_ni,
12:   input rst_shadowed_ni,
13:   input  tlul_pkg::tl_h2d_t tl_i,
14:   output tlul_pkg::tl_d2h_t tl_o,
15:   // To HW
16:   output aes_reg_pkg::aes_reg2hw_t reg2hw, // Write
17:   input  aes_reg_pkg::aes_hw2reg_t hw2reg, // Read
18: 
19:   output logic shadowed_storage_err_o,
20:   output logic shadowed_update_err_o,
21: 
22:   // Integrity check errors
23:   output logic intg_err_o
24: );
25: 
26:   import aes_reg_pkg::* ;
27: 
28:   localparam int AW = 8;
29:   localparam int DW = 32;
30:   localparam int DBW = DW/8;                    // Byte Width
31: 
32:   // register signals
33:   logic           reg_we;
34:   logic           reg_re;
35:   logic [AW-1:0]  reg_addr;
36:   logic [DW-1:0]  reg_wdata;
37:   logic [DBW-1:0] reg_be;
38:   logic [DW-1:0]  reg_rdata;
39:   logic           reg_error;
40: 
41:   logic          addrmiss, wr_err;
42: 
43:   logic [DW-1:0] reg_rdata_next;
44:   logic reg_busy;
45: 
46:   tlul_pkg::tl_h2d_t tl_reg_h2d;
47:   tlul_pkg::tl_d2h_t tl_reg_d2h;
48: 
49: 
50:   // incoming payload check
51:   logic intg_err;
52:   tlul_cmd_intg_chk u_chk (
53:     .tl_i(tl_i),
54:     .err_o(intg_err)
55:   );
56: 
57:   // also check for spurious write enables
58:   logic reg_we_err;
59:   logic [33:0] reg_we_check;
60:   prim_reg_we_check #(
61:     .OneHotWidth(34)
62:   ) u_prim_reg_we_check (
63:     .clk_i(clk_i),
64:     .rst_ni(rst_ni),
65:     .oh_i  (reg_we_check),
66:     .en_i  (reg_we && !addrmiss),
67:     .err_o (reg_we_err)
68:   );
69: 
70:   logic err_q;
71:   always_ff @(posedge clk_i or negedge rst_ni) begin
72:     if (!rst_ni) begin
73:       err_q <= '0;
74:     end else if (intg_err || reg_we_err) begin
75:       err_q <= 1'b1;
76:     end
77:   end
78: 
79:   // integrity error output is permanent and should be used for alert generation
80:   // register errors are transactional
81:   assign intg_err_o = err_q | intg_err | reg_we_err;
82: 
83:   // outgoing integrity generation
84:   tlul_pkg::tl_d2h_t tl_o_pre;
85:   tlul_rsp_intg_gen #(
86:     .EnableRspIntgGen(1),
87:     .EnableDataIntgGen(1)
88:   ) u_rsp_intg_gen (
89:     .tl_i(tl_o_pre),
90:     .tl_o(tl_o)
91:   );
92: 
93:   assign tl_reg_h2d = tl_i;
94:   assign tl_o_pre   = tl_reg_d2h;
95: 
96:   tlul_adapter_reg #(
97:     .RegAw(AW),
98:     .RegDw(DW),
99:     .EnableDataIntgGen(0)
100:   ) u_reg_if (
101:     .clk_i  (clk_i),
102:     .rst_ni (rst_ni),
103: 
104:     .tl_i (tl_reg_h2d),
105:     .tl_o (tl_reg_d2h),
106: 
107:     .en_ifetch_i(prim_mubi_pkg::MuBi4False),
108:     .intg_error_o(),
109: 
110:     .we_o    (reg_we),
111:     .re_o    (reg_re),
112:     .addr_o  (reg_addr),
113:     .wdata_o (reg_wdata),
114:     .be_o    (reg_be),
115:     .busy_i  (reg_busy),
116:     .rdata_i (reg_rdata),
117:     .error_i (reg_error)
118:   );
119: 
120:   // cdc oversampling signals
121: 
122:   assign reg_rdata = reg_rdata_next ;
123:   assign reg_error = addrmiss | wr_err | intg_err;
124: 
125:   // Define SW related signals
126:   // Format: <reg>_<field>_{wd|we|qs}
127:   //        or <reg>_{wd|we|qs} if field == 1 or 0
128:   logic alert_test_we;
129:   logic alert_test_recov_ctrl_update_err_wd;
130:   logic alert_test_fatal_fault_wd;
131:   logic key_share0_0_we;
132:   logic [31:0] key_share0_0_wd;
133:   logic key_share0_1_we;
134:   logic [31:0] key_share0_1_wd;
135:   logic key_share0_2_we;
136:   logic [31:0] key_share0_2_wd;
137:   logic key_share0_3_we;
138:   logic [31:0] key_share0_3_wd;
139:   logic key_share0_4_we;
140:   logic [31:0] key_share0_4_wd;
141:   logic key_share0_5_we;
142:   logic [31:0] key_share0_5_wd;
143:   logic key_share0_6_we;
144:   logic [31:0] key_share0_6_wd;
145:   logic key_share0_7_we;
146:   logic [31:0] key_share0_7_wd;
147:   logic key_share1_0_we;
148:   logic [31:0] key_share1_0_wd;
149:   logic key_share1_1_we;
150:   logic [31:0] key_share1_1_wd;
151:   logic key_share1_2_we;
152:   logic [31:0] key_share1_2_wd;
153:   logic key_share1_3_we;
154:   logic [31:0] key_share1_3_wd;
155:   logic key_share1_4_we;
156:   logic [31:0] key_share1_4_wd;
157:   logic key_share1_5_we;
158:   logic [31:0] key_share1_5_wd;
159:   logic key_share1_6_we;
160:   logic [31:0] key_share1_6_wd;
161:   logic key_share1_7_we;
162:   logic [31:0] key_share1_7_wd;
163:   logic iv_0_re;
164:   logic iv_0_we;
165:   logic [31:0] iv_0_qs;
166:   logic [31:0] iv_0_wd;
167:   logic iv_1_re;
168:   logic iv_1_we;
169:   logic [31:0] iv_1_qs;
170:   logic [31:0] iv_1_wd;
171:   logic iv_2_re;
172:   logic iv_2_we;
173:   logic [31:0] iv_2_qs;
174:   logic [31:0] iv_2_wd;
175:   logic iv_3_re;
176:   logic iv_3_we;
177:   logic [31:0] iv_3_qs;
178:   logic [31:0] iv_3_wd;
179:   logic data_in_0_we;
180:   logic [31:0] data_in_0_wd;
181:   logic data_in_1_we;
182:   logic [31:0] data_in_1_wd;
183:   logic data_in_2_we;
184:   logic [31:0] data_in_2_wd;
185:   logic data_in_3_we;
186:   logic [31:0] data_in_3_wd;
187:   logic data_out_0_re;
188:   logic [31:0] data_out_0_qs;
189:   logic data_out_1_re;
190:   logic [31:0] data_out_1_qs;
191:   logic data_out_2_re;
192:   logic [31:0] data_out_2_qs;
193:   logic data_out_3_re;
194:   logic [31:0] data_out_3_qs;
195:   logic ctrl_shadowed_re;
196:   logic ctrl_shadowed_we;
197:   logic [1:0] ctrl_shadowed_operation_qs;
198:   logic [1:0] ctrl_shadowed_operation_wd;
199:   logic [5:0] ctrl_shadowed_mode_qs;
200:   logic [5:0] ctrl_shadowed_mode_wd;
201:   logic [2:0] ctrl_shadowed_key_len_qs;
202:   logic [2:0] ctrl_shadowed_key_len_wd;
203:   logic ctrl_shadowed_sideload_qs;
204:   logic ctrl_shadowed_sideload_wd;
205:   logic [2:0] ctrl_shadowed_prng_reseed_rate_qs;
206:   logic [2:0] ctrl_shadowed_prng_reseed_rate_wd;
207:   logic ctrl_shadowed_manual_operation_qs;
208:   logic ctrl_shadowed_manual_operation_wd;
209:   logic ctrl_aux_shadowed_re;
210:   logic ctrl_aux_shadowed_we;
211:   logic ctrl_aux_shadowed_key_touch_forces_reseed_qs;
212:   logic ctrl_aux_shadowed_key_touch_forces_reseed_wd;
213:   logic ctrl_aux_shadowed_key_touch_forces_reseed_storage_err;
214:   logic ctrl_aux_shadowed_key_touch_forces_reseed_update_err;
215:   logic ctrl_aux_shadowed_force_masks_qs;
216:   logic ctrl_aux_shadowed_force_masks_wd;
217:   logic ctrl_aux_shadowed_force_masks_storage_err;
218:   logic ctrl_aux_shadowed_force_masks_update_err;
219:   logic ctrl_aux_regwen_we;
220:   logic ctrl_aux_regwen_qs;
221:   logic ctrl_aux_regwen_wd;
222:   logic trigger_we;
223:   logic trigger_start_wd;
224:   logic trigger_key_iv_data_in_clear_wd;
225:   logic trigger_data_out_clear_wd;
226:   logic trigger_prng_reseed_wd;
227:   logic status_idle_qs;
228:   logic status_stall_qs;
229:   logic status_output_lost_qs;
230:   logic status_output_valid_qs;
231:   logic status_input_ready_qs;
232:   logic status_alert_recov_ctrl_update_err_qs;
233:   logic status_alert_fatal_fault_qs;
234: 
235:   // Register instances
236:   // R[alert_test]: V(True)
237:   logic alert_test_qe;
238:   logic [1:0] alert_test_flds_we;
239:   assign alert_test_qe = &alert_test_flds_we;
240:   //   F[recov_ctrl_update_err]: 0:0
241:   prim_subreg_ext #(
242:     .DW    (1)
243:   ) u_alert_test_recov_ctrl_update_err (
244:     .re     (1'b0),
245:     .we     (alert_test_we),
246:     .wd     (alert_test_recov_ctrl_update_err_wd),
247:     .d      ('0),
248:     .qre    (),
249:     .qe     (alert_test_flds_we[0]),
250:     .q      (reg2hw.alert_test.recov_ctrl_update_err.q),
251:     .ds     (),
252:     .qs     ()
253:   );
254:   assign reg2hw.alert_test.recov_ctrl_update_err.qe = alert_test_qe;
255: 
256:   //   F[fatal_fault]: 1:1
257:   prim_subreg_ext #(
258:     .DW    (1)
259:   ) u_alert_test_fatal_fault (
260:     .re     (1'b0),
261:     .we     (alert_test_we),
262:     .wd     (alert_test_fatal_fault_wd),
263:     .d      ('0),
264:     .qre    (),
265:     .qe     (alert_test_flds_we[1]),
266:     .q      (reg2hw.alert_test.fatal_fault.q),
267:     .ds     (),
268:     .qs     ()
269:   );
270:   assign reg2hw.alert_test.fatal_fault.qe = alert_test_qe;
271: 
272: 
273:   // Subregister 0 of Multireg key_share0
274:   // R[key_share0_0]: V(True)
275:   logic key_share0_0_qe;
276:   logic [0:0] key_share0_0_flds_we;
277:   assign key_share0_0_qe = &key_share0_0_flds_we;
278:   prim_subreg_ext #(
279:     .DW    (32)
280:   ) u_key_share0_0 (
281:     .re     (1'b0),
282:     .we     (key_share0_0_we),
283:     .wd     (key_share0_0_wd),
284:     .d      (hw2reg.key_share0[0].d),
285:     .qre    (),
286:     .qe     (key_share0_0_flds_we[0]),
287:     .q      (reg2hw.key_share0[0].q),
288:     .ds     (),
289:     .qs     ()
290:   );
291:   assign reg2hw.key_share0[0].qe = key_share0_0_qe;
292: 
293: 
294:   // Subregister 1 of Multireg key_share0
295:   // R[key_share0_1]: V(True)
296:   logic key_share0_1_qe;
297:   logic [0:0] key_share0_1_flds_we;
298:   assign key_share0_1_qe = &key_share0_1_flds_we;
299:   prim_subreg_ext #(
300:     .DW    (32)
301:   ) u_key_share0_1 (
302:     .re     (1'b0),
303:     .we     (key_share0_1_we),
304:     .wd     (key_share0_1_wd),
305:     .d      (hw2reg.key_share0[1].d),
306:     .qre    (),
307:     .qe     (key_share0_1_flds_we[0]),
308:     .q      (reg2hw.key_share0[1].q),
309:     .ds     (),
310:     .qs     ()
311:   );
312:   assign reg2hw.key_share0[1].qe = key_share0_1_qe;
313: 
314: 
315:   // Subregister 2 of Multireg key_share0
316:   // R[key_share0_2]: V(True)
317:   logic key_share0_2_qe;
318:   logic [0:0] key_share0_2_flds_we;
319:   assign key_share0_2_qe = &key_share0_2_flds_we;
320:   prim_subreg_ext #(
321:     .DW    (32)
322:   ) u_key_share0_2 (
323:     .re     (1'b0),
324:     .we     (key_share0_2_we),
325:     .wd     (key_share0_2_wd),
326:     .d      (hw2reg.key_share0[2].d),
327:     .qre    (),
328:     .qe     (key_share0_2_flds_we[0]),
329:     .q      (reg2hw.key_share0[2].q),
330:     .ds     (),
331:     .qs     ()
332:   );
333:   assign reg2hw.key_share0[2].qe = key_share0_2_qe;
334: 
335: 
336:   // Subregister 3 of Multireg key_share0
337:   // R[key_share0_3]: V(True)
338:   logic key_share0_3_qe;
339:   logic [0:0] key_share0_3_flds_we;
340:   assign key_share0_3_qe = &key_share0_3_flds_we;
341:   prim_subreg_ext #(
342:     .DW    (32)
343:   ) u_key_share0_3 (
344:     .re     (1'b0),
345:     .we     (key_share0_3_we),
346:     .wd     (key_share0_3_wd),
347:     .d      (hw2reg.key_share0[3].d),
348:     .qre    (),
349:     .qe     (key_share0_3_flds_we[0]),
350:     .q      (reg2hw.key_share0[3].q),
351:     .ds     (),
352:     .qs     ()
353:   );
354:   assign reg2hw.key_share0[3].qe = key_share0_3_qe;
355: 
356: 
357:   // Subregister 4 of Multireg key_share0
358:   // R[key_share0_4]: V(True)
359:   logic key_share0_4_qe;
360:   logic [0:0] key_share0_4_flds_we;
361:   assign key_share0_4_qe = &key_share0_4_flds_we;
362:   prim_subreg_ext #(
363:     .DW    (32)
364:   ) u_key_share0_4 (
365:     .re     (1'b0),
366:     .we     (key_share0_4_we),
367:     .wd     (key_share0_4_wd),
368:     .d      (hw2reg.key_share0[4].d),
369:     .qre    (),
370:     .qe     (key_share0_4_flds_we[0]),
371:     .q      (reg2hw.key_share0[4].q),
372:     .ds     (),
373:     .qs     ()
374:   );
375:   assign reg2hw.key_share0[4].qe = key_share0_4_qe;
376: 
377: 
378:   // Subregister 5 of Multireg key_share0
379:   // R[key_share0_5]: V(True)
380:   logic key_share0_5_qe;
381:   logic [0:0] key_share0_5_flds_we;
382:   assign key_share0_5_qe = &key_share0_5_flds_we;
383:   prim_subreg_ext #(
384:     .DW    (32)
385:   ) u_key_share0_5 (
386:     .re     (1'b0),
387:     .we     (key_share0_5_we),
388:     .wd     (key_share0_5_wd),
389:     .d      (hw2reg.key_share0[5].d),
390:     .qre    (),
391:     .qe     (key_share0_5_flds_we[0]),
392:     .q      (reg2hw.key_share0[5].q),
393:     .ds     (),
394:     .qs     ()
395:   );
396:   assign reg2hw.key_share0[5].qe = key_share0_5_qe;
397: 
398: 
399:   // Subregister 6 of Multireg key_share0
400:   // R[key_share0_6]: V(True)
401:   logic key_share0_6_qe;
402:   logic [0:0] key_share0_6_flds_we;
403:   assign key_share0_6_qe = &key_share0_6_flds_we;
404:   prim_subreg_ext #(
405:     .DW    (32)
406:   ) u_key_share0_6 (
407:     .re     (1'b0),
408:     .we     (key_share0_6_we),
409:     .wd     (key_share0_6_wd),
410:     .d      (hw2reg.key_share0[6].d),
411:     .qre    (),
412:     .qe     (key_share0_6_flds_we[0]),
413:     .q      (reg2hw.key_share0[6].q),
414:     .ds     (),
415:     .qs     ()
416:   );
417:   assign reg2hw.key_share0[6].qe = key_share0_6_qe;
418: 
419: 
420:   // Subregister 7 of Multireg key_share0
421:   // R[key_share0_7]: V(True)
422:   logic key_share0_7_qe;
423:   logic [0:0] key_share0_7_flds_we;
424:   assign key_share0_7_qe = &key_share0_7_flds_we;
425:   prim_subreg_ext #(
426:     .DW    (32)
427:   ) u_key_share0_7 (
428:     .re     (1'b0),
429:     .we     (key_share0_7_we),
430:     .wd     (key_share0_7_wd),
431:     .d      (hw2reg.key_share0[7].d),
432:     .qre    (),
433:     .qe     (key_share0_7_flds_we[0]),
434:     .q      (reg2hw.key_share0[7].q),
435:     .ds     (),
436:     .qs     ()
437:   );
438:   assign reg2hw.key_share0[7].qe = key_share0_7_qe;
439: 
440: 
441:   // Subregister 0 of Multireg key_share1
442:   // R[key_share1_0]: V(True)
443:   logic key_share1_0_qe;
444:   logic [0:0] key_share1_0_flds_we;
445:   assign key_share1_0_qe = &key_share1_0_flds_we;
446:   prim_subreg_ext #(
447:     .DW    (32)
448:   ) u_key_share1_0 (
449:     .re     (1'b0),
450:     .we     (key_share1_0_we),
451:     .wd     (key_share1_0_wd),
452:     .d      (hw2reg.key_share1[0].d),
453:     .qre    (),
454:     .qe     (key_share1_0_flds_we[0]),
455:     .q      (reg2hw.key_share1[0].q),
456:     .ds     (),
457:     .qs     ()
458:   );
459:   assign reg2hw.key_share1[0].qe = key_share1_0_qe;
460: 
461: 
462:   // Subregister 1 of Multireg key_share1
463:   // R[key_share1_1]: V(True)
464:   logic key_share1_1_qe;
465:   logic [0:0] key_share1_1_flds_we;
466:   assign key_share1_1_qe = &key_share1_1_flds_we;
467:   prim_subreg_ext #(
468:     .DW    (32)
469:   ) u_key_share1_1 (
470:     .re     (1'b0),
471:     .we     (key_share1_1_we),
472:     .wd     (key_share1_1_wd),
473:     .d      (hw2reg.key_share1[1].d),
474:     .qre    (),
475:     .qe     (key_share1_1_flds_we[0]),
476:     .q      (reg2hw.key_share1[1].q),
477:     .ds     (),
478:     .qs     ()
479:   );
480:   assign reg2hw.key_share1[1].qe = key_share1_1_qe;
481: 
482: 
483:   // Subregister 2 of Multireg key_share1
484:   // R[key_share1_2]: V(True)
485:   logic key_share1_2_qe;
486:   logic [0:0] key_share1_2_flds_we;
487:   assign key_share1_2_qe = &key_share1_2_flds_we;
488:   prim_subreg_ext #(
489:     .DW    (32)
490:   ) u_key_share1_2 (
491:     .re     (1'b0),
492:     .we     (key_share1_2_we),
493:     .wd     (key_share1_2_wd),
494:     .d      (hw2reg.key_share1[2].d),
495:     .qre    (),
496:     .qe     (key_share1_2_flds_we[0]),
497:     .q      (reg2hw.key_share1[2].q),
498:     .ds     (),
499:     .qs     ()
500:   );
501:   assign reg2hw.key_share1[2].qe = key_share1_2_qe;
502: 
503: 
504:   // Subregister 3 of Multireg key_share1
505:   // R[key_share1_3]: V(True)
506:   logic key_share1_3_qe;
507:   logic [0:0] key_share1_3_flds_we;
508:   assign key_share1_3_qe = &key_share1_3_flds_we;
509:   prim_subreg_ext #(
510:     .DW    (32)
511:   ) u_key_share1_3 (
512:     .re     (1'b0),
513:     .we     (key_share1_3_we),
514:     .wd     (key_share1_3_wd),
515:     .d      (hw2reg.key_share1[3].d),
516:     .qre    (),
517:     .qe     (key_share1_3_flds_we[0]),
518:     .q      (reg2hw.key_share1[3].q),
519:     .ds     (),
520:     .qs     ()
521:   );
522:   assign reg2hw.key_share1[3].qe = key_share1_3_qe;
523: 
524: 
525:   // Subregister 4 of Multireg key_share1
526:   // R[key_share1_4]: V(True)
527:   logic key_share1_4_qe;
528:   logic [0:0] key_share1_4_flds_we;
529:   assign key_share1_4_qe = &key_share1_4_flds_we;
530:   prim_subreg_ext #(
531:     .DW    (32)
532:   ) u_key_share1_4 (
533:     .re     (1'b0),
534:     .we     (key_share1_4_we),
535:     .wd     (key_share1_4_wd),
536:     .d      (hw2reg.key_share1[4].d),
537:     .qre    (),
538:     .qe     (key_share1_4_flds_we[0]),
539:     .q      (reg2hw.key_share1[4].q),
540:     .ds     (),
541:     .qs     ()
542:   );
543:   assign reg2hw.key_share1[4].qe = key_share1_4_qe;
544: 
545: 
546:   // Subregister 5 of Multireg key_share1
547:   // R[key_share1_5]: V(True)
548:   logic key_share1_5_qe;
549:   logic [0:0] key_share1_5_flds_we;
550:   assign key_share1_5_qe = &key_share1_5_flds_we;
551:   prim_subreg_ext #(
552:     .DW    (32)
553:   ) u_key_share1_5 (
554:     .re     (1'b0),
555:     .we     (key_share1_5_we),
556:     .wd     (key_share1_5_wd),
557:     .d      (hw2reg.key_share1[5].d),
558:     .qre    (),
559:     .qe     (key_share1_5_flds_we[0]),
560:     .q      (reg2hw.key_share1[5].q),
561:     .ds     (),
562:     .qs     ()
563:   );
564:   assign reg2hw.key_share1[5].qe = key_share1_5_qe;
565: 
566: 
567:   // Subregister 6 of Multireg key_share1
568:   // R[key_share1_6]: V(True)
569:   logic key_share1_6_qe;
570:   logic [0:0] key_share1_6_flds_we;
571:   assign key_share1_6_qe = &key_share1_6_flds_we;
572:   prim_subreg_ext #(
573:     .DW    (32)
574:   ) u_key_share1_6 (
575:     .re     (1'b0),
576:     .we     (key_share1_6_we),
577:     .wd     (key_share1_6_wd),
578:     .d      (hw2reg.key_share1[6].d),
579:     .qre    (),
580:     .qe     (key_share1_6_flds_we[0]),
581:     .q      (reg2hw.key_share1[6].q),
582:     .ds     (),
583:     .qs     ()
584:   );
585:   assign reg2hw.key_share1[6].qe = key_share1_6_qe;
586: 
587: 
588:   // Subregister 7 of Multireg key_share1
589:   // R[key_share1_7]: V(True)
590:   logic key_share1_7_qe;
591:   logic [0:0] key_share1_7_flds_we;
592:   assign key_share1_7_qe = &key_share1_7_flds_we;
593:   prim_subreg_ext #(
594:     .DW    (32)
595:   ) u_key_share1_7 (
596:     .re     (1'b0),
597:     .we     (key_share1_7_we),
598:     .wd     (key_share1_7_wd),
599:     .d      (hw2reg.key_share1[7].d),
600:     .qre    (),
601:     .qe     (key_share1_7_flds_we[0]),
602:     .q      (reg2hw.key_share1[7].q),
603:     .ds     (),
604:     .qs     ()
605:   );
606:   assign reg2hw.key_share1[7].qe = key_share1_7_qe;
607: 
608: 
609:   // Subregister 0 of Multireg iv
610:   // R[iv_0]: V(True)
611:   logic iv_0_qe;
612:   logic [0:0] iv_0_flds_we;
613:   assign iv_0_qe = &iv_0_flds_we;
614:   prim_subreg_ext #(
615:     .DW    (32)
616:   ) u_iv_0 (
617:     .re     (iv_0_re),
618:     .we     (iv_0_we),
619:     .wd     (iv_0_wd),
620:     .d      (hw2reg.iv[0].d),
621:     .qre    (),
622:     .qe     (iv_0_flds_we[0]),
623:     .q      (reg2hw.iv[0].q),
624:     .ds     (),
625:     .qs     (iv_0_qs)
626:   );
627:   assign reg2hw.iv[0].qe = iv_0_qe;
628: 
629: 
630:   // Subregister 1 of Multireg iv
631:   // R[iv_1]: V(True)
632:   logic iv_1_qe;
633:   logic [0:0] iv_1_flds_we;
634:   assign iv_1_qe = &iv_1_flds_we;
635:   prim_subreg_ext #(
636:     .DW    (32)
637:   ) u_iv_1 (
638:     .re     (iv_1_re),
639:     .we     (iv_1_we),
640:     .wd     (iv_1_wd),
641:     .d      (hw2reg.iv[1].d),
642:     .qre    (),
643:     .qe     (iv_1_flds_we[0]),
644:     .q      (reg2hw.iv[1].q),
645:     .ds     (),
646:     .qs     (iv_1_qs)
647:   );
648:   assign reg2hw.iv[1].qe = iv_1_qe;
649: 
650: 
651:   // Subregister 2 of Multireg iv
652:   // R[iv_2]: V(True)
653:   logic iv_2_qe;
654:   logic [0:0] iv_2_flds_we;
655:   assign iv_2_qe = &iv_2_flds_we;
656:   prim_subreg_ext #(
657:     .DW    (32)
658:   ) u_iv_2 (
659:     .re     (iv_2_re),
660:     .we     (iv_2_we),
661:     .wd     (iv_2_wd),
662:     .d      (hw2reg.iv[2].d),
663:     .qre    (),
664:     .qe     (iv_2_flds_we[0]),
665:     .q      (reg2hw.iv[2].q),
666:     .ds     (),
667:     .qs     (iv_2_qs)
668:   );
669:   assign reg2hw.iv[2].qe = iv_2_qe;
670: 
671: 
672:   // Subregister 3 of Multireg iv
673:   // R[iv_3]: V(True)
674:   logic iv_3_qe;
675:   logic [0:0] iv_3_flds_we;
676:   assign iv_3_qe = &iv_3_flds_we;
677:   prim_subreg_ext #(
678:     .DW    (32)
679:   ) u_iv_3 (
680:     .re     (iv_3_re),
681:     .we     (iv_3_we),
682:     .wd     (iv_3_wd),
683:     .d      (hw2reg.iv[3].d),
684:     .qre    (),
685:     .qe     (iv_3_flds_we[0]),
686:     .q      (reg2hw.iv[3].q),
687:     .ds     (),
688:     .qs     (iv_3_qs)
689:   );
690:   assign reg2hw.iv[3].qe = iv_3_qe;
691: 
692: 
693:   // Subregister 0 of Multireg data_in
694:   // R[data_in_0]: V(False)
695:   logic data_in_0_qe;
696:   logic [0:0] data_in_0_flds_we;
697:   prim_flop #(
698:     .Width(1),
699:     .ResetValue(0)
700:   ) u_data_in0_qe (
701:     .clk_i(clk_i),
702:     .rst_ni(rst_ni),
703:     .d_i(&data_in_0_flds_we),
704:     .q_o(data_in_0_qe)
705:   );
706:   prim_subreg #(
707:     .DW      (32),
708:     .SwAccess(prim_subreg_pkg::SwAccessRW),
709:     .RESVAL  (32'h0),
710:     .Mubi    (1'b0)
711:   ) u_data_in_0 (
712:     .clk_i   (clk_i),
713:     .rst_ni  (rst_ni),
714: 
715:     // from register interface
716:     .we     (data_in_0_we),
717:     .wd     (data_in_0_wd),
718: 
719:     // from internal hardware
720:     .de     (hw2reg.data_in[0].de),
721:     .d      (hw2reg.data_in[0].d),
722: 
723:     // to internal hardware
724:     .qe     (data_in_0_flds_we[0]),
725:     .q      (reg2hw.data_in[0].q),
726:     .ds     (),
727: 
728:     // to register interface (read)
729:     .qs     (data_in_0_qs)
730:   );
731:   assign reg2hw.data_in[0].qe = data_in_0_qe;
732: 
733: 
734:   // Subregister 1 of Multireg data_in
735:   // R[data_in_1]: V(False)
736:   logic data_in_1_qe;
737:   logic [0:0] data_in_1_flds_we;
738:   prim_flop #(
739:     .Width(1),
740:     .ResetValue(0)
741:   ) u_data_in1_qe (
742:     .clk_i(clk_i),
743:     .rst_ni(rst_ni),
744:     .d_i(&data_in_1_flds_we),
745:     .q_o(data_in_1_qe)
746:   );
747:   prim_subreg #(
748:     .DW      (32),
749:     .SwAccess(prim_subreg_pkg::SwAccessWO),
750:     .RESVAL  (32'h0),
751:     .Mubi    (1'b0)
752:   ) u_data_in_1 (
753:     .clk_i   (clk_i),
754:     .rst_ni  (rst_ni),
755: 
756:     // from register interface
757:     .we     (data_in_1_we),
758:     .wd     (data_in_1_wd),
759: 
760:     // from internal hardware
761:     .de     (hw2reg.data_in[1].de),
762:     .d      (hw2reg.data_in[1].d),
763: 
764:     // to internal hardware
765:     .qe     (data_in_1_flds_we[0]),
766:     .q      (reg2hw.data_in[1].q),
767:     .ds     (),
768: 
769:     // to register interface (read)
770:     .qs     (data_in_1_qs)
771:   );
772:   assign reg2hw.data_in[1].qe = data_in_1_qe;
773: 
774: 
775:   // Subregister 2 of Multireg data_in
776:   // R[data_in_2]: V(False)
777:   logic data_in_2_qe;
778:   logic [0:0] data_in_2_flds_we;
779:   prim_flop #(
780:     .Width(1),
781:     .ResetValue(0)
782:   ) u_data_in2_qe (
783:     .clk_i(clk_i),
784:     .rst_ni(rst_ni),
785:     .d_i(&data_in_2_flds_we),
786:     .q_o(data_in_2_qe)
787:   );
788:   prim_subreg #(
789:     .DW      (32),
790:     .SwAccess(prim_subreg_pkg::SwAccessWO),
791:     .RESVAL  (32'h0),
792:     .Mubi    (1'b0)
793:   ) u_data_in_2 (
794:     .clk_i   (clk_i),
795:     .rst_ni  (rst_ni),
796: 
797:     // from register interface
798:     .we     (data_in_2_we),
799:     .wd     (data_in_2_wd),
800: 
801:     // from internal hardware
802:     .de     (hw2reg.data_in[2].de),
803:     .d      (hw2reg.data_in[2].d),
804: 
805:     // to internal hardware
806:     .qe     (data_in_2_flds_we[0]),
807:     .q      (reg2hw.data_in[2].q),
808:     .ds     (),
809: 
810:     // to register interface (read)
811:     .qs     (data_in_2_qs)
812:   );
813:   assign reg2hw.data_in[2].qe = data_in_2_qe;
814: 
815: 
816:   // Subregister 3 of Multireg data_in
817:   // R[data_in_3]: V(False)
818:   logic data_in_3_qe;
819:   logic [0:0] data_in_3_flds_we;
820:   prim_flop #(
821:     .Width(1),
822:     .ResetValue(0)
823:   ) u_data_in3_qe (
824:     .clk_i(clk_i),
825:     .rst_ni(rst_ni),
826:     .d_i(&data_in_3_flds_we),
827:     .q_o(data_in_3_qe)
828:   );
829:   prim_subreg #(
830:     .DW      (32),
831:     .SwAccess(prim_subreg_pkg::SwAccessWO),
832:     .RESVAL  (32'h0),
833:     .Mubi    (1'b0)
834:   ) u_data_in_3 (
835:     .clk_i   (clk_i),
836:     .rst_ni  (rst_ni),
837: 
838:     // from register interface
839:     .we     (data_in_3_we),
840:     .wd     (data_in_3_wd),
841: 
842:     // from internal hardware
843:     .de     (hw2reg.data_in[3].de),
844:     .d      (hw2reg.data_in[3].d),
845: 
846:     // to internal hardware
847:     .qe     (data_in_3_flds_we[0]),
848:     .q      (reg2hw.data_in[3].q),
849:     .ds     (),
850: 
851:     // to register interface (read)
852:     .qs     (data_in_3_qs)
853:   );
854:   assign reg2hw.data_in[3].qe = data_in_3_qe;
855: 
856: 
857:   // Subregister 0 of Multireg data_out
858:   // R[data_out_0]: V(True)
859:   prim_subreg_ext #(
860:     .DW    (32)
861:   ) u_data_out_0 (
862:     .re     (data_out_0_re),
863:     .we     (1'b0),
864:     .wd     ('0),
865:     .d      (hw2reg.data_out[0].d),
866:     .qre    (reg2hw.data_out[0].re),
867:     .qe     (),
868:     .q      (reg2hw.data_out[0].q),
869:     .ds     (),
870:     .qs     (data_out_0_qs)
871:   );
872: 
873: 
874:   // Subregister 1 of Multireg data_out
875:   // R[data_out_1]: V(True)
876:   prim_subreg_ext #(
877:     .DW    (32)
878:   ) u_data_out_1 (
879:     .re     (data_out_1_re),
880:     .we     (1'b0),
881:     .wd     ('0),
882:     .d      (hw2reg.data_out[1].d),
883:     .qre    (reg2hw.data_out[1].re),
884:     .qe     (),
885:     .q      (reg2hw.data_out[1].q),
886:     .ds     (),
887:     .qs     (data_out_1_qs)
888:   );
889: 
890: 
891:   // Subregister 2 of Multireg data_out
892:   // R[data_out_2]: V(True)
893:   prim_subreg_ext #(
894:     .DW    (32)
895:   ) u_data_out_2 (
896:     .re     (data_out_2_re),
897:     .we     (1'b0),
898:     .wd     ('0),
899:     .d      (hw2reg.data_out[2].d),
900:     .qre    (reg2hw.data_out[2].re),
901:     .qe     (),
902:     .q      (reg2hw.data_out[2].q),
903:     .ds     (),
904:     .qs     (data_out_2_qs)
905:   );
906: 
907: 
908:   // Subregister 3 of Multireg data_out
909:   // R[data_out_3]: V(True)
910:   prim_subreg_ext #(
911:     .DW    (32)
912:   ) u_data_out_3 (
913:     .re     (data_out_3_re),
914:     .we     (1'b0),
915:     .wd     ('0),
916:     .d      (hw2reg.data_out[3].d),
917:     .qre    (reg2hw.data_out[3].re),
918:     .qe     (),
919:     .q      (reg2hw.data_out[3].q),
920:     .ds     (),
921:     .qs     (data_out_3_qs)
922:   );
923: 
924: 
925:   // R[ctrl_shadowed]: V(True)
926:   logic ctrl_shadowed_qe;
927:   logic [5:0] ctrl_shadowed_flds_we;
928:   assign ctrl_shadowed_qe = &ctrl_shadowed_flds_we;
929:   //   F[operation]: 1:0
930:   prim_subreg_ext #(
931:     .DW    (2)
932:   ) u_ctrl_shadowed_operation (
933:     .re     (ctrl_shadowed_re),
934:     .we     (ctrl_shadowed_we),
935:     .wd     (ctrl_shadowed_operation_wd),
936:     .d      (hw2reg.ctrl_shadowed.operation.d),
937:     .qre    (reg2hw.ctrl_shadowed.operation.re),
938:     .qe     (ctrl_shadowed_flds_we[0]),
939:     .q      (reg2hw.ctrl_shadowed.operation.q),
940:     .ds     (),
941:     .qs     (ctrl_shadowed_operation_qs)
942:   );
943:   assign reg2hw.ctrl_shadowed.operation.qe = ctrl_shadowed_qe;
944: 
945:   //   F[mode]: 7:2
946:   prim_subreg_ext #(
947:     .DW    (6)
948:   ) u_ctrl_shadowed_mode (
949:     .re     (ctrl_shadowed_re),
950:     .we     (ctrl_shadowed_we),
951:     .wd     (ctrl_shadowed_mode_wd),
952:     .d      (hw2reg.ctrl_shadowed.mode.d),
953:     .qre    (reg2hw.ctrl_shadowed.mode.re),
954:     .qe     (ctrl_shadowed_flds_we[1]),
955:     .q      (reg2hw.ctrl_shadowed.mode.q),
956:     .ds     (),
957:     .qs     (ctrl_shadowed_mode_qs)
958:   );
959:   assign reg2hw.ctrl_shadowed.mode.qe = ctrl_shadowed_qe;
960: 
961:   //   F[key_len]: 10:8
962:   prim_subreg_ext #(
963:     .DW    (3)
964:   ) u_ctrl_shadowed_key_len (
965:     .re     (ctrl_shadowed_re),
966:     .we     (ctrl_shadowed_we),
967:     .wd     (ctrl_shadowed_key_len_wd),
968:     .d      (hw2reg.ctrl_shadowed.key_len.d),
969:     .qre    (reg2hw.ctrl_shadowed.key_len.re),
970:     .qe     (ctrl_shadowed_flds_we[2]),
971:     .q      (reg2hw.ctrl_shadowed.key_len.q),
972:     .ds     (),
973:     .qs     (ctrl_shadowed_key_len_qs)
974:   );
975:   assign reg2hw.ctrl_shadowed.key_len.qe = ctrl_shadowed_qe;
976: 
977:   //   F[sideload]: 11:11
978:   prim_subreg_ext #(
979:     .DW    (1)
980:   ) u_ctrl_shadowed_sideload (
981:     .re     (ctrl_shadowed_re),
982:     .we     (ctrl_shadowed_we),
983:     .wd     (ctrl_shadowed_sideload_wd),
984:     .d      (hw2reg.ctrl_shadowed.sideload.d),
985:     .qre    (reg2hw.ctrl_shadowed.sideload.re),
986:     .qe     (ctrl_shadowed_flds_we[3]),
987:     .q      (reg2hw.ctrl_shadowed.sideload.q),
988:     .ds     (),
989:     .qs     (ctrl_shadowed_sideload_qs)
990:   );
991:   assign reg2hw.ctrl_shadowed.sideload.qe = ctrl_shadowed_qe;
992: 
993:   //   F[prng_reseed_rate]: 14:12
994:   prim_subreg_ext #(
995:     .DW    (3)
996:   ) u_ctrl_shadowed_prng_reseed_rate (
997:     .re     (ctrl_shadowed_re),
998:     .we     (ctrl_shadowed_we),
999:     .wd     (ctrl_shadowed_prng_reseed_rate_wd),
1000:     .d      (hw2reg.ctrl_shadowed.prng_reseed_rate.d),
1001:     .qre    (reg2hw.ctrl_shadowed.prng_reseed_rate.re),
1002:     .qe     (ctrl_shadowed_flds_we[4]),
1003:     .q      (reg2hw.ctrl_shadowed.prng_reseed_rate.q),
1004:     .ds     (),
1005:     .qs     (ctrl_shadowed_prng_reseed_rate_qs)
1006:   );
1007:   assign reg2hw.ctrl_shadowed.prng_reseed_rate.qe = ctrl_shadowed_qe;
1008: 
1009:   //   F[manual_operation]: 15:15
1010:   prim_subreg_ext #(
1011:     .DW    (1)
1012:   ) u_ctrl_shadowed_manual_operation (
1013:     .re     (ctrl_shadowed_re),
1014:     .we     (ctrl_shadowed_we),
1015:     .wd     (ctrl_shadowed_manual_operation_wd),
1016:     .d      (hw2reg.ctrl_shadowed.manual_operation.d),
1017:     .qre    (reg2hw.ctrl_shadowed.manual_operation.re),
1018:     .qe     (ctrl_shadowed_flds_we[5]),
1019:     .q      (reg2hw.ctrl_shadowed.manual_operation.q),
1020:     .ds     (),
1021:     .qs     (ctrl_shadowed_manual_operation_qs)
1022:   );
1023:   assign reg2hw.ctrl_shadowed.manual_operation.qe = ctrl_shadowed_qe;
1024: 
1025: 
1026:   // R[ctrl_aux_shadowed]: V(False)
1027:   // Create REGWEN-gated WE signal
1028:   logic ctrl_aux_shadowed_gated_we;
1029:   assign ctrl_aux_shadowed_gated_we = ctrl_aux_shadowed_we & ctrl_aux_regwen_qs;
1030:   //   F[key_touch_forces_reseed]: 0:0
1031:   prim_subreg_shadow #(
1032:     .DW      (1),
1033:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1034:     .RESVAL  (1'h1),
1035:     .Mubi    (1'b0)
1036:   ) u_ctrl_aux_shadowed_key_touch_forces_reseed (
1037:     .clk_i   (clk_i),
1038:     .rst_ni  (rst_ni),
1039:     .rst_shadowed_ni (rst_shadowed_ni),
1040: 
1041:     // from register interface
1042:     .re     (ctrl_aux_shadowed_re),
1043:     .we     (ctrl_aux_shadowed_gated_we),
1044:     .wd     (ctrl_aux_shadowed_key_touch_forces_reseed_wd),
1045: 
1046:     // from internal hardware
1047:     .de     (1'b0),
1048:     .d      ('0),
1049: 
1050:     // to internal hardware
1051:     .qe     (),
1052:     .q      (reg2hw.ctrl_aux_shadowed.key_touch_forces_reseed.q),
1053:     .ds     (),
1054: 
1055:     // to register interface (read)
1056:     .qs     (ctrl_aux_shadowed_key_touch_forces_reseed_qs),
1057: 
1058:     // Shadow register phase. Relevant for hwext only.
1059:     .phase  (),
1060: 
1061:     // Shadow register error conditions
1062:     .err_update  (ctrl_aux_shadowed_key_touch_forces_reseed_update_err),
1063:     .err_storage (ctrl_aux_shadowed_key_touch_forces_reseed_storage_err)
1064:   );
1065: 
1066:   //   F[force_masks]: 1:1
1067:   prim_subreg_shadow #(
1068:     .DW      (1),
1069:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1070:     .RESVAL  (1'h0),
1071:     .Mubi    (1'b0)
1072:   ) u_ctrl_aux_shadowed_force_masks (
1073:     .clk_i   (clk_i),
1074:     .rst_ni  (rst_ni),
1075:     .rst_shadowed_ni (rst_shadowed_ni),
1076: 
1077:     // from register interface
1078:     .re     (ctrl_aux_shadowed_re),
1079:     .we     (ctrl_aux_shadowed_gated_we),
1080:     .wd     (ctrl_aux_shadowed_force_masks_wd),
1081: 
1082:     // from internal hardware
1083:     .de     (1'b0),
1084:     .d      ('0),
1085: 
1086:     // to internal hardware
1087:     .qe     (),
1088:     .q      (reg2hw.ctrl_aux_shadowed.force_masks.q),
1089:     .ds     (),
1090: 
1091:     // to register interface (read)
1092:     .qs     (ctrl_aux_shadowed_force_masks_qs),
1093: 
1094:     // Shadow register phase. Relevant for hwext only.
1095:     .phase  (),
1096: 
1097:     // Shadow register error conditions
1098:     .err_update  (ctrl_aux_shadowed_force_masks_update_err),
1099:     .err_storage (ctrl_aux_shadowed_force_masks_storage_err)
1100:   );
1101: 
1102: 
1103:   // R[ctrl_aux_regwen]: V(False)
1104:   prim_subreg #(
1105:     .DW      (1),
1106:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
1107:     .RESVAL  (1'h1),
1108:     .Mubi    (1'b0)
1109:   ) u_ctrl_aux_regwen (
1110:     .clk_i   (clk_i),
1111:     .rst_ni  (rst_ni),
1112: 
1113:     // from register interface
1114:     .we     (ctrl_aux_regwen_we),
1115:     .wd     (ctrl_aux_regwen_wd),
1116: 
1117:     // from internal hardware
1118:     .de     (1'b0),
1119:     .d      ('0),
1120: 
1121:     // to internal hardware
1122:     .qe     (),
1123:     .q      (),
1124:     .ds     (),
1125: 
1126:     // to register interface (read)
1127:     .qs     (ctrl_aux_regwen_qs)
1128:   );
1129: 
1130: 
1131:   // R[trigger]: V(False)
1132:   //   F[start]: 0:0
1133:   prim_subreg #(
1134:     .DW      (1),
1135:     .SwAccess(prim_subreg_pkg::SwAccessWO),
1136:     .RESVAL  (1'h0),
1137:     .Mubi    (1'b0)
1138:   ) u_trigger_start (
1139:     .clk_i   (clk_i),
1140:     .rst_ni  (rst_ni),
1141: 
1142:     // from register interface
1143:     .we     (trigger_we),
1144:     .wd     (trigger_start_wd),
1145: 
1146:     // from internal hardware
1147:     .de     (hw2reg.trigger.start.de),
1148:     .d      (hw2reg.trigger.start.d),
1149: 
1150:     // to internal hardware
1151:     .qe     (),
1152:     .q      (reg2hw.trigger.start.q),
1153:     .ds     (),
1154: 
1155:     // to register interface (read)
1156:     .qs     ()
1157:   );
1158: 
1159:   //   F[key_iv_data_in_clear]: 1:1
1160:   prim_subreg #(
1161:     .DW      (1),
1162:     .SwAccess(prim_subreg_pkg::SwAccessWO),
1163:     .RESVAL  (1'h1),
1164:     .Mubi    (1'b0)
1165:   ) u_trigger_key_iv_data_in_clear (
1166:     .clk_i   (clk_i),
1167:     .rst_ni  (rst_ni),
1168: 
1169:     // from register interface
1170:     .we     (trigger_we),
1171:     .wd     (trigger_key_iv_data_in_clear_wd),
1172: 
1173:     // from internal hardware
1174:     .de     (hw2reg.trigger.key_iv_data_in_clear.de),
1175:     .d      (hw2reg.trigger.key_iv_data_in_clear.d),
1176: 
1177:     // to internal hardware
1178:     .qe     (),
1179:     .q      (reg2hw.trigger.key_iv_data_in_clear.q),
1180:     .ds     (),
1181: 
1182:     // to register interface (read)
1183:     .qs     ()
1184:   );
1185: 
1186:   //   F[data_out_clear]: 2:2
1187:   prim_subreg #(
1188:     .DW      (1),
1189:     .SwAccess(prim_subreg_pkg::SwAccessWO),
1190:     .RESVAL  (1'h1),
1191:     .Mubi    (1'b0)
1192:   ) u_trigger_data_out_clear (
1193:     .clk_i   (clk_i),
1194:     .rst_ni  (rst_ni),
1195: 
1196:     // from register interface
1197:     .we     (trigger_we),
1198:     .wd     (trigger_data_out_clear_wd),
1199: 
1200:     // from internal hardware
1201:     .de     (hw2reg.trigger.data_out_clear.de),
1202:     .d      (hw2reg.trigger.data_out_clear.d),
1203: 
1204:     // to internal hardware
1205:     .qe     (),
1206:     .q      (reg2hw.trigger.data_out_clear.q),
1207:     .ds     (),
1208: 
1209:     // to register interface (read)
1210:     .qs     ()
1211:   );
1212: 
1213:   //   F[prng_reseed]: 3:3
1214:   prim_subreg #(
1215:     .DW      (1),
1216:     .SwAccess(prim_subreg_pkg::SwAccessWO),
1217:     .RESVAL  (1'h1),
1218:     .Mubi    (1'b0)
1219:   ) u_trigger_prng_reseed (
1220:     .clk_i   (clk_i),
1221:     .rst_ni  (rst_ni),
1222: 
1223:     // from register interface
1224:     .we     (trigger_we),
1225:     .wd     (trigger_prng_reseed_wd),
1226: 
1227:     // from internal hardware
1228:     .de     (hw2reg.trigger.prng_reseed.de),
1229:     .d      (hw2reg.trigger.prng_reseed.d),
1230: 
1231:     // to internal hardware
1232:     .qe     (),
1233:     .q      (reg2hw.trigger.prng_reseed.q),
1234:     .ds     (),
1235: 
1236:     // to register interface (read)
1237:     .qs     ()
1238:   );
1239: 
1240: 
1241:   // R[status]: V(False)
1242:   //   F[idle]: 0:0
1243:   prim_subreg #(
1244:     .DW      (1),
1245:     .SwAccess(prim_subreg_pkg::SwAccessRO),
1246:     .RESVAL  (1'h0),
1247:     .Mubi    (1'b0)
1248:   ) u_status_idle (
1249:     .clk_i   (clk_i),
1250:     .rst_ni  (rst_ni),
1251: 
1252:     // from register interface
1253:     .we     (1'b0),
1254:     .wd     ('0),
1255: 
1256:     // from internal hardware
1257:     .de     (hw2reg.status.idle.de),
1258:     .d      (hw2reg.status.idle.d),
1259: 
1260:     // to internal hardware
1261:     .qe     (),
1262:     .q      (reg2hw.status.idle.q),
1263:     .ds     (),
1264: 
1265:     // to register interface (read)
1266:     .qs     (status_idle_qs)
1267:   );
1268: 
1269:   //   F[stall]: 1:1
1270:   prim_subreg #(
1271:     .DW      (1),
1272:     .SwAccess(prim_subreg_pkg::SwAccessRO),
1273:     .RESVAL  (1'h0),
1274:     .Mubi    (1'b0)
1275:   ) u_status_stall (
1276:     .clk_i   (clk_i),
1277:     .rst_ni  (rst_ni),
1278: 
1279:     // from register interface
1280:     .we     (1'b0),
1281:     .wd     ('0),
1282: 
1283:     // from internal hardware
1284:     .de     (hw2reg.status.stall.de),
1285:     .d      (hw2reg.status.stall.d),
1286: 
1287:     // to internal hardware
1288:     .qe     (),
1289:     .q      (),
1290:     .ds     (),
1291: 
1292:     // to register interface (read)
1293:     .qs     (status_stall_qs)
1294:   );
1295: 
1296:   //   F[output_lost]: 2:2
1297:   prim_subreg #(
1298:     .DW      (1),
1299:     .SwAccess(prim_subreg_pkg::SwAccessRO),
1300:     .RESVAL  (1'h0),
1301:     .Mubi    (1'b0)
1302:   ) u_status_output_lost (
1303:     .clk_i   (clk_i),
1304:     .rst_ni  (rst_ni),
1305: 
1306:     // from register interface
1307:     .we     (1'b0),
1308:     .wd     ('0),
1309: 
1310:     // from internal hardware
1311:     .de     (hw2reg.status.output_lost.de),
1312:     .d      (hw2reg.status.output_lost.d),
1313: 
1314:     // to internal hardware
1315:     .qe     (),
1316:     .q      (reg2hw.status.output_lost.q),
1317:     .ds     (),
1318: 
1319:     // to register interface (read)
1320:     .qs     (status_output_lost_qs)
1321:   );
1322: 
1323:   //   F[output_valid]: 3:3
1324:   prim_subreg #(
1325:     .DW      (1),
1326:     .SwAccess(prim_subreg_pkg::SwAccessRO),
1327:     .RESVAL  (1'h0),
1328:     .Mubi    (1'b0)
1329:   ) u_status_output_valid (
1330:     .clk_i   (clk_i),
1331:     .rst_ni  (rst_ni),
1332: 
1333:     // from register interface
1334:     .we     (1'b0),
1335:     .wd     ('0),
1336: 
1337:     // from internal hardware
1338:     .de     (hw2reg.status.output_valid.de),
1339:     .d      (hw2reg.status.output_valid.d),
1340: 
1341:     // to internal hardware
1342:     .qe     (),
1343:     .q      (),
1344:     .ds     (),
1345: 
1346:     // to register interface (read)
1347:     .qs     (status_output_valid_qs)
1348:   );
1349: 
1350:   //   F[input_ready]: 4:4
1351:   prim_subreg #(
1352:     .DW      (1),
1353:     .SwAccess(prim_subreg_pkg::SwAccessRO),
1354:     .RESVAL  (1'h0),
1355:     .Mubi    (1'b0)
1356:   ) u_status_input_ready (
1357:     .clk_i   (clk_i),
1358:     .rst_ni  (rst_ni),
1359: 
1360:     // from register interface
1361:     .we     (1'b0),
1362:     .wd     ('0),
1363: 
1364:     // from internal hardware
1365:     .de     (hw2reg.status.input_ready.de),
1366:     .d      (hw2reg.status.input_ready.d),
1367: 
1368:     // to internal hardware
1369:     .qe     (),
1370:     .q      (),
1371:     .ds     (),
1372: 
1373:     // to register interface (read)
1374:     .qs     (status_input_ready_qs)
1375:   );
1376: 
1377:   //   F[alert_recov_ctrl_update_err]: 5:5
1378:   prim_subreg #(
1379:     .DW      (1),
1380:     .SwAccess(prim_subreg_pkg::SwAccessRO),
1381:     .RESVAL  (1'h0),
1382:     .Mubi    (1'b0)
1383:   ) u_status_alert_recov_ctrl_update_err (
1384:     .clk_i   (clk_i),
1385:     .rst_ni  (rst_ni),
1386: 
1387:     // from register interface
1388:     .we     (1'b0),
1389:     .wd     ('0),
1390: 
1391:     // from internal hardware
1392:     .de     (hw2reg.status.alert_recov_ctrl_update_err.de),
1393:     .d      (hw2reg.status.alert_recov_ctrl_update_err.d),
1394: 
1395:     // to internal hardware
1396:     .qe     (),
1397:     .q      (),
1398:     .ds     (),
1399: 
1400:     // to register interface (read)
1401:     .qs     (status_alert_recov_ctrl_update_err_qs)
1402:   );
1403: 
1404:   //   F[alert_fatal_fault]: 6:6
1405:   prim_subreg #(
1406:     .DW      (1),
1407:     .SwAccess(prim_subreg_pkg::SwAccessRO),
1408:     .RESVAL  (1'h0),
1409:     .Mubi    (1'b0)
1410:   ) u_status_alert_fatal_fault (
1411:     .clk_i   (clk_i),
1412:     .rst_ni  (rst_ni),
1413: 
1414:     // from register interface
1415:     .we     (1'b0),
1416:     .wd     ('0),
1417: 
1418:     // from internal hardware
1419:     .de     (hw2reg.status.alert_fatal_fault.de),
1420:     .d      (hw2reg.status.alert_fatal_fault.d),
1421: 
1422:     // to internal hardware
1423:     .qe     (),
1424:     .q      (),
1425:     .ds     (),
1426: 
1427:     // to register interface (read)
1428:     .qs     (status_alert_fatal_fault_qs)
1429:   );
1430: 
1431: 
1432: 
1433:   logic [33:0] addr_hit;
1434:   always_comb begin
1435:     addr_hit[ 0] = (reg_addr == AES_ALERT_TEST_OFFSET);
1436:     addr_hit[ 1] = (reg_addr == AES_KEY_SHARE0_0_OFFSET);
1437:     addr_hit[ 2] = (reg_addr == AES_KEY_SHARE0_1_OFFSET);
1438:     addr_hit[ 3] = (reg_addr == AES_KEY_SHARE0_2_OFFSET);
1439:     addr_hit[ 4] = (reg_addr == AES_KEY_SHARE0_3_OFFSET);
1440:     addr_hit[ 5] = (reg_addr == AES_KEY_SHARE0_4_OFFSET);
1441:     addr_hit[ 6] = (reg_addr == AES_KEY_SHARE0_5_OFFSET);
1442:     addr_hit[ 7] = (reg_addr == AES_KEY_SHARE0_6_OFFSET);
1443:     addr_hit[ 8] = (reg_addr == AES_KEY_SHARE0_7_OFFSET);
1444:     addr_hit[ 9] = (reg_addr == AES_KEY_SHARE1_0_OFFSET);
1445:     addr_hit[10] = (reg_addr == AES_KEY_SHARE1_1_OFFSET);
1446:     addr_hit[11] = (reg_addr == AES_KEY_SHARE1_2_OFFSET);
1447:     addr_hit[12] = (reg_addr == AES_KEY_SHARE1_3_OFFSET);
1448:     addr_hit[13] = (reg_addr == AES_KEY_SHARE1_4_OFFSET);
1449:     addr_hit[14] = (reg_addr == AES_KEY_SHARE1_5_OFFSET);
1450:     addr_hit[15] = (reg_addr == AES_KEY_SHARE1_6_OFFSET);
1451:     addr_hit[16] = (reg_addr == AES_KEY_SHARE1_7_OFFSET);
1452:     addr_hit[17] = (reg_addr == AES_IV_0_OFFSET);
1453:     addr_hit[18] = (reg_addr == AES_IV_1_OFFSET);
1454:     addr_hit[19] = (reg_addr == AES_IV_2_OFFSET);
1455:     addr_hit[20] = (reg_addr == AES_IV_3_OFFSET);
1456:     addr_hit[21] = (reg_addr == AES_DATA_IN_0_OFFSET);
1457:     addr_hit[22] = (reg_addr == AES_DATA_IN_1_OFFSET);
1458:     addr_hit[23] = (reg_addr == AES_DATA_IN_2_OFFSET);
1459:     addr_hit[24] = (reg_addr == AES_DATA_IN_3_OFFSET);
1460:     addr_hit[25] = (reg_addr == AES_DATA_OUT_0_OFFSET);
1461:     addr_hit[26] = (reg_addr == AES_DATA_OUT_1_OFFSET);
1462:     addr_hit[27] = (reg_addr == AES_DATA_OUT_2_OFFSET);
1463:     addr_hit[28] = (reg_addr == AES_DATA_OUT_3_OFFSET);
1464:     addr_hit[29] = (reg_addr == AES_CTRL_SHADOWED_OFFSET);
1465:     addr_hit[30] = (reg_addr == AES_CTRL_AUX_SHADOWED_OFFSET);
1466:     addr_hit[31] = (reg_addr == AES_CTRL_AUX_REGWEN_OFFSET);
1467:     addr_hit[32] = (reg_addr == AES_TRIGGER_OFFSET);
1468:     addr_hit[33] = (reg_addr == AES_STATUS_OFFSET);
1469:   end
1470: 
1471:   assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;
1472: 
1473:   // Check sub-word write is permitted
1474:   always_comb begin
1475:     wr_err = (reg_we &
1476:               ((addr_hit[ 0] & (|(AES_PERMIT[ 0] & ~reg_be))) |
1477:                (addr_hit[ 1] & (|(AES_PERMIT[ 1] & ~reg_be))) |
1478:                (addr_hit[ 2] & (|(AES_PERMIT[ 2] & ~reg_be))) |
1479:                (addr_hit[ 3] & (|(AES_PERMIT[ 3] & ~reg_be))) |
1480:                (addr_hit[ 4] & (|(AES_PERMIT[ 4] & ~reg_be))) |
1481:                (addr_hit[ 5] & (|(AES_PERMIT[ 5] & ~reg_be))) |
1482:                (addr_hit[ 6] & (|(AES_PERMIT[ 6] & ~reg_be))) |
1483:                (addr_hit[ 7] & (|(AES_PERMIT[ 7] & ~reg_be))) |
1484:                (addr_hit[ 8] & (|(AES_PERMIT[ 8] & ~reg_be))) |
1485:                (addr_hit[ 9] & (|(AES_PERMIT[ 9] & ~reg_be))) |
1486:                (addr_hit[10] & (|(AES_PERMIT[10] & ~reg_be))) |
1487:                (addr_hit[11] & (|(AES_PERMIT[11] & ~reg_be))) |
1488:                (addr_hit[12] & (|(AES_PERMIT[12] & ~reg_be))) |
1489:                (addr_hit[13] & (|(AES_PERMIT[13] & ~reg_be))) |
1490:                (addr_hit[14] & (|(AES_PERMIT[14] & ~reg_be))) |
1491:                (addr_hit[15] & (|(AES_PERMIT[15] & ~reg_be))) |
1492:                (addr_hit[16] & (|(AES_PERMIT[16] & ~reg_be))) |
1493:                (addr_hit[17] & (|(AES_PERMIT[17] & ~reg_be))) |
1494:                (addr_hit[18] & (|(AES_PERMIT[18] & ~reg_be))) |
1495:                (addr_hit[19] & (|(AES_PERMIT[19] & ~reg_be))) |
1496:                (addr_hit[20] & (|(AES_PERMIT[20] & ~reg_be))) |
1497:                (addr_hit[21] & (|(AES_PERMIT[21] & ~reg_be))) |
1498:                (addr_hit[22] & (|(AES_PERMIT[22] & ~reg_be))) |
1499:                (addr_hit[23] & (|(AES_PERMIT[23] & ~reg_be))) |
1500:                (addr_hit[24] & (|(AES_PERMIT[24] & ~reg_be))) |
1501:                (addr_hit[25] & (|(AES_PERMIT[25] & ~reg_be))) |
1502:                (addr_hit[26] & (|(AES_PERMIT[26] & ~reg_be))) |
1503:                (addr_hit[27] & (|(AES_PERMIT[27] & ~reg_be))) |
1504:                (addr_hit[28] & (|(AES_PERMIT[28] & ~reg_be))) |
1505:                (addr_hit[29] & (|(AES_PERMIT[29] & ~reg_be))) |
1506:                (addr_hit[30] & (|(AES_PERMIT[30] & ~reg_be))) |
1507:                (addr_hit[31] & (|(AES_PERMIT[31] & ~reg_be))) |
1508:                (addr_hit[32] & (|(AES_PERMIT[32] & ~reg_be))) |
1509:                (addr_hit[33] & (|(AES_PERMIT[33] & ~reg_be)))));
1510:   end
1511: 
1512:   // Generate write-enables
1513:   assign alert_test_we = addr_hit[0] & reg_we & !reg_error;
1514: 
1515:   assign alert_test_recov_ctrl_update_err_wd = reg_wdata[0];
1516: 
1517:   assign alert_test_fatal_fault_wd = reg_wdata[1];
1518:   assign key_share0_0_we = addr_hit[1] & reg_we & !reg_error;
1519: 
1520:   assign key_share0_0_wd = reg_wdata[31:0];
1521:   assign key_share0_1_we = addr_hit[2] & reg_we & !reg_error;
1522: 
1523:   assign key_share0_1_wd = reg_wdata[31:0];
1524:   assign key_share0_2_we = addr_hit[3] & reg_we & !reg_error;
1525: 
1526:   assign key_share0_2_wd = reg_wdata[31:0];
1527:   assign key_share0_3_we = addr_hit[4] & reg_we & !reg_error;
1528: 
1529:   assign key_share0_3_wd = reg_wdata[31:0];
1530:   assign key_share0_4_we = addr_hit[5] & reg_we & !reg_error;
1531: 
1532:   assign key_share0_4_wd = reg_wdata[31:0];
1533:   assign key_share0_5_we = addr_hit[6] & reg_we & !reg_error;
1534: 
1535:   assign key_share0_5_wd = reg_wdata[31:0];
1536:   assign key_share0_6_we = addr_hit[7] & reg_we & !reg_error;
1537: 
1538:   assign key_share0_6_wd = reg_wdata[31:0];
1539:   assign key_share0_7_we = addr_hit[8] & reg_we & !reg_error;
1540: 
1541:   assign key_share0_7_wd = reg_wdata[31:0];
1542:   assign key_share1_0_we = addr_hit[9] & reg_we & !reg_error;
1543: 
1544:   assign key_share1_0_wd = reg_wdata[31:0];
1545:   assign key_share1_1_we = addr_hit[10] & reg_we & !reg_error;
1546: 
1547:   assign key_share1_1_wd = reg_wdata[31:0];
1548:   assign key_share1_2_we = addr_hit[11] & reg_we & !reg_error;
1549: 
1550:   assign key_share1_2_wd = reg_wdata[31:0];
1551:   assign key_share1_3_we = addr_hit[12] & reg_we & !reg_error;
1552: 
1553:   assign key_share1_3_wd = reg_wdata[31:0];
1554:   assign key_share1_4_we = addr_hit[13] & reg_we & !reg_error;
1555: 
1556:   assign key_share1_4_wd = reg_wdata[31:0];
1557:   assign key_share1_5_we = addr_hit[14] & reg_we & !reg_error;
1558: 
1559:   assign key_share1_5_wd = reg_wdata[31:0];
1560:   assign key_share1_6_we = addr_hit[15] & reg_we & !reg_error;
1561: 
1562:   assign key_share1_6_wd = reg_wdata[31:0];
1563:   assign key_share1_7_we = addr_hit[16] & reg_we & !reg_error;
1564: 
1565:   assign key_share1_7_wd = reg_wdata[31:0];
1566:   assign iv_0_re = addr_hit[17] & reg_re & !reg_error;
1567:   assign iv_0_we = addr_hit[17] & reg_we & !reg_error;
1568: 
1569:   assign iv_0_wd = reg_wdata[31:0];
1570:   assign iv_1_re = addr_hit[18] & reg_re & !reg_error;
1571:   assign iv_1_we = addr_hit[18] & reg_we & !reg_error;
1572: 
1573:   assign iv_1_wd = reg_wdata[31:0];
1574:   assign iv_2_re = addr_hit[19] & reg_re & !reg_error;
1575:   assign iv_2_we = addr_hit[19] & reg_we & !reg_error;
1576: 
1577:   assign iv_2_wd = reg_wdata[31:0];
1578:   assign iv_3_re = addr_hit[20] & reg_re & !reg_error;
1579:   assign iv_3_we = addr_hit[20] & reg_we & !reg_error;
1580: 
1581:   assign iv_3_wd = reg_wdata[31:0];
1582:   assign data_in_0_we = addr_hit[21] & reg_we & !reg_error;
1583: 
1584:   assign data_in_0_wd = reg_wdata[31:0];
1585:   assign data_in_1_we = addr_hit[22] & reg_we & !reg_error;
1586: 
1587:   assign data_in_1_wd = reg_wdata[31:0];
1588:   assign data_in_2_we = addr_hit[23] & reg_we & !reg_error;
1589: 
1590:   assign data_in_2_wd = reg_wdata[31:0];
1591:   assign data_in_3_we = addr_hit[24] & reg_we & !reg_error;
1592: 
1593:   assign data_in_3_wd = reg_wdata[31:0];
1594:   assign data_out_0_re = addr_hit[25] & reg_re & !reg_error;
1595:   assign data_out_1_re = addr_hit[26] & reg_re & !reg_error;
1596:   assign data_out_2_re = addr_hit[27] & reg_re & !reg_error;
1597:   assign data_out_3_re = addr_hit[28] & reg_re & !reg_error;
1598:   assign ctrl_shadowed_re = addr_hit[29] & reg_re & !reg_error;
1599:   assign ctrl_shadowed_we = addr_hit[29] & reg_we & !reg_error;
1600: 
1601:   assign ctrl_shadowed_operation_wd = reg_wdata[1:0];
1602: 
1603:   assign ctrl_shadowed_mode_wd = reg_wdata[7:2];
1604: 
1605:   assign ctrl_shadowed_key_len_wd = reg_wdata[10:8];
1606: 
1607:   assign ctrl_shadowed_sideload_wd = reg_wdata[11];
1608: 
1609:   assign ctrl_shadowed_prng_reseed_rate_wd = reg_wdata[14:12];
1610: 
1611:   assign ctrl_shadowed_manual_operation_wd = reg_wdata[15];
1612:   assign ctrl_aux_shadowed_re = addr_hit[30] & reg_re & !reg_error;
1613:   assign ctrl_aux_shadowed_we = addr_hit[30] & reg_we & !reg_error;
1614: 
1615:   assign ctrl_aux_shadowed_key_touch_forces_reseed_wd = reg_wdata[0];
1616: 
1617:   assign ctrl_aux_shadowed_force_masks_wd = reg_wdata[1];
1618:   assign ctrl_aux_regwen_we = addr_hit[31] & reg_we & !reg_error;
1619: 
1620:   assign ctrl_aux_regwen_wd = reg_wdata[0];
1621:   assign trigger_we = addr_hit[32] & reg_we & !reg_error;
1622: 
1623:   assign trigger_start_wd = reg_wdata[0];
1624: 
1625:   assign trigger_key_iv_data_in_clear_wd = reg_wdata[1];
1626: 
1627:   assign trigger_data_out_clear_wd = reg_wdata[2];
1628: 
1629:   assign trigger_prng_reseed_wd = reg_wdata[3];
1630: 
1631:   // Assign write-enables to checker logic vector.
1632:   always_comb begin
1633:     reg_we_check[0] = alert_test_we;
1634:     reg_we_check[1] = key_share0_0_we;
1635:     reg_we_check[2] = key_share0_1_we;
1636:     reg_we_check[3] = key_share0_2_we;
1637:     reg_we_check[4] = key_share0_3_we;
1638:     reg_we_check[5] = key_share0_4_we;
1639:     reg_we_check[6] = key_share0_5_we;
1640:     reg_we_check[7] = key_share0_6_we;
1641:     reg_we_check[8] = key_share0_7_we;
1642:     reg_we_check[9] = key_share1_0_we;
1643:     reg_we_check[10] = key_share1_1_we;
1644:     reg_we_check[11] = key_share1_2_we;
1645:     reg_we_check[12] = key_share1_3_we;
1646:     reg_we_check[13] = key_share1_4_we;
1647:     reg_we_check[14] = key_share1_5_we;
1648:     reg_we_check[15] = key_share1_6_we;
1649:     reg_we_check[16] = key_share1_7_we;
1650:     reg_we_check[17] = iv_0_we;
1651:     reg_we_check[18] = iv_1_we;
1652:     reg_we_check[19] = iv_2_we;
1653:     reg_we_check[20] = iv_3_we;
1654:     reg_we_check[21] = data_in_0_we;
1655:     reg_we_check[22] = data_in_1_we;
1656:     reg_we_check[23] = data_in_2_we;
1657:     reg_we_check[24] = data_in_3_we;
1658:     reg_we_check[25] = 1'b0;
1659:     reg_we_check[26] = 1'b0;
1660:     reg_we_check[27] = 1'b0;
1661:     reg_we_check[28] = 1'b0;
1662:     reg_we_check[29] = ctrl_shadowed_we;
1663:     reg_we_check[30] = ctrl_aux_shadowed_gated_we;
1664:     reg_we_check[31] = ctrl_aux_regwen_we;
1665:     reg_we_check[32] = trigger_we;
1666:     reg_we_check[33] = 1'b0;
1667:   end
1668: 
1669:   // Read data return
1670:   always_comb begin
1671:     reg_rdata_next = '0;
1672:     unique case (1'b1)
1673:       addr_hit[0]: begin
1674:         reg_rdata_next[0] = '0;
1675:         reg_rdata_next[1] = '0;
1676:       end
1677: 
1678:       addr_hit[1]: begin
1679:         reg_rdata_next[31:0] = reg2hw.key_share0[0].q;
1680:       end
1681: 
1682:       addr_hit[2]: begin
1683:         reg_rdata_next[31:0] = reg2hw.key_share0[1].q;
1684:       end
1685: 
1686:       addr_hit[3]: begin
1687:         reg_rdata_next[31:0] = reg2hw.key_share0[2].q;
1688:       end
1689: 
1690:       addr_hit[4]: begin
1691:         reg_rdata_next[31:0] = reg2hw.key_share0[3].q;
1692:       end
1693: 
1694:       addr_hit[5]: begin
1695:         reg_rdata_next[31:0] = reg2hw.key_share0[4].q;
1696:       end
1697: 
1698:       addr_hit[6]: begin
1699:         reg_rdata_next[31:0] = reg2hw.key_share0[5].q;
1700:       end
1701: 
1702:       addr_hit[7]: begin
1703:         reg_rdata_next[31:0] = reg2hw.key_share0[6].q;
1704:       end
1705: 
1706:       addr_hit[8]: begin
1707:         reg_rdata_next[31:0] = reg2hw.key_share0[7].q;
1708:       end
1709: 
1710:       addr_hit[9]: begin
1711:         reg_rdata_next[31:0] = data_in_0_qs;
1712:       end
1713: 
1714:       addr_hit[10]: begin
1715:         reg_rdata_next[31:0] = data_in_1_qs;
1716:       end
1717: 
1718:       addr_hit[11]: begin
1719:         reg_rdata_next[31:0] = data_in_2_qs;
1720:       end
1721: 
1722:       addr_hit[12]: begin
1723:         reg_rdata_next[31:0] = data_in_3_qs;
1724:       end
1725: 
1726:       addr_hit[13]: begin
1727:         reg_rdata_next[31:0] = '0;
1728:       end
1729: 
1730:       addr_hit[14]: begin
1731:         reg_rdata_next[31:0] = '0;
1732:       end
1733: 
1734:       addr_hit[15]: begin
1735:         reg_rdata_next[31:0] = '0;
1736:       end
1737: 
1738:       addr_hit[16]: begin
1739:         reg_rdata_next[31:0] = '0;
1740:       end
1741: 
1742:       addr_hit[17]: begin
1743:         reg_rdata_next[31:0] = iv_0_qs;
1744:       end
1745: 
1746:       addr_hit[18]: begin
1747:         reg_rdata_next[31:0] = iv_1_qs;
1748:       end
1749: 
1750:       addr_hit[19]: begin
1751:         reg_rdata_next[31:0] = iv_2_qs;
1752:       end
1753: 
1754:       addr_hit[20]: begin
1755:         reg_rdata_next[31:0] = iv_3_qs;
1756:       end
1757: 
1758:       addr_hit[21]: begin
1759:         reg_rdata_next[31:0] = '0;
1760:       end
1761: 
1762:       addr_hit[22]: begin
1763:         reg_rdata_next[31:0] = '0;
1764:       end
1765: 
1766:       addr_hit[23]: begin
1767:         reg_rdata_next[31:0] = '0;
1768:       end
1769: 
1770:       addr_hit[24]: begin
1771:         reg_rdata_next[31:0] = '0;
1772:       end
1773: 
1774:       addr_hit[25]: begin
1775:         reg_rdata_next[31:0] = data_out_0_qs;
1776:       end
1777: 
1778:       addr_hit[26]: begin
1779:         reg_rdata_next[31:0] = data_out_1_qs;
1780:       end
1781: 
1782:       addr_hit[27]: begin
1783:         reg_rdata_next[31:0] = data_out_2_qs;
1784:       end
1785: 
1786:       addr_hit[28]: begin
1787:         reg_rdata_next[31:0] = data_out_3_qs;
1788:       end
1789: 
1790:       addr_hit[29]: begin
1791:         reg_rdata_next[1:0] = ctrl_shadowed_operation_qs;
1792:         reg_rdata_next[7:2] = ctrl_shadowed_mode_qs;
1793:         reg_rdata_next[10:8] = ctrl_shadowed_key_len_qs;
1794:         reg_rdata_next[11] = ctrl_shadowed_sideload_qs;
1795:         reg_rdata_next[14:12] = ctrl_shadowed_prng_reseed_rate_qs;
1796:         reg_rdata_next[15] = ctrl_shadowed_manual_operation_qs;
1797:       end
1798: 
1799:       addr_hit[30]: begin
1800:         reg_rdata_next[0] = ctrl_aux_shadowed_key_touch_forces_reseed_qs;
1801:         reg_rdata_next[1] = ctrl_aux_shadowed_force_masks_qs;
1802:       end
1803: 
1804:       addr_hit[31]: begin
1805:         reg_rdata_next[0] = ctrl_aux_regwen_qs;
1806:       end
1807: 
1808:       addr_hit[32]: begin
1809:         reg_rdata_next[0] = '0;
1810:         reg_rdata_next[1] = '0;
1811:         reg_rdata_next[2] = '0;
1812:         reg_rdata_next[3] = '0;
1813:       end
1814: 
1815:       addr_hit[33]: begin
1816:         reg_rdata_next[0] = status_idle_qs;
1817:         reg_rdata_next[1] = status_stall_qs;
1818:         reg_rdata_next[2] = status_output_lost_qs;
1819:         reg_rdata_next[3] = status_output_valid_qs;
1820:         reg_rdata_next[4] = status_input_ready_qs;
1821:         reg_rdata_next[5] = status_alert_recov_ctrl_update_err_qs;
1822:         reg_rdata_next[6] = status_alert_fatal_fault_qs;
1823:       end
1824: 
1825:       default: begin
1826:         reg_rdata_next = '1;
1827:       end
1828:     endcase
1829:   end
1830: 
1831:   // shadow busy
1832:   logic shadow_busy;
1833:   logic rst_done;
1834:   logic shadow_rst_done;
1835:   always_ff @(posedge clk_i or negedge rst_ni) begin
1836:     if (!rst_ni) begin
1837:       rst_done <= '0;
1838:     end else begin
1839:       rst_done <= 1'b1;
1840:     end
1841:   end
1842: 
1843:   always_ff @(posedge clk_i or negedge rst_shadowed_ni) begin
1844:     if (!rst_shadowed_ni) begin
1845:       shadow_rst_done <= '0;
1846:     end else begin
1847:       shadow_rst_done <= 1'b1;
1848:     end
1849:   end
1850: 
1851:   // both shadow and normal resets have been released
1852:   assign shadow_busy = ~(rst_done & shadow_rst_done);
1853: 
1854:   // Collect up storage and update errors
1855:   assign shadowed_storage_err_o = |{
1856:     ctrl_aux_shadowed_key_touch_forces_reseed_storage_err,
1857:     ctrl_aux_shadowed_force_masks_storage_err
1858:   };
1859:   assign shadowed_update_err_o = |{
1860:     ctrl_aux_shadowed_key_touch_forces_reseed_update_err,
1861:     ctrl_aux_shadowed_force_masks_update_err
1862:   };
1863: 
1864:   // register busy
1865:   assign reg_busy = shadow_busy;
1866: 
1867:   // Unused signal tieoff
1868: 
1869:   // wdata / byte enable are not always fully used
1870:   // add a blanket unused statement to handle lint waivers
1871:   logic unused_wdata;
1872:   logic unused_be;
1873:   assign unused_wdata = ^reg_wdata;
1874:   assign unused_be = ^reg_be;
1875: 
1876:   // Assertions for Register Interface
1877:   `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
1878:   `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)
1879: 
1880:   `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)
1881: 
1882:   `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)
1883: 
1884:   // this is formulated as an assumption such that the FPV testbenches do disprove this
1885:   // property by mistake
1886:   //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)
1887: 
1888: endmodule

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_gKHMfG2XsVsKrluZPkhXKFO4)
 Call ID: call_gKHMfG2XsVsKrluZPkhXKFO4
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes/rtl/aes_control.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // AES main control
6: //
7: // This module controls the interplay of input/output registers and the AES cipher core.
8: 
9: `include "prim_assert.sv"
10: 
11: module aes_control
12:   import aes_pkg::*;
13:   import aes_reg_pkg::*;
14: #(
15:   parameter bit          SecMasking           = 0,
16:   parameter int unsigned SecStartTriggerDelay = 0
17: ) (
18:   input  logic                      clk_i,
19:   input  logic                      rst_ni,
20: 
21:   // Main control signals
22:   input  logic                      ctrl_qe_i,
23:   output logic                      ctrl_we_o,
24:   input  logic                      ctrl_phase_i,
25:   input  logic                      ctrl_err_storage_i,
26:   input  aes_op_e                   op_i,
27:   input  aes_mode_e                 mode_i,
28:   input  ciph_op_e                  cipher_op_i,
29:   input  logic                      sideload_i,
30:   input  prs_rate_e                 prng_reseed_rate_i,
31:   input  logic                      manual_operation_i,
32:   input  logic                      key_touch_forces_reseed_i,
33:   input  logic                      start_i,
34:   input  logic                      key_iv_data_in_clear_i,
35:   input  logic                      data_out_clear_i,
36:   input  logic                      prng_reseed_i,
37:   input  logic                      mux_sel_err_i,
38:   input  logic                      sp_enc_err_i,
39:   input  lc_ctrl_pkg::lc_tx_t       lc_escalate_en_i,
40:   input  logic                      alert_fatal_i,
41:   output logic                      alert_o,
42: 
43:   // I/O register read/write enables
44:   input  logic                      key_sideload_valid_i,
45:   input  logic     [NumRegsKey-1:0] key_init_qe_i [NumSharesKey],
46:   input  logic      [NumRegsIv-1:0] iv_qe_i,
47:   input  logic    [NumRegsData-1:0] data_in_qe_i,
48:   input  logic    [NumRegsData-1:0] data_out_re_i,
49:   output logic                      data_in_we_o,
50:   output sp2v_e                     data_out_we_o,
51: 
52:   // Previous input data register
53:   output dip_sel_e                  data_in_prev_sel_o,
54:   output sp2v_e                     data_in_prev_we_o,
55: 
56:   // Cipher I/O muxes
57:   output si_sel_e                   state_in_sel_o,
58:   output add_si_sel_e               add_state_in_sel_o,
59:   output add_so_sel_e               add_state_out_sel_o,
60: 
61:   // Counter
62:   output sp2v_e                     ctr_incr_o,
63:   input  sp2v_e                     ctr_ready_i,
64:   input  sp2v_e  [NumSlicesCtr-1:0] ctr_we_i,
65: 
66:   // Cipher core control and sync
67:   output sp2v_e                     cipher_in_valid_o,
68:   input  sp2v_e                     cipher_in_ready_i,
69:   input  sp2v_e                     cipher_out_valid_i,
70:   output sp2v_e                     cipher_out_ready_o,
71:   output sp2v_e                     cipher_crypt_o,
72:   input  sp2v_e                     cipher_crypt_i,
73:   output sp2v_e                     cipher_dec_key_gen_o,
74:   input  sp2v_e                     cipher_dec_key_gen_i,
75:   output logic                      cipher_prng_reseed_o,
76:   input  logic                      cipher_prng_reseed_i,
77:   output logic                      cipher_key_clear_o,
78:   input  logic                      cipher_key_clear_i,
79:   output logic                      cipher_data_out_clear_o,
80:   input  logic                      cipher_data_out_clear_i,
81: 
82:   // Initial key registers
83:   output key_init_sel_e             key_init_sel_o,
84:   output sp2v_e    [NumRegsKey-1:0] key_init_we_o [NumSharesKey],
85: 
86:   // IV registers
87:   output iv_sel_e                   iv_sel_o,
88:   output sp2v_e  [NumSlicesCtr-1:0] iv_we_o,
89: 
90:   // Pseudo-random number generator interface
91:   output logic                      prng_data_req_o,
92:   input  logic                      prng_data_ack_i,
93:   output logic                      prng_reseed_req_o,
94:   input  logic                      prng_reseed_ack_i,
95: 
96:   // Trigger register
97:   output logic                      start_o,
98:   output logic                      start_we_o,
99:   output logic                      key_iv_data_in_clear_o,
100:   output logic                      key_iv_data_in_clear_we_o,
101:   output logic                      data_out_clear_o,
102:   output logic                      data_out_clear_we_o,
103:   output logic                      prng_reseed_o,
104:   output logic                      prng_reseed_we_o,
105: 
106:   // Status register
107:   output logic                      idle_o,
108:   output logic                      idle_we_o,
109:   output logic                      stall_o,
110:   output logic                      stall_we_o,
111:   input  logic                      output_lost_i,
112:   output logic                      output_lost_o,
113:   output logic                      output_lost_we_o,
114:   output logic                      output_valid_o,
115:   output logic                      output_valid_we_o,
116:   output logic                      input_ready_o,
117:   output logic                      input_ready_we_o
118: );
119: 
120:   // Optional delay of manual start trigger
121:   logic start_trigger;
122: 
123:   // Create a lint error to reduce the risk of accidentally enabling this feature.
124:   `ASSERT_STATIC_LINT_ERROR(AesSecStartTriggerDelayNonDefault, SecStartTriggerDelay == 0)
125: 
126:   if (SecStartTriggerDelay > 0) begin : gen_start_delay
127:     // Delay the manual start trigger input for SCA measurements.
128:     localparam int unsigned WidthCounter = $clog2(SecStartTriggerDelay+1);
129:     logic [WidthCounter-1:0] count_d, count_q;
130: 
131:     // Clear counter when input goes low. Keep value if the specified delay is reached.
132:     assign count_d = !start_i       ? '0      :
133:                       start_trigger ? count_q : count_q + 1'b1;
134:     assign start_trigger = (count_q == SecStartTriggerDelay[WidthCounter-1:0]) ? 1'b1 : 1'b0;
135: 
136:     always_ff @(posedge clk_i or negedge rst_ni) begin
137:       if (!rst_ni) begin
138:         count_q <= '0;
139:       end else begin
140:         count_q <= count_d;
141:       end
142:     end
143: 
144:   end else begin : gen_no_start_delay
145:     // Directly forward the manual start trigger input.
146:     assign start_trigger = start_i;
147:   end
148: 
149:   // Signals
150:   sp2v_e                         ctr_ready;
151:   sp2v_e      [NumSlicesCtr-1:0] ctr_we;
152:   sp2v_e                         cipher_in_ready;
153:   sp2v_e                         cipher_out_valid;
154:   sp2v_e                         cipher_crypt;
155:   sp2v_e                         cipher_dec_key_gen;
156:   logic                          mux_sel_err;
157:   logic                          mr_err;
158:   logic                          sp_enc_err;
159: 
160:   // Sparsified FSM signals. These are needed for connecting the individual bits of the Sp2V
161:   // signals to the single-rail FSMs.
162:   logic          [Sp2VWidth-1:0] sp_data_out_we;
163:   logic          [Sp2VWidth-1:0] sp_data_in_prev_we;
164:   logic          [Sp2VWidth-1:0] sp_ctr_incr;
165:   logic          [Sp2VWidth-1:0] sp_ctr_ready;
166:   logic          [Sp2VWidth-1:0] sp_cipher_in_valid;
167:   logic          [Sp2VWidth-1:0] sp_cipher_in_ready;
168:   logic          [Sp2VWidth-1:0] sp_cipher_out_valid;
169:   logic          [Sp2VWidth-1:0] sp_cipher_out_ready;
170:   logic          [Sp2VWidth-1:0] sp_in_cipher_crypt;
171:   logic          [Sp2VWidth-1:0] sp_out_cipher_crypt;
172:   logic          [Sp2VWidth-1:0] sp_in_cipher_dec_key_gen;
173:   logic          [Sp2VWidth-1:0] sp_out_cipher_dec_key_gen;
174: 
175:   // Multi-rail signals. These are outputs of the single-rail FSMs and need combining.
176:   logic          [Sp2VWidth-1:0] mr_ctrl_we;
177:   logic          [Sp2VWidth-1:0] mr_alert;
178:   logic          [Sp2VWidth-1:0] mr_data_in_we;
179:   dip_sel_e      [Sp2VWidth-1:0] mr_data_in_prev_sel;
180:   si_sel_e       [Sp2VWidth-1:0] mr_state_in_sel;
181:   add_si_sel_e   [Sp2VWidth-1:0] mr_add_state_in_sel;
182:   add_so_sel_e   [Sp2VWidth-1:0] mr_add_state_out_sel;
183:   logic          [Sp2VWidth-1:0] mr_cipher_prng_reseed;
184:   logic          [Sp2VWidth-1:0] mr_cipher_key_clear;
185:   logic          [Sp2VWidth-1:0] mr_cipher_data_out_clear;
186:   key_init_sel_e [Sp2VWidth-1:0] mr_key_init_sel;
187:   iv_sel_e       [Sp2VWidth-1:0] mr_iv_sel;
188:   logic          [Sp2VWidth-1:0] mr_prng_data_req;
189:   logic          [Sp2VWidth-1:0] mr_prng_reseed_req;
190:   logic          [Sp2VWidth-1:0] mr_start_we;
191:   logic          [Sp2VWidth-1:0] mr_key_iv_data_in_clear_we;
192:   logic          [Sp2VWidth-1:0] mr_data_out_clear_we;
193:   logic          [Sp2VWidth-1:0] mr_prng_reseed;
194:   logic          [Sp2VWidth-1:0] mr_prng_reseed_we;
195:   logic          [Sp2VWidth-1:0] mr_idle;
196:   logic          [Sp2VWidth-1:0] mr_idle_we;
197:   logic          [Sp2VWidth-1:0] mr_stall;
198:   logic          [Sp2VWidth-1:0] mr_stall_we;
199:   logic          [Sp2VWidth-1:0] mr_output_lost;
200:   logic          [Sp2VWidth-1:0] mr_output_lost_we;
201:   logic          [Sp2VWidth-1:0] mr_output_valid;
202:   logic          [Sp2VWidth-1:0] mr_output_valid_we;
203:   logic          [Sp2VWidth-1:0] mr_input_ready;
204:   logic          [Sp2VWidth-1:0] mr_input_ready_we;
205: 
206:   // To ease interfacing with the individual FSM rails, some signals need to be converted to packed
207:   // arrays.
208:   logic [Sp2VWidth-1:0][NumSharesKey-1:0][NumRegsKey-1:0]                int_key_init_we;
209:   logic                [NumSharesKey-1:0][NumRegsKey-1:0][Sp2VWidth-1:0] log_key_init_we;
210:   logic                [NumSharesKey-1:0][NumRegsKey-1:0]                int_key_init_qe;
211:   for (genvar s = 0; s < NumSharesKey; s++) begin : gen_conv_key_init_wqe_shares
212:     for (genvar i = 0; i < NumRegsKey; i++) begin : gen_conv_key_init_wqe_regs
213:       assign int_key_init_qe[s][i] = key_init_qe_i[s][i];
214:       for (genvar j = 0; j < Sp2VWidth; j++) begin : gen_conv_key_init_wqe_log
215:         assign log_key_init_we[s][i][j] = int_key_init_we[j][s][i];
216:       end
217:       assign key_init_we_o[s][i] = sp2v_e'(log_key_init_we[s][i]);
218:     end
219:   end
220:   logic [Sp2VWidth-1:0][NumSlicesCtr-1:0]                int_ctr_we;
221:   logic                [NumSlicesCtr-1:0][Sp2VWidth-1:0] log_ctr_we;
222:   logic [Sp2VWidth-1:0][NumSlicesCtr-1:0]                int_iv_we;
223:   logic                [NumSlicesCtr-1:0][Sp2VWidth-1:0] log_iv_we;
224:   for (genvar i = 0; i < NumSlicesCtr; i++) begin : gen_conv_ctr_iv_we_slices
225:     assign log_ctr_we[i] = {ctr_we[i]};
226:     for (genvar j = 0; j < Sp2VWidth; j++) begin : gen_conv_ctr_iv_we_log
227:       assign int_ctr_we[j][i] = log_ctr_we[i][j];
228:       assign log_iv_we[i][j]  = int_iv_we[j][i];
229:     end
230:     assign iv_we_o[i] = sp2v_e'(log_iv_we[i]);
231:   end
232: 
233:   /////////
234:   // FSM //
235:   /////////
236: 
237:   // Convert sp2v_e signals to sparsified inputs.
238:   assign sp_ctr_ready             = {ctr_ready};
239:   assign sp_cipher_in_ready       = {cipher_in_ready};
240:   assign sp_cipher_out_valid      = {cipher_out_valid};
241:   assign sp_in_cipher_crypt       = {cipher_crypt};
242:   assign sp_in_cipher_dec_key_gen = {cipher_dec_key_gen};
243: 
244:   // SEC_CM: MAIN.FSM.REDUN
245:   // For every bit in the Sp2V signals, one separate rail is instantiated. The inputs and outputs
246:   // of every rail are buffered to prevent aggressive synthesis optimizations.
247:   for (genvar i = 0; i < Sp2VWidth; i++) begin : gen_fsm
248:     if (SP2V_LOGIC_HIGH[i] == 1'b1) begin : gen_fsm_p
249:       aes_control_fsm_p #(
250:         .SecMasking ( SecMasking )
251:       ) u_aes_control_fsm_i (
252:         .clk_i                     ( clk_i                         ),
253:         .rst_ni                    ( rst_ni                        ),
254: 
255:         .ctrl_qe_i                 ( ctrl_qe_i                     ),
256:         .ctrl_we_o                 ( mr_ctrl_we[i]                 ), // AND-combine
257:         .ctrl_phase_i              ( ctrl_phase_i                  ),
258:         .ctrl_err_storage_i        ( ctrl_err_storage_i            ),
259:         .op_i                      ( op_i                          ),
260:         .mode_i                    ( mode_i                        ),
261:         .cipher_op_i               ( cipher_op_i                   ),
262:         .sideload_i                ( sideload_i                    ),
263:         .prng_reseed_rate_i        ( prng_reseed_rate_i            ),
264:         .manual_operation_i        ( manual_operation_i            ),
265:         .key_touch_forces_reseed_i ( key_touch_forces_reseed_i     ),
266:         .start_i                   ( start_trigger                 ),
267:         .key_iv_data_in_clear_i    ( key_iv_data_in_clear_i        ),
268:         .data_out_clear_i          ( data_out_clear_i              ),
269:         .prng_reseed_i             ( prng_reseed_i                 ),
270:         .mux_sel_err_i             ( mux_sel_err                   ),
271:         .sp_enc_err_i              ( sp_enc_err                    ),
272:         .lc_escalate_en_i          ( lc_escalate_en_i              ),
273:         .alert_fatal_i             ( alert_fatal_i                 ),
274:         .alert_o                   ( mr_alert[i]                   ), // OR-combine
275: 
276:         .key_sideload_valid_i      ( key_sideload_valid_i          ),
277:         .key_init_qe_i             ( int_key_init_qe               ),
278:         .iv_qe_i                   ( iv_qe_i                       ),
279:         .data_in_qe_i              ( data_in_qe_i                  ),
280:         .data_out_re_i             ( data_out_re_i                 ),
281:         .data_in_we_o              ( mr_data_in_we[i]              ), // AND-combine
282:         .data_out_we_o             ( sp_data_out_we[i]             ), // Sparsified
283: 
284:         .data_in_prev_sel_o        ( mr_data_in_prev_sel[i]        ), // OR-combine
285:         .data_in_prev_we_o         ( sp_data_in_prev_we[i]         ), // Sparsified
286: 
287:         .state_in_sel_o            ( mr_state_in_sel[i]            ), // OR-combine
288:         .add_state_in_sel_o        ( mr_add_state_in_sel[i]        ), // OR-combine
289:         .add_state_out_sel_o       ( mr_add_state_out_sel[i]       ), // OR-combine
290: 
291:         .ctr_incr_o                ( sp_ctr_incr[i]                ), // Sparsified
292:         .ctr_ready_i               ( sp_ctr_ready[i]               ), // Sparsified
293:         .ctr_we_i                  ( int_ctr_we[i]                 ), // Sparsified
294: 
295:         .cipher_in_valid_o         ( sp_cipher_in_valid[i]         ), // Sparsified
296:         .cipher_in_ready_i         ( sp_cipher_in_ready[i]         ), // Sparsified
297:         .cipher_out_valid_i        ( sp_cipher_out_valid[i]        ), // Sparsified
298:         .cipher_out_ready_o        ( sp_cipher_out_ready[i]        ), // Sparsified
299:         .cipher_crypt_o            ( sp_out_cipher_crypt[i]        ), // Sparsified
300:         .cipher_crypt_i            ( sp_in_cipher_crypt[i]         ), // Sparsified
301:         .cipher_dec_key_gen_o      ( sp_out_cipher_dec_key_gen[i]  ), // Sparsified
302:         .cipher_dec_key_gen_i      ( sp_in_cipher_dec_key_gen[i]   ), // Sparsified
303:         .cipher_prng_reseed_o      ( mr_cipher_prng_reseed[i]      ), // OR-combine
304:         .cipher_prng_reseed_i      ( cipher_prng_reseed_i          ),
305:         .cipher_key_clear_o        ( mr_cipher_key_clear[i]        ), // OR-combine
306:         .cipher_key_clear_i        ( cipher_key_clear_i            ),
307:         .cipher_data_out_clear_o   ( mr_cipher_data_out_clear[i]   ), // OR-combine
308:         .cipher_data_out_clear_i   ( cipher_data_out_clear_i       ),
309: 
310:         .key_init_sel_o            ( mr_key_init_sel[i]            ), // OR-combine
311:         .key_init_we_o             ( int_key_init_we[i]            ), // Sparsified
312: 
313:         .iv_sel_o                  ( mr_iv_sel[i]                  ), // OR-combine
314:         .iv_we_o                   ( int_iv_we[i]                  ), // Sparsified
315: 
316:         .prng_data_req_o           ( mr_prng_data_req[i]           ), // OR-combine
317:         .prng_data_ack_i           ( prng_data_ack_i               ),
318:         .prng_reseed_req_o         ( mr_prng_reseed_req[i]         ), // OR-combine
319:         .prng_reseed_ack_i         ( prng_reseed_ack_i             ),
320: 
321:         .start_we_o                ( mr_start_we[i]                ), // OR-combine
322:         .key_iv_data_in_clear_we_o ( mr_key_iv_data_in_clear_we[i] ), // AND-combine
323:         .data_out_clear_we_o       ( mr_data_out_clear_we[i]       ), // AND-combine
324:         .prng_reseed_o             ( mr_prng_reseed[i]             ), // OR-combine
325:         .prng_reseed_we_o          ( mr_prng_reseed_we[i]          ), // OR-combine
326: 
327:         .idle_o                    ( mr_idle[i]                    ), // AND-combine
328:         .idle_we_o                 ( mr_idle_we[i]                 ), // AND-combine
329:         .stall_o                   ( mr_stall[i]                   ), // AND-combine
330:         .stall_we_o                ( mr_stall_we[i]                ), // AND-combine
331:         .output_lost_i             ( output_lost_i                 ), // AND-combine
332:         .output_lost_o             ( mr_output_lost[i]             ), // AND-combine
333:         .output_lost_we_o          ( mr_output_lost_we[i]          ), // AND-combine
334:         .output_valid_o            ( mr_output_valid[i]            ), // AND-combine
335:         .output_valid_we_o         ( mr_output_valid_we[i]         ), // AND-combine
336:         .input_ready_o             ( mr_input_ready[i]             ), // AND-combine
337:         .input_ready_we_o          ( mr_input_ready_we[i]          )  // AND-combine
338:       );
339:     end else begin : gen_fsm_n
340:       aes_control_fsm_n #(
341:         .SecMasking ( SecMasking )
342:       ) u_aes_control_fsm_i (
343:         .clk_i                     ( clk_i                         ),
344:         .rst_ni                    ( rst_ni                        ),
345: 
346:         .ctrl_qe_i                 ( ctrl_qe_i                     ),
347:         .ctrl_we_o                 ( mr_ctrl_we[i]                 ), // AND-combine
348:         .ctrl_phase_i              ( ctrl_phase_i                  ),
349:         .ctrl_err_storage_i        ( ctrl_err_storage_i            ),
350:         .op_i                      ( op_i                          ),
351:         .mode_i                    ( mode_i                        ),
352:         .cipher_op_i               ( cipher_op_i                   ),
353:         .sideload_i                ( sideload_i                    ),
354:         .prng_reseed_rate_i        ( prng_reseed_rate_i            ),
355:         .manual_operation_i        ( manual_operation_i            ),
356:         .key_touch_forces_reseed_i ( key_touch_forces_reseed_i     ),
357:         .start_i                   ( start_trigger                 ),
358:         .key_iv_data_in_clear_i    ( key_iv_data_in_clear_i        ),
359:         .data_out_clear_i          ( data_out_clear_i              ),
360:         .prng_reseed_i             ( prng_reseed_i                 ),
361:         .mux_sel_err_i             ( mux_sel_err                   ),
362:         .sp_enc_err_i              ( sp_enc_err                    ),
363:         .lc_escalate_en_i          ( lc_escalate_en_i              ),
364:         .alert_fatal_i             ( alert_fatal_i                 ),
365:         .alert_o                   ( mr_alert[i]                   ), // OR-combine
366: 
367:         .key_sideload_valid_i      ( key_sideload_valid_i          ),
368:         .key_init_qe_i             ( int_key_init_qe               ),
369:         .iv_qe_i                   ( iv_qe_i                       ),
370:         .data_in_qe_i              ( data_in_qe_i                  ),
371:         .data_out_re_i             ( data_out_re_i                 ),
372:         .data_in_we_o              ( mr_data_in_we[i]              ), // AND-combine
373:         .data_out_we_no            ( sp_data_out_we[i]             ), // Sparsified
374: 
375:         .data_in_prev_sel_o        ( mr_data_in_prev_sel[i]        ), // OR-combine
376:         .data_in_prev_we_no        ( sp_data_in_prev_we[i]         ), // Sparsified
377: 
378:         .state_in_sel_o            ( mr_state_in_sel[i]            ), // OR-combine
379:         .add_state_in_sel_o        ( mr_add_state_in_sel[i]        ), // OR-combine
380:         .add_state_out_sel_o       ( mr_add_state_out_sel[i]       ), // OR-combine
381: 
382:         .ctr_incr_no               ( sp_ctr_incr[i]                ), // Sparsified
383:         .ctr_ready_ni              ( sp_ctr_ready[i]               ), // Sparsified
384:         .ctr_we_ni                 ( int_ctr_we[i]                 ), // Sparsified
385: 
386:         .cipher_in_valid_no        ( sp_cipher_in_valid[i]         ), // Sparsified
387:         .cipher_in_ready_ni        ( sp_cipher_in_ready[i]         ), // Sparsified
388:         .cipher_out_valid_ni       ( sp_cipher_out_valid[i]        ), // Sparsified
389:         .cipher_out_ready_no       ( sp_cipher_out_ready[i]        ), // Sparsified
390:         .cipher_crypt_no           ( sp_out_cipher_crypt[i]        ), // Sparsified
391:         .cipher_crypt_ni           ( sp_in_cipher_crypt[i]         ), // Sparsified
392:         .cipher_dec_key_gen_no     ( sp_out_cipher_dec_key_gen[i]  ), // Sparsified
393:         .cipher_dec_key_gen_ni     ( sp_in_cipher_dec_key_gen[i]   ), // Sparsified
394:         .cipher_prng_reseed_o      ( mr_cipher_prng_reseed[i]      ), // OR-combine
395:         .cipher_prng_reseed_i      ( cipher_prng_reseed_i          ),
396:         .cipher_key_clear_o        ( mr_cipher_key_clear[i]        ), // OR-combine
397:         .cipher_key_clear_i        ( cipher_key_clear_i            ),
398:         .cipher_data_out_clear_o   ( mr_cipher_data_out_clear[i]   ), // OR-combine
399:         .cipher_data_out_clear_i   ( cipher_data_out_clear_i       ),
400: 
401:         .key_init_sel_o            ( mr_key_init_sel[i]            ), // OR-combine
402:         .key_init_we_no            ( int_key_init_we[i]            ), // Sparsified
403: 
404:         .iv_sel_o                  ( mr_iv_sel[i]                  ), // OR-combine
405:         .iv_we_no                  ( int_iv_we[i]                  ), // Sparsified
406: 
407:         .prng_data_req_o           ( mr_prng_data_req[i]           ), // OR-combine
408:         .prng_data_ack_i           ( prng_data_ack_i               ),
409:         .prng_reseed_req_o         ( mr_prng_reseed_req[i]         ), // OR-combine
410:         .prng_reseed_ack_i         ( prng_reseed_ack_i             ),
411: 
412:         .start_we_o                ( mr_start_we[i]                ), // OR-combine
413:         .key_iv_data_in_clear_we_o ( mr_key_iv_data_in_clear_we[i] ), // AND-combine
414:         .data_out_clear_we_o       ( mr_data_out_clear_we[i]       ), // AND-combine
415:         .prng_reseed_o             ( mr_prng_reseed[i]             ), // OR-combine
416:         .prng_reseed_we_o          ( mr_prng_reseed_we[i]          ), // OR-combine
417: 
418:         .idle_o                    ( mr_idle[i]                    ), // AND-combine
419:         .idle_we_o                 ( mr_idle_we[i]                 ), // AND-combine
420:         .stall_o                   ( mr_stall[i]                   ), // AND-combine
421:         .stall_we_o                ( mr_stall_we[i]                ), // AND-combine
422:         .output_lost_i             ( output_lost_i                 ), // AND-combine
423:         .output_lost_o             ( mr_output_lost[i]             ), // AND-combine
424:         .output_lost_we_o          ( mr_output_lost_we[i]          ), // AND-combine
425:         .output_valid_o            ( mr_output_valid[i]            ), // AND-combine
426:         .output_valid_we_o         ( mr_output_valid_we[i]         ), // AND-combine
427:         .input_ready_o             ( mr_input_ready[i]             ), // AND-combine
428:         .input_ready_we_o          ( mr_input_ready_we[i]          )  // AND-combine
429:       );
430:     end
431:   end
432: 
433:   // Convert sparsified outputs to sp2v_e type.
434:   assign data_out_we_o        = sp2v_e'(sp_data_out_we);
435:   assign data_in_prev_we_o    = sp2v_e'(sp_data_in_prev_we);
436:   assign ctr_incr_o           = sp2v_e'(sp_ctr_incr);
437:   assign cipher_in_valid_o    = sp2v_e'(sp_cipher_in_valid);
438:   assign cipher_out_ready_o   = sp2v_e'(sp_cipher_out_ready);
439:   assign cipher_crypt_o       = sp2v_e'(sp_out_cipher_crypt);
440:   assign cipher_dec_key_gen_o = sp2v_e'(sp_out_cipher_dec_key_gen);
441: 
442:   // Combine single-bit FSM outputs.
443:   // OR: One bit is sufficient to drive the corresponding output bit high.
444:   assign alert_o                   = |mr_alert;
445:   assign cipher_prng_reseed_o      = |mr_cipher_prng_reseed;
446:   assign cipher_key_clear_o        = |mr_cipher_key_clear;
447:   assign cipher_data_out_clear_o   = |mr_cipher_data_out_clear;
448:   assign prng_data_req_o           = |mr_prng_data_req;
449:   assign prng_reseed_req_o         = |mr_prng_reseed_req;
450:   assign start_we_o                = |mr_start_we;
451:   assign prng_reseed_o             = |mr_prng_reseed;
452:   assign prng_reseed_we_o          = |mr_prng_reseed_we;
453: 
454:   // AND: Only if all bits are high, the corresponding action should be triggered.
455:   assign ctrl_we_o                 = &mr_ctrl_we;
456:   assign data_in_we_o              = &mr_data_in_we;
457:   assign key_iv_data_in_clear_we_o = &mr_key_iv_data_in_clear_we;
458:   assign data_out_clear_we_o       = &mr_data_out_clear_we;
459:   assign idle_o                    = &mr_idle;
460:   assign idle_we_o                 = &mr_idle_we;
461:   assign stall_o                   = &mr_stall;
462:   assign stall_we_o                = &mr_stall_we;
463:   assign output_lost_o             = &mr_output_lost;
464:   assign output_lost_we_o          = &mr_output_lost_we;
465:   assign output_valid_o            = &mr_output_valid;
466:   assign output_valid_we_o         = &mr_output_valid_we;
467:   assign input_ready_o             = &mr_input_ready;
468:   assign input_ready_we_o          = &mr_input_ready_we;
469: 
470:   // Combine multi-bit, sparse FSM outputs. We simply OR them together. If the FSMs don't provide
471:   // the same outputs, two cases are possible:
472:   // - An invalid encoding results: A downstream checker will fire, see mux_sel_err_i.
473:   // - A valid encoding results: The outputs are compared below to cover this case, see mr_err;
474:   always_comb begin : combine_sparse_signals
475:     data_in_prev_sel_o  = dip_sel_e'({DIPSelWidth{1'b0}});
476:     state_in_sel_o      = si_sel_e'({SISelWidth{1'b0}});
477:     add_state_in_sel_o  = add_si_sel_e'({AddSISelWidth{1'b0}});
478:     add_state_out_sel_o = add_so_sel_e'({AddSOSelWidth{1'b0}});
479:     key_init_sel_o      = key_init_sel_e'({KeyInitSelWidth{1'b0}});
480:     iv_sel_o            = iv_sel_e'({IVSelWidth{1'b0}});
481:     mr_err              = 1'b0;
482: 
483:     for (int i = 0; i < Sp2VWidth; i++) begin
484:       data_in_prev_sel_o  = dip_sel_e'({data_in_prev_sel_o}     | {mr_data_in_prev_sel[i]});
485:       state_in_sel_o      = si_sel_e'({state_in_sel_o}          | {mr_state_in_sel[i]});
486:       add_state_in_sel_o  = add_si_sel_e'({add_state_in_sel_o}  | {mr_add_state_in_sel[i]});
487:       add_state_out_sel_o = add_so_sel_e'({add_state_out_sel_o} | {mr_add_state_out_sel[i]});
488:       key_init_sel_o      = key_init_sel_e'({key_init_sel_o}    | {mr_key_init_sel[i]});
489:       iv_sel_o            = iv_sel_e'({iv_sel_o}                | {mr_iv_sel[i]});
490:     end
491: 
492:     for (int i = 0; i < Sp2VWidth; i++) begin
493:       if (data_in_prev_sel_o  != mr_data_in_prev_sel[i]  ||
494:           state_in_sel_o      != mr_state_in_sel[i]      ||
495:           add_state_in_sel_o  != mr_add_state_in_sel[i]  ||
496:           add_state_out_sel_o != mr_add_state_out_sel[i] ||
497:           key_init_sel_o      != mr_key_init_sel[i]      ||
498:           iv_sel_o            != mr_iv_sel[i]) begin
499:         mr_err = 1'b1;
500:       end
501:     end
502:   end
503: 
504:   // Collect errors in mux selector signals.
505:   assign mux_sel_err = mux_sel_err_i | mr_err;
506: 
507:   //////////////////////////////
508:   // Sparsely Encoded Signals //
509:   //////////////////////////////
510: 
511:   // SEC_CM: CTRL.SPARSE
512:   // We use sparse encodings for various critical signals and must ensure that:
513:   // 1. The synthesis tool doesn't optimize away the sparse encoding.
514:   // 2. The sparsely encoded signal is always valid. More precisely, an alert or SVA is triggered
515:   //    if a sparse signal takes on an invalid value.
516:   // 3. The alert signal remains asserted until reset even if the sparse signal becomes valid again
517:   //    This is achieved by driving the control FSM into the terminal error state whenever any
518:   //    sparsely encoded signal becomes invalid.
519:   //
520:   // If any sparsely encoded signal becomes invalid, the controller further immediately de-asserts
521:   // data_out_we_o and other write-enable signals to prevent any data from being released.
522: 
523:   // We use vectors of sparsely encoded signals to reduce code duplication.
524:   localparam int unsigned NumSp2VSig = 5 + NumSlicesCtr;
525:   sp2v_e [NumSp2VSig-1:0]                sp2v_sig;
526:   sp2v_e [NumSp2VSig-1:0]                sp2v_sig_chk;
527:   logic  [NumSp2VSig-1:0][Sp2VWidth-1:0] sp2v_sig_chk_raw;
528:   logic  [NumSp2VSig-1:0]                sp2v_sig_err;
529: 
530:   assign sp2v_sig[0] = cipher_in_ready_i;
531:   assign sp2v_sig[1] = cipher_out_valid_i;
532:   assign sp2v_sig[2] = cipher_crypt_i;
533:   assign sp2v_sig[3] = cipher_dec_key_gen_i;
534:   assign sp2v_sig[4] = ctr_ready_i;
535:   for (genvar i = 0; i < NumSlicesCtr; i++) begin : gen_use_ctr_we_i
536:     assign sp2v_sig[5+i] = ctr_we_i[i];
537:   end
538: 
539:   // All signals inside sp2v_sig are driven and consumed by multi-rail FSMs.
540:   localparam bit [NumSp2VSig-1:0] Sp2VEnSecBuf = '0;
541: 
542:   // Individually check sparsely encoded signals.
543:   for (genvar i = 0; i < NumSp2VSig; i++) begin : gen_sel_buf_chk
544:     aes_sel_buf_chk #(
545:       .Num      ( Sp2VNum         ),
546:       .Width    ( Sp2VWidth       ),
547:       .EnSecBuf ( Sp2VEnSecBuf[i] )
548:     ) u_aes_sp2v_sig_buf_chk_i (
549:       .clk_i  ( clk_i               ),
550:       .rst_ni ( rst_ni              ),
551:       .sel_i  ( sp2v_sig[i]         ),
552:       .sel_o  ( sp2v_sig_chk_raw[i] ),
553:       .err_o  ( sp2v_sig_err[i]     )
554:     );
555:     assign sp2v_sig_chk[i] = sp2v_e'(sp2v_sig_chk_raw[i]);
556:   end
557: 
558:   assign cipher_in_ready    = sp2v_sig_chk[0];
559:   assign cipher_out_valid   = sp2v_sig_chk[1];
560:   assign cipher_crypt       = sp2v_sig_chk[2];
561:   assign cipher_dec_key_gen = sp2v_sig_chk[3];
562:   assign ctr_ready          = sp2v_sig_chk[4];
563:   for (genvar i = 0; i < NumSlicesCtr; i++) begin : gen_ctr_we
564:     assign ctr_we[i]        = sp2v_sig_chk[5+i];
565:   end
566: 
567:   // Collect encoding errors.
568:   // We instantiate the checker modules as close as possible to where the sparsely encoded signals
569:   // are used. Here, we collect also encoding errors detected in other places of the core.
570:   assign sp_enc_err = |sp2v_sig_err | sp_enc_err_i;
571: 
572:   //////////////////////
573:   // Trigger Register //
574:   //////////////////////
575:   // Most triggers are only ever cleared by control.
576:   assign start_o                   = 1'b0;
577:   assign key_iv_data_in_clear_o    = 1'b0;
578:   assign data_out_clear_o          = 1'b0;
579: 
580: endmodule

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_nxQsGLYFXlAx6uZ92aTz2O5v)
 Call ID: call_nxQsGLYFXlAx6uZ92aTz2O5v
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes/rtl/aes_reg_status.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // AES reg status
6: //
7: // This module tracks the collective status of multiple registers.
8: 
9: module aes_reg_status #(
10:   parameter int Width = 1
11: ) (
12:   input  logic             clk_i,
13:   input  logic             rst_ni,
14: 
15:   input  logic [Width-1:0] we_i,
16:   input  logic             use_i,
17:   input  logic             clear_i,
18:   input  logic             arm_i,
19:   output logic             new_o,
20:   output logic             new_pulse_o,
21:   output logic             clean_o
22: );
23: 
24:   logic [Width-1:0] we_d, we_q;
25:   logic             armed_d, armed_q;
26:   logic             all_written;
27:   logic             none_written;
28:   logic             new_d, new_q;
29:   logic             clean_d, clean_q;
30: 
31:   // Collect write operations. Upon clear or use, we start over. If armed, the next write will
32:   // restart the tracking.
33:   assign we_d    = (clear_i || use_i) ? '0   :
34:                    (armed_q && |we_i) ? we_i : (we_q | we_i);
35:   assign armed_d = (clear_i || use_i) ? 1'b0 :
36:                    (armed_q && |we_i) ? 1'b0 : armed_q | arm_i;
37: 
38:   always_ff @(posedge clk_i or negedge rst_ni) begin : reg_ops
39:     if (!rst_ni) begin
40:       we_q    <= '0;
41:       armed_q <= 1'b0;
42:     end else begin
43:       we_q    <= we_d;
44:       armed_q <= armed_d;
45:     end
46:   end
47: 
48:   // Status tracking
49:   assign all_written  =  &we_d;
50:   assign none_written = ~|we_d;
51: 
52:   // We have a complete new value if all registers have been written at least once.
53:   assign new_d   = (clear_i || use_i) ? 1'b0 : all_written;
54: 
55:   // We have a clean value, if either:
56:   // - all registers have been written at least once, or
57:   // - no registers have been written but the value was clean previsously.
58:   // A value is NOT clean, if either:
59:   // - we get a clear or reset, or
60:   // - some but not all registers have been written.
61:   assign clean_d =  clear_i      ? 1'b0    :
62:                     all_written  ? 1'b1    :
63:                     none_written ? clean_q : 1'b0;
64: 
65:   always_ff @(posedge clk_i or negedge rst_ni) begin : reg_status
66:     if (!rst_ni) begin
67:       new_q   <= 1'b0;
68:       clean_q <= 1'b0;
69:     end else begin
70:       new_q   <= new_d;
71:       clean_q <= clean_d;
72:     end
73:   end
74: 
75:   assign new_o       = new_q;
76:   assign new_pulse_o = new_d & ~new_q;
77:   assign clean_o     = clean_q;
78: 
79: endmodule

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_Meka7aIiLOjjMsvRKAtRheWH)
 Call ID: call_Meka7aIiLOjjMsvRKAtRheWH
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes/rtl/aes_core.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // AES core implementation
6: 
7: `include "prim_assert.sv"
8: 
9: module aes_core
10:   import aes_pkg::*;
11:   import aes_reg_pkg::*;
12: #(
13:   parameter bit          AES192Enable         = 1,
14:   parameter bit          SecMasking           = 1,
15:   parameter sbox_impl_e  SecSBoxImpl          = SBoxImplDom,
16:   parameter int unsigned SecStartTriggerDelay = 0,
17:   parameter bit          SecAllowForcingMasks = 0,
18:   parameter bit          SecSkipPRNGReseeding = 0,
19:   parameter int unsigned EntropyWidth         = edn_pkg::ENDPOINT_BUS_WIDTH,
20: 
21:   localparam int         NumShares            = SecMasking ? 2 : 1, // derived parameter
22: 
23:   parameter clearing_lfsr_seed_t RndCnstClearingLfsrSeed  = RndCnstClearingLfsrSeedDefault,
24:   parameter clearing_lfsr_perm_t RndCnstClearingLfsrPerm  = RndCnstClearingLfsrPermDefault,
25:   parameter clearing_lfsr_perm_t RndCnstClearingSharePerm = RndCnstClearingSharePermDefault,
26:   parameter masking_lfsr_seed_t  RndCnstMaskingLfsrSeed   = RndCnstMaskingLfsrSeedDefault,
27:   parameter masking_lfsr_perm_t  RndCnstMaskingLfsrPerm   = RndCnstMaskingLfsrPermDefault
28: ) (
29:   input  logic                        clk_i,
30:   input  logic                        rst_ni,
31:   input  logic                        rst_shadowed_ni,
32: 
33:   // Entropy request interfaces for clearing and masking PRNGs
34:   output logic                        entropy_clearing_req_o,
35:   input  logic                        entropy_clearing_ack_i,
36:   input  logic     [EntropyWidth-1:0] entropy_clearing_i,
37:   output logic                        entropy_masking_req_o,
38:   input  logic                        entropy_masking_ack_i,
39:   input  logic     [EntropyWidth-1:0] entropy_masking_i,
40: 
41:   // Key manager (keymgr) key sideload interface
42:   input  keymgr_pkg::hw_key_req_t     keymgr_key_i,
43: 
44:   // Life cycle
45:   input  lc_ctrl_pkg::lc_tx_t         lc_escalate_en_i,
46: 
47:   // Alerts
48:   input  logic                        shadowed_storage_err_i,
49:   input  logic                        shadowed_update_err_i,
50:   input  logic                        intg_err_alert_i,
51:   output logic                        alert_recov_o,
52:   output logic                        alert_fatal_o,
53: 
54:   // Bus Interface
55:   input  aes_reg2hw_t                 reg2hw,
56:   output aes_hw2reg_t                 hw2reg
57: );
58: 
59:   // Signals
60:   logic                                       ctrl_qe;
61:   logic                                       ctrl_we;
62:   logic                                       ctrl_phase;
63:   aes_op_e                                    aes_op_q;
64:   aes_mode_e                                  aes_mode_q;
65:   ciph_op_e                                   cipher_op;
66:   ciph_op_e                                   cipher_op_buf;
67:   key_len_e                                   key_len_q;
68:   logic                                       sideload_q;
69:   prs_rate_e                                  prng_reseed_rate_q;
70:   logic                                       manual_operation_q;
71:   logic                                       ctrl_reg_err_update;
72:   logic                                       ctrl_reg_err_storage;
73:   logic                                       ctrl_err_update;
74:   logic                                       ctrl_err_storage;
75:   logic                                       ctrl_err_storage_d;
76:   logic                                       ctrl_err_storage_q;
77:   logic                                       ctrl_alert;
78:   logic                                       key_touch_forces_reseed;
79:   logic                                       force_masks;
80:   logic                                       mux_sel_err;
81:   logic                                       sp_enc_err_d, sp_enc_err_q;
82:   logic                                       clear_on_fatal;
83: 
84:   logic                       [3:0][3:0][7:0] state_in;
85:   logic                      [SISelWidth-1:0] state_in_sel_raw;
86:   si_sel_e                                    state_in_sel_ctrl;
87:   si_sel_e                                    state_in_sel;
88:   logic                                       state_in_sel_err;
89:   logic                       [3:0][3:0][7:0] add_state_in;
90:   logic                   [AddSISelWidth-1:0] add_state_in_sel_raw;
91:   add_si_sel_e                                add_state_in_sel_ctrl;
92:   add_si_sel_e                                add_state_in_sel;
93:   logic                                       add_state_in_sel_err;
94: 
95:   logic                       [3:0][3:0][7:0] state_mask;
96:   logic                       [3:0][3:0][7:0] state_init [NumShares];
97:   logic                       [3:0][3:0][7:0] state_done [NumShares];
98:   logic                       [3:0][3:0][7:0] state_out;
99: 
100:   logic                [NumRegsKey-1:0][31:0] key_init [NumSharesKey];
101:   logic                [NumRegsKey-1:0]       key_init_qe [NumSharesKey];
102:   logic                [NumRegsKey-1:0]       key_init_qe_buf [NumSharesKey];
103:   logic                [NumRegsKey-1:0][31:0] key_init_d [NumSharesKey];
104:   logic                [NumRegsKey-1:0][31:0] key_init_q [NumSharesKey];
105:   logic                [NumRegsKey-1:0][31:0] key_init_cipher [NumShares];
106:   sp2v_e               [NumRegsKey-1:0]       key_init_we_ctrl [NumSharesKey];
107:   sp2v_e               [NumRegsKey-1:0]       key_init_we [NumSharesKey];
108:   logic                 [KeyInitSelWidth-1:0] key_init_sel_raw;
109:   key_init_sel_e                              key_init_sel_ctrl;
110:   key_init_sel_e                              key_init_sel;
111:   logic                                       key_init_sel_err;
112:   logic                [NumRegsKey-1:0][31:0] key_sideload [NumSharesKey];
113: 
114:   logic                 [NumRegsIv-1:0][31:0] iv;
115:   logic                 [NumRegsIv-1:0]       iv_qe;
116:   logic                 [NumRegsIv-1:0]       iv_qe_buf;
117:   logic  [NumSlicesCtr-1:0][SliceSizeCtr-1:0] iv_d;
118:   logic  [NumSlicesCtr-1:0][SliceSizeCtr-1:0] iv_q;
119:   sp2v_e [NumSlicesCtr-1:0]                   iv_we_ctrl;
120:   sp2v_e [NumSlicesCtr-1:0]                   iv_we;
121:   logic                      [IVSelWidth-1:0] iv_sel_raw;
122:   iv_sel_e                                    iv_sel_ctrl;
123:   iv_sel_e                                    iv_sel;
124:   logic                                       iv_sel_err;
125: 
126:   logic  [NumSlicesCtr-1:0][SliceSizeCtr-1:0] ctr;
127:   sp2v_e [NumSlicesCtr-1:0]                   ctr_we;
128:   sp2v_e                                      ctr_incr;
129:   sp2v_e                                      ctr_ready;
130:   logic                                       ctr_alert;
131: 
132:   logic               [NumRegsData-1:0][31:0] data_in_prev_d;
133:   logic               [NumRegsData-1:0][31:0] data_in_prev_q;
134:   sp2v_e                                      data_in_prev_we_ctrl;
135:   sp2v_e                                      data_in_prev_we;
136:   logic                     [DIPSelWidth-1:0] data_in_prev_sel_raw;
137:   dip_sel_e                                   data_in_prev_sel_ctrl;
138:   dip_sel_e                                   data_in_prev_sel;
139:   logic                                       data_in_prev_sel_err;
140: 
141:   logic               [NumRegsData-1:0][31:0] data_in;
142:   logic               [NumRegsData-1:0]       data_in_qe;
143:   logic               [NumRegsData-1:0]       data_in_qe_buf;
144:   logic                                       data_in_we;
145: 
146:   logic                       [3:0][3:0][7:0] add_state_out;
147:   logic                   [AddSOSelWidth-1:0] add_state_out_sel_raw;
148:   add_so_sel_e                                add_state_out_sel_ctrl;
149:   add_so_sel_e                                add_state_out_sel;
150:   logic                                       add_state_out_sel_err;
151: 
152:   logic               [NumRegsData-1:0][31:0] data_out_d;
153:   logic               [NumRegsData-1:0][31:0] data_out_q;
154:   sp2v_e                                      data_out_we_ctrl;
155:   sp2v_e                                      data_out_we;
156:   logic               [NumRegsData-1:0]       data_out_re;
157:   logic               [NumRegsData-1:0]       data_out_re_buf;
158: 
159:   sp2v_e                                      cipher_in_valid;
160:   sp2v_e                                      cipher_in_ready;
161:   sp2v_e                                      cipher_out_valid;
162:   sp2v_e                                      cipher_out_ready;
163:   sp2v_e                                      cipher_crypt;
164:   sp2v_e                                      cipher_crypt_busy;
165:   sp2v_e                                      cipher_dec_key_gen;
166:   sp2v_e                                      cipher_dec_key_gen_busy;
167:   logic                                       cipher_prng_reseed;
168:   logic                                       cipher_prng_reseed_busy;
169:   logic                                       cipher_key_clear;
170:   logic                                       cipher_key_clear_busy;
171:   logic                                       cipher_data_out_clear;
172:   logic                                       cipher_data_out_clear_busy;
173:   logic                                       cipher_alert;
174: 
175:   // Pseudo-random data for clearing purposes
176:   logic                [WidthPRDClearing-1:0] prd_clearing [NumSharesKey];
177:   logic                                       prd_clearing_upd_req;
178:   logic                                       prd_clearing_upd_ack;
179:   logic                                       prd_clearing_rsd_req;
180:   logic                                       prd_clearing_rsd_ack;
181:   logic                               [127:0] prd_clearing_128 [NumShares];
182:   logic                               [255:0] prd_clearing_256 [NumShares];
183:   logic                           [3:0][31:0] prd_clearing_data;
184:   logic                               [255:0] prd_clearing_key_init [NumSharesKey];
185:   logic                       [3:0][3:0][7:0] prd_clearing_state [NumShares];
186:   logic                           [7:0][31:0] prd_clearing_key [NumShares];
187: 
188:   // Unused signals
189:   logic               [NumRegsData-1:0][31:0] unused_data_out_q;
190: 
191:   // The clearing PRNG provides pseudo-random data for register clearing purposes.
192:   aes_prng_clearing #(
193:     .Width                ( WidthPRDClearing         ),
194:     .EntropyWidth         ( EntropyWidth             ),
195:     .SecSkipPRNGReseeding ( SecSkipPRNGReseeding     ),
196:     .RndCnstLfsrSeed      ( RndCnstClearingLfsrSeed  ),
197:     .RndCnstLfsrPerm      ( RndCnstClearingLfsrPerm  ),
198:     .RndCnstSharePerm     ( RndCnstClearingSharePerm )
199:   ) u_aes_prng_clearing (
200:     .clk_i         ( clk_i                  ),
201:     .rst_ni        ( rst_ni                 ),
202: 
203:     .data_req_i    ( prd_clearing_upd_req   ),
204:     .data_ack_o    ( prd_clearing_upd_ack   ),
205:     .data_o        ( prd_clearing           ),
206:     .reseed_req_i  ( prd_clearing_rsd_req   ),
207:     .reseed_ack_o  ( prd_clearing_rsd_ack   ),
208: 
209:     .entropy_req_o ( entropy_clearing_req_o ),
210:     .entropy_ack_i ( entropy_clearing_ack_i ),
211:     .entropy_i     ( entropy_clearing_i     )
212:   );
213: 
214:   // Generate clearing signals of appropriate widths.
215:   // Different shares need to be cleared with different pseudo-random data.
216:   for (genvar s = 0; s < NumShares; s++) begin : gen_prd_clearing_shares
217:     for (genvar c = 0; c < NumChunksPRDClearing128; c++) begin : gen_prd_clearing_128
218:       assign prd_clearing_128[s][c * WidthPRDClearing +: WidthPRDClearing] = prd_clearing[s];
219:     end
220:     for (genvar c = 0; c < NumChunksPRDClearing256; c++) begin : gen_prd_clearing_256
221:       assign prd_clearing_256[s][c * WidthPRDClearing +: WidthPRDClearing] = prd_clearing[s];
222:     end
223:   end
224:   // The data registers are always unmasked.
225:   assign prd_clearing_data = prd_clearing_128[0];
226:   // The initial key is always provided in two shares. The two shares of the initial key register
227:   // need to be cleared with different pseudo-random data.
228:   for (genvar s = 0; s < NumSharesKey; s++) begin : gen_prd_clearing_key_init_shares
229:     for (genvar c = 0; c < NumChunksPRDClearing256; c++) begin : gen_prd_clearing_key_init
230:       assign prd_clearing_key_init[s][c * WidthPRDClearing +: WidthPRDClearing] = prd_clearing[s];
231:     end
232:   end
233:   // The cipher core uses multiple packed dimensions internally but the number of bits remain the
234:   // same. Since some tools fail to peform the `conversion` on input ports, we do it here.
235:   assign prd_clearing_state = prd_clearing_128;
236:   assign prd_clearing_key   = prd_clearing_256;
237: 
238:   ////////////
239:   // Inputs //
240:   ////////////
241: 
242:   always_comb begin : key_init_get
243:     for (int i = 0; i < NumRegsKey; i++) begin
244:       key_init[0][i]    = reg2hw.key_share0[i].q;
245:       key_init_qe[0][i] = reg2hw.key_share0[i].qe;
246:       key_init[1][i]    = reg2hw.key_share1[i].q;
247:       key_init_qe[1][i] = reg2hw.key_share1[i].qe;
248:     end
249:   end
250: 
251:   prim_sec_anchor_buf #(
252:     .Width ( NumSharesKey * NumRegsKey )
253:   ) u_prim_buf_key_init_qe (
254:     .in_i  ( {key_init_qe[1],     key_init_qe[0]}     ),
255:     .out_o ( {key_init_qe_buf[1], key_init_qe_buf[0]} )
256:   );
257: 
258:   always_comb begin : key_sideload_get
259:     for (int s = 0; s < NumSharesKey; s++) begin
260:       for (int i = 0; i < NumRegsKey; i++) begin
261:         key_sideload[s][i] = keymgr_key_i.key[s][i * 32 +: 32];
262:       end
263:     end
264:   end
265: 
266:   always_comb begin : iv_get
267:     for (int i = 0; i < NumRegsIv; i++) begin
268:       iv[i]    = reg2hw.iv[i].q;
269:       iv_qe[i] = reg2hw.iv[i].qe;
270:     end
271:   end
272: 
273:   prim_sec_anchor_buf #(
274:     .Width ( NumRegsIv )
275:   ) u_prim_buf_iv_qe (
276:     .in_i  ( iv_qe     ),
277:     .out_o ( iv_qe_buf )
278:   );
279: 
280:   always_comb begin : data_in_get
281:     for (int i = 0; i < NumRegsData; i++) begin
282:       data_in[i]    = reg2hw.data_in[i].q;
283:       data_in_qe[i] = reg2hw.data_in[i].qe;
284:     end
285:   end
286: 
287:   prim_sec_anchor_buf #(
288:     .Width ( NumRegsData )
289:   ) u_prim_buf_data_in_qe (
290:     .in_i  ( data_in_qe     ),
291:     .out_o ( data_in_qe_buf )
292:   );
293: 
294:   always_comb begin : data_out_get
295:     for (int i = 0; i < NumRegsData; i++) begin
296:       // data_out is actually hwo, but we need hrw for hwre
297:       unused_data_out_q[i] = reg2hw.data_out[i].q;
298:       data_out_re[i]       = reg2hw.data_out[i].re;
299:     end
300:   end
301: 
302:   prim_sec_anchor_buf #(
303:     .Width ( NumRegsData )
304:   ) u_prim_buf_data_out_re (
305:     .in_i  ( data_out_re     ),
306:     .out_o ( data_out_re_buf )
307:   );
308: 
309:   //////////////////////
310:   // Key, IV and Data //
311:   //////////////////////
312: 
313:   // SEC_CM: KEY.SEC_WIPE
314:   // SEC_CM: KEY.SIDELOAD
315:   // Initial Key registers
316:   always_comb begin : key_init_mux
317:     unique case (key_init_sel)
318:       KEY_INIT_INPUT:  key_init_d = key_init;
319:       KEY_INIT_KEYMGR: key_init_d = key_sideload;
320:       KEY_INIT_CLEAR:  key_init_d = prd_clearing_key_init;
321:       default:         key_init_d = prd_clearing_key_init;
322:     endcase
323:   end
324: 
325:   always_ff @(posedge clk_i or negedge rst_ni) begin : key_init_reg
326:     if (!rst_ni) begin
327:       key_init_q <= '{default: '0};
328:     end else begin
329:       for (int s = 0; s < NumSharesKey; s++) begin
330:         for (int i = 0; i < NumRegsKey; i++) begin
331:           if (key_init_we[s][i] == SP2V_HIGH) begin
332:             key_init_q[s][i] <= key_init_d[s][i];
333:           end
334:         end
335:       end
336:     end
337:   end
338: 
339:   // SEC_CM: IV.CONFIG.SEC_WIPE
340:   // IV registers
341:   always_comb begin : iv_mux
342:     unique case (iv_sel)
343:       IV_INPUT:        iv_d = iv;
344:       IV_DATA_OUT:     iv_d = data_out_d;
345:       IV_DATA_OUT_RAW: iv_d = aes_transpose(state_out);
346:       IV_DATA_IN_PREV: iv_d = data_in_prev_q;
347:       IV_CTR:          iv_d = ctr;
348:       IV_CLEAR:        iv_d = prd_clearing_data;
349:       default:         iv_d = prd_clearing_data;
350:     endcase
351:   end
352: 
353:   always_ff @(posedge clk_i or negedge rst_ni) begin : iv_reg
354:     if (!rst_ni) begin
355:       iv_q <= '0;
356:     end else begin
357:       for (int i = 0; i < NumSlicesCtr; i++) begin
358:         if (iv_we[i] == SP2V_HIGH) begin
359:           iv_q[i] <= iv_d[i];
360:         end
361:       end
362:     end
363:   end
364: 
365:   // SEC_CM: DATA_REG.SEC_WIPE
366:   // Previous input data register
367:   always_comb begin : data_in_prev_mux
368:     unique case (data_in_prev_sel)
369:       DIP_DATA_IN: data_in_prev_d = data_in;
370:       DIP_CLEAR:   data_in_prev_d = data_in;
371:       default:     data_in_prev_d = prd_clearing_data;
372:     endcase
373:   end
374: 
375:   always_ff @(posedge clk_i or negedge rst_ni) begin : data_in_prev_reg
376:     if (!rst_ni) begin
377:       data_in_prev_q <= '0;
378:     end else if (data_in_prev_we == SP2V_HIGH) begin
379:       data_in_prev_q <= data_in_prev_d;
380:     end
381:   end
382: 
383:   /////////////
384:   // Counter //
385:   /////////////
386: 
387:   aes_ctr u_aes_ctr (
388:     .clk_i    ( clk_i     ),
389:     .rst_ni   ( rst_ni    ),
390: 
391:     .incr_i   ( ctr_incr  ),
392:     .ready_o  ( ctr_ready ),
393:     .alert_o  ( ctr_alert ),
394: 
395:     .ctr_i    ( iv_q      ),
396:     .ctr_o    ( ctr       ),
397:     .ctr_we_o ( ctr_we    )
398:   );
399: 
400:   /////////////////
401:   // Cipher Core //
402:   /////////////////
403: 
404:   // Cipher core operation
405:   assign cipher_op = (aes_mode_q == AES_ECB && aes_op_q == AES_ENC) ? CIPH_FWD :
406:                      (aes_mode_q == AES_ECB && aes_op_q == AES_DEC) ? CIPH_INV :
407:                      (aes_mode_q == AES_CBC && aes_op_q == AES_ENC) ? CIPH_FWD :
408:                      (aes_mode_q == AES_CBC && aes_op_q == AES_DEC) ? CIPH_INV :
409:                      (aes_mode_q == AES_CFB)                        ? CIPH_FWD :
410:                      (aes_mode_q == AES_OFB)                        ? CIPH_FWD :
411:                      (aes_mode_q == AES_CTR)                        ? CIPH_FWD : CIPH_FWD;
412: 
413:   // This primitive is used to place a size-only constraint on the
414:   // buffers to act as a synthesis optimization barrier.
415:   logic [$bits(ciph_op_e)-1:0] cipher_op_raw;
416:   prim_buf #(
417:     .Width($bits(ciph_op_e))
418:   ) u_prim_buf_op (
419:     .in_i(cipher_op),
420:     .out_o(cipher_op_raw)
421:   );
422:   assign cipher_op_buf = ciph_op_e'(cipher_op_raw);
423: 
424:   // Convert input data/IV to state format (every word corresponds to one state column).
425:   // Mux for state input
426:   always_comb begin : state_in_mux
427:     unique case (state_in_sel)
428:       SI_ZERO: state_in = '0;
429:       SI_DATA: state_in = aes_transpose(data_in);
430:       default: state_in = '0;
431:     endcase
432:   end
433: 
434:   // Mux for addition to state input
435:   always_comb begin : add_state_in_mux
436:     unique case (add_state_in_sel)
437:       ADD_SI_ZERO: add_state_in = '0;
438:       ADD_SI_IV:   add_state_in = aes_transpose(iv_q);
439:       default:     add_state_in = '0;
440:     endcase
441:   end
442: 
443:   if (!SecMasking) begin : gen_state_init_unmasked
444:     assign state_init[0] = state_in ^ add_state_in;
445: 
446:     logic [3:0][3:0][7:0] unused_state_mask;
447:     assign unused_state_mask = state_mask;
448: 
449:   end else begin : gen_state_init_masked
450:     assign state_init[0] = (state_in ^ add_state_in) ^ state_mask; // Masked data share
451:     assign state_init[1] = state_mask;                             // Mask share
452:   end
453: 
454:   if (!SecMasking) begin : gen_key_init_unmasked
455:     // Combine the two key shares for the unmasked cipher core. This causes SCA leakage of the key
456:     // and thus should be avoided.
457:     assign key_init_cipher[0] = key_init_q[0] ^ key_init_q[1];
458: 
459:   end else begin : gen_key_init_masked
460:     // Forward the masked key share and the mask share to the masked cipher core.
461:     assign key_init_cipher    = key_init_q;
462:   end
463: 
464:   // SEC_CM: KEY.MASKING
465:   // Cipher core
466:   aes_cipher_core #(
467:     .AES192Enable           ( AES192Enable           ),
468:     .SecMasking             ( SecMasking             ),
469:     .SecSBoxImpl            ( SecSBoxImpl            ),
470:     .SecAllowForcingMasks   ( SecAllowForcingMasks   ),
471:     .SecSkipPRNGReseeding   ( SecSkipPRNGReseeding   ),
472:     .RndCnstMaskingLfsrSeed ( RndCnstMaskingLfsrSeed ),
473:     .RndCnstMaskingLfsrPerm ( RndCnstMaskingLfsrPerm )
474:   ) u_aes_cipher_core (
475:     .clk_i                ( clk_i                      ),
476:     .rst_ni               ( rst_ni                     ),
477: 
478:     .in_valid_i           ( cipher_in_valid            ),
479:     .in_ready_o           ( cipher_in_ready            ),
480: 
481:     .out_valid_o          ( cipher_out_valid           ),
482:     .out_ready_i          ( cipher_out_ready           ),
483: 
484:     .cfg_valid_i          ( ~ctrl_err_storage          ), // Used for gating assertions only.
485:     .op_i                 ( cipher_op_buf              ),
486:     .key_len_i            ( key_len_q                  ),
487:     .crypt_i              ( cipher_crypt               ),
488:     .crypt_o              ( cipher_crypt_busy          ),
489:     .dec_key_gen_i        ( cipher_dec_key_gen         ),
490:     .dec_key_gen_o        ( cipher_dec_key_gen_busy    ),
491:     .prng_reseed_i        ( cipher_prng_reseed         ),
492:     .prng_reseed_o        ( cipher_prng_reseed_busy    ),
493:     .key_clear_i          ( cipher_key_clear           ),
494:     .key_clear_o          ( cipher_key_clear_busy      ),
495:     .data_out_clear_i     ( cipher_data_out_clear      ),
496:     .data_out_clear_o     ( cipher_data_out_clear_busy ),
497:     .alert_fatal_i        ( alert_fatal_o              ),
498:     .alert_o              ( cipher_alert               ),
499: 
500:     .prd_clearing_state_i ( prd_clearing_state         ),
501:     .prd_clearing_key_i   ( prd_clearing_key           ),
502: 
503:     .force_masks_i        ( force_masks                ),
504:     .data_in_mask_o       ( state_mask                 ),
505:     .entropy_req_o        ( entropy_masking_req_o      ),
506:     .entropy_ack_i        ( entropy_masking_ack_i      ),
507:     .entropy_i            ( entropy_masking_i          ),
508: 
509:     .state_init_i         ( state_init                 ),
510:     .key_init_i           ( key_init_cipher            ),
511:     .state_o              ( state_done                 )
512:   );
513: 
514:   if (!SecMasking) begin : gen_state_out_unmasked
515:     assign state_out = state_done[0];
516:   end else begin : gen_state_out_masked
517:     // Unmask the cipher core output. This might get reworked in the future when masking the
518:     // counter and feedback path through the IV regs.
519: 
520:     // Only unmask the final cipher core output. Unmasking intermediate output data causes
521:     // additional SCA leakage and thus has to be avoided. Forward PRD instead of a determinsitic
522:     // value to avoid leaking the cipher core output when it becomes valid.
523:     logic [3:0][3:0][7:0] state_done_muxed [NumShares];
524:     for (genvar s = 0; s < NumShares; s++) begin : gen_state_done_muxed
525:       assign state_done_muxed[s] =
526:           (cipher_out_valid == SP2V_HIGH) ? state_done[s] : prd_clearing_state[s];
527:     end
528: 
529:     // Avoid aggressive synthesis optimizations.
530:     logic [3:0][3:0][7:0] state_done_buf [NumShares];
531:     prim_buf #(
532:       .Width ( 128 * NumShares )
533:     ) u_prim_state_done_muxed (
534:       .in_i  ( {state_done_muxed[1], state_done_muxed[0]} ),
535:       .out_o ( {state_done_buf[1],   state_done_buf[0]}   )
536:     );
537: 
538:     // Unmask the cipher core output.
539:     assign state_out = state_done_buf[0] ^ state_done_buf[1];
540:   end
541: 
542:   // Mux for addition to state output
543:   always_comb begin : add_state_out_mux
544:     unique case (add_state_out_sel)
545:       ADD_SO_ZERO: add_state_out = '0;
546:       ADD_SO_IV:   add_state_out = aes_transpose(iv_q);
547:       ADD_SO_DIP:  add_state_out = aes_transpose(data_in_prev_q);
548:       default:     add_state_out = '0;
549:     endcase
550:   end
551: 
552:   // Convert output state to output data format (every column corresponds to one output word).
553:   assign data_out_d = aes_transpose(state_out ^ add_state_out);
554: 
555:   //////////////////////
556:   // Control Register //
557:   //////////////////////
558: 
559:   // Shadowed register primitve
560:   aes_ctrl_reg_shadowed #(
561:     .AES192Enable ( AES192Enable )
562:   ) u_ctrl_reg_shadowed (
563:     .clk_i              ( clk_i                ),
564:     .rst_ni             ( rst_ni               ),
565:     .rst_shadowed_ni    ( rst_shadowed_ni      ),
566:     .qe_o               ( ctrl_qe              ),
567:     .we_i               ( ctrl_we              ),
568:     .phase_o            ( ctrl_phase           ),
569:     .operation_o        ( aes_op_q             ),
570:     .mode_o             ( aes_mode_q           ),
571:     .key_len_o          ( key_len_q            ),
572:     .sideload_o         ( sideload_q           ),
573:     .prng_reseed_rate_o ( prng_reseed_rate_q   ),
574:     .manual_operation_o ( manual_operation_q   ),
575:     .err_update_o       ( ctrl_reg_err_update  ),
576:     .err_storage_o      ( ctrl_reg_err_storage ),
577:     .reg2hw_ctrl_i      ( reg2hw.ctrl_shadowed ),
578:     .hw2reg_ctrl_o      ( hw2reg.ctrl_shadowed )
579:   );
580: 
581:   // Auxiliary control register signals
582:   assign key_touch_forces_reseed = reg2hw.ctrl_aux_shadowed.key_touch_forces_reseed.q;
583:   assign force_masks             = reg2hw.ctrl_aux_shadowed.force_masks.q;
584: 
585:   /////////////
586:   // Control //
587:   /////////////
588: 
589:   // Control
590:   aes_control #(
591:     .SecMasking           ( SecMasking           ),
592:     .SecStartTriggerDelay ( SecStartTriggerDelay )
593:   ) u_aes_control (
594:     .clk_i                     ( clk_i                                  ),
595:     .rst_ni                    ( rst_ni                                 ),
596: 
597:     .ctrl_qe_i                 ( ctrl_qe                                ),
598:     .ctrl_we_o                 ( ctrl_we                                ),
599:     .ctrl_phase_i              ( ctrl_phase                             ),
600:     .ctrl_err_storage_i        ( ctrl_err_storage                       ),
601:     .op_i                      ( aes_op_q                               ),
602:     .mode_i                    ( aes_mode_q                             ),
603:     .cipher_op_i               ( cipher_op_buf                          ),
604:     .sideload_i                ( sideload_q                             ),
605:     .prng_reseed_rate_i        ( prng_reseed_rate_q                     ),
606:     .manual_operation_i        ( manual_operation_q                     ),
607:     .key_touch_forces_reseed_i ( key_touch_forces_reseed                ),
608:     .start_i                   ( reg2hw.trigger.start.q                 ),
609:     .key_iv_data_in_clear_i    ( reg2hw.trigger.key_iv_data_in_clear.q  ),
610:     .data_out_clear_i          ( reg2hw.trigger.data_out_clear.q        ),
611:     .prng_reseed_i             ( reg2hw.trigger.prng_reseed.q           ),
612:     .mux_sel_err_i             ( mux_sel_err                            ),
613:     .sp_enc_err_i              ( sp_enc_err_q                           ),
614:     .lc_escalate_en_i          ( lc_escalate_en_i                       ),
615:     .alert_fatal_i             ( alert_fatal_o                          ),
616:     .alert_o                   ( ctrl_alert                             ),
617: 
618:     .key_sideload_valid_i      ( keymgr_key_i.valid                     ),
619:     .key_init_qe_i             ( key_init_qe_buf                        ),
620:     .iv_qe_i                   ( iv_qe_buf                              ),
621:     .data_in_qe_i              ( data_in_qe_buf                         ),
622:     .data_out_re_i             ( data_out_re_buf                        ),
623:     .data_in_we_o              ( data_in_we                             ),
624:     .data_out_we_o             ( data_out_we_ctrl                       ),
625: 
626:     .data_in_prev_sel_o        ( data_in_prev_sel_ctrl                  ),
627:     .data_in_prev_we_o         ( data_in_prev_we_ctrl                   ),
628: 
629:     .state_in_sel_o            ( state_in_sel_ctrl                      ),
630:     .add_state_in_sel_o        ( add_state_in_sel_ctrl                  ),
631:     .add_state_out_sel_o       ( add_state_out_sel_ctrl                 ),
632: 
633:     .ctr_incr_o                ( ctr_incr                               ),
634:     .ctr_ready_i               ( ctr_ready                              ),
635:     .ctr_we_i                  ( ctr_we                                 ),
636: 
637:     .cipher_in_valid_o         ( cipher_in_valid                        ),
638:     .cipher_in_ready_i         ( cipher_in_ready                        ),
639:     .cipher_out_valid_i        ( cipher_out_valid                       ),
640:     .cipher_out_ready_o        ( cipher_out_ready                       ),
641:     .cipher_crypt_o            ( cipher_crypt                           ),
642:     .cipher_crypt_i            ( cipher_crypt_busy                      ),
643:     .cipher_dec_key_gen_o      ( cipher_dec_key_gen                     ),
644:     .cipher_dec_key_gen_i      ( cipher_dec_key_gen_busy                ),
645:     .cipher_prng_reseed_o      ( cipher_prng_reseed                     ),
646:     .cipher_prng_reseed_i      ( cipher_prng_reseed_busy                ),
647:     .cipher_key_clear_o        ( cipher_key_clear                       ),
648:     .cipher_key_clear_i        ( cipher_key_clear_busy                  ),
649:     .cipher_data_out_clear_o   ( cipher_data_out_clear                  ),
650:     .cipher_data_out_clear_i   ( cipher_data_out_clear_busy             ),
651: 
652:     .key_init_sel_o            ( key_init_sel_ctrl                      ),
653:     .key_init_we_o             ( key_init_we_ctrl                       ),
654:     .iv_sel_o                  ( iv_sel_ctrl                            ),
655:     .iv_we_o                   ( iv_we_ctrl                             ),
656: 
657:     .prng_data_req_o           ( prd_clearing_upd_req                   ),
658:     .prng_data_ack_i           ( prd_clearing_upd_ack                   ),
659:     .prng_reseed_req_o         ( prd_clearing_rsd_req                   ),
660:     .prng_reseed_ack_i         ( prd_clearing_rsd_ack                   ),
661: 
662:     .start_o                   ( hw2reg.trigger.start.d                 ),
663:     .start_we_o                ( hw2reg.trigger.start.de                ),
664:     .key_iv_data_in_clear_o    ( hw2reg.trigger.key_iv_data_in_clear.d  ),
665:     .key_iv_data_in_clear_we_o ( hw2reg.trigger.key_iv_data_in_clear.de ),
666:     .data_out_clear_o          ( hw2reg.trigger.data_out_clear.d        ),
667:     .data_out_clear_we_o       ( hw2reg.trigger.data_out_clear.de       ),
668:     .prng_reseed_o             ( hw2reg.trigger.prng_reseed.d           ),
669:     .prng_reseed_we_o          ( hw2reg.trigger.prng_reseed.de          ),
670: 
671:     .idle_o                    ( hw2reg.status.idle.d                   ),
672:     .idle_we_o                 ( hw2reg.status.idle.de                  ),
673:     .stall_o                   ( hw2reg.status.stall.d                  ),
674:     .stall_we_o                ( hw2reg.status.stall.de                 ),
675:     .output_lost_i             ( reg2hw.status.output_lost.q            ),
676:     .output_lost_o             ( hw2reg.status.output_lost.d            ),
677:     .output_lost_we_o          ( hw2reg.status.output_lost.de           ),
678:     .output_valid_o            ( hw2reg.status.output_valid.d           ),
679:     .output_valid_we_o         ( hw2reg.status.output_valid.de          ),
680:     .input_ready_o             ( hw2reg.status.input_ready.d            ),
681:     .input_ready_we_o          ( hw2reg.status.input_ready.de           )
682:   );
683: 
684:   // SEC_CM: DATA_REG.SEC_WIPE
685:   // Input data register clear
686:   always_comb begin : data_in_reg_clear
687:     for (int i = 0; i < NumRegsData; i++) begin
688:       hw2reg.data_in[i].de = data_in_we;
689:     end
690:   end
691: 
692:   ///////////////
693:   // Selectors //
694:   ///////////////
695: 
696:   // We use sparse encodings for these mux selector signals and must ensure that:
697:   // 1. The synthesis tool doesn't optimize away the sparse encoding.
698:   // 2. The selector signal is always valid. More precisely, an alert or SVA is triggered if a
699:   //    selector signal takes on an invalid value.
700:   // 3. The alert signal remains asserted until reset even if the selector signal becomes valid
701:   //    again. This is achieved by driving the control FSM into the terminal error state whenever
702:   //    any mux selector signal becomes invalid.
703:   //
704:   // If any mux selector signal becomes invalid, the control FSM further prevents any data from
705:   // being released from the cipher core by de-asserting the write enable of the output data
706:   // registers.
707: 
708:   aes_sel_buf_chk #(
709:     .Num      ( DIPSelNum   ),
710:     .Width    ( DIPSelWidth ),
711:     .EnSecBuf ( 1'b1        )
712:   ) u_aes_data_in_prev_sel_buf_chk (
713:     .clk_i  ( clk_i                 ),
714:     .rst_ni ( rst_ni                ),
715:     .sel_i  ( data_in_prev_sel_ctrl ),
716:     .sel_o  ( data_in_prev_sel_raw  ),
717:     .err_o  ( data_in_prev_sel_err  )
718:   );
719:   assign data_in_prev_sel = dip_sel_e'(data_in_prev_sel_raw);
720: 
721:   aes_sel_buf_chk #(
722:     .Num      ( SISelNum   ),
723:     .Width    ( SISelWidth ),
724:     .EnSecBuf ( 1'b1       )
725:   ) u_aes_state_in_sel_buf_chk (
726:     .clk_i  ( clk_i             ),
727:     .rst_ni ( rst_ni            ),
728:     .sel_i  ( state_in_sel_ctrl ),
729:     .sel_o  ( state_in_sel_raw  ),
730:     .err_o  ( state_in_sel_err  )
731:   );
732:   assign state_in_sel = si_sel_e'(state_in_sel_raw);
733: 
734:   aes_sel_buf_chk #(
735:     .Num      ( AddSISelNum   ),
736:     .Width    ( AddSISelWidth ),
737:     .EnSecBuf ( 1'b1          )
738:   ) u_aes_add_state_in_sel_buf_chk (
739:     .clk_i  ( clk_i                 ),
740:     .rst_ni ( rst_ni                ),
741:     .sel_i  ( add_state_in_sel_ctrl ),
742:     .sel_o  ( add_state_in_sel_raw  ),
743:     .err_o  ( add_state_in_sel_err  )
744:   );
745:   assign add_state_in_sel = add_si_sel_e'(add_state_in_sel_raw);
746: 
747:   aes_sel_buf_chk #(
748:     .Num      ( AddSOSelNum   ),
749:     .Width    ( AddSOSelWidth ),
750:     .EnSecBuf ( 1'b1          )
751:   ) u_aes_add_state_out_sel_buf_chk (
752:     .clk_i  ( clk_i                  ),
753:     .rst_ni ( rst_ni                 ),
754:     .sel_i  ( add_state_out_sel_ctrl ),
755:     .sel_o  ( add_state_out_sel_raw  ),
756:     .err_o  ( add_state_out_sel_err  )
757:   );
758:   assign add_state_out_sel = add_so_sel_e'(add_state_out_sel_raw);
759: 
760:   aes_sel_buf_chk #(
761:     .Num      ( KeyInitSelNum   ),
762:     .Width    ( KeyInitSelWidth ),
763:     .EnSecBuf ( 1'b1            )
764:   ) u_aes_key_init_sel_buf_chk (
765:     .clk_i  ( clk_i             ),
766:     .rst_ni ( rst_ni            ),
767:     .sel_i  ( key_init_sel_ctrl ),
768:     .sel_o  ( key_init_sel_raw  ),
769:     .err_o  ( key_init_sel_err  )
770:   );
771:   assign key_init_sel = key_init_sel_e'(key_init_sel_raw);
772: 
773:   aes_sel_buf_chk #(
774:     .Num      ( IVSelNum   ),
775:     .Width    ( IVSelWidth ),
776:     .EnSecBuf ( 1'b1       )
777:   ) u_aes_iv_sel_buf_chk (
778:     .clk_i  ( clk_i       ),
779:     .rst_ni ( rst_ni      ),
780:     .sel_i  ( iv_sel_ctrl ),
781:     .sel_o  ( iv_sel_raw  ),
782:     .err_o  ( iv_sel_err  )
783:   );
784:   assign iv_sel = iv_sel_e'(iv_sel_raw);
785: 
786:   // Signal invalid mux selector signals to control FSM which will lock up and trigger an alert.
787:   assign mux_sel_err = data_in_prev_sel_err | state_in_sel_err | add_state_in_sel_err |
788:       add_state_out_sel_err | key_init_sel_err | iv_sel_err;
789: 
790:   //////////////////////////////
791:   // Sparsely Encoded Signals //
792:   //////////////////////////////
793: 
794:   // We use sparse encodings for various critical signals and must ensure that:
795:   // 1. The synthesis tool doesn't optimize away the sparse encoding.
796:   // 2. The sparsely encoded signal is always valid. More precisely, an alert or SVA is triggered
797:   //    if a sparse signal takes on an invalid value.
798:   // 3. The alert signal remains asserted until reset even if the sparse signal becomes valid again
799:   //    This is achieved by driving the control FSM into the terminal error state whenever any
800:   //    sparsely encoded signal becomes invalid.
801:   //
802:   // If any sparsely encoded signal becomes invalid, the core controller further immediately
803:   // de-asserts the data_out_we_o signal to prevent any data from being released.
804: 
805:   // We use vectors of sparsely encoded signals to reduce code duplication.
806:   localparam int unsigned NumSp2VSig = NumSharesKey * NumRegsKey + NumSlicesCtr + 2;
807:   sp2v_e [NumSp2VSig-1:0]                sp2v_sig;
808:   sp2v_e [NumSp2VSig-1:0]                sp2v_sig_chk;
809:   logic  [NumSp2VSig-1:0][Sp2VWidth-1:0] sp2v_sig_chk_raw;
810:   logic  [NumSp2VSig-1:0]                sp2v_sig_err;
811: 
812:   for (genvar s = 0; s < NumSharesKey; s++) begin : gen_use_key_init_we_ctrl_shares
813:     for (genvar i = 0; i < NumRegsKey; i++) begin : gen_use_key_init_we_ctrl
814:       assign sp2v_sig[s * NumRegsKey + i] = key_init_we_ctrl[s][i];
815:     end
816:   end
817:   for (genvar i = 0; i < NumSlicesCtr; i++) begin : gen_use_iv_we_ctrl
818:     assign sp2v_sig[NumSharesKey * NumRegsKey + i] = iv_we_ctrl[i];
819:   end
820:   assign sp2v_sig[NumSharesKey * NumRegsKey + NumSlicesCtr + 0] = data_in_prev_we_ctrl;
821:   assign sp2v_sig[NumSharesKey * NumRegsKey + NumSlicesCtr + 1] = data_out_we_ctrl;
822: 
823:   // All signals inside sp2v_sig are eventually converted to single-rail signals.
824:   localparam bit [NumSp2VSig-1:0] Sp2VEnSecBuf = {NumSp2VSig{1'b1}};
825: 
826:   // Individually check sparsely encoded signals.
827:   for (genvar i = 0; i < NumSp2VSig; i++) begin : gen_sel_buf_chk
828:     aes_sel_buf_chk #(
829:       .Num      ( Sp2VNum         ),
830:       .Width    ( Sp2VWidth       ),
831:       .EnSecBuf ( Sp2VEnSecBuf[i] )
832:     ) u_aes_sp2v_sig_buf_chk_i (
833:       .clk_i  ( clk_i               ),
834:       .rst_ni ( rst_ni              ),
835:       .sel_i  ( sp2v_sig[i]         ),
836:       .sel_o  ( sp2v_sig_chk_raw[i] ),
837:       .err_o  ( sp2v_sig_err[i]     )
838:     );
839:     assign sp2v_sig_chk[i] = sp2v_e'(sp2v_sig_chk_raw[i]);
840:   end
841: 
842:   for (genvar s = 0; s < NumSharesKey; s++) begin : gen_key_init_we_shares
843:     for (genvar i = 0; i < NumRegsKey; i++) begin : gen_key_init_we
844:       assign key_init_we[s][i] = sp2v_sig_chk[s * NumRegsKey + i];
845:     end
846:   end
847:   for (genvar i = 0; i < NumSlicesCtr; i++) begin : gen_iv_we
848:     assign iv_we[i]      = sp2v_sig_chk[NumSharesKey * NumRegsKey + i];
849:   end
850:   assign data_in_prev_we = sp2v_sig_chk[NumSharesKey * NumRegsKey + NumSlicesCtr + 0];
851:   assign data_out_we     = sp2v_sig_chk[NumSharesKey * NumRegsKey + NumSlicesCtr + 1];
852: 
853:   // Collect encoding errors.
854:   // We instantiate the checker modules as close as possible to where the sparsely encoded signals
855:   // are used. Here, we collect also encoding errors detected in other places of the core.
856:   assign sp_enc_err_d = |sp2v_sig_err;
857: 
858:   // We need to register the collected error signal to avoid circular loops in the core controller
859:   // related to iv_we and data_out_we.
860:   always_ff @(posedge clk_i or negedge rst_ni) begin : reg_sp_enc_err
861:     if (!rst_ni) begin
862:       sp_enc_err_q <= 1'b0;
863:     end else if (sp_enc_err_d) begin
864:       sp_enc_err_q <= 1'b1;
865:     end
866:   end
867: 
868:   /////////////
869:   // Outputs //
870:   /////////////
871: 
872:   always_ff @(posedge clk_i or negedge rst_ni) begin : data_out_reg
873:     if (!rst_ni && data_out_we != SP2V_HIGH) begin 
874:       data_out_q <= '0;
875:     end else if (data_out_we == SP2V_HIGH) begin
876:       data_out_q <= data_out_d;
877:     end
878:   end
879: 
880:   always_comb begin : key_reg_put
881:     for (int i = 0; i < NumRegsKey; i++) begin
882:       hw2reg.key_share0[i].d = key_init_q[0][i];
883:       hw2reg.key_share1[i].d = key_init_q[1][i];
884:     end
885:   end
886: 
887:   always_comb begin : iv_reg_put
888:     for (int i = 0; i < NumRegsIv; i++) begin
889:       // Software updates IV in chunks of 32 bits. Internally, the counter updates SliceSizeCtr
890:       // bits at a time.
891:       hw2reg.iv[i].d  = {iv_q[2 * i + 1], iv_q[2 * i]};
892:     end
893:   end
894: 
895:   always_comb begin : data_out_put
896:     for (int i = 0; i < NumRegsData; i++) begin
897:       hw2reg.data_out[i].d = data_out_q[i];
898:     end
899:   end
900: 
901:   ////////////
902:   // Alerts //
903:   ////////////
904: 
905:   // Should fatal alerts clear the status register?
906:   assign clear_on_fatal = ClearStatusOnFatalAlert ? alert_fatal_o : 1'b0;
907: 
908:   // Recoverable alert conditions are signaled as a single alert event.
909:   assign ctrl_err_update = ctrl_reg_err_update | shadowed_update_err_i;
910:   assign alert_recov_o = ctrl_err_update;
911: 
912:   // The recoverable alert is observable via status register until the AES operation is restarted
913:   // by re-writing the Control Register. Fatal alerts clear all other bits in the status register.
914:   assign hw2reg.status.alert_recov_ctrl_update_err.d  = ctrl_err_update & ~clear_on_fatal;
915:   assign hw2reg.status.alert_recov_ctrl_update_err.de = ctrl_err_update | ctrl_we | clear_on_fatal;
916: 
917:   // Fatal alert conditions need to remain asserted until reset.
918:   assign ctrl_err_storage_d = ctrl_reg_err_storage | shadowed_storage_err_i;
919:   always_ff @(posedge clk_i or negedge rst_ni) begin : ctrl_err_storage_reg
920:     if (!rst_ni) begin
921:       ctrl_err_storage_q <= 1'b0;
922:     end else if (ctrl_err_storage_d) begin
923:       ctrl_err_storage_q <= 1'b1;
924:     end
925:   end
926:   assign ctrl_err_storage = ctrl_err_storage_d | ctrl_err_storage_q;
927: 
928:   // Collect fatal alert signals.
929:   assign alert_fatal_o = ctrl_err_storage |
930:                          ctr_alert        |
931:                          cipher_alert     |
932:                          ctrl_alert       |
933:                          intg_err_alert_i;
934: 
935:   // Make the fatal alert observable via status register.
936:   assign hw2reg.status.alert_fatal_fault.d  = alert_fatal_o;
937:   assign hw2reg.status.alert_fatal_fault.de = alert_fatal_o;
938: 
939:   // Unused alert signals
940:   logic unused_alert_signals;
941:   assign unused_alert_signals = ^reg2hw.alert_test;
942: 
943:   // Unused inputs
944:   logic unused_idle;
945:   assign unused_idle = reg2hw.status.idle.q;
946: 
947:   ////////////////
948:   // Assertions //
949:   ////////////////
950: 
951:   // Create a lint error to reduce the risk of accidentally disabling the masking.
952:   `ASSERT_STATIC_LINT_ERROR(AesCoreSecMaskingNonDefault, SecMasking == 1)
953: 
954:   // Selectors must be known/valid
955:   `ASSERT(AesModeValid, !ctrl_err_storage |-> aes_mode_q inside {
956:       AES_ECB,
957:       AES_CBC,
958:       AES_CFB,
959:       AES_OFB,
960:       AES_CTR,
961:       AES_NONE
962:       })
963:   `ASSERT(AesOpValid, !ctrl_err_storage |-> aes_op_q inside {
964:       AES_ENC,
965:       AES_DEC
966:       })
967: 
968:   // Check parameters
969:   `ASSERT_INIT(AesNumSlicesCtr, NumSlicesCtr == 8)
970: 
971:   // Signals used for assertions only.
972:   logic [3:0][31:0] state_done_transposed, unused_state_done_transposed;
973:   if (!SecMasking) begin : gen_state_done_transposed_unmasked
974:     assign state_done_transposed = aes_transpose(state_done[0]);
975:   end else begin : gen_state_done_transposed_masked
976:     assign state_done_transposed = aes_transpose(state_done[0] ^ state_done[1]);
977:   end
978:   assign unused_state_done_transposed = state_done_transposed;
979: 
980:   // Ensure that upon local escalation of any of the FSMs, no intermediate state is released from
981:   // the cipher core into the software readable output data or IV registers.
982:   `ASSERT(AesSecCmDataRegLocalEscDataOut, $changed(data_out_q) && alert_fatal_o &&
983:       ($past(cipher_crypt, 2) == SP2V_HIGH || $past(cipher_crypt_busy, 2) == SP2V_HIGH) |=>
984:       ($past(data_out_q) != $past(state_done_transposed, 2)) &&
985:       ($past(data_out_q) != $past(state_done_transposed, 2) ^ $past(iv_q, 2)) &&
986:       ($past(data_out_q) != $past(state_done_transposed, 2) ^ $past(data_in_prev_q, 2)))
987: 
988:   `ASSERT(AesSecCmDataRegLocalEscIv, $changed(iv_q) && alert_fatal_o &&
989:       ($past(cipher_crypt, 2) == SP2V_HIGH || $past(cipher_crypt_busy, 2) == SP2V_HIGH) |=>
990:       ($past(iv_q) != $past(state_done_transposed, 2)) &&
991:       ($past(iv_q) != $past(state_done_transposed, 2) ^ $past(iv_q, 2)) &&
992:       ($past(iv_q) != $past(state_done_transposed, 2) ^ $past(data_in_prev_q, 2)))
993: 
994: endmodule

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_6GtDy31rJ52ZKffoe6CSJs1b)
 Call ID: call_6GtDy31rJ52ZKffoe6CSJs1b
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes/rtl/aes_control_fsm.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // AES main control FSM
6: //
7: // This module contains the main control FSM handling the interplay of input/output registers and
8: // the AES cipher core.
9: 
10: `include "prim_assert.sv"
11: 
12: module aes_control_fsm
13:   import aes_pkg::*;
14:   import aes_reg_pkg::*;
15: #(
16:   parameter bit SecMasking = 0
17: ) (
18:   input  logic                                    clk_i,
19:   input  logic                                    rst_ni,
20: 
21:   // Main control signals
22:   input  logic                                    ctrl_qe_i,
23:   output logic                                    ctrl_we_o,
24:   input  logic                                    ctrl_phase_i,
25:   input  logic                                    ctrl_err_storage_i,
26:   input  aes_op_e                                 op_i,
27:   input  aes_mode_e                               mode_i,
28:   input  ciph_op_e                                cipher_op_i,
29:   input  logic                                    sideload_i,
30:   input  prs_rate_e                               prng_reseed_rate_i,
31:   input  logic                                    manual_operation_i,
32:   input  logic                                    key_touch_forces_reseed_i,
33:   input  logic                                    start_i,
34:   input  logic                                    key_iv_data_in_clear_i,
35:   input  logic                                    data_out_clear_i,
36:   input  logic                                    prng_reseed_i,
37:   input  logic                                    mux_sel_err_i,
38:   input  logic                                    sp_enc_err_i,
39:   input  lc_ctrl_pkg::lc_tx_t                     lc_escalate_en_i,
40:   input  logic                                    alert_fatal_i,
41:   output logic                                    alert_o,
42: 
43:   // I/O register read/write enables
44:   input  logic                                    key_sideload_valid_i,
45:   input  logic [NumSharesKey-1:0][NumRegsKey-1:0] key_init_qe_i,
46:   input  logic                    [NumRegsIv-1:0] iv_qe_i,
47:   input  logic                  [NumRegsData-1:0] data_in_qe_i,
48:   input  logic                  [NumRegsData-1:0] data_out_re_i,
49:   output logic                                    data_in_we_o,
50:   output logic                                    data_out_we_o,           // Sparsify
51: 
52:   // Previous input data register
53:   output dip_sel_e                                data_in_prev_sel_o,
54:   output logic                                    data_in_prev_we_o,       // Sparsify
55: 
56:   // Cipher I/O muxes
57:   output si_sel_e                                 state_in_sel_o,
58:   output add_si_sel_e                             add_state_in_sel_o,
59:   output add_so_sel_e                             add_state_out_sel_o,
60: 
61:   // Counter
62:   output logic                                    ctr_incr_o,              // Sparsify
63:   input  logic                                    ctr_ready_i,             // Sparsify
64:   input  logic                 [NumSlicesCtr-1:0] ctr_we_i,                // Sparsify
65: 
66:   // Cipher core control and sync
67:   output logic                                    cipher_in_valid_o,       // Sparsify
68:   input  logic                                    cipher_in_ready_i,       // Sparsify
69:   input  logic                                    cipher_out_valid_i,      // Sparsify
70:   output logic                                    cipher_out_ready_o,      // Sparsify
71:   output logic                                    cipher_crypt_o,          // Sparsify
72:   input  logic                                    cipher_crypt_i,          // Sparsify
73:   output logic                                    cipher_dec_key_gen_o,    // Sparsify
74:   input  logic                                    cipher_dec_key_gen_i,    // Sparsify
75:   output logic                                    cipher_prng_reseed_o,
76:   input  logic                                    cipher_prng_reseed_i,
77:   output logic                                    cipher_key_clear_o,
78:   input  logic                                    cipher_key_clear_i,
79:   output logic                                    cipher_data_out_clear_o,
80:   input  logic                                    cipher_data_out_clear_i,
81: 
82:   // Initial key registers
83:   output key_init_sel_e                           key_init_sel_o,
84:   output logic [NumSharesKey-1:0][NumRegsKey-1:0] key_init_we_o,           // Sparsify
85: 
86:   // IV registers
87:   output iv_sel_e                                 iv_sel_o,
88:   output logic                 [NumSlicesCtr-1:0] iv_we_o,                 // Sparsify
89: 
90:   // Pseudo-random number generator interface
91:   output logic                                    prng_data_req_o,
92:   input  logic                                    prng_data_ack_i,
93:   output logic                                    prng_reseed_req_o,
94:   input  logic                                    prng_reseed_ack_i,
95: 
96:   // Trigger register
97:   output logic                                    start_we_o,
98:   output logic                                    key_iv_data_in_clear_we_o,
99:   output logic                                    data_out_clear_we_o,
100:   output logic                                    prng_reseed_o,
101:   output logic                                    prng_reseed_we_o,
102: 
103:   // Status register
104:   output logic                                    idle_o,
105:   output logic                                    idle_we_o,
106:   output logic                                    stall_o,
107:   output logic                                    stall_we_o,
108:   input  logic                                    output_lost_i,
109:   output logic                                    output_lost_o,
110:   output logic                                    output_lost_we_o,
111:   output logic                                    output_valid_o,
112:   output logic                                    output_valid_we_o,
113:   output logic                                    input_ready_o,
114:   output logic                                    input_ready_we_o
115: );
116: 
117:   // Signals
118:   aes_ctrl_e                aes_ctrl_ns, aes_ctrl_cs;
119:   logic                     prng_reseed_done_d, prng_reseed_done_q;
120: 
121:   logic                     key_init_clear;
122:   logic                     key_init_new;
123:   logic                     key_init_new_pulse;
124:   logic                     key_init_load;
125:   logic                     key_init_arm;
126:   logic                     key_init_ready;
127:   logic                     key_sideload;
128: 
129:   logic  [NumSlicesCtr-1:0] iv_qe;
130:   logic                     iv_clear;
131:   logic                     iv_load;
132:   logic                     iv_arm;
133:   logic                     iv_ready;
134: 
135:   logic   [NumRegsData-1:0] data_in_new_d, data_in_new_q;
136:   logic                     data_in_new;
137:   logic                     data_in_load;
138: 
139:   logic   [NumRegsData-1:0] data_out_read_d, data_out_read_q;
140:   logic                     data_out_read;
141:   logic                     output_valid_q;
142: 
143:   logic                     cfg_valid;
144:   logic                     no_alert;
145:   logic                     cipher_op_err;
146:   logic                     start_common, start_ecb, start_cbc, start_cfb, start_ofb, start_ctr;
147:   logic                     start;
148:   logic                     start_core;
149:   logic                     finish;
150:   logic                     crypt;
151:   logic                     cipher_out_done;
152:   logic                     doing_cbc_enc, doing_cbc_dec;
153:   logic                     doing_cfb_enc, doing_cfb_dec;
154:   logic                     doing_ofb;
155:   logic                     doing_ctr;
156:   logic                     ctrl_we_q;
157:   logic                     clear_in_out_status;
158:   logic                     clear_on_fatal;
159: 
160:   logic                     start_we;
161:   logic                     key_iv_data_in_clear_we;
162:   logic                     data_out_clear_we;
163:   logic                     prng_reseed_we;
164: 
165:   logic                     idle;
166:   logic                     idle_we;
167:   logic                     stall;
168:   logic                     stall_we;
169:   logic                     output_lost;
170:   logic                     output_lost_we;
171:   logic                     output_valid;
172:   logic                     output_valid_we;
173:   logic                     input_ready;
174:   logic                     input_ready_we;
175: 
176:   logic                     block_ctr_expr;
177:   logic                     block_ctr_decr;
178: 
179:   // Software updates IV in chunks of 32 bits, the counter updates SliceSizeCtr bits at a time.
180:   // Convert word write enable to internal half-word write enable.
181:   assign iv_qe = {iv_qe_i[3], iv_qe_i[3], iv_qe_i[2], iv_qe_i[2],
182:                   iv_qe_i[1], iv_qe_i[1], iv_qe_i[0], iv_qe_i[0]};
183: 
184:   // The cipher core is only ever allowed to start or finish if the control register holds a valid
185:   // configuration and if no fatal alert condition occured.
186:   assign cfg_valid = ~((mode_i == AES_NONE) | ctrl_err_storage_i);
187:   assign no_alert  = ~alert_fatal_i;
188: 
189:   // cipher_op_i is obtained from the configuration of the control register with additional logic.
190:   assign cipher_op_err = ~(cipher_op_i == CIPH_FWD || cipher_op_i == CIPH_INV);
191: 
192:   // Check common start conditions. These are needed for any mode, unless we are running in
193:   // manual mode.
194:   assign start_common = key_init_ready & data_in_new &
195:       // If key sideload is enabled, we only start if the key is valid.
196:       (sideload_i ? key_sideload_valid_i : 1'b1);
197: 
198:   // Check mode-specific start conditions. If the IV (and counter) is needed, we only start if
199:   // also the IV (and counter) is ready.
200:   assign start_ecb = (mode_i == AES_ECB);
201:   assign start_cbc = (mode_i == AES_CBC) & iv_ready;
202:   assign start_cfb = (mode_i == AES_CFB) & iv_ready;
203:   assign start_ofb = (mode_i == AES_OFB) & iv_ready;
204:   assign start_ctr = (mode_i == AES_CTR) & iv_ready & ctr_ready_i;
205: 
206:   // If set to start manually, we just wait for the trigger. Otherwise, check common as well as
207:   // mode-specific start conditions.
208:   assign start = cfg_valid & no_alert &
209:       // Manual operation has priority.
210:       (manual_operation_i ? start_i  :
211:           // Check start conditions for automatic operation.
212:           ((start_ecb |
213:             start_cbc |
214:             start_cfb |
215:             start_ofb |
216:             start_ctr) & start_common));
217: 
218:   // If not set to overwrite data, we wait for any previous output data to be read. data_out_read
219:   // synchronously clears output_valid_q, unless new output data is written in the exact same
220:   // clock cycle.
221:   assign finish = cfg_valid & no_alert &
222:       // Manual operation has priority.
223:       (manual_operation_i ? 1'b1 :
224:           // Make sure previous output data has been read.
225:           (~output_valid_q | data_out_read));
226: 
227:   // Helper signals for FSM
228:   assign crypt = cipher_crypt_o | cipher_crypt_i;
229: 
230:   assign doing_cbc_enc = (mode_i == AES_CBC && op_i == AES_ENC) & crypt;
231:   assign doing_cbc_dec = (mode_i == AES_CBC && op_i == AES_DEC) & crypt;
232:   assign doing_cfb_enc = (mode_i == AES_CFB && op_i == AES_ENC) & crypt;
233:   assign doing_cfb_dec = (mode_i == AES_CFB && op_i == AES_DEC) & crypt;
234:   assign doing_ofb     = (mode_i == AES_OFB)                    & crypt;
235:   assign doing_ctr     = (mode_i == AES_CTR)                    & crypt;
236: 
237:   // FSM
238:   always_comb begin : aes_ctrl_fsm
239: 
240:     // Previous input data register control
241:     data_in_prev_sel_o = DIP_CLEAR;
242:     data_in_prev_we_o  = 1'b0;
243: 
244:     // Cipher I/O mux control
245:     state_in_sel_o      = SI_DATA;
246:     add_state_in_sel_o  = ADD_SI_ZERO;
247:     add_state_out_sel_o = ADD_SO_ZERO;
248: 
249:     // Counter control
250:     ctr_incr_o = 1'b0;
251: 
252:     // Cipher core control
253:     cipher_in_valid_o       = 1'b0;
254:     cipher_out_ready_o      = 1'b0;
255:     cipher_out_done         = 1'b0;
256:     cipher_crypt_o          = 1'b0;
257:     cipher_dec_key_gen_o    = 1'b0;
258:     cipher_prng_reseed_o    = 1'b0;
259:     cipher_key_clear_o      = 1'b0;
260:     cipher_data_out_clear_o = 1'b0;
261: 
262:     // Initial key registers
263:     key_init_sel_o = sideload_i ? KEY_INIT_KEYMGR : KEY_INIT_INPUT;
264:     key_init_we_o = {NumSharesKey * NumRegsKey{1'b0}};
265: 
266:     // IV registers
267:     iv_sel_o = IV_INPUT;
268:     iv_we_o  = {NumSlicesCtr{1'b0}};
269: 
270:     // Control register
271:     ctrl_we_o = 1'b0;
272: 
273:     // Alert
274:     alert_o = 1'b0;
275: 
276:     // Pseudo-random number generator control
277:     prng_data_req_o   = 1'b0;
278:     prng_reseed_req_o = 1'b0;
279: 
280:     // Trigger register control
281:     start_we                = 1'b0;
282:     key_iv_data_in_clear_we = 1'b0;
283:     data_out_clear_we       = 1'b0;
284:     prng_reseed_we          = 1'b0;
285: 
286:     // Status register
287:     idle     = 1'b0;
288:     idle_we  = 1'b0;
289:     stall    = 1'b0;
290:     stall_we = 1'b0;
291: 
292:     // Key, data I/O register control
293:     data_in_load  = 1'b0;
294:     data_in_we_o  = 1'b0;
295:     data_out_we_o = 1'b0;
296: 
297:     // Register status tracker control
298:     key_init_clear = 1'b0;
299:     key_init_load  = 1'b0;
300:     key_init_arm   = 1'b0;
301:     iv_clear       = 1'b0;
302:     iv_load        = 1'b0;
303:     iv_arm         = 1'b0;
304: 
305:     // Block counter
306:     block_ctr_decr = 1'b0;
307: 
308:     // FSM
309:     aes_ctrl_ns        = aes_ctrl_cs;
310:     start_core         = 1'b0;
311:     prng_reseed_done_d = prng_reseed_done_q | prng_reseed_ack_i;
312: 
313:     unique case (aes_ctrl_cs)
314: 
315:       CTRL_IDLE: begin
316:         // The core is about to start encryption/decryption or another action.
317:         start_core = start | key_iv_data_in_clear_i | data_out_clear_i | prng_reseed_i;
318: 
319:         // Update status register. A write to the main control register (if sideload is enabled)
320:         // or writing the last key register can initiate a PRNG reseed operation via trigger
321:         // register. To avoid that subsequent writes to the main control, key or IV registers
322:         // collide with the start of the reseed operation, de-assert the idle bit.
323:         idle    = ~(start_core | (prng_reseed_o & prng_reseed_we_o));
324:         idle_we = 1'b1;
325: 
326:         // Clear the start trigger when seeing invalid configurations or performing automatic
327:         // operation.
328:         start_we = start_i & ((mode_i == AES_NONE) | ~manual_operation_i);
329: 
330:         if (!start_core) begin
331:           // Initial key and IV updates are ignored if the core is about to start. If key sideload
332:           // is enabled, software writes to the initial key registers are ignored.
333:           key_init_we_o = sideload_i ? {NumSharesKey * NumRegsKey{key_sideload}} : key_init_qe_i;
334:           iv_we_o       = iv_qe;
335: 
336:           // Updates to the control register are only allowed if the core is not about to start and
337:           // there isn't a storage error. A storage error is unrecoverable and requires a reset.
338:           ctrl_we_o      = !ctrl_err_storage_i ? ctrl_qe_i : 1'b0;
339: 
340:           // Control register updates clear all register status trackers.
341:           key_init_clear = ctrl_we_o;
342:           iv_clear       = ctrl_we_o;
343:         end
344: 
345:         if (prng_reseed_i) begin
346:           // PRNG reseeding has highest priority.
347:           if (!SecMasking) begin
348:             prng_reseed_done_d = 1'b0;
349:             aes_ctrl_ns        = CTRL_PRNG_RESEED;
350:           end else begin
351:             // In case masking is enabled, also the masking PRNG inside the cipher core needs to
352:             // be reseeded.
353:             cipher_prng_reseed_o = 1'b1;
354: 
355:             // Perform handshake.
356:             cipher_in_valid_o = 1'b1;
357:             if (cipher_in_ready_i) begin
358:               prng_reseed_done_d = 1'b0;
359:               aes_ctrl_ns        = CTRL_PRNG_RESEED;
360:             end
361:           end
362: 
363:         end else if (key_iv_data_in_clear_i || data_out_clear_i) begin
364:           // To clear registers, we must first request fresh pseudo-random data.
365:           aes_ctrl_ns = CTRL_PRNG_UPDATE;
366: 
367:         end else if (start) begin
368:           // Signal that we want to start encryption/decryption.
369:           cipher_crypt_o = 1'b1;
370: 
371:           // Signal if the cipher core shall reseed the masking PRNG.
372:           cipher_prng_reseed_o = block_ctr_expr;
373: 
374:           // We got a new initial key, but want to do decryption. The cipher core must first
375:           // generate the start key for decryption.
376:           cipher_dec_key_gen_o = (cipher_op_i == CIPH_INV) ? key_init_new : 1'b0;
377: 
378:           // Previous input data register control
379:           data_in_prev_sel_o = doing_cbc_dec ? DIP_DATA_IN :
380:                                doing_cfb_enc ? DIP_DATA_IN :
381:                                doing_cfb_dec ? DIP_DATA_IN :
382:                                doing_ofb     ? DIP_DATA_IN :
383:                                doing_ctr     ? DIP_DATA_IN : DIP_CLEAR;
384:           data_in_prev_we_o  = doing_cbc_dec |
385:                                doing_cfb_enc |
386:                                doing_cfb_dec |
387:                                doing_ofb     |
388:                                doing_ctr;
389: 
390:           // State input mux control
391:           state_in_sel_o     = doing_cfb_enc ? SI_ZERO :
392:                                doing_cfb_dec ? SI_ZERO :
393:                                doing_ofb     ? SI_ZERO :
394:                                doing_ctr     ? SI_ZERO : SI_DATA;
395: 
396:           // State input additon mux control
397:           add_state_in_sel_o = doing_cbc_enc ? ADD_SI_IV :
398:                                doing_cfb_enc ? ADD_SI_IV :
399:                                doing_cfb_dec ? ADD_SI_IV :
400:                                doing_ofb     ? ADD_SI_IV :
401:                                doing_ctr     ? ADD_SI_IV : ADD_SI_ZERO;
402: 
403:           // We have work for the cipher core, perform handshake.
404:           cipher_in_valid_o = 1'b1;
405:           if (cipher_in_ready_i) begin
406:             // Do not yet clear a possible start trigger if we are just starting the generation of
407:             // the start key for decryption.
408:             start_we    = ~cipher_dec_key_gen_o;
409:             aes_ctrl_ns = CTRL_LOAD;
410:           end
411:         end
412:       end
413: 
414:       CTRL_LOAD: begin
415:         // Signal that we have used the current key, IV, data input to register status tracking.
416:         key_init_load =  cipher_dec_key_gen_i; // This key is no longer "new", but still clean.
417:         key_init_arm  = ~cipher_dec_key_gen_i; // The key is still "new", prevent partial updates.
418:         iv_load       = ~cipher_dec_key_gen_i & (doing_cbc_enc |
419:                                                  doing_cbc_dec |
420:                                                  doing_cfb_enc |
421:                                                  doing_cfb_dec |
422:                                                  doing_ofb     |
423:                                                  doing_ctr);
424:         data_in_load  = ~cipher_dec_key_gen_i;
425: 
426:         // Trigger counter increment.
427:         ctr_incr_o   = doing_ctr;
428: 
429:         // Unless we are just generating the start key for decryption, we must update the PRNG.
430:         aes_ctrl_ns  = !cipher_dec_key_gen_i ? CTRL_PRNG_UPDATE : CTRL_FINISH;
431:       end
432: 
433:       CTRL_PRNG_UPDATE: begin
434:         // Fresh pseudo-random data is used to:
435:         // - clear the state in the final cipher round,
436:         // - clear any other registers in the CLEAR_I/CO states.
437: 
438:         // IV control in case of ongoing encryption/decryption
439:         // - CTR: IV registers are updated by counter during cipher operation
440:         iv_sel_o = doing_ctr ? IV_CTR   : IV_INPUT;
441:         iv_we_o  = doing_ctr ? ctr_we_i : {NumSlicesCtr{1'b0}};
442: 
443:         // Request fresh pseudo-random data, perform handshake.
444:         prng_data_req_o = 1'b1;
445:         if (prng_data_ack_i) begin
446: 
447:           // Ongoing encryption/decryption operations have the highest priority. The clear triggers
448:           // might have become asserted after the handshake with the cipher core.
449:           if (cipher_crypt_i) begin
450:             aes_ctrl_ns = CTRL_FINISH;
451: 
452:           end else if (key_iv_data_in_clear_i || data_out_clear_i) begin
453:             // To clear the output data registers, we re-use the muxing resources of the cipher
454:             // core. To clear all key material, some key registers inside the cipher core need to
455:             // be cleared.
456:             cipher_key_clear_o      = key_iv_data_in_clear_i;
457:             cipher_data_out_clear_o = data_out_clear_i;
458: 
459:             // We have work for the cipher core, perform handshake.
460:             cipher_in_valid_o = 1'b1;
461:             if (cipher_in_ready_i) begin
462:               aes_ctrl_ns = CTRL_CLEAR_I;
463:             end
464:           end else begin
465:             // Another write to the trigger register must have overwritten the trigger bits that
466:             // actually caused us to enter this state. Just return.
467:             aes_ctrl_ns = CTRL_IDLE;
468:           end // cipher_crypt_i
469:         end // prng_data_ack_i
470:       end
471: 
472:       CTRL_PRNG_RESEED: begin
473:         // Request a reseed of the clearing PRNG.
474:         prng_reseed_req_o = ~prng_reseed_done_q;
475: 
476:         if (!SecMasking) begin
477:           if (prng_reseed_done_q) begin
478:             // Clear the trigger and return.
479:             prng_reseed_we     = 1'b1;
480:             prng_reseed_done_d = 1'b0;
481:             aes_ctrl_ns        = CTRL_IDLE;
482:           end
483: 
484:         end else begin
485:           // In case masking is used, we must also wait for the cipher core to reseed the internal
486:           // masking PRNG. Perform handshake.
487:           cipher_out_ready_o = prng_reseed_done_q;
488:           if (cipher_out_ready_o && cipher_out_valid_i) begin
489:             // Clear the trigger and return.
490:             prng_reseed_we     = 1'b1;
491:             prng_reseed_done_d = 1'b0;
492:             aes_ctrl_ns        = CTRL_IDLE;
493:           end
494:         end
495:       end
496: 
497:       CTRL_FINISH: begin
498:         // Wait for cipher core to finish.
499: 
500:         if (cipher_dec_key_gen_i) begin
501:           // We are ready.
502:           cipher_out_ready_o = 1'b1;
503:           if (cipher_out_valid_i) begin
504:             block_ctr_decr = 1'b1;
505:             aes_ctrl_ns    = CTRL_IDLE;
506:           end
507:         end else begin
508:           // Handshake signals: We are ready once the output data registers can be written. Don't
509:           // let data propagate in case of mux selector or sparsely encoded signals taking on
510:           // invalid values.
511:           cipher_out_ready_o = finish;
512:           cipher_out_done    = finish & cipher_out_valid_i &
513:               ~mux_sel_err_i & ~sp_enc_err_i & ~cipher_op_err;
514: 
515:           // Signal if the cipher core is stalled (because previous output has not yet been read).
516:           stall    = ~finish & cipher_out_valid_i;
517:           stall_we = 1'b1;
518: 
519:           // State out addition mux control
520:           add_state_out_sel_o = doing_cbc_dec ? ADD_SO_IV  :
521:                                 doing_cfb_enc ? ADD_SO_DIP :
522:                                 doing_cfb_dec ? ADD_SO_DIP :
523:                                 doing_ofb     ? ADD_SO_DIP :
524:                                 doing_ctr     ? ADD_SO_DIP : ADD_SO_ZERO;
525: 
526:           // IV control
527:           // - CBC/CFB/OFB: IV registers are only updated when cipher finishes.
528:           // - CTR: IV registers are updated by counter during cipher operation.
529:           iv_sel_o = doing_cbc_enc ? IV_DATA_OUT     :
530:                      doing_cbc_dec ? IV_DATA_IN_PREV :
531:                      doing_cfb_enc ? IV_DATA_OUT     :
532:                      doing_cfb_dec ? IV_DATA_IN_PREV :
533:                      doing_ofb     ? IV_DATA_OUT_RAW :
534:                      doing_ctr     ? IV_CTR          : IV_INPUT;
535:           iv_we_o  = doing_cbc_enc ||
536:                      doing_cbc_dec ||
537:                      doing_cfb_enc ||
538:                      doing_cfb_dec ||
539:                      doing_ofb     ? {NumSlicesCtr{cipher_out_done}} :
540:                      doing_ctr     ? ctr_we_i                        : {NumSlicesCtr{1'b0}};
541: 
542:           // Arm the IV status tracker: After finishing, the IV registers can be written again
543:           // by software. We need to make sure software does not partially update the IV.
544:           iv_arm = (doing_cbc_enc |
545:                     doing_cbc_dec |
546:                     doing_cfb_enc |
547:                     doing_cfb_dec |
548:                     doing_ofb     |
549:                     doing_ctr) & cipher_out_done;
550: 
551:           // Proceed upon successful handshake.
552:           if (cipher_out_done) begin
553:             block_ctr_decr = 1'b1;
554:             data_out_we_o  = 1'b1;
555:             aes_ctrl_ns    = CTRL_IDLE;
556:           end
557:         end
558:       end
559: 
560:       CTRL_CLEAR_I: begin
561:         // Clear input registers such as Initial Key, IV and input data registers.
562:         if (key_iv_data_in_clear_i) begin
563:           // Initial Key
564:           key_init_sel_o = KEY_INIT_CLEAR;
565:           key_init_we_o  = {NumSharesKey * NumRegsKey{1'b1}};
566:           key_init_clear = 1'b1;
567: 
568:           // IV
569:           iv_sel_o = IV_CLEAR;
570:           iv_we_o  = {NumSlicesCtr{1'b1}};
571:           iv_clear = 1'b1;
572: 
573:           // Input data
574:           data_in_we_o       = 1'b1;
575:           data_in_prev_sel_o = DIP_CLEAR;
576:           data_in_prev_we_o  = 1'b1;
577:         end
578:         aes_ctrl_ns = CTRL_CLEAR_CO;
579:       end
580: 
581:       CTRL_CLEAR_CO: begin
582:         // Wait for cipher core to clear internal Full Key and Decryption Key registers and/or
583:         // the state register and clear output data registers afterwards.
584: 
585:         // Perform handshake with cipher core.
586:         cipher_out_ready_o = 1'b1;
587:         if (cipher_out_valid_i) begin
588: 
589:           // Full Key and Decryption Key registers are cleared by the cipher core.
590:           // key_iv_data_in_clear_i is acknowledged by the cipher core with cipher_key_clear_i.
591:           if (cipher_key_clear_i) begin
592:             // Clear the trigger bit.
593:             key_iv_data_in_clear_we = 1'b1;
594:           end
595: 
596:           // To clear the output data registers, we re-use the muxing resources of the cipher core.
597:           // data_out_clear_i is acknowledged by the cipher core with cipher_data_out_clear_i.
598:           if (cipher_data_out_clear_i) begin
599:             // Clear output data and the trigger bit. Don't release data from cipher core in case
600:             // of mux selector or sparsely encoded signals taking on invalid values.
601:             data_out_we_o     = ~mux_sel_err_i & ~sp_enc_err_i & ~cipher_op_err;
602:             data_out_clear_we = 1'b1;
603:           end
604: 
605:           aes_ctrl_ns = CTRL_IDLE;
606:         end
607:       end
608: 
609:       CTRL_ERROR: begin
610:         // SEC_CM: MAIN.FSM.GLOBAL_ESC
611:         // SEC_CM: MAIN.FSM.LOCAL_ESC
612:         // Terminal error state
613:         alert_o = 1'b1;
614:       end
615: 
616:       // We should never get here. If we do (e.g. via a malicious glitch), error out immediately.
617:       default: begin
618:         aes_ctrl_ns = CTRL_ERROR;
619:         alert_o = 1'b1;
620:       end
621:     endcase
622: 
623:     // Unconditionally jump into the terminal error state in case a mux selector or a sparsely
624:     // encoded signal becomes invalid, or if the life cycle controller triggers an escalation.
625:     if (mux_sel_err_i || sp_enc_err_i || cipher_op_err ||
626:             lc_ctrl_pkg::lc_tx_test_true_loose(lc_escalate_en_i)) begin
627:       aes_ctrl_ns = CTRL_ERROR;
628:     end
629:   end
630: 
631:   // SEC_CM: MAIN.FSM.SPARSE
632:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, aes_ctrl_ns, aes_ctrl_cs, aes_ctrl_e, CTRL_IDLE)
633: 
634:   always_ff @(posedge clk_i or negedge rst_ni) begin : reg_fsm
635:     if (!rst_ni) begin
636:       prng_reseed_done_q <= 1'b0;
637:     end else begin
638:       prng_reseed_done_q <= prng_reseed_done_d;
639:     end
640:   end
641: 
642:   /////////////////////
643:   // Status Tracking //
644:   /////////////////////
645: 
646:   // We only take a new sideload key if sideload is enabled, if the provided sideload key is marked
647:   // as valid, and after the control register has been written for the second time. After that
648:   // point we don't update the key anymore, as we don't have a notion of when it actually changes.
649:   // This would be required to trigger decryption key generation for ECB/CBC decryption.
650:   // To update the sideload key, software has to:
651:   // 1) wait unitl AES is idle,
652:   // 2) wait for the key manager to provide the new key,
653:   // 3) start a new message by writing the control register and providing the IV (if needed).
654:   assign key_sideload = sideload_i & key_sideload_valid_i & ctrl_we_q & ~ctrl_phase_i;
655: 
656:   // We only use clean initial keys. Either software/counter has updated
657:   // - all initial key registers, or
658:   // - none of the initial key registers but the registers were updated in the past.
659:   aes_reg_status #(
660:     .Width ( $bits(key_init_we_o) )
661:   ) u_reg_status_key_init (
662:     .clk_i       ( clk_i              ),
663:     .rst_ni      ( rst_ni             ),
664:     .we_i        ( key_init_we_o      ),
665:     .use_i       ( key_init_load      ),
666:     .clear_i     ( key_init_clear     ),
667:     .arm_i       ( key_init_arm       ),
668:     .new_o       ( key_init_new       ),
669:     .new_pulse_o ( key_init_new_pulse ),
670:     .clean_o     ( key_init_ready     )
671:   );
672: 
673:   // We only use clean and unused IVs. Either software/counter has updated
674:   // - all IV registers, or
675:   // - none of the IV registers but the registers were updated in the past
676:   // and this particular IV has not yet been used.
677:   aes_reg_status #(
678:     .Width ( $bits(iv_we_o) )
679:   ) u_reg_status_iv (
680:     .clk_i       ( clk_i    ),
681:     .rst_ni      ( rst_ni   ),
682:     .we_i        ( iv_we_o  ),
683:     .use_i       ( iv_load  ),
684:     .clear_i     ( iv_clear ),
685:     .arm_i       ( iv_arm   ),
686:     .new_o       ( iv_ready ),
687:     .new_pulse_o (          ),
688:     .clean_o     (          )
689:   );
690: 
691:   // Input and output data register status tracking detects if:
692:   // - A complete new data input block is available, and
693:   // - An output data block has been read completely.
694:   // The status tracking needs to be cleared upon writes to the control register. The clearing is
695:   // applied one cycle later here to avoid zero-latency loops. This additional delay is not
696:   // relevant as if we are about to start encryption/decryption, we anyway don't allow writes
697:   // to the control register.
698:   always_ff @(posedge clk_i or negedge rst_ni) begin : reg_ctrl_we
699:     if (!rst_ni) begin
700:       ctrl_we_q <= 1'b0;
701:     end else begin
702:       ctrl_we_q <= ctrl_we_o;
703:     end
704:   end
705:   assign clear_in_out_status = ctrl_we_q;
706: 
707:   // Collect writes to data input registers. Cleared if:
708:   // - data is loaded into cipher core,
709:   // - clearing data input registers with random data (all data_in_qe_i bits high in next cycle),
710:   // - clearing the status tracking.
711:   assign data_in_new_d = data_in_load || &data_in_qe_i || clear_in_out_status ? '0 :
712:       data_in_new_q | data_in_qe_i;
713:   assign data_in_new   = &data_in_new_d;
714: 
715:   // Collect reads of data output registers. data_out_read is high for one clock cycle only and
716:   // clears output_valid_q unless new output is written in the exact same cycle. Cleared if:
717:   // - clearing data ouput registers with random data,
718:   // - clearing the status tracking.
719:   assign data_out_read_d = &data_out_read_q || clear_in_out_status ? '0 :
720:       data_out_read_q | data_out_re_i;
721:   assign data_out_read   = &data_out_read_d;
722: 
723:   always_ff @(posedge clk_i or negedge rst_ni) begin : reg_edge_detection
724:     if (!rst_ni) begin
725:       data_in_new_q   <= '0;
726:       data_out_read_q <= '0;
727:     end else begin
728:       data_in_new_q   <= data_in_new_d;
729:       data_out_read_q <= data_out_read_d;
730:     end
731:   end
732: 
733:   // Status register bits for data input and output
734:   // Cleared to 1 if:
735:   // - data is loaded into cipher core,
736:   // - clearing data input registers with random data,
737:   // - clearing the status tracking.
738:   assign input_ready    = ~data_in_new;
739:   assign input_ready_we =  data_in_new | data_in_load | data_in_we_o | clear_in_out_status;
740: 
741:   // Cleared if:
742:   // - all data output registers have been read (unless new output is written in the same cycle),
743:   // - clearing data ouput registers with random data,
744:   // - clearing the status tracking.
745:   assign output_valid    = data_out_we_o & ~data_out_clear_we;
746:   assign output_valid_we = data_out_we_o | data_out_read | data_out_clear_we |
747:       clear_in_out_status;
748: 
749:   always_ff @(posedge clk_i or negedge rst_ni) begin : reg_output_valid
750:     if (!rst_ni) begin
751:       output_valid_q <= '0;
752:     end else if (output_valid_we) begin
753:       output_valid_q <= output_valid;
754:     end
755:   end
756: 
757:   // Output lost status register bit
758:   // Cleared when updating the Control Register. Set when overwriting previous output data that has
759:   // not yet been read.
760:   assign output_lost    = ctrl_we_o     ? 1'b0 :
761:                           output_lost_i ? 1'b1 : output_valid_q & ~data_out_read;
762:   assign output_lost_we = ctrl_we_o | data_out_we_o;
763: 
764:   // Should fatal alerts clear the status and trigger register?
765:   assign clear_on_fatal = ClearStatusOnFatalAlert ? alert_fatal_i : 1'b0;
766: 
767:   /////////////////////
768:   // Status Register //
769:   /////////////////////
770:   assign idle_o            = clear_on_fatal ? 1'b0 : idle;
771:   assign idle_we_o         = clear_on_fatal ? 1'b1 : idle_we;
772:   assign stall_o           = clear_on_fatal ? 1'b0 : stall;
773:   assign stall_we_o        = clear_on_fatal ? 1'b1 : stall_we;
774:   assign output_lost_o     = clear_on_fatal ? 1'b0 : output_lost;
775:   assign output_lost_we_o  = clear_on_fatal ? 1'b1 : output_lost_we;
776:   assign output_valid_o    = clear_on_fatal ? 1'b0 : output_valid;
777:   assign output_valid_we_o = clear_on_fatal ? 1'b1 : output_valid_we;
778:   assign input_ready_o     = clear_on_fatal ? 1'b0 : input_ready;
779:   assign input_ready_we_o  = clear_on_fatal ? 1'b1 : input_ready_we;
780: 
781:   //////////////////////
782:   // Trigger Register //
783:   //////////////////////
784:   // Most triggers are only ever cleared by control. Fatal alerts clear all bits in the trigger
785:   // register.
786:   assign start_we_o                = clear_on_fatal ? 1'b1 : start_we;
787:   assign key_iv_data_in_clear_we_o = clear_on_fatal ? 1'b1 : key_iv_data_in_clear_we;
788:   assign data_out_clear_we_o       = clear_on_fatal ? 1'b1 : data_out_clear_we;
789: 
790:   // If configured, trigger the reseeding of the PRNGs used for clearing and masking purposes after
791:   // the key has been updated.
792:   assign prng_reseed_o    = clear_on_fatal     ? 1'b0 :
793:                             key_init_new_pulse ? 1'b1 : 1'b0;
794:   assign prng_reseed_we_o = clear_on_fatal     ? 1'b1                      :
795:                             key_init_new_pulse ? key_touch_forces_reseed_i : prng_reseed_we;
796: 
797:   ////////////////////////////
798:   // PRNG Reseeding Counter //
799:   ////////////////////////////
800:   // Count the number of blocks since the start of the message to determine when the masking PRNG
801:   // inside the cipher core needs to be reseeded.
802:   if (SecMasking) begin : gen_block_ctr
803:     logic                     block_ctr_set;
804:     logic [BlockCtrWidth-1:0] block_ctr_d, block_ctr_q;
805:     logic [BlockCtrWidth-1:0] block_ctr_set_val, block_ctr_decr_val;
806: 
807:     assign block_ctr_expr = block_ctr_q == '0;
808:     assign block_ctr_set  = ctrl_we_q | (block_ctr_decr & (block_ctr_expr | cipher_prng_reseed_i));
809: 
810:     assign block_ctr_set_val  = prng_reseed_rate_i == PER_1  ? '0                   :
811:                                 prng_reseed_rate_i == PER_64 ? BlockCtrWidth'(63)   :
812:                                 prng_reseed_rate_i == PER_8K ? BlockCtrWidth'(8191) : '0;
813: 
814:     assign block_ctr_decr_val = block_ctr_q - BlockCtrWidth'(1);
815: 
816:     assign block_ctr_d = block_ctr_set  ? block_ctr_set_val  :
817:                          block_ctr_decr ? block_ctr_decr_val : block_ctr_q;
818: 
819:     always_ff @(posedge clk_i or negedge rst_ni) begin : reg_block_ctr
820:       if (!rst_ni) begin
821:         block_ctr_q <= '0;
822:       end else begin
823:         block_ctr_q <= block_ctr_d;
824:       end
825:     end
826: 
827:   end else begin : gen_no_block_ctr
828:     assign block_ctr_expr = 1'b0;
829: 
830:     // Tie off unused signals.
831:     logic      unused_block_ctr_decr;
832:     prs_rate_e unused_prng_reseed_rate;
833:     logic      unused_cipher_prng_reseed;
834:     assign unused_block_ctr_decr     = block_ctr_decr;
835:     assign unused_prng_reseed_rate   = prng_reseed_rate_i;
836:     assign unused_cipher_prng_reseed = cipher_prng_reseed_i;
837:   end
838: 
839:   ////////////////
840:   // Assertions //
841:   ////////////////
842: 
843:   // Create a lint error to reduce the risk of accidentally disabling the masking.
844:   `ASSERT_STATIC_LINT_ERROR(AesControlFsmSecMaskingNonDefault, SecMasking == 1)
845: 
846:   // Selectors must be known/valid
847:   `ASSERT(AesModeValid, !ctrl_err_storage_i |-> mode_i inside {
848:       AES_ECB,
849:       AES_CBC,
850:       AES_CFB,
851:       AES_OFB,
852:       AES_CTR,
853:       AES_NONE
854:       })
855:   `ASSERT(AesOpValid, !ctrl_err_storage_i |-> op_i inside {
856:       AES_ENC,
857:       AES_DEC
858:       })
859:   `ASSERT(AesCiphOpValid, !cipher_op_err |-> cipher_op_i inside {
860:       CIPH_FWD,
861:       CIPH_INV
862:       })
863:   `ASSERT(AesControlStateValid, !alert_o |-> aes_ctrl_cs inside {
864:       CTRL_IDLE,
865:       CTRL_LOAD,
866:       CTRL_PRNG_UPDATE,
867:       CTRL_PRNG_RESEED,
868:       CTRL_FINISH,
869:       CTRL_CLEAR_I,
870:       CTRL_CLEAR_CO
871:       })
872: 
873:   // Check parameters
874:   `ASSERT_INIT(AesNumSlicesCtr, NumSlicesCtr == 8)
875: 
876: endmodule

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_xpM83eGvFW371ImBTMr5qabr)
 Call ID: call_xpM83eGvFW371ImBTMr5qabr
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes/rtl/aes_pkg.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // AES package
6: 
7: package aes_pkg;
8: 
9: // If this parameter is set, fatal alerts clear all status and trigger bits to zero. By
10: // default, it's not set, i.e., no clearing is happening, in order to simplify debugging.
11: parameter bit ClearStatusOnFatalAlert = 1'b0;
12: 
13: // The initial key is always provided in two shares, independently whether the cipher core is
14: // masked or not.
15: parameter int unsigned NumSharesKey = 2;
16: 
17: // Software updates IV in chunks of 32 bits, the counter updates 16 bits at a time.
18: parameter int unsigned SliceSizeCtr = 16;
19: parameter int unsigned NumSlicesCtr = aes_reg_pkg::NumRegsIv * 32 / SliceSizeCtr;
20: parameter int unsigned SliceIdxWidth = prim_util_pkg::vbits(NumSlicesCtr);
21: 
22: // Widths of signals carrying pseudo-random data for clearing
23: parameter int unsigned WidthPRDClearing = 64;
24: parameter int unsigned NumChunksPRDClearing128 = 128/WidthPRDClearing;
25: parameter int unsigned NumChunksPRDClearing256 = 256/WidthPRDClearing;
26: 
27: // Widths of signals carrying pseudo-random data for masking
28: parameter int unsigned WidthPRDSBox     = 8;  // Number PRD bits per S-Box. This includes the
29:                                               // 8 bits for the output mask when using any of the
30:                                               // masked Canright S-Box implementations.
31: parameter int unsigned WidthPRDData     = 16*WidthPRDSBox; // 16 S-Boxes for the data path
32: parameter int unsigned WidthPRDKey      = 4*WidthPRDSBox;  // 4 S-Boxes for the key expand
33: parameter int unsigned WidthPRDMasking  = WidthPRDData + WidthPRDKey;
34: 
35: // Clearing PRNG default LFSR seed and permutation
36: // These LFSR parameters have been generated with
37: // $ util/design/gen-lfsr-seed.py --width 64 --seed 31468618 --prefix "Clearing"
38: parameter int ClearingLfsrWidth = 64;
39: typedef logic [ClearingLfsrWidth-1:0] clearing_lfsr_seed_t;
40: typedef logic [ClearingLfsrWidth-1:0][$clog2(ClearingLfsrWidth)-1:0] clearing_lfsr_perm_t;
41: parameter clearing_lfsr_seed_t RndCnstClearingLfsrSeedDefault = 64'hc32d580f74f1713a;
42: parameter clearing_lfsr_perm_t RndCnstClearingLfsrPermDefault = {
43:   128'hb33fdfc81deb6292c21f8a3102585067,
44:   256'h9c2f4be1bbe937b4b7c9d7f4e57568d99c8ae291a899143e0d8459d31b143223
45: };
46: // A second permutation is needed for the second share.
47: parameter clearing_lfsr_perm_t RndCnstClearingSharePermDefault = {
48:   128'hf66fd61b27847edc2286706fb3a2e900,
49:   256'h9736b95ac3f3b5205caf8dc536aad73605d393c8dd94476e830e97891d4828d0
50: };
51: 
52: // Masking PRNG default state seed and output permutation
53: // The output width is 160 bits (WidthPRDMasking = WidthPRDSBox * (16 + 4)).
54: // These LFSR parameters have been generated with
55: // $ util/design/gen-lfsr-seed.py --width 160 --seed 31468618 --prefix "Masking"
56: parameter int MaskingLfsrWidth = 160; // = WidthPRDMasking = WidthPRDSBox * (16 + 4)
57: typedef logic [MaskingLfsrWidth-1:0][$clog2(MaskingLfsrWidth)-1:0] masking_lfsr_perm_t;
58: parameter masking_lfsr_perm_t RndCnstMaskingLfsrPermDefault = {
59:   256'h17261943423e4c5c03872194050c7e5f8497081d96666d406f4b606473303469,
60:   256'h8e7c721c8832471f59919e0b128f067b25622768462e554d8970815d490d7f44,
61:   256'h048c867d907a239b20220f6c79071a852d76485452189f14091b1e744e396737,
62:   256'h4f785b772b352f6550613c58130a8b104a3f28019c9a380233956b00563a512c,
63:   256'h808d419d63982a16995e0e3b57826a36718a9329452492533d83115a75316e15
64: };
65: // The state width is 177 bits (Bivium) but the primitive expects a 288-bit seed (Trivium).
66: // These LFSR parameters have been generated with
67: // $ util/design/gen-lfsr-seed.py --width 288 --seed 31468618 --prefix "Masking"
68: parameter int MaskingPrngStateWidth = 288;
69: typedef logic [MaskingPrngStateWidth-1:0] masking_lfsr_seed_t;
70: parameter masking_lfsr_seed_t RndCnstMaskingLfsrSeedDefault = {
71:   32'h758a4420,
72:   256'h31e1c461_6ea343ec_153282a3_0c132b57_23c5a4cf_4743b3c7_c32d580f_74f1713a
73: };
74: 
75: typedef enum integer {
76:   SBoxImplLut,                   // Unmasked LUT-based S-Box
77:   SBoxImplCanright,              // Unmasked Canright S-Box, see aes_sbox_canright.sv
78:   SBoxImplCanrightMasked,        // First-order masked Canright S-Box
79:                                  // see aes_sbox_canright_masked.sv
80:   SBoxImplCanrightMaskedNoreuse, // First-order masked Canright S-Box without mask reuse,
81:                                  // see aes_sbox_canright_masked_noreuse.sv
82:   SBoxImplDom                    // First-order masked S-Box using domain-oriented masking,
83:                                  // see aes_sbox_canright_dom.sv
84: } sbox_impl_e;
85: 
86: 
87: // Parameters used for controlgroups in the coverage
88: parameter int AES_OP_WIDTH             = 2;
89: parameter int AES_MODE_WIDTH           = 6;
90: parameter int AES_KEYLEN_WIDTH         = 3;
91: parameter int AES_PRNGRESEEDRATE_WIDTH = 3;
92: 
93: // SEC_CM: MAIN.CONFIG.SPARSE
94: typedef enum logic [AES_OP_WIDTH-1:0] {
95:   AES_ENC = 2'b01,
96:   AES_DEC = 2'b10
97: } aes_op_e;
98: 
99: // SEC_CM: MAIN.CONFIG.SPARSE
100: typedef enum logic [AES_MODE_WIDTH-1:0] {
101:   AES_ECB  = 6'b00_0001,
102:   AES_CBC  = 6'b00_0010,
103:   AES_CFB  = 6'b00_0100,
104:   AES_OFB  = 6'b00_1000,
105:   AES_CTR  = 6'b01_0000,
106:   AES_NONE = 6'b10_0000
107: } aes_mode_e;
108: 
109: typedef enum logic [AES_OP_WIDTH-1:0] {
110:   CIPH_FWD = 2'b01,
111:   CIPH_INV = 2'b10
112: } ciph_op_e;
113: 
114: // SEC_CM: MAIN.CONFIG.SPARSE
115: typedef enum logic [AES_KEYLEN_WIDTH-1:0] {
116:   AES_128 = 3'b001,
117:   AES_192 = 3'b010,
118:   AES_256 = 3'b100
119: } key_len_e;
120: 
121: // SEC_CM: MAIN.CONFIG.SPARSE
122: typedef enum logic [AES_PRNGRESEEDRATE_WIDTH-1:0] {
123:   PER_1  = 3'b001,
124:   PER_64 = 3'b010,
125:   PER_8K = 3'b100
126: } prs_rate_e;
127: parameter int unsigned BlockCtrWidth = 13;
128: 
129: typedef struct packed {
130:   logic [31:7] unused;
131:   logic        alert_fatal_fault;
132:   logic        alert_recov_ctrl_update_err;
133:   logic        input_ready;
134:   logic        output_valid;
135:   logic        output_lost;
136:   logic        stall;
137:   logic        idle;
138: } status_t;
139: 
140: typedef struct packed {
141:   logic        recov_ctrl_update_err;
142:   logic        fatal_fault;
143: } alert_test_t;
144: 
145:   // Sparse state encodings
146: 
147:   // Encoding generated with:
148:   // $ ./util/design/sparse-fsm-encode.py -d 3 -m 8 -n 6 \
149:   //      -s 31468618 --language=sv
150:   //
151:   // Hamming distance histogram:
152:   //
153:   //  0: --
154:   //  1: --
155:   //  2: --
156:   //  3: |||||||||||||||||||| (57.14%)
157:   //  4: ||||||||||||||| (42.86%)
158:   //  5: --
159:   //  6: --
160:   //
161:   // Minimum Hamming distance: 3
162:   // Maximum Hamming distance: 4
163:   // Minimum Hamming weight: 1
164:   // Maximum Hamming weight: 5
165:   //
166:   localparam int CipherCtrlStateWidth = 6;
167:   typedef enum logic [CipherCtrlStateWidth-1:0] {
168:     CIPHER_CTRL_IDLE        = 6'b001001,
169:     CIPHER_CTRL_INIT        = 6'b100011,
170:     CIPHER_CTRL_ROUND       = 6'b111101,
171:     CIPHER_CTRL_FINISH      = 6'b010000,
172:     CIPHER_CTRL_PRNG_RESEED = 6'b100100,
173:     CIPHER_CTRL_CLEAR_S     = 6'b111010,
174:     CIPHER_CTRL_CLEAR_KD    = 6'b001110,
175:     CIPHER_CTRL_ERROR       = 6'b010111
176:   } aes_cipher_ctrl_e;
177: 
178:   // $ ./sparse-fsm-encode.py -d 3 -m 3 -n 5 \
179:   //      -s 31468618 --language=sv
180:   //
181:   // Hamming distance histogram:
182:   //
183:   //  0: --
184:   //  1: --
185:   //  2: --
186:   //  3: |||||||||||||||||||| (66.67%)
187:   //  4: |||||||||| (33.33%)
188:   //  5: --
189:   //
190:   // Minimum Hamming distance: 3
191:   // Maximum Hamming distance: 4
192:   //
193:   localparam int CtrStateWidth = 5;
194:   typedef enum logic [CtrStateWidth-1:0] {
195:     CTR_IDLE  = 5'b01110,
196:     CTR_INCR  = 5'b11000,
197:     CTR_ERROR = 5'b00001
198:   } aes_ctr_e;
199: 
200:   // Encoding generated with:
201:   // $ ./util/design/sparse-fsm-encode.py -d 3 -m 8 -n 6 \
202:   //      -s 31468618 --language=sv
203:   //
204:   // Hamming distance histogram:
205:   //
206:   //  0: --
207:   //  1: --
208:   //  2: --
209:   //  3: |||||||||||||||||||| (57.14%)
210:   //  4: ||||||||||||||| (42.86%)
211:   //  5: --
212:   //  6: --
213:   //
214:   // Minimum Hamming distance: 3
215:   // Maximum Hamming distance: 4
216:   // Minimum Hamming weight: 1
217:   // Maximum Hamming weight: 5
218:   //
219:   localparam int CtrlStateWidth = 6;
220:   typedef enum logic [CtrlStateWidth-1:0] {
221:     CTRL_IDLE        = 6'b001001,
222:     CTRL_LOAD        = 6'b100011,
223:     CTRL_PRNG_UPDATE = 6'b111101,
224:     CTRL_PRNG_RESEED = 6'b010000,
225:     CTRL_FINISH      = 6'b100100,
226:     CTRL_CLEAR_I     = 6'b111010,
227:     CTRL_CLEAR_CO    = 6'b001110,
228:     CTRL_ERROR       = 6'b010111
229:   } aes_ctrl_e;
230: 
231: // Generic, sparse mux selector encodings
232: 
233: // Encoding generated with:
234: // $ ./util/design/sparse-fsm-encode.py -d 3 -m 2 -n 3 \
235: //      -s 31468618 --language=sv
236: //
237: // Hamming distance histogram:
238: //
239: //  0: --
240: //  1: --
241: //  2: --
242: //  3: |||||||||||||||||||| (100.00%)
243: //
244: // Minimum Hamming distance: 3
245: // Maximum Hamming distance: 3
246: // Minimum Hamming weight: 1
247: // Maximum Hamming weight: 2
248: //
249: parameter int Mux2SelWidth = 3;
250: typedef enum logic [Mux2SelWidth-1:0] {
251:   MUX2_SEL_0 = 3'b011,
252:   MUX2_SEL_1 = 3'b100
253: } mux2_sel_e;
254: 
255: // Encoding generated with:
256: // $ ./sparse-fsm-encode.py -d 3 -m 3 -n 5 \
257: //      -s 31468618 --language=sv
258: //
259: // Hamming distance histogram:
260: //
261: //  0: --
262: //  1: --
263: //  2: --
264: //  3: |||||||||||||||||||| (66.67%)
265: //  4: |||||||||| (33.33%)
266: //  5: --
267: //
268: // Minimum Hamming distance: 3
269: // Maximum Hamming distance: 4
270: //
271: parameter int Mux3SelWidth = 5;
272: typedef enum logic [Mux3SelWidth-1:0] {
273:   MUX3_SEL_0 = 5'b01110,
274:   MUX3_SEL_1 = 5'b11000,
275:   MUX3_SEL_2 = 5'b00001
276: } mux3_sel_e;
277: 
278: // Encoding generated with:
279: // $ ./sparse-fsm-encode.py -d 3 -m 4 -n 5 \
280: //      -s 31468618 --language=sv
281: //
282: // Hamming distance histogram:
283: //
284: //  0: --
285: //  1: --
286: //  2: --
287: //  3: |||||||||||||||||||| (66.67%)
288: //  4: |||||||||| (33.33%)
289: //  5: --
290: //
291: // Minimum Hamming distance: 3
292: // Maximum Hamming distance: 4
293: //
294: parameter int Mux4SelWidth = 5;
295: typedef enum logic [Mux4SelWidth-1:0] {
296:   MUX4_SEL_0 = 5'b01110,
297:   MUX4_SEL_1 = 5'b11000,
298:   MUX4_SEL_2 = 5'b00001,
299:   MUX4_SEL_3 = 5'b10111
300: } mux4_sel_e;
301: 
302: // $ ./sparse-fsm-encode.py -d 3 -m 6 -n 6 \
303: //      -s 31468618 --language=sv
304: //
305: // Hamming distance histogram:
306: //
307: //  0: --
308: //  1: --
309: //  2: --
310: //  3: |||||||||||||||||||| (53.33%)
311: //  4: ||||||||||||||| (40.00%)
312: //  5: || (6.67%)
313: //  6: --
314: //
315: // Minimum Hamming distance: 3
316: // Maximum Hamming distance: 5
317: //
318: parameter int Mux6SelWidth = 6;
319: typedef enum logic [Mux6SelWidth-1:0] {
320:   MUX6_SEL_0 = 6'b011101,
321:   MUX6_SEL_1 = 6'b110000,
322:   MUX6_SEL_2 = 6'b001000,
323:   MUX6_SEL_3 = 6'b000011,
324:   MUX6_SEL_4 = 6'b111110,
325:   MUX6_SEL_5 = 6'b100101
326: } mux6_sel_e;
327: 
328: // Mux selector signal types. These use the generic types defined above.
329: 
330: parameter int DIPSelNum = 2;
331: parameter int DIPSelWidth = Mux2SelWidth;
332: typedef enum logic [DIPSelWidth-1:0] {
333:   DIP_DATA_IN = MUX2_SEL_0,
334:   DIP_CLEAR   = MUX2_SEL_1
335: } dip_sel_e;
336: 
337: parameter int SISelNum = 2;
338: parameter int SISelWidth = Mux2SelWidth;
339: typedef enum logic [SISelWidth-1:0] {
340:   SI_ZERO = MUX2_SEL_0,
341:   SI_DATA = MUX2_SEL_1
342: } si_sel_e;
343: 
344: parameter int AddSISelNum = 2;
345: parameter int AddSISelWidth = Mux2SelWidth;
346: typedef enum logic [AddSISelWidth-1:0] {
347:   ADD_SI_ZERO = MUX2_SEL_0,
348:   ADD_SI_IV   = MUX2_SEL_1
349: } add_si_sel_e;
350: 
351: parameter int StateSelNum = 3;
352: parameter int StateSelWidth = Mux3SelWidth;
353: typedef enum logic [StateSelWidth-1:0] {
354:   STATE_INIT  = MUX3_SEL_0,
355:   STATE_ROUND = MUX3_SEL_1,
356:   STATE_CLEAR = MUX3_SEL_2
357: } state_sel_e;
358: 
359: parameter int AddRKSelNum = 3;
360: parameter int AddRKSelWidth = Mux3SelWidth;
361: typedef enum logic [AddRKSelWidth-1:0] {
362:   ADD_RK_INIT  = MUX3_SEL_0,
363:   ADD_RK_ROUND = MUX3_SEL_1,
364:   ADD_RK_FINAL = MUX3_SEL_2
365: } add_rk_sel_e;
366: 
367: parameter int KeyInitSelNum = 3;
368: parameter int KeyInitSelWidth = Mux3SelWidth;
369: typedef enum logic [KeyInitSelWidth-1:0] {
370:   KEY_INIT_INPUT  = MUX3_SEL_0,
371:   KEY_INIT_KEYMGR = MUX3_SEL_1,
372:   KEY_INIT_CLEAR  = MUX3_SEL_2
373: } key_init_sel_e;
374: 
375: parameter int IVSelNum = 6;
376: parameter int IVSelWidth = Mux6SelWidth;
377: typedef enum logic [IVSelWidth-1:0] {
378:   IV_INPUT        = MUX6_SEL_0,
379:   IV_DATA_OUT     = MUX6_SEL_1,
380:   IV_DATA_OUT_RAW = MUX6_SEL_2,
381:   IV_DATA_IN_PREV = MUX6_SEL_3,
382:   IV_CTR          = MUX6_SEL_4,
383:   IV_CLEAR        = MUX6_SEL_5
384: } iv_sel_e;
385: 
386: parameter int KeyFullSelNum = 4;
387: parameter int KeyFullSelWidth = Mux4SelWidth;
388: typedef enum logic [KeyFullSelWidth-1:0] {
389:   KEY_FULL_ENC_INIT = MUX4_SEL_0,
390:   KEY_FULL_DEC_INIT = MUX4_SEL_1,
391:   KEY_FULL_ROUND    = MUX4_SEL_2,
392:   KEY_FULL_CLEAR    = MUX4_SEL_3
393: } key_full_sel_e;
394: 
395: parameter int KeyDecSelNum = 2;
396: parameter int KeyDecSelWidth = Mux2SelWidth;
397: typedef enum logic [KeyDecSelWidth-1:0] {
398:   KEY_DEC_EXPAND = MUX2_SEL_0,
399:   KEY_DEC_CLEAR  = MUX2_SEL_1
400: } key_dec_sel_e;
401: 
402: parameter int KeyWordsSelNum = 4;
403: parameter int KeyWordsSelWidth = Mux4SelWidth;
404: typedef enum logic [KeyWordsSelWidth-1:0] {
405:   KEY_WORDS_0123 = MUX4_SEL_0,
406:   KEY_WORDS_2345 = MUX4_SEL_1,
407:   KEY_WORDS_4567 = MUX4_SEL_2,
408:   KEY_WORDS_ZERO = MUX4_SEL_3
409: } key_words_sel_e;
410: 
411: parameter int RoundKeySelNum = 2;
412: parameter int RoundKeySelWidth = Mux2SelWidth;
413: typedef enum logic [RoundKeySelWidth-1:0] {
414:   ROUND_KEY_DIRECT = MUX2_SEL_0,
415:   ROUND_KEY_MIXED  = MUX2_SEL_1
416: } round_key_sel_e;
417: 
418: parameter int AddSOSelNum = 3;
419: parameter int AddSOSelWidth = Mux3SelWidth;
420: typedef enum logic [AddSOSelWidth-1:0] {
421:   ADD_SO_ZERO = MUX3_SEL_0,
422:   ADD_SO_IV   = MUX3_SEL_1,
423:   ADD_SO_DIP  = MUX3_SEL_2
424: } add_so_sel_e;
425: 
426: // Sparse two-value signal type sp2v_e
427: parameter int Sp2VNum = 2;
428: parameter int Sp2VWidth = Mux2SelWidth;
429: typedef enum logic [Sp2VWidth-1:0] {
430:   SP2V_HIGH = MUX2_SEL_0,
431:   SP2V_LOW  = MUX2_SEL_1
432: } sp2v_e;
433: 
434: typedef logic [Sp2VWidth-1:0] sp2v_logic_t;
435: parameter sp2v_logic_t SP2V_LOGIC_HIGH = {SP2V_HIGH};
436: 
437: // Control register type
438: typedef struct packed {
439:   logic      manual_operation;
440:   prs_rate_e prng_reseed_rate;
441:   logic      sideload;
442:   key_len_e  key_len;
443:   aes_mode_e mode;
444:   aes_op_e   operation;
445: } ctrl_reg_t;
446: 
447: parameter ctrl_reg_t CTRL_RESET = '{
448:   manual_operation: aes_reg_pkg::AES_CTRL_SHADOWED_MANUAL_OPERATION_RESVAL,
449:   prng_reseed_rate: prs_rate_e'(aes_reg_pkg::AES_CTRL_SHADOWED_PRNG_RESEED_RATE_RESVAL),
450:   sideload:         aes_reg_pkg::AES_CTRL_SHADOWED_SIDELOAD_RESVAL,
451:   key_len:          key_len_e'(aes_reg_pkg::AES_CTRL_SHADOWED_KEY_LEN_RESVAL),
452:   mode:             aes_mode_e'(aes_reg_pkg::AES_CTRL_SHADOWED_MODE_RESVAL),
453:   operation:        aes_op_e'(aes_reg_pkg::AES_CTRL_SHADOWED_OPERATION_RESVAL)
454: };
455: 
456: // Multiplication by {02} (i.e. x) on GF(2^8)
457: // with field generating polynomial {01}{1b} (9'h11b)
458: // Sometimes also denoted by xtime().
459: function automatic logic [7:0] aes_mul2(logic [7:0] in);
460:   logic [7:0] out;
461:   out[7] = in[6];
462:   out[6] = in[5];
463:   out[5] = in[4];
464:   out[4] = in[3] ^ in[7];
465:   out[3] = in[2] ^ in[7];
466:   out[2] = in[1];
467:   out[1] = in[0] ^ in[7];
468:   out[0] = in[7];
469:   return out;
470: endfunction
471: 
472: // Multiplication by {04} (i.e. x^2) on GF(2^8)
473: // with field generating polynomial {01}{1b} (9'h11b)
474: function automatic logic [7:0] aes_mul4(logic [7:0] in);
475:   return aes_mul2(aes_mul2(in));
476: endfunction
477: 
478: // Division by {02} (i.e. x) on GF(2^8)
479: // with field generating polynomial {01}{1b} (9'h11b)
480: // This is the inverse of aes_mul2() or xtime().
481: function automatic logic [7:0] aes_div2(logic [7:0] in);
482:   logic [7:0] out;
483:   out[7] = in[0];
484:   out[6] = in[7];
485:   out[5] = in[6];
486:   out[4] = in[5];
487:   out[3] = in[4] ^ in[0];
488:   out[2] = in[3] ^ in[0];
489:   out[1] = in[2];
490:   out[0] = in[1] ^ in[0];
491:   return out;
492: endfunction
493: 
494: // Circular byte shift to the left
495: function automatic logic [31:0] aes_circ_byte_shift(logic [31:0] in, logic [1:0] shift);
496:   logic [31:0] out;
497:   logic [31:0] s;
498:   s = {30'b0,shift};
499:   out = {in[8*((7-s)%4) +: 8], in[8*((6-s)%4) +: 8],
500:          in[8*((5-s)%4) +: 8], in[8*((4-s)%4) +: 8]};
501:   return out;
502: endfunction
503: 
504: // Transpose state matrix
505: function automatic logic [3:0][3:0][7:0] aes_transpose(logic [3:0][3:0][7:0] in);
506:   logic [3:0][3:0][7:0] transpose;
507:   transpose = '0;
508:   for (int j = 0; j < 4; j++) begin
509:     for (int i = 0; i < 4; i++) begin
510:       transpose[i][j] = in[j][i];
511:     end
512:   end
513:   return transpose;
514: endfunction
515: 
516: // Extract single column from state matrix
517: function automatic logic [3:0][7:0] aes_col_get(logic [3:0][3:0][7:0] in, logic [1:0] idx);
518:   logic [3:0][7:0] out;
519:   for (int i = 0; i < 4; i++) begin
520:     out[i] = in[i][idx];
521:   end
522:   return out;
523: endfunction
524: 
525: // Matrix-vector multiplication in GF(2^8): c = A * b
526: function automatic logic [7:0] aes_mvm(
527:   logic [7:0] vec_b,
528:   logic [7:0] mat_a [8]
529: );
530:   logic [7:0] vec_c;
531:   vec_c = '0;
532:   for (int i = 0; i < 8; i++) begin
533:     for (int j = 0; j < 8; j++) begin
534:       vec_c[i] = vec_c[i] ^ (mat_a[j][i] & vec_b[7-j]);
535:     end
536:   end
537:   return vec_c;
538: endfunction
539: 
540: // Rotate integer indices
541: function automatic integer aes_rot_int(integer in, integer num);
542:   integer out;
543:   if (in == 0) begin
544:     out = num - 1;
545:   end else begin
546:     out = in - 1;
547:   end
548:   return out;
549: endfunction
550: 
551: // Function for extracting LSBs of the per-S-Box pseudo-random data (PRD) from the output of the
552: // masking PRNG.
553: //
554: // The masking PRNG is used for generating both the PRD for the S-Boxes/SubBytes operation as
555: // well as for the input data masks. When using any of the masked Canright S-Box implementations,
556: // it is important that the SubBytes input masks (generated by the PRNG in Round X-1) and the
557: // SubBytes output masks (generated by the PRNG in Round X) are independent. This can be achieved
558: // by using e.g. an unrolled Bivium stream cipher primitive inside the PRNG. Since the input data
559: // masks become the SubBytes input masks in the first round, we select the same 8 bit lanes for the
560: // input data masks which are also used to form the SubBytes output mask for the masked Canright
561: // S-Box implementations, i.e., the 8 LSBs of the per S-Box PRD. In particular, we have:
562: //
563: // prng_output = { prd_key_expand, ... , sb_prd[4], sb_out_mask[4], sb_prd[0], sb_out_mask[0] }
564: //
565: // Where sb_out_mask[x] contains the SubBytes output mask for byte x (when using a masked
566: // Canright S-Box implementation) and sb_prd[x] contains additional PRD consumed by SubBytes for
567: // byte x.
568: //
569: // When using a masked S-Box implementation other than Canright, we still select the 8 LSBs of
570: // the per-S-Box PRD to form the input data mask of the corresponding byte. We do this to
571: // distribute the input data masks over all output bits the masking PRNG.
572: 
573: // For one row of the state matrix, extract the 8 LSBs of the per-S-Box PRD from the PRNG output.
574: // These bits are used as:
575: // - input data masks, and
576: // - SubBytes output mask when using a masked Canright S-Box implementation.
577: function automatic logic [3:0][7:0] aes_prd_get_lsbs(
578:   logic [(4*WidthPRDSBox)-1:0] in
579: );
580:   logic [3:0][7:0] prd_lsbs;
581:   for (int i = 0; i < 4; i++) begin
582:     prd_lsbs[i] = in[i*WidthPRDSBox +: 8];
583:   end
584:   return prd_lsbs;
585: endfunction
586: 
587: endpackage

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_TVpWkEUZqONA2dzlNyGxYqVS)
 Call ID: call_TVpWkEUZqONA2dzlNyGxYqVS
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes/rtl/aes.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // AES top-level wrapper
6: 
7: `include "prim_assert.sv"
8: 
9: module aes
10:   import aes_pkg::*;
11:   import aes_reg_pkg::*;
12: #(
13:   parameter bit          AES192Enable          = 1, // Can be 0 (disable), or 1 (enable).
14:   parameter bit          SecMasking            = 1, // Can be 0 (no masking), or
15:                                                     // 1 (first-order masking) of the cipher
16:                                                     // core. Masking requires the use of a
17:                                                     // masked S-Box, see SecSBoxImpl parameter.
18:   parameter sbox_impl_e  SecSBoxImpl           = SBoxImplDom, // See aes_pkg.sv
19:   parameter int unsigned SecStartTriggerDelay  = 0, // Manual start trigger delay, useful for
20:                                                     // SCA measurements. A value of e.g. 40
21:                                                     // allows the processor to go into sleep
22:                                                     // before AES starts operation.
23:   parameter bit          SecAllowForcingMasks  = 0, // Allow forcing masks to constant values using
24:                                                     // FORCE_MASKS bit in Auxiliary Control
25:                                                     // Register. Useful for SCA only.
26:   parameter bit          SecSkipPRNGReseeding  = 0, // The current SCA setup doesn't provide enough
27:                                                     // resources to implement the infrastucture
28:                                                     // required for PRNG reseeding (CSRNG, EDN).
29:                                                     // To enable SCA resistance evaluations, we
30:                                                     // need to skip reseeding requests.
31:                                                     // Useful for SCA only.
32:   parameter logic [NumAlerts-1:0] AlertAsyncOn = {NumAlerts{1'b1}},
33:   parameter clearing_lfsr_seed_t RndCnstClearingLfsrSeed  = RndCnstClearingLfsrSeedDefault,
34:   parameter clearing_lfsr_perm_t RndCnstClearingLfsrPerm  = RndCnstClearingLfsrPermDefault,
35:   parameter clearing_lfsr_perm_t RndCnstClearingSharePerm = RndCnstClearingSharePermDefault,
36:   parameter masking_lfsr_seed_t  RndCnstMaskingLfsrSeed   = RndCnstMaskingLfsrSeedDefault,
37:   parameter masking_lfsr_perm_t  RndCnstMaskingLfsrPerm   = RndCnstMaskingLfsrPermDefault
38: ) (
39:   input  logic                                      clk_i,
40:   input  logic                                      rst_ni,
41:   input  logic                                      rst_shadowed_ni,
42: 
43:   // Idle indicator for clock manager
44:   output prim_mubi_pkg::mubi4_t                     idle_o,
45: 
46:   // Life cycle
47:   input  lc_ctrl_pkg::lc_tx_t                       lc_escalate_en_i,
48: 
49:   // Entropy distribution network (EDN) interface
50:   input  logic                                      clk_edn_i,
51:   input  logic                                      rst_edn_ni,
52:   output edn_pkg::edn_req_t                         edn_o,
53:   input  edn_pkg::edn_rsp_t                         edn_i,
54: 
55:   // Key manager (keymgr) key sideload interface
56:   input  keymgr_pkg::hw_key_req_t                   keymgr_key_i,
57: 
58:   // Bus interface
59:   input  tlul_pkg::tl_h2d_t                         tl_i,
60:   output tlul_pkg::tl_d2h_t                         tl_o,
61: 
62:   // Alerts
63:   input  prim_alert_pkg::alert_rx_t [NumAlerts-1:0] alert_rx_i,
64:   output prim_alert_pkg::alert_tx_t [NumAlerts-1:0] alert_tx_o
65: );
66: 
67:   localparam int unsigned EntropyWidth = edn_pkg::ENDPOINT_BUS_WIDTH;
68: 
69:   // Signals
70:   aes_reg2hw_t               reg2hw;
71:   aes_hw2reg_t               hw2reg;
72: 
73:   logic      [NumAlerts-1:0] alert;
74:   lc_ctrl_pkg::lc_tx_t       lc_escalate_en;
75: 
76:   logic                      edn_req_int;
77:   logic                      edn_req_hold_d, edn_req_hold_q;
78:   logic                      edn_req;
79:   logic                      edn_ack;
80:   logic   [EntropyWidth-1:0] edn_data;
81:   logic                      unused_edn_fips;
82:   logic                      entropy_clearing_req, entropy_masking_req;
83:   logic                      entropy_clearing_ack, entropy_masking_ack;
84: 
85:   ////////////
86:   // Inputs //
87:   ////////////
88: 
89:   // SEC_CM: BUS.INTEGRITY
90:   // SEC_CM: AUX.CONFIG.SHADOW
91:   // SEC_CM: AUX.CONFIG.REGWEN
92:   // SEC_CM: KEY.SW_UNREADABLE
93:   // SEC_CM: DATA_REG.SW_UNREADABLE
94:   // Register interface
95:   logic intg_err_alert;
96:   logic shadowed_storage_err, shadowed_update_err;
97:   aes_reg_top u_reg (
98:     .clk_i,
99:     .rst_ni,
100:     .rst_shadowed_ni,
101:     .tl_i,
102:     .tl_o,
103:     .reg2hw,
104:     .hw2reg,
105:     .shadowed_storage_err_o(shadowed_storage_err),
106:     .shadowed_update_err_o(shadowed_update_err),
107:     .intg_err_o(intg_err_alert)
108:   );
109: 
110:   // SEC_CM: LC_ESCALATE_EN.INTERSIG.MUBI
111:   // Synchronize life cycle input
112:   prim_lc_sync #(
113:     .NumCopies (1)
114:   ) u_prim_lc_sync (
115:     .clk_i,
116:     .rst_ni,
117:     .lc_en_i ( lc_escalate_en_i ),
118:     .lc_en_o ( {lc_escalate_en} )
119:   );
120: 
121:   ///////////////////
122:   // EDN Interface //
123:   ///////////////////
124: 
125:   // Internally, we have up to two PRNGs that share the EDN interface for reseeding. Here, we just
126:   // arbitrate the requests. Upsizing of the entropy to the correct width is performed inside the
127:   // PRNGs.
128:   // Reseed operations for the clearing PRNG are initiated by software. Reseed operations for the
129:   // masking PRNG can also be automatically initiated.
130:   assign edn_req_int          = entropy_clearing_req | entropy_masking_req;
131:   // Only forward ACK to PRNG currently requesting entropy. Give higher priority to clearing PRNG.
132:   assign entropy_clearing_ack =  entropy_clearing_req & edn_ack;
133:   assign entropy_masking_ack  = ~entropy_clearing_req & entropy_masking_req & edn_ack;
134: 
135:   // Upon escalation or detection of a fatal alert, an EDN request signal can be dropped before
136:   // getting acknowledged. This is okay with respect to AES as the module will need to be reset
137:   // anyway. However, to not leave EDN in a strange state, we hold the request until it's actually
138:   // acknowledged.
139:   assign edn_req        = edn_req_int | edn_req_hold_q;
140:   assign edn_req_hold_d = (edn_req_hold_q | edn_req) & ~edn_ack;
141:   always_ff @(posedge clk_i or negedge rst_ni) begin : edn_req_reg
142:     if (!rst_ni) begin
143:       edn_req_hold_q <= '0;
144:     end else begin
145:       edn_req_hold_q <= edn_req_hold_d;
146:     end
147:   end
148: 
149:   // Synchronize EDN interface
150:   prim_sync_reqack_data #(
151:     .Width(EntropyWidth),
152:     .DataSrc2Dst(1'b0),
153:     .DataReg(1'b0)
154:   ) u_prim_sync_reqack_data (
155:     .clk_src_i  ( clk_i         ),
156:     .rst_src_ni ( rst_ni        ),
157:     .clk_dst_i  ( clk_edn_i     ),
158:     .rst_dst_ni ( rst_edn_ni    ),
159:     .req_chk_i  ( 1'b1          ),
160:     .src_req_i  ( edn_req       ),
161:     .src_ack_o  ( edn_ack       ),
162:     .dst_req_o  ( edn_o.edn_req ),
163:     .dst_ack_i  ( edn_i.edn_ack ),
164:     .data_i     ( edn_i.edn_bus ),
165:     .data_o     ( edn_data      )
166:   );
167:   // We don't track whether the entropy is pre-FIPS or not inside AES.
168:   assign unused_edn_fips = edn_i.edn_fips;
169: 
170:   //////////
171:   // Core //
172:   //////////
173: 
174:   // AES core
175:   aes_core #(
176:     .AES192Enable             ( AES192Enable             ),
177:     .SecMasking               ( SecMasking               ),
178:     .SecSBoxImpl              ( SecSBoxImpl              ),
179:     .SecStartTriggerDelay     ( SecStartTriggerDelay     ),
180:     .SecAllowForcingMasks     ( 1     ),
181:     .SecSkipPRNGReseeding     ( SecSkipPRNGReseeding     ),
182:     .EntropyWidth             ( EntropyWidth             ),
183:     .RndCnstClearingLfsrSeed  ( RndCnstClearingLfsrSeed  ),
184:     .RndCnstClearingLfsrPerm  ( RndCnstClearingLfsrPerm  ),
185:     .RndCnstClearingSharePerm ( RndCnstClearingSharePerm ),
186:     .RndCnstMaskingLfsrSeed   ( RndCnstMaskingLfsrSeed   ),
187:     .RndCnstMaskingLfsrPerm   ( RndCnstMaskingLfsrPerm   )
188:   ) u_aes_core (
189:     .clk_i                  ( clk_i                ),
190:     .rst_ni                 ( rst_ni               ),
191:     .rst_shadowed_ni        ( rst_shadowed_ni      ),
192:     .entropy_clearing_req_o ( entropy_clearing_req ),
193:     .entropy_clearing_ack_i ( entropy_clearing_ack ),
194:     .entropy_clearing_i     ( edn_data             ),
195:     .entropy_masking_req_o  ( entropy_masking_req  ),
196:     .entropy_masking_ack_i  ( entropy_masking_ack  ),
197:     .entropy_masking_i      ( edn_data             ),
198: 
199:     .keymgr_key_i           ( keymgr_key_i         ),
200: 
201:     .lc_escalate_en_i       ( lc_escalate_en       ),
202: 
203:     .shadowed_storage_err_i ( shadowed_storage_err ),
204:     .shadowed_update_err_i  ( shadowed_update_err  ),
205:     .intg_err_alert_i       ( intg_err_alert       ),
206:     .alert_recov_o          ( alert[0]             ),
207:     .alert_fatal_o          ( alert[1]             ),
208: 
209:     .reg2hw                 ( reg2hw               ),
210:     .hw2reg                 ( hw2reg               )
211:   );
212: 
213:   assign idle_o = prim_mubi_pkg::mubi4_bool_to_mubi(reg2hw.status.idle.q);
214: 
215:   ////////////
216:   // Alerts //
217:   ////////////
218: 
219:   logic [NumAlerts-1:0] alert_test;
220:   assign alert_test = {
221:     reg2hw.alert_test.fatal_fault.q &
222:     reg2hw.alert_test.fatal_fault.qe,
223:     reg2hw.alert_test.recov_ctrl_update_err.q &
224:     reg2hw.alert_test.recov_ctrl_update_err.qe
225:   };
226: 
227:   for (genvar i = 0; i < NumAlerts; i++) begin : gen_alert_tx
228:     prim_alert_sender #(
229:       .AsyncOn(AlertAsyncOn[i]),
230:       .IsFatal(i)
231:     ) u_prim_alert_sender (
232:       .clk_i,
233:       .rst_ni,
234:       .alert_test_i  ( alert_test[i] ),
235:       .alert_req_i   ( alert[i]      ),
236:       .alert_ack_o   (               ),
237:       .alert_state_o (               ),
238:       .alert_rx_i    ( alert_rx_i[i] ),
239:       .alert_tx_o    ( alert_tx_o[i] )
240:     );
241:   end
242: 
243:   ////////////////
244:   // Assertions //
245:   ////////////////
246: 
247:   // All outputs should have a known value after reset
248:   `ASSERT_KNOWN(TlODValidKnown, tl_o.d_valid)
249:   `ASSERT_KNOWN(TlOAReadyKnown, tl_o.a_ready)
250:   `ASSERT_KNOWN(IdleKnown, idle_o)
251:   `ASSERT_KNOWN(EdnReqKnown, edn_o)
252:   `ASSERT_KNOWN(AlertTxKnown, alert_tx_o)
253: 
254:   // Alert assertions for sparse FSMs.
255:   for (genvar i = 0; i < Sp2VWidth; i++) begin : gen_control_fsm_svas
256:     if (SP2V_LOGIC_HIGH[i] == 1'b1) begin : gen_control_fsm_svas_p
257:       `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(AesControlFsmCheck_A,
258:           u_aes_core.u_aes_control.gen_fsm[i].gen_fsm_p.
259:               u_aes_control_fsm_i.u_aes_control_fsm.u_state_regs,
260:           alert_tx_o[1])
261:     end else begin : gen_control_fsm_svas_n
262:       `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(AesControlFsmCheck_A,
263:           u_aes_core.u_aes_control.gen_fsm[i].gen_fsm_n.
264:               u_aes_control_fsm_i.u_aes_control_fsm.u_state_regs,
265:           alert_tx_o[1])
266:     end
267:   end
268: 
269:   for (genvar i = 0; i < Sp2VWidth; i++) begin : gen_ctr_fsm_svas
270:     if (SP2V_LOGIC_HIGH[i] == 1'b1) begin : gen_ctr_fsm_svas_p
271:       `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(AesCtrFsmCheck_A,
272:           u_aes_core.u_aes_ctr.gen_fsm[i].gen_fsm_p.
273:               u_aes_ctr_fsm_i.u_aes_ctr_fsm.u_state_regs,
274:           alert_tx_o[1])
275:     end else begin : gen_ctr_fsm_svas_n
276:       `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(AesCtrFsmCheck_A,
277:           u_aes_core.u_aes_ctr.gen_fsm[i].gen_fsm_n.
278:               u_aes_ctr_fsm_i.u_aes_ctr_fsm.u_state_regs,
279:           alert_tx_o[1])
280:     end
281:   end
282: 
283:   for (genvar i = 0; i < Sp2VWidth; i++) begin : gen_cipher_control_fsm_svas
284:     if (SP2V_LOGIC_HIGH[i] == 1'b1) begin : gen_cipher_control_fsm_svas_p
285:       `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(AesCipherControlFsmCheck_A,
286:           u_aes_core.u_aes_cipher_core.u_aes_cipher_control.gen_fsm[i].gen_fsm_p.
287:               u_aes_cipher_control_fsm_i.u_aes_cipher_control_fsm.u_state_regs,
288:           alert_tx_o[1])
289:     end else begin : gen_cipher_control_fsm_svas_n
290:       `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(AesCipherControlFsmCheck_A,
291:           u_aes_core.u_aes_cipher_core.u_aes_cipher_control.gen_fsm[i].gen_fsm_n.
292:               u_aes_cipher_control_fsm_i.u_aes_cipher_control_fsm.u_state_regs,
293:           alert_tx_o[1])
294:     end
295:   end
296: 
297:   // Alert assertions for reg_we onehot check
298:   `ASSERT_PRIM_REG_WE_ONEHOT_ERROR_TRIGGER_ALERT(RegWeOnehotCheck_A, u_reg, alert_tx_o[1])
299: endmodule

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_i6XDo0RsmqNWvpG34nh1gxGv)
 Call ID: call_i6XDo0RsmqNWvpG34nh1gxGv
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes/rtl/aes_ctrl_reg_shadowed.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // AES shadowed control register
6: //
7: // This module implements the AES shadowed control register. The main differences compared
8: // to implementing the register as part of the auto-generated aes_reg_top.sv are:
9: //
10: // 1. The hardware can block updates to the control register from software.
11: //    Whenever the module is busy, control register writes are ignored.
12: // 2. Invalid values written by software are resolved to valid configurations.
13: 
14: `include "prim_assert.sv"
15: 
16: module aes_ctrl_reg_shadowed
17:   import aes_pkg::*;
18:   import aes_reg_pkg::*;
19: #(
20:   parameter bit AES192Enable = 1
21: ) (
22:   input  logic clk_i,
23:   input  logic rst_ni,
24:   input  logic rst_shadowed_ni,
25:   // Main control
26:   output logic      qe_o, // software wants to write
27:   input  logic      we_i, // hardware grants software write
28:   output logic      phase_o,
29:   output aes_op_e   operation_o,
30:   output aes_mode_e mode_o,
31:   output key_len_e  key_len_o,
32:   output logic      sideload_o,
33:   output prs_rate_e prng_reseed_rate_o,
34:   output logic      manual_operation_o,
35: 
36:   // Alerts
37:   output logic err_update_o,
38:   output logic err_storage_o,
39: 
40:   // Bus interface
41:   input  aes_reg2hw_ctrl_shadowed_reg_t reg2hw_ctrl_i,
42:   output aes_hw2reg_ctrl_shadowed_reg_t hw2reg_ctrl_o
43: );
44: 
45:   // Signals
46:   ctrl_reg_t ctrl_wd;
47:   aes_op_e   op;
48:   aes_mode_e mode;
49:   key_len_e  key_len;
50:   prs_rate_e prng_reseed_rate;
51:   logic      phase_operation;
52:   logic      phase_mode;
53:   logic      phase_key_len;
54:   logic      phase_key_sideload;
55:   logic      phase_prng_reseed_rate;
56:   logic      phase_manual_operation;
57:   logic      err_update_operation;
58:   logic      err_update_mode;
59:   logic      err_update_key_len;
60:   logic      err_update_sideload;
61:   logic      err_update_prng_reseed_rate;
62:   logic      err_update_manual_operation;
63:   logic      err_storage_operation;
64:   logic      err_storage_mode;
65:   logic      err_storage_key_len;
66:   logic      err_storage_sideload;
67:   logic      err_storage_prng_reseed_rate;
68:   logic      err_storage_manual_operation;
69: 
70:   // Get and forward write enable. Writes are only allowed if the module is idle.
71:   assign qe_o = reg2hw_ctrl_i.operation.qe & reg2hw_ctrl_i.mode.qe &
72:       reg2hw_ctrl_i.key_len.qe & reg2hw_ctrl_i.sideload.qe &
73:       reg2hw_ctrl_i.prng_reseed_rate.qe & reg2hw_ctrl_i.manual_operation.qe;
74: 
75:   // Get and resolve values from register interface.
76:   assign op = aes_op_e'(reg2hw_ctrl_i.operation.q);
77:   always_comb begin : operation_get
78:     unique case (op)
79:       AES_ENC: ctrl_wd.operation = AES_ENC;
80:       AES_DEC: ctrl_wd.operation = AES_DEC;
81:       default: ctrl_wd.operation = AES_ENC; // unsupported values are mapped to AES_ENC
82:     endcase
83:   end
84: 
85:   assign mode = aes_mode_e'(reg2hw_ctrl_i.mode.q);
86:   always_comb begin : mode_get
87:     unique case (mode)
88:       AES_ECB: ctrl_wd.mode = AES_ECB;
89:       AES_CBC: ctrl_wd.mode = AES_CBC;
90:       AES_CFB: ctrl_wd.mode = AES_CFB;
91:       AES_OFB: ctrl_wd.mode = AES_OFB;
92:       AES_CTR: ctrl_wd.mode = AES_CTR;
93:       default: ctrl_wd.mode = AES_NONE; // unsupported values are mapped to AES_NONE
94:     endcase
95:   end
96: 
97:   assign key_len = key_len_e'(reg2hw_ctrl_i.key_len.q);
98:   always_comb begin : key_len_get
99:     unique case (key_len)
100:       AES_128: ctrl_wd.key_len = AES_128;
101:       AES_256: ctrl_wd.key_len = AES_256;
102:       AES_192: ctrl_wd.key_len = AES192Enable ? AES_192 : AES_256;
103:       default: ctrl_wd.key_len = AES_256; // unsupported values are mapped to AES_256
104:     endcase
105:   end
106: 
107:   assign ctrl_wd.sideload = reg2hw_ctrl_i.sideload.q;
108: 
109:   assign prng_reseed_rate = prs_rate_e'(reg2hw_ctrl_i.prng_reseed_rate.q);
110:   always_comb begin : prng_reseed_rate_get
111:     unique case (prng_reseed_rate)
112:       PER_1:   ctrl_wd.prng_reseed_rate = PER_1;
113:       PER_64:  ctrl_wd.prng_reseed_rate = PER_64;
114:       PER_8K:  ctrl_wd.prng_reseed_rate = PER_8K;
115:       default: ctrl_wd.prng_reseed_rate = PER_1; // unsupported values are mapped to PER_1.
116:     endcase
117:   end
118: 
119:   assign ctrl_wd.manual_operation = reg2hw_ctrl_i.manual_operation.q;
120: 
121:   // SEC_CM: MAIN.CONFIG.SHADOW
122:   // Instantiate one shadowed register primitive per field. An update error in a field should
123:   // only prevent the update of the affected field.
124:   prim_subreg_shadow #(
125:     .DW      ($bits(aes_op_e)),
126:     .SwAccess(prim_subreg_pkg::SwAccessWO),
127:     .RESVAL  (AES_CTRL_SHADOWED_OPERATION_RESVAL)
128:   ) u_ctrl_reg_shadowed_operation (
129:     .clk_i,
130:     .rst_ni,
131:     .rst_shadowed_ni,
132:     .re         (reg2hw_ctrl_i.operation.re),
133:     .we         (we_i),
134:     .wd         ({ctrl_wd.operation}),
135:     .de         (1'b0),
136:     .d          ('0),
137:     .qe         (),
138:     .q          (hw2reg_ctrl_o.operation.d),
139:     .qs         (),
140:     .ds         (),
141:     .phase      (phase_operation),
142:     .err_update (err_update_operation),
143:     .err_storage(err_storage_operation)
144:   );
145: 
146:   prim_subreg_shadow #(
147:     .DW      ($bits(aes_mode_e)),
148:     .SwAccess(prim_subreg_pkg::SwAccessWO),
149:     .RESVAL  (AES_CTRL_SHADOWED_MODE_RESVAL)
150:   ) u_ctrl_reg_shadowed_mode (
151:     .clk_i,
152:     .rst_ni,
153:     .rst_shadowed_ni,
154:     .re         (reg2hw_ctrl_i.mode.re),
155:     .we         (we_i),
156:     .wd         ({ctrl_wd.mode}),
157:     .de         (1'b0),
158:     .d          ('0),
159:     .qe         (),
160:     .q          (hw2reg_ctrl_o.mode.d),
161:     .qs         (),
162:     .ds         (),
163:     .phase      (phase_mode),
164:     .err_update (err_update_mode),
165:     .err_storage(err_storage_mode)
166:   );
167: 
168:   prim_subreg_shadow #(
169:     .DW      ($bits(key_len_e)),
170:     .SwAccess(prim_subreg_pkg::SwAccessWO),
171:     .RESVAL  (AES_CTRL_SHADOWED_KEY_LEN_RESVAL)
172:   ) u_ctrl_reg_shadowed_key_len (
173:     .clk_i,
174:     .rst_ni,
175:     .rst_shadowed_ni,
176:     .re         (reg2hw_ctrl_i.key_len.re),
177:     .we         (we_i),
178:     .wd         ({ctrl_wd.key_len}),
179:     .de         (1'b0),
180:     .d          ('0),
181:     .qe         (),
182:     .q          (hw2reg_ctrl_o.key_len.d),
183:     .qs         (),
184:     .ds         (),
185:     .phase      (phase_key_len),
186:     .err_update (err_update_key_len),
187:     .err_storage(err_storage_key_len)
188:   );
189: 
190:   prim_subreg_shadow #(
191:     .DW      (1),
192:     .SwAccess(prim_subreg_pkg::SwAccessWO),
193:     .RESVAL  (AES_CTRL_SHADOWED_SIDELOAD_RESVAL)
194:   ) u_ctrl_reg_shadowed_sideload (
195:     .clk_i,
196:     .rst_ni,
197:     .rst_shadowed_ni,
198:     .re         (reg2hw_ctrl_i.sideload.re),
199:     .we         (we_i),
200:     .wd         (ctrl_wd.sideload),
201:     .de         (1'b0),
202:     .d          ('0),
203:     .qe         (),
204:     .q          (hw2reg_ctrl_o.sideload.d),
205:     .qs         (),
206:     .ds         (),
207:     .phase      (phase_key_sideload),
208:     .err_update (err_update_sideload),
209:     .err_storage(err_storage_sideload)
210:   );
211: 
212:   prim_subreg_shadow #(
213:     .DW      ($bits(prs_rate_e)),
214:     .SwAccess(prim_subreg_pkg::SwAccessWO),
215:     .RESVAL  (AES_CTRL_SHADOWED_PRNG_RESEED_RATE_RESVAL)
216:   ) u_ctrl_reg_shadowed_prng_reseed_rate (
217:     .clk_i,
218:     .rst_ni,
219:     .rst_shadowed_ni,
220:     .re         (reg2hw_ctrl_i.prng_reseed_rate.re),
221:     .we         (we_i),
222:     .wd         ({ctrl_wd.prng_reseed_rate}),
223:     .de         (1'b0),
224:     .d          ('0),
225:     .qe         (),
226:     .q          (hw2reg_ctrl_o.prng_reseed_rate.d),
227:     .qs         (),
228:     .ds         (),
229:     .phase      (phase_prng_reseed_rate),
230:     .err_update (err_update_prng_reseed_rate),
231:     .err_storage(err_storage_prng_reseed_rate)
232:   );
233: 
234:   prim_subreg_shadow #(
235:     .DW      (1),
236:     .SwAccess(prim_subreg_pkg::SwAccessWO),
237:     .RESVAL  (AES_CTRL_SHADOWED_MANUAL_OPERATION_RESVAL)
238:   ) u_ctrl_reg_shadowed_manual_operation (
239:     .clk_i,
240:     .rst_ni,
241:     .rst_shadowed_ni,
242:     .re         (reg2hw_ctrl_i.manual_operation.re),
243:     .we         (we_i),
244:     .wd         (ctrl_wd.manual_operation),
245:     .de         (1'b0),
246:     .d          ('0),
247:     .qe         (),
248:     .q          (hw2reg_ctrl_o.manual_operation.d),
249:     .qs         (),
250:     .ds         (),
251:     .phase      (phase_manual_operation),
252:     .err_update (err_update_manual_operation),
253:     .err_storage(err_storage_manual_operation)
254:   );
255: 
256:   // Collect phase signals.
257:   assign phase_o = phase_operation | phase_mode | phase_key_len | phase_key_sideload |
258:       phase_prng_reseed_rate | phase_manual_operation;
259: 
260:   // Collect alerts.
261:   assign err_update_o = err_update_operation | err_update_mode | err_update_key_len |
262:       err_update_sideload | err_update_prng_reseed_rate | err_update_manual_operation;
263:   assign err_storage_o = err_storage_operation | err_storage_mode | err_storage_key_len |
264:       err_storage_sideload | err_storage_prng_reseed_rate | err_storage_manual_operation;
265: 
266:   // Generate shorter references.
267:   // Doing that here as opposed to in aes_core avoids several Verilator lint errors.
268:   assign operation_o        = aes_op_e'(hw2reg_ctrl_o.operation.d);
269:   assign mode_o             = aes_mode_e'(hw2reg_ctrl_o.mode.d);
270:   assign key_len_o          = key_len_e'(hw2reg_ctrl_o.key_len.d);
271:   assign sideload_o         = hw2reg_ctrl_o.sideload.d;
272:   assign prng_reseed_rate_o = prs_rate_e'(hw2reg_ctrl_o.prng_reseed_rate.d);
273:   assign manual_operation_o = hw2reg_ctrl_o.manual_operation.d;
274: 
275: endmodule

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_tD2ZJw3EPq1oVUfSB7zH7JZd)
 Call ID: call_tD2ZJw3EPq1oVUfSB7zH7JZd
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes/rtl/aes_reg_pkg.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Register Package auto-generated by `reggen` containing data structure
6: 
7: package aes_reg_pkg;
8: 
9:   // Param list
10:   parameter int NumRegsKey = 8;
11:   parameter int NumRegsIv = 4;
12:   parameter int NumRegsData = 4;
13:   parameter int NumAlerts = 2;
14: 
15:   // Address widths within the block
16:   parameter int BlockAw = 8;
17: 
18:   // Number of registers for every interface
19:   parameter int NumRegs = 34;
20: 
21:   ////////////////////////////
22:   // Typedefs for registers //
23:   ////////////////////////////
24: 
25:   typedef struct packed {
26:     struct packed {
27:       logic        q;
28:       logic        qe;
29:     } fatal_fault;
30:     struct packed {
31:       logic        q;
32:       logic        qe;
33:     } recov_ctrl_update_err;
34:   } aes_reg2hw_alert_test_reg_t;
35: 
36:   typedef struct packed {
37:     logic [31:0] q;
38:     logic        qe;
39:   } aes_reg2hw_key_share0_mreg_t;
40: 
41:   typedef struct packed {
42:     logic [31:0] q;
43:     logic        qe;
44:   } aes_reg2hw_key_share1_mreg_t;
45: 
46:   typedef struct packed {
47:     logic [31:0] q;
48:     logic        qe;
49:   } aes_reg2hw_iv_mreg_t;
50: 
51:   typedef struct packed {
52:     logic [31:0] q;
53:     logic        qe;
54:   } aes_reg2hw_data_in_mreg_t;
55: 
56:   typedef struct packed {
57:     logic [31:0] q;
58:     logic        re;
59:   } aes_reg2hw_data_out_mreg_t;
60: 
61:   typedef struct packed {
62:     struct packed {
63:       logic        q;
64:       logic        qe;
65:       logic        re;
66:     } manual_operation;
67:     struct packed {
68:       logic [2:0]  q;
69:       logic        qe;
70:       logic        re;
71:     } prng_reseed_rate;
72:     struct packed {
73:       logic        q;
74:       logic        qe;
75:       logic        re;
76:     } sideload;
77:     struct packed {
78:       logic [2:0]  q;
79:       logic        qe;
80:       logic        re;
81:     } key_len;
82:     struct packed {
83:       logic [5:0]  q;
84:       logic        qe;
85:       logic        re;
86:     } mode;
87:     struct packed {
88:       logic [1:0]  q;
89:       logic        qe;
90:       logic        re;
91:     } operation;
92:   } aes_reg2hw_ctrl_shadowed_reg_t;
93: 
94:   typedef struct packed {
95:     struct packed {
96:       logic        q;
97:     } force_masks;
98:     struct packed {
99:       logic        q;
100:     } key_touch_forces_reseed;
101:   } aes_reg2hw_ctrl_aux_shadowed_reg_t;
102: 
103:   typedef struct packed {
104:     struct packed {
105:       logic        q;
106:     } prng_reseed;
107:     struct packed {
108:       logic        q;
109:     } data_out_clear;
110:     struct packed {
111:       logic        q;
112:     } key_iv_data_in_clear;
113:     struct packed {
114:       logic        q;
115:     } start;
116:   } aes_reg2hw_trigger_reg_t;
117: 
118:   typedef struct packed {
119:     struct packed {
120:       logic        q;
121:     } output_lost;
122:     struct packed {
123:       logic        q;
124:     } idle;
125:   } aes_reg2hw_status_reg_t;
126: 
127:   typedef struct packed {
128:     logic [31:0] d;
129:   } aes_hw2reg_key_share0_mreg_t;
130: 
131:   typedef struct packed {
132:     logic [31:0] d;
133:   } aes_hw2reg_key_share1_mreg_t;
134: 
135:   typedef struct packed {
136:     logic [31:0] d;
137:   } aes_hw2reg_iv_mreg_t;
138: 
139:   typedef struct packed {
140:     logic [31:0] d;
141:     logic        de;
142:   } aes_hw2reg_data_in_mreg_t;
143: 
144:   typedef struct packed {
145:     logic [31:0] d;
146:   } aes_hw2reg_data_out_mreg_t;
147: 
148:   typedef struct packed {
149:     struct packed {
150:       logic        d;
151:     } manual_operation;
152:     struct packed {
153:       logic [2:0]  d;
154:     } prng_reseed_rate;
155:     struct packed {
156:       logic        d;
157:     } sideload;
158:     struct packed {
159:       logic [2:0]  d;
160:     } key_len;
161:     struct packed {
162:       logic [5:0]  d;
163:     } mode;
164:     struct packed {
165:       logic [1:0]  d;
166:     } operation;
167:   } aes_hw2reg_ctrl_shadowed_reg_t;
168: 
169:   typedef struct packed {
170:     struct packed {
171:       logic        d;
172:       logic        de;
173:     } prng_reseed;
174:     struct packed {
175:       logic        d;
176:       logic        de;
177:     } data_out_clear;
178:     struct packed {
179:       logic        d;
180:       logic        de;
181:     } key_iv_data_in_clear;
182:     struct packed {
183:       logic        d;
184:       logic        de;
185:     } start;
186:   } aes_hw2reg_trigger_reg_t;
187: 
188:   typedef struct packed {
189:     struct packed {
190:       logic        d;
191:       logic        de;
192:     } alert_fatal_fault;
193:     struct packed {
194:       logic        d;
195:       logic        de;
196:     } alert_recov_ctrl_update_err;
197:     struct packed {
198:       logic        d;
199:       logic        de;
200:     } input_ready;
201:     struct packed {
202:       logic        d;
203:       logic        de;
204:     } output_valid;
205:     struct packed {
206:       logic        d;
207:       logic        de;
208:     } output_lost;
209:     struct packed {
210:       logic        d;
211:       logic        de;
212:     } stall;
213:     struct packed {
214:       logic        d;
215:       logic        de;
216:     } idle;
217:   } aes_hw2reg_status_reg_t;
218: 
219:   // Register -> HW type
220:   typedef struct packed {
221:     aes_reg2hw_alert_test_reg_t alert_test; // [957:954]
222:     aes_reg2hw_key_share0_mreg_t [7:0] key_share0; // [953:690]
223:     aes_reg2hw_key_share1_mreg_t [7:0] key_share1; // [689:426]
224:     aes_reg2hw_iv_mreg_t [3:0] iv; // [425:294]
225:     aes_reg2hw_data_in_mreg_t [3:0] data_in; // [293:162]
226:     aes_reg2hw_data_out_mreg_t [3:0] data_out; // [161:30]
227:     aes_reg2hw_ctrl_shadowed_reg_t ctrl_shadowed; // [29:8]
228:     aes_reg2hw_ctrl_aux_shadowed_reg_t ctrl_aux_shadowed; // [7:6]
229:     aes_reg2hw_trigger_reg_t trigger; // [5:2]
230:     aes_reg2hw_status_reg_t status; // [1:0]
231:   } aes_reg2hw_t;
232: 
233:   // HW -> register type
234:   typedef struct packed {
235:     aes_hw2reg_key_share0_mreg_t [7:0] key_share0; // [937:682]
236:     aes_hw2reg_key_share1_mreg_t [7:0] key_share1; // [681:426]
237:     aes_hw2reg_iv_mreg_t [3:0] iv; // [425:298]
238:     aes_hw2reg_data_in_mreg_t [3:0] data_in; // [297:166]
239:     aes_hw2reg_data_out_mreg_t [3:0] data_out; // [165:38]
240:     aes_hw2reg_ctrl_shadowed_reg_t ctrl_shadowed; // [37:22]
241:     aes_hw2reg_trigger_reg_t trigger; // [21:14]
242:     aes_hw2reg_status_reg_t status; // [13:0]
243:   } aes_hw2reg_t;
244: 
245:   // Register offsets
246:   parameter logic [BlockAw-1:0] AES_ALERT_TEST_OFFSET = 8'h 0;
247:   parameter logic [BlockAw-1:0] AES_KEY_SHARE0_0_OFFSET = 8'h 4;
248:   parameter logic [BlockAw-1:0] AES_KEY_SHARE0_1_OFFSET = 8'h 8;
249:   parameter logic [BlockAw-1:0] AES_KEY_SHARE0_2_OFFSET = 8'h c;
250:   parameter logic [BlockAw-1:0] AES_KEY_SHARE0_3_OFFSET = 8'h 10;
251:   parameter logic [BlockAw-1:0] AES_KEY_SHARE0_4_OFFSET = 8'h 14;
252:   parameter logic [BlockAw-1:0] AES_KEY_SHARE0_5_OFFSET = 8'h 18;
253:   parameter logic [BlockAw-1:0] AES_KEY_SHARE0_6_OFFSET = 8'h 1c;
254:   parameter logic [BlockAw-1:0] AES_KEY_SHARE0_7_OFFSET = 8'h 20;
255:   parameter logic [BlockAw-1:0] AES_KEY_SHARE1_0_OFFSET = 8'h 24;
256:   parameter logic [BlockAw-1:0] AES_KEY_SHARE1_1_OFFSET = 8'h 28;
257:   parameter logic [BlockAw-1:0] AES_KEY_SHARE1_2_OFFSET = 8'h 2c;
258:   parameter logic [BlockAw-1:0] AES_KEY_SHARE1_3_OFFSET = 8'h 30;
259:   parameter logic [BlockAw-1:0] AES_KEY_SHARE1_4_OFFSET = 8'h 34;
260:   parameter logic [BlockAw-1:0] AES_KEY_SHARE1_5_OFFSET = 8'h 38;
261:   parameter logic [BlockAw-1:0] AES_KEY_SHARE1_6_OFFSET = 8'h 3c;
262:   parameter logic [BlockAw-1:0] AES_KEY_SHARE1_7_OFFSET = 8'h 40;
263:   parameter logic [BlockAw-1:0] AES_IV_0_OFFSET = 8'h 44;
264:   parameter logic [BlockAw-1:0] AES_IV_1_OFFSET = 8'h 48;
265:   parameter logic [BlockAw-1:0] AES_IV_2_OFFSET = 8'h 4c;
266:   parameter logic [BlockAw-1:0] AES_IV_3_OFFSET = 8'h 50;
267:   parameter logic [BlockAw-1:0] AES_DATA_IN_0_OFFSET = 8'h 54;
268:   parameter logic [BlockAw-1:0] AES_DATA_IN_1_OFFSET = 8'h 58;
269:   parameter logic [BlockAw-1:0] AES_DATA_IN_2_OFFSET = 8'h 5c;
270:   parameter logic [BlockAw-1:0] AES_DATA_IN_3_OFFSET = 8'h 60;
271:   parameter logic [BlockAw-1:0] AES_DATA_OUT_0_OFFSET = 8'h 64;
272:   parameter logic [BlockAw-1:0] AES_DATA_OUT_1_OFFSET = 8'h 68;
273:   parameter logic [BlockAw-1:0] AES_DATA_OUT_2_OFFSET = 8'h 6c;
274:   parameter logic [BlockAw-1:0] AES_DATA_OUT_3_OFFSET = 8'h 70;
275:   parameter logic [BlockAw-1:0] AES_CTRL_SHADOWED_OFFSET = 8'h 74;
276:   parameter logic [BlockAw-1:0] AES_CTRL_AUX_SHADOWED_OFFSET = 8'h 78;
277:   parameter logic [BlockAw-1:0] AES_CTRL_AUX_REGWEN_OFFSET = 8'h 7c;
278:   parameter logic [BlockAw-1:0] AES_TRIGGER_OFFSET = 8'h 80;
279:   parameter logic [BlockAw-1:0] AES_STATUS_OFFSET = 8'h 84;
280: 
281:   // Reset values for hwext registers and their fields
282:   parameter logic [1:0] AES_ALERT_TEST_RESVAL = 2'h 0;
283:   parameter logic [0:0] AES_ALERT_TEST_RECOV_CTRL_UPDATE_ERR_RESVAL = 1'h 0;
284:   parameter logic [0:0] AES_ALERT_TEST_FATAL_FAULT_RESVAL = 1'h 0;
285:   parameter logic [31:0] AES_KEY_SHARE0_0_RESVAL = 32'h 0;
286:   parameter logic [31:0] AES_KEY_SHARE0_0_KEY_SHARE0_0_RESVAL = 32'h 0;
287:   parameter logic [31:0] AES_KEY_SHARE0_1_RESVAL = 32'h 0;
288:   parameter logic [31:0] AES_KEY_SHARE0_1_KEY_SHARE0_1_RESVAL = 32'h 0;
289:   parameter logic [31:0] AES_KEY_SHARE0_2_RESVAL = 32'h 0;
290:   parameter logic [31:0] AES_KEY_SHARE0_2_KEY_SHARE0_2_RESVAL = 32'h 0;
291:   parameter logic [31:0] AES_KEY_SHARE0_3_RESVAL = 32'h 0;
292:   parameter logic [31:0] AES_KEY_SHARE0_3_KEY_SHARE0_3_RESVAL = 32'h 0;
293:   parameter logic [31:0] AES_KEY_SHARE0_4_RESVAL = 32'h 0;
294:   parameter logic [31:0] AES_KEY_SHARE0_4_KEY_SHARE0_4_RESVAL = 32'h 0;
295:   parameter logic [31:0] AES_KEY_SHARE0_5_RESVAL = 32'h 0;
296:   parameter logic [31:0] AES_KEY_SHARE0_5_KEY_SHARE0_5_RESVAL = 32'h 0;
297:   parameter logic [31:0] AES_KEY_SHARE0_6_RESVAL = 32'h 0;
298:   parameter logic [31:0] AES_KEY_SHARE0_6_KEY_SHARE0_6_RESVAL = 32'h 0;
299:   parameter logic [31:0] AES_KEY_SHARE0_7_RESVAL = 32'h 0;
300:   parameter logic [31:0] AES_KEY_SHARE0_7_KEY_SHARE0_7_RESVAL = 32'h 0;
301:   parameter logic [31:0] AES_KEY_SHARE1_0_RESVAL = 32'h 0;
302:   parameter logic [31:0] AES_KEY_SHARE1_0_KEY_SHARE1_0_RESVAL = 32'h 0;
303:   parameter logic [31:0] AES_KEY_SHARE1_1_RESVAL = 32'h 0;
304:   parameter logic [31:0] AES_KEY_SHARE1_1_KEY_SHARE1_1_RESVAL = 32'h 0;
305:   parameter logic [31:0] AES_KEY_SHARE1_2_RESVAL = 32'h 0;
306:   parameter logic [31:0] AES_KEY_SHARE1_2_KEY_SHARE1_2_RESVAL = 32'h 0;
307:   parameter logic [31:0] AES_KEY_SHARE1_3_RESVAL = 32'h 0;
308:   parameter logic [31:0] AES_KEY_SHARE1_3_KEY_SHARE1_3_RESVAL = 32'h 0;
309:   parameter logic [31:0] AES_KEY_SHARE1_4_RESVAL = 32'h 0;
310:   parameter logic [31:0] AES_KEY_SHARE1_4_KEY_SHARE1_4_RESVAL = 32'h 0;
311:   parameter logic [31:0] AES_KEY_SHARE1_5_RESVAL = 32'h 0;
312:   parameter logic [31:0] AES_KEY_SHARE1_5_KEY_SHARE1_5_RESVAL = 32'h 0;
313:   parameter logic [31:0] AES_KEY_SHARE1_6_RESVAL = 32'h 0;
314:   parameter logic [31:0] AES_KEY_SHARE1_6_KEY_SHARE1_6_RESVAL = 32'h 0;
315:   parameter logic [31:0] AES_KEY_SHARE1_7_RESVAL = 32'h 0;
316:   parameter logic [31:0] AES_KEY_SHARE1_7_KEY_SHARE1_7_RESVAL = 32'h 0;
317:   parameter logic [31:0] AES_IV_0_RESVAL = 32'h 0;
318:   parameter logic [31:0] AES_IV_0_IV_0_RESVAL = 32'h 0;
319:   parameter logic [31:0] AES_IV_1_RESVAL = 32'h 0;
320:   parameter logic [31:0] AES_IV_1_IV_1_RESVAL = 32'h 0;
321:   parameter logic [31:0] AES_IV_2_RESVAL = 32'h 0;
322:   parameter logic [31:0] AES_IV_2_IV_2_RESVAL = 32'h 0;
323:   parameter logic [31:0] AES_IV_3_RESVAL = 32'h 0;
324:   parameter logic [31:0] AES_IV_3_IV_3_RESVAL = 32'h 0;
325:   parameter logic [31:0] AES_DATA_OUT_0_RESVAL = 32'h 0;
326:   parameter logic [31:0] AES_DATA_OUT_0_DATA_OUT_0_RESVAL = 32'h 0;
327:   parameter logic [31:0] AES_DATA_OUT_1_RESVAL = 32'h 0;
328:   parameter logic [31:0] AES_DATA_OUT_1_DATA_OUT_1_RESVAL = 32'h 0;
329:   parameter logic [31:0] AES_DATA_OUT_2_RESVAL = 32'h 0;
330:   parameter logic [31:0] AES_DATA_OUT_2_DATA_OUT_2_RESVAL = 32'h 0;
331:   parameter logic [31:0] AES_DATA_OUT_3_RESVAL = 32'h 0;
332:   parameter logic [31:0] AES_DATA_OUT_3_DATA_OUT_3_RESVAL = 32'h 0;
333:   parameter logic [15:0] AES_CTRL_SHADOWED_RESVAL = 16'h 1181;
334:   parameter logic [1:0] AES_CTRL_SHADOWED_OPERATION_RESVAL = 2'h 1;
335:   parameter logic [5:0] AES_CTRL_SHADOWED_MODE_RESVAL = 6'h 20;
336:   parameter logic [2:0] AES_CTRL_SHADOWED_KEY_LEN_RESVAL = 3'h 1;
337:   parameter logic [0:0] AES_CTRL_SHADOWED_SIDELOAD_RESVAL = 1'h 0;
338:   parameter logic [2:0] AES_CTRL_SHADOWED_PRNG_RESEED_RATE_RESVAL = 3'h 1;
339:   parameter logic [0:0] AES_CTRL_SHADOWED_MANUAL_OPERATION_RESVAL = 1'h 0;
340: 
341:   // Register index
342:   typedef enum int {
343:     AES_ALERT_TEST,
344:     AES_KEY_SHARE0_0,
345:     AES_KEY_SHARE0_1,
346:     AES_KEY_SHARE0_2,
347:     AES_KEY_SHARE0_3,
348:     AES_KEY_SHARE0_4,
349:     AES_KEY_SHARE0_5,
350:     AES_KEY_SHARE0_6,
351:     AES_KEY_SHARE0_7,
352:     AES_KEY_SHARE1_0,
353:     AES_KEY_SHARE1_1,
354:     AES_KEY_SHARE1_2,
355:     AES_KEY_SHARE1_3,
356:     AES_KEY_SHARE1_4,
357:     AES_KEY_SHARE1_5,
358:     AES_KEY_SHARE1_6,
359:     AES_KEY_SHARE1_7,
360:     AES_IV_0,
361:     AES_IV_1,
362:     AES_IV_2,
363:     AES_IV_3,
364:     AES_DATA_IN_0,
365:     AES_DATA_IN_1,
366:     AES_DATA_IN_2,
367:     AES_DATA_IN_3,
368:     AES_DATA_OUT_0,
369:     AES_DATA_OUT_1,
370:     AES_DATA_OUT_2,
371:     AES_DATA_OUT_3,
372:     AES_CTRL_SHADOWED,
373:     AES_CTRL_AUX_SHADOWED,
374:     AES_CTRL_AUX_REGWEN,
375:     AES_TRIGGER,
376:     AES_STATUS
377:   } aes_id_e;
378: 
379:   // Register width information to check illegal writes
380:   parameter logic [3:0] AES_PERMIT [34] = '{
381:     4'b 0001, // index[ 0] AES_ALERT_TEST
382:     4'b 1111, // index[ 1] AES_KEY_SHARE0_0
383:     4'b 1111, // index[ 2] AES_KEY_SHARE0_1
384:     4'b 1111, // index[ 3] AES_KEY_SHARE0_2
385:     4'b 1111, // index[ 4] AES_KEY_SHARE0_3
386:     4'b 1111, // index[ 5] AES_KEY_SHARE0_4
387:     4'b 1111, // index[ 6] AES_KEY_SHARE0_5
388:     4'b 1111, // index[ 7] AES_KEY_SHARE0_6
389:     4'b 1111, // index[ 8] AES_KEY_SHARE0_7
390:     4'b 1111, // index[ 9] AES_KEY_SHARE1_0
391:     4'b 1111, // index[10] AES_KEY_SHARE1_1
392:     4'b 1111, // index[11] AES_KEY_SHARE1_2
393:     4'b 1111, // index[12] AES_KEY_SHARE1_3
394:     4'b 1111, // index[13] AES_KEY_SHARE1_4
395:     4'b 1111, // index[14] AES_KEY_SHARE1_5
396:     4'b 1111, // index[15] AES_KEY_SHARE1_6
397:     4'b 1111, // index[16] AES_KEY_SHARE1_7
398:     4'b 1111, // index[17] AES_IV_0
399:     4'b 1111, // index[18] AES_IV_1
400:     4'b 1111, // index[19] AES_IV_2
401:     4'b 1111, // index[20] AES_IV_3
402:     4'b 1111, // index[21] AES_DATA_IN_0
403:     4'b 1111, // index[22] AES_DATA_IN_1
404:     4'b 1111, // index[23] AES_DATA_IN_2
405:     4'b 1111, // index[24] AES_DATA_IN_3
406:     4'b 1111, // index[25] AES_DATA_OUT_0
407:     4'b 1111, // index[26] AES_DATA_OUT_1
408:     4'b 1111, // index[27] AES_DATA_OUT_2
409:     4'b 1111, // index[28] AES_DATA_OUT_3
410:     4'b 0011, // index[29] AES_CTRL_SHADOWED
411:     4'b 0001, // index[30] AES_CTRL_AUX_SHADOWED
412:     4'b 0001, // index[31] AES_CTRL_AUX_REGWEN
413:     4'b 0001, // index[32] AES_TRIGGER
414:     4'b 0001  // index[33] AES_STATUS
415:   };
416: 
417: endpackage

================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_lC4CJQVIuFaN1IwnCQBvIisg)
 Call ID: call_lC4CJQVIuFaN1IwnCQBvIisg
  Args:
    design_filepath: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes/rtl/aes_core.sv
    top_module: aes_core
    security_objective: Zeroization / reset-clearing of sensitive storage (CWE-1239, CWE-1271)
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

Based on the CWE details, I'll analyze the provided RTL code for security concerns related to zeroization/reset-clearing of sensitive storage.

## Analysis of Zeroization/Reset-Clearing in the AES Core

The provided RTL code is for an AES core implementation that appears to be from the OpenTitan project. Let me analyze it for concerns related to CWE-1239 (Improper Zeroization of Hardware Register):

### Positive Security Features Identified:

1. **Dedicated Clearing Mechanisms**:
   - The design includes a dedicated PRNG for clearing purposes (`aes_prng_clearing`) that generates pseudo-random data to overwrite sensitive registers.
   - There are explicit signals for clearing operations: `cipher_key_clear`, `cipher_data_out_clear`, etc.

2. **Clearing Triggers**:
   - The code includes trigger signals for clearing operations: `key_iv_data_in_clear` and `data_out_clear`.
   - These can be triggered via software through register writes.

3. **Pseudo-Random Clearing**:
   - Instead of simply zeroing out registers (which could be vulnerable to power analysis), the design uses pseudo-random data for clearing, which is a stronger approach.
   - The code includes `prd_clearing_key_init`, `prd_clearing_state`, etc., for clearing different types of registers.

### Potential Security Concerns:

1. **Conditional Reset in `data_out_reg`**:
   ```systemverilog
   always_ff @(posedge clk_i or negedge rst_ni) begin : data_out_reg
     if (!rst_ni && data_out_we != SP2V_HIGH) begin 
       data_out_q <= '0;
     end else if (data_out_we == SP2V_HIGH) begin
       data_out_q <= data_out_d;
     end
   end
   ```
   This reset condition is problematic because it only clears `data_out_q` when `data_out_we != SP2V_HIGH`. If `data_out_we` is high during reset, the register won't be cleared. This could potentially leave sensitive data in the output registers after a reset, which violates proper zeroization practices.

2. **No Explicit Clearing on Context Switch**:
   While the code has mechanisms for clearing registers, it's not immediately clear if these are automatically triggered when the user of the hardware block changes (e.g., when switching between different software contexts or processes). This is a key requirement mentioned in CWE-1239.

3. **Potential for Incomplete Clearing**:
   The code has multiple sensitive registers (key registers, state registers, IV registers, etc.). It's important to ensure that all of these are properly cleared when needed. While the code does have clearing mechanisms, a comprehensive analysis would need to verify that all sensitive registers are included in the clearing operations.

### Specific Code Areas of Concern:

1. The reset condition in the `data_out_reg` block as mentioned above.

2. The `key_init_reg` block:
   ```systemverilog
   always_ff @(posedge clk_i or negedge rst_ni) begin : key_init_reg
     if (!rst_ni) begin
       key_init_q <= '{default: '0};
     end else begin
       for (int s = 0; s < NumSharesKey; s++) begin
         for (int i = 0; i < NumRegsKey; i++) begin
           if (key_init_we[s][i] == SP2V_HIGH) begin
             key_init_q[s][i] <= key_init_d[s][i];
           end
         end
       end
     end
   end
   ```
   This properly clears the key registers on reset, but there's no explicit condition for clearing when switching users or contexts.

3. The `iv_reg` block:
   ```systemverilog
   always_ff @(posedge clk_i or negedge rst_ni) begin : iv_reg
     if (!rst_ni) begin
       iv_q <= '0;
     end else begin
       for (int i = 0; i < NumSlicesCtr; i++) begin
         if (iv_we[i] == SP2V_HIGH) begin
           
================================== Ai Message ==================================
Tool Calls:
  run_similar_bug_agent (call_QjmIIeMyBXBxb5daFc4s6KdH)
 Call ID: call_QjmIIeMyBXBxb5daFc4s6KdH
  Args:
    bug: if (!rst_ni && data_out_we != SP2V_HIGH) begin
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes/rtl/aes_core.sv
================================= Tool Message =================================
Name: run_similar_bug_agent

873: if (!rst_ni && data_out_we != SP2V_HIGH) begin
================================== Ai Message ==================================
Tool Calls:
  run_anomaly_detector_agent (call_UAiGT9plPMguvcdVqFExSVAC)
 Call ID: call_UAiGT9plPMguvcdVqFExSVAC
  Args:
    design_filepath: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes/rtl/aes_reg_top.sv
    top_module: aes_reg_top
    security_objective: Access policy enforcement and leakage (read-only/write-only behavior)
================================= Tool Message =================================
Name: run_anomaly_detector_agent

I ran the anomaly detector on aes_reg_top.sv and inspected the clusters it returned. The most important anomalous behavior is in the read-data multiplexer (reg_rdata_next) — there is an index/mapping mismatch between addr_hit indices and the values returned. This is a functional/semantic anomaly that has security implications (possible leakage of sensitive values such as key shares and input data).

What I found (summary)

1) Mis‑mapped read-case entries (primary security issue)
- In the always_comb for reg_rdata_next (the unique case (1'b1) block), the case arms for addr_hit[9..12] return data_in_0_qs .. data_in_3_qs, while according to the addr_hit assignment earlier those indices are defined as AES_KEY_SHARE1_0..AES_KEY_SHARE1_3. Concretely:
  - addr_hit[9] --> reg_rdata_next = data_in_0_qs
  - addr_hit[10] --> reg_rdata_next = data_in_1_qs
  - addr_hit[11] --> reg_rdata_next = data_in_2_qs
  - addr_hit[12] --> reg_rdata_next = data_in_3_qs

  But addr_hit[9..12] should be returning key_share1[*].q (or some key-share-related read behavior), not data_in_*_qs. Later in the same read block the indices that should correspond to data_in (21..24) return '0 instead of data_in_qs:

  - addr_hit[21..24] currently return '0 but those indices map to AES_DATA_IN_0..3.

- The result: reads to the KEY_SHARE1 address space will return data_in values (or vice‑versa), and reads to the DATA_IN addresses return zeros. This is an indexing / generator bug that can cause:
  - accidental exposure of plaintext input data under the key-share address range, or
  - possible exposure of key material (depending on how the prim_subreg_ext q fields are driven) via wrong addresses,
  - incorrect software-visible behavior for registers (wrong readback, corrupted register map).

Why this is a security concern
- Key shares and data_in are sensitive. If an attacker (or legitimate software) can read an address that returns secret key material or recent plaintext, that is a confidentiality breach.
- Misindexing can also break intended write-only / read-only protections (software might believe a register is write-only, but another address returns its contents).
- Even if actual key registers are intended to return zeros on read, the current mapping returns unintended signals for some address ranges, so the intended protections are not reliably enforced.

2) Related suspicious / unexpected items (worth checking)
- Several prim_subreg / prim_subreg_ext instances for key shares and data_in registers:
  - key_share0/1 use prim_subreg_ext with .re(1'b0) and they expose reg2hw.key_share*.q in the read mux (addr_hit[1..8] returns reg2hw.key_share0[*].q). Confirm intended behavior: key registers should typically be write-only with reads returning zero (or unreadable). If prim_subreg_ext.q contains the secret key, exposing reg2hw.key_share*.q on reads is a leakage risk.
  - data_in_1..data_in_3 are declared SwAccessWO (write-only) but they have qs outputs connected and the read mux attempts to use data_in_*_qs (further complicated by the misindexing above). Confirm whether the generator intended qs to be readable; if they are supposed to be write-only, returning qs on a read is a policy violation.

Concrete lines / places to inspect and fix
- The reg_rdata_next case arms starting with:
  - "addr_hit[9]: begin reg_rdata_next[31:0] = data_in_0_qs; end"
  - through "addr_hit[12]" (and the nearby addr_hit[13..16] entries that return '0 where key_share1 values should be)
  - The block "addr_hit[21]: begin reg_rdata_next[31:0] = '0; end" through "addr_hit[24]" (these should return DATA_IN_*_qs).
- The addr_hit assignments earlier (addr_hit[1..33]) — verify the intended mapping and ensure the read-case uses the matching indices.

Recommended fixes and mitigations
1) Correct the mapping:
   - Fix the reg_rdata_next case arms so that each addr_hit index returns the value intended by the addr_hit table:
     - addr_hit[1..8] -> key_share0[*].q (already there)
     - addr_hit[9..16] -> key_share1[*].q (currently incorrectly returning data_in / zeros)
     - addr_hit[17..20] -> iv_*_qs (OK)
     - addr_hit[21..24] -> data_in_*_qs (currently '0)
     - addr_hit[25..28] -> data_out_*_qs (OK)
     - etc.
   - Re-run code generation/reggen to ensure the generator aligns index ordering.

2) Confirm access policies (RO/WO/RW semantics):
   - For key shares: ensure they are write-only in the software-visible map. If they must be non-readable, ensure readback returns zeros or a safe value and that no other addr maps return the secret.
   - For data_in registers flagged as WO: ensure qs is not returned on reads (unless explicitly intended); if qs exists, document intended behavior and ensure it's safe.

3) Add tests & formal checks:
   - Add unit/fuzzer tests to read each address after known writes and check for expected readback behavior.
   - Add formal properties asserting that write-only registers return zeros (or defined safe values) on reads and that each addr_hit index has a consistent behavior (one-hot mapping).
   - Add an assertion that the software-visible read mapping corresponds exactly to the addr_hit table.

4) Short-term mitigation:
   - If you cannot fix generator immediately, consider gating reg_rdata_next outputs for the affected indices to safe values (zeros) until the mapping is corrected.
   - Review any firmware that may have previously read these addresses and ensure no secret leakage already occurred.

Overall assessment
- The index mismatch in reg_rdata_next is an anomalous bug and a definite security concern (high priority to fix) because it can result in incorrect exposure of sensitive internal signals (key shares, input data) at wrong addresses.
- There are additional questionable exposures (key_share*.q and data_in WO registers with qs connected) that should be audited for intended access policy. But the immediate high-severity item is the mis‑mapping in the read multiplexer.

If you want, I can:
- produce a small patched snippet for the reg_rdata_next case (re-order the case arms to match addr_hit mapping), or
- highlight the exact lines (with a diff) if you provide the file with line numbers / I can output a patched version of the case block.
================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_EgHISyEZLk0o6ZYfVuIimH9R)
 Call ID: call_EgHISyEZLk0o6ZYfVuIimH9R
  Args:
    design_filepath: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes/rtl/aes_reg_top.sv
    top_module: aes_reg_top
    security_objective: Unauthorized read or write via CSR interface (policy mismatch, CWE-1191/CWE-668)
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

Based on the CWE details, I'll analyze the provided RTL code for potential security issues related to unauthorized read or write via CSR interface, focusing on policy mismatch and insufficient granularity of access control.

## Analysis of the AES Register Top Module

The provided RTL code is for an AES (Advanced Encryption Standard) register top module, which handles the register interface for an AES cryptographic accelerator. Let me analyze it for potential security issues:

### Key Findings:

1. **Access Control Granularity Issues:**
   - The module implements various registers for AES operations, including key registers, initialization vector (IV) registers, data input/output registers, and control registers.
   - Some registers have different access policies (read-only, write-only, read-write), but there are potential issues with the granularity of access control.

2. **Specific Security Concerns:**

   a) **Key Registers Access Control:**
   - The key registers (`key_share0_*` and `key_share1_*`) are implemented with write access but no explicit access control based on privilege levels or different agents.
   - Lines 1019-1158 show the implementation of key registers with write access, but there's no differentiation between different agents who might access these sensitive registers.

   b) **Shadow Registers Implementation:**
   - The module uses shadow registers for critical control settings (lines 1481-1566), which is a good security practice, but the access control is primarily based on a single `ctrl_aux_regwen` register (line 1567-1585).
   - This could lead to insufficient granularity if different agents need different levels of access to these control settings.

   c) **Register Write Enable Checks:**
   - The module implements a register write enable check (lines 1019-1158), but it doesn't differentiate between different agents or privilege levels.
   - This could allow unauthorized agents to write to sensitive registers if they have general write access to the register interface.

   d) **No Explicit Privilege Level Checks:**
   - Unlike the examples in the CWE description, there's no explicit checking of privilege levels or agent identities before allowing access to sensitive registers.
   - The code at lines 1751-1784 shows address hit detection for register access, but doesn't include privilege-based filtering.

3. **Potential Vulnerability:**
   - The most significant concern is that the access control for key registers and control registers doesn't appear to differentiate between different agents or privilege levels.
   - This could allow an unauthorized agent with general access to the register interface to read or write sensitive cryptographic material or change control settings.

### Conclusion:

The RTL code shows potential security concerns related to CWE-1220 (Insufficient Granularity of Access Control). The register interface doesn't appear to implement sufficiently granular access control policies that would restrict different agents from accessing sensitive registers based on their privilege levels or identities.

Specifically, the key registers, which contain sensitive cryptographic material, don't have explicit access controls that would prevent unauthorized agents from reading or writing them. Similarly, the control registers that determine the AES operation mode and other settings don't have granular access controls.

This could potentially allow unauthorized agents to:
1. Read or write cryptographic keys
2. Modify control settings to change the AES operation
3. Access sensitive data in the data input/output registers

To address these issues, the design should implement more granular access control that differentiates between different agents and privilege levels, and applies appropriate read/write restrictions based on the sensitivity of each register.
================================== Ai Message ==================================

Security analysis of OpenTitan AES IP at /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/aes

A. Security properties and CSR read/write policies (from documentation)
- Keying and masking
  - Two-share keying for 1st-order masked core; KEY_SHARE0/1 registers hold shares; actual key is XOR of both shares.
  - Masking PRNG reseeded automatically on new key (optional) and at configured block rate; software can manually reseed.
  - Force masks (CTRL_AUX_SHADOWED.FORCE_MASKS) can freeze masks to constant values if enabled at compile-time.
- Control path hardening
  - CTRL_SHADOWED and CTRL_AUX_SHADOWED are shadowed CSRs; invalid double-writes trigger recoverable alert.
  - FSMs and critical mux selectors use sparse encodings with multi-rail checking; faults trigger fatal alert and lock until reset.
- Data path and zeroization
  - Internal state, key material, and data registers are cleared with pseudo-random data (PRD) on reset and via triggers.
  - Output/state masking to prevent leakage of intermediate values; state PRD clearing while finishing rounds.
- Operation modes
  - Automatic vs manual operation; in auto, new input starts operation and output backpressure stalls; in manual, SW triggers START and outputs may be overwritten.
- CSR access policy (registers.md)
  - KEY_SHARE0_0..7, KEY_SHARE1_0..7: write-only; writes only when idle; bus writes ignored when non-idle; read should not reveal content.
  - IV_0..3: read/write but writes ignored when non-idle; IV auto-updated by hardware in some modes.
  - DATA_IN_0..3: write-only; writing all words readies one input block.
  - DATA_OUT_0..3: read-only; backpressure if not read (in auto mode).
  - CTRL_SHADOWED, CTRL_AUX_SHADOWED: shadowed; writes require two identical writes.
  - CTRL_AUX_REGWEN: write-once-to-clear lock bit for CTRL_AUX_SHADOWED.
  - TRIGGER: write-only; START, KEY_IV_DATA_IN_CLEAR, DATA_OUT_CLEAR, PRNG_RESEED.
  - STATUS: read-only; IDLE, STALL, OUTPUT_VALID, OUTPUT_LOST, alerts, etc.

B. Findings in RTL (issues)

Issue 1
- File: hw/ip/aes/rtl/aes_reg_top.sv
- Line numbers: 1678–1708; 1711–1724; 1726–1740; 1758–1772
- Description:
  - Read-data mux mapping is incorrect and violates documented access policies, causing leakage/misread of sensitive data:
    - KEY_SHARE0_0..7 (addr_hit[1..8]) reads return reg2hw.key_share0[*].q, exposing share0 key values to software, despite being documented write-only.
    - KEY_SHARE1_0..3 addresses (addr_hit[9..12]) return data_in_0..3_qs (plaintext input), not key share1 values; this leaks input data under key addresses.
    - KEY_SHARE1_4..7 addresses (addr_hit[13..16]) return '0, not key share1 values (still violating policy; keys should not be readable anyway).
    - DATA_IN_0..3 addresses (addr_hit[21..24]) return '0; contrary to the (incorrect) prior mapping, but the documented policy is write-only. The mapping mismatch shows structural bugs.
  - Security aspect affected: Confidentiality breach via CSR interface; violation of write-only policy for key registers; mis-addressed readback (CWE-1191/CWE-668/CWE-1220).
- Tools used: Anomaly Detector Agent; manual review; CWE Checker Agent (policy mismatch)

Issue 2
- File: hw/ip/aes/rtl/aes_core.sv
- Line numbers: 368–372 (data_in_prev_mux)
- Description:
  - DIP_CLEAR path does not clear; it assigns data_in to data_in_prev when selector is DIP_CLEAR:
    - unique case (data_in_prev_sel) DIP_DATA_IN: data_in; DIP_CLEAR: data_in; default: prd_clearing_data;
  - Effect: When the controller selects DIP_CLEAR (intended to clear previous-input register with PRD), it instead copies current input data, defeating the clearing mechanism and potentially leaking previous input history into feedback modes.
  - Security aspect affected: Zeroization/clearing failure of sensitive data flow (CWE-1239), potential misuse of previous input in CBC/CFB/OFB/CTR and data remanence.
- Tools used: Manual review

Issue 3
- File: hw/ip/aes/rtl/aes_core.sv
- Line numbers: 873–878 (data_out_reg)
- Description:
  - Reset clearing of output data register is gated by data_out_we:
    - if (!rst_ni && data_out_we != SP2V_HIGH) data_out_q <= '0; else if (data_out_we == SP2V_HIGH) data_out_q <= data_out_d;
  - On asynchronous reset (!rst_ni), if data_out_we==SP2V_HIGH (or X) in the same cycle, the output register may not get cleared, leading to residual data after reset.
  - Security aspect affected: Improper zeroization on reset (CWE-1271/CWE-1239); data remnants may persist post-reset.
- Tools used: CWE Checker Agent; Similar Bug Agent (localized at line 873)

Issue 4
- File: hw/ip/aes/rtl/aes.sv
- Line numbers: 181 (approx., in aes_core instantiation)
- Description:
  - SecAllowForcingMasks is hard-set to 1 in the top-level instantiation:
    .SecAllowForcingMasks( 1 )
  - Combined with CTRL_AUX_SHADOWED.FORCE_MASKS, software can force constant masks, substantially degrading side-channel resistance. No lifecycle gating is applied to restrict this in production lifecycle states.
  - While documentation says this is “useful for SCA only,” exposing this control to SW without LC gating or secure lock can be abused by a compromised host to reduce protections.
  - Security aspect affected: Debug/testing feature exposed in production context (CWE-1244: Internal asset exposed through debug/test modes), side-channel hardening defeat.
- Tools used: Manual review, documentation cross-check

Issue 5
- File: hw/ip/aes/rtl/aes_reg_top.sv
- Line numbers: 706–730; 748–853; 1678–1776 (cross-reference)
- Description:
  - Inconsistent access semantics and generated primitives:
    - DATA_IN_0 instantiated with SwAccessRW (u_data_in_0), while DATA_IN_1..3 are SwAccessWO. This is inconsistent with documented write-only policy for all DATA_IN registers.
    - The read mux further mis-uses DATA_IN_*_qs under wrong addresses (see Issue 1), compounding policy violations.
  - Security aspect affected: Policy mismatch and insufficient access control enforcement (CWE-1220), increasing risk of unintended SW readback of sensitive inputs.
- Tools used: Anomaly Detector Agent; manual review

C. Recommendations
- For Issue 1 (aes_reg_top read mux)
  - Correct the reg_rdata_next mapping to match addr_hit indices and documented access policies:
    - KEY_SHARE0/1: return 0 on read (or a safe constant), not the stored q; never expose key shares via CSR.
    - DATA_IN_0..3: return 0 for write-only semantics.
    - Ensure IV_* return current values (rw), DATA_OUT_* return output (ro).
  - Consider formally asserting that write-only CSRs read as zero and that the address decoding to read mux is consistent with addr_hit (onehot and index-based assertions).
- For Issue 2 (DIP_CLEAR not clearing)
  - In data_in_prev_mux, set DIP_CLEAR case to PRD-based clearing:
    - DIP_CLEAR: data_in_prev_d = prd_clearing_data;
  - Add assertion that DIP_CLEAR never forwards data_in.
- For Issue 3 (data_out_reg reset)
  - Use unconditional async reset for data_out_q:
    - if (!rst_ni) data_out_q <= '0; else if (data_out_we == SP2V_HIGH) data_out_q <= data_out_d;
  - Add SVA to assert that after reset release, data_out_q is zero until explicitly written.
- For Issue 4 (FORCE_MASKS exposure)
  - Gate FORCE_MASKS by life-cycle state, or tie SecAllowForcingMasks to 0 for production builds. Enforce CTRL_AUX_REGWEN lock in ROM to prevent post-boot enabling.
  - Add DV test that FORCE_MASKS transitions are blocked in PROD LC state.
- For Issue 5 (DATA_IN access inconsistency)
  - Align DATA_IN_0 to SwAccessWO like others and ensure read mux returns 0 for DATA_IN_*.
  - Add CSR DV tests verifying read-only and write-only behaviors for all relevant registers.

D. Tools usage summary
- Anomaly Detector Agent
  - Found mis-mapped read-case entries and policy inconsistencies in aes_reg_top.sv (Issue 1, 5).
- CWE Checker Agent
  - Flagged zeroization/reset clearing concerns in aes_core.sv (Issue 3) and general CSR policy risks (Issue 1, 5).
- Similar Bug Agent
  - Localized the conditional reset-gating bug in aes_core.sv at line 873 (Issue 3).
- Manual review
  - Identified the DIP_CLEAR clearing bug (Issue 2) and FORCE_MASKS exposure (Issue 4).
- Documentation cross-check
  - Used doc/registers.md and doc/theory_of_operation.md to validate intended access policies and security features.

END


Token Usage Summary:
===================
Total API Calls: 24
Total Input Tokens: 1,108,327
Total Output Tokens: 21,648
Total Tokens: 1,129,975
Average Input Tokens/Call: 46180.3
Average Output Tokens/Call: 902.0
Average Total Tokens/Call: 47082.3


Detailed Call History:
==================================================
Call 1: gpt-5-2025-08-07 - Input: 1063, Output: 107, Total: 1170
Call 2: gpt-5-2025-08-07 - Input: 1248, Output: 45, Total: 1293
Call 3: gpt-5-2025-08-07 - Input: 1375, Output: 40, Total: 1415
Call 4: gpt-5-2025-08-07 - Input: 1508, Output: 45, Total: 1553
Call 5: gpt-5-2025-08-07 - Input: 8772, Output: 43, Total: 8815
Call 6: gpt-5-2025-08-07 - Input: 16439, Output: 47, Total: 16486
Call 7: gpt-5-2025-08-07 - Input: 16771, Output: 120, Total: 16891
Call 8: gpt-5-2025-08-07 - Input: 39685, Output: 247, Total: 39932
Call 9: gpt-5-2025-08-07 - Input: 48802, Output: 50, Total: 48852
Call 10: gpt-5-2025-08-07 - Input: 49708, Output: 49, Total: 49757
Call 11: gpt-5-2025-08-07 - Input: 62937, Output: 1721, Total: 64658
Call 12: gpt-5-2025-08-07 - Input: 73443, Output: 49, Total: 73492
Call 13: gpt-5-2025-08-07 - Input: 81148, Output: 48, Total: 81196
Call 14: gpt-5-2025-08-07 - Input: 85159, Output: 122, Total: 85281
Call 15: gpt-5-2025-08-07 - Input: 88353, Output: 1720, Total: 90073
Call 16: gpt-5-2025-08-07 - Input: 94166, Output: 793, Total: 94959
Call 17: gpt-5-2025-08-07 - Input: 95121, Output: 458, Total: 95579
Call 18: gpt-5-mini-2025-08-07 - Input: 356, Output: 55, Total: 411
Call 19: gpt-5-mini-2025-08-07 - Input: 13585, Output: 987, Total: 14572
Call 20: gpt-5-2025-08-07 - Input: 95221, Output: 3024, Total: 98245
Call 21: gpt-5-mini-2025-08-07 - Input: 18220, Output: 119, Total: 18339
Call 22: gpt-5-mini-2025-08-07 - Input: 20888, Output: 4804, Total: 25692
Call 23: gpt-5-2025-08-07 - Input: 96776, Output: 986, Total: 97762
Call 24: gpt-5-2025-08-07 - Input: 97583, Output: 5969, Total: 103552
    


Token Usage Summary:
===================
Total API Calls: 24
Total Input Tokens: 1,108,327
Total Output Tokens: 21,648
Total Tokens: 1,129,975
Average Input Tokens/Call: 46180.3
Average Output Tokens/Call: 902.0
Average Total Tokens/Call: 47082.3


Detailed Call History:
==================================================
Call 1: gpt-5-2025-08-07 - Input: 1063, Output: 107, Total: 1170
Call 2: gpt-5-2025-08-07 - Input: 1248, Output: 45, Total: 1293
Call 3: gpt-5-2025-08-07 - Input: 1375, Output: 40, Total: 1415
Call 4: gpt-5-2025-08-07 - Input: 1508, Output: 45, Total: 1553
Call 5: gpt-5-2025-08-07 - Input: 8772, Output: 43, Total: 8815
Call 6: gpt-5-2025-08-07 - Input: 16439, Output: 47, Total: 16486
Call 7: gpt-5-2025-08-07 - Input: 16771, Output: 120, Total: 16891
Call 8: gpt-5-2025-08-07 - Input: 39685, Output: 247, Total: 39932
Call 9: gpt-5-2025-08-07 - Input: 48802, Output: 50, Total: 48852
Call 10: gpt-5-2025-08-07 - Input: 49708, Output: 49, Total: 49757
Call 11: gpt-5-2025-08-07 - Input: 62937, Output: 1721, Total: 64658
Call 12: gpt-5-2025-08-07 - Input: 73443, Output: 49, Total: 73492
Call 13: gpt-5-2025-08-07 - Input: 81148, Output: 48, Total: 81196
Call 14: gpt-5-2025-08-07 - Input: 85159, Output: 122, Total: 85281
Call 15: gpt-5-2025-08-07 - Input: 88353, Output: 1720, Total: 90073
Call 16: gpt-5-2025-08-07 - Input: 94166, Output: 793, Total: 94959
Call 17: gpt-5-2025-08-07 - Input: 95121, Output: 458, Total: 95579
Call 18: gpt-5-mini-2025-08-07 - Input: 356, Output: 55, Total: 411
Call 19: gpt-5-mini-2025-08-07 - Input: 13585, Output: 987, Total: 14572
Call 20: gpt-5-2025-08-07 - Input: 95221, Output: 3024, Total: 98245
Call 21: gpt-5-mini-2025-08-07 - Input: 18220, Output: 119, Total: 18339
Call 22: gpt-5-mini-2025-08-07 - Input: 20888, Output: 4804, Total: 25692
Call 23: gpt-5-2025-08-07 - Input: 96776, Output: 986, Total: 97762
Call 24: gpt-5-2025-08-07 - Input: 97583, Output: 5969, Total: 103552
    
