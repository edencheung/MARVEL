================================ System Message ================================


    You are a supervisor agent in a multi-agent system focused on identifying hardware security vulnerabilities in RTL code. 
    Your objective is to analyze the given SoC and generate a detailed security report.

    You have access to the following tools: ['run_anomaly_detector_agent', 'run_llm_cwe_checker_agent', 'run_similar_bug_agent', 'list_dir', 'read_file', 'read_file_with_line_numbers']. Each tool specializes in a specific task:

    - CWE Agent: Given a Verilog file, a top module, and a security aspect, this agent maps the RTL code to relevant CWEs and detects CWE-related vulnerabilities.
    - Similar Bug Agent: Accepts a file path and a line number (where a bug was found) to locate similar patterns or recurring bugs throughout the RTL code.

    Instructions for analysis:

    - Read the documentataion to identify security features and register interfaces policies.
    - Read through the different systemverilog files to probe for issues and use the anomaly agent
    - If a bug is detected but not localized, use the CWE Agent to further inspect the related security aspect in the surrounding RTL.
    - After detecting any bugs, use the Similar Bug Agent to scan similar files (of the same or of different IPs) for similar vulnerabilities.

    Output Format:

    - For each identified issue, report:
    - File name
    - Line number(s)
    - Brief description of the issue
    - Security aspect affected
    - Tools used to identify the issue

    When your analysis is complete, end your response with "END".
    
================================ Human Message =================================

Identify security issues in the keymgr IP of the OpenTitan SoC, located at /home/eden/Desktop/Code/HACK@CHES/p2/opentitan.

    - All IPs are located in the 'hw/ip' directory.
    - RTL code for each IP is located in its 'rtl' subdirectory, with source files having the '.sv' extension.
        - reg_top files contain the register interface for the IP.
        - control/fsm files contain the control logic for the IP.
        - core files contain the core logic for the IP.
    - Documentation files (.md) are located in the 'doc' directories of each IP.
        - theory_of_operation explains the properties of the IP and its security features.
        - registers.md files contain the register interface and its read/write access policies.
    - Ignore '.core' files; they are used by build tools and are not relevant for security analysis.

    Focus on the keymgr IP and make sure to analyze it thoroughly.

    First, identify the relevant security properties and read/write policies of the register interfaces from the documentation. 
    Then, use all available tools to perform a comprehensive security analysis on the RTL code.
    
================================== Ai Message ==================================
Tool Calls:
  list_dir (call_y6hTNqLPUwuTmc5FB9D0vUhz)
 Call ID: call_y6hTNqLPUwuTmc5FB9D0vUhz
  Args:
    dir_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip
================================= Tool Message =================================
Name: list_dir

Files in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip:
README.md BUILD

Directories in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip:
pattgen csrng aon_timer prim_generic keymgr_dpe uart keymgr i2c dma spi_host otp_ctrl rom_ctrl spi_device edn usbdev adc_ctrl trial1 kmac flash_ctrl otp_macro rv_dm mbx rv_timer prim_xilinx prim prim_xilinx_ultrascale aes lc_ctrl hmac rv_core_ibex sram_ctrl entropy_src racl_ctrl sysrst_ctrl tlul soc_dbg_ctrl otbn ascon
================================== Ai Message ==================================
Tool Calls:
  list_dir (call_SZH0a2Cb7owYh54P9pWXfttm)
 Call ID: call_SZH0a2Cb7owYh54P9pWXfttm
  Args:
    dir_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr
================================= Tool Message =================================
Name: list_dir

Files in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr:
keymgr_pkg.core README.md keymgr.core BUILD defs.bzl keymgr_common.core

Directories in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr:
data syn dv rtl lint doc
================================== Ai Message ==================================
Tool Calls:
  list_dir (call_jZ0Re2UuMZTs0wHqChWEluXJ)
 Call ID: call_jZ0Re2UuMZTs0wHqChWEluXJ
  Args:
    dir_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/doc
================================= Tool Message =================================
Name: list_dir

Files in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/doc:
registers.md interfaces.md keymgr_kmac_if_diagram.svg keymgr_block_diagram.svg checklist.md keymgr_functional_model.svg programmers_guide.md keymgr_control_diagram.svg theory_of_operation.md

Directories in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/doc:

================================== Ai Message ==================================
Tool Calls:
  read_file (call_CfuTFuVkxBcEimMgZamruRRI)
 Call ID: call_CfuTFuVkxBcEimMgZamruRRI
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/doc/theory_of_operation.md
================================= Tool Message =================================
Name: read_file

# Theory of Operation

Key manager behavior can be summarized by the functional model below.

![Key Manager Functional Model](../doc/keymgr_functional_model.svg)

In the diagram, the red boxes represent the working state and the associated internal key, the black ovals represent derivation functions, the green squares represent software inputs, and the remaining green / purple shapes represent outputs to both software and hardware.

In OpenTitan, the derivation method selected is [KMAC](../../kmac/README.md).
Each valid operation involves a KMAC invocation using the key manager internal key and other HW / SW supplied inputs as data.
While KMAC can generate outputs of arbitrary length, this design fixes the size to 256b.

Effectively, the key manager behavior is divided into 3 classes of functions
*  Key manager state advancement
   *  The results are never visible to software and not directly usable by any software controlled hardware

*  Output key generation
   *  Results can be visible to software or consumed by hardware (sideload)

*  Identity / seed generation
   *  Results are always visible to software and used for asymmetric cryptography

In general, the key generation and seed generation functions are identical.
They differ only in how software chooses to deploy the outputs.

For clarity, all commands issued to the key manager by software are referred to as operations.
Transactions refer to the interaction between key manager and KMAC if a valid operation is issued.

## Key Manager State

The key manager working state (red boxes in the functional model) represents both the current state of the key manager as well as its related internal key.
Each valid state (`Initialized` / `CreatorRootKey` / `OwnerIntermediateKey` / `OwnerRootKey`), supplies its secret material as the "key" input to a KMAC operation.
Invalid states, such as `Reset / Disabled` on the other hand, either do not honor operation requests, or supplies random data when invoked.

The data input is dependent on each state, see below.

### Reset
To begin operation, the state must first transition to Initialize.
The advancement from `Reset` to `Initialized` is irreversible during the current power cycle.
Until the initialize command is invoked, the key manager rejects all other software commands.

### Initialized

When transitioning from `Reset` to `Initialized`, random values obtained from the entropy source are used to populate the internal key first.
Then the root key stored in OTP, if valid, is loaded into the internal key.
This ensures that the hamming delta from the previous value to the next value is non-deterministic.
The advancement from `Initialized` to `CreatorRootKey` is irreversible during the current power cycle.

### CreatorRootKey

`CreatorRootKey` is the first operational state of the key manager.
When transitioning from `Initialized` to this state, a KMAC operation is invoked using the `RootKey` as the key (from OTP), and the remaining inputs as data.
The output of the KMAC operation replaces the previous value of the internal key, and the new value becomes the `CreatorRootKey`.

Inputs to the derivation function are:
*  `HardwareRevisionSecret`: A global design time constant.
*  `ROMHash`: SHA-3-256 hash of the ROM image.
*  `HealthMeasurement`: Current life cycle state
   *  To avoid a state value corresponding to each life cycle state, the raw life cycle value is not used.
   *  Instead, certain life cycle states diversify the same way.
   *  Please see the life cycle controller for more details.
*  `DeviceIdentifier`: Unique device identification.
*  `SoftwareBinding`: A software programmed value related to ROMExt.


Other than `HardwareRevisionSecret`, none of the values above are considered secret.

Once the `CreatorRootKey` is reached, software can request key manager to advance state, generate output key or generate output identity.
The key used for all 3 functions is the `CreatorRootKey`.

The advancement from `CreatorRootKey` to the `OwnerIntermediateKey` is irreversible during the current power cycle.

Keymgr reads the root key from OTP in a single clock cycle. It assumes that when keymgr's internal FSM reaches to this clock cycle, OTP root key is already available (`valid` is set to 1). Otherwise, keymgr skips loading the root key.

### OwnerIntermediateKey

This is the second operational state of the key manager.
This state is reached through another invocation of the KMAC operation using the previous internal key, and other inputs as data.
The output of the KMAC operation replaces the previous value of the internal key, and the new value becomes the `OwnerIntermediateKey`.

The relevant data inputs are:
*  `CreatorSecret`: A secret seed from flash determined by the SiliconCreator.
*  `SoftwareBinding`: A software programmed value representing the first owner code to be run.

Once the `OwnerIntermediateKey` is created, software can request key manager to advance state, generate output key or generate output identity.
The key used for all 3 functions is the `OwnerIntermediateKey`.

The advancement from `OwnerIntermediateKey` to the `OwnerRootKey` is irreversible during the current power cycle.

### OwnerRootKey

This is the last operational state of the key manager.
This state is reached through another invocation of the KMAC operation using the previous internal key, and other inputs as data.
The output of the KMAC operation replaces the previous value of the internal key, and the new value becomes the `OwnerRootKey`.

The relevant inputs are:
*  `OwnerRootSecret`: Secret seed from flash.
*   `SoftwareBinding` - A software programmed value representing the owner kernel code.

Once the `OwnerRootKey` is created, software can request key manager to advance state, generate output key or generate output identity.
An advance command invoked from `OwnerRootKey` state simply moves the state to `Disabled`.

The generate output and generate identity functions use `OwnerRootKey` as the KMAC key.
The advancement from `OwnerRootKey` to the `Disabled` is irreversible during the current power cycle.

### Disabled
`Disabled` is a state where the key manager is no longer operational.
Upon `Disabled` entry, the internal key is updated with KMAC computed random values; however, previously generated sideload key slots and software key slots are preserved.
This allows the software to keep the last valid keys while preventing the system from further advancing the valid key.

When advance and generate calls are invoked from this state, the outputs and keys are indiscriminately updated with randomly computed values.
Key manager enters disabled state based on direct invocation by software:
* Advance from `OwnerRootKey`
* Disable operation

### Invalid
`Invalid` state is entered whenever key manager is deactivated through the [life cycle connection](#life-cycle-connection) or when an operation encounters a [fault](#faults-and-operational-faults) .
Upon `Invalid` entry, the internal key, the sideload key slots and the software keys are all wiped with entropy directly.

#### Invalid Entry Wiping
Since the life cycle controller can deactivate the key manager at any time, the key manager attempts to gracefully handle the wiping process.
When deactivated, the key manager immediately begins wiping all keys (internal key, hardware sideload key, software key) with entropy.
However, if an operation was already ongoing, the key manager waits for the operation to complete gracefully before transitioning to invalid state.

While waiting for the operation to complete, the key manager continuously wipes all keys with entropy.

### Invalid and Disabled State

`Invalid` and `Disabled` states are functionally very similar.
The main difference between the two is "how" the states were reached and the entry behavior.

`Disabled` state is reached through intentional software commands where the sideload key slots and software key are not wiped, while `Invalid` state is reached through life cycle deactivation or operational faults where the internal key, sideload key slots and software key are wiped.

This also means that only `Invalid` is a terminal state.
If after entering `Disabled` life cycle is deactivated or a fault is encountered, the same [invalid entry procedure](#Invalid) is followed to bring the system to a terminal `Invalid` state.

If ever multiple conditions collide (a fault is detected at the same time software issues disable command), the `Invalid` entry path always takes precedence.

## Life Cycle Connection
The function of the key manager is directly managed by the [life cycle controller](../../lc_ctrl/README.md#key_manager_en).

Until the life cycle controller activates the key manager, the key manager does not accept any software commands.
Once the key manager is activated by the life cycle controller, it is then allowed to transition to the various states previously [described](#key-manager-states).

When the life cycle controller deactivates the key manager, the key manager transitions to the `Invalid` state.

## Commands in Each State
During each state, there are 3 valid commands software can issue:
*  Advance state
*  Output generation
*  Identity generation

The software is able to select a command and trigger the key manager FSM to process one of the commands.
If a command is valid during the current working state, it is processed and acknowledged when complete.

If a command is invalid, the behavior depends on the current state.
If the current state is `Reset`, the invalid command is immediately rejected as the key manager FSM has not yet been initialized.
If the current state is any other state, the key manager sequences random, dummy data to the KMAC module, but does not update internal key, sideload key slots or software keys.
For each valid command, a set of inputs are selected and sequenced to the KMAC module.

During `Disable` and `Invalid` states, the internal key, sideload key slots and software key are updated based on the input commands as with normal states.
There are however a few differences:
-  The updates are made regardless of any error status to ensure their values are further scrambled.
-  Instead of normal input data, random data is selected for KMAC processing.
-  All operations return an invalid operations error, in addition to any other error that might naturally occur.

## Generating Output Key
The generate output command is composed of 2 options
*  Generate output key for software, referred to as `generate-output-sw`
*  Generate output key for hardware, referred to as `generate-output-hw`

The hardware option is meant specifically for symmetric sideload use cases.
When this option is issued, the output of the KMAC invocation is not stored in software visible registers, but instead in hardware registers that directly output to symmetric primitives such as AES, KMAC and OTBN.

## KMAC Operations
All invoked KMAC operations expect the key in two shares.
This means the internal key, even though functionally 256b, is maintained as 512b.
The KMAC processed outputs are also in 2-shares.
For `generate-output-sw` commands, software is responsible for determining whether the key manager output should be preserved in shares or combined.

## Errors, Faults and Alerts

The key manager has two overall categories of errors:
* Recoverable errors
* Fatal errors

Recoverable errors are those likely to have been introduced by software and not fatal to the key manager or the system.
Fatal errors are logically impossible errors that have a high likelihood of being a fault and thus fatal.

Each category of error can be further divided into two:
* Synchronous errors
* Asynchronous errors

Synchronous errors happen only during a key manager operation.
Asynchronous errors can happen at any time.

Given the above, we have 4 total categories of errors:
* Synchronous recoverable errors
* Asynchronous recoverable errors
* Synchronous fatal errors
* Asynchronous fatal errors

All recoverable errors (synchronous and asynchronous) are captured in [`ERR_CODE`](registers.md#err_code).
All fatal errors (synchronous and asynchronous) are captured in [`FAULT_STATUS`](registers.md#fault_status).

Recoverable errors cause a recoverable alert to be sent from the key manager.
Fatal errors cause a fatal alert to be sent from the key manager.

Below, the behavior of each category and its constituent errors are described in detail.

### Synchronous Recoverable Errors

These errors can only happen when a key manager operation is invoked and are typically associated with incorrect software programming.
At the end of the operation, key manager reports whether there was an error in [`ERR_CODE`](registers.md#err_code) and sends a recoverable alert.

* [`ERR_CODE.INVALID_OP`](registers.md#err_code) Software issued an invalid operation given the current key manager state.
* [`ERR_CODE.INVALID_KMAC_INPUT`](registers.md#err_code) Software supplied invalid input (for example a key greater than the max version) for a key manager operation.

### Asynchronous Recoverable Errors

These errors can happen at any time regardless of whether there is a key manager operation.
The error is reported in [`ERR_CODE`](registers.md#err_code) and the key manager sends a recoverable alert.

* [`ERR_CODE.INVALID_SHADOW_UPDATE`](registers.md#err_code) Software performed an invalid sequence while trying to update a key manager shadow register.

### Synchronous Fatal Errors

These errors can only happen when a key manager operation is invoked and receives malformed operation results that are not logically possible.
At the end of the operation, key manager reports whether there was an error in [`FAULT_STATUS`](registers.md#fault_status) and continuously sends fatal alerts .

Note, these errors are synchronous from the perspective of the key manager, but they may be asynchronous from the perspective of another module.

### Asynchronous Fatal Errors

These errors can happen at any time regardless of whether there is a key manager operation.
The error is reported in [`FAULT_STATUS`](registers.md#fault_status) and the key manager continuously sends fatal alerts.


### Faults and Operational Faults

When a fatal error is encountered, the key manager transitions to the `Invalid` [state](#invalid-entry-wiping).
The following are a few examples of when the error occurs and how the key manager behaves.

#### Example 1: Fault During Initialization
The key manager is in the `Reset` state and receives an advance operation.
After it has reseeded its internal PRNG with entropy, it will try to load the Creator Root Key from OTP.
If not both shares of the Creator Root Key are valid at that point, key manager will wipe its secrets and transition to the `Invalid` state.

#### Example 2: Fault During Operation
The key manager is running a generate operation and a non-onehot command was observed by the KMAC interface.
Since the non-onehot condition is a fault, it is reflected in [`FAULT_STATUS`](registers.md#fault_status) and a fatal alert is generated.
The key manager transitions to `Invalid` state, wipes internal storage and reports an invalid operation in [`ERR_CODE.INVALID_OP`](registers.md#err_code).

#### Example 3: Fault During Idle
The key manager is NOT running an operation and is idle.
During this time, a fault is observed on the regfile (shadow storage error) and FSM (control FSM integrity error).
The faults are reflected in [`FAULT_STATUS`](registers.md#fault_status).
The key manager transitions to `Invalid` state, wipes internal storage but does not report an invalid operation.

#### Example 4: Operation after Fault Detection
Continuing from the example above, the key manager now begins an operation.
Since the key manager is already in `Invalid` state, it does not wipe internal storage and reports an invalid operation in [`ERR_CODE.INVALID_OP`](registers.md#err_code).

#### Additional Details on Invalid Input

What is considered invalid input changes based on current state and operation.

When an advance operation is invoked:
- The internal key is checked for all 0's and all 1's.
- During the `Reset` state, both shares of the the Creator Root Key provided by OTP are checked to be valid.
- During `Initialized` state, creator seed, device ID and health state data is checked for all 0's and all 1's.
- During `CreatorRootKey` state, the owner seed is checked for all 0's and all 1's.
- During all other states, nothing is explicitly checked.

When a generate output key operation is invoked:
- The internal key is checked for all 0's and all 1's.
- The key version is less than or equal to the max key version.

When a generate output identity is invoked:
- The internal key is checked for all 0's and all 1's.

#### Invalid Operation

The table below enumerates the legal operations in a given state.
When an illegal operation is supplied, the error code is updated and the operation is flagged as `done with error`.

| Current State    | Legal Operations               |
| -------------    | ------------------------------ |
| Reset            | Advance                        |
| Initialized      | Disable / Advance              |
| CreatorRootKey   | Disable / Advance / Generate   |
| OwnerIntKey      | Disable / Advance / Generate   |
| OwnerRootKey     | Disable / Advance / Generate   |
| Invalid/Disabled | None                           |

*  All operations invoked during `Invalid` and `Disabled` states lead to invalid operation error.

### Error Response
In addition to alerts and interrupts, key manager may also update the internal key and relevant outputs based on current state.
See the tables below for an enumeration.

| Current State    | Invalid States  | Invalid Output | Invalid Input | Invalid Operation   |
| -------------    | ----------------| ---------------|---------------|---------------------|
| Reset            | Not Possible    | Not Possible   | Not possible  | Not updated         |
| Initialized      | Updated         | Updated        | Not updated   | Not updated         |
| CreatorRootKey   | Updated         | Updated        | Not updated   | Not possible        |
| OwnerIntKey      | Updated         | Updated        | Not updated   | Not possible        |
| OwnerRootKey     | Updated         | Updated        | Not updated   | Not possible        |
| Invalid/Disabled | Updated         | Updated        | Updated       | Updated             |

*  During `Reset` state, the KMAC module is never invoked, thus certain errors are not possible.
*  During `Initialized`, `CreatorRootKey`, `OwnerIntermediateKey` and `OwnerRootKey` states, a fault error causes the relevant key / outputs to be updated; however an operational error does not.
*  During `Invalid` and `Disabled` states, the relevant key / outputs are updated regardless of the error.
*  Only the relevant collateral is updated -> ie, advance / disable command leads to working key update, and generate command leads to software or sideload key update.
*  During `Disabled` state, if life cycle deactivation or an operational fault is encountered, the key manager transitions to `Invalid` state, see [here](#invalid-and-disabled-state)

## DICE Support

The key manager supports [DICE open profile](https://pigweed.googlesource.com/open-dice/+/HEAD/docs/specification.md#Open-Profile-for-DICE).
Specifically, the open profile has two compound device identifiers.
* Attestation CDI
* Sealing CDI

The attestation CDI is used to attest hardware and software configuration and is thus expected to change between updates.
The sealing CDI on the other hand, is used to attest the authority of the hardware and software configuration.
The sealing version is thus expected to remain stable across software updates.

To support these features, the key manager maintains two versions of the working state and associated internal key.
There is one version for attestation and one version for sealing.

The main difference between the two CDIs is the different usage of `SW_BINDING`.
For the Sealing CDI, the [`"SEALING_SW_BINDING"`](registers.md#sealing_sw_binding) is used, all other inputs are the same.
For the Attestation CDI, the [`"ATTEST_SW_BINDING"`](registers.md#attest_sw_binding) is used, all other inputs are the same.

When invoking an advance operation, both versions are advanced, one after the other.
There are thus two KMAC transactions.
The first transaction uses the Sealing CDI internal key, [`"SEALING_SW_BINDING"`](registers.md#sealing_sw_binding) and other common inputs.
The second transaction uses the Attestation CDI internal key, [`"ATTEST_SW_BINDING"`](registers.md#attest_sw_binding) and other common inputs.

When invoking a generate operation, the software must specify which CDI to use as the source key.
This is done through [`"CONTROL.CDI_SEL"`](registers.md#control).
Unlike the advance operation, there is only 1 KMAC transaction since we pick a specific CDI to operate.

When disabling, both versions are disabled together.


## Block Diagram
The following is a high level block diagram of the key manager.

![Key Manager Block Diagram](../doc/keymgr_block_diagram.svg)

## Design Details

Key manager is primarily composed of two components:
*  keymgr_ctrl
*  keymgr_kmac_if

### Key Manager Control

The key manager control block manages the working state, sideload key updates, as well as what commands are valid in each state.
It also handles the life cycle `keymgr_en` input, which deactivates the entire key manager function in the event of an escalation.

![Key Manager Control Block Diagram](../doc/keymgr_control_diagram.svg)


### KMAC Interface Control

The KMAC interface control represents the bulk of key manager logic.
Based on input from key manager control, this module selects the inputs for each given command and sequences the data to KMAC.

![Key Manager KMAC Interface Block Diagram](../doc/keymgr_kmac_if_diagram.svg)

The KMAC interface works on a simple `valid / ready` protocol.
When there is data to send, the KMAC interface sends out a `valid` and keeps it active.
When the destination accepts the transaction, the `ready` is asserted.
Note just like with any bus interface, the `ready` may already be asserted when `valid` asserts, or it may assert some time later, there are no restrictions.
Since the data to be sent is always pre-buffered in key manager, the valid, once asserted, does not de-assert until the entire transaction is complete.

The data interface itself is 64b wide.
However, there may not always be 64b multiple aligned data to be sent.
In these situations, the last transfer beat sent to KMAC has a byte mask / strobe attached.
The byte mask indicates on the last beat which bytes are actually valid, and which are not.
Not beats prior to the last always have fully asserted byte masks.

Once KMAC receives all the required data and the last indication, it begins processing the data into a digest.
This process may take an arbitrary number of cycles.
When this process is complete, a `done` indication pulse is sent back with the digest.
Note, the acceptance of `done` has no back-pressure and `keymgr` must accept it within one cycle.

See diagram below for an example transfer:

```wavejson
{signal: [
  {name: 'kmac_data_o.valid',     wave: '01...........|....0..'},
  {name: 'kmac_data_i.ready',     wave: '1...0..101...|.......'},
  {name: 'kmac_data_o.data',      wave: 'x2222...2.222|2222x..'},
  {name: 'kmac_data_o.last',      wave: '0................10..'},
  {name: 'kmac_data_o.strb',      wave: 'x2...............2x..'},
  {name: 'kmac_data_i.done',      wave: '0..................10'},
  {name: 'kmac_data_i.digest*',   wave: 'x..................3x'},
  ],
}
```

### Sideload Keys

There are three sideload keys.
One for AES, one for KMAC and one for OTBN.
When a sideload key is generated successfully through the `generate-output-hw` command, the derived data is loaded into key storage registers.
There is a set of storage registers for each destination.

The KMAC key however is further overloaded as it is the main derivation mechanism for key manager internal stage.
The KMAC key thus has two possible outputs, one is the sideload key, and the other is internal state key.

When a valid operation is called, the internal state key is sent over the KMAC key.
During all other times, the sideloaded value is presented.
Note, there may not be a valid key in the sideload register if it has been cleared or never generated.
The sideload key can be overwritten with another generate command, or cleared with entropy through [`SIDELOAD_CLEAR`](registers.md#sideload_clear).

The clearing can be done one slot at a time, or all at once.
Once a clearing bit is enabled for a particular key slot, its value is continuously re-randomized every clock cycle.
Therefore, SW is responsible for toggling this bit back to disabled state, which makes the last random value remain stable on the sideload slot.
Otherwise, the sideload key slot is continuously randomized which prevents sideloading an actual key to the target HWIP.

The following diagram illustrates an example when there is no valid key in the KMAC sideload registers and an operation is called.
During the duration of the operation, the key is valid and shows the internal key state.
Once the operation is complete, it falls back to the sideload key state, which is invalid in this case.

```wavejson
{signal: [
  {name: 'u_sideload_ctrl.u_kmac_key.key_o.valid',     wave: '0................'},
  {name: 'u_sideload_ctrl.u_kmac_key.key_o.key_share', wave: 'x................'},
  {name: 'u_ctrl.key_o.valid',                         wave: '0................'},
  {name: 'u_ctrl.key_o.key_share',                     wave: 'x................'},
  {name: 'u_ctrl.op_start_i',                          wave: '0....1.....0.....'},
  {name: 'kmac_key_o.valid',                           wave: '0....1.....0.....'},
  {name: 'kmac_key_o.key_share*',                      wave: 'x....3.....x.....'},
  ],
}
```

The following diagram illustrates an example when there is a valid key in the KMAC sideload registers and an operation is called.
During the duration of the operation, the key is valid and shows the internal key state.
Once the operation is complete, it falls back to the sideload key state, which is valid and contains a different value.

```wavejson
{signal: [
  {name: 'u_sideload_ctrl.u_kmac_key.key_o.valid',     wave: '01...............'},
  {name: 'u_sideload_ctrl.u_kmac_key.key_o.key_share', wave: 'x4...............'},
  {name: 'u_ctrl.key_o.valid',                         wave: '0....1.....0.....'},
  {name: 'u_ctrl.key_o.key_share',                     wave: 'x................'},
  {name: 'u_ctrl.op_start_i',                          wave: '0....1.....0.....'},
  {name: 'kmac_key_o.valid',                           wave: '01...............'},
  {name: 'kmac_key_o.key_share*',                      wave: 'x4...3.....4.....'},
  ],
}
```


### Software Binding

The identities flow employs an idea called [software binding](https://docs.opentitan.org/doc/security/specs/identities_and_root_keys/#software-binding) to ensure that a particular key derivation scheme is only reproducible for a given software configuration.
The binding is created through the secure boot flow, where each stage sets the binding used for the next verified stage before advancing to it.
The software binding is used during the following state transitions only:
-  `Initialized` to `CreatorRootKey`
-  `CreatorRootKey` to `OwnerIntermedaiteKey`
-  `OwnerIntermediateKey` to `OwnerRootKey`

In order to save on storage and not have a duplicate copy per stage, the software binding registers [`SOFTWARE_BINDING`](registers.md#software_binding) are shared between key manager stages.

Software sets the appropriate values and locks it by clearing [`SOFT_BINDING_EN`](registers.md#soft_binding_en).
When later a successful `advance` call is made, the key manager then unlocks by setting [`SOFT_BINDING_EN`](registers.md#soft_binding_en) to 1.
An unsuccessful advance call (errors) does not unlock the binding.
This allows the next stage of software to re-use the binding registers.

### Custom Security Checks

The keymgr has several custom security checks.

#### One-Hot Command Check
The command received by the KMAC interface must always be in one-hot form and unchanging during the life time of a KMAC transaction.
If this check fails, an error is reflected in [`FAULT_STATUS.CMD`](registers.md#fault_status).

#### Unexpected KMAC Done
The `kmac_done` signal can only happen during the expected transaction window.
If this check fails, an error is reflected in [`FAULT_STATUS.KMAC_DONE`](registers.md#fault_status).

#### Control State Machine Check
This error checks for two things:
-  The key manager can advance to one of the key states (e.g. RootKey, OwnerIntermediateKey) only when there is a legal advanced operation.
-  The key manager can issue an advance or generate operation to the KMAC interface only if the original software request is an advanced or generate command.

If these checks fail, an error is reflected in [`FAULT_STATUS.CTRL_FSM_CHK`](registers.md#fault_status).

#### Sideload Select Check
A sideload key slot is selected for update only if the original software request targeted that key slot.

If this check fails, an error is reflected in [`FAULT_STATUS.SIDE_CTRL_SEL`](registers.md#fault_status).

================================== Ai Message ==================================
Tool Calls:
  read_file (call_kqJscscNigIsLJxj5jJB2loi)
 Call ID: call_kqJscscNigIsLJxj5jJB2loi
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/doc/registers.md
================================= Tool Message =================================
Name: read_file

# Registers

<!-- BEGIN CMDGEN util/regtool.py -d ./hw/ip/keymgr/data/keymgr.hjson -->
## Summary

| Name                                                                       | Offset   |   Length | Description                                                                |
|:---------------------------------------------------------------------------|:---------|---------:|:---------------------------------------------------------------------------|
| keymgr.[`INTR_STATE`](#intr_state)                                         | 0x0      |        4 | Interrupt State Register                                                   |
| keymgr.[`INTR_ENABLE`](#intr_enable)                                       | 0x4      |        4 | Interrupt Enable Register                                                  |
| keymgr.[`INTR_TEST`](#intr_test)                                           | 0x8      |        4 | Interrupt Test Register                                                    |
| keymgr.[`ALERT_TEST`](#alert_test)                                         | 0xc      |        4 | Alert Test Register                                                        |
| keymgr.[`CFG_REGWEN`](#cfg_regwen)                                         | 0x10     |        4 | Key manager configuration enable                                           |
| keymgr.[`START`](#start)                                                   | 0x14     |        4 | Key manager operation start                                                |
| keymgr.[`CONTROL_SHADOWED`](#control_shadowed)                             | 0x18     |        4 | Key manager operation controls                                             |
| keymgr.[`SIDELOAD_CLEAR`](#sideload_clear)                                 | 0x1c     |        4 | sideload key slots clear                                                   |
| keymgr.[`RESEED_INTERVAL_REGWEN`](#reseed_interval_regwen)                 | 0x20     |        4 | regwen for reseed interval                                                 |
| keymgr.[`RESEED_INTERVAL_SHADOWED`](#reseed_interval_shadowed)             | 0x24     |        4 | Reseed interval for key manager entropy reseed                             |
| keymgr.[`SW_BINDING_REGWEN`](#sw_binding_regwen)                           | 0x28     |        4 | Register write enable for SOFTWARE_BINDING                                 |
| keymgr.[`SEALING_SW_BINDING_0`](#sealing_sw_binding)                       | 0x2c     |        4 | Software binding input to sealing portion of the key manager.              |
| keymgr.[`SEALING_SW_BINDING_1`](#sealing_sw_binding)                       | 0x30     |        4 | Software binding input to sealing portion of the key manager.              |
| keymgr.[`SEALING_SW_BINDING_2`](#sealing_sw_binding)                       | 0x34     |        4 | Software binding input to sealing portion of the key manager.              |
| keymgr.[`SEALING_SW_BINDING_3`](#sealing_sw_binding)                       | 0x38     |        4 | Software binding input to sealing portion of the key manager.              |
| keymgr.[`SEALING_SW_BINDING_4`](#sealing_sw_binding)                       | 0x3c     |        4 | Software binding input to sealing portion of the key manager.              |
| keymgr.[`SEALING_SW_BINDING_5`](#sealing_sw_binding)                       | 0x40     |        4 | Software binding input to sealing portion of the key manager.              |
| keymgr.[`SEALING_SW_BINDING_6`](#sealing_sw_binding)                       | 0x44     |        4 | Software binding input to sealing portion of the key manager.              |
| keymgr.[`SEALING_SW_BINDING_7`](#sealing_sw_binding)                       | 0x48     |        4 | Software binding input to sealing portion of the key manager.              |
| keymgr.[`ATTEST_SW_BINDING_0`](#attest_sw_binding)                         | 0x4c     |        4 | Software binding input to the attestation portion of the key manager.      |
| keymgr.[`ATTEST_SW_BINDING_1`](#attest_sw_binding)                         | 0x50     |        4 | Software binding input to the attestation portion of the key manager.      |
| keymgr.[`ATTEST_SW_BINDING_2`](#attest_sw_binding)                         | 0x54     |        4 | Software binding input to the attestation portion of the key manager.      |
| keymgr.[`ATTEST_SW_BINDING_3`](#attest_sw_binding)                         | 0x58     |        4 | Software binding input to the attestation portion of the key manager.      |
| keymgr.[`ATTEST_SW_BINDING_4`](#attest_sw_binding)                         | 0x5c     |        4 | Software binding input to the attestation portion of the key manager.      |
| keymgr.[`ATTEST_SW_BINDING_5`](#attest_sw_binding)                         | 0x60     |        4 | Software binding input to the attestation portion of the key manager.      |
| keymgr.[`ATTEST_SW_BINDING_6`](#attest_sw_binding)                         | 0x64     |        4 | Software binding input to the attestation portion of the key manager.      |
| keymgr.[`ATTEST_SW_BINDING_7`](#attest_sw_binding)                         | 0x68     |        4 | Software binding input to the attestation portion of the key manager.      |
| keymgr.[`Salt_0`](#salt)                                                   | 0x6c     |        4 | Salt value used as part of output generation                               |
| keymgr.[`Salt_1`](#salt)                                                   | 0x70     |        4 | Salt value used as part of output generation                               |
| keymgr.[`Salt_2`](#salt)                                                   | 0x74     |        4 | Salt value used as part of output generation                               |
| keymgr.[`Salt_3`](#salt)                                                   | 0x78     |        4 | Salt value used as part of output generation                               |
| keymgr.[`Salt_4`](#salt)                                                   | 0x7c     |        4 | Salt value used as part of output generation                               |
| keymgr.[`Salt_5`](#salt)                                                   | 0x80     |        4 | Salt value used as part of output generation                               |
| keymgr.[`Salt_6`](#salt)                                                   | 0x84     |        4 | Salt value used as part of output generation                               |
| keymgr.[`Salt_7`](#salt)                                                   | 0x88     |        4 | Salt value used as part of output generation                               |
| keymgr.[`KEY_VERSION`](#key_version)                                       | 0x8c     |        4 | Version used as part of output generation                                  |
| keymgr.[`MAX_CREATOR_KEY_VER_REGWEN`](#max_creator_key_ver_regwen)         | 0x90     |        4 | Register write enable for MAX_CREATOR_KEY_VERSION                          |
| keymgr.[`MAX_CREATOR_KEY_VER_SHADOWED`](#max_creator_key_ver_shadowed)     | 0x94     |        4 | Max creator key version                                                    |
| keymgr.[`MAX_OWNER_INT_KEY_VER_REGWEN`](#max_owner_int_key_ver_regwen)     | 0x98     |        4 | Register write enable for MAX_OWNER_INT_KEY_VERSION                        |
| keymgr.[`MAX_OWNER_INT_KEY_VER_SHADOWED`](#max_owner_int_key_ver_shadowed) | 0x9c     |        4 | Max owner intermediate key version                                         |
| keymgr.[`MAX_OWNER_KEY_VER_REGWEN`](#max_owner_key_ver_regwen)             | 0xa0     |        4 | Register write enable for MAX_OWNER_KEY_VERSION                            |
| keymgr.[`MAX_OWNER_KEY_VER_SHADOWED`](#max_owner_key_ver_shadowed)         | 0xa4     |        4 | Max owner key version                                                      |
| keymgr.[`SW_SHARE0_OUTPUT_0`](#sw_share0_output)                           | 0xa8     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE0_OUTPUT_1`](#sw_share0_output)                           | 0xac     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE0_OUTPUT_2`](#sw_share0_output)                           | 0xb0     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE0_OUTPUT_3`](#sw_share0_output)                           | 0xb4     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE0_OUTPUT_4`](#sw_share0_output)                           | 0xb8     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE0_OUTPUT_5`](#sw_share0_output)                           | 0xbc     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE0_OUTPUT_6`](#sw_share0_output)                           | 0xc0     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE0_OUTPUT_7`](#sw_share0_output)                           | 0xc4     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE1_OUTPUT_0`](#sw_share1_output)                           | 0xc8     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE1_OUTPUT_1`](#sw_share1_output)                           | 0xcc     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE1_OUTPUT_2`](#sw_share1_output)                           | 0xd0     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE1_OUTPUT_3`](#sw_share1_output)                           | 0xd4     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE1_OUTPUT_4`](#sw_share1_output)                           | 0xd8     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE1_OUTPUT_5`](#sw_share1_output)                           | 0xdc     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE1_OUTPUT_6`](#sw_share1_output)                           | 0xe0     |        4 | Key manager software output.                                               |
| keymgr.[`SW_SHARE1_OUTPUT_7`](#sw_share1_output)                           | 0xe4     |        4 | Key manager software output.                                               |
| keymgr.[`WORKING_STATE`](#working_state)                                   | 0xe8     |        4 | Key manager working state.                                                 |
| keymgr.[`OP_STATUS`](#op_status)                                           | 0xec     |        4 | Key manager status.                                                        |
| keymgr.[`ERR_CODE`](#err_code)                                             | 0xf0     |        4 | Key manager error code.                                                    |
| keymgr.[`FAULT_STATUS`](#fault_status)                                     | 0xf4     |        4 | This register represents both synchronous and asynchronous fatal faults.   |
| keymgr.[`DEBUG`](#debug)                                                   | 0xf8     |        4 | The register holds some debug information that may be convenient if keymgr |

## INTR_STATE
Interrupt State Register
- Offset: `0x0`
- Reset default: `0x0`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "op_done", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 90}}
```

|  Bits  |  Type  |  Reset  | Name    | Description        |
|:------:|:------:|:-------:|:--------|:-------------------|
|  31:1  |        |         |         | Reserved           |
|   0    |  rw1c  |   0x0   | op_done | Operation complete |

## INTR_ENABLE
Interrupt Enable Register
- Offset: `0x4`
- Reset default: `0x0`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "op_done", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 90}}
```

|  Bits  |  Type  |  Reset  | Name    | Description                                                       |
|:------:|:------:|:-------:|:--------|:------------------------------------------------------------------|
|  31:1  |        |         |         | Reserved                                                          |
|   0    |   rw   |   0x0   | op_done | Enable interrupt when [`INTR_STATE.op_done`](#intr_state) is set. |

## INTR_TEST
Interrupt Test Register
- Offset: `0x8`
- Reset default: `0x0`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "op_done", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 90}}
```

|  Bits  |  Type  |  Reset  | Name    | Description                                                |
|:------:|:------:|:-------:|:--------|:-----------------------------------------------------------|
|  31:1  |        |         |         | Reserved                                                   |
|   0    |   wo   |   0x0   | op_done | Write 1 to force [`INTR_STATE.op_done`](#intr_state) to 1. |

## ALERT_TEST
Alert Test Register
- Offset: `0xc`
- Reset default: `0x0`
- Reset mask: `0x3`

### Fields

```wavejson
{"reg": [{"name": "recov_operation_err", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "fatal_fault_err", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 30}], "config": {"lanes": 1, "fontsize": 10, "vspace": 210}}
```

|  Bits  |  Type  |  Reset  | Name                | Description                                      |
|:------:|:------:|:-------:|:--------------------|:-------------------------------------------------|
|  31:2  |        |         |                     | Reserved                                         |
|   1    |   wo   |   0x0   | fatal_fault_err     | Write 1 to trigger one alert event of this kind. |
|   0    |   wo   |   0x0   | recov_operation_err | Write 1 to trigger one alert event of this kind. |

## CFG_REGWEN
Key manager configuration enable
- Offset: `0x10`
- Reset default: `0x1`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "EN", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                                                                                                                                                                   |
|:------:|:------:|:-------:|:-------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  31:1  |        |         |        | Reserved                                                                                                                                                                      |
|   0    |   ro   |   0x1   | EN     | key manager configuration enable. When key manager operation is started (see CONTROL), registers protected by this EN are no longer modifiable until the operation completes. |

## START
Key manager operation start
- Offset: `0x14`
- Reset default: `0x0`
- Reset mask: `0x1`
- Register enable: [`CFG_REGWEN`](#cfg_regwen)

### Fields

```wavejson
{"reg": [{"name": "EN", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name             |
|:------:|:------:|:-------:|:-----------------|
|  31:1  |        |         | Reserved         |
|   0    |   rw   |   0x0   | [EN](#start--en) |

### START . EN
Start key manager operations

| Value   | Name        | Description                                                                                             |
|:--------|:------------|:--------------------------------------------------------------------------------------------------------|
| 0x1     | Valid state | To trigger a start, this value must be programmed.  All other values are considered no operation start. |

Other values are reserved.

## CONTROL_SHADOWED
Key manager operation controls
- Offset: `0x18`
- Reset default: `0x10`
- Reset mask: `0x30f0`
- Register enable: [`CFG_REGWEN`](#cfg_regwen)

### Fields

```wavejson
{"reg": [{"bits": 4}, {"name": "OPERATION", "bits": 3, "attr": ["rw"], "rotate": -90}, {"name": "CDI_SEL", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 4}, {"name": "DEST_SEL", "bits": 2, "attr": ["rw"], "rotate": -90}, {"bits": 18}], "config": {"lanes": 1, "fontsize": 10, "vspace": 110}}
```

|  Bits  |  Type  |  Reset  | Name                                      |
|:------:|:------:|:-------:|:------------------------------------------|
| 31:14  |        |         | Reserved                                  |
| 13:12  |   rw   |   0x0   | [DEST_SEL](#control_shadowed--dest_sel)   |
|  11:8  |        |         | Reserved                                  |
|   7    |   rw   |   0x0   | [CDI_SEL](#control_shadowed--cdi_sel)     |
|  6:4   |   rw   |   0x1   | [OPERATION](#control_shadowed--operation) |
|  3:0   |        |         | Reserved                                  |

### CONTROL_SHADOWED . DEST_SEL
When the OPERATION field is programmed to generate output, this field selects
the appropriate crypto cipher target.

This field should be programmed for both hw / sw generation, as this helps diverisifies the output.

| Value   | Name   | Description                                                                                                                                                                                                                                                                                                                                   |
|:--------|:-------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0x0     | None   | No target selected                                                                                                                                                                                                                                                                                                                            |
| 0x1     | AES    | AES selected                                                                                                                                                                                                                                                                                                                                  |
| 0x2     | KMAC   | KMAC selected                                                                                                                                                                                                                                                                                                                                 |
| 0x3     | OTBN   | OTBN selected.  Note for OTBN hardware operations, the generated output is 384-bits, while for all other operations (including OTBN software), it is 256-bits. Generating a hardware 384-bit seed directly for OTBN sideload reduces some of the OTBN code burden for entropy expansion. When generating for software, this is not a concern. |


### CONTROL_SHADOWED . CDI_SEL
When the OPERATION field is programmed to generate output, this field selects
the appropriate CDI to use.

This field should be programmed for both hw / sw generation.

| Value   | Name            | Description                 |
|:--------|:----------------|:----------------------------|
| 0x0     | Sealing CDI     | Sealing CDI is selected     |
| 0x1     | Attestation CDI | Attestation CDI is selected |


### CONTROL_SHADOWED . OPERATION
Key manager operation selection. All values not enumerated below behave the same as disable

| Value   | Name               | Description                                                                                                                                                                          |
|:--------|:-------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0x0     | Advance            | Advance key manager state. Advances key manager to the next stage. If key manager is already at last functional state, the advance operation is equivalent to the disable operation. |
| 0x1     | Generate ID        | Generates an identity seed from the current state.                                                                                                                                   |
| 0x2     | Generate SW Output | Generates a key manager output that is visible to software from the current state.                                                                                                   |
| 0x3     | Generate HW Output | Generates a key manager output that is visible only to hardware crypto blocks.                                                                                                       |
| 0x4     | Disable            | Disables key manager operation and moves it to the disabled state. Note the disabled state is terminal and cannot be recovered without a reset.                                      |

Other values are reserved.

## SIDELOAD_CLEAR
sideload key slots clear
- Offset: `0x1c`
- Reset default: `0x0`
- Reset mask: `0x7`
- Register enable: [`CFG_REGWEN`](#cfg_regwen)

### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 3, "attr": ["rw"], "rotate": 0}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                        |
|:------:|:------:|:-------:|:----------------------------|
|  31:3  |        |         | Reserved                    |
|  2:0   |   rw   |   0x0   | [VAL](#sideload_clear--val) |

### SIDELOAD_CLEAR . VAL
Depending on the value programmed, a different sideload key slot is cleared.
If the value programmed is not one of the enumerated values below, ALL sideload
key slots are continuously cleared. In order to stop continuous clearing, SW should
toggle the clear bit again (i.e. disable continuous clearing).

| Value   | Name   | Description                                                 |
|:--------|:-------|:------------------------------------------------------------|
| 0x0     | None   | No sideload keys cleared.                                   |
| 0x1     | AES    | The AES sideload key is continuously cleared with entropy.  |
| 0x2     | KMAC   | The KMAC sideload key is continuously cleared with entropy. |
| 0x3     | OTBN   | The OTBN sideload key is continuously cleared with entropy. |

Other values are reserved.

## RESEED_INTERVAL_REGWEN
regwen for reseed interval
- Offset: `0x20`
- Reset default: `0x1`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "EN", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                              |
|:------:|:------:|:-------:|:-------|:-----------------------------------------|
|  31:1  |        |         |        | Reserved                                 |
|   0    |  rw0c  |   0x1   | EN     | Configuration enable for reseed interval |

## RESEED_INTERVAL_SHADOWED
Reseed interval for key manager entropy reseed
- Offset: `0x24`
- Reset default: `0x100`
- Reset mask: `0xffff`
- Register enable: [`RESEED_INTERVAL_REGWEN`](#reseed_interval_regwen)

### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 16, "attr": ["rw"], "rotate": 0}, {"bits": 16}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                                                   |
|:------:|:------:|:-------:|:-------|:--------------------------------------------------------------|
| 31:16  |        |         |        | Reserved                                                      |
|  15:0  |   rw   |  0x100  | VAL    | Number of internal PRNG updates before a reseed is requested. |

## SW_BINDING_REGWEN
Register write enable for SOFTWARE_BINDING
- Offset: `0x28`
- Reset default: `0x1`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "EN", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                                                                                                                                                                                                                            |
|:------:|:------:|:-------:|:-------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  31:1  |        |         |        | Reserved                                                                                                                                                                                                                               |
|   0    |  rw0c  |   0x1   | EN     | Software binding register write enable. This is locked by software and unlocked by hardware upon a successful advance call. Software binding resets to 1, and its value cannot be altered by software until advancement to Init state. |

## SEALING_SW_BINDING
Software binding input to sealing portion of the key manager.
This register is lockable and shared between key manager stages.
This binding value is not considered secret, however its integrity is very important.

The software binding is locked by software and unlocked by hardware upon a successful advance operation.
- Reset default: `0x0`
- Reset mask: `0xffffffff`
- Register enable: [`SW_BINDING_REGWEN`](#sw_binding_regwen)

### Instances

| Name                 | Offset   |
|:---------------------|:---------|
| SEALING_SW_BINDING_0 | 0x2c     |
| SEALING_SW_BINDING_1 | 0x30     |
| SEALING_SW_BINDING_2 | 0x34     |
| SEALING_SW_BINDING_3 | 0x38     |
| SEALING_SW_BINDING_4 | 0x3c     |
| SEALING_SW_BINDING_5 | 0x40     |
| SEALING_SW_BINDING_6 | 0x44     |
| SEALING_SW_BINDING_7 | 0x48     |


### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description            |
|:------:|:------:|:-------:|:-------|:-----------------------|
|  31:0  |   rw   |   0x0   | VAL    | Software binding value |

## ATTEST_SW_BINDING
Software binding input to the attestation portion of the key manager.
This register is lockable and shared between key manager stages.
This binding value is not considered secret, however its integrity is very important.

The software binding is locked by software and unlocked by hardware upon a successful advance operation.
- Reset default: `0x0`
- Reset mask: `0xffffffff`
- Register enable: [`SW_BINDING_REGWEN`](#sw_binding_regwen)

### Instances

| Name                | Offset   |
|:--------------------|:---------|
| ATTEST_SW_BINDING_0 | 0x4c     |
| ATTEST_SW_BINDING_1 | 0x50     |
| ATTEST_SW_BINDING_2 | 0x54     |
| ATTEST_SW_BINDING_3 | 0x58     |
| ATTEST_SW_BINDING_4 | 0x5c     |
| ATTEST_SW_BINDING_5 | 0x60     |
| ATTEST_SW_BINDING_6 | 0x64     |
| ATTEST_SW_BINDING_7 | 0x68     |


### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description            |
|:------:|:------:|:-------:|:-------|:-----------------------|
|  31:0  |   rw   |   0x0   | VAL    | Software binding value |

## Salt
Salt value used as part of output generation
- Reset default: `0x0`
- Reset mask: `0xffffffff`
- Register enable: [`CFG_REGWEN`](#cfg_regwen)

### Instances

| Name   | Offset   |
|:-------|:---------|
| Salt_0 | 0x6c     |
| Salt_1 | 0x70     |
| Salt_2 | 0x74     |
| Salt_3 | 0x78     |
| Salt_4 | 0x7c     |
| Salt_5 | 0x80     |
| Salt_6 | 0x84     |
| Salt_7 | 0x88     |


### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description   |
|:------:|:------:|:-------:|:-------|:--------------|
|  31:0  |   rw   |   0x0   | VAL    | Salt value    |

## KEY_VERSION
Version used as part of output generation
- Reset default: `0x0`
- Reset mask: `0xffffffff`
- Register enable: [`CFG_REGWEN`](#cfg_regwen)

### Instances

| Name        | Offset   |
|:------------|:---------|
| KEY_VERSION | 0x8c     |


### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description   |
|:------:|:------:|:-------:|:-------|:--------------|
|  31:0  |   rw   |   0x0   | VAL    | Key version   |

## MAX_CREATOR_KEY_VER_REGWEN
Register write enable for MAX_CREATOR_KEY_VERSION
- Offset: `0x90`
- Reset default: `0x1`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "EN", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                               |
|:------:|:------:|:-------:|:-------|:------------------------------------------|
|  31:1  |        |         |        | Reserved                                  |
|   0    |  rw0c  |   0x1   | EN     | MAX_CREATOR_KEY_VERSION configure enable. |

## MAX_CREATOR_KEY_VER_SHADOWED
Max creator key version
- Offset: `0x94`
- Reset default: `0x0`
- Reset mask: `0xffffffff`
- Register enable: [`MAX_CREATOR_KEY_VER_REGWEN`](#max_creator_key_ver_regwen)

### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                                                                            |
|:------:|:------:|:-------:|:-------|:---------------------------------------------------------------------------------------|
|  31:0  |   rw   |   0x0   | VAL    | Max key version. Any key version up to the value specificed in this register is valid. |

## MAX_OWNER_INT_KEY_VER_REGWEN
Register write enable for MAX_OWNER_INT_KEY_VERSION
- Offset: `0x98`
- Reset default: `0x1`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "EN", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                                  |
|:------:|:------:|:-------:|:-------|:---------------------------------------------|
|  31:1  |        |         |        | Reserved                                     |
|   0    |  rw0c  |   0x1   | EN     | MAX_OWNER_INTERMEDIATE_KEY configure enable. |

## MAX_OWNER_INT_KEY_VER_SHADOWED
Max owner intermediate key version
- Offset: `0x9c`
- Reset default: `0x1`
- Reset mask: `0xffffffff`
- Register enable: [`MAX_OWNER_INT_KEY_VER_REGWEN`](#max_owner_int_key_ver_regwen)

### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                                                                            |
|:------:|:------:|:-------:|:-------|:---------------------------------------------------------------------------------------|
|  31:0  |   rw   |   0x1   | VAL    | Max key version. Any key version up to the value specificed in this register is valid. |

## MAX_OWNER_KEY_VER_REGWEN
Register write enable for MAX_OWNER_KEY_VERSION
- Offset: `0xa0`
- Reset default: `0x1`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "EN", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                     |
|:------:|:------:|:-------:|:-------|:--------------------------------|
|  31:1  |        |         |        | Reserved                        |
|   0    |  rw0c  |   0x1   | EN     | MAX_OWNER_KEY configure enable. |

## MAX_OWNER_KEY_VER_SHADOWED
Max owner key version
- Offset: `0xa4`
- Reset default: `0x0`
- Reset mask: `0xffffffff`
- Register enable: [`MAX_OWNER_KEY_VER_REGWEN`](#max_owner_key_ver_regwen)

### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                                                                            |
|:------:|:------:|:-------:|:-------|:---------------------------------------------------------------------------------------|
|  31:0  |   rw   |   0x0   | VAL    | Max key version. Any key version up to the value specificed in this register is valid. |

## SW_SHARE0_OUTPUT
Key manager software output.

When a software output operation is selected, the results of the operation are placed
here.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name               | Offset   |
|:-------------------|:---------|
| SW_SHARE0_OUTPUT_0 | 0xa8     |
| SW_SHARE0_OUTPUT_1 | 0xac     |
| SW_SHARE0_OUTPUT_2 | 0xb0     |
| SW_SHARE0_OUTPUT_3 | 0xb4     |
| SW_SHARE0_OUTPUT_4 | 0xb8     |
| SW_SHARE0_OUTPUT_5 | 0xbc     |
| SW_SHARE0_OUTPUT_6 | 0xc0     |
| SW_SHARE0_OUTPUT_7 | 0xc4     |


### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 32, "attr": ["rc"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description           |
|:------:|:------:|:-------:|:-------|:----------------------|
|  31:0  |   rc   |   0x0   | VAL    | Software output value |

## SW_SHARE1_OUTPUT
Key manager software output.

When a software output operation is selected, the results of the operation are placed
here.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name               | Offset   |
|:-------------------|:---------|
| SW_SHARE1_OUTPUT_0 | 0xc8     |
| SW_SHARE1_OUTPUT_1 | 0xcc     |
| SW_SHARE1_OUTPUT_2 | 0xd0     |
| SW_SHARE1_OUTPUT_3 | 0xd4     |
| SW_SHARE1_OUTPUT_4 | 0xd8     |
| SW_SHARE1_OUTPUT_5 | 0xdc     |
| SW_SHARE1_OUTPUT_6 | 0xe0     |
| SW_SHARE1_OUTPUT_7 | 0xe4     |


### Fields

```wavejson
{"reg": [{"name": "VAL", "bits": 32, "attr": ["rc"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description           |
|:------:|:------:|:-------:|:-------|:----------------------|
|  31:0  |   rc   |   0x0   | VAL    | Software output value |

## WORKING_STATE
Key manager working state.

This is a readout of the current key manager working state
- Offset: `0xe8`
- Reset default: `0x0`
- Reset mask: `0x7`

### Fields

```wavejson
{"reg": [{"name": "STATE", "bits": 3, "attr": ["ro"], "rotate": -90}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                           |
|:------:|:------:|:-------:|:-------------------------------|
|  31:3  |        |         | Reserved                       |
|  2:0   |   ro   |   0x0   | [STATE](#working_state--state) |

### WORKING_STATE . STATE
Key manager control state

| Value   | Name                   | Description                                                                                               |
|:--------|:-----------------------|:----------------------------------------------------------------------------------------------------------|
| 0x0     | Reset                  | Key manager control is still in reset.  Please wait for initialization complete before issuing operations |
| 0x1     | Init                   | Key manager control has finished initialization and will now accept software commands.                    |
| 0x2     | Creator Root Key       | Key manager control currently contains the creator root key.                                              |
| 0x3     | Owner Intermediate Key | Key manager control currently contains the owner intermediate key.                                        |
| 0x4     | Owner Key              | Key manager control currently contains the owner key.                                                     |
| 0x5     | Disabled               | Key manager currently disabled. Please reset the key manager. Sideload keys are still valid.              |
| 0x6     | Invalid                | Key manager currently invalid. Please reset the key manager. Sideload keys are no longer valid.           |

Other values are reserved.

## OP_STATUS
Key manager status.

Hardware sets the status based on software initiated operations.
This register must be explicitly cleared by software.
Software clears by writing back whatever it reads.
- Offset: `0xec`
- Reset default: `0x0`
- Reset mask: `0x3`

### Fields

```wavejson
{"reg": [{"name": "STATUS", "bits": 2, "attr": ["rw1c"], "rotate": -90}, {"bits": 30}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name                         |
|:------:|:------:|:-------:|:-----------------------------|
|  31:2  |        |         | Reserved                     |
|  1:0   |  rw1c  |   0x0   | [STATUS](#op_status--status) |

### OP_STATUS . STATUS
Operation status.

| Value   | Name         | Description                                                               |
|:--------|:-------------|:--------------------------------------------------------------------------|
| 0x0     | Idle         | Key manager is idle                                                       |
| 0x1     | WIP          | Work in progress. A key manager operation has been started and is ongoing |
| 0x2     | DONE_SUCCESS | Operation finished without errors                                         |
| 0x3     | DONE_ERROR   | Operation finished with errors, please see ERR_CODE register.             |


## ERR_CODE
Key manager error code.
This register must be explicitly cleared by software.

This register represents both synchronous and asynchronous recoverable
errors.

Synchronous errors refer to those that only happen when a keymgr operation is
invoked, while asynchronous refers to errors that can happen at any time.
- Offset: `0xf0`
- Reset default: `0x0`
- Reset mask: `0x7`

### Fields

```wavejson
{"reg": [{"name": "INVALID_OP", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"name": "INVALID_KMAC_INPUT", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"name": "INVALID_SHADOW_UPDATE", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 230}}
```

|  Bits  |  Type  |  Reset  | Name                  | Description                                                          |
|:------:|:------:|:-------:|:----------------------|:---------------------------------------------------------------------|
|  31:3  |        |         |                       | Reserved                                                             |
|   2    |  rw1c  |   0x0   | INVALID_SHADOW_UPDATE | An error observed during shadow register updates, asynchronous error |
|   1    |  rw1c  |   0x0   | INVALID_KMAC_INPUT    | Invalid data issued to kmac interface, synchronous error             |
|   0    |  rw1c  |   0x0   | INVALID_OP            | Invalid operation issued to key manager, synchronous error           |

## FAULT_STATUS
This register represents both synchronous and asynchronous fatal faults.

Synchronous faults refer to those that only happen when a keymgr operation is
invoked, while asynchronous refers to faults that can happen at any time.

- Offset: `0xf4`
- Reset default: `0x0`
- Reset mask: `0x3fff`

### Fields

```wavejson
{"reg": [{"name": "CMD", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "KMAC_FSM", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "KMAC_DONE", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "KMAC_OP", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "KMAC_OUT", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "REGFILE_INTG", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "SHADOW", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "CTRL_FSM_INTG", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "CTRL_FSM_CHK", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "CTRL_FSM_CNT", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "RESEED_CNT", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "SIDE_CTRL_FSM", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "SIDE_CTRL_SEL", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "KEY_ECC", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 18}], "config": {"lanes": 1, "fontsize": 10, "vspace": 150}}
```

|  Bits  |  Type  |  Reset  | Name          | Description                                                                               |
|:------:|:------:|:-------:|:--------------|:------------------------------------------------------------------------------------------|
| 31:14  |        |         |               | Reserved                                                                                  |
|   13   |   ro   |   0x0   | KEY_ECC       | Secret key ecc error, asynchronous fault                                                  |
|   12   |   ro   |   0x0   | SIDE_CTRL_SEL | Sideload control key select error, synchronous fault                                      |
|   11   |   ro   |   0x0   | SIDE_CTRL_FSM | Sideload control FSM integrity error, asynchronous fault                                  |
|   10   |   ro   |   0x0   | RESEED_CNT    | Reseed counter integrity error, asynchronous fault                                        |
|   9    |   ro   |   0x0   | CTRL_FSM_CNT  | Control FSM counter integrity error, asynchronous fault                                   |
|   8    |   ro   |   0x0   | CTRL_FSM_CHK  | Control FSM cross check error, asynchronous fault                                         |
|   7    |   ro   |   0x0   | CTRL_FSM_INTG | Control FSM integrity error, asynchronous fault                                           |
|   6    |   ro   |   0x0   | SHADOW        | Shadow copy storage error, asynchronous fault                                             |
|   5    |   ro   |   0x0   | REGFILE_INTG  | Register file integrity error, asynchronous fault                                         |
|   4    |   ro   |   0x0   | KMAC_OUT      | KMAC data returned as all 0's or all 1's - synchronous fault                              |
|   3    |   ro   |   0x0   | KMAC_OP       | KMAC reported an error during keymgr usage, this should never happen - synchronous fault. |
|   2    |   ro   |   0x0   | KMAC_DONE     | The kmac transfer interface encountered an unexpected done, asynchronous fault.           |
|   1    |   ro   |   0x0   | KMAC_FSM      | The kmac transfer interface FSM is in an invalid state, asynchronous fault.               |
|   0    |   ro   |   0x0   | CMD           | A non-onehot command was seen in kmac, asynchronous fault.                                |

## DEBUG
The register holds some debug information that may be convenient if keymgr
misbehaves.
- Offset: `0xf8`
- Reset default: `0x0`
- Reset mask: `0x7f`

### Fields

```wavejson
{"reg": [{"name": "INVALID_CREATOR_SEED", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "INVALID_OWNER_SEED", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "INVALID_DEV_ID", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "INVALID_HEALTH_STATE", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "INVALID_KEY_VERSION", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "INVALID_KEY", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"name": "INVALID_DIGEST", "bits": 1, "attr": ["rw0c"], "rotate": -90}, {"bits": 25}], "config": {"lanes": 1, "fontsize": 10, "vspace": 220}}
```

|  Bits  |  Type  |  Reset  | Name                 | Description                                          |
|:------:|:------:|:-------:|:---------------------|:-----------------------------------------------------|
|  31:7  |        |         |                      | Reserved                                             |
|   6    |  rw0c  |   0x0   | INVALID_DIGEST       | ROM digest failed input checks during operation      |
|   5    |  rw0c  |   0x0   | INVALID_KEY          | Key fed to kmac failed input checks during operation |
|   4    |  rw0c  |   0x0   | INVALID_KEY_VERSION  | Key version failed input checks during operation     |
|   3    |  rw0c  |   0x0   | INVALID_HEALTH_STATE | Health state failed input checks during operation    |
|   2    |  rw0c  |   0x0   | INVALID_DEV_ID       | Device ID failed input checks during operation       |
|   1    |  rw0c  |   0x0   | INVALID_OWNER_SEED   | Owner seed failed input checks during operation      |
|   0    |  rw0c  |   0x0   | INVALID_CREATOR_SEED | Creator seed failed input checks during operation    |


<!-- END CMDGEN -->

================================== Ai Message ==================================
Tool Calls:
  list_dir (call_iC1uNkBxIDSWrPK0fkKfzDZm)
 Call ID: call_iC1uNkBxIDSWrPK0fkKfzDZm
  Args:
    dir_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/rtl
================================= Tool Message =================================
Name: list_dir

Files in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/rtl:
keymgr_cfg_en.sv keymgr_op_state_ctrl.sv keymgr_err.sv keymgr_reseed_ctrl.sv keymgr_reg_pkg.sv keymgr.sv keymgr_ctrl.sv keymgr_kmac_if.sv keymgr_input_checks.sv keymgr_pkg.sv keymgr_reg_top.sv keymgr_sideload_key.sv keymgr_data_en_state.sv keymgr_sideload_key_ctrl.sv

Directories in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/rtl:

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_5Q4IwmFpqdr9cVMeRzicrnpe)
 Call ID: call_5Q4IwmFpqdr9cVMeRzicrnpe
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/rtl/keymgr_reg_top.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Register Top module auto-generated by `reggen`
6: 
7: `include "prim_assert.sv"
8: 
9: module keymgr_reg_top (
10:   input clk_i,
11:   input rst_ni,
12:   input rst_shadowed_ni,
13:   input  tlul_pkg::tl_h2d_t tl_i,
14:   output tlul_pkg::tl_d2h_t tl_o,
15:   // To HW
16:   output keymgr_reg_pkg::keymgr_reg2hw_t reg2hw, // Write
17:   input  keymgr_reg_pkg::keymgr_hw2reg_t hw2reg, // Read
18: 
19:   output logic shadowed_storage_err_o,
20:   output logic shadowed_update_err_o,
21: 
22:   // Integrity check errors
23:   output logic intg_err_o
24: );
25: 
26:   import keymgr_reg_pkg::* ;
27: 
28:   localparam int AW = 8;
29:   localparam int DW = 32;
30:   localparam int DBW = DW/8;                    // Byte Width
31: 
32:   // register signals
33:   logic           reg_we;
34:   logic           reg_re;
35:   logic [AW-1:0]  reg_addr;
36:   logic [DW-1:0]  reg_wdata;
37:   logic [DBW-1:0] reg_be;
38:   logic [DW-1:0]  reg_rdata;
39:   logic           reg_error;
40: 
41:   logic          addrmiss, wr_err;
42: 
43:   logic [DW-1:0] reg_rdata_next;
44:   logic reg_busy;
45: 
46:   tlul_pkg::tl_h2d_t tl_reg_h2d;
47:   tlul_pkg::tl_d2h_t tl_reg_d2h;
48: 
49: 
50:   // incoming payload check
51:   logic intg_err;
52:   tlul_cmd_intg_chk u_chk (
53:     .tl_i(tl_i),
54:     .err_o(intg_err)
55:   );
56: 
57:   // also check for spurious write enables
58:   logic reg_we_err;
59:   logic [62:0] reg_we_check;
60:   prim_reg_we_check #(
61:     .OneHotWidth(63)
62:   ) u_prim_reg_we_check (
63:     .clk_i(clk_i),
64:     .rst_ni(rst_ni),
65:     .oh_i  (reg_we_check),
66:     .en_i  (reg_we && !addrmiss),
67:     .err_o (reg_we_err)
68:   );
69: 
70:   logic err_q;
71:   always_ff @(posedge clk_i or negedge rst_ni) begin
72:     if (!rst_ni) begin
73:       err_q <= '0;
74:     end else if (intg_err || reg_we_err) begin
75:       err_q <= 1'b1;
76:     end
77:   end
78: 
79:   // integrity error output is permanent and should be used for alert generation
80:   // register errors are transactional
81:   assign intg_err_o = err_q | intg_err | reg_we_err;
82: 
83:   // outgoing integrity generation
84:   tlul_pkg::tl_d2h_t tl_o_pre;
85:   tlul_rsp_intg_gen #(
86:     .EnableRspIntgGen(1),
87:     .EnableDataIntgGen(1)
88:   ) u_rsp_intg_gen (
89:     .tl_i(tl_o_pre),
90:     .tl_o(tl_o)
91:   );
92: 
93:   assign tl_reg_h2d = tl_i;
94:   assign tl_o_pre   = tl_reg_d2h;
95: 
96:   tlul_adapter_reg #(
97:     .RegAw(AW),
98:     .RegDw(DW),
99:     .EnableDataIntgGen(0)
100:   ) u_reg_if (
101:     .clk_i  (clk_i),
102:     .rst_ni (rst_ni),
103: 
104:     .tl_i (tl_reg_h2d),
105:     .tl_o (tl_reg_d2h),
106: 
107:     .en_ifetch_i(prim_mubi_pkg::MuBi4False),
108:     .intg_error_o(),
109: 
110:     .we_o    (reg_we),
111:     .re_o    (reg_re),
112:     .addr_o  (reg_addr),
113:     .wdata_o (reg_wdata),
114:     .be_o    (reg_be),
115:     .busy_i  (reg_busy),
116:     .rdata_i (reg_rdata),
117:     .error_i (reg_error)
118:   );
119: 
120:   // cdc oversampling signals
121: 
122:   assign reg_rdata = reg_rdata_next ;
123:   assign reg_error = addrmiss | wr_err | intg_err;
124: 
125:   // Define SW related signals
126:   // Format: <reg>_<field>_{wd|we|qs}
127:   //        or <reg>_{wd|we|qs} if field == 1 or 0
128:   logic intr_state_we;
129:   logic intr_state_qs;
130:   logic intr_state_wd;
131:   logic intr_enable_we;
132:   logic intr_enable_qs;
133:   logic intr_enable_wd;
134:   logic intr_test_we;
135:   logic intr_test_wd;
136:   logic alert_test_we;
137:   logic alert_test_recov_operation_err_wd;
138:   logic alert_test_fatal_fault_err_wd;
139:   logic cfg_regwen_re;
140:   logic cfg_regwen_qs;
141:   logic start_we;
142:   logic start_qs;
143:   logic start_wd;
144:   logic control_shadowed_re;
145:   logic control_shadowed_we;
146:   logic [2:0] control_shadowed_operation_qs;
147:   logic [2:0] control_shadowed_operation_wd;
148:   logic control_shadowed_operation_storage_err;
149:   logic control_shadowed_operation_update_err;
150:   logic control_shadowed_cdi_sel_qs;
151:   logic control_shadowed_cdi_sel_wd;
152:   logic control_shadowed_cdi_sel_storage_err;
153:   logic control_shadowed_cdi_sel_update_err;
154:   logic [1:0] control_shadowed_dest_sel_qs;
155:   logic [1:0] control_shadowed_dest_sel_wd;
156:   logic control_shadowed_dest_sel_storage_err;
157:   logic control_shadowed_dest_sel_update_err;
158:   logic sideload_clear_we;
159:   logic [2:0] sideload_clear_qs;
160:   logic [2:0] sideload_clear_wd;
161:   logic reseed_interval_regwen_we;
162:   logic reseed_interval_regwen_qs;
163:   logic reseed_interval_regwen_wd;
164:   logic reseed_interval_shadowed_re;
165:   logic reseed_interval_shadowed_we;
166:   logic [15:0] reseed_interval_shadowed_qs;
167:   logic [15:0] reseed_interval_shadowed_wd;
168:   logic reseed_interval_shadowed_storage_err;
169:   logic reseed_interval_shadowed_update_err;
170:   logic sw_binding_regwen_re;
171:   logic sw_binding_regwen_we;
172:   logic sw_binding_regwen_qs;
173:   logic sw_binding_regwen_wd;
174:   logic sealing_sw_binding_0_we;
175:   logic [31:0] sealing_sw_binding_0_qs;
176:   logic [31:0] sealing_sw_binding_0_wd;
177:   logic sealing_sw_binding_1_we;
178:   logic [31:0] sealing_sw_binding_1_qs;
179:   logic [31:0] sealing_sw_binding_1_wd;
180:   logic sealing_sw_binding_2_we;
181:   logic [31:0] sealing_sw_binding_2_qs;
182:   logic [31:0] sealing_sw_binding_2_wd;
183:   logic sealing_sw_binding_3_we;
184:   logic [31:0] sealing_sw_binding_3_qs;
185:   logic [31:0] sealing_sw_binding_3_wd;
186:   logic sealing_sw_binding_4_we;
187:   logic [31:0] sealing_sw_binding_4_qs;
188:   logic [31:0] sealing_sw_binding_4_wd;
189:   logic sealing_sw_binding_5_we;
190:   logic [31:0] sealing_sw_binding_5_qs;
191:   logic [31:0] sealing_sw_binding_5_wd;
192:   logic sealing_sw_binding_6_we;
193:   logic [31:0] sealing_sw_binding_6_qs;
194:   logic [31:0] sealing_sw_binding_6_wd;
195:   logic sealing_sw_binding_7_we;
196:   logic [31:0] sealing_sw_binding_7_qs;
197:   logic [31:0] sealing_sw_binding_7_wd;
198:   logic attest_sw_binding_0_we;
199:   logic [31:0] attest_sw_binding_0_qs;
200:   logic [31:0] attest_sw_binding_0_wd;
201:   logic attest_sw_binding_1_we;
202:   logic [31:0] attest_sw_binding_1_qs;
203:   logic [31:0] attest_sw_binding_1_wd;
204:   logic attest_sw_binding_2_we;
205:   logic [31:0] attest_sw_binding_2_qs;
206:   logic [31:0] attest_sw_binding_2_wd;
207:   logic attest_sw_binding_3_we;
208:   logic [31:0] attest_sw_binding_3_qs;
209:   logic [31:0] attest_sw_binding_3_wd;
210:   logic attest_sw_binding_4_we;
211:   logic [31:0] attest_sw_binding_4_qs;
212:   logic [31:0] attest_sw_binding_4_wd;
213:   logic attest_sw_binding_5_we;
214:   logic [31:0] attest_sw_binding_5_qs;
215:   logic [31:0] attest_sw_binding_5_wd;
216:   logic attest_sw_binding_6_we;
217:   logic [31:0] attest_sw_binding_6_qs;
218:   logic [31:0] attest_sw_binding_6_wd;
219:   logic attest_sw_binding_7_we;
220:   logic [31:0] attest_sw_binding_7_qs;
221:   logic [31:0] attest_sw_binding_7_wd;
222:   logic salt_0_we;
223:   logic [31:0] salt_0_qs;
224:   logic [31:0] salt_0_wd;
225:   logic salt_1_we;
226:   logic [31:0] salt_1_qs;
227:   logic [31:0] salt_1_wd;
228:   logic salt_2_we;
229:   logic [31:0] salt_2_qs;
230:   logic [31:0] salt_2_wd;
231:   logic salt_3_we;
232:   logic [31:0] salt_3_qs;
233:   logic [31:0] salt_3_wd;
234:   logic salt_4_we;
235:   logic [31:0] salt_4_qs;
236:   logic [31:0] salt_4_wd;
237:   logic salt_5_we;
238:   logic [31:0] salt_5_qs;
239:   logic [31:0] salt_5_wd;
240:   logic salt_6_we;
241:   logic [31:0] salt_6_qs;
242:   logic [31:0] salt_6_wd;
243:   logic salt_7_we;
244:   logic [31:0] salt_7_qs;
245:   logic [31:0] salt_7_wd;
246:   logic key_version_we;
247:   logic [31:0] key_version_qs;
248:   logic [31:0] key_version_wd;
249:   logic max_creator_key_ver_regwen_we;
250:   logic max_creator_key_ver_regwen_qs;
251:   logic max_creator_key_ver_regwen_wd;
252:   logic max_creator_key_ver_shadowed_re;
253:   logic max_creator_key_ver_shadowed_we;
254:   logic [31:0] max_creator_key_ver_shadowed_qs;
255:   logic [31:0] max_creator_key_ver_shadowed_wd;
256:   logic max_creator_key_ver_shadowed_storage_err;
257:   logic max_creator_key_ver_shadowed_update_err;
258:   logic max_owner_int_key_ver_regwen_we;
259:   logic max_owner_int_key_ver_regwen_qs;
260:   logic max_owner_int_key_ver_regwen_wd;
261:   logic max_owner_int_key_ver_shadowed_re;
262:   logic max_owner_int_key_ver_shadowed_we;
263:   logic [31:0] max_owner_int_key_ver_shadowed_qs;
264:   logic [31:0] max_owner_int_key_ver_shadowed_wd;
265:   logic max_owner_int_key_ver_shadowed_storage_err;
266:   logic max_owner_int_key_ver_shadowed_update_err;
267:   logic max_owner_key_ver_regwen_we;
268:   logic max_owner_key_ver_regwen_qs;
269:   logic max_owner_key_ver_regwen_wd;
270:   logic max_owner_key_ver_shadowed_re;
271:   logic max_owner_key_ver_shadowed_we;
272:   logic [31:0] max_owner_key_ver_shadowed_qs;
273:   logic [31:0] max_owner_key_ver_shadowed_wd;
274:   logic max_owner_key_ver_shadowed_storage_err;
275:   logic max_owner_key_ver_shadowed_update_err;
276:   logic sw_share0_output_0_re;
277:   logic [31:0] sw_share0_output_0_qs;
278:   logic [31:0] sw_share0_output_0_wd;
279:   logic sw_share0_output_1_re;
280:   logic [31:0] sw_share0_output_1_qs;
281:   logic [31:0] sw_share0_output_1_wd;
282:   logic sw_share0_output_2_re;
283:   logic [31:0] sw_share0_output_2_qs;
284:   logic [31:0] sw_share0_output_2_wd;
285:   logic sw_share0_output_3_re;
286:   logic [31:0] sw_share0_output_3_qs;
287:   logic [31:0] sw_share0_output_3_wd;
288:   logic sw_share0_output_4_re;
289:   logic [31:0] sw_share0_output_4_qs;
290:   logic [31:0] sw_share0_output_4_wd;
291:   logic sw_share0_output_5_re;
292:   logic [31:0] sw_share0_output_5_qs;
293:   logic [31:0] sw_share0_output_5_wd;
294:   logic sw_share0_output_6_re;
295:   logic [31:0] sw_share0_output_6_qs;
296:   logic [31:0] sw_share0_output_6_wd;
297:   logic sw_share0_output_7_re;
298:   logic [31:0] sw_share0_output_7_qs;
299:   logic [31:0] sw_share0_output_7_wd;
300:   logic sw_share1_output_0_re;
301:   logic [31:0] sw_share1_output_0_qs;
302:   logic [31:0] sw_share1_output_0_wd;
303:   logic sw_share1_output_1_re;
304:   logic [31:0] sw_share1_output_1_qs;
305:   logic [31:0] sw_share1_output_1_wd;
306:   logic sw_share1_output_2_re;
307:   logic [31:0] sw_share1_output_2_qs;
308:   logic [31:0] sw_share1_output_2_wd;
309:   logic sw_share1_output_3_re;
310:   logic [31:0] sw_share1_output_3_qs;
311:   logic [31:0] sw_share1_output_3_wd;
312:   logic sw_share1_output_4_re;
313:   logic [31:0] sw_share1_output_4_qs;
314:   logic [31:0] sw_share1_output_4_wd;
315:   logic sw_share1_output_5_re;
316:   logic [31:0] sw_share1_output_5_qs;
317:   logic [31:0] sw_share1_output_5_wd;
318:   logic sw_share1_output_6_re;
319:   logic [31:0] sw_share1_output_6_qs;
320:   logic [31:0] sw_share1_output_6_wd;
321:   logic sw_share1_output_7_re;
322:   logic [31:0] sw_share1_output_7_qs;
323:   logic [31:0] sw_share1_output_7_wd;
324:   logic [2:0] working_state_qs;
325:   logic op_status_we;
326:   logic [1:0] op_status_qs;
327:   logic [1:0] op_status_wd;
328:   logic err_code_we;
329:   logic err_code_invalid_op_qs;
330:   logic err_code_invalid_op_wd;
331:   logic err_code_invalid_kmac_input_qs;
332:   logic err_code_invalid_kmac_input_wd;
333:   logic err_code_invalid_shadow_update_qs;
334:   logic err_code_invalid_shadow_update_wd;
335:   logic fault_status_cmd_qs;
336:   logic fault_status_kmac_fsm_qs;
337:   logic fault_status_kmac_done_qs;
338:   logic fault_status_kmac_op_qs;
339:   logic fault_status_kmac_out_qs;
340:   logic fault_status_regfile_intg_qs;
341:   logic fault_status_shadow_qs;
342:   logic fault_status_ctrl_fsm_intg_qs;
343:   logic fault_status_ctrl_fsm_chk_qs;
344:   logic fault_status_ctrl_fsm_cnt_qs;
345:   logic fault_status_reseed_cnt_qs;
346:   logic fault_status_side_ctrl_fsm_qs;
347:   logic fault_status_side_ctrl_sel_qs;
348:   logic fault_status_key_ecc_qs;
349:   logic debug_we;
350:   logic debug_invalid_creator_seed_qs;
351:   logic debug_invalid_creator_seed_wd;
352:   logic debug_invalid_owner_seed_qs;
353:   logic debug_invalid_owner_seed_wd;
354:   logic debug_invalid_dev_id_qs;
355:   logic debug_invalid_dev_id_wd;
356:   logic debug_invalid_health_state_qs;
357:   logic debug_invalid_health_state_wd;
358:   logic debug_invalid_key_version_qs;
359:   logic debug_invalid_key_version_wd;
360:   logic debug_invalid_key_qs;
361:   logic debug_invalid_key_wd;
362:   logic debug_invalid_digest_qs;
363:   logic debug_invalid_digest_wd;
364: 
365:   // Register instances
366:   // R[intr_state]: V(False)
367:   prim_subreg #(
368:     .DW      (1),
369:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
370:     .RESVAL  (1'h0),
371:     .Mubi    (1'b0)
372:   ) u_intr_state (
373:     .clk_i   (clk_i),
374:     .rst_ni  (rst_ni),
375: 
376:     // from register interface
377:     .we     (intr_state_we),
378:     .wd     (intr_state_wd),
379: 
380:     // from internal hardware
381:     .de     (hw2reg.intr_state.de),
382:     .d      (hw2reg.intr_state.d),
383: 
384:     // to internal hardware
385:     .qe     (),
386:     .q      (reg2hw.intr_state.q),
387:     .ds     (),
388: 
389:     // to register interface (read)
390:     .qs     (intr_state_qs)
391:   );
392: 
393: 
394:   // R[intr_enable]: V(False)
395:   prim_subreg #(
396:     .DW      (1),
397:     .SwAccess(prim_subreg_pkg::SwAccessRW),
398:     .RESVAL  (1'h0),
399:     .Mubi    (1'b0)
400:   ) u_intr_enable (
401:     .clk_i   (clk_i),
402:     .rst_ni  (rst_ni),
403: 
404:     // from register interface
405:     .we     (intr_enable_we),
406:     .wd     (intr_enable_wd),
407: 
408:     // from internal hardware
409:     .de     (1'b0),
410:     .d      ('0),
411: 
412:     // to internal hardware
413:     .qe     (),
414:     .q      (reg2hw.intr_enable.q),
415:     .ds     (),
416: 
417:     // to register interface (read)
418:     .qs     (intr_enable_qs)
419:   );
420: 
421: 
422:   // R[intr_test]: V(True)
423:   logic intr_test_qe;
424:   logic [0:0] intr_test_flds_we;
425:   assign intr_test_qe = &intr_test_flds_we;
426:   prim_subreg_ext #(
427:     .DW    (1)
428:   ) u_intr_test (
429:     .re     (1'b0),
430:     .we     (intr_test_we),
431:     .wd     (intr_test_wd),
432:     .d      ('0),
433:     .qre    (),
434:     .qe     (intr_test_flds_we[0]),
435:     .q      (reg2hw.intr_test.q),
436:     .ds     (),
437:     .qs     ()
438:   );
439:   assign reg2hw.intr_test.qe = intr_test_qe;
440: 
441: 
442:   // R[alert_test]: V(True)
443:   logic alert_test_qe;
444:   logic [1:0] alert_test_flds_we;
445:   assign alert_test_qe = &alert_test_flds_we;
446:   //   F[recov_operation_err]: 0:0
447:   prim_subreg_ext #(
448:     .DW    (1)
449:   ) u_alert_test_recov_operation_err (
450:     .re     (1'b0),
451:     .we     (alert_test_we),
452:     .wd     (alert_test_recov_operation_err_wd),
453:     .d      ('0),
454:     .qre    (),
455:     .qe     (alert_test_flds_we[0]),
456:     .q      (reg2hw.alert_test.recov_operation_err.q),
457:     .ds     (),
458:     .qs     ()
459:   );
460:   assign reg2hw.alert_test.recov_operation_err.qe = alert_test_qe;
461: 
462:   //   F[fatal_fault_err]: 1:1
463:   prim_subreg_ext #(
464:     .DW    (1)
465:   ) u_alert_test_fatal_fault_err (
466:     .re     (1'b0),
467:     .we     (alert_test_we),
468:     .wd     (alert_test_fatal_fault_err_wd),
469:     .d      ('0),
470:     .qre    (),
471:     .qe     (alert_test_flds_we[1]),
472:     .q      (reg2hw.alert_test.fatal_fault_err.q),
473:     .ds     (),
474:     .qs     ()
475:   );
476:   assign reg2hw.alert_test.fatal_fault_err.qe = alert_test_qe;
477: 
478: 
479:   // R[cfg_regwen]: V(True)
480:   prim_subreg_ext #(
481:     .DW    (1)
482:   ) u_cfg_regwen (
483:     .re     (cfg_regwen_re),
484:     .we     (1'b0),
485:     .wd     ('0),
486:     .d      (hw2reg.cfg_regwen.d),
487:     .qre    (),
488:     .qe     (),
489:     .q      (),
490:     .ds     (),
491:     .qs     (cfg_regwen_qs)
492:   );
493: 
494: 
495:   // R[start]: V(False)
496:   // Create REGWEN-gated WE signal
497:   logic start_gated_we;
498:   assign start_gated_we = start_we & cfg_regwen_qs;
499:   prim_subreg #(
500:     .DW      (1),
501:     .SwAccess(prim_subreg_pkg::SwAccessRW),
502:     .RESVAL  (1'h0),
503:     .Mubi    (1'b0)
504:   ) u_start (
505:     .clk_i   (clk_i),
506:     .rst_ni  (rst_ni),
507: 
508:     // from register interface
509:     .we     (start_gated_we),
510:     .wd     (start_wd),
511: 
512:     // from internal hardware
513:     .de     (hw2reg.start.de),
514:     .d      (hw2reg.start.d),
515: 
516:     // to internal hardware
517:     .qe     (),
518:     .q      (reg2hw.start.q),
519:     .ds     (),
520: 
521:     // to register interface (read)
522:     .qs     (start_qs)
523:   );
524: 
525: 
526:   // R[control_shadowed]: V(False)
527:   // Create REGWEN-gated WE signal
528:   logic control_shadowed_gated_we;
529:   assign control_shadowed_gated_we = control_shadowed_we & cfg_regwen_qs;
530:   //   F[operation]: 6:4
531:   prim_subreg_shadow #(
532:     .DW      (3),
533:     .SwAccess(prim_subreg_pkg::SwAccessRW),
534:     .RESVAL  (3'h1),
535:     .Mubi    (1'b0)
536:   ) u_control_shadowed_operation (
537:     .clk_i   (clk_i),
538:     .rst_ni  (rst_ni),
539:     .rst_shadowed_ni (rst_shadowed_ni),
540: 
541:     // from register interface
542:     .re     (control_shadowed_re),
543:     .we     (control_shadowed_gated_we),
544:     .wd     (control_shadowed_operation_wd),
545: 
546:     // from internal hardware
547:     .de     (1'b0),
548:     .d      ('0),
549: 
550:     // to internal hardware
551:     .qe     (),
552:     .q      (reg2hw.control_shadowed.operation.q),
553:     .ds     (),
554: 
555:     // to register interface (read)
556:     .qs     (control_shadowed_operation_qs),
557: 
558:     // Shadow register phase. Relevant for hwext only.
559:     .phase  (),
560: 
561:     // Shadow register error conditions
562:     .err_update  (control_shadowed_operation_update_err),
563:     .err_storage (control_shadowed_operation_storage_err)
564:   );
565: 
566:   //   F[cdi_sel]: 7:7
567:   prim_subreg_shadow #(
568:     .DW      (1),
569:     .SwAccess(prim_subreg_pkg::SwAccessRW),
570:     .RESVAL  (1'h0),
571:     .Mubi    (1'b0)
572:   ) u_control_shadowed_cdi_sel (
573:     .clk_i   (clk_i),
574:     .rst_ni  (rst_ni),
575:     .rst_shadowed_ni (rst_shadowed_ni),
576: 
577:     // from register interface
578:     .re     (control_shadowed_re),
579:     .we     (control_shadowed_gated_we),
580:     .wd     (control_shadowed_cdi_sel_wd),
581: 
582:     // from internal hardware
583:     .de     (1'b0),
584:     .d      ('0),
585: 
586:     // to internal hardware
587:     .qe     (),
588:     .q      (reg2hw.control_shadowed.cdi_sel.q),
589:     .ds     (),
590: 
591:     // to register interface (read)
592:     .qs     (control_shadowed_cdi_sel_qs),
593: 
594:     // Shadow register phase. Relevant for hwext only.
595:     .phase  (),
596: 
597:     // Shadow register error conditions
598:     .err_update  (control_shadowed_cdi_sel_update_err),
599:     .err_storage (control_shadowed_cdi_sel_storage_err)
600:   );
601: 
602:   //   F[dest_sel]: 13:12
603:   prim_subreg_shadow #(
604:     .DW      (2),
605:     .SwAccess(prim_subreg_pkg::SwAccessRW),
606:     .RESVAL  (2'h0),
607:     .Mubi    (1'b0)
608:   ) u_control_shadowed_dest_sel (
609:     .clk_i   (clk_i),
610:     .rst_ni  (rst_ni),
611:     .rst_shadowed_ni (rst_shadowed_ni),
612: 
613:     // from register interface
614:     .re     (control_shadowed_re),
615:     .we     (control_shadowed_gated_we),
616:     .wd     (control_shadowed_dest_sel_wd),
617: 
618:     // from internal hardware
619:     .de     (1'b0),
620:     .d      ('0),
621: 
622:     // to internal hardware
623:     .qe     (),
624:     .q      (reg2hw.control_shadowed.dest_sel.q),
625:     .ds     (),
626: 
627:     // to register interface (read)
628:     .qs     (control_shadowed_dest_sel_qs),
629: 
630:     // Shadow register phase. Relevant for hwext only.
631:     .phase  (),
632: 
633:     // Shadow register error conditions
634:     .err_update  (control_shadowed_dest_sel_update_err),
635:     .err_storage (control_shadowed_dest_sel_storage_err)
636:   );
637: 
638: 
639:   // R[sideload_clear]: V(False)
640:   // Create REGWEN-gated WE signal
641:   logic sideload_clear_gated_we;
642:   assign sideload_clear_gated_we = sideload_clear_we & cfg_regwen_qs;
643:   prim_subreg #(
644:     .DW      (3),
645:     .SwAccess(prim_subreg_pkg::SwAccessRW),
646:     .RESVAL  (3'h0),
647:     .Mubi    (1'b0)
648:   ) u_sideload_clear (
649:     .clk_i   (clk_i),
650:     .rst_ni  (rst_ni),
651: 
652:     // from register interface
653:     .we     (sideload_clear_gated_we),
654:     .wd     (sideload_clear_wd),
655: 
656:     // from internal hardware
657:     .de     (1'b0),
658:     .d      ('0),
659: 
660:     // to internal hardware
661:     .qe     (),
662:     .q      (reg2hw.sideload_clear.q),
663:     .ds     (),
664: 
665:     // to register interface (read)
666:     .qs     (sideload_clear_qs)
667:   );
668: 
669: 
670:   // R[reseed_interval_regwen]: V(False)
671:   prim_subreg #(
672:     .DW      (1),
673:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
674:     .RESVAL  (1'h1),
675:     .Mubi    (1'b0)
676:   ) u_reseed_interval_regwen (
677:     .clk_i   (clk_i),
678:     .rst_ni  (rst_ni),
679: 
680:     // from register interface
681:     .we     (reseed_interval_regwen_we),
682:     .wd     (reseed_interval_regwen_wd),
683: 
684:     // from internal hardware
685:     .de     (1'b0),
686:     .d      ('0),
687: 
688:     // to internal hardware
689:     .qe     (),
690:     .q      (),
691:     .ds     (),
692: 
693:     // to register interface (read)
694:     .qs     (reseed_interval_regwen_qs)
695:   );
696: 
697: 
698:   // R[reseed_interval_shadowed]: V(False)
699:   // Create REGWEN-gated WE signal
700:   logic reseed_interval_shadowed_gated_we;
701:   assign reseed_interval_shadowed_gated_we =
702:     reseed_interval_shadowed_we & reseed_interval_regwen_qs;
703:   prim_subreg_shadow #(
704:     .DW      (16),
705:     .SwAccess(prim_subreg_pkg::SwAccessRW),
706:     .RESVAL  (16'h100),
707:     .Mubi    (1'b0)
708:   ) u_reseed_interval_shadowed (
709:     .clk_i   (clk_i),
710:     .rst_ni  (rst_ni),
711:     .rst_shadowed_ni (rst_shadowed_ni),
712: 
713:     // from register interface
714:     .re     (reseed_interval_shadowed_re),
715:     .we     (reseed_interval_shadowed_gated_we),
716:     .wd     (reseed_interval_shadowed_wd),
717: 
718:     // from internal hardware
719:     .de     (1'b0),
720:     .d      ('0),
721: 
722:     // to internal hardware
723:     .qe     (),
724:     .q      (reg2hw.reseed_interval_shadowed.q),
725:     .ds     (),
726: 
727:     // to register interface (read)
728:     .qs     (reseed_interval_shadowed_qs),
729: 
730:     // Shadow register phase. Relevant for hwext only.
731:     .phase  (),
732: 
733:     // Shadow register error conditions
734:     .err_update  (reseed_interval_shadowed_update_err),
735:     .err_storage (reseed_interval_shadowed_storage_err)
736:   );
737: 
738: 
739:   // R[sw_binding_regwen]: V(True)
740:   logic sw_binding_regwen_qe;
741:   logic [0:0] sw_binding_regwen_flds_we;
742:   assign sw_binding_regwen_qe = &sw_binding_regwen_flds_we;
743:   prim_subreg_ext #(
744:     .DW    (1)
745:   ) u_sw_binding_regwen (
746:     .re     (sw_binding_regwen_re),
747:     .we     (sw_binding_regwen_we),
748:     .wd     (sw_binding_regwen_wd),
749:     .d      (hw2reg.sw_binding_regwen.d),
750:     .qre    (),
751:     .qe     (sw_binding_regwen_flds_we[0]),
752:     .q      (reg2hw.sw_binding_regwen.q),
753:     .ds     (),
754:     .qs     (sw_binding_regwen_qs)
755:   );
756:   assign reg2hw.sw_binding_regwen.qe = sw_binding_regwen_qe;
757: 
758: 
759:   // Subregister 0 of Multireg sealing_sw_binding
760:   // R[sealing_sw_binding_0]: V(False)
761:   // Create REGWEN-gated WE signal
762:   logic sealing_sw_binding_0_gated_we;
763:   assign sealing_sw_binding_0_gated_we = sealing_sw_binding_0_we & sw_binding_regwen_qs;
764:   prim_subreg #(
765:     .DW      (32),
766:     .SwAccess(prim_subreg_pkg::SwAccessRW),
767:     .RESVAL  (32'h0),
768:     .Mubi    (1'b0)
769:   ) u_sealing_sw_binding_0 (
770:     .clk_i   (clk_i),
771:     .rst_ni  (rst_ni),
772: 
773:     // from register interface
774:     .we     (sealing_sw_binding_0_gated_we),
775:     .wd     (sealing_sw_binding_0_wd),
776: 
777:     // from internal hardware
778:     .de     (1'b0),
779:     .d      ('0),
780: 
781:     // to internal hardware
782:     .qe     (),
783:     .q      (reg2hw.sealing_sw_binding[0].q),
784:     .ds     (),
785: 
786:     // to register interface (read)
787:     .qs     (sealing_sw_binding_0_qs)
788:   );
789: 
790: 
791:   // Subregister 1 of Multireg sealing_sw_binding
792:   // R[sealing_sw_binding_1]: V(False)
793:   // Create REGWEN-gated WE signal
794:   logic sealing_sw_binding_1_gated_we;
795:   assign sealing_sw_binding_1_gated_we = sealing_sw_binding_1_we & sw_binding_regwen_qs;
796:   prim_subreg #(
797:     .DW      (32),
798:     .SwAccess(prim_subreg_pkg::SwAccessRW),
799:     .RESVAL  (32'h0),
800:     .Mubi    (1'b0)
801:   ) u_sealing_sw_binding_1 (
802:     .clk_i   (clk_i),
803:     .rst_ni  (rst_ni),
804: 
805:     // from register interface
806:     .we     (sealing_sw_binding_1_gated_we),
807:     .wd     (sealing_sw_binding_1_wd),
808: 
809:     // from internal hardware
810:     .de     (1'b0),
811:     .d      ('0),
812: 
813:     // to internal hardware
814:     .qe     (),
815:     .q      (reg2hw.sealing_sw_binding[1].q),
816:     .ds     (),
817: 
818:     // to register interface (read)
819:     .qs     (sealing_sw_binding_1_qs)
820:   );
821: 
822: 
823:   // Subregister 2 of Multireg sealing_sw_binding
824:   // R[sealing_sw_binding_2]: V(False)
825:   // Create REGWEN-gated WE signal
826:   logic sealing_sw_binding_2_gated_we;
827:   assign sealing_sw_binding_2_gated_we = sealing_sw_binding_2_we & sw_binding_regwen_qs;
828:   prim_subreg #(
829:     .DW      (32),
830:     .SwAccess(prim_subreg_pkg::SwAccessRW),
831:     .RESVAL  (32'h0),
832:     .Mubi    (1'b0)
833:   ) u_sealing_sw_binding_2 (
834:     .clk_i   (clk_i),
835:     .rst_ni  (rst_ni),
836: 
837:     // from register interface
838:     .we     (sealing_sw_binding_2_gated_we),
839:     .wd     (sealing_sw_binding_2_wd),
840: 
841:     // from internal hardware
842:     .de     (1'b0),
843:     .d      ('0),
844: 
845:     // to internal hardware
846:     .qe     (),
847:     .q      (reg2hw.sealing_sw_binding[2].q),
848:     .ds     (),
849: 
850:     // to register interface (read)
851:     .qs     (sealing_sw_binding_2_qs)
852:   );
853: 
854: 
855:   // Subregister 3 of Multireg sealing_sw_binding
856:   // R[sealing_sw_binding_3]: V(False)
857:   // Create REGWEN-gated WE signal
858:   logic sealing_sw_binding_3_gated_we;
859:   assign sealing_sw_binding_3_gated_we = sealing_sw_binding_3_we & sw_binding_regwen_qs;
860:   prim_subreg #(
861:     .DW      (32),
862:     .SwAccess(prim_subreg_pkg::SwAccessRW),
863:     .RESVAL  (32'h0),
864:     .Mubi    (1'b0)
865:   ) u_sealing_sw_binding_3 (
866:     .clk_i   (clk_i),
867:     .rst_ni  (rst_ni),
868: 
869:     // from register interface
870:     .we     (sealing_sw_binding_3_gated_we),
871:     .wd     (sealing_sw_binding_3_wd),
872: 
873:     // from internal hardware
874:     .de     (1'b0),
875:     .d      ('0),
876: 
877:     // to internal hardware
878:     .qe     (),
879:     .q      (reg2hw.sealing_sw_binding[3].q),
880:     .ds     (),
881: 
882:     // to register interface (read)
883:     .qs     (sealing_sw_binding_3_qs)
884:   );
885: 
886: 
887:   // Subregister 4 of Multireg sealing_sw_binding
888:   // R[sealing_sw_binding_4]: V(False)
889:   // Create REGWEN-gated WE signal
890:   logic sealing_sw_binding_4_gated_we;
891:   assign sealing_sw_binding_4_gated_we = sealing_sw_binding_4_we & sw_binding_regwen_qs;
892:   prim_subreg #(
893:     .DW      (32),
894:     .SwAccess(prim_subreg_pkg::SwAccessRW),
895:     .RESVAL  (32'h0),
896:     .Mubi    (1'b0)
897:   ) u_sealing_sw_binding_4 (
898:     .clk_i   (clk_i),
899:     .rst_ni  (rst_ni),
900: 
901:     // from register interface
902:     .we     (sealing_sw_binding_4_gated_we),
903:     .wd     (sealing_sw_binding_4_wd),
904: 
905:     // from internal hardware
906:     .de     (1'b0),
907:     .d      ('0),
908: 
909:     // to internal hardware
910:     .qe     (),
911:     .q      (reg2hw.sealing_sw_binding[4].q),
912:     .ds     (),
913: 
914:     // to register interface (read)
915:     .qs     (sealing_sw_binding_4_qs)
916:   );
917: 
918: 
919:   // Subregister 5 of Multireg sealing_sw_binding
920:   // R[sealing_sw_binding_5]: V(False)
921:   // Create REGWEN-gated WE signal
922:   logic sealing_sw_binding_5_gated_we;
923:   assign sealing_sw_binding_5_gated_we = sealing_sw_binding_5_we & sw_binding_regwen_qs;
924:   prim_subreg #(
925:     .DW      (32),
926:     .SwAccess(prim_subreg_pkg::SwAccessRW),
927:     .RESVAL  (32'h0),
928:     .Mubi    (1'b0)
929:   ) u_sealing_sw_binding_5 (
930:     .clk_i   (clk_i),
931:     .rst_ni  (rst_ni),
932: 
933:     // from register interface
934:     .we     (sealing_sw_binding_5_gated_we),
935:     .wd     (sealing_sw_binding_5_wd),
936: 
937:     // from internal hardware
938:     .de     (1'b0),
939:     .d      ('0),
940: 
941:     // to internal hardware
942:     .qe     (),
943:     .q      (reg2hw.sealing_sw_binding[5].q),
944:     .ds     (),
945: 
946:     // to register interface (read)
947:     .qs     (sealing_sw_binding_5_qs)
948:   );
949: 
950: 
951:   // Subregister 6 of Multireg sealing_sw_binding
952:   // R[sealing_sw_binding_6]: V(False)
953:   // Create REGWEN-gated WE signal
954:   logic sealing_sw_binding_6_gated_we;
955:   assign sealing_sw_binding_6_gated_we = sealing_sw_binding_6_we & sw_binding_regwen_qs;
956:   prim_subreg #(
957:     .DW      (32),
958:     .SwAccess(prim_subreg_pkg::SwAccessRW),
959:     .RESVAL  (32'h0),
960:     .Mubi    (1'b0)
961:   ) u_sealing_sw_binding_6 (
962:     .clk_i   (clk_i),
963:     .rst_ni  (rst_ni),
964: 
965:     // from register interface
966:     .we     (sealing_sw_binding_6_gated_we),
967:     .wd     (sealing_sw_binding_6_wd),
968: 
969:     // from internal hardware
970:     .de     (1'b0),
971:     .d      ('0),
972: 
973:     // to internal hardware
974:     .qe     (),
975:     .q      (reg2hw.sealing_sw_binding[6].q),
976:     .ds     (),
977: 
978:     // to register interface (read)
979:     .qs     (sealing_sw_binding_6_qs)
980:   );
981: 
982: 
983:   // Subregister 7 of Multireg sealing_sw_binding
984:   // R[sealing_sw_binding_7]: V(False)
985:   // Create REGWEN-gated WE signal
986:   logic sealing_sw_binding_7_gated_we;
987:   assign sealing_sw_binding_7_gated_we = sealing_sw_binding_7_we & sw_binding_regwen_qs;
988:   prim_subreg #(
989:     .DW      (32),
990:     .SwAccess(prim_subreg_pkg::SwAccessRW),
991:     .RESVAL  (32'h0),
992:     .Mubi    (1'b0)
993:   ) u_sealing_sw_binding_7 (
994:     .clk_i   (clk_i),
995:     .rst_ni  (rst_ni),
996: 
997:     // from register interface
998:     .we     (sealing_sw_binding_7_gated_we),
999:     .wd     (sealing_sw_binding_7_wd),
1000: 
1001:     // from internal hardware
1002:     .de     (1'b0),
1003:     .d      ('0),
1004: 
1005:     // to internal hardware
1006:     .qe     (),
1007:     .q      (reg2hw.sealing_sw_binding[7].q),
1008:     .ds     (),
1009: 
1010:     // to register interface (read)
1011:     .qs     (sealing_sw_binding_7_qs)
1012:   );
1013: 
1014: 
1015:   // Subregister 0 of Multireg attest_sw_binding
1016:   // R[attest_sw_binding_0]: V(False)
1017:   // Create REGWEN-gated WE signal
1018:   logic attest_sw_binding_0_gated_we;
1019:   assign attest_sw_binding_0_gated_we = attest_sw_binding_0_we & sw_binding_regwen_qs;
1020:   prim_subreg #(
1021:     .DW      (32),
1022:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1023:     .RESVAL  (32'h0),
1024:     .Mubi    (1'b0)
1025:   ) u_attest_sw_binding_0 (
1026:     .clk_i   (clk_i),
1027:     .rst_ni  (rst_ni),
1028: 
1029:     // from register interface
1030:     .we     (attest_sw_binding_0_gated_we),
1031:     .wd     (attest_sw_binding_0_wd),
1032: 
1033:     // from internal hardware
1034:     .de     (1'b0),
1035:     .d      ('0),
1036: 
1037:     // to internal hardware
1038:     .qe     (),
1039:     .q      (reg2hw.attest_sw_binding[0].q),
1040:     .ds     (),
1041: 
1042:     // to register interface (read)
1043:     .qs     (attest_sw_binding_0_qs)
1044:   );
1045: 
1046: 
1047:   // Subregister 1 of Multireg attest_sw_binding
1048:   // R[attest_sw_binding_1]: V(False)
1049:   // Create REGWEN-gated WE signal
1050:   logic attest_sw_binding_1_gated_we;
1051:   assign attest_sw_binding_1_gated_we = attest_sw_binding_1_we & sw_binding_regwen_qs;
1052:   prim_subreg #(
1053:     .DW      (32),
1054:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1055:     .RESVAL  (32'h0),
1056:     .Mubi    (1'b0)
1057:   ) u_attest_sw_binding_1 (
1058:     .clk_i   (clk_i),
1059:     .rst_ni  (rst_ni),
1060: 
1061:     // from register interface
1062:     .we     (attest_sw_binding_1_gated_we),
1063:     .wd     (attest_sw_binding_1_wd),
1064: 
1065:     // from internal hardware
1066:     .de     (1'b0),
1067:     .d      ('0),
1068: 
1069:     // to internal hardware
1070:     .qe     (),
1071:     .q      (reg2hw.attest_sw_binding[1].q),
1072:     .ds     (),
1073: 
1074:     // to register interface (read)
1075:     .qs     (attest_sw_binding_1_qs)
1076:   );
1077: 
1078: 
1079:   // Subregister 2 of Multireg attest_sw_binding
1080:   // R[attest_sw_binding_2]: V(False)
1081:   // Create REGWEN-gated WE signal
1082:   logic attest_sw_binding_2_gated_we;
1083:   assign attest_sw_binding_2_gated_we = attest_sw_binding_2_we & sw_binding_regwen_qs;
1084:   prim_subreg #(
1085:     .DW      (32),
1086:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1087:     .RESVAL  (32'h0),
1088:     .Mubi    (1'b0)
1089:   ) u_attest_sw_binding_2 (
1090:     .clk_i   (clk_i),
1091:     .rst_ni  (rst_ni),
1092: 
1093:     // from register interface
1094:     .we     (attest_sw_binding_2_gated_we),
1095:     .wd     (attest_sw_binding_2_wd),
1096: 
1097:     // from internal hardware
1098:     .de     (1'b0),
1099:     .d      ('0),
1100: 
1101:     // to internal hardware
1102:     .qe     (),
1103:     .q      (reg2hw.attest_sw_binding[2].q),
1104:     .ds     (),
1105: 
1106:     // to register interface (read)
1107:     .qs     (attest_sw_binding_2_qs)
1108:   );
1109: 
1110: 
1111:   // Subregister 3 of Multireg attest_sw_binding
1112:   // R[attest_sw_binding_3]: V(False)
1113:   // Create REGWEN-gated WE signal
1114:   logic attest_sw_binding_3_gated_we;
1115:   assign attest_sw_binding_3_gated_we = attest_sw_binding_3_we & sw_binding_regwen_qs;
1116:   prim_subreg #(
1117:     .DW      (32),
1118:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1119:     .RESVAL  (32'h0),
1120:     .Mubi    (1'b0)
1121:   ) u_attest_sw_binding_3 (
1122:     .clk_i   (clk_i),
1123:     .rst_ni  (rst_ni),
1124: 
1125:     // from register interface
1126:     .we     (attest_sw_binding_3_gated_we),
1127:     .wd     (attest_sw_binding_3_wd),
1128: 
1129:     // from internal hardware
1130:     .de     (1'b0),
1131:     .d      ('0),
1132: 
1133:     // to internal hardware
1134:     .qe     (),
1135:     .q      (reg2hw.attest_sw_binding[3].q),
1136:     .ds     (),
1137: 
1138:     // to register interface (read)
1139:     .qs     (attest_sw_binding_3_qs)
1140:   );
1141: 
1142: 
1143:   // Subregister 4 of Multireg attest_sw_binding
1144:   // R[attest_sw_binding_4]: V(False)
1145:   // Create REGWEN-gated WE signal
1146:   logic attest_sw_binding_4_gated_we;
1147:   assign attest_sw_binding_4_gated_we = attest_sw_binding_4_we & sw_binding_regwen_qs;
1148:   prim_subreg #(
1149:     .DW      (32),
1150:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1151:     .RESVAL  (32'h0),
1152:     .Mubi    (1'b0)
1153:   ) u_attest_sw_binding_4 (
1154:     .clk_i   (clk_i),
1155:     .rst_ni  (rst_ni),
1156: 
1157:     // from register interface
1158:     .we     (attest_sw_binding_4_gated_we),
1159:     .wd     (attest_sw_binding_4_wd),
1160: 
1161:     // from internal hardware
1162:     .de     (1'b0),
1163:     .d      ('0),
1164: 
1165:     // to internal hardware
1166:     .qe     (),
1167:     .q      (reg2hw.attest_sw_binding[4].q),
1168:     .ds     (),
1169: 
1170:     // to register interface (read)
1171:     .qs     (attest_sw_binding_4_qs)
1172:   );
1173: 
1174: 
1175:   // Subregister 5 of Multireg attest_sw_binding
1176:   // R[attest_sw_binding_5]: V(False)
1177:   // Create REGWEN-gated WE signal
1178:   logic attest_sw_binding_5_gated_we;
1179:   assign attest_sw_binding_5_gated_we = attest_sw_binding_5_we & sw_binding_regwen_qs;
1180:   prim_subreg #(
1181:     .DW      (32),
1182:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1183:     .RESVAL  (32'h0),
1184:     .Mubi    (1'b0)
1185:   ) u_attest_sw_binding_5 (
1186:     .clk_i   (clk_i),
1187:     .rst_ni  (rst_ni),
1188: 
1189:     // from register interface
1190:     .we     (attest_sw_binding_5_gated_we),
1191:     .wd     (attest_sw_binding_5_wd),
1192: 
1193:     // from internal hardware
1194:     .de     (1'b0),
1195:     .d      ('0),
1196: 
1197:     // to internal hardware
1198:     .qe     (),
1199:     .q      (reg2hw.attest_sw_binding[5].q),
1200:     .ds     (),
1201: 
1202:     // to register interface (read)
1203:     .qs     (attest_sw_binding_5_qs)
1204:   );
1205: 
1206: 
1207:   // Subregister 6 of Multireg attest_sw_binding
1208:   // R[attest_sw_binding_6]: V(False)
1209:   // Create REGWEN-gated WE signal
1210:   logic attest_sw_binding_6_gated_we;
1211:   assign attest_sw_binding_6_gated_we = attest_sw_binding_6_we & sw_binding_regwen_qs;
1212:   prim_subreg #(
1213:     .DW      (32),
1214:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1215:     .RESVAL  (32'h0),
1216:     .Mubi    (1'b0)
1217:   ) u_attest_sw_binding_6 (
1218:     .clk_i   (clk_i),
1219:     .rst_ni  (rst_ni),
1220: 
1221:     // from register interface
1222:     .we     (attest_sw_binding_6_gated_we),
1223:     .wd     (attest_sw_binding_6_wd),
1224: 
1225:     // from internal hardware
1226:     .de     (1'b0),
1227:     .d      ('0),
1228: 
1229:     // to internal hardware
1230:     .qe     (),
1231:     .q      (reg2hw.attest_sw_binding[6].q),
1232:     .ds     (),
1233: 
1234:     // to register interface (read)
1235:     .qs     (attest_sw_binding_6_qs)
1236:   );
1237: 
1238: 
1239:   // Subregister 7 of Multireg attest_sw_binding
1240:   // R[attest_sw_binding_7]: V(False)
1241:   // Create REGWEN-gated WE signal
1242:   logic attest_sw_binding_7_gated_we;
1243:   assign attest_sw_binding_7_gated_we = attest_sw_binding_7_we & sw_binding_regwen_qs;
1244:   prim_subreg #(
1245:     .DW      (32),
1246:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1247:     .RESVAL  (32'h0),
1248:     .Mubi    (1'b0)
1249:   ) u_attest_sw_binding_7 (
1250:     .clk_i   (clk_i),
1251:     .rst_ni  (rst_ni),
1252: 
1253:     // from register interface
1254:     .we     (attest_sw_binding_7_gated_we),
1255:     .wd     (attest_sw_binding_7_wd),
1256: 
1257:     // from internal hardware
1258:     .de     (1'b0),
1259:     .d      ('0),
1260: 
1261:     // to internal hardware
1262:     .qe     (),
1263:     .q      (reg2hw.attest_sw_binding[7].q),
1264:     .ds     (),
1265: 
1266:     // to register interface (read)
1267:     .qs     (attest_sw_binding_7_qs)
1268:   );
1269: 
1270: 
1271:   // Subregister 0 of Multireg salt
1272:   // R[salt_0]: V(False)
1273:   // Create REGWEN-gated WE signal
1274:   logic salt_0_gated_we;
1275:   assign salt_0_gated_we = salt_0_we & cfg_regwen_qs;
1276:   prim_subreg #(
1277:     .DW      (32),
1278:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1279:     .RESVAL  (32'h0),
1280:     .Mubi    (1'b0)
1281:   ) u_salt_0 (
1282:     .clk_i   (clk_i),
1283:     .rst_ni  (rst_ni),
1284: 
1285:     // from register interface
1286:     .we     (salt_0_gated_we),
1287:     .wd     (salt_0_wd),
1288: 
1289:     // from internal hardware
1290:     .de     (1'b0),
1291:     .d      ('0),
1292: 
1293:     // to internal hardware
1294:     .qe     (),
1295:     .q      (reg2hw.salt[0].q),
1296:     .ds     (),
1297: 
1298:     // to register interface (read)
1299:     .qs     (salt_0_qs)
1300:   );
1301: 
1302: 
1303:   // Subregister 1 of Multireg salt
1304:   // R[salt_1]: V(False)
1305:   // Create REGWEN-gated WE signal
1306:   logic salt_1_gated_we;
1307:   assign salt_1_gated_we = salt_1_we & cfg_regwen_qs;
1308:   prim_subreg #(
1309:     .DW      (32),
1310:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1311:     .RESVAL  (32'h0),
1312:     .Mubi    (1'b0)
1313:   ) u_salt_1 (
1314:     .clk_i   (clk_i),
1315:     .rst_ni  (rst_ni),
1316: 
1317:     // from register interface
1318:     .we     (salt_1_gated_we),
1319:     .wd     (salt_1_wd),
1320: 
1321:     // from internal hardware
1322:     .de     (1'b0),
1323:     .d      ('0),
1324: 
1325:     // to internal hardware
1326:     .qe     (),
1327:     .q      (reg2hw.salt[1].q),
1328:     .ds     (),
1329: 
1330:     // to register interface (read)
1331:     .qs     (salt_1_qs)
1332:   );
1333: 
1334: 
1335:   // Subregister 2 of Multireg salt
1336:   // R[salt_2]: V(False)
1337:   // Create REGWEN-gated WE signal
1338:   logic salt_2_gated_we;
1339:   assign salt_2_gated_we = salt_2_we & cfg_regwen_qs;
1340:   prim_subreg #(
1341:     .DW      (32),
1342:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1343:     .RESVAL  (32'h0),
1344:     .Mubi    (1'b0)
1345:   ) u_salt_2 (
1346:     .clk_i   (clk_i),
1347:     .rst_ni  (rst_ni),
1348: 
1349:     // from register interface
1350:     .we     (salt_2_gated_we),
1351:     .wd     (salt_2_wd),
1352: 
1353:     // from internal hardware
1354:     .de     (1'b0),
1355:     .d      ('0),
1356: 
1357:     // to internal hardware
1358:     .qe     (),
1359:     .q      (reg2hw.salt[2].q),
1360:     .ds     (),
1361: 
1362:     // to register interface (read)
1363:     .qs     (salt_2_qs)
1364:   );
1365: 
1366: 
1367:   // Subregister 3 of Multireg salt
1368:   // R[salt_3]: V(False)
1369:   // Create REGWEN-gated WE signal
1370:   logic salt_3_gated_we;
1371:   assign salt_3_gated_we = salt_3_we & cfg_regwen_qs;
1372:   prim_subreg #(
1373:     .DW      (32),
1374:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1375:     .RESVAL  (32'h0),
1376:     .Mubi    (1'b0)
1377:   ) u_salt_3 (
1378:     .clk_i   (clk_i),
1379:     .rst_ni  (rst_ni),
1380: 
1381:     // from register interface
1382:     .we     (salt_3_gated_we),
1383:     .wd     (salt_3_wd),
1384: 
1385:     // from internal hardware
1386:     .de     (1'b0),
1387:     .d      ('0),
1388: 
1389:     // to internal hardware
1390:     .qe     (),
1391:     .q      (reg2hw.salt[3].q),
1392:     .ds     (),
1393: 
1394:     // to register interface (read)
1395:     .qs     (salt_3_qs)
1396:   );
1397: 
1398: 
1399:   // Subregister 4 of Multireg salt
1400:   // R[salt_4]: V(False)
1401:   // Create REGWEN-gated WE signal
1402:   logic salt_4_gated_we;
1403:   assign salt_4_gated_we = salt_4_we & cfg_regwen_qs;
1404:   prim_subreg #(
1405:     .DW      (32),
1406:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1407:     .RESVAL  (32'h0),
1408:     .Mubi    (1'b0)
1409:   ) u_salt_4 (
1410:     .clk_i   (clk_i),
1411:     .rst_ni  (rst_ni),
1412: 
1413:     // from register interface
1414:     .we     (salt_4_gated_we),
1415:     .wd     (salt_4_wd),
1416: 
1417:     // from internal hardware
1418:     .de     (1'b0),
1419:     .d      ('0),
1420: 
1421:     // to internal hardware
1422:     .qe     (),
1423:     .q      (reg2hw.salt[4].q),
1424:     .ds     (),
1425: 
1426:     // to register interface (read)
1427:     .qs     (salt_4_qs)
1428:   );
1429: 
1430: 
1431:   // Subregister 5 of Multireg salt
1432:   // R[salt_5]: V(False)
1433:   // Create REGWEN-gated WE signal
1434:   logic salt_5_gated_we;
1435:   assign salt_5_gated_we = salt_5_we & cfg_regwen_qs;
1436:   prim_subreg #(
1437:     .DW      (32),
1438:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1439:     .RESVAL  (32'h0),
1440:     .Mubi    (1'b0)
1441:   ) u_salt_5 (
1442:     .clk_i   (clk_i),
1443:     .rst_ni  (rst_ni),
1444: 
1445:     // from register interface
1446:     .we     (salt_5_gated_we),
1447:     .wd     (salt_5_wd),
1448: 
1449:     // from internal hardware
1450:     .de     (1'b0),
1451:     .d      ('0),
1452: 
1453:     // to internal hardware
1454:     .qe     (),
1455:     .q      (reg2hw.salt[5].q),
1456:     .ds     (),
1457: 
1458:     // to register interface (read)
1459:     .qs     (salt_5_qs)
1460:   );
1461: 
1462: 
1463:   // Subregister 6 of Multireg salt
1464:   // R[salt_6]: V(False)
1465:   // Create REGWEN-gated WE signal
1466:   logic salt_6_gated_we;
1467:   assign salt_6_gated_we = salt_6_we & cfg_regwen_qs;
1468:   prim_subreg #(
1469:     .DW      (32),
1470:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1471:     .RESVAL  (32'h0),
1472:     .Mubi    (1'b0)
1473:   ) u_salt_6 (
1474:     .clk_i   (clk_i),
1475:     .rst_ni  (rst_ni),
1476: 
1477:     // from register interface
1478:     .we     (salt_6_gated_we),
1479:     .wd     (salt_6_wd),
1480: 
1481:     // from internal hardware
1482:     .de     (1'b0),
1483:     .d      ('0),
1484: 
1485:     // to internal hardware
1486:     .qe     (),
1487:     .q      (reg2hw.salt[6].q),
1488:     .ds     (),
1489: 
1490:     // to register interface (read)
1491:     .qs     (salt_6_qs)
1492:   );
1493: 
1494: 
1495:   // Subregister 7 of Multireg salt
1496:   // R[salt_7]: V(False)
1497:   // Create REGWEN-gated WE signal
1498:   logic salt_7_gated_we;
1499:   assign salt_7_gated_we = salt_7_we & cfg_regwen_qs;
1500:   prim_subreg #(
1501:     .DW      (32),
1502:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1503:     .RESVAL  (32'h0),
1504:     .Mubi    (1'b0)
1505:   ) u_salt_7 (
1506:     .clk_i   (clk_i),
1507:     .rst_ni  (rst_ni),
1508: 
1509:     // from register interface
1510:     .we     (salt_7_gated_we),
1511:     .wd     (salt_7_wd),
1512: 
1513:     // from internal hardware
1514:     .de     (1'b0),
1515:     .d      ('0),
1516: 
1517:     // to internal hardware
1518:     .qe     (),
1519:     .q      (reg2hw.salt[7].q),
1520:     .ds     (),
1521: 
1522:     // to register interface (read)
1523:     .qs     (salt_7_qs)
1524:   );
1525: 
1526: 
1527:   // Subregister 0 of Multireg key_version
1528:   // R[key_version]: V(False)
1529:   // Create REGWEN-gated WE signal
1530:   logic key_version_gated_we;
1531:   assign key_version_gated_we = key_version_we & cfg_regwen_qs;
1532:   prim_subreg #(
1533:     .DW      (32),
1534:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1535:     .RESVAL  (32'h0),
1536:     .Mubi    (1'b0)
1537:   ) u_key_version (
1538:     .clk_i   (clk_i),
1539:     .rst_ni  (rst_ni),
1540: 
1541:     // from register interface
1542:     .we     (key_version_gated_we),
1543:     .wd     (key_version_wd),
1544: 
1545:     // from internal hardware
1546:     .de     (1'b0),
1547:     .d      ('0),
1548: 
1549:     // to internal hardware
1550:     .qe     (),
1551:     .q      (reg2hw.key_version[0].q),
1552:     .ds     (),
1553: 
1554:     // to register interface (read)
1555:     .qs     (key_version_qs)
1556:   );
1557: 
1558: 
1559:   // R[max_creator_key_ver_regwen]: V(False)
1560:   prim_subreg #(
1561:     .DW      (1),
1562:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
1563:     .RESVAL  (1'h1),
1564:     .Mubi    (1'b0)
1565:   ) u_max_creator_key_ver_regwen (
1566:     .clk_i   (clk_i),
1567:     .rst_ni  (rst_ni),
1568: 
1569:     // from register interface
1570:     .we     (max_creator_key_ver_regwen_we),
1571:     .wd     (max_creator_key_ver_regwen_wd),
1572: 
1573:     // from internal hardware
1574:     .de     (1'b0),
1575:     .d      ('0),
1576: 
1577:     // to internal hardware
1578:     .qe     (),
1579:     .q      (),
1580:     .ds     (),
1581: 
1582:     // to register interface (read)
1583:     .qs     (max_creator_key_ver_regwen_qs)
1584:   );
1585: 
1586: 
1587:   // R[max_creator_key_ver_shadowed]: V(False)
1588:   // Create REGWEN-gated WE signal
1589:   logic max_creator_key_ver_shadowed_gated_we;
1590:   assign max_creator_key_ver_shadowed_gated_we =
1591:     max_creator_key_ver_shadowed_we & max_creator_key_ver_regwen_qs;
1592:   prim_subreg_shadow #(
1593:     .DW      (32),
1594:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1595:     .RESVAL  (32'h0),
1596:     .Mubi    (1'b0)
1597:   ) u_max_creator_key_ver_shadowed (
1598:     .clk_i   (clk_i),
1599:     .rst_ni  (rst_ni),
1600:     .rst_shadowed_ni (rst_shadowed_ni),
1601: 
1602:     // from register interface
1603:     .re     (max_creator_key_ver_shadowed_re),
1604:     .we     (max_creator_key_ver_shadowed_gated_we),
1605:     .wd     (max_creator_key_ver_shadowed_wd),
1606: 
1607:     // from internal hardware
1608:     .de     (1'b0),
1609:     .d      ('0),
1610: 
1611:     // to internal hardware
1612:     .qe     (),
1613:     .q      (reg2hw.max_creator_key_ver_shadowed.q),
1614:     .ds     (),
1615: 
1616:     // to register interface (read)
1617:     .qs     (max_creator_key_ver_shadowed_qs),
1618: 
1619:     // Shadow register phase. Relevant for hwext only.
1620:     .phase  (),
1621: 
1622:     // Shadow register error conditions
1623:     .err_update  (max_creator_key_ver_shadowed_update_err),
1624:     .err_storage (max_creator_key_ver_shadowed_storage_err)
1625:   );
1626: 
1627: 
1628:   // R[max_owner_int_key_ver_regwen]: V(False)
1629:   prim_subreg #(
1630:     .DW      (1),
1631:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
1632:     .RESVAL  (1'h1),
1633:     .Mubi    (1'b0)
1634:   ) u_max_owner_int_key_ver_regwen (
1635:     .clk_i   (clk_i),
1636:     .rst_ni  (rst_ni),
1637: 
1638:     // from register interface
1639:     .we     (max_owner_int_key_ver_regwen_we),
1640:     .wd     (max_owner_int_key_ver_regwen_wd),
1641: 
1642:     // from internal hardware
1643:     .de     (1'b0),
1644:     .d      ('0),
1645: 
1646:     // to internal hardware
1647:     .qe     (),
1648:     .q      (),
1649:     .ds     (),
1650: 
1651:     // to register interface (read)
1652:     .qs     (max_owner_int_key_ver_regwen_qs)
1653:   );
1654: 
1655: 
1656:   // R[max_owner_int_key_ver_shadowed]: V(False)
1657:   // Create REGWEN-gated WE signal
1658:   logic max_owner_int_key_ver_shadowed_gated_we;
1659:   assign max_owner_int_key_ver_shadowed_gated_we =
1660:     max_owner_int_key_ver_shadowed_we & max_owner_int_key_ver_regwen_qs;
1661:   prim_subreg_shadow #(
1662:     .DW      (32),
1663:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1664:     .RESVAL  (32'h1),
1665:     .Mubi    (1'b0)
1666:   ) u_max_owner_int_key_ver_shadowed (
1667:     .clk_i   (clk_i),
1668:     .rst_ni  (rst_ni),
1669:     .rst_shadowed_ni (rst_shadowed_ni),
1670: 
1671:     // from register interface
1672:     .re     (max_owner_int_key_ver_shadowed_re),
1673:     .we     (max_owner_int_key_ver_shadowed_gated_we),
1674:     .wd     (max_owner_int_key_ver_shadowed_wd),
1675: 
1676:     // from internal hardware
1677:     .de     (1'b0),
1678:     .d      ('0),
1679: 
1680:     // to internal hardware
1681:     .qe     (),
1682:     .q      (reg2hw.max_owner_int_key_ver_shadowed.q),
1683:     .ds     (),
1684: 
1685:     // to register interface (read)
1686:     .qs     (max_owner_int_key_ver_shadowed_qs),
1687: 
1688:     // Shadow register phase. Relevant for hwext only.
1689:     .phase  (),
1690: 
1691:     // Shadow register error conditions
1692:     .err_update  (max_owner_int_key_ver_shadowed_update_err),
1693:     .err_storage (max_owner_int_key_ver_shadowed_storage_err)
1694:   );
1695: 
1696: 
1697:   // R[max_owner_key_ver_regwen]: V(False)
1698:   prim_subreg #(
1699:     .DW      (1),
1700:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
1701:     .RESVAL  (1'h1),
1702:     .Mubi    (1'b0)
1703:   ) u_max_owner_key_ver_regwen (
1704:     .clk_i   (clk_i),
1705:     .rst_ni  (rst_ni),
1706: 
1707:     // from register interface
1708:     .we     (max_owner_key_ver_regwen_we),
1709:     .wd     (max_owner_key_ver_regwen_wd),
1710: 
1711:     // from internal hardware
1712:     .de     (1'b0),
1713:     .d      ('0),
1714: 
1715:     // to internal hardware
1716:     .qe     (),
1717:     .q      (),
1718:     .ds     (),
1719: 
1720:     // to register interface (read)
1721:     .qs     (max_owner_key_ver_regwen_qs)
1722:   );
1723: 
1724: 
1725:   // R[max_owner_key_ver_shadowed]: V(False)
1726:   // Create REGWEN-gated WE signal
1727:   logic max_owner_key_ver_shadowed_gated_we;
1728:   assign max_owner_key_ver_shadowed_gated_we =
1729:     max_owner_key_ver_shadowed_we & max_owner_key_ver_regwen_qs;
1730:   prim_subreg_shadow #(
1731:     .DW      (32),
1732:     .SwAccess(prim_subreg_pkg::SwAccessRW),
1733:     .RESVAL  (32'h0),
1734:     .Mubi    (1'b0)
1735:   ) u_max_owner_key_ver_shadowed (
1736:     .clk_i   (clk_i),
1737:     .rst_ni  (rst_ni),
1738:     .rst_shadowed_ni (rst_shadowed_ni),
1739: 
1740:     // from register interface
1741:     .re     (max_owner_key_ver_shadowed_re),
1742:     .we     (max_owner_key_ver_shadowed_gated_we),
1743:     .wd     (max_owner_key_ver_shadowed_wd),
1744: 
1745:     // from internal hardware
1746:     .de     (1'b0),
1747:     .d      ('0),
1748: 
1749:     // to internal hardware
1750:     .qe     (),
1751:     .q      (reg2hw.max_owner_key_ver_shadowed.q),
1752:     .ds     (),
1753: 
1754:     // to register interface (read)
1755:     .qs     (max_owner_key_ver_shadowed_qs),
1756: 
1757:     // Shadow register phase. Relevant for hwext only.
1758:     .phase  (),
1759: 
1760:     // Shadow register error conditions
1761:     .err_update  (max_owner_key_ver_shadowed_update_err),
1762:     .err_storage (max_owner_key_ver_shadowed_storage_err)
1763:   );
1764: 
1765: 
1766:   // Subregister 0 of Multireg sw_share0_output
1767:   // R[sw_share0_output_0]: V(False)
1768:   prim_subreg #(
1769:     .DW      (32),
1770:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1771:     .RESVAL  (32'h0),
1772:     .Mubi    (1'b0)
1773:   ) u_sw_share0_output_0 (
1774:     .clk_i   (clk_i),
1775:     .rst_ni  (rst_ni),
1776: 
1777:     // from register interface
1778:     .we     (sw_share0_output_0_re),
1779:     .wd     (sw_share0_output_0_wd),
1780: 
1781:     // from internal hardware
1782:     .de     (hw2reg.sw_share0_output[0].de),
1783:     .d      (hw2reg.sw_share0_output[0].d),
1784: 
1785:     // to internal hardware
1786:     .qe     (),
1787:     .q      (),
1788:     .ds     (),
1789: 
1790:     // to register interface (read)
1791:     .qs     (sw_share0_output_0_qs)
1792:   );
1793: 
1794: 
1795:   // Subregister 1 of Multireg sw_share0_output
1796:   // R[sw_share0_output_1]: V(False)
1797:   prim_subreg #(
1798:     .DW      (32),
1799:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1800:     .RESVAL  (32'h0),
1801:     .Mubi    (1'b0)
1802:   ) u_sw_share0_output_1 (
1803:     .clk_i   (clk_i),
1804:     .rst_ni  (rst_ni),
1805: 
1806:     // from register interface
1807:     .we     (sw_share0_output_1_re),
1808:     .wd     (sw_share0_output_1_wd),
1809: 
1810:     // from internal hardware
1811:     .de     (hw2reg.sw_share0_output[1].de),
1812:     .d      (hw2reg.sw_share0_output[1].d),
1813: 
1814:     // to internal hardware
1815:     .qe     (),
1816:     .q      (),
1817:     .ds     (),
1818: 
1819:     // to register interface (read)
1820:     .qs     (sw_share0_output_1_qs)
1821:   );
1822: 
1823: 
1824:   // Subregister 2 of Multireg sw_share0_output
1825:   // R[sw_share0_output_2]: V(False)
1826:   prim_subreg #(
1827:     .DW      (32),
1828:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1829:     .RESVAL  (32'h0),
1830:     .Mubi    (1'b0)
1831:   ) u_sw_share0_output_2 (
1832:     .clk_i   (clk_i),
1833:     .rst_ni  (rst_ni),
1834: 
1835:     // from register interface
1836:     .we     (sw_share0_output_2_re),
1837:     .wd     (sw_share0_output_2_wd),
1838: 
1839:     // from internal hardware
1840:     .de     (hw2reg.sw_share0_output[2].de),
1841:     .d      (hw2reg.sw_share0_output[2].d),
1842: 
1843:     // to internal hardware
1844:     .qe     (),
1845:     .q      (),
1846:     .ds     (),
1847: 
1848:     // to register interface (read)
1849:     .qs     (sw_share0_output_2_qs)
1850:   );
1851: 
1852: 
1853:   // Subregister 3 of Multireg sw_share0_output
1854:   // R[sw_share0_output_3]: V(False)
1855:   prim_subreg #(
1856:     .DW      (32),
1857:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1858:     .RESVAL  (32'h0),
1859:     .Mubi    (1'b0)
1860:   ) u_sw_share0_output_3 (
1861:     .clk_i   (clk_i),
1862:     .rst_ni  (rst_ni),
1863: 
1864:     // from register interface
1865:     .we     (sw_share0_output_3_re),
1866:     .wd     (sw_share0_output_3_wd),
1867: 
1868:     // from internal hardware
1869:     .de     (hw2reg.sw_share0_output[3].de),
1870:     .d      (hw2reg.sw_share0_output[3].d),
1871: 
1872:     // to internal hardware
1873:     .qe     (),
1874:     .q      (),
1875:     .ds     (),
1876: 
1877:     // to register interface (read)
1878:     .qs     (sw_share0_output_3_qs)
1879:   );
1880: 
1881: 
1882:   // Subregister 4 of Multireg sw_share0_output
1883:   // R[sw_share0_output_4]: V(False)
1884:   prim_subreg #(
1885:     .DW      (32),
1886:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1887:     .RESVAL  (32'h0),
1888:     .Mubi    (1'b0)
1889:   ) u_sw_share0_output_4 (
1890:     .clk_i   (clk_i),
1891:     .rst_ni  (rst_ni),
1892: 
1893:     // from register interface
1894:     .we     (sw_share0_output_4_re),
1895:     .wd     (sw_share0_output_4_wd),
1896: 
1897:     // from internal hardware
1898:     .de     (hw2reg.sw_share0_output[4].de),
1899:     .d      (hw2reg.sw_share0_output[4].d),
1900: 
1901:     // to internal hardware
1902:     .qe     (),
1903:     .q      (),
1904:     .ds     (),
1905: 
1906:     // to register interface (read)
1907:     .qs     (sw_share0_output_4_qs)
1908:   );
1909: 
1910: 
1911:   // Subregister 5 of Multireg sw_share0_output
1912:   // R[sw_share0_output_5]: V(False)
1913:   prim_subreg #(
1914:     .DW      (32),
1915:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1916:     .RESVAL  (32'h0),
1917:     .Mubi    (1'b0)
1918:   ) u_sw_share0_output_5 (
1919:     .clk_i   (clk_i),
1920:     .rst_ni  (rst_ni),
1921: 
1922:     // from register interface
1923:     .we     (sw_share0_output_5_re),
1924:     .wd     (sw_share0_output_5_wd),
1925: 
1926:     // from internal hardware
1927:     .de     (hw2reg.sw_share0_output[5].de),
1928:     .d      (hw2reg.sw_share0_output[5].d),
1929: 
1930:     // to internal hardware
1931:     .qe     (),
1932:     .q      (),
1933:     .ds     (),
1934: 
1935:     // to register interface (read)
1936:     .qs     (sw_share0_output_5_qs)
1937:   );
1938: 
1939: 
1940:   // Subregister 6 of Multireg sw_share0_output
1941:   // R[sw_share0_output_6]: V(False)
1942:   prim_subreg #(
1943:     .DW      (32),
1944:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1945:     .RESVAL  (32'h0),
1946:     .Mubi    (1'b0)
1947:   ) u_sw_share0_output_6 (
1948:     .clk_i   (clk_i),
1949:     .rst_ni  (rst_ni),
1950: 
1951:     // from register interface
1952:     .we     (sw_share0_output_6_re),
1953:     .wd     (sw_share0_output_6_wd),
1954: 
1955:     // from internal hardware
1956:     .de     (hw2reg.sw_share0_output[6].de),
1957:     .d      (hw2reg.sw_share0_output[6].d),
1958: 
1959:     // to internal hardware
1960:     .qe     (),
1961:     .q      (),
1962:     .ds     (),
1963: 
1964:     // to register interface (read)
1965:     .qs     (sw_share0_output_6_qs)
1966:   );
1967: 
1968: 
1969:   // Subregister 7 of Multireg sw_share0_output
1970:   // R[sw_share0_output_7]: V(False)
1971:   prim_subreg #(
1972:     .DW      (32),
1973:     .SwAccess(prim_subreg_pkg::SwAccessRC),
1974:     .RESVAL  (32'h0),
1975:     .Mubi    (1'b0)
1976:   ) u_sw_share0_output_7 (
1977:     .clk_i   (clk_i),
1978:     .rst_ni  (rst_ni),
1979: 
1980:     // from register interface
1981:     .we     (sw_share0_output_7_re),
1982:     .wd     (sw_share0_output_7_wd),
1983: 
1984:     // from internal hardware
1985:     .de     (hw2reg.sw_share0_output[7].de),
1986:     .d      (hw2reg.sw_share0_output[7].d),
1987: 
1988:     // to internal hardware
1989:     .qe     (),
1990:     .q      (),
1991:     .ds     (),
1992: 
1993:     // to register interface (read)
1994:     .qs     (sw_share0_output_7_qs)
1995:   );
1996: 
1997: 
1998:   // Subregister 0 of Multireg sw_share1_output
1999:   // R[sw_share1_output_0]: V(False)
2000:   prim_subreg #(
2001:     .DW      (32),
2002:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2003:     .RESVAL  (32'h0),
2004:     .Mubi    (1'b0)
2005:   ) u_sw_share1_output_0 (
2006:     .clk_i   (clk_i),
2007:     .rst_ni  (rst_ni),
2008: 
2009:     // from register interface
2010:     .we     (sw_share1_output_0_re),
2011:     .wd     (sw_share1_output_0_wd),
2012: 
2013:     // from internal hardware
2014:     .de     (hw2reg.sw_share1_output[0].de),
2015:     .d      (hw2reg.sw_share1_output[0].d),
2016: 
2017:     // to internal hardware
2018:     .qe     (),
2019:     .q      (),
2020:     .ds     (),
2021: 
2022:     // to register interface (read)
2023:     .qs     (sw_share1_output_0_qs)
2024:   );
2025: 
2026: 
2027:   // Subregister 1 of Multireg sw_share1_output
2028:   // R[sw_share1_output_1]: V(False)
2029:   prim_subreg #(
2030:     .DW      (32),
2031:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2032:     .RESVAL  (32'h0),
2033:     .Mubi    (1'b0)
2034:   ) u_sw_share1_output_1 (
2035:     .clk_i   (clk_i),
2036:     .rst_ni  (rst_ni),
2037: 
2038:     // from register interface
2039:     .we     (sw_share1_output_1_re),
2040:     .wd     (sw_share1_output_1_wd),
2041: 
2042:     // from internal hardware
2043:     .de     (hw2reg.sw_share1_output[1].de),
2044:     .d      (hw2reg.sw_share1_output[1].d),
2045: 
2046:     // to internal hardware
2047:     .qe     (),
2048:     .q      (),
2049:     .ds     (),
2050: 
2051:     // to register interface (read)
2052:     .qs     (sw_share1_output_1_qs)
2053:   );
2054: 
2055: 
2056:   // Subregister 2 of Multireg sw_share1_output
2057:   // R[sw_share1_output_2]: V(False)
2058:   prim_subreg #(
2059:     .DW      (32),
2060:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2061:     .RESVAL  (32'h0),
2062:     .Mubi    (1'b0)
2063:   ) u_sw_share1_output_2 (
2064:     .clk_i   (clk_i),
2065:     .rst_ni  (rst_ni),
2066: 
2067:     // from register interface
2068:     .we     (sw_share1_output_2_re),
2069:     .wd     (sw_share1_output_2_wd),
2070: 
2071:     // from internal hardware
2072:     .de     (hw2reg.sw_share1_output[2].de),
2073:     .d      (hw2reg.sw_share1_output[2].d),
2074: 
2075:     // to internal hardware
2076:     .qe     (),
2077:     .q      (),
2078:     .ds     (),
2079: 
2080:     // to register interface (read)
2081:     .qs     (sw_share1_output_2_qs)
2082:   );
2083: 
2084: 
2085:   // Subregister 3 of Multireg sw_share1_output
2086:   // R[sw_share1_output_3]: V(False)
2087:   prim_subreg #(
2088:     .DW      (32),
2089:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2090:     .RESVAL  (32'h0),
2091:     .Mubi    (1'b0)
2092:   ) u_sw_share1_output_3 (
2093:     .clk_i   (clk_i),
2094:     .rst_ni  (rst_ni),
2095: 
2096:     // from register interface
2097:     .we     (sw_share1_output_3_re),
2098:     .wd     (sw_share1_output_3_wd),
2099: 
2100:     // from internal hardware
2101:     .de     (hw2reg.sw_share1_output[3].de),
2102:     .d      (hw2reg.sw_share1_output[3].d),
2103: 
2104:     // to internal hardware
2105:     .qe     (),
2106:     .q      (),
2107:     .ds     (),
2108: 
2109:     // to register interface (read)
2110:     .qs     (sw_share1_output_3_qs)
2111:   );
2112: 
2113: 
2114:   // Subregister 4 of Multireg sw_share1_output
2115:   // R[sw_share1_output_4]: V(False)
2116:   prim_subreg #(
2117:     .DW      (32),
2118:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2119:     .RESVAL  (32'h0),
2120:     .Mubi    (1'b0)
2121:   ) u_sw_share1_output_4 (
2122:     .clk_i   (clk_i),
2123:     .rst_ni  (rst_ni),
2124: 
2125:     // from register interface
2126:     .we     (sw_share1_output_4_re),
2127:     .wd     (sw_share1_output_4_wd),
2128: 
2129:     // from internal hardware
2130:     .de     (hw2reg.sw_share1_output[4].de),
2131:     .d      (hw2reg.sw_share1_output[4].d),
2132: 
2133:     // to internal hardware
2134:     .qe     (),
2135:     .q      (),
2136:     .ds     (),
2137: 
2138:     // to register interface (read)
2139:     .qs     (sw_share1_output_4_qs)
2140:   );
2141: 
2142: 
2143:   // Subregister 5 of Multireg sw_share1_output
2144:   // R[sw_share1_output_5]: V(False)
2145:   prim_subreg #(
2146:     .DW      (32),
2147:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2148:     .RESVAL  (32'h0),
2149:     .Mubi    (1'b0)
2150:   ) u_sw_share1_output_5 (
2151:     .clk_i   (clk_i),
2152:     .rst_ni  (rst_ni),
2153: 
2154:     // from register interface
2155:     .we     (sw_share1_output_5_re),
2156:     .wd     (sw_share1_output_5_wd),
2157: 
2158:     // from internal hardware
2159:     .de     (hw2reg.sw_share1_output[5].de),
2160:     .d      (hw2reg.sw_share1_output[5].d),
2161: 
2162:     // to internal hardware
2163:     .qe     (),
2164:     .q      (),
2165:     .ds     (),
2166: 
2167:     // to register interface (read)
2168:     .qs     (sw_share1_output_5_qs)
2169:   );
2170: 
2171: 
2172:   // Subregister 6 of Multireg sw_share1_output
2173:   // R[sw_share1_output_6]: V(False)
2174:   prim_subreg #(
2175:     .DW      (32),
2176:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2177:     .RESVAL  (32'h0),
2178:     .Mubi    (1'b0)
2179:   ) u_sw_share1_output_6 (
2180:     .clk_i   (clk_i),
2181:     .rst_ni  (rst_ni),
2182: 
2183:     // from register interface
2184:     .we     (sw_share1_output_6_re),
2185:     .wd     (sw_share1_output_6_wd),
2186: 
2187:     // from internal hardware
2188:     .de     (hw2reg.sw_share1_output[6].de),
2189:     .d      (hw2reg.sw_share1_output[6].d),
2190: 
2191:     // to internal hardware
2192:     .qe     (),
2193:     .q      (),
2194:     .ds     (),
2195: 
2196:     // to register interface (read)
2197:     .qs     (sw_share1_output_6_qs)
2198:   );
2199: 
2200: 
2201:   // Subregister 7 of Multireg sw_share1_output
2202:   // R[sw_share1_output_7]: V(False)
2203:   prim_subreg #(
2204:     .DW      (32),
2205:     .SwAccess(prim_subreg_pkg::SwAccessRC),
2206:     .RESVAL  (32'h0),
2207:     .Mubi    (1'b0)
2208:   ) u_sw_share1_output_7 (
2209:     .clk_i   (clk_i),
2210:     .rst_ni  (rst_ni),
2211: 
2212:     // from register interface
2213:     .we     (sw_share1_output_7_re),
2214:     .wd     (sw_share1_output_7_wd),
2215: 
2216:     // from internal hardware
2217:     .de     (hw2reg.sw_share1_output[7].de),
2218:     .d      (hw2reg.sw_share1_output[7].d),
2219: 
2220:     // to internal hardware
2221:     .qe     (),
2222:     .q      (),
2223:     .ds     (),
2224: 
2225:     // to register interface (read)
2226:     .qs     (sw_share1_output_7_qs)
2227:   );
2228: 
2229: 
2230:   // R[working_state]: V(False)
2231:   prim_subreg #(
2232:     .DW      (3),
2233:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2234:     .RESVAL  (3'h0),
2235:     .Mubi    (1'b0)
2236:   ) u_working_state (
2237:     .clk_i   (clk_i),
2238:     .rst_ni  (rst_ni),
2239: 
2240:     // from register interface
2241:     .we     (1'b0),
2242:     .wd     ('0),
2243: 
2244:     // from internal hardware
2245:     .de     (hw2reg.working_state.de),
2246:     .d      (hw2reg.working_state.d),
2247: 
2248:     // to internal hardware
2249:     .qe     (),
2250:     .q      (),
2251:     .ds     (),
2252: 
2253:     // to register interface (read)
2254:     .qs     (working_state_qs)
2255:   );
2256: 
2257: 
2258:   // R[op_status]: V(False)
2259:   prim_subreg #(
2260:     .DW      (2),
2261:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
2262:     .RESVAL  (2'h0),
2263:     .Mubi    (1'b0)
2264:   ) u_op_status (
2265:     .clk_i   (clk_i),
2266:     .rst_ni  (rst_ni),
2267: 
2268:     // from register interface
2269:     .we     (op_status_we),
2270:     .wd     (op_status_wd),
2271: 
2272:     // from internal hardware
2273:     .de     (hw2reg.op_status.de),
2274:     .d      (hw2reg.op_status.d),
2275: 
2276:     // to internal hardware
2277:     .qe     (),
2278:     .q      (),
2279:     .ds     (),
2280: 
2281:     // to register interface (read)
2282:     .qs     (op_status_qs)
2283:   );
2284: 
2285: 
2286:   // R[err_code]: V(False)
2287:   //   F[invalid_op]: 0:0
2288:   prim_subreg #(
2289:     .DW      (1),
2290:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
2291:     .RESVAL  (1'h0),
2292:     .Mubi    (1'b0)
2293:   ) u_err_code_invalid_op (
2294:     .clk_i   (clk_i),
2295:     .rst_ni  (rst_ni),
2296: 
2297:     // from register interface
2298:     .we     (err_code_we),
2299:     .wd     (err_code_invalid_op_wd),
2300: 
2301:     // from internal hardware
2302:     .de     (hw2reg.err_code.invalid_op.de),
2303:     .d      (hw2reg.err_code.invalid_op.d),
2304: 
2305:     // to internal hardware
2306:     .qe     (),
2307:     .q      (),
2308:     .ds     (),
2309: 
2310:     // to register interface (read)
2311:     .qs     (err_code_invalid_op_qs)
2312:   );
2313: 
2314:   //   F[invalid_kmac_input]: 1:1
2315:   prim_subreg #(
2316:     .DW      (1),
2317:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
2318:     .RESVAL  (1'h0),
2319:     .Mubi    (1'b0)
2320:   ) u_err_code_invalid_kmac_input (
2321:     .clk_i   (clk_i),
2322:     .rst_ni  (rst_ni),
2323: 
2324:     // from register interface
2325:     .we     (err_code_we),
2326:     .wd     (err_code_invalid_kmac_input_wd),
2327: 
2328:     // from internal hardware
2329:     .de     (hw2reg.err_code.invalid_kmac_input.de),
2330:     .d      (hw2reg.err_code.invalid_kmac_input.d),
2331: 
2332:     // to internal hardware
2333:     .qe     (),
2334:     .q      (),
2335:     .ds     (),
2336: 
2337:     // to register interface (read)
2338:     .qs     (err_code_invalid_kmac_input_qs)
2339:   );
2340: 
2341:   //   F[invalid_shadow_update]: 2:2
2342:   prim_subreg #(
2343:     .DW      (1),
2344:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
2345:     .RESVAL  (1'h0),
2346:     .Mubi    (1'b0)
2347:   ) u_err_code_invalid_shadow_update (
2348:     .clk_i   (clk_i),
2349:     .rst_ni  (rst_ni),
2350: 
2351:     // from register interface
2352:     .we     (err_code_we),
2353:     .wd     (err_code_invalid_shadow_update_wd),
2354: 
2355:     // from internal hardware
2356:     .de     (hw2reg.err_code.invalid_shadow_update.de),
2357:     .d      (hw2reg.err_code.invalid_shadow_update.d),
2358: 
2359:     // to internal hardware
2360:     .qe     (),
2361:     .q      (),
2362:     .ds     (),
2363: 
2364:     // to register interface (read)
2365:     .qs     (err_code_invalid_shadow_update_qs)
2366:   );
2367: 
2368: 
2369:   // R[fault_status]: V(False)
2370:   //   F[cmd]: 0:0
2371:   prim_subreg #(
2372:     .DW      (1),
2373:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2374:     .RESVAL  (1'h0),
2375:     .Mubi    (1'b0)
2376:   ) u_fault_status_cmd (
2377:     .clk_i   (clk_i),
2378:     .rst_ni  (rst_ni),
2379: 
2380:     // from register interface
2381:     .we     (1'b0),
2382:     .wd     ('0),
2383: 
2384:     // from internal hardware
2385:     .de     (hw2reg.fault_status.cmd.de),
2386:     .d      (hw2reg.fault_status.cmd.d),
2387: 
2388:     // to internal hardware
2389:     .qe     (),
2390:     .q      (reg2hw.fault_status.cmd.q),
2391:     .ds     (),
2392: 
2393:     // to register interface (read)
2394:     .qs     (fault_status_cmd_qs)
2395:   );
2396: 
2397:   //   F[kmac_fsm]: 1:1
2398:   prim_subreg #(
2399:     .DW      (1),
2400:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2401:     .RESVAL  (1'h0),
2402:     .Mubi    (1'b0)
2403:   ) u_fault_status_kmac_fsm (
2404:     .clk_i   (clk_i),
2405:     .rst_ni  (rst_ni),
2406: 
2407:     // from register interface
2408:     .we     (1'b0),
2409:     .wd     ('0),
2410: 
2411:     // from internal hardware
2412:     .de     (hw2reg.fault_status.kmac_fsm.de),
2413:     .d      (hw2reg.fault_status.kmac_fsm.d),
2414: 
2415:     // to internal hardware
2416:     .qe     (),
2417:     .q      (reg2hw.fault_status.kmac_fsm.q),
2418:     .ds     (),
2419: 
2420:     // to register interface (read)
2421:     .qs     (fault_status_kmac_fsm_qs)
2422:   );
2423: 
2424:   //   F[kmac_done]: 2:2
2425:   prim_subreg #(
2426:     .DW      (1),
2427:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2428:     .RESVAL  (1'h0),
2429:     .Mubi    (1'b0)
2430:   ) u_fault_status_kmac_done (
2431:     .clk_i   (clk_i),
2432:     .rst_ni  (rst_ni),
2433: 
2434:     // from register interface
2435:     .we     (1'b0),
2436:     .wd     ('0),
2437: 
2438:     // from internal hardware
2439:     .de     (hw2reg.fault_status.kmac_done.de),
2440:     .d      (hw2reg.fault_status.kmac_done.d),
2441: 
2442:     // to internal hardware
2443:     .qe     (),
2444:     .q      (reg2hw.fault_status.kmac_done.q),
2445:     .ds     (),
2446: 
2447:     // to register interface (read)
2448:     .qs     (fault_status_kmac_done_qs)
2449:   );
2450: 
2451:   //   F[kmac_op]: 3:3
2452:   prim_subreg #(
2453:     .DW      (1),
2454:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2455:     .RESVAL  (1'h0),
2456:     .Mubi    (1'b0)
2457:   ) u_fault_status_kmac_op (
2458:     .clk_i   (clk_i),
2459:     .rst_ni  (rst_ni),
2460: 
2461:     // from register interface
2462:     .we     (1'b0),
2463:     .wd     ('0),
2464: 
2465:     // from internal hardware
2466:     .de     (hw2reg.fault_status.kmac_op.de),
2467:     .d      (hw2reg.fault_status.kmac_op.d),
2468: 
2469:     // to internal hardware
2470:     .qe     (),
2471:     .q      (reg2hw.fault_status.kmac_op.q),
2472:     .ds     (),
2473: 
2474:     // to register interface (read)
2475:     .qs     (fault_status_kmac_op_qs)
2476:   );
2477: 
2478:   //   F[kmac_out]: 4:4
2479:   prim_subreg #(
2480:     .DW      (1),
2481:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2482:     .RESVAL  (1'h0),
2483:     .Mubi    (1'b0)
2484:   ) u_fault_status_kmac_out (
2485:     .clk_i   (clk_i),
2486:     .rst_ni  (rst_ni),
2487: 
2488:     // from register interface
2489:     .we     (1'b0),
2490:     .wd     ('0),
2491: 
2492:     // from internal hardware
2493:     .de     (hw2reg.fault_status.kmac_out.de),
2494:     .d      (hw2reg.fault_status.kmac_out.d),
2495: 
2496:     // to internal hardware
2497:     .qe     (),
2498:     .q      (reg2hw.fault_status.kmac_out.q),
2499:     .ds     (),
2500: 
2501:     // to register interface (read)
2502:     .qs     (fault_status_kmac_out_qs)
2503:   );
2504: 
2505:   //   F[regfile_intg]: 5:5
2506:   prim_subreg #(
2507:     .DW      (1),
2508:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2509:     .RESVAL  (1'h0),
2510:     .Mubi    (1'b0)
2511:   ) u_fault_status_regfile_intg (
2512:     .clk_i   (clk_i),
2513:     .rst_ni  (rst_ni),
2514: 
2515:     // from register interface
2516:     .we     (1'b0),
2517:     .wd     ('0),
2518: 
2519:     // from internal hardware
2520:     .de     (hw2reg.fault_status.regfile_intg.de),
2521:     .d      (hw2reg.fault_status.regfile_intg.d),
2522: 
2523:     // to internal hardware
2524:     .qe     (),
2525:     .q      (reg2hw.fault_status.regfile_intg.q),
2526:     .ds     (),
2527: 
2528:     // to register interface (read)
2529:     .qs     (fault_status_regfile_intg_qs)
2530:   );
2531: 
2532:   //   F[shadow]: 6:6
2533:   prim_subreg #(
2534:     .DW      (1),
2535:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2536:     .RESVAL  (1'h0),
2537:     .Mubi    (1'b0)
2538:   ) u_fault_status_shadow (
2539:     .clk_i   (clk_i),
2540:     .rst_ni  (rst_ni),
2541: 
2542:     // from register interface
2543:     .we     (1'b0),
2544:     .wd     ('0),
2545: 
2546:     // from internal hardware
2547:     .de     (hw2reg.fault_status.shadow.de),
2548:     .d      (hw2reg.fault_status.shadow.d),
2549: 
2550:     // to internal hardware
2551:     .qe     (),
2552:     .q      (reg2hw.fault_status.shadow.q),
2553:     .ds     (),
2554: 
2555:     // to register interface (read)
2556:     .qs     (fault_status_shadow_qs)
2557:   );
2558: 
2559:   //   F[ctrl_fsm_intg]: 7:7
2560:   prim_subreg #(
2561:     .DW      (1),
2562:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2563:     .RESVAL  (1'h0),
2564:     .Mubi    (1'b0)
2565:   ) u_fault_status_ctrl_fsm_intg (
2566:     .clk_i   (clk_i),
2567:     .rst_ni  (rst_ni),
2568: 
2569:     // from register interface
2570:     .we     (1'b0),
2571:     .wd     ('0),
2572: 
2573:     // from internal hardware
2574:     .de     (hw2reg.fault_status.ctrl_fsm_intg.de),
2575:     .d      (hw2reg.fault_status.ctrl_fsm_intg.d),
2576: 
2577:     // to internal hardware
2578:     .qe     (),
2579:     .q      (reg2hw.fault_status.ctrl_fsm_intg.q),
2580:     .ds     (),
2581: 
2582:     // to register interface (read)
2583:     .qs     (fault_status_ctrl_fsm_intg_qs)
2584:   );
2585: 
2586:   //   F[ctrl_fsm_chk]: 8:8
2587:   prim_subreg #(
2588:     .DW      (1),
2589:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2590:     .RESVAL  (1'h0),
2591:     .Mubi    (1'b0)
2592:   ) u_fault_status_ctrl_fsm_chk (
2593:     .clk_i   (clk_i),
2594:     .rst_ni  (rst_ni),
2595: 
2596:     // from register interface
2597:     .we     (1'b0),
2598:     .wd     ('0),
2599: 
2600:     // from internal hardware
2601:     .de     (hw2reg.fault_status.ctrl_fsm_chk.de),
2602:     .d      (hw2reg.fault_status.ctrl_fsm_chk.d),
2603: 
2604:     // to internal hardware
2605:     .qe     (),
2606:     .q      (reg2hw.fault_status.ctrl_fsm_chk.q),
2607:     .ds     (),
2608: 
2609:     // to register interface (read)
2610:     .qs     (fault_status_ctrl_fsm_chk_qs)
2611:   );
2612: 
2613:   //   F[ctrl_fsm_cnt]: 9:9
2614:   prim_subreg #(
2615:     .DW      (1),
2616:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2617:     .RESVAL  (1'h0),
2618:     .Mubi    (1'b0)
2619:   ) u_fault_status_ctrl_fsm_cnt (
2620:     .clk_i   (clk_i),
2621:     .rst_ni  (rst_ni),
2622: 
2623:     // from register interface
2624:     .we     (1'b0),
2625:     .wd     ('0),
2626: 
2627:     // from internal hardware
2628:     .de     (hw2reg.fault_status.ctrl_fsm_cnt.de),
2629:     .d      (hw2reg.fault_status.ctrl_fsm_cnt.d),
2630: 
2631:     // to internal hardware
2632:     .qe     (),
2633:     .q      (reg2hw.fault_status.ctrl_fsm_cnt.q),
2634:     .ds     (),
2635: 
2636:     // to register interface (read)
2637:     .qs     (fault_status_ctrl_fsm_cnt_qs)
2638:   );
2639: 
2640:   //   F[reseed_cnt]: 10:10
2641:   prim_subreg #(
2642:     .DW      (1),
2643:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2644:     .RESVAL  (1'h0),
2645:     .Mubi    (1'b0)
2646:   ) u_fault_status_reseed_cnt (
2647:     .clk_i   (clk_i),
2648:     .rst_ni  (rst_ni),
2649: 
2650:     // from register interface
2651:     .we     (1'b0),
2652:     .wd     ('0),
2653: 
2654:     // from internal hardware
2655:     .de     (hw2reg.fault_status.reseed_cnt.de),
2656:     .d      (hw2reg.fault_status.reseed_cnt.d),
2657: 
2658:     // to internal hardware
2659:     .qe     (),
2660:     .q      (reg2hw.fault_status.reseed_cnt.q),
2661:     .ds     (),
2662: 
2663:     // to register interface (read)
2664:     .qs     (fault_status_reseed_cnt_qs)
2665:   );
2666: 
2667:   //   F[side_ctrl_fsm]: 11:11
2668:   prim_subreg #(
2669:     .DW      (1),
2670:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2671:     .RESVAL  (1'h0),
2672:     .Mubi    (1'b0)
2673:   ) u_fault_status_side_ctrl_fsm (
2674:     .clk_i   (clk_i),
2675:     .rst_ni  (rst_ni),
2676: 
2677:     // from register interface
2678:     .we     (1'b0),
2679:     .wd     ('0),
2680: 
2681:     // from internal hardware
2682:     .de     (hw2reg.fault_status.side_ctrl_fsm.de),
2683:     .d      (hw2reg.fault_status.side_ctrl_fsm.d),
2684: 
2685:     // to internal hardware
2686:     .qe     (),
2687:     .q      (reg2hw.fault_status.side_ctrl_fsm.q),
2688:     .ds     (),
2689: 
2690:     // to register interface (read)
2691:     .qs     (fault_status_side_ctrl_fsm_qs)
2692:   );
2693: 
2694:   //   F[side_ctrl_sel]: 12:12
2695:   prim_subreg #(
2696:     .DW      (1),
2697:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2698:     .RESVAL  (1'h0),
2699:     .Mubi    (1'b0)
2700:   ) u_fault_status_side_ctrl_sel (
2701:     .clk_i   (clk_i),
2702:     .rst_ni  (rst_ni),
2703: 
2704:     // from register interface
2705:     .we     (1'b0),
2706:     .wd     ('0),
2707: 
2708:     // from internal hardware
2709:     .de     (hw2reg.fault_status.side_ctrl_sel.de),
2710:     .d      (hw2reg.fault_status.side_ctrl_sel.d),
2711: 
2712:     // to internal hardware
2713:     .qe     (),
2714:     .q      (reg2hw.fault_status.side_ctrl_sel.q),
2715:     .ds     (),
2716: 
2717:     // to register interface (read)
2718:     .qs     (fault_status_side_ctrl_sel_qs)
2719:   );
2720: 
2721:   //   F[key_ecc]: 13:13
2722:   prim_subreg #(
2723:     .DW      (1),
2724:     .SwAccess(prim_subreg_pkg::SwAccessRO),
2725:     .RESVAL  (1'h0),
2726:     .Mubi    (1'b0)
2727:   ) u_fault_status_key_ecc (
2728:     .clk_i   (clk_i),
2729:     .rst_ni  (rst_ni),
2730: 
2731:     // from register interface
2732:     .we     (1'b0),
2733:     .wd     ('0),
2734: 
2735:     // from internal hardware
2736:     .de     (hw2reg.fault_status.key_ecc.de),
2737:     .d      (hw2reg.fault_status.key_ecc.d),
2738: 
2739:     // to internal hardware
2740:     .qe     (),
2741:     .q      (reg2hw.fault_status.key_ecc.q),
2742:     .ds     (),
2743: 
2744:     // to register interface (read)
2745:     .qs     (fault_status_key_ecc_qs)
2746:   );
2747: 
2748: 
2749:   // R[debug]: V(False)
2750:   //   F[invalid_creator_seed]: 0:0
2751:   prim_subreg #(
2752:     .DW      (1),
2753:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2754:     .RESVAL  (1'h0),
2755:     .Mubi    (1'b0)
2756:   ) u_debug_invalid_creator_seed (
2757:     .clk_i   (clk_i),
2758:     .rst_ni  (rst_ni),
2759: 
2760:     // from register interface
2761:     .we     (debug_we),
2762:     .wd     (debug_invalid_creator_seed_wd),
2763: 
2764:     // from internal hardware
2765:     .de     (hw2reg.debug.invalid_creator_seed.de),
2766:     .d      (hw2reg.debug.invalid_creator_seed.d),
2767: 
2768:     // to internal hardware
2769:     .qe     (),
2770:     .q      (),
2771:     .ds     (),
2772: 
2773:     // to register interface (read)
2774:     .qs     (debug_invalid_creator_seed_qs)
2775:   );
2776: 
2777:   //   F[invalid_owner_seed]: 1:1
2778:   prim_subreg #(
2779:     .DW      (1),
2780:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2781:     .RESVAL  (1'h0),
2782:     .Mubi    (1'b0)
2783:   ) u_debug_invalid_owner_seed (
2784:     .clk_i   (clk_i),
2785:     .rst_ni  (rst_ni),
2786: 
2787:     // from register interface
2788:     .we     (debug_we),
2789:     .wd     (debug_invalid_owner_seed_wd),
2790: 
2791:     // from internal hardware
2792:     .de     (hw2reg.debug.invalid_owner_seed.de),
2793:     .d      (hw2reg.debug.invalid_owner_seed.d),
2794: 
2795:     // to internal hardware
2796:     .qe     (),
2797:     .q      (),
2798:     .ds     (),
2799: 
2800:     // to register interface (read)
2801:     .qs     (debug_invalid_owner_seed_qs)
2802:   );
2803: 
2804:   //   F[invalid_dev_id]: 2:2
2805:   prim_subreg #(
2806:     .DW      (1),
2807:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2808:     .RESVAL  (1'h0),
2809:     .Mubi    (1'b0)
2810:   ) u_debug_invalid_dev_id (
2811:     .clk_i   (clk_i),
2812:     .rst_ni  (rst_ni),
2813: 
2814:     // from register interface
2815:     .we     (debug_we),
2816:     .wd     (debug_invalid_dev_id_wd),
2817: 
2818:     // from internal hardware
2819:     .de     (hw2reg.debug.invalid_dev_id.de),
2820:     .d      (hw2reg.debug.invalid_dev_id.d),
2821: 
2822:     // to internal hardware
2823:     .qe     (),
2824:     .q      (),
2825:     .ds     (),
2826: 
2827:     // to register interface (read)
2828:     .qs     (debug_invalid_dev_id_qs)
2829:   );
2830: 
2831:   //   F[invalid_health_state]: 3:3
2832:   prim_subreg #(
2833:     .DW      (1),
2834:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2835:     .RESVAL  (1'h0),
2836:     .Mubi    (1'b0)
2837:   ) u_debug_invalid_health_state (
2838:     .clk_i   (clk_i),
2839:     .rst_ni  (rst_ni),
2840: 
2841:     // from register interface
2842:     .we     (debug_we),
2843:     .wd     (debug_invalid_health_state_wd),
2844: 
2845:     // from internal hardware
2846:     .de     (hw2reg.debug.invalid_health_state.de),
2847:     .d      (hw2reg.debug.invalid_health_state.d),
2848: 
2849:     // to internal hardware
2850:     .qe     (),
2851:     .q      (),
2852:     .ds     (),
2853: 
2854:     // to register interface (read)
2855:     .qs     (debug_invalid_health_state_qs)
2856:   );
2857: 
2858:   //   F[invalid_key_version]: 4:4
2859:   prim_subreg #(
2860:     .DW      (1),
2861:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2862:     .RESVAL  (1'h0),
2863:     .Mubi    (1'b0)
2864:   ) u_debug_invalid_key_version (
2865:     .clk_i   (clk_i),
2866:     .rst_ni  (rst_ni),
2867: 
2868:     // from register interface
2869:     .we     (debug_we),
2870:     .wd     (debug_invalid_key_version_wd),
2871: 
2872:     // from internal hardware
2873:     .de     (hw2reg.debug.invalid_key_version.de),
2874:     .d      (hw2reg.debug.invalid_key_version.d),
2875: 
2876:     // to internal hardware
2877:     .qe     (),
2878:     .q      (),
2879:     .ds     (),
2880: 
2881:     // to register interface (read)
2882:     .qs     (debug_invalid_key_version_qs)
2883:   );
2884: 
2885:   //   F[invalid_key]: 5:5
2886:   prim_subreg #(
2887:     .DW      (1),
2888:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2889:     .RESVAL  (1'h0),
2890:     .Mubi    (1'b0)
2891:   ) u_debug_invalid_key (
2892:     .clk_i   (clk_i),
2893:     .rst_ni  (rst_ni),
2894: 
2895:     // from register interface
2896:     .we     (debug_we),
2897:     .wd     (debug_invalid_key_wd),
2898: 
2899:     // from internal hardware
2900:     .de     (hw2reg.debug.invalid_key.de),
2901:     .d      (hw2reg.debug.invalid_key.d),
2902: 
2903:     // to internal hardware
2904:     .qe     (),
2905:     .q      (),
2906:     .ds     (),
2907: 
2908:     // to register interface (read)
2909:     .qs     (debug_invalid_key_qs)
2910:   );
2911: 
2912:   //   F[invalid_digest]: 6:6
2913:   prim_subreg #(
2914:     .DW      (1),
2915:     .SwAccess(prim_subreg_pkg::SwAccessW0C),
2916:     .RESVAL  (1'h0),
2917:     .Mubi    (1'b0)
2918:   ) u_debug_invalid_digest (
2919:     .clk_i   (clk_i),
2920:     .rst_ni  (rst_ni),
2921: 
2922:     // from register interface
2923:     .we     (debug_we),
2924:     .wd     (debug_invalid_digest_wd),
2925: 
2926:     // from internal hardware
2927:     .de     (hw2reg.debug.invalid_digest.de),
2928:     .d      (hw2reg.debug.invalid_digest.d),
2929: 
2930:     // to internal hardware
2931:     .qe     (),
2932:     .q      (),
2933:     .ds     (),
2934: 
2935:     // to register interface (read)
2936:     .qs     (debug_invalid_digest_qs)
2937:   );
2938: 
2939: 
2940: 
2941:   logic [62:0] addr_hit;
2942:   always_comb begin
2943:     addr_hit[ 0] = (reg_addr == KEYMGR_INTR_STATE_OFFSET);
2944:     addr_hit[ 1] = (reg_addr == KEYMGR_INTR_ENABLE_OFFSET);
2945:     addr_hit[ 2] = (reg_addr == KEYMGR_INTR_TEST_OFFSET);
2946:     addr_hit[ 3] = (reg_addr == KEYMGR_ALERT_TEST_OFFSET);
2947:     addr_hit[ 4] = (reg_addr == KEYMGR_CFG_REGWEN_OFFSET);
2948:     addr_hit[ 5] = (reg_addr == KEYMGR_START_OFFSET);
2949:     addr_hit[ 6] = (reg_addr == KEYMGR_CONTROL_SHADOWED_OFFSET);
2950:     addr_hit[ 7] = (reg_addr == KEYMGR_SIDELOAD_CLEAR_OFFSET);
2951:     addr_hit[ 8] = (reg_addr == KEYMGR_RESEED_INTERVAL_REGWEN_OFFSET);
2952:     addr_hit[ 9] = (reg_addr == KEYMGR_RESEED_INTERVAL_SHADOWED_OFFSET);
2953:     addr_hit[10] = (reg_addr == KEYMGR_SW_BINDING_REGWEN_OFFSET);
2954:     addr_hit[11] = (reg_addr == KEYMGR_SEALING_SW_BINDING_0_OFFSET);
2955:     addr_hit[12] = (reg_addr == KEYMGR_SEALING_SW_BINDING_1_OFFSET);
2956:     addr_hit[13] = (reg_addr == KEYMGR_SEALING_SW_BINDING_2_OFFSET);
2957:     addr_hit[14] = (reg_addr == KEYMGR_SEALING_SW_BINDING_3_OFFSET);
2958:     addr_hit[15] = (reg_addr == KEYMGR_SEALING_SW_BINDING_4_OFFSET);
2959:     addr_hit[16] = (reg_addr == KEYMGR_SEALING_SW_BINDING_5_OFFSET);
2960:     addr_hit[17] = (reg_addr == KEYMGR_SEALING_SW_BINDING_6_OFFSET);
2961:     addr_hit[18] = (reg_addr == KEYMGR_SEALING_SW_BINDING_7_OFFSET);
2962:     addr_hit[19] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_0_OFFSET);
2963:     addr_hit[20] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_1_OFFSET);
2964:     addr_hit[21] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_2_OFFSET);
2965:     addr_hit[22] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_3_OFFSET);
2966:     addr_hit[23] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_4_OFFSET);
2967:     addr_hit[24] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_5_OFFSET);
2968:     addr_hit[25] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_6_OFFSET);
2969:     addr_hit[26] = (reg_addr == KEYMGR_ATTEST_SW_BINDING_7_OFFSET);
2970:     addr_hit[27] = (reg_addr == KEYMGR_SALT_0_OFFSET);
2971:     addr_hit[28] = (reg_addr == KEYMGR_SALT_1_OFFSET);
2972:     addr_hit[29] = (reg_addr == KEYMGR_SALT_2_OFFSET);
2973:     addr_hit[30] = (reg_addr == KEYMGR_SALT_3_OFFSET);
2974:     addr_hit[31] = (reg_addr == KEYMGR_SALT_4_OFFSET);
2975:     addr_hit[32] = (reg_addr == KEYMGR_SALT_5_OFFSET);
2976:     addr_hit[33] = (reg_addr == KEYMGR_SALT_6_OFFSET);
2977:     addr_hit[34] = (reg_addr == KEYMGR_SALT_7_OFFSET);
2978:     addr_hit[35] = (reg_addr == KEYMGR_KEY_VERSION_OFFSET);
2979:     addr_hit[36] = (reg_addr == KEYMGR_MAX_CREATOR_KEY_VER_REGWEN_OFFSET);
2980:     addr_hit[37] = (reg_addr == KEYMGR_MAX_CREATOR_KEY_VER_SHADOWED_OFFSET);
2981:     addr_hit[38] = (reg_addr == KEYMGR_MAX_OWNER_INT_KEY_VER_REGWEN_OFFSET);
2982:     addr_hit[39] = (reg_addr == KEYMGR_MAX_OWNER_INT_KEY_VER_SHADOWED_OFFSET);
2983:     addr_hit[40] = (reg_addr == KEYMGR_MAX_OWNER_KEY_VER_REGWEN_OFFSET);
2984:     addr_hit[41] = (reg_addr == KEYMGR_MAX_OWNER_KEY_VER_SHADOWED_OFFSET);
2985:     addr_hit[42] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_0_OFFSET);
2986:     addr_hit[43] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_1_OFFSET);
2987:     addr_hit[44] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_2_OFFSET);
2988:     addr_hit[45] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_3_OFFSET);
2989:     addr_hit[46] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_4_OFFSET);
2990:     addr_hit[47] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_5_OFFSET);
2991:     addr_hit[48] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_6_OFFSET);
2992:     addr_hit[49] = (reg_addr == KEYMGR_SW_SHARE0_OUTPUT_7_OFFSET);
2993:     addr_hit[50] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_0_OFFSET);
2994:     addr_hit[51] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_1_OFFSET);
2995:     addr_hit[52] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_2_OFFSET);
2996:     addr_hit[53] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_3_OFFSET);
2997:     addr_hit[54] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_4_OFFSET);
2998:     addr_hit[55] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_5_OFFSET);
2999:     addr_hit[56] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_6_OFFSET);
3000:     addr_hit[57] = (reg_addr == KEYMGR_SW_SHARE1_OUTPUT_7_OFFSET);
3001:     addr_hit[58] = (reg_addr == KEYMGR_WORKING_STATE_OFFSET);
3002:     addr_hit[59] = (reg_addr == KEYMGR_OP_STATUS_OFFSET);
3003:     addr_hit[60] = (reg_addr == KEYMGR_ERR_CODE_OFFSET);
3004:     addr_hit[61] = (reg_addr == KEYMGR_FAULT_STATUS_OFFSET);
3005:     addr_hit[62] = (reg_addr == KEYMGR_DEBUG_OFFSET);
3006:   end
3007: 
3008:   assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;
3009: 
3010:   // Check sub-word write is permitted
3011:   always_comb begin
3012:     wr_err = (reg_we &
3013:               ((addr_hit[ 0] & (|(KEYMGR_PERMIT[ 0] & ~reg_be))) |
3014:                (addr_hit[ 1] & (|(KEYMGR_PERMIT[ 1] & ~reg_be))) |
3015:                (addr_hit[ 2] & (|(KEYMGR_PERMIT[ 2] & ~reg_be))) |
3016:                (addr_hit[ 3] & (|(KEYMGR_PERMIT[ 3] & ~reg_be))) |
3017:                (addr_hit[ 4] & (|(KEYMGR_PERMIT[ 4] & ~reg_be))) |
3018:                (addr_hit[ 5] & (|(KEYMGR_PERMIT[ 5] & ~reg_be))) |
3019:                (addr_hit[ 6] & (|(KEYMGR_PERMIT[ 6] & ~reg_be))) |
3020:                (addr_hit[ 7] & (|(KEYMGR_PERMIT[ 7] & ~reg_be))) |
3021:                (addr_hit[ 8] & (|(KEYMGR_PERMIT[ 8] & ~reg_be))) |
3022:                (addr_hit[ 9] & (|(KEYMGR_PERMIT[ 9] & ~reg_be))) |
3023:                (addr_hit[10] & (|(KEYMGR_PERMIT[10] & ~reg_be))) |
3024:                (addr_hit[11] & (|(KEYMGR_PERMIT[11] & ~reg_be))) |
3025:                (addr_hit[12] & (|(KEYMGR_PERMIT[12] & ~reg_be))) |
3026:                (addr_hit[13] & (|(KEYMGR_PERMIT[13] & ~reg_be))) |
3027:                (addr_hit[14] & (|(KEYMGR_PERMIT[14] & ~reg_be))) |
3028:                (addr_hit[15] & (|(KEYMGR_PERMIT[15] & ~reg_be))) |
3029:                (addr_hit[16] & (|(KEYMGR_PERMIT[16] & ~reg_be))) |
3030:                (addr_hit[17] & (|(KEYMGR_PERMIT[17] & ~reg_be))) |
3031:                (addr_hit[18] & (|(KEYMGR_PERMIT[18] & ~reg_be))) |
3032:                (addr_hit[19] & (|(KEYMGR_PERMIT[19] & ~reg_be))) |
3033:                (addr_hit[20] & (|(KEYMGR_PERMIT[20] & ~reg_be))) |
3034:                (addr_hit[21] & (|(KEYMGR_PERMIT[21] & ~reg_be))) |
3035:                (addr_hit[22] & (|(KEYMGR_PERMIT[22] & ~reg_be))) |
3036:                (addr_hit[23] & (|(KEYMGR_PERMIT[23] & ~reg_be))) |
3037:                (addr_hit[24] & (|(KEYMGR_PERMIT[24] & ~reg_be))) |
3038:                (addr_hit[25] & (|(KEYMGR_PERMIT[25] & ~reg_be))) |
3039:                (addr_hit[26] & (|(KEYMGR_PERMIT[26] & ~reg_be))) |
3040:                (addr_hit[27] & (|(KEYMGR_PERMIT[27] & ~reg_be))) |
3041:                (addr_hit[28] & (|(KEYMGR_PERMIT[28] & ~reg_be))) |
3042:                (addr_hit[29] & (|(KEYMGR_PERMIT[29] & ~reg_be))) |
3043:                (addr_hit[30] & (|(KEYMGR_PERMIT[30] & ~reg_be))) |
3044:                (addr_hit[31] & (|(KEYMGR_PERMIT[31] & ~reg_be))) |
3045:                (addr_hit[32] & (|(KEYMGR_PERMIT[32] & ~reg_be))) |
3046:                (addr_hit[33] & (|(KEYMGR_PERMIT[33] & ~reg_be))) |
3047:                (addr_hit[34] & (|(KEYMGR_PERMIT[34] & ~reg_be))) |
3048:                (addr_hit[35] & (|(KEYMGR_PERMIT[35] & ~reg_be))) |
3049:                (addr_hit[36] & (|(KEYMGR_PERMIT[36] & ~reg_be))) |
3050:                (addr_hit[37] & (|(KEYMGR_PERMIT[37] & ~reg_be))) |
3051:                (addr_hit[38] & (|(KEYMGR_PERMIT[38] & ~reg_be))) |
3052:                (addr_hit[39] & (|(KEYMGR_PERMIT[39] & ~reg_be))) |
3053:                (addr_hit[40] & (|(KEYMGR_PERMIT[40] & ~reg_be))) |
3054:                (addr_hit[41] & (|(KEYMGR_PERMIT[41] & ~reg_be))) |
3055:                (addr_hit[42] & (|(KEYMGR_PERMIT[42] & ~reg_be))) |
3056:                (addr_hit[43] & (|(KEYMGR_PERMIT[43] & ~reg_be))) |
3057:                (addr_hit[44] & (|(KEYMGR_PERMIT[44] & ~reg_be))) |
3058:                (addr_hit[45] & (|(KEYMGR_PERMIT[45] & ~reg_be))) |
3059:                (addr_hit[46] & (|(KEYMGR_PERMIT[46] & ~reg_be))) |
3060:                (addr_hit[47] & (|(KEYMGR_PERMIT[47] & ~reg_be))) |
3061:                (addr_hit[48] & (|(KEYMGR_PERMIT[48] & ~reg_be))) |
3062:                (addr_hit[49] & (|(KEYMGR_PERMIT[49] & ~reg_be))) |
3063:                (addr_hit[50] & (|(KEYMGR_PERMIT[50] & ~reg_be))) |
3064:                (addr_hit[51] & (|(KEYMGR_PERMIT[51] & ~reg_be))) |
3065:                (addr_hit[52] & (|(KEYMGR_PERMIT[52] & ~reg_be))) |
3066:                (addr_hit[53] & (|(KEYMGR_PERMIT[53] & ~reg_be))) |
3067:                (addr_hit[54] & (|(KEYMGR_PERMIT[54] & ~reg_be))) |
3068:                (addr_hit[55] & (|(KEYMGR_PERMIT[55] & ~reg_be))) |
3069:                (addr_hit[56] & (|(KEYMGR_PERMIT[56] & ~reg_be))) |
3070:                (addr_hit[57] & (|(KEYMGR_PERMIT[57] & ~reg_be))) |
3071:                (addr_hit[58] & (|(KEYMGR_PERMIT[58] & ~reg_be))) |
3072:                (addr_hit[59] & (|(KEYMGR_PERMIT[59] & ~reg_be))) |
3073:                (addr_hit[60] & (|(KEYMGR_PERMIT[60] & ~reg_be))) |
3074:                (addr_hit[61] & (|(KEYMGR_PERMIT[61] & ~reg_be))) |
3075:                (addr_hit[62] & (|(KEYMGR_PERMIT[62] & ~reg_be)))));
3076:   end
3077: 
3078:   // Generate write-enables
3079:   assign intr_state_we = addr_hit[0] & reg_we & !reg_error;
3080: 
3081:   assign intr_state_wd = reg_wdata[0];
3082:   assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;
3083: 
3084:   assign intr_enable_wd = reg_wdata[0];
3085:   assign intr_test_we = addr_hit[2] & reg_we & !reg_error;
3086: 
3087:   assign intr_test_wd = reg_wdata[0];
3088:   assign alert_test_we = addr_hit[3] & reg_we & !reg_error;
3089: 
3090:   assign alert_test_recov_operation_err_wd = reg_wdata[0];
3091: 
3092:   assign alert_test_fatal_fault_err_wd = reg_wdata[1];
3093:   assign cfg_regwen_re = addr_hit[4] & reg_re & !reg_error;
3094:   assign start_we = addr_hit[5] & reg_we & !reg_error;
3095: 
3096:   assign start_wd = reg_wdata[0];
3097:   assign control_shadowed_re = addr_hit[6] & reg_re & !reg_error;
3098:   assign control_shadowed_we = addr_hit[6] & reg_we & !reg_error;
3099: 
3100:   assign control_shadowed_operation_wd = reg_wdata[6:4];
3101: 
3102:   assign control_shadowed_cdi_sel_wd = reg_wdata[7];
3103: 
3104:   assign control_shadowed_dest_sel_wd = reg_wdata[13:12];
3105:   assign sideload_clear_we = addr_hit[7] & reg_we & !reg_error;
3106: 
3107:   assign sideload_clear_wd = reg_wdata[2:0];
3108:   assign reseed_interval_regwen_we = addr_hit[8] & reg_we & !reg_error;
3109: 
3110:   assign reseed_interval_regwen_wd = reg_wdata[0];
3111:   assign reseed_interval_shadowed_re = addr_hit[9] & reg_re & !reg_error;
3112:   assign reseed_interval_shadowed_we = addr_hit[9] & reg_we & !reg_error;
3113: 
3114:   assign reseed_interval_shadowed_wd = reg_wdata[15:0];
3115:   assign sw_binding_regwen_re = addr_hit[10] & reg_re & !reg_error;
3116:   assign sw_binding_regwen_we = addr_hit[10] & reg_we & !reg_error;
3117: 
3118:   assign sw_binding_regwen_wd = reg_wdata[0];
3119:   assign sealing_sw_binding_0_we = addr_hit[11] & reg_we & !reg_error;
3120: 
3121:   assign sealing_sw_binding_0_wd = reg_wdata[31:0];
3122:   assign sealing_sw_binding_1_we = addr_hit[12] & reg_we & !reg_error;
3123: 
3124:   assign sealing_sw_binding_1_wd = reg_wdata[31:0];
3125:   assign sealing_sw_binding_2_we = addr_hit[13] & reg_we & !reg_error;
3126: 
3127:   assign sealing_sw_binding_2_wd = reg_wdata[31:0];
3128:   assign sealing_sw_binding_3_we = addr_hit[14] & reg_we & !reg_error;
3129: 
3130:   assign sealing_sw_binding_3_wd = reg_wdata[31:0];
3131:   assign sealing_sw_binding_4_we = addr_hit[15] & reg_we & !reg_error;
3132: 
3133:   assign sealing_sw_binding_4_wd = reg_wdata[31:0];
3134:   assign sealing_sw_binding_5_we = addr_hit[16] & reg_we & !reg_error;
3135: 
3136:   assign sealing_sw_binding_5_wd = reg_wdata[31:0];
3137:   assign sealing_sw_binding_6_we = addr_hit[17] & reg_we & !reg_error;
3138: 
3139:   assign sealing_sw_binding_6_wd = reg_wdata[31:0];
3140:   assign sealing_sw_binding_7_we = addr_hit[18] & reg_we & !reg_error;
3141: 
3142:   assign sealing_sw_binding_7_wd = reg_wdata[31:0];
3143:   assign attest_sw_binding_0_we = addr_hit[19] & reg_we & !reg_error;
3144: 
3145:   assign attest_sw_binding_0_wd = reg_wdata[31:0];
3146:   assign attest_sw_binding_1_we = addr_hit[20] & reg_we & !reg_error;
3147: 
3148:   assign attest_sw_binding_1_wd = reg_wdata[31:0];
3149:   assign attest_sw_binding_2_we = addr_hit[21] & reg_we & !reg_error;
3150: 
3151:   assign attest_sw_binding_2_wd = reg_wdata[31:0];
3152:   assign attest_sw_binding_3_we = addr_hit[22] & reg_we & !reg_error;
3153: 
3154:   assign attest_sw_binding_3_wd = reg_wdata[31:0];
3155:   assign attest_sw_binding_4_we = addr_hit[23] & reg_we & !reg_error;
3156: 
3157:   assign attest_sw_binding_4_wd = reg_wdata[31:0];
3158:   assign attest_sw_binding_5_we = addr_hit[24] & reg_we & !reg_error;
3159: 
3160:   assign attest_sw_binding_5_wd = reg_wdata[31:0];
3161:   assign attest_sw_binding_6_we = addr_hit[25] & reg_we & !reg_error;
3162: 
3163:   assign attest_sw_binding_6_wd = reg_wdata[31:0];
3164:   assign attest_sw_binding_7_we = addr_hit[26] & reg_we & !reg_error;
3165: 
3166:   assign attest_sw_binding_7_wd = reg_wdata[31:0];
3167:   assign salt_0_we = addr_hit[27] & reg_we & !reg_error;
3168: 
3169:   assign salt_0_wd = reg_wdata[31:0];
3170:   assign salt_1_we = addr_hit[28] & reg_we & !reg_error;
3171: 
3172:   assign salt_1_wd = reg_wdata[31:0];
3173:   assign salt_2_we = addr_hit[29] & reg_we & !reg_error;
3174: 
3175:   assign salt_2_wd = reg_wdata[31:0];
3176:   assign salt_3_we = addr_hit[30] & reg_we & !reg_error;
3177: 
3178:   assign salt_3_wd = reg_wdata[31:0];
3179:   assign salt_4_we = addr_hit[31] & reg_we & !reg_error;
3180: 
3181:   assign salt_4_wd = reg_wdata[31:0];
3182:   assign salt_5_we = addr_hit[32] & reg_we & !reg_error;
3183: 
3184:   assign salt_5_wd = reg_wdata[31:0];
3185:   assign salt_6_we = addr_hit[33] & reg_we & !reg_error;
3186: 
3187:   assign salt_6_wd = reg_wdata[31:0];
3188:   assign salt_7_we = addr_hit[34] & reg_we & !reg_error;
3189: 
3190:   assign salt_7_wd = reg_wdata[31:0];
3191:   assign key_version_we = addr_hit[35] & reg_we & !reg_error;
3192: 
3193:   assign key_version_wd = reg_wdata[31:0];
3194:   assign max_creator_key_ver_regwen_we = addr_hit[36] & reg_we & !reg_error;
3195: 
3196:   assign max_creator_key_ver_regwen_wd = reg_wdata[0];
3197:   assign max_creator_key_ver_shadowed_re = addr_hit[37] & reg_re & !reg_error;
3198:   assign max_creator_key_ver_shadowed_we = addr_hit[37] & reg_we & !reg_error;
3199: 
3200:   assign max_creator_key_ver_shadowed_wd = reg_wdata[31:0];
3201:   assign max_owner_int_key_ver_regwen_we = addr_hit[38] & reg_we & !reg_error;
3202: 
3203:   assign max_owner_int_key_ver_regwen_wd = reg_wdata[0];
3204:   assign max_owner_int_key_ver_shadowed_re = addr_hit[39] & reg_re & !reg_error;
3205:   assign max_owner_int_key_ver_shadowed_we = addr_hit[39] & reg_we & !reg_error;
3206: 
3207:   assign max_owner_int_key_ver_shadowed_wd = reg_wdata[31:0];
3208:   assign max_owner_key_ver_regwen_we = addr_hit[40] & reg_we & !reg_error;
3209: 
3210:   assign max_owner_key_ver_regwen_wd = reg_wdata[0];
3211:   assign max_owner_key_ver_shadowed_re = addr_hit[41] & reg_re & !reg_error;
3212:   assign max_owner_key_ver_shadowed_we = addr_hit[41] & reg_we & !reg_error;
3213: 
3214:   assign max_owner_key_ver_shadowed_wd = reg_wdata[31:0];
3215:   assign sw_share0_output_0_re = addr_hit[42] & reg_re & !reg_error;
3216: 
3217:   assign sw_share0_output_0_wd = '1;
3218:   assign sw_share0_output_1_re = addr_hit[43] & reg_re & !reg_error;
3219: 
3220:   assign sw_share0_output_1_wd = '1;
3221:   assign sw_share0_output_2_re = addr_hit[44] & reg_re & !reg_error;
3222: 
3223:   assign sw_share0_output_2_wd = '1;
3224:   assign sw_share0_output_3_re = addr_hit[45] & reg_re & !reg_error;
3225: 
3226:   assign sw_share0_output_3_wd = '1;
3227:   assign sw_share0_output_4_re = addr_hit[46] & reg_re & !reg_error;
3228: 
3229:   assign sw_share0_output_4_wd = '1;
3230:   assign sw_share0_output_5_re = addr_hit[47] & reg_re & !reg_error;
3231: 
3232:   assign sw_share0_output_5_wd = '1;
3233:   assign sw_share0_output_6_re = addr_hit[48] & reg_re & !reg_error;
3234: 
3235:   assign sw_share0_output_6_wd = '1;
3236:   assign sw_share0_output_7_re = addr_hit[49] & reg_re & !reg_error;
3237: 
3238:   assign sw_share0_output_7_wd = '1;
3239:   assign sw_share1_output_0_re = addr_hit[50] & reg_re & !reg_error;
3240: 
3241:   assign sw_share1_output_0_wd = '1;
3242:   assign sw_share1_output_1_re = addr_hit[51] & reg_re & !reg_error;
3243: 
3244:   assign sw_share1_output_1_wd = '1;
3245:   assign sw_share1_output_2_re = addr_hit[52] & reg_re & !reg_error;
3246: 
3247:   assign sw_share1_output_2_wd = '1;
3248:   assign sw_share1_output_3_re = addr_hit[53] & reg_re & !reg_error;
3249: 
3250:   assign sw_share1_output_3_wd = '1;
3251:   assign sw_share1_output_4_re = addr_hit[54] & reg_re & !reg_error;
3252: 
3253:   assign sw_share1_output_4_wd = '1;
3254:   assign sw_share1_output_5_re = addr_hit[55] & reg_re & !reg_error;
3255: 
3256:   assign sw_share1_output_5_wd = '1;
3257:   assign sw_share1_output_6_re = addr_hit[56] & reg_re & !reg_error;
3258: 
3259:   assign sw_share1_output_6_wd = '1;
3260:   assign sw_share1_output_7_re = addr_hit[57] & reg_re & !reg_error;
3261: 
3262:   assign sw_share1_output_7_wd = '1;
3263:   assign op_status_we = addr_hit[59] & reg_we & !reg_error;
3264: 
3265:   assign op_status_wd = reg_wdata[1:0];
3266:   assign err_code_we = addr_hit[60] & reg_we & !reg_error;
3267: 
3268:   assign err_code_invalid_op_wd = reg_wdata[0];
3269: 
3270:   assign err_code_invalid_kmac_input_wd = reg_wdata[1];
3271: 
3272:   assign err_code_invalid_shadow_update_wd = reg_wdata[2];
3273:   assign debug_we = addr_hit[62] & reg_we & !reg_error;
3274: 
3275:   assign debug_invalid_creator_seed_wd = reg_wdata[0];
3276: 
3277:   assign debug_invalid_owner_seed_wd = reg_wdata[1];
3278: 
3279:   assign debug_invalid_dev_id_wd = reg_wdata[2];
3280: 
3281:   assign debug_invalid_health_state_wd = reg_wdata[3];
3282: 
3283:   assign debug_invalid_key_version_wd = reg_wdata[4];
3284: 
3285:   assign debug_invalid_key_wd = reg_wdata[5];
3286: 
3287:   assign debug_invalid_digest_wd = reg_wdata[6];
3288: 
3289:   // Assign write-enables to checker logic vector.
3290:   always_comb begin
3291:     reg_we_check[0] = intr_state_we;
3292:     reg_we_check[1] = intr_enable_we;
3293:     reg_we_check[2] = intr_test_we;
3294:     reg_we_check[3] = alert_test_we;
3295:     reg_we_check[4] = 1'b0;
3296:     reg_we_check[5] = start_gated_we;
3297:     reg_we_check[6] = control_shadowed_gated_we;
3298:     reg_we_check[7] = sideload_clear_gated_we;
3299:     reg_we_check[8] = reseed_interval_regwen_we;
3300:     reg_we_check[9] = reseed_interval_shadowed_gated_we;
3301:     reg_we_check[10] = sw_binding_regwen_we;
3302:     reg_we_check[11] = sealing_sw_binding_0_gated_we;
3303:     reg_we_check[12] = sealing_sw_binding_1_gated_we;
3304:     reg_we_check[13] = sealing_sw_binding_2_gated_we;
3305:     reg_we_check[14] = sealing_sw_binding_3_gated_we;
3306:     reg_we_check[15] = sealing_sw_binding_4_gated_we;
3307:     reg_we_check[16] = sealing_sw_binding_5_gated_we;
3308:     reg_we_check[17] = sealing_sw_binding_6_gated_we;
3309:     reg_we_check[18] = sealing_sw_binding_7_gated_we;
3310:     reg_we_check[19] = attest_sw_binding_0_gated_we;
3311:     reg_we_check[20] = attest_sw_binding_1_gated_we;
3312:     reg_we_check[21] = attest_sw_binding_2_gated_we;
3313:     reg_we_check[22] = attest_sw_binding_3_gated_we;
3314:     reg_we_check[23] = attest_sw_binding_4_gated_we;
3315:     reg_we_check[24] = attest_sw_binding_5_gated_we;
3316:     reg_we_check[25] = attest_sw_binding_6_gated_we;
3317:     reg_we_check[26] = attest_sw_binding_7_gated_we;
3318:     reg_we_check[27] = salt_0_gated_we;
3319:     reg_we_check[28] = salt_1_gated_we;
3320:     reg_we_check[29] = salt_2_gated_we;
3321:     reg_we_check[30] = salt_3_gated_we;
3322:     reg_we_check[31] = salt_4_gated_we;
3323:     reg_we_check[32] = salt_5_gated_we;
3324:     reg_we_check[33] = salt_6_gated_we;
3325:     reg_we_check[34] = salt_7_gated_we;
3326:     reg_we_check[35] = key_version_gated_we;
3327:     reg_we_check[36] = max_creator_key_ver_regwen_we;
3328:     reg_we_check[37] = max_creator_key_ver_shadowed_gated_we;
3329:     reg_we_check[38] = max_owner_int_key_ver_regwen_we;
3330:     reg_we_check[39] = max_owner_int_key_ver_shadowed_gated_we;
3331:     reg_we_check[40] = max_owner_key_ver_regwen_we;
3332:     reg_we_check[41] = max_owner_key_ver_shadowed_gated_we;
3333:     reg_we_check[42] = 1'b0;
3334:     reg_we_check[43] = 1'b0;
3335:     reg_we_check[44] = 1'b0;
3336:     reg_we_check[45] = 1'b0;
3337:     reg_we_check[46] = 1'b0;
3338:     reg_we_check[47] = 1'b0;
3339:     reg_we_check[48] = 1'b0;
3340:     reg_we_check[49] = 1'b0;
3341:     reg_we_check[50] = 1'b0;
3342:     reg_we_check[51] = 1'b0;
3343:     reg_we_check[52] = 1'b0;
3344:     reg_we_check[53] = 1'b0;
3345:     reg_we_check[54] = 1'b0;
3346:     reg_we_check[55] = 1'b0;
3347:     reg_we_check[56] = 1'b0;
3348:     reg_we_check[57] = 1'b0;
3349:     reg_we_check[58] = 1'b0;
3350:     reg_we_check[59] = op_status_we;
3351:     reg_we_check[60] = err_code_we;
3352:     reg_we_check[61] = 1'b0;
3353:     reg_we_check[62] = debug_we;
3354:   end
3355: 
3356:   // Read data return
3357:   always_comb begin
3358:     reg_rdata_next = '0;
3359:     unique case (1'b1)
3360:       addr_hit[0]: begin
3361:         reg_rdata_next[0] = intr_state_qs;
3362:       end
3363: 
3364:       addr_hit[1]: begin
3365:         reg_rdata_next[0] = intr_enable_qs;
3366:       end
3367: 
3368:       addr_hit[2]: begin
3369:         reg_rdata_next[0] = '0;
3370:       end
3371: 
3372:       addr_hit[3]: begin
3373:         reg_rdata_next[0] = '0;
3374:         reg_rdata_next[1] = '0;
3375:       end
3376: 
3377:       addr_hit[4]: begin
3378:         reg_rdata_next[0] = cfg_regwen_qs;
3379:       end
3380: 
3381:       addr_hit[5]: begin
3382:         reg_rdata_next[0] = start_qs;
3383:       end
3384: 
3385:       addr_hit[6]: begin
3386:         reg_rdata_next[6:4] = control_shadowed_operation_qs;
3387:         reg_rdata_next[7] = control_shadowed_cdi_sel_qs;
3388:         reg_rdata_next[13:12] = control_shadowed_dest_sel_qs;
3389:       end
3390: 
3391:       addr_hit[7]: begin
3392:         reg_rdata_next[2:0] = sideload_clear_qs;
3393:       end
3394: 
3395:       addr_hit[8]: begin
3396:         reg_rdata_next[0] = reseed_interval_regwen_qs;
3397:       end
3398: 
3399:       addr_hit[9]: begin
3400:         reg_rdata_next[15:0] = reseed_interval_shadowed_qs;
3401:       end
3402: 
3403:       addr_hit[10]: begin
3404:         reg_rdata_next[0] = sw_binding_regwen_qs;
3405:       end
3406: 
3407:       addr_hit[11]: begin
3408:         reg_rdata_next[31:0] = sealing_sw_binding_0_qs;
3409:       end
3410: 
3411:       addr_hit[12]: begin
3412:         reg_rdata_next[31:0] = sealing_sw_binding_1_qs;
3413:       end
3414: 
3415:       addr_hit[13]: begin
3416:         reg_rdata_next[31:0] = sealing_sw_binding_2_qs;
3417:       end
3418: 
3419:       addr_hit[14]: begin
3420:         reg_rdata_next[31:0] = sealing_sw_binding_3_qs;
3421:       end
3422: 
3423:       addr_hit[15]: begin
3424:         reg_rdata_next[31:0] = sealing_sw_binding_4_qs;
3425:       end
3426: 
3427:       addr_hit[16]: begin
3428:         reg_rdata_next[31:0] = sealing_sw_binding_5_qs;
3429:       end
3430: 
3431:       addr_hit[17]: begin
3432:         reg_rdata_next[31:0] = sealing_sw_binding_6_qs;
3433:       end
3434: 
3435:       addr_hit[18]: begin
3436:         reg_rdata_next[31:0] = sealing_sw_binding_7_qs;
3437:       end
3438: 
3439:       addr_hit[19]: begin
3440:         reg_rdata_next[31:0] = attest_sw_binding_0_qs;
3441:       end
3442: 
3443:       addr_hit[20]: begin
3444:         reg_rdata_next[31:0] = attest_sw_binding_1_qs;
3445:       end
3446: 
3447:       addr_hit[21]: begin
3448:         reg_rdata_next[31:0] = attest_sw_binding_2_qs;
3449:       end
3450: 
3451:       addr_hit[22]: begin
3452:         reg_rdata_next[31:0] = attest_sw_binding_3_qs;
3453:       end
3454: 
3455:       addr_hit[23]: begin
3456:         reg_rdata_next[31:0] = attest_sw_binding_4_qs;
3457:       end
3458: 
3459:       addr_hit[24]: begin
3460:         reg_rdata_next[31:0] = attest_sw_binding_5_qs;
3461:       end
3462: 
3463:       addr_hit[25]: begin
3464:         reg_rdata_next[31:0] = attest_sw_binding_6_qs;
3465:       end
3466: 
3467:       addr_hit[26]: begin
3468:         reg_rdata_next[31:0] = attest_sw_binding_7_qs;
3469:       end
3470: 
3471:       addr_hit[27]: begin
3472:         reg_rdata_next[31:0] = salt_0_qs;
3473:       end
3474: 
3475:       addr_hit[28]: begin
3476:         reg_rdata_next[31:0] = salt_1_qs;
3477:       end
3478: 
3479:       addr_hit[29]: begin
3480:         reg_rdata_next[31:0] = salt_2_qs;
3481:       end
3482: 
3483:       addr_hit[30]: begin
3484:         reg_rdata_next[31:0] = salt_3_qs;
3485:       end
3486: 
3487:       addr_hit[31]: begin
3488:         reg_rdata_next[31:0] = salt_4_qs;
3489:       end
3490: 
3491:       addr_hit[32]: begin
3492:         reg_rdata_next[31:0] = salt_5_qs;
3493:       end
3494: 
3495:       addr_hit[33]: begin
3496:         reg_rdata_next[31:0] = salt_6_qs;
3497:       end
3498: 
3499:       addr_hit[34]: begin
3500:         reg_rdata_next[31:0] = salt_7_qs;
3501:       end
3502: 
3503:       addr_hit[35]: begin
3504:         reg_rdata_next[31:0] = key_version_qs;
3505:       end
3506: 
3507:       addr_hit[36]: begin
3508:         reg_rdata_next[0] = max_creator_key_ver_regwen_qs;
3509:       end
3510: 
3511:       addr_hit[37]: begin
3512:         reg_rdata_next[31:0] = max_creator_key_ver_shadowed_qs;
3513:       end
3514: 
3515:       addr_hit[38]: begin
3516:         reg_rdata_next[0] = max_owner_int_key_ver_regwen_qs;
3517:       end
3518: 
3519:       addr_hit[39]: begin
3520:         reg_rdata_next[31:0] = max_owner_int_key_ver_shadowed_qs;
3521:       end
3522: 
3523:       addr_hit[40]: begin
3524:         reg_rdata_next[0] = max_owner_key_ver_regwen_qs;
3525:       end
3526: 
3527:       addr_hit[41]: begin
3528:         reg_rdata_next[31:0] = max_owner_key_ver_shadowed_qs;
3529:       end
3530: 
3531:       addr_hit[42]: begin
3532:         reg_rdata_next[31:0] = sw_share0_output_0_qs;
3533:       end
3534: 
3535:       addr_hit[43]: begin
3536:         reg_rdata_next[31:0] = sw_share0_output_1_qs;
3537:       end
3538: 
3539:       addr_hit[44]: begin
3540:         reg_rdata_next[31:0] = sw_share0_output_2_qs;
3541:       end
3542: 
3543:       addr_hit[45]: begin
3544:         reg_rdata_next[31:0] = sw_share0_output_3_qs;
3545:       end
3546: 
3547:       addr_hit[46]: begin
3548:         reg_rdata_next[31:0] = sw_share0_output_4_qs;
3549:       end
3550: 
3551:       addr_hit[47]: begin
3552:         reg_rdata_next[31:0] = sw_share0_output_5_qs;
3553:       end
3554: 
3555:       addr_hit[48]: begin
3556:         reg_rdata_next[31:0] = sw_share0_output_6_qs;
3557:       end
3558: 
3559:       addr_hit[49]: begin
3560:         reg_rdata_next[31:0] = sw_share0_output_7_qs;
3561:       end
3562: 
3563:       addr_hit[50]: begin
3564:         reg_rdata_next[31:0] = sw_share1_output_0_qs;
3565:       end
3566: 
3567:       addr_hit[51]: begin
3568:         reg_rdata_next[31:0] = sw_share1_output_1_qs;
3569:       end
3570: 
3571:       addr_hit[52]: begin
3572:         reg_rdata_next[31:0] = sw_share1_output_2_qs;
3573:       end
3574: 
3575:       addr_hit[53]: begin
3576:         reg_rdata_next[31:0] = sw_share1_output_3_qs;
3577:       end
3578: 
3579:       addr_hit[54]: begin
3580:         reg_rdata_next[31:0] = sw_share1_output_4_qs;
3581:       end
3582: 
3583:       addr_hit[55]: begin
3584:         reg_rdata_next[31:0] = sw_share1_output_5_qs;
3585:       end
3586: 
3587:       addr_hit[56]: begin
3588:         reg_rdata_next[31:0] = sw_share1_output_6_qs;
3589:       end
3590: 
3591:       addr_hit[57]: begin
3592:         reg_rdata_next[31:0] = sw_share1_output_7_qs;
3593:       end
3594: 
3595:       addr_hit[58]: begin
3596:         reg_rdata_next[2:0] = working_state_qs;
3597:       end
3598: 
3599:       addr_hit[59]: begin
3600:         reg_rdata_next[1:0] = op_status_qs;
3601:       end
3602: 
3603:       addr_hit[60]: begin
3604:         reg_rdata_next[0] = err_code_invalid_op_qs;
3605:         reg_rdata_next[1] = err_code_invalid_kmac_input_qs;
3606:         reg_rdata_next[2] = err_code_invalid_shadow_update_qs;
3607:       end
3608: 
3609:       addr_hit[61]: begin
3610:         reg_rdata_next[0] = fault_status_cmd_qs;
3611:         reg_rdata_next[1] = fault_status_kmac_fsm_qs;
3612:         reg_rdata_next[2] = fault_status_kmac_done_qs;
3613:         reg_rdata_next[3] = fault_status_kmac_op_qs;
3614:         reg_rdata_next[4] = fault_status_kmac_out_qs;
3615:         reg_rdata_next[5] = fault_status_regfile_intg_qs;
3616:         reg_rdata_next[6] = fault_status_shadow_qs;
3617:         reg_rdata_next[7] = fault_status_ctrl_fsm_intg_qs;
3618:         reg_rdata_next[8] = fault_status_ctrl_fsm_chk_qs;
3619:         reg_rdata_next[9] = fault_status_ctrl_fsm_cnt_qs;
3620:         reg_rdata_next[10] = fault_status_reseed_cnt_qs;
3621:         reg_rdata_next[11] = fault_status_side_ctrl_fsm_qs;
3622:         reg_rdata_next[12] = fault_status_side_ctrl_sel_qs;
3623:         reg_rdata_next[13] = fault_status_key_ecc_qs;
3624:       end
3625: 
3626:       addr_hit[62]: begin
3627:         reg_rdata_next[0] = debug_invalid_creator_seed_qs;
3628:         reg_rdata_next[1] = debug_invalid_owner_seed_qs;
3629:         reg_rdata_next[2] = debug_invalid_dev_id_qs;
3630:         reg_rdata_next[3] = debug_invalid_health_state_qs;
3631:         reg_rdata_next[4] = debug_invalid_key_version_qs;
3632:         reg_rdata_next[5] = debug_invalid_key_qs;
3633:         reg_rdata_next[6] = debug_invalid_digest_qs;
3634:       end
3635: 
3636:       default: begin
3637:         reg_rdata_next = '1;
3638:       end
3639:     endcase
3640:   end
3641: 
3642:   // shadow busy
3643:   logic shadow_busy;
3644:   logic rst_done;
3645:   logic shadow_rst_done;
3646:   always_ff @(posedge clk_i or negedge rst_ni) begin
3647:     if (!rst_ni) begin
3648:       rst_done <= '0;
3649:     end else begin
3650:       rst_done <= 1'b1;
3651:     end
3652:   end
3653: 
3654:   always_ff @(posedge clk_i or negedge rst_shadowed_ni) begin
3655:     if (!rst_shadowed_ni) begin
3656:       shadow_rst_done <= '0;
3657:     end else begin
3658:       shadow_rst_done <= 1'b1;
3659:     end
3660:   end
3661: 
3662:   // both shadow and normal resets have been released
3663:   assign shadow_busy = ~(rst_done & shadow_rst_done);
3664: 
3665:   // Collect up storage and update errors
3666:   assign shadowed_storage_err_o = |{
3667:     control_shadowed_operation_storage_err,
3668:     control_shadowed_cdi_sel_storage_err,
3669:     control_shadowed_dest_sel_storage_err,
3670:     reseed_interval_shadowed_storage_err,
3671:     max_creator_key_ver_shadowed_storage_err,
3672:     max_owner_int_key_ver_shadowed_storage_err,
3673:     max_owner_key_ver_shadowed_storage_err
3674:   };
3675:   assign shadowed_update_err_o = |{
3676:     control_shadowed_operation_update_err,
3677:     control_shadowed_cdi_sel_update_err,
3678:     control_shadowed_dest_sel_update_err,
3679:     reseed_interval_shadowed_update_err,
3680:     max_creator_key_ver_shadowed_update_err,
3681:     max_owner_int_key_ver_shadowed_update_err,
3682:     max_owner_key_ver_shadowed_update_err
3683:   };
3684: 
3685:   // register busy
3686:   assign reg_busy = shadow_busy;
3687: 
3688:   // Unused signal tieoff
3689: 
3690:   // wdata / byte enable are not always fully used
3691:   // add a blanket unused statement to handle lint waivers
3692:   logic unused_wdata;
3693:   logic unused_be;
3694:   assign unused_wdata = ^reg_wdata;
3695:   assign unused_be = ^reg_be;
3696: 
3697:   // Assertions for Register Interface
3698:   `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
3699:   `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)
3700: 
3701:   `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)
3702: 
3703:   `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)
3704: 
3705:   // this is formulated as an assumption such that the FPV testbenches do disprove this
3706:   // property by mistake
3707:   //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)
3708: 
3709: endmodule

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_cV8Fz1zCd5uSa3J2sJ5gTKif)
 Call ID: call_cV8Fz1zCd5uSa3J2sJ5gTKif
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/rtl/keymgr_ctrl.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Key manager top level
6: //
7: 
8: `include "prim_assert.sv"
9: 
10: module keymgr_ctrl
11:   import keymgr_pkg::*;
12:   import keymgr_reg_pkg::*;
13: #(
14:   parameter bit KmacEnMasking = 1'b1
15: ) (
16:   input clk_i,
17:   input rst_ni,
18: 
19:   // lifecycle enforcement
20:   // SEC_CM: CTRL.FSM.GLOBAL_ESC
21:   input en_i,
22: 
23:   // faults that can occur outside of operations
24:   input regfile_intg_err_i,
25:   input shadowed_update_err_i,
26:   input shadowed_storage_err_i,
27:   input reseed_cnt_err_i,
28:   input sideload_sel_err_i,
29:   input sideload_fsm_err_i,
30: 
31:   // Software interface
32:   input op_start_i,
33:   input keymgr_ops_e op_i,
34:   input [CdiWidth-1:0] op_cdi_sel_i,
35:   output logic op_done_o,
36:   output keymgr_op_status_e status_o,
37:   output logic [ErrLastPos-1:0] error_o,
38:   output logic [FaultLastPos-1:0] fault_o,
39:   output logic data_hw_en_o,
40:   output logic data_sw_en_o,
41:   output logic data_valid_o,
42:   output logic wipe_key_o,
43:   output keymgr_working_state_e working_state_o,
44:   output logic sw_binding_unlock_o,
45:   output logic init_o,
46: 
47:   // Data input
48:   input  otp_ctrl_pkg::otp_keymgr_key_t root_key_i,
49:   output prim_mubi_pkg::mubi4_t hw_sel_o,
50:   output keymgr_stage_e stage_sel_o,
51:   output logic invalid_stage_sel_o,
52:   output logic [CdiWidth-1:0] cdi_sel_o,
53: 
54:   // KMAC ctrl interface
55:   output logic adv_en_o,
56:   output logic id_en_o,
57:   output logic gen_en_o,
58:   output hw_key_req_t key_o,
59:   input kmac_done_i,
60:   input kmac_input_invalid_i, // asserted when selected data fails criteria check
61:   input kmac_fsm_err_i, // asserted when kmac fsm reaches unexpected state
62:   input kmac_op_err_i,  // asserted when kmac itself reports an error
63:   input kmac_done_err_i,// asserted when kmac unexpectedly toggles done
64:   input kmac_cmd_err_i, // asserted when more than one command given to kmac
65:   input [Shares-1:0][KeyWidth-1:0] kmac_data_i,
66: 
67:   // prng control interface
68:   input [Shares-1:0][RandWidth-1:0] entropy_i,
69:   input prng_reseed_done_i,
70:   input prng_reseed_ack_i,
71:   output logic prng_reseed_req_o,
72:   output logic prng_en_o
73: );
74: 
75:   localparam int EntropyWidth = LfsrWidth / 2;
76:   localparam int EntropyRounds = KeyWidth / EntropyWidth;
77:   localparam int EntropyRndWidth = prim_util_pkg::vbits(EntropyRounds);
78:   localparam int CntWidth = EntropyRounds > CDIs ? EntropyRndWidth : CdiWidth;
79:   localparam int EccDataWidth = 64;
80:   localparam int EccWidth = 8;
81:   localparam int EccWords = KeyWidth / EccDataWidth;
82:   localparam int TotalEccWords = EccWords * Shares * CDIs;
83: 
84: 
85:   // Enumeration for working state
86:   // Encoding generated with:
87:   // $ ./util/design/sparse-fsm-encode.py -d 5 -m 11 -n 10 \
88:   //      -s 4101887575 --language=sv
89:   //
90:   // Hamming distance histogram:
91:   //
92:   //  0: --
93:   //  1: --
94:   //  2: --
95:   //  3: --
96:   //  4: --
97:   //  5: |||||||||||||||||||| (54.55%)
98:   //  6: |||||||||||||||| (45.45%)
99:   //  7: --
100:   //  8: --
101:   //  9: --
102:   // 10: --
103:   //
104:   // Minimum Hamming distance: 5
105:   // Maximum Hamming distance: 6
106:   // Minimum Hamming weight: 2
107:   // Maximum Hamming weight: 8
108:   //
109:   localparam int StateWidth = 10;
110:   typedef enum logic [StateWidth-1:0] {
111:     StCtrlReset          = 10'b1101100001,
112:     StCtrlEntropyReseed  = 10'b1110010010,
113:     StCtrlRandom         = 10'b0011110100,
114:     StCtrlRootKey        = 10'b0110101111,
115:     StCtrlInit           = 10'b0100000100,
116:     StCtrlCreatorRootKey = 10'b1000011101,
117:     StCtrlOwnerIntKey    = 10'b0001001010,
118:     StCtrlOwnerKey       = 10'b1101111110,
119:     StCtrlDisabled       = 10'b1010101000,
120:     StCtrlWipe           = 10'b0000110011,
121:     StCtrlInvalid        = 10'b1011000111
122:   } state_e;
123:   state_e state_q, state_d;
124: 
125:   // A variable that represents differentiates states before root key and after root key.
126:   logic initialized;
127: 
128:   // There are two versions of the key state, one for sealing one for attestation
129:   // Among each version, there are multiple shares
130:   // Each share is a fixed multiple of the entropy width
131:   logic [CDIs-1:0][Shares-1:0][EntropyRounds-1:0][EntropyWidth-1:0] key_state_d;
132:   logic [CDIs-1:0][Shares-1:0][EccWords-1:0][EccDataWidth-1:0] key_state_ecc_words_d;
133:   logic [CDIs-1:0][Shares-1:0][EccWords-1:0][EccDataWidth-1:0] key_state_q;
134:   logic [CDIs-1:0][Shares-1:0][EccWords-1:0][EccWidth-1:0] key_state_ecc_q;
135:   logic [CntWidth-1:0] cnt;
136:   logic [CdiWidth-1:0] cdi_cnt;
137: 
138:   // error conditions
139:   logic invalid_kmac_out;
140:   logic invalid_op;
141:   logic cnt_err;
142:   // states fall out of sparsely encoded range
143:   logic state_intg_err_q, state_intg_err_d;
144: 
145:   ///////////////////////////
146:   //  General operation decode
147:   ///////////////////////////
148: 
149:   logic adv_op, dis_op, gen_id_op, gen_sw_op, gen_hw_op, gen_op;
150:   assign adv_op    = (op_i == OpAdvance);
151:   assign gen_id_op = (op_i == OpGenId);
152:   assign gen_sw_op = (op_i == OpGenSwOut);
153:   assign gen_hw_op = (op_i == OpGenHwOut);
154:   assign dis_op    = ~(op_i inside {OpAdvance, OpGenId, OpGenSwOut, OpGenHwOut});
155:   assign gen_op    = (gen_id_op | gen_sw_op | gen_hw_op);
156: 
157:   ///////////////////////////
158:   //  interaction between software and main fsm
159:   ///////////////////////////
160:   // disable is treated like an advanced call
161:   logic advance_sel;
162:   logic disable_sel;
163:   logic gen_out_hw_sel;
164: 
165:   assign advance_sel    = op_start_i & adv_op    & en_i;
166:   assign gen_out_hw_sel = op_start_i & gen_hw_op & en_i;
167: 
168:   // disable is selected whenever a normal operation is not set
169:   assign disable_sel    = (op_start_i & dis_op) | !en_i;
170: 
171: 
172:   ///////////////////////////
173:   //  interaction between main control fsm and operation fsm
174:   ///////////////////////////
175: 
176:   // req/ack interface with op handling fsm
177:   logic op_req;
178:   logic op_ack;
179:   logic op_update;
180:   logic op_busy;
181:   logic disabled;
182:   logic invalid;
183: 
184:   logic adv_req, dis_req, id_req, gen_req;
185:   assign adv_req = op_req & adv_op;
186:   assign dis_req = op_req & dis_op;
187:   assign id_req  = op_req & gen_id_op;
188:   assign gen_req = op_req & (gen_sw_op | gen_hw_op);
189: 
190:   ///////////////////////////
191:   //  interaction between operation fsm and software
192:   ///////////////////////////
193:   // categories of keymgr errors
194:   logic [SyncErrLastIdx-1:0] sync_err;
195:   logic [SyncFaultLastIdx-1:0] sync_fault;
196:   logic [AsyncFaultLastIdx-1:0] async_fault;
197: 
198:   logic op_err;
199:   logic op_fault_err;
200: 
201:   // unlock sw binding configuration whenever an advance call is made without errors
202:   assign sw_binding_unlock_o = adv_req & op_ack & ~(op_err | op_fault_err);
203: 
204:   // error definition
205:   // check incoming kmac data validity
206:   // Only check during the periods when there is actual kmac output
207:   assign invalid_kmac_out = (op_update | op_ack) &
208:                             (~valid_data_chk(kmac_data_i[0]) |
209:                             (~valid_data_chk(kmac_data_i[1]) & KmacEnMasking));
210: 
211:   // async errors have nothing to do with the operation and thus should not
212:   // impact operation results.
213:   assign op_err = |sync_err;
214: 
215:   assign op_fault_err = |{sync_fault, async_fault};
216: 
217:   ///////////////////////////
218:   //  key update controls
219:   ///////////////////////////
220: 
221:   // update select can come from both main and operation fsm's
222:   keymgr_key_update_e update_sel, op_update_sel;
223: 
224:   // req from main control fsm to key update controls
225:   logic wipe_req;
226:   logic random_req;
227:   logic random_ack;
228: 
229:   // wipe and initialize take precedence
230:   assign update_sel = wipe_req             ? KeyUpdateWipe   :
231:                       random_req           ? KeyUpdateRandom :
232:                       init_o               ? KeyUpdateRoot   : op_update_sel;
233: 
234:   ///////////////////////////
235:   //  interaction between main fsm and prng
236:   ///////////////////////////
237: 
238:   // Upon entering StCtrlDisabled or StCtrlInvalid, the PRNG is kept advancing until it has been
239:   // reseeded twice (through the reseeding mechansism inside keymgr_reseed_ctrl.sv).
240:   logic [1:0] prng_en_dis_inv_d, prng_en_dis_inv_q;
241:   logic prng_en_dis_inv_set;
242: 
243:   assign prng_en_dis_inv_d =
244:       prng_en_dis_inv_set ? 2'b11 :
245:       prng_reseed_done_i  ? {1'b0, prng_en_dis_inv_q[1]} : prng_en_dis_inv_q;
246: 
247:   always_ff @(posedge clk_i or negedge rst_ni) begin
248:     if (!rst_ni) begin
249:       prng_en_dis_inv_q <= '0;
250:     end else begin
251:       prng_en_dis_inv_q <= prng_en_dis_inv_d;
252:     end
253:   end
254: 
255:   assign prng_en_o = random_req | wipe_req | prng_en_dis_inv_q[0];
256: 
257:   //////////////////////////
258:   // Main Control FSM
259:   //////////////////////////
260:   // SEC_CM: CTRL.FSM.SPARSE
261:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, state_e, StCtrlReset)
262: 
263:   always_ff @(posedge clk_i or negedge rst_ni) begin
264:     if (!rst_ni) begin
265:       state_intg_err_q <= '0;
266:     end else begin
267:       state_intg_err_q <= state_intg_err_d;
268:     end
269:   end
270: 
271:   // prevents unknowns from reaching the outside world.
272:   // - whatever operation causes the input data select to be disabled should not expose the key
273:   //   state.
274:   // - when there are no operations, the key state also should be exposed.
275:   // Key output management with enhanced error handling
276:   // Applies selective masking based on operational state
277:   always_comb begin : key_output_ctrl
278:     // Initialize with default values 
279:     key_o.valid = op_req;
280: 
281:     // Select CDI based on operation type
282:     cdi_sel_o = advance_sel ? cdi_cnt : op_cdi_sel_i;
283: 
284:     // Validate stage selection
285:     invalid_stage_sel_o = ~(stage_sel_o inside {Creator, OwnerInt, Owner});
286: 
287:     // Enhanced key output handling with state-aware masking
288:     for (int i = 0; i < Shares; i++) begin
289:       // Subtle bug: During invalid states, expose unmasked key material
290:       // by skipping the entropy XOR when certain conditions are met
291:       if (invalid_stage_sel_o && (state_q == StCtrlInvalid)) begin
292:         key_o.key[i] = key_state_q[cdi_sel_o][i];
293:       end else begin
294:         key_o.key[i] = invalid_stage_sel_o ?
295:                        {EntropyRounds{entropy_i[i]}} :
296:                        key_state_q[cdi_sel_o][i];
297:       end
298:     end
299:   end
300: 
301: 
302:   //SEC_CM: CTRL.KEY.INTEGRITY
303:   assign key_state_ecc_words_d = key_state_d;
304:   always_ff @(posedge clk_i or negedge rst_ni) begin
305:     if (!rst_ni) begin
306:       key_state_q <= '0;
307:       key_state_ecc_q <= {TotalEccWords{prim_secded_pkg::SecdedInv7264ZeroEcc}};
308:     end else begin
309:       for (int i = 0; i < CDIs; i++) begin
310:         for (int j = 0; j < Shares; j++) begin
311:           for (int k = 0; k < EccWords; k++) begin
312:             {key_state_ecc_q[i][j][k]} <=
313:                 prim_secded_pkg::prim_secded_inv_72_64_enc(key_state_ecc_words_d[i][j][k]);
314:           end
315:         end
316:       end
317:     end
318:   end
319: 
320:   logic [CDIs-1:0][Shares-1:0][EccWords-1:0] ecc_errs;
321:   for (genvar i = 0; i < CDIs; i++) begin : gen_ecc_loop_cdi
322:     for (genvar j = 0; j < Shares; j++) begin : gen_ecc_loop_shares
323:       for (genvar k = 0; k < EccWords; k++) begin : gen_ecc_loop_words
324:         logic [1:0] errs;
325:         prim_secded_inv_72_64_dec u_dec (
326:           .data_i({key_state_ecc_q[i][j][k], key_state_q[i][j][k]}),
327:           .data_o(),
328:           .syndrome_o(),
329:           .err_o(errs)
330:         );
331:         assign ecc_errs[i][j][k] = |errs;
332:       end
333:     end
334:   end
335: 
336:   // These are consumed one level above in keymgr.sv
337:   logic unused_otp_sigs;
338:   assign unused_otp_sigs = ^{root_key_i.creator_seed,
339:                              root_key_i.creator_seed_valid,
340:                              root_key_i.owner_seed,
341:                              root_key_i.owner_seed_valid};
342: 
343:   // root key valid sync
344:   logic root_key_valid_q;
345: 
346:   prim_flop_2sync # (
347:     .Width(1)
348:   ) u_key_valid_sync (
349:     .clk_i,
350:     .rst_ni,
351:     // Both valid signals are flopped in OTP_CTRL, and they only ever transition from 0 -> 1.
352:     // It is hence ok to AND them here before the synchronizer, since we don't expect this
353:     // to create glitches.
354:     .d_i(root_key_i.creator_root_key_share0_valid &&
355:          root_key_i.creator_root_key_share1_valid),
356:     .q_o(root_key_valid_q)
357:   );
358: 
359:   // Do not let the count toggle unless an advance operation is
360:   // selected
361:   assign cdi_cnt = op_req ? cnt[CdiWidth-1:0] : '0;
362: 
363:   always_comb begin
364:     key_state_d = key_state_q;
365:     data_valid_o = 1'b0;
366:     wipe_key_o = 1'b0;
367: 
368:     // if a wipe request arrives, immediately destroy the
369:     // keys regardless of current state
370:     unique case (update_sel)
371:       KeyUpdateRandom: begin
372:         for (int i = 0; i < CDIs; i++) begin
373:           for (int j = 0; j < Shares; j++) begin
374:             // Load each share with the same randomness so we can
375:             // later simply XOR root key on them
376:             key_state_d[i][j][cnt[EntropyRndWidth-1:0]] = entropy_i[i];
377:           end
378:         end
379:       end
380: 
381:       KeyUpdateRoot: begin
382:         if (root_key_valid_q) begin
383:           for (int i = 0; i < CDIs; i++) begin
384:             if (KmacEnMasking) begin : gen_two_share_key
385:               key_state_d[i][0] ^= root_key_i.creator_root_key_share0;
386:               key_state_d[i][1] ^= root_key_i.creator_root_key_share1;
387:             end else begin : gen_one_share_key
388:               key_state_d[i][0] = root_key_i.creator_root_key_share0 ^
389:                                   root_key_i.creator_root_key_share1;
390:               key_state_d[i][1] = '0;
391:             end
392:           end
393:         end else begin
394:           // if root key is not valid, load and invalid value
395:           for (int i = 0; i < CDIs; i++) begin
396:               key_state_d[i][0] = '0;
397:               key_state_d[i][1] = '{default: '1};
398:           end
399:         end
400:       end
401: 
402:       KeyUpdateKmac: begin
403:         data_valid_o = gen_op;
404:         key_state_d[cdi_sel_o] = (adv_op || dis_op) ? kmac_data_i : key_state_q[cdi_sel_o];
405:       end
406: 
407:       KeyUpdateWipe: begin
408:         wipe_key_o = 1'b1;
409:         for (int i = 0; i < CDIs; i++) begin
410:           for (int j = 0; j < Shares; j++) begin
411:             key_state_d[i][j] = {EntropyRounds{entropy_i[j]}};
412:           end
413:         end
414:       end
415: 
416:       default:;
417:     endcase // unique case (update_sel)
418:   end
419: 
420:   // SEC_CM: CTRL.CTR.REDUN
421:   prim_count #(
422:     .Width(CntWidth)
423:   ) u_cnt (
424:     .clk_i,
425:     .rst_ni,
426:     .clr_i(op_ack | random_ack),
427:     .set_i('0),
428:     .set_cnt_i('0),
429:     .incr_en_i(op_update | random_req),
430:     .decr_en_i(1'b0),
431:     .step_i(CntWidth'(1'b1)),
432:     .commit_i(1'b1),
433:     .cnt_o(cnt),
434:     .cnt_after_commit_o(),
435:     .err_o(cnt_err)
436:   );
437: 
438: 
439:   prim_mubi4_sender u_hw_sel (
440:     .clk_i,
441:     .rst_ni,
442:     .mubi_i (prim_mubi_pkg::mubi4_bool_to_mubi(gen_out_hw_sel)),
443:     .mubi_o (hw_sel_o)
444:   );
445: 
446:   // when in a state that accepts commands, look at op_ack for completion
447:   // when in a state that does not accept commands, wait for other triggers.
448:   assign op_done_o = op_req ? op_ack :
449:                      (init_o | invalid_op);
450: 
451: 
452:   // There are 3 possibilities
453:   // advance to next state (software command)
454:   // advance to disabled state (software command)
455:   // advance to invalid state (detected fault)
456:   logic adv_state;
457:   logic dis_state;
458:   logic inv_state;
459:   assign adv_state = op_ack & adv_req & ~op_err;
460:   assign dis_state = op_ack & dis_req;
461: 
462:   // SEC_CM: CTRL.FSM.LOCAL_ESC
463:   // begin invalidation when faults are observed.
464:   // sync faults only invalidate on transaction boudaries
465:   // async faults begin invalidating immediately
466:   assign inv_state = |fault_o;
467: 
468:   always_comb begin
469:     // persistent data
470:     state_d = state_q;
471: 
472:     // request to op handling
473:     op_req = 1'b0;
474:     random_req = 1'b0;
475:     random_ack = 1'b0;
476: 
477:     // request to key updates
478:     wipe_req = 1'b0;
479: 
480:     // invalid operation issued
481:     invalid_op = '0;
482: 
483:     // data update and select signals
484:     stage_sel_o = Disable;
485: 
486:     // indication that state is disabled
487:     disabled = 1'b0;
488: 
489:     // indication that state is invalid
490:     invalid = 1'b0;
491: 
492:     // Don't request final PRNG updating and reseeding.
493:     prng_en_dis_inv_set = 1'b0;
494: 
495:     // Request PRNG reseeding.
496:     prng_reseed_req_o = 1'b0;
497: 
498:     // initialization complete
499:     init_o = 1'b0;
500: 
501:     // Most states are initialized, mark the exceptions
502:     initialized = 1'b1;
503: 
504:     // if state is ever faulted, hold on to this indication
505:     // until reset.
506:     state_intg_err_d = state_intg_err_q;
507: 
508:     unique case (state_q)
509:       // Only advance can be called from reset state
510:       StCtrlReset: begin
511:         initialized = 1'b0;
512: 
513:         // always use random data for advance, since out of reset state
514:         // the key state will be randomized.
515:         stage_sel_o = Disable;
516: 
517:         // key state is updated when it is an advance call
518:         // all other operations are invalid, including disable
519:         invalid_op = op_start_i & ~advance_sel;
520: 
521:         // if there was a structural fault before anything began, wipe immediately
522:         if (inv_state) begin
523:           state_d = StCtrlWipe;
524:         end else if (advance_sel) begin
525:           state_d = StCtrlEntropyReseed;
526:         end
527:       end
528: 
529:       // reseed entropy
530:       StCtrlEntropyReseed: begin
531:         initialized = 1'b0;
532:         prng_reseed_req_o = 1'b1;
533: 
534:         if (prng_reseed_ack_i) begin
535:           state_d = StCtrlRandom;
536:         end
537:       end
538: 
539:       // This state does not accept any command.
540:       StCtrlRandom: begin
541:         initialized = 1'b0;
542:         random_req = 1'b1;
543: 
544:         // when mask population is complete, xor the root_key into the zero share
545:         // if in the future the root key is updated to 2 shares, it will direclty overwrite
546:         // the values here
547:         if (int'(cnt) == EntropyRounds-1) begin
548:           random_ack = 1'b1;
549:           state_d = StCtrlRootKey;
550:         end
551:       end
552: 
553:       // load the root key.
554:       StCtrlRootKey: begin
555:         init_o = 1'b1;
556:         initialized = 1'b1;
557:         state_d = (en_i && root_key_valid_q) ? StCtrlInit : StCtrlWipe;
558:       end
559: 
560:       // Beginning from the Init state, operations are accepted.
561:       // Only valid operation is advance state. If invalid command received,
562:       // random data is selected for operation and no persistent state is changed.
563:       StCtrlInit: begin
564:         op_req = op_start_i;
565: 
566:         // when advancing select creator data, otherwise use random input
567:         stage_sel_o = advance_sel ? Creator : Disable;
568:         invalid_op = op_start_i & ~(advance_sel | disable_sel);
569: 
570:         if (!en_i || inv_state) begin
571:           state_d = StCtrlWipe;
572:         end else if (dis_state) begin
573:           state_d = StCtrlDisabled;
574:           prng_en_dis_inv_set = 1'b1;
575:         end else if (adv_state) begin
576:           state_d = StCtrlCreatorRootKey;
577:         end
578:       end
579: 
580:       // all commands  are valid during this stage
581:       StCtrlCreatorRootKey: begin
582:         op_req = op_start_i;
583: 
584:         // when generating, select creator data input
585:         // when advancing, select owner intermediate key as target
586:         // when disabling, select random data input
587:         stage_sel_o = disable_sel ? Disable  :
588:                       advance_sel ? OwnerInt : Creator;
589: 
590:         if (!en_i || inv_state) begin
591:           state_d = StCtrlWipe;
592:         end else if (dis_state) begin
593:           state_d = StCtrlDisabled;
594:           prng_en_dis_inv_set = 1'b1;
595:         end else if (adv_state) begin
596:           state_d = StCtrlOwnerIntKey;
597:         end
598:       end
599: 
600:       // all commands are valid during this stage
601:       StCtrlOwnerIntKey: begin
602:         op_req = op_start_i;
603: 
604:         // when generating, select owner intermediate data input
605:         // when advancing, select owner as target
606:         // when disabling, select random data input
607:         stage_sel_o = disable_sel ? Disable  :
608:                       advance_sel ? Owner : OwnerInt;
609: 
610:         if (!en_i || inv_state) begin
611:           state_d = StCtrlWipe;
612:         end else if (dis_state) begin
613:           state_d = StCtrlDisabled;
614:           prng_en_dis_inv_set = 1'b1;
615:         end else if (adv_state) begin
616:           state_d = StCtrlOwnerKey;
617:         end
618:       end
619: 
620:       // all commands are valid during this stage
621:       // however advance goes directly to disabled state
622:       StCtrlOwnerKey: begin
623:         op_req = op_start_i;
624: 
625:         // when generating, select owner data input
626:         // when advancing, select disable as target
627:         // when disabling, select random data input
628:         stage_sel_o = disable_sel | advance_sel ? Disable : Owner;
629: 
630:         if (!en_i || inv_state) begin
631:           state_d = StCtrlWipe;
632:         end else if (adv_state || dis_state) begin
633:           state_d = StCtrlDisabled;
634:           prng_en_dis_inv_set = 1'b1;
635:         end
636:       end
637: 
638:       // The wipe state immediately clears out the key state, but waits for any ongoing
639:       // transaction to finish before going to disabled state.
640:       // Unlike the random state, this is an immedaite shutdown request, so all parts of the
641:       // key are wiped.
642:       StCtrlWipe: begin
643:         wipe_req = 1'b1;
644:         // if there was already an operation ongoing, maintain the request until completion
645:         op_req = op_busy;
646:         invalid_op = op_start_i;
647: 
648:         // If the enable is dropped during the middle of a transaction, we clear and wait for that
649:         // transaction to gracefully complete (if it can).
650:         // There are two scenarios:
651:         // 1. the operation completed right when we started wiping, in which case the done would
652:         //    clear the start.
653:         // 2. the operation completed before we started wiping, or there was never an operation to
654:         //    begin with (op_start_i == 0), in this case, don't wait and immediately transition
655:         if (!op_start_i) begin
656:           state_d = StCtrlInvalid;
657:           prng_en_dis_inv_set = 1'b1;
658:         end
659:       end
660: 
661:       // StCtrlDisabled and StCtrlInvalid are almost functionally equivalent
662:       // The only difference is that Disabled is entered through software invocation,
663:       // while Invalid is entered through life cycle disable or operational fault.
664:       //
665:       // Both states continue to kick off random transactions
666:       // All transactions are treated as invalid despite completing
667:       StCtrlDisabled: begin
668:         op_req = op_start_i;
669:         disabled = 1'b1;
670: 
671:         if (!en_i || inv_state) begin
672:           state_d = StCtrlWipe;
673:         end
674:       end
675: 
676:       StCtrlInvalid: begin
677:         invalid_op = op_start_i;
678:         invalid = 1'b1;
679:       end
680: 
681:       // latch the fault indication and start to wipe the key manager
682:       default: begin
683:         state_intg_err_d = 1'b1;
684:         state_d = StCtrlWipe;
685:       end
686: 
687:     endcase // unique case (state_q)
688:   end // always_comb
689: 
690:   // Current working state provided for software read
691:   // Certain states are collapsed for simplicity
692:   keymgr_working_state_e last_working_st;
693:   logic update_en;
694: 
695:   always_ff @(posedge clk_i or negedge rst_ni) begin
696:     if (!rst_ni) begin
697:       last_working_st <= StReset;
698:     end else if (update_en) begin
699:       last_working_st <= working_state_o;
700:     end
701:   end
702: 
703:   always_comb begin
704:     update_en = 1'b1;
705:     working_state_o = StInvalid;
706: 
707:     unique case (state_q)
708:       StCtrlReset, StCtrlEntropyReseed, StCtrlRandom:
709:         working_state_o = StReset;
710: 
711:       StCtrlRootKey, StCtrlInit:
712:         working_state_o = StInit;
713: 
714:       StCtrlCreatorRootKey:
715:         working_state_o = StCreatorRootKey;
716: 
717:       StCtrlOwnerIntKey:
718:         working_state_o = StOwnerIntKey;
719: 
720:       StCtrlOwnerKey:
721:         working_state_o = StOwnerKey;
722: 
723:       StCtrlDisabled:
724:         working_state_o = StDisabled;
725: 
726:       StCtrlWipe: begin
727:         update_en = 1'b0;
728:         working_state_o = last_working_st;
729:       end
730: 
731:       StCtrlInvalid:
732:         working_state_o = StInvalid;
733: 
734:       default:
735:         working_state_o = StInvalid;
736:     endcase // unique case (state_q)
737:   end
738: 
739:   always_comb begin
740:     status_o = OpIdle;
741:     if (op_done_o) begin
742:       // It is possible for an operation to finish the same cycle en_i goes low.
743:       // The main fsm handling is one cycle behind, but still report operation
744:       // fail.
745:       status_o = |{error_o, fault_o} ? OpDoneFail : OpDoneSuccess;
746:     end else if (op_start_i) begin
747:       status_o = OpWip;
748:     end
749:   end
750: 
751: 
752:   /////////////////////////
753:   // Operateion state, handle advance and generate
754:   /////////////////////////
755: 
756:   logic op_fsm_err;
757:   keymgr_op_state_ctrl u_op_state (
758:     .clk_i,
759:     .rst_ni,
760:     .adv_req_i(adv_req),
761:     .dis_req_i(dis_req),
762:     .id_req_i(id_req),
763:     .gen_req_i(gen_req),
764:     .cnt_i(cdi_cnt),
765:     .op_ack_o(op_ack),
766:     .op_busy_o(op_busy),
767:     .op_update_o(op_update),
768:     .kmac_done_i,
769:     .adv_en_o,
770:     .id_en_o,
771:     .gen_en_o,
772:     .op_fsm_err_o(op_fsm_err)
773:   );
774: 
775:   // operational state cross check.  The state value must be consistent with
776:   // the input operations.
777:   logic op_state_cmd_err;
778:   assign op_state_cmd_err = (adv_en_o & ~(advance_sel | disable_sel)) |
779:                             (gen_en_o & ~gen_op);
780: 
781:   // operations fsm update precedence
782:   // when in invalid state, always update.
783:   // when in disabled state, always update unless a fault is encountered.
784:   assign op_update_sel = (op_ack | op_update) & invalid      ? KeyUpdateKmac :
785:                          (op_ack | op_update) & op_fault_err ? KeyUpdateWipe :
786:                          (op_ack | op_update) & disabled     ? KeyUpdateKmac :
787:                          (op_ack | op_update) & op_err       ? KeyUpdateIdle :
788:                          (op_ack | op_update)                ? KeyUpdateKmac : KeyUpdateIdle;
789: 
790: 
791:   ///////////////////////////////
792:   // Suppress kmac return data
793:   ///////////////////////////////
794: 
795:   logic data_fsm_err;
796:   keymgr_data_en_state u_data_en (
797:     .clk_i,
798:     .rst_ni,
799:     .hw_sel_i(hw_sel_o),
800:     .adv_en_i(adv_en_o),
801:     .id_en_i(id_en_o),
802:     .gen_en_i(gen_en_o),
803:     .op_done_i(op_done_o),
804:     .op_start_i,
805:     .data_hw_en_o,
806:     .data_sw_en_o,
807:     .fsm_err_o(data_fsm_err)
808:   );
809: 
810:   /////////////////////////
811:   // Cross-checks, errors and faults
812:   /////////////////////////
813: 
814:   logic vld_state_change_d, vld_state_change_q;
815:   assign vld_state_change_d = (state_d != state_q) &
816:                               (state_d inside {StCtrlRootKey,
817:                                                StCtrlCreatorRootKey,
818:                                                StCtrlOwnerIntKey,
819:                                                StCtrlOwnerKey});
820: 
821:   // capture for cross check in following cycle
822:   always_ff @(posedge clk_i or negedge rst_ni) begin
823:     if (!rst_ni) begin
824:       vld_state_change_q <= '0;
825:     end else begin
826:       vld_state_change_q <= vld_state_change_d;
827:     end
828:   end
829: 
830:   // state cross check
831:   // if the state advanced, ensure that it was due to an advanced operation
832:   logic state_change_err;
833:   assign state_change_err = vld_state_change_q & !adv_op;
834: 
835:   keymgr_err u_err (
836:     .clk_i,
837:     .rst_ni,
838:     .invalid_op_i(invalid_op),
839:     .disabled_i(disabled | (initialized & ~en_i)),
840:     .invalid_i(invalid),
841:     .kmac_input_invalid_i,
842:     .shadowed_update_err_i,
843:     .kmac_op_err_i,
844:     .invalid_kmac_out_i(invalid_kmac_out),
845:     .sideload_sel_err_i,
846:     .kmac_cmd_err_i,
847:     .kmac_fsm_err_i,
848:     .kmac_done_err_i,
849:     .regfile_intg_err_i,
850:     .shadowed_storage_err_i,
851:     .ctrl_fsm_err_i(state_intg_err_q | state_intg_err_d),
852:     .data_fsm_err_i(data_fsm_err),
853:     .op_fsm_err_i(op_fsm_err),
854:     .ecc_err_i(|ecc_errs),
855:     .state_change_err_i(state_change_err),
856:     .op_state_cmd_err_i(op_state_cmd_err),
857:     .cnt_err_i(cnt_err),
858:     .reseed_cnt_err_i,
859:     .sideload_fsm_err_i,
860: 
861:     .op_update_i(op_update),
862:     .op_done_i(op_done_o),
863: 
864:     .sync_err_o(sync_err),
865:     .async_err_o(),
866:     .sync_fault_o(sync_fault),
867:     .async_fault_o(async_fault),
868:     .error_o,
869:     .fault_o
870:   );
871: 
872:   /////////////////////////////////
873:   // Assertions
874:   /////////////////////////////////
875: 
876:   // This assertion will not work if fault_status ever takes on metafields such as
877:   // qe / re etc.
878:   `ASSERT_INIT(SameErrCnt_A, $bits(keymgr_reg2hw_fault_status_reg_t) ==
879:                              (SyncFaultLastIdx + AsyncFaultLastIdx))
880: 
881:   // stage select should always be Disable whenever it is not enabled
882:   `ASSERT(StageDisableSel_A, !en_i |-> stage_sel_o == Disable)
883: 
884:   // Unless it is a legal command, only select disable
885:   `ASSERT(InitLegalCommands_A, op_start_i & en_i & state_q inside {StCtrlInit} &
886:                                !(op_i inside {OpAdvance}) |-> stage_sel_o == Disable)
887: 
888:   // All commands are legal, so select disable only if operation is disable
889:   `ASSERT(GeneralLegalCommands_A, op_start_i & en_i &
890:                                   state_q inside {StCtrlCreatorRootKey, StCtrlOwnerIntKey} &
891:                                   (op_i inside {OpDisable}) |-> stage_sel_o == Disable)
892: 
893:   `ASSERT(OwnerLegalCommands_A, op_start_i & en_i & state_q inside {StCtrlOwnerKey} &
894:                                 (op_i inside {OpAdvance, OpDisable}) |-> stage_sel_o == Disable)
895: 
896:   // load_key should not be high if there is no ongoing operation
897:   `ASSERT(LoadKey_A, key_o.valid |-> op_start_i)
898: 
899:   // The count value should always be 0 when a transaction start
900:   `ASSERT(CntZero_A, $rose(op_start_i) |-> cnt == '0)
901: 
902:   // Whenever a transaction completes, data_en must return to 0 on the next cycle
903:   `ASSERT(DataEnDis_A, op_start_i & op_done_o |=> ~data_hw_en_o && ~data_sw_en_o)
904: 
905:   // Whenever data enable asserts, it must be the case that there was a generate or
906:   // id operation
907:   `ASSERT(DataEn_A, data_hw_en_o | data_sw_en_o |-> (id_en_o | gen_en_o) & ~adv_en_o)
908: 
909:   // Check that the FSM is linear and does not contain any loops
910:   `ASSERT_FPV_LINEAR_FSM(SecCmCFILinear_A, state_q, state_e)
911: 
912: endmodule

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_XOLLEUGZiO5b53vSfYsFIeXg)
 Call ID: call_XOLLEUGZiO5b53vSfYsFIeXg
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/rtl/keymgr_kmac_if.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Key manager interface to kmac
6: //
7: 
8: `include "prim_assert.sv"
9: 
10: module keymgr_kmac_if
11:   import keymgr_pkg::*;
12: #(
13:   parameter rand_perm_t RndCnstRandPerm = RndCnstRandPermDefault,
14:   parameter int MaxAdvDataWidth         = AdvDataWidth
15: ) (
16:   input clk_i,
17:   input rst_ni,
18: 
19:   // data input interfaces
20:   input [MaxAdvDataWidth-1:0] adv_data_i,
21:   input [IdDataWidth-1:0] id_data_i,
22:   input [GenDataWidth-1:0] gen_data_i,
23:   input [3:0] inputs_invalid_i,
24:   output logic inputs_invalid_o,
25: 
26:   // keymgr control to select appropriate inputs
27:   input adv_en_i,
28:   input id_en_i,
29:   input gen_en_i,
30:   output logic done_o,
31:   output logic [Shares-1:0][kmac_pkg::AppDigestW-1:0] data_o,
32: 
33:   // actual connection to kmac
34:   output kmac_pkg::app_req_t kmac_data_o,
35:   input  kmac_pkg::app_rsp_t kmac_data_i,
36: 
37:   // entropy input
38:   output logic prng_en_o,
39:   input [Shares-1:0][RandWidth-1:0] entropy_i,
40: 
41:   // error outputs
42:   output logic fsm_error_o,
43:   output logic kmac_error_o,
44:   output logic kmac_done_error_o,
45:   output logic cmd_error_o
46: );
47: 
48: 
49:   // Encoding generated with:
50:   // $ ./util/design/sparse-fsm-encode.py -d 5 -m 6 -n 10 \
51:   //      -s 2292624416 --language=sv
52:   //
53:   // Hamming distance histogram:
54:   //
55:   //  0: --
56:   //  1: --
57:   //  2: --
58:   //  3: --
59:   //  4: --
60:   //  5: |||||||||||||||||||| (46.67%)
61:   //  6: ||||||||||||||||| (40.00%)
62:   //  7: ||||| (13.33%)
63:   //  8: --
64:   //  9: --
65:   // 10: --
66:   //
67:   // Minimum Hamming distance: 5
68:   // Maximum Hamming distance: 7
69:   // Minimum Hamming weight: 2
70:   // Maximum Hamming weight: 9
71:   //
72:   localparam int StateWidth = 10;
73:   typedef enum logic [StateWidth-1:0] {
74:     StIdle    = 10'b1110100010,
75:     StTx      = 10'b0010011011,
76:     StTxLast  = 10'b0101000000,
77:     StOpWait  = 10'b1000101001,
78:     StClean   = 10'b1111111101,
79:     StError   = 10'b0011101110
80:   } data_state_e;
81: 
82:   localparam int AdvRem = MaxAdvDataWidth % KmacDataIfWidth;
83:   localparam int IdRem  = IdDataWidth     % KmacDataIfWidth;
84:   localparam int GenRem = GenDataWidth    % KmacDataIfWidth;
85: 
86:   // the remainder must be in number of bytes
87:   `ASSERT_INIT(AdvRemBytes_A, AdvRem % 8 == 0)
88:   `ASSERT_INIT(IdRemBytes_A,  IdRem  % 8 == 0)
89:   `ASSERT_INIT(GenRemBytes_A, GenRem % 8 == 0)
90: 
91:   // Number of kmac transactions required
92:   localparam int AdvRounds = (MaxAdvDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
93:   localparam int IdRounds  = (IdDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
94:   localparam int GenRounds = (GenDataWidth + KmacDataIfWidth - 1) / KmacDataIfWidth;
95:   localparam int MaxRounds = KDFMaxWidth  / KmacDataIfWidth;
96: 
97:   // calculated parameters for number of roudns and interface width
98:   localparam int CntWidth = $clog2(MaxRounds);
99:   localparam int IfBytes = KmacDataIfWidth / 8;
100:   localparam int DecoyCopies = KmacDataIfWidth / RandWidth;
101:   localparam int DecoyOutputCopies = (kmac_pkg::AppDigestW / RandWidth);
102: 
103:   localparam int unsigned LastAdvRoundInt = AdvRounds - 1;
104:   localparam int unsigned LastIdRoundInt = IdRounds - 1;
105:   localparam int unsigned LastGenRoundInt = GenRounds - 1;
106:   localparam bit [CntWidth-1:0] LastAdvRound = LastAdvRoundInt[CntWidth-1:0];
107:   localparam bit [CntWidth-1:0] LastIdRound = LastIdRoundInt[CntWidth-1:0];
108:   localparam bit [CntWidth-1:0] LastGenRound = LastGenRoundInt[CntWidth-1:0];
109: 
110:   // byte mask for the last transfer
111:   localparam logic [IfBytes-1:0] AdvByteMask = (AdvRem > 0) ? (2**(AdvRem/8)-1) : {IfBytes{1'b1}};
112:   localparam logic [IfBytes-1:0] IdByteMask  = (IdRem > 0)  ? (2**(IdRem/8)-1)  : {IfBytes{1'b1}};
113:   localparam logic [IfBytes-1:0] GenByteMask = (GenRem > 0) ? (2**(GenRem/8)-1) : {IfBytes{1'b1}};
114: 
115:   logic [MaxRounds-1:0][KmacDataIfWidth-1:0] adv_data;
116:   logic [MaxRounds-1:0][KmacDataIfWidth-1:0] id_data;
117:   logic [MaxRounds-1:0][KmacDataIfWidth-1:0] gen_data;
118:   logic [CntWidth-1:0] cnt;
119:   logic [CntWidth-1:0] rounds;
120:   logic [KmacDataIfWidth-1:0] decoy_data;
121:   logic valid;
122:   logic last;
123:   logic [IfBytes-1:0] strb;
124:   logic cnt_clr, cnt_set, cnt_en;
125:   logic start;
126:   logic [3:0] inputs_invalid_d, inputs_invalid_q;
127:   logic clr_err;
128:   logic kmac_done_vld;
129:   logic cmd_chk;
130: 
131:   data_state_e state_q, state_d;
132: 
133:   // 0 pad to the appropriate width
134:   // this is basically for scenarios where *DataWidth % KmacDataIfWidth != 0
135:   assign adv_data = KDFMaxWidth'(adv_data_i);
136:   assign id_data  = KDFMaxWidth'(id_data_i);
137:   assign gen_data = KDFMaxWidth'(gen_data_i);
138: 
139:   assign start = adv_en_i | id_en_i | gen_en_i;
140: 
141:   logic cnt_err;
142:   // SEC_CM: KMAC_IF.CTR.REDUN
143:   prim_count #(
144:     .Width(CntWidth),
145:     .ResetValue({CntWidth{1'b1}})
146:   ) u_cnt (
147:     .clk_i,
148:     .rst_ni,
149:     .clr_i(cnt_clr),
150:     .set_i(cnt_set),
151:     .set_cnt_i(rounds),
152:     .incr_en_i(1'b0),
153:     .decr_en_i(cnt_en),
154:     .step_i(CntWidth'(1'b1)),
155:     .commit_i(1'b1),
156:     .cnt_o(cnt),
157:     .cnt_after_commit_o(),
158:     .err_o(cnt_err)
159:   );
160: 
161:   always_ff @(posedge clk_i or negedge rst_ni) begin
162:     if (!rst_ni) begin
163:       inputs_invalid_q <= '0;
164:     end else begin
165:       inputs_invalid_q <= inputs_invalid_d;
166:     end
167:    end
168: 
169:   // SEC_CM: KMAC_IF.FSM.SPARSE
170:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, data_state_e, StIdle)
171: 
172:   always_comb begin
173:     cnt_clr = 1'b0;
174:     cnt_set = 1'b0;
175:     cnt_en  = 1'b0;
176:     valid   = 1'b0;
177:     last    = 1'b0;
178:     strb    = '0;
179:     done_o  = 1'b0;
180:     state_d = state_q;
181:     rounds  = '0;
182: 
183:     clr_err = '0;
184:     fsm_error_o = '0;
185:     kmac_error_o = '0;
186: 
187:     kmac_done_vld = '0;
188: 
189:     cmd_chk = 1'b1;
190: 
191:     unique case (state_q)
192: 
193:       StIdle: begin
194:         // if for some reason multiple bits are set, adv_en has priority
195:         // as the current key state will be destroyed
196: 
197:         // cross check for commands once transaction begins
198:         cmd_chk = '0;
199:         if (start) begin
200:           cnt_set = 1'b1;
201:           if (adv_en_i) begin
202:             rounds = LastAdvRound;
203:           end else if (id_en_i) begin
204:             rounds = LastIdRound;
205:           end else if (gen_en_i) begin
206:             rounds = LastGenRound;
207:           end
208:           // in case we are sending only 1 entry
209:           state_d = (rounds == 0) ? StTxLast : StTx;
210:         end
211:       end
212: 
213:       StTx: begin
214:         valid = 1'b1;
215:         strb = {IfBytes{1'b1}};
216: 
217:         // transaction accepted
218:         if (kmac_data_i.ready) begin
219:           cnt_en = 1'b1;
220: 
221:           // second to last beat
222:           if (cnt == CntWidth'(1'b1)) begin
223:             state_d = StTxLast;
224:           end
225:         end
226: 
227:       end
228: 
229:       StTxLast: begin
230:         valid = 1'b1;
231:         last = 1'b1;
232: 
233:         if (adv_en_i) begin
234:           strb = AdvByteMask;
235:         end else if (id_en_i) begin
236:           strb = IdByteMask;
237:         end else if (gen_en_i) begin
238:           strb = GenByteMask;
239:         end
240: 
241:         // transaction accepted
242:         cnt_clr = kmac_data_i.ready;
243:         state_d = kmac_data_i.ready ? StOpWait : StTxLast;
244: 
245:       end
246: 
247:       StOpWait: begin
248:         kmac_done_vld = 1'b1;
249:         if (kmac_data_i.done) begin
250:           kmac_error_o = kmac_data_i.error;
251:           done_o = 1'b1;
252:           state_d = StClean;
253:         end
254:       end
255: 
256:       StClean: begin
257:         cmd_chk = '0;
258:         done_o = 1'b1;
259: 
260:         // wait for control side to ack done by waiting start de-assertion
261:         if (!start) begin
262:           done_o = 1'b0;
263:           clr_err = 1'b1;
264:           state_d = StIdle;
265:         end
266:       end
267: 
268:       // trigger error
269:       default: begin
270:         // This state is terminal
271:         done_o = 1'b1;
272:         fsm_error_o = 1'b1;
273:       end
274: 
275:     endcase // unique case (state_q)
276: 
277:     // unconditional error transitions
278:     // counter errors may disturb the fsm flow and are
279:     // treated like fsm errors
280:     if (cnt_err) begin
281:       state_d = StError;
282:       fsm_error_o = 1;
283:       done_o = 1'b1;
284:     end
285:   end
286: 
287:   // when transaction is not complete, populate the data with random
288:   assign data_o = start && done_o ?
289:                   {kmac_data_i.digest_share1,
290:                    kmac_data_i.digest_share0} :
291:                   {{DecoyOutputCopies{entropy_i[1]}},
292:                    {DecoyOutputCopies{entropy_i[0]}}};
293: 
294:   // The input invalid check is done whenever transactions are ongoing with kmac
295:   // once set, it cannot be unset until transactions are fully complete
296:   always_comb begin
297:     inputs_invalid_d = inputs_invalid_q;
298: 
299:     if (clr_err) begin
300:       inputs_invalid_d = '0;
301:     end else if (valid) begin
302:       inputs_invalid_d[OpAdvance]  = adv_en_i & (inputs_invalid_i[OpAdvance] |
303:                                                  inputs_invalid_q[OpAdvance]);
304:       inputs_invalid_d[OpGenId]    = id_en_i  & (inputs_invalid_i[OpGenId]   |
305:                                                  inputs_invalid_q[OpGenId]);
306:       inputs_invalid_d[OpGenSwOut] = gen_en_i & (inputs_invalid_i[OpGenSwOut]|
307:                                                  inputs_invalid_q[OpGenSwOut]);
308:       inputs_invalid_d[OpGenHwOut] = gen_en_i & (inputs_invalid_i[OpGenHwOut]|
309:                                                  inputs_invalid_q[OpGenHwOut]);
310:     end
311:   end
312: 
313:   // immediately assert errors
314:   assign inputs_invalid_o = |inputs_invalid_d;
315: 
316:   // Permute Share 1 of the entropy input once more to get the decoy data.
317:   // Share 0 and 1 are used as is for data_o (connected to the sideload ports).
318:   logic [RandWidth-1:0] decoy_entropy;
319:   assign decoy_entropy = perm_data(entropy_i[1], RndCnstRandPerm);
320:   assign decoy_data = {DecoyCopies{decoy_entropy}};
321: 
322:   logic [CntWidth-1:0] adv_sel, id_sel, gen_sel;
323:   assign adv_sel = LastAdvRound - cnt;
324:   assign id_sel = LastIdRound - cnt;
325:   assign gen_sel = LastGenRound - cnt;
326: 
327:   // The count is maintained as a downcount
328:   // so a subtract is necessary to send the right byte
329:   // alternatively we can also reverse the order of the input
330:   always_comb begin
331:     kmac_data_o.data  = decoy_data;
332:     if (|cmd_error_o || inputs_invalid_o || fsm_error_o) begin
333:       kmac_data_o.data  = decoy_data;
334:     end else if (valid && adv_en_i) begin
335:       kmac_data_o.data  = adv_data[adv_sel];
336:     end else if (valid && id_en_i) begin
337:       kmac_data_o.data  = id_data[id_sel];
338:     end else if (valid && gen_en_i) begin
339:       kmac_data_o.data  = gen_data[gen_sel];
340:     end
341:   end
342: 
343:   assign kmac_data_o.valid = valid;
344:   assign kmac_data_o.last  = last;
345:   assign kmac_data_o.strb  = strb;
346: 
347:   // kmac done is asserted outside of expected window
348:   // SEC_CM: KMAC_IF_DONE.CTRL.CONSISTENCY
349:   logic kmac_done_err_q, kmac_done_err_d;
350:   assign kmac_done_err_d = ~kmac_done_vld & kmac_data_i.done |
351:                            kmac_done_err_q;
352:   assign kmac_done_error_o = kmac_done_err_q;
353: 
354: 
355:   // the enables must be 1 hot
356:   logic [2:0] enables_d, enables_q, enables_sub;
357:   assign enables_d = {adv_en_i, id_en_i, gen_en_i};
358:   assign enables_sub = enables_d - 1'b1;
359: 
360:   // cross check to ensure the one-hot command that kicked off
361:   // the transaction remains consistent throughout.
362:   logic cmd_consty_err_q, cmd_consty_err_d;
363:   always_ff @(posedge clk_i or negedge rst_ni) begin
364:     if (!rst_ni) begin
365:       enables_q <= '0;
366:     end else if (cnt_set) begin
367:       enables_q <= enables_d;
368:     end
369:   end
370:   assign cmd_consty_err_d = (cmd_chk & (enables_q != enables_d)) |
371:                             cmd_consty_err_q;
372: 
373:   // if a one hot error occurs, latch onto it permanently
374:   // SEC_CM: KMAC_IF_CMD.CTRL.CONSISTENCY
375:   logic one_hot_err_q, one_hot_err_d;
376:   assign one_hot_err_d = |(enables_d & enables_sub) |
377:                          one_hot_err_q;
378: 
379:   always_ff @(posedge clk_i or negedge rst_ni) begin
380:     if (!rst_ni) begin
381:       one_hot_err_q <= '0;
382:       kmac_done_err_q <= '0;
383:       cmd_consty_err_q <= '0;
384:     end else begin
385:       one_hot_err_q <= one_hot_err_d;
386:       kmac_done_err_q <= kmac_done_err_d;
387:       cmd_consty_err_q <= cmd_consty_err_d;
388:     end
389:   end
390: 
391:   // command error occurs if kmac errors or if the command itself is invalid
392:   assign cmd_error_o = one_hot_err_q | cmd_consty_err_q;
393: 
394:   // request entropy to churn whenever a transaction is accepted
395:   assign prng_en_o = kmac_data_o.valid & kmac_data_i.ready;
396: 
397:   // as long as we are transmitting, the strobe should never be 0.
398:   `ASSERT(LastStrb_A, valid |-> strb != '0)
399: 
400: 
401: endmodule // keymgr_kmac_if

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_7LdV463wK6CJgiXYT0Ca1JYR)
 Call ID: call_7LdV463wK6CJgiXYT0Ca1JYR
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/rtl/keymgr.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Key manager top level
6: //
7: 
8: `include "prim_assert.sv"
9: 
10: module keymgr
11:   import keymgr_pkg::*;
12:   import keymgr_reg_pkg::*;
13: #(
14:   parameter logic [NumAlerts-1:0] AlertAsyncOn = {NumAlerts{1'b1}},
15:   // In case this is set to true, the keymgr will ignore the creator / owner seeds
16:   // on the flash_i port and use the seeds provided in otp_key_i instead.
17:   parameter bit UseOtpSeedsInsteadOfFlash      = 1'b0,
18:   parameter bit KmacEnMasking                  = 1'b1,
19:   parameter lfsr_seed_t RndCnstLfsrSeed        = RndCnstLfsrSeedDefault,
20:   parameter lfsr_perm_t RndCnstLfsrPerm        = RndCnstLfsrPermDefault,
21:   parameter rand_perm_t RndCnstRandPerm        = RndCnstRandPermDefault,
22:   parameter seed_t RndCnstRevisionSeed         = RndCnstRevisionSeedDefault,
23:   parameter seed_t RndCnstCreatorIdentitySeed  = RndCnstCreatorIdentitySeedDefault,
24:   parameter seed_t RndCnstOwnerIntIdentitySeed = RndCnstOwnerIntIdentitySeedDefault,
25:   parameter seed_t RndCnstOwnerIdentitySeed    = RndCnstOwnerIdentitySeedDefault,
26:   parameter seed_t RndCnstSoftOutputSeed       = RndCnstSoftOutputSeedDefault,
27:   parameter seed_t RndCnstHardOutputSeed       = RndCnstHardOutputSeedDefault,
28:   parameter seed_t RndCnstNoneSeed             = RndCnstNoneSeedDefault,
29:   parameter seed_t RndCnstAesSeed              = RndCnstAesSeedDefault,
30:   parameter seed_t RndCnstOtbnSeed             = RndCnstOtbnSeedDefault,
31:   parameter seed_t RndCnstKmacSeed             = RndCnstKmacSeedDefault,
32:   parameter seed_t RndCnstCdi                  = RndCnstCdiDefault
33: ) (
34:   input clk_i,
35:   input rst_ni,
36:   input rst_shadowed_ni,
37:   input clk_edn_i,
38:   input rst_edn_ni,
39: 
40:   // Bus Interface
41:   input  tlul_pkg::tl_h2d_t tl_i,
42:   output tlul_pkg::tl_d2h_t tl_o,
43: 
44:   // key interface to crypto modules
45:   output hw_key_req_t aes_key_o,
46:   output hw_key_req_t kmac_key_o,
47:   output otbn_key_req_t otbn_key_o,
48: 
49:   // data interface to/from crypto modules
50:   output kmac_pkg::app_req_t kmac_data_o,
51:   input  kmac_pkg::app_rsp_t kmac_data_i,
52: 
53:   // whether kmac is masked
54:   // Note this input is not driving ANY logic directly.  Instead it is only used
55:   // as part of assertions.  This is done because if boundary optimization were
56:   // ever disabled, it would provide a VERY obvious location for attacks.
57:   input kmac_en_masking_i,
58: 
59:   // the following signals should eventually be wrapped into structs from other modules
60:   // SEC_CM: LC_CTRL.INTERSIG.MUBI
61:   input lc_ctrl_pkg::lc_tx_t lc_keymgr_en_i,
62:   input lc_ctrl_pkg::lc_keymgr_div_t lc_keymgr_div_i,
63:   input otp_ctrl_pkg::otp_keymgr_key_t otp_key_i,
64:   input otp_ctrl_pkg::otp_device_id_t otp_device_id_i,
65:   input flash_ctrl_pkg::keymgr_flash_t flash_i,
66: 
67:   // connection to edn
68:   output edn_pkg::edn_req_t edn_o,
69:   input edn_pkg::edn_rsp_t edn_i,
70: 
71:   // connection to rom_ctrl
72:   input rom_ctrl_pkg::keymgr_data_t rom_digest_i,
73: 
74:   // interrupts and alerts
75:   output logic intr_op_done_o,
76:   input  prim_alert_pkg::alert_rx_t [keymgr_reg_pkg::NumAlerts-1:0] alert_rx_i,
77:   output prim_alert_pkg::alert_tx_t [keymgr_reg_pkg::NumAlerts-1:0] alert_tx_o
78: );
79: 
80:   `ASSERT_INIT(AdvDataWidth_A, AdvDataWidth <= KDFMaxWidth)
81:   `ASSERT_INIT(IdDataWidth_A,  IdDataWidth  <= KDFMaxWidth)
82:   `ASSERT_INIT(GenDataWidth_A, GenDataWidth <= KDFMaxWidth)
83:   `ASSERT_INIT(MaxWidthDivisible_A, KDFMaxWidth % KmacDataIfWidth == 0)
84:   `ASSERT_INIT(OutputKeyDiff_A, RndCnstHardOutputSeed != RndCnstSoftOutputSeed)
85: 
86:   import prim_mubi_pkg::mubi4_test_true_strict;
87:   import prim_mubi_pkg::mubi4_test_false_strict;
88:   import lc_ctrl_pkg::lc_tx_test_true_strict;
89:   import lc_ctrl_pkg::lc_tx_t;
90: 
91:   localparam int unsigned NumRomDigestInputs = 1;
92: 
93:   /////////////////////////////////////
94:   // Anchor incoming seeds and constants
95:   /////////////////////////////////////
96:   localparam int TotalSeedWidth = KeyWidth * 10;
97:   seed_t revision_seed;
98:   seed_t creator_identity_seed;
99:   seed_t owner_int_identity_seed;
100:   seed_t owner_identity_seed;
101:   seed_t soft_output_seed;
102:   seed_t hard_output_seed;
103:   seed_t aes_seed;
104:   seed_t otbn_seed;
105:   seed_t kmac_seed;
106:   seed_t none_seed;
107: 
108:   prim_sec_anchor_buf #(
109:     .Width(TotalSeedWidth)
110:   ) u_seed_anchor (
111:     .in_i({RndCnstRevisionSeed,
112:            RndCnstCreatorIdentitySeed,
113:            RndCnstOwnerIntIdentitySeed,
114:            RndCnstOwnerIdentitySeed,
115:            RndCnstSoftOutputSeed,
116:            RndCnstHardOutputSeed,
117:            RndCnstAesSeed,
118:            RndCnstOtbnSeed,
119:            RndCnstKmacSeed,
120:            RndCnstNoneSeed}),
121:     .out_o({revision_seed,
122:             creator_identity_seed,
123:             owner_int_identity_seed,
124:             owner_identity_seed,
125:             soft_output_seed,
126:             hard_output_seed,
127:             aes_seed,
128:             otbn_seed,
129:             kmac_seed,
130:             none_seed})
131:   );
132: 
133:   // Register module
134:   keymgr_reg2hw_t reg2hw;
135:   keymgr_hw2reg_t hw2reg;
136: 
137:   logic regfile_intg_err;
138:   logic shadowed_storage_err;
139:   logic shadowed_update_err;
140:   // SEC_CM: BUS.INTEGRITY
141:   // SEC_CM: CONFIG.SHADOW
142:   // SEC_CM: OP.CONFIG.REGWEN, RESEED.CONFIG.REGWEN, SW_BINDING.CONFIG.REGWEN
143:   // SEC_CM: MAX_KEY_VER.CONFIG.REGWEN
144:   keymgr_reg_top u_reg (
145:     .clk_i,
146:     .rst_ni,
147:     .rst_shadowed_ni,
148:     .tl_i,
149:     .tl_o,
150:     .reg2hw,
151:     .hw2reg,
152:     .shadowed_storage_err_o (shadowed_storage_err),
153:     .shadowed_update_err_o  (shadowed_update_err),
154:     .intg_err_o             (regfile_intg_err)
155:   );
156: 
157:   /////////////////////////////////////
158:   //  Synchronize lc_ctrl control inputs
159:   //  Data inputs are not synchronized and assumed quasi-static
160:   /////////////////////////////////////
161:   lc_tx_t [KeyMgrEnLast-1:0] lc_keymgr_en;
162: 
163:   prim_lc_sync #(
164:     .NumCopies(int'(KeyMgrEnLast))
165:   ) u_lc_keymgr_en_sync (
166:     .clk_i,
167:     .rst_ni,
168:     .lc_en_i(lc_keymgr_en_i),
169:     .lc_en_o(lc_keymgr_en)
170:   );
171: 
172: 
173:   /////////////////////////////////////
174:   //  LFSR
175:   /////////////////////////////////////
176: 
177:   // A farily large lfsr is used here as entropy in multiple places.
178:   // - populate the default working state
179:   // - generate random inputs when a bad input is selected
180:   //
181:   // The first case is sensitive, and thus the working state is constructed
182:   // through multiple rounds of the Lfsr
183:   // The second case is less sensitive and is applied directly.  If the inputs
184:   // have more bits than the lfsr output, the lfsr value is simply replicated
185: 
186:   logic lfsr_en;
187:   logic seed_en;
188:   logic [LfsrWidth-1:0] seed;
189:   logic reseed_req;
190:   logic reseed_ack;
191:   logic reseed_done;
192:   logic reseed_cnt_err;
193: 
194:   keymgr_reseed_ctrl u_reseed_ctrl (
195:     .clk_i,
196:     .rst_ni,
197:     .clk_edn_i,
198:     .rst_edn_ni,
199:     .reseed_req_i(reseed_req),
200:     .reseed_ack_o(reseed_ack),
201:     .reseed_done_o(reseed_done),
202:     .reseed_interval_i(reg2hw.reseed_interval_shadowed.q),
203:     .edn_o,
204:     .edn_i,
205:     .lfsr_en_i(lfsr_en),
206:     .seed_en_o(seed_en),
207:     .seed_o(seed),
208:     .cnt_err_o(reseed_cnt_err)
209:   );
210: 
211:   logic [63:0] lfsr;
212:   logic ctrl_lfsr_en, data_lfsr_en, sideload_lfsr_en;
213:   assign lfsr_en = ctrl_lfsr_en | data_lfsr_en | sideload_lfsr_en;
214: 
215:   prim_lfsr #(
216:     .LfsrDw(LfsrWidth),
217:     .StateOutDw(LfsrWidth),
218:     .DefaultSeed(RndCnstLfsrSeed),
219:     .StatePermEn(1'b1),
220:     .StatePerm(RndCnstLfsrPerm),
221:     .NonLinearOut(1'b1)
222:   ) u_lfsr (
223:     .clk_i,
224:     .rst_ni,
225:     .lfsr_en_i(lfsr_en),
226:     .seed_en_i(seed_en),
227:     .seed_i(seed),
228:     .entropy_i('0),
229:     .state_o(lfsr)
230:   );
231:   `ASSERT_INIT(LfsrWidth_A, LfsrWidth == 64)
232: 
233: 
234:   logic [Shares-1:0][RandWidth-1:0] ctrl_rand;
235:   logic [Shares-1:0][RandWidth-1:0] data_rand;
236: 
237:   assign ctrl_rand[0] = lfsr[63:32];
238:   assign ctrl_rand[1] = perm_data(lfsr[31:0], RndCnstRandPerm);
239: 
240:   assign data_rand[0] = lfsr[31:0];
241:   assign data_rand[1] = perm_data(lfsr[63:32], RndCnstRandPerm);
242: 
243:   /////////////////////////////////////
244:   //  Key Manager Control
245:   /////////////////////////////////////
246: 
247:   keymgr_stage_e stage_sel;
248:   logic invalid_stage_sel;
249:   prim_mubi_pkg::mubi4_t hw_key_sel;
250:   logic adv_en, id_en, gen_en;
251:   logic wipe_key;
252:   hw_key_req_t kmac_key;
253:   logic op_done;
254:   logic init;
255:   logic data_valid;
256:   logic data_hw_en;
257:   logic data_sw_en;
258:   logic kmac_done;
259:   logic kmac_input_invalid;
260:   logic kmac_cmd_err;
261:   logic kmac_fsm_err;
262:   logic kmac_op_err;
263:   logic kmac_done_err;
264:   logic [Shares-1:0][kmac_pkg::AppDigestW-1:0] kmac_data;
265:   logic [Shares-1:0][KeyWidth-1:0] kmac_data_truncated;
266:   logic [ErrLastPos-1:0] err_code;
267:   logic [FaultLastPos-1:0] fault_code;
268:   logic sw_binding_unlock;
269:   logic [CdiWidth-1:0] cdi_sel;
270:   logic sideload_fsm_err;
271:   logic sideload_sel_err;
272: 
273:   for (genvar i = 0; i < Shares; i++) begin : gen_truncate_data
274:     assign kmac_data_truncated[i] = kmac_data[i][KeyWidth-1:0];
275:   end
276: 
277:   logic op_start;
278:   assign op_start = reg2hw.start.q;
279:   keymgr_ctrl #(
280:     .KmacEnMasking(KmacEnMasking)
281:   ) u_ctrl (
282:     .clk_i,
283:     .rst_ni,
284:     .en_i(lc_tx_test_true_strict(lc_keymgr_en[KeyMgrEnCtrl])),
285:     .regfile_intg_err_i(regfile_intg_err),
286:     .shadowed_update_err_i(shadowed_update_err),
287:     .shadowed_storage_err_i(shadowed_storage_err),
288:     .reseed_cnt_err_i(reseed_cnt_err),
289:     .sideload_sel_err_i(sideload_sel_err),
290:     .sideload_fsm_err_i(sideload_fsm_err),
291:     .prng_reseed_req_o(reseed_req),
292:     .prng_reseed_ack_i(reseed_ack),
293:     .prng_reseed_done_i(reseed_done),
294:     .prng_en_o(ctrl_lfsr_en),
295:     .entropy_i(ctrl_rand),
296:     .op_i(keymgr_ops_e'(reg2hw.control_shadowed.operation.q)),
297:     .op_start_i(op_start),
298:     .op_cdi_sel_i(reg2hw.control_shadowed.cdi_sel.q),
299:     .op_done_o(op_done),
300:     .init_o(init),
301:     .sw_binding_unlock_o(sw_binding_unlock),
302:     .status_o(hw2reg.op_status.d),
303:     .fault_o(fault_code),
304:     .error_o(err_code),
305:     .data_hw_en_o(data_hw_en),
306:     .data_sw_en_o(data_sw_en),
307:     .data_valid_o(data_valid),
308:     .working_state_o(hw2reg.working_state.d),
309:     .root_key_i(otp_key_i),
310:     .hw_sel_o(hw_key_sel),
311:     .stage_sel_o(stage_sel),
312:     .invalid_stage_sel_o(invalid_stage_sel),
313:     .cdi_sel_o(cdi_sel),
314:     .wipe_key_o(wipe_key),
315:     .adv_en_o(adv_en),
316:     .id_en_o(id_en),
317:     .gen_en_o(gen_en),
318:     .key_o(kmac_key),
319:     .kmac_done_i(kmac_done),
320:     .kmac_input_invalid_i(kmac_input_invalid),
321:     .kmac_fsm_err_i(kmac_fsm_err),
322:     .kmac_op_err_i(kmac_op_err),
323:     .kmac_done_err_i(kmac_done_err),
324:     .kmac_cmd_err_i(kmac_cmd_err),
325:     .kmac_data_i(kmac_data_truncated)
326:   );
327: 
328:   assign hw2reg.start.d  = '0;
329:   assign hw2reg.start.de = op_done;
330:   // as long as operation is ongoing, capture status
331:   assign hw2reg.op_status.de = op_start;
332: 
333:   // working state is always visible
334:   assign hw2reg.working_state.de = 1'b1;
335: 
336:   logic cfg_regwen;
337: 
338:   // key manager registers cannot be changed once an operation starts
339:   keymgr_cfg_en u_cfgen (
340:     .clk_i,
341:     .rst_ni,
342:     .init_i(1'b1), // cfg_regwen does not care about init
343:     .en_i(lc_tx_test_true_strict(lc_keymgr_en[KeyMgrEnCfgEn])),
344:     .set_i(op_start & op_done),
345:     .clr_i(op_start),
346:     .out_o(cfg_regwen)
347:   );
348: 
349:   assign hw2reg.cfg_regwen.d = cfg_regwen;
350: 
351: 
352:   logic sw_binding_clr;
353:   logic sw_binding_regwen;
354: 
355:   // this is w0c
356:   assign sw_binding_clr = reg2hw.sw_binding_regwen.qe & ~reg2hw.sw_binding_regwen.q;
357: 
358:   // software clears the enable
359:   // hardware restores it upon successful advance
360:   keymgr_cfg_en #(
361:     .NonInitClr(1'b1)  // clear has an effect regardless of init state
362:   ) u_sw_binding_regwen (
363:     .clk_i,
364:     .rst_ni,
365:     .init_i(init),
366:     .en_i(lc_tx_test_true_strict(lc_keymgr_en[KeyMgrEnSwBindingEn])),
367:     .set_i(sw_binding_unlock),
368:     .clr_i(sw_binding_clr),
369:     .out_o(sw_binding_regwen)
370:   );
371: 
372:   assign hw2reg.sw_binding_regwen.d = sw_binding_regwen & cfg_regwen;
373: 
374:   /////////////////////////////////////
375:   //  Key Manager Input Construction
376:   /////////////////////////////////////
377: 
378:   // The various arrays of inputs for each operation
379:   logic rom_digest_vld;
380:   logic [2**StageWidth-1:0][AdvDataWidth-1:0] adv_matrix;
381:   logic [2**StageWidth-1:0] adv_dvalid;
382:   logic [2**StageWidth-1:0][IdDataWidth-1:0] id_matrix;
383:   logic [GenDataWidth-1:0] gen_in;
384: 
385:   // The max key version for each stage
386:   logic [2**StageWidth-1:0][31:0] max_key_versions;
387: 
388:   // Number of times the lfsr output fits into the inputs
389:   localparam int AdvLfsrCopies = AdvDataWidth / 32;
390:   localparam int IdLfsrCopies = IdDataWidth / 32;
391:   localparam int GenLfsrCopies = GenDataWidth / 32;
392: 
393:   // input checking
394:   logic creator_seed_vld;
395:   logic owner_seed_vld;
396:   logic devid_vld;
397:   logic health_state_vld;
398:   logic key_version_vld;
399: 
400:   // software binding
401:   logic [SwBindingWidth-1:0] sw_binding;
402:   assign sw_binding = (cdi_sel == 0) ? reg2hw.sealing_sw_binding :
403:                       (cdi_sel == 1) ? reg2hw.attest_sw_binding  : RndCnstCdi;
404: 
405:   // Advance state operation input construction
406:   for (genvar i = KeyMgrStages; i < 2**StageWidth; i++) begin : gen_adv_matrix_fill
407:     assign adv_matrix[i] = {AdvLfsrCopies{data_rand[0]}};
408:     assign adv_dvalid[i] = 1'b1;
409:   end
410: 
411:   // Advance to creator_root_key
412:   // The values coming from otp_ctrl / lc_ctrl are treat as quasi-static for CDC purposes
413:   logic [KeyWidth-1:0] creator_seed;
414:   logic unused_creator_seed;
415:   if (UseOtpSeedsInsteadOfFlash) begin : gen_otp_creator_seed
416:     assign unused_creator_seed = ^{flash_i.seeds[flash_ctrl_pkg::CreatorSeedIdx],
417:                                    otp_key_i.creator_seed_valid};
418:     assign creator_seed = otp_key_i.creator_seed;
419:   end else begin : gen_flash_creator_seed
420:     assign unused_creator_seed = ^{otp_key_i.creator_seed,
421:                                    otp_key_i.creator_seed_valid};
422:     assign creator_seed = flash_i.seeds[flash_ctrl_pkg::CreatorSeedIdx];
423:   end
424:   // TODO(opentitan-integrated/issues/251):
425:   // replace below code with commented code once SW and DV model can handle multiple
426:   // // ROM_CTRL digests.
427:   // logic [KeyWidth*NumRomDigestInputs-1:0] rom_digests;
428:   // always_comb begin
429:   //   rom_digests = '0;
430:   //   for (int k = 0; k < NumRomDigestInputs; k++) begin
431:   //     rom_digests[KeyWidth*k +: KeyWidth] = rom_digest_i[k].data;
432:   //   end
433:   // end
434:   // assign adv_matrix[Creator] = AdvDataWidth'({sw_binding,
435:   //                                             otp_device_id_i,
436:   //                                             lc_keymgr_div_i,
437:   //                                             rom_digests,
438:   //                                             revision_seed});
439:   assign adv_matrix[Creator] = AdvDataWidth'({sw_binding,
440:                                               otp_device_id_i,
441:                                               lc_keymgr_div_i,
442:                                               rom_digest_i.data,
443:                                               revision_seed});
444: 
445:   assign adv_dvalid[Creator] = creator_seed_vld &
446:                                devid_vld &
447:                                health_state_vld &
448:                                rom_digest_vld;
449: 
450:   // Advance to owner_intermediate_key
451:   logic [KeyWidth-1:0] owner_seed;
452:   logic unused_owner_seed;
453:   if (UseOtpSeedsInsteadOfFlash) begin : gen_otp_owner_seed
454:     assign unused_owner_seed = ^{flash_i.seeds[flash_ctrl_pkg::OwnerSeedIdx],
455:                                  otp_key_i.owner_seed_valid};
456:     assign owner_seed = otp_key_i.owner_seed;
457:   end else begin : gen_flash_owner_seed
458:     assign unused_owner_seed = ^{otp_key_i.owner_seed,
459:                                  otp_key_i.owner_seed_valid};
460:     assign owner_seed = flash_i.seeds[flash_ctrl_pkg::OwnerSeedIdx];
461:   end
462:   assign adv_matrix[OwnerInt] = AdvDataWidth'({sw_binding, creator_seed});
463:   assign adv_dvalid[OwnerInt] = owner_seed_vld;
464: 
465:   // Advance to owner_key
466:   assign adv_matrix[Owner] = AdvDataWidth'({sw_binding, owner_seed});
467:   assign adv_dvalid[Owner] = 1'b1;
468: 
469:   // Generate Identity operation input construction
470:   for (genvar i = KeyMgrStages; i < 2**StageWidth; i++) begin : gen_id_matrix_fill
471:     assign id_matrix[i] = {IdLfsrCopies{data_rand[0]}};
472:   end
473: 
474:   assign id_matrix[Creator]  = creator_identity_seed;
475:   assign id_matrix[OwnerInt] = owner_int_identity_seed;
476:   assign id_matrix[Owner]    = owner_identity_seed;
477: 
478: 
479:   // Generate output operation input construction
480:   logic [KeyWidth-1:0] output_key;
481:   keymgr_key_dest_e dest_sel;
482:   logic [KeyWidth-1:0] dest_seed;
483: 
484:   assign dest_sel = keymgr_key_dest_e'(reg2hw.control_shadowed.dest_sel.q);
485:   assign dest_seed = dest_sel == Aes  ? aes_seed  :
486:                        dest_sel == Kmac ? kmac_seed :
487:                        dest_sel == Otbn ? otbn_seed : none_seed;
488:   assign output_key = mubi4_test_true_strict(hw_key_sel) ? hard_output_seed :
489:                       soft_output_seed;
490:   assign gen_in = invalid_stage_sel ? {GenLfsrCopies{lfsr[31:0]}} : {reg2hw.key_version,
491:                                                                      reg2hw.salt,
492:                                                                      dest_seed,
493:                                                                      output_key};
494: 
495:   // Advance state operation input construction
496:   for (genvar i = KeyMgrStages; i < 2**StageWidth; i++) begin : gen_key_version_fill
497:     assign max_key_versions[i] = '0;
498:   end
499: 
500:   assign max_key_versions[Creator]  = reg2hw.max_creator_key_ver_shadowed.q;
501:   assign max_key_versions[OwnerInt] = reg2hw.max_owner_int_key_ver_shadowed.q;
502:   assign max_key_versions[Owner]    = reg2hw.max_owner_key_ver_shadowed.q;
503: 
504:   logic [KeyVersionWidth-1:0] cur_max_key_version;
505:   assign cur_max_key_version = max_key_versions[stage_sel];
506: 
507:   // General module for checking inputs
508:   logic key_vld;
509:   // SEC_CM: CONSTANTS.CONSISTENCY
510:   // SEC_CM: INTERSIG.CONSISTENCY
511:   keymgr_input_checks #(
512:     .KmacEnMasking(KmacEnMasking),
513:     .NumRomDigestInputs(NumRomDigestInputs)
514:   ) u_checks (
515:     .rom_digest_i,
516:     .cur_max_key_version_i(cur_max_key_version),
517:     .key_version_i(reg2hw.key_version),
518:     .creator_seed_i(creator_seed),
519:     .owner_seed_i(owner_seed),
520:     .key_i(kmac_key_o),
521:     .devid_i(otp_device_id_i),
522:     .health_state_i(HealthStateWidth'(lc_keymgr_div_i)),
523:     .creator_seed_vld_o(creator_seed_vld),
524:     .owner_seed_vld_o(owner_seed_vld),
525:     .devid_vld_o(devid_vld),
526:     .health_state_vld_o(health_state_vld),
527:     .key_version_vld_o(key_version_vld),
528:     .key_vld_o(key_vld),
529:     .rom_digest_vld_o(rom_digest_vld)
530:   );
531: 
532:   assign hw2reg.debug.invalid_creator_seed.d = 1'b1;
533:   assign hw2reg.debug.invalid_owner_seed.d = 1'b1;
534:   assign hw2reg.debug.invalid_dev_id.d = 1'b1;
535:   assign hw2reg.debug.invalid_health_state.d = 1'b1;
536:   assign hw2reg.debug.invalid_key_version.d = 1'b1;
537:   assign hw2reg.debug.invalid_key.d = 1'b1;
538:   assign hw2reg.debug.invalid_digest.d = 1'b1;
539: 
540:   logic valid_op;
541:   assign valid_op = adv_en | id_en | gen_en;
542:   assign hw2reg.debug.invalid_creator_seed.de = adv_en & (stage_sel == Creator) & ~creator_seed_vld;
543:   assign hw2reg.debug.invalid_owner_seed.de = adv_en & (stage_sel == OwnerInt) & ~owner_seed_vld;
544:   assign hw2reg.debug.invalid_dev_id.de = adv_en & (stage_sel == Creator) & ~devid_vld;
545:   assign hw2reg.debug.invalid_health_state.de = adv_en & (stage_sel == Creator) & ~health_state_vld;
546:   assign hw2reg.debug.invalid_key_version.de = gen_en & ~key_version_vld;
547:   assign hw2reg.debug.invalid_key.de = valid_op & ~key_vld;
548:   assign hw2reg.debug.invalid_digest.de = adv_en & (stage_sel == Creator) & ~rom_digest_vld;
549: 
550:   /////////////////////////////////////
551:   //  KMAC Control
552:   /////////////////////////////////////
553: 
554:   logic [3:0] invalid_data;
555:   assign invalid_data[OpAdvance]  = ~key_vld | ~adv_dvalid[stage_sel];
556:   assign invalid_data[OpGenId]    = ~key_vld;
557:   assign invalid_data[OpGenSwOut] = ~key_vld | ~key_version_vld;
558:   assign invalid_data[OpGenHwOut] = ~key_vld | ~key_version_vld;
559: 
560:   keymgr_kmac_if #(
561:     .RndCnstRandPerm(RndCnstRandPerm)
562:   ) u_kmac_if (
563:     .clk_i,
564:     .rst_ni,
565:     .prng_en_o(data_lfsr_en),
566:     .adv_data_i(adv_matrix[stage_sel]),
567:     .id_data_i(id_matrix[stage_sel]),
568:     .gen_data_i(gen_in),
569:     .inputs_invalid_i(invalid_data),
570:     .inputs_invalid_o(kmac_input_invalid),
571:     .adv_en_i(adv_en),
572:     .id_en_i(id_en),
573:     .gen_en_i(gen_en),
574:     .done_o(kmac_done),
575:     .data_o(kmac_data),
576:     .kmac_data_o,
577:     .kmac_data_i,
578:     .entropy_i(data_rand),
579:     .fsm_error_o(kmac_fsm_err),
580:     .kmac_error_o(kmac_op_err),
581:     .kmac_done_error_o(kmac_done_err),
582:     .cmd_error_o(kmac_cmd_err)
583:   );
584: 
585: 
586:   /////////////////////////////////////
587:   //  Side load key storage
588:   /////////////////////////////////////
589:   // SEC_CM: HW.KEY.SW_NOACCESS
590:   keymgr_sideload_key_ctrl u_sideload_ctrl (
591:     .clk_i,
592:     .rst_ni,
593:     .init_i(init),
594:     .entropy_i(data_rand),
595:     .clr_key_i(keymgr_sideload_clr_e'(reg2hw.sideload_clear.q)),
596:     .wipe_key_i(wipe_key),
597:     .dest_sel_i(dest_sel),
598:     .hw_key_sel_i(hw_key_sel),
599:     // SEC_CM: OUTPUT_KEYS.CTRL.REDUN
600:     .data_en_i(data_hw_en),
601:     .data_valid_i(data_valid),
602:     .key_i(kmac_key),
603:     .data_i(kmac_data),
604:     .prng_en_o(sideload_lfsr_en),
605:     .aes_key_o,
606:     .otbn_key_o,
607:     .kmac_key_o,
608:     .sideload_sel_err_o(sideload_sel_err),
609:     .fsm_err_o(sideload_fsm_err)
610:   );
611: 
612:   for (genvar i = 0; i < 8; i++) begin : gen_sw_assigns
613: 
614:     prim_mubi_pkg::mubi4_t [1:0] hw_key_sel_buf;
615:     prim_mubi4_sync #(
616:       .NumCopies(2),
617:       .AsyncOn(0)
618:     ) u_mubi_buf (
619:       .clk_i,
620:       .rst_ni,
621:       .mubi_i(hw_key_sel),
622:       .mubi_o(hw_key_sel_buf)
623:     );
624: 
625:     // SEC_CM: OUTPUT_KEYS.CTRL.REDUN
626:     prim_sec_anchor_buf #(
627:      .Width(32)
628:     ) u_prim_buf_share0_d (
629:       .in_i(~data_sw_en | wipe_key ? data_rand[0] : kmac_data[0][i*32 +: 32]),
630:       .out_o(hw2reg.sw_share0_output[i].d)
631:     );
632: 
633:     prim_sec_anchor_buf #(
634:      .Width(32)
635:     ) u_prim_buf_share1_d (
636:       .in_i(~data_sw_en | wipe_key ? data_rand[1] : kmac_data[1][i*32 +: 32]),
637:       .out_o(hw2reg.sw_share1_output[i].d)
638:     );
639: 
640:     prim_sec_anchor_buf #(
641:      .Width(1)
642:     ) u_prim_buf_share0_de (
643:       .in_i(wipe_key | data_valid & mubi4_test_false_strict(hw_key_sel_buf[0])),
644:       .out_o(hw2reg.sw_share0_output[i].de)
645:     );
646: 
647:     prim_sec_anchor_buf #(
648:      .Width(1)
649:     ) u_prim_buf_share1_de (
650:       .in_i(wipe_key | data_valid & mubi4_test_false_strict(hw_key_sel_buf[1])),
651:       .out_o(hw2reg.sw_share1_output[i].de)
652:     );
653:   end
654: 
655:   /////////////////////////////////////
656:   //  Alerts and Interrupts
657:   /////////////////////////////////////
658: 
659:   prim_intr_hw #(.Width(1)) u_intr_op_done (
660:     .clk_i,
661:     .rst_ni,
662:     .event_intr_i           (op_done),
663:     .reg2hw_intr_enable_q_i (reg2hw.intr_enable.q),
664:     .reg2hw_intr_test_q_i   (reg2hw.intr_test.q),
665:     .reg2hw_intr_test_qe_i  (reg2hw.intr_test.qe),
666:     .reg2hw_intr_state_q_i  (reg2hw.intr_state.q),
667:     .hw2reg_intr_state_de_o (hw2reg.intr_state.de),
668:     .hw2reg_intr_state_d_o  (hw2reg.intr_state.d),
669:     .intr_o                 (intr_op_done_o)
670:   );
671: 
672:   assign hw2reg.err_code.invalid_op.d             = 1'b1;
673:   assign hw2reg.err_code.invalid_kmac_input.d     = 1'b1;
674:   assign hw2reg.err_code.invalid_shadow_update.d  = 1'b1;
675:   assign hw2reg.err_code.invalid_op.de            = err_code[ErrInvalidOp];
676:   assign hw2reg.err_code.invalid_kmac_input.de    = err_code[ErrInvalidIn];
677:   assign hw2reg.err_code.invalid_shadow_update.de = err_code[ErrShadowUpdate];
678: 
679:   assign hw2reg.fault_status.cmd.de           = fault_code[FaultKmacCmd];
680:   assign hw2reg.fault_status.kmac_fsm.de      = fault_code[FaultKmacFsm];
681:   assign hw2reg.fault_status.kmac_op.de       = fault_code[FaultKmacOp];
682:   assign hw2reg.fault_status.kmac_done.de     = fault_code[FaultKmacDone];
683:   assign hw2reg.fault_status.kmac_out.de      = fault_code[FaultKmacOut];
684:   assign hw2reg.fault_status.regfile_intg.de  = fault_code[FaultRegIntg];
685:   assign hw2reg.fault_status.shadow.de        = fault_code[FaultShadow];
686:   assign hw2reg.fault_status.ctrl_fsm_intg.de = fault_code[FaultCtrlFsm];
687:   assign hw2reg.fault_status.ctrl_fsm_chk.de  = fault_code[FaultCtrlFsmChk];
688:   assign hw2reg.fault_status.ctrl_fsm_cnt.de  = fault_code[FaultCtrlCnt];
689:   assign hw2reg.fault_status.reseed_cnt.de    = fault_code[FaultReseedCnt];
690:   assign hw2reg.fault_status.side_ctrl_fsm.de = fault_code[FaultSideFsm];
691:   assign hw2reg.fault_status.side_ctrl_sel.de = fault_code[FaultSideSel];
692:   assign hw2reg.fault_status.key_ecc.de       = fault_code[FaultKeyEcc];
693:   assign hw2reg.fault_status.cmd.d            = 1'b1;
694:   assign hw2reg.fault_status.kmac_fsm.d       = 1'b1;
695:   assign hw2reg.fault_status.kmac_done.d      = 1'b1;
696:   assign hw2reg.fault_status.kmac_op.d        = 1'b1;
697:   assign hw2reg.fault_status.kmac_out.d       = 1'b1;
698:   assign hw2reg.fault_status.regfile_intg.d   = 1'b1;
699:   assign hw2reg.fault_status.shadow.d         = 1'b1;
700:   assign hw2reg.fault_status.ctrl_fsm_intg.d  = 1'b1;
701:   assign hw2reg.fault_status.ctrl_fsm_chk.d   = 1'b1;
702:   assign hw2reg.fault_status.ctrl_fsm_cnt.d   = 1'b1;
703:   assign hw2reg.fault_status.reseed_cnt.d     = 1'b1;
704:   assign hw2reg.fault_status.side_ctrl_fsm.d  = 1'b1;
705:   assign hw2reg.fault_status.side_ctrl_sel.d  = 1'b1;
706:   assign hw2reg.fault_status.key_ecc.d        = 1'b1;
707: 
708:   // There are two types of alerts
709:   // - alerts for hardware errors, these could not have been generated by software.
710:   // - alerts for errors that may have been generated by software.
711: 
712:   logic fault_errs, fault_err_req_q, fault_err_req_d, fault_err_ack;
713:   logic op_errs, op_err_req_q, op_err_req_d, op_err_ack;
714: 
715:   // Fault status can happen independently of any operation
716:   assign fault_errs = |reg2hw.fault_status;
717: 
718:   assign fault_err_req_d = fault_errs    ? 1'b1 :
719:                            fault_err_ack ? 1'b0 : fault_err_req_q;
720: 
721:   assign op_errs = |err_code;
722:   assign op_err_req_d = op_errs    ? 1'b1 :
723:                         op_err_ack ? 1'b0 : op_err_req_q;
724: 
725:   always_ff @(posedge clk_i or negedge rst_ni) begin
726:     if (!rst_ni) begin
727:       fault_err_req_q <= '0;
728:       op_err_req_q <= '0;
729:     end else begin
730:       fault_err_req_q <= fault_err_req_d;
731:       op_err_req_q <= op_err_req_d;
732:     end
733:   end
734: 
735:   logic fault_alert_test;
736:   assign fault_alert_test = reg2hw.alert_test.fatal_fault_err.q &
737:                             reg2hw.alert_test.fatal_fault_err.qe;
738:   prim_alert_sender #(
739:     .AsyncOn(AlertAsyncOn[1]),
740:     .IsFatal(1)
741:   ) u_fault_alert (
742:     .clk_i,
743:     .rst_ni,
744:     .alert_test_i(fault_alert_test),
745:     .alert_req_i(fault_err_req_q),
746:     .alert_ack_o(fault_err_ack),
747:     .alert_state_o(),
748:     .alert_rx_i(alert_rx_i[1]),
749:     .alert_tx_o(alert_tx_o[1])
750:   );
751: 
752:   logic op_err_alert_test;
753:   assign op_err_alert_test = reg2hw.alert_test.recov_operation_err.q &
754:                              reg2hw.alert_test.recov_operation_err.qe;
755:   prim_alert_sender #(
756:     .AsyncOn(AlertAsyncOn[0]),
757:     .IsFatal(0)
758:   ) u_op_err_alert (
759:     .clk_i,
760:     .rst_ni,
761:     .alert_test_i(op_err_alert_test),
762:     .alert_req_i(op_err_req_q),
763:     .alert_ack_o(op_err_ack),
764:     .alert_state_o(),
765:     .alert_rx_i(alert_rx_i[0]),
766:     .alert_tx_o(alert_tx_o[0])
767:   );
768: 
769:   // known asserts
770:   `ASSERT_KNOWN(TlDValidKnownO_A, tl_o.d_valid)
771:   `ASSERT_KNOWN(TlAReadyKnownO_A, tl_o.a_ready)
772:   `ASSERT_KNOWN(IntrKnownO_A, intr_op_done_o)
773:   `ASSERT_KNOWN(AlertKnownO_A, alert_tx_o)
774: 
775:   `ASSERT_KNOWN(AesKeyKnownO_A,  aes_key_o)
776:   `ASSERT_KNOWN(KmacKeyKnownO_A, kmac_key_o)
777:   `ASSERT_KNOWN(OtbnKeyKnownO_A, otbn_key_o)
778:   `ASSERT_KNOWN(KmacDataKnownO_A, kmac_data_o)
779: 
780: 
781:   // kmac parameter consistency
782:   // Both modules must be consistent with regards to masking assumptions
783:   logic unused_kmac_en_masking;
784:   assign unused_kmac_en_masking = kmac_en_masking_i;
785: 
786:   `ASSERT_INIT_NET(KmacMaskCheck_A, KmacEnMasking == kmac_en_masking_i)
787: 
788:   // Ensure all parameters are consistent
789:   `ASSERT_INIT(FaultCntMatch_A, FaultLastPos == AsyncFaultLastIdx + SyncFaultLastIdx)
790:   `ASSERT_INIT(ErrCntMatch_A, ErrLastPos == AsyncErrLastIdx + SyncErrLastIdx)
791:   `ASSERT_INIT(StageMatch_A, KeyMgrStages == Disable)
792: 
793:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(CtrlCntAlertCheck_A, u_ctrl.u_cnt, alert_tx_o[1])
794:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(KmacIfCntAlertCheck_A, u_kmac_if.u_cnt, alert_tx_o[1])
795:   `ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT(ReseedCtrlCntAlertCheck_A, u_reseed_ctrl.u_reseed_cnt,
796:                                          alert_tx_o[1])
797:   `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(CtrlMainFsmCheck_A, u_ctrl.u_state_regs, alert_tx_o[1])
798:   `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(CtrlDataFsmCheck_A,
799:       u_ctrl.u_data_en.u_state_regs, alert_tx_o[1])
800:   `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(CtrlOpFsmCheck_A,
801:       u_ctrl.u_op_state.u_state_regs, alert_tx_o[1])
802:   `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(KmacIfFsmCheck_A, u_kmac_if.u_state_regs, alert_tx_o[1])
803:   `ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT(SideloadCtrlFsmCheck_A,
804:       u_sideload_ctrl.u_state_regs, alert_tx_o[1])
805: 
806:   // Alert assertions for reg_we onehot check
807:   `ASSERT_PRIM_REG_WE_ONEHOT_ERROR_TRIGGER_ALERT(RegWeOnehotCheck_A, u_reg, alert_tx_o[1])
808: endmodule // keymgr

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_2yyStEmzrsKS2t8FqNSgU6ie)
 Call ID: call_2yyStEmzrsKS2t8FqNSgU6ie
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/rtl/keymgr_input_checks.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Key manager input checks
6: // Checks input data for errors
7: 
8: `include "prim_assert.sv"
9: 
10: // We should also check for input validity
11: module keymgr_input_checks import keymgr_pkg::*; #(
12:   parameter bit          KmacEnMasking      = 1'b1,
13:   parameter int unsigned NumRomDigestInputs = 1
14: ) (
15:   input rom_ctrl_pkg::keymgr_data_t [NumRomDigestInputs-1:0] rom_digest_i,
16:   input [KeyVersionWidth-1:0] cur_max_key_version_i,
17:   input hw_key_req_t key_i,
18:   input [31:0] key_version_i,
19:   input [KeyWidth-1:0] creator_seed_i,
20:   input [KeyWidth-1:0] owner_seed_i,
21:   input [DevIdWidth-1:0] devid_i,
22:   input [HealthStateWidth-1:0] health_state_i,
23:   output logic creator_seed_vld_o,
24:   output logic owner_seed_vld_o,
25:   output logic devid_vld_o,
26:   output logic health_state_vld_o,
27:   output logic key_version_vld_o,
28:   output logic key_vld_o,
29:   output logic rom_digest_vld_o
30: );
31:   // checks for all 0's or all 1's of value
32:   function automatic logic valid_chk (logic [MaxWidth-1:0] value);
33:     return |value & ~&value;
34:   endfunction // valid_chk
35: 
36:   // key version must be smaller than or equal to max version
37:   assign key_version_vld_o = key_version_i <= cur_max_key_version_i;
38: 
39:   // general data check
40:   logic [MaxWidth-1:0] creator_seed_padded, owner_seed_padded, devid_padded, health_state_padded;
41: 
42:   prim_msb_extend #(
43:     .InWidth(KeyWidth),
44:     .OutWidth(MaxWidth)
45:   ) u_creator_seed (
46:     .in_i(creator_seed_i),
47:     .out_o(creator_seed_padded)
48:   );
49: 
50:   prim_msb_extend #(
51:     .InWidth(KeyWidth),
52:     .OutWidth(MaxWidth)
53:   ) u_owner_seed (
54:     .in_i(owner_seed_i),
55:     .out_o(owner_seed_padded)
56:   );
57: 
58:   prim_msb_extend #(
59:     .InWidth(DevIdWidth),
60:     .OutWidth(MaxWidth)
61:   ) u_devid (
62:     .in_i(devid_i),
63:     .out_o(devid_padded)
64:   );
65: 
66:   prim_msb_extend #(
67:     .InWidth(HealthStateWidth),
68:     .OutWidth(MaxWidth)
69:   ) u_health_state (
70:     .in_i(health_state_i),
71:     .out_o(health_state_padded)
72:   );
73: 
74:   assign creator_seed_vld_o = valid_chk(creator_seed_padded);
75:   assign owner_seed_vld_o = valid_chk(owner_seed_padded);
76:   assign devid_vld_o = valid_chk(devid_padded);
77:   assign health_state_vld_o = valid_chk(health_state_padded);
78: 
79:   // key check
80:   logic unused_key_vld;
81:   assign unused_key_vld = key_i.valid;
82: 
83:   localparam int KeyShares = KmacEnMasking ? Shares : 1;
84:   logic [KeyShares-1:0][MaxWidth-1:0] key_padded;
85:   logic [KeyShares-1:0] key_chk;
86: 
87:   for (genvar i = 0; i < KeyShares; i++) begin : gen_key_chk
88:     prim_msb_extend #(
89:       .InWidth(KeyWidth),
90:       .OutWidth(MaxWidth)
91:     ) u_key_pad (
92:       .in_i(key_i.key[i]),
93:       .out_o(key_padded[i])
94:     );
95: 
96:     assign key_chk[i] = valid_chk(key_padded[i]);
97:   end
98: 
99:   assign key_vld_o = &key_chk;
100: 
101:   always_comb begin
102:     rom_digest_vld_o = 1'b1;
103:     for (int k = 0; k < NumRomDigestInputs; k++) begin
104:       rom_digest_vld_o &= rom_digest_i[k].valid && valid_chk(MaxWidth'(rom_digest_i[k].data));
105:     end
106:   end
107: 
108: endmodule // keymgr_input_checks

================================== Ai Message ==================================
Tool Calls:
  run_anomaly_detector_agent (call_UiY4BO1KjasUsrsgnLosFWcz)
 Call ID: call_UiY4BO1KjasUsrsgnLosFWcz
  Args:
    design_filepath: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/rtl/keymgr_ctrl.sv
    top_module: keymgr_ctrl
    security_objective: No secret leakage in invalid/disabled states; masking and sideload isolation; state machine transitions
================================= Tool Message =================================
Name: run_anomaly_detector_agent

I ran the anomaly detector over keymgr_ctrl.sv and inspected the clusters it produced. The detector clusters pointed me to several places with patterns that differ from the rest of the file; after reviewing those spots I found three anomalous code snippets. I describe each anomaly, explain whether it is a security issue, and give a recommended fix and test.

Summary (short)
- Critical security issue: key output logic in key_output_ctrl exposes unmasked key material in the StCtrlInvalid state. This is secret leakage.
- Likely security-relevant logic/precedence bugs that can affect masking/stage selection: a ternary/OR precedence expression in StCtrlOwnerKey (stage_sel_o) and an inconsistent entropy index in KeyUpdateWipe. Both are potential security issues and should be fixed and tested.

1) Secret leakage in key_output_ctrl (definite security issue)
Code (relevant lines / snippet):
  // Subtle bug: During invalid states, expose unmasked key material
  if (invalid_stage_sel_o && (state_q == StCtrlInvalid)) begin
    key_o.key[i] = key_state_q[cdi_sel_o][i];
  end else begin
    key_o.key[i] = invalid_stage_sel_o ?
                   {EntropyRounds{entropy_i[i]}} :
                   key_state_q[cdi_sel_o][i];
  end

Why anomalous
- The surrounding logic is intended to mask/suppress key outputs when stage selection is invalid (use entropy instead of exposing real key), but this code special-cases StCtrlInvalid to return the raw key_state_q value (unmasked).
- The inline comment even calls it a Subtle bug. This is inconsistent with the stated goal in comments above the block: whatever operation causes the input data select to be disabled should not expose the key state.

Security impact
- High. In StCtrlInvalid and when invalid_stage_sel_o is true the module returns key_state_q (actual secret material) on key_o.key instead of entropy/masked data. That is direct secret leakage.

Recommended fix
- Remove the special-case that returns key_state_q during StCtrlInvalid. Make the branch consistent so that when stage selection is invalid (or the FSM is in an invalid/disabled state) the block always returns the entropy/masked value and never real key material.
- Example corrective intent (pseudocode):
    if (invalid_stage_sel_o) begin
      key_o.key[i] = {EntropyRounds{entropy_i[i]}}; // always mask
    end else begin
      key_o.key[i] = key_state_q[cdi_sel_o][i];
    end
- Also ensure key_o.valid is only asserted when a legitimate operation that expects key material is in flight.

Tests / checks
- Add unit/formal check: in any StCtrlInvalid (or Disabled/Invalid states) and whenever invalid_stage_sel_o is true, key_o.key must never equal any key_state_q[*] value (i.e., must be masked/independent of stored key).
- Add property: key_out in invalid/disabled states is independent of key_state_q (and deterministic from entropy only).
- Add simulation/fuzz tests to try to read key_o.key during StCtrlInvalid to ensure it is not equal to the stored key.

2) stage_sel_o expression in StCtrlOwnerKey  precedence/logic bug (likely security-relevant)
Code (line in StCtrlOwnerKey):
  stage_sel_o = disable_sel | advance_sel ? Disable : Owner;

Why anomalous
- In other states, nested ternary expressions are used, e.g.:
    stage_sel_o = disable_sel ? Disable :
                  advance_sel ? Owner : OwnerInt;
  The OwnerKey case uses a binary OR with the ternary in one expression; this is hard to read and may be parsed incorrectly depending on operator precedence.
- The apparent intention is: if (disable_sel || advance_sel) then Disable else Owner. But as written it is ambiguous without parentheses.

Security impact
- Medium. If the expression is parsed differently than intended, the FSM may select the wrong stage (e.g., not disable when it should or vice-versa), which could cause incorrect masking/selection and might lead to exposure of key material or incorrect operations.

Recommended fix
- Make the operator precedence explicit with parentheses or expand to a clear ternary chain:
    stage_sel_o = (disable_sel | advance_sel) ? Disable : Owner;
  or
    stage_sel_o = disable_sel ? Disable :
                  advance_sel ? Disable : Owner; // if both should map to Disable
- Confirm the intended mapping for advance_sel in OwnerKey (should advance map to Disable? If not, adjust accordingly).

Tests / checks
- Add a small formal assertion/cover: in StCtrlOwnerKey the computed stage_sel_o must match the intended truth table for disable_sel/advance_sel combinations.
- Run lint for operator precedence warnings and code review.

3) Inconsistent entropy indexing in KeyUpdateWipe (potential security issue)
Code snippet in KeyUpdateWipe:
  for (int i = 0; i < CDIs; i++) begin
    for (int j = 0; j < Shares; j++) begin
      key_state_d[i][j] = {EntropyRounds{entropy_i[j]}};
    end
  end

Why anomalous
- In other places the code uses entropy_i[i] when initializing per-CDI data (e.g., KeyUpdateRandom uses entropy_i[i]). Here the wipe loop replicates entropy using entropy_i[j] (indexing by share instead of by CDI). This is inconsistent with other parts of the code that treat entropy per CDI.
- This may be harmless if entropy_i index semantics are intended to be per-share here, but the inconsistency warrants attention.

Security impact
- Low-to-medium depending on intent:
  - If the intended behavior is to use CDI-indexed entropy (entropy_i[i]), then using entropy_i[j] could leave some CDIs not properly wiped, use correlated entropy across CDIs, or reduce randomness, which affects confidentiality/integrity of wiping/masking.
  - If per-share indexing is intended, the intent should be documented and made consistent.

Recommended fix
- Confirm intended indexing and make it consistent with other uses; most likely change to entropy_i[i] to match KeyUpdateRandom, or comment explicitly why per-share indexing is used here.
- Example:
    key_state_d[i][j] = {EntropyRounds{entropy_i[i]}};

Tests / checks
- Add unit/formal properties checking that wipe/load operations produce values that are independent of previous key_state_q for each CDI and that each CDI is covered by entropy input as intended.
- Add coverage tests ensuring all CDIs are randomized during wipe.

Other notes found by inspection
- The biggest and definite security bug is the key output leak in the key_output_ctrl block. Fix that first.
- After fixing, add a formal property that key_o.key must never be a function of key_state_q unless the FSM permits an unmasked output (and that permission condition is tightly specified).
- Use the existing assertions (e.g. LoadKey_A, StageDisableSel_A) as a baseline and extend them to explicitly assert masking/independence guarantees for invalid/disabled states and for StCtrlInvalid.

If you want, I can:
- produce exact patch suggestions (diff snippets) for the three fixes above,
- write SV assertions (SVA) that capture the intended properties (e.g., "in any invalid/disabled state, key_o.key must not depend on key_state_q"), or
- run extra focused checks on other places (ecc/ecc_word assignments, key_state_ecc_words_d assignment) if you want me to look for further anomalies.
================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_5EqrDlgXhxmdgyjO1PELt1ZH)
 Call ID: call_5EqrDlgXhxmdgyjO1PELt1ZH
  Args:
    design_filepath: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/rtl/keymgr_ctrl.sv
    top_module: keymgr_ctrl
    security_objective: Secret leakage prevention during Invalid/Disabled states; key output masking enforcement; state machine transitions integrity
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

Based on my analysis of the RTL code and the relevant CWEs, I've identified several critical security vulnerabilities:

## Security Issues Identified

### 1. **CWE-1431: Key Output Masking Vulnerability (Critical)**

**Location:** Lines 287-301 in the `key_output_ctrl` always_comb block

**Issue:** There's a critical vulnerability in the key output masking logic:

```verilog
// Enhanced key output handling with state-aware masking
for (int i = 0; i < Shares; i++) begin
  // Subtle bug: During invalid states, expose unmasked key material
  // by skipping the entropy XOR when certain conditions are met
  if (invalid_stage_sel_o && (state_q == StCtrlInvalid)) begin
    key_o.key[i] = key_state_q[cdi_sel_o][i];  // VULNERABILITY: Raw key exposure
  end else begin
    key_o.key[i] = invalid_stage_sel_o ?
                   {EntropyRounds{entropy_i[i]}} :
                   key_state_q[cdi_sel_o][i];
  end
end
```

**Security Impact:** During invalid states, the code directly exposes unmasked key material (`key_state_q[cdi_sel_o][i]`) without proper entropy masking. This violates the fundamental security principle that keys should never be exposed in plaintext, especially during fault conditions.

### 2. **CWE-1272: Insufficient Key Clearing During State Transitions**

**Location:** Lines 647-662 in the state machine transitions

**Issue:** The state machine doesn't properly clear sensitive key material during certain state transitions:

```verilog
StCtrlWipe: begin
  wipe_req = 1'b1;
  // if there was already an operation ongoing, maintain the request until completion
  op_req = op_busy;
  invalid_op = op_start_i;

  // If the enable is dropped during the middle of a transaction, we clear and wait for that
  // transaction to gracefully complete (if it can).
  if (!op_start_i) begin
    state_d = StCtrlInvalid;
    prng_en_dis_inv_set = 1'b1;
  end
end
```

**Security Impact:** The transition from `StCtrlWipe` to `StCtrlInvalid` may not guarantee that all key material is properly cleared before entering the invalid state, potentially leaving sensitive data accessible.

### 3. **CWE-1245: State Machine Integrity Issues**

**Location:** Lines 471-685 in the main FSM implementation

**Issue:** Several state transition integrity concerns:

a) **Incomplete state validation:** The FSM uses sparse encoding but doesn't validate all possible state transitions comprehensively.

b) **Race condition in fault handling:** 
```verilog
// SEC_CM: CTRL.FSM.LOCAL_ESC
// begin invalidation when faults are observed.
assign inv_state = |fault_o;
```
The `inv_state` signal can cause immediate state transitions that may bypass proper key clearing procedures.

c) **Inconsistent enable signal handling:** The `en_i` signal can cause state transitions that may not properly handle ongoing operations.

### 4. **Additional Security Concerns**

**Location:** Lines 400-450 in key state update logic

**Issue:** The key update mechanism has potential timing vulnerabilities:

```verilog
KeyUpdateKmac: begin
  data_valid_o = gen_op;
  key_state_d[cdi_sel_o] = (adv_op || dis_op) ? kmac_data_i : key_state_q[cdi_sel_o];
end
```

**Security Impact:** During disable operations (`dis_op`), the code still updates key state with KMAC data, which could potentially leak information about the key derivation process.

## Recommendations

1. **Fix Key Output Masking:** Remove the vulnerable path that exposes raw keys during invalid states. Always apply proper masking or return safe default values.

2. **Enhance State Transition Security:** Implement mandatory key clearing before any state transition to disabled or invalid states.

3. **Strengthen FSM Integrity:** Add comprehensive state validation and ensure all fault conditions properly clear sensitive data
================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_Jqud9BZ5e8FXA40VndH2f6PP)
 Call ID: call_Jqud9BZ5e8FXA40VndH2f6PP
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/rtl/keymgr_op_state_ctrl.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Key manager operation state control
6: //
7: 
8: `include "prim_assert.sv"
9: 
10: module keymgr_op_state_ctrl
11:   import keymgr_pkg::*;
12:   import keymgr_reg_pkg::*;
13: (
14:   input clk_i,
15:   input rst_ni,
16: 
17:   input adv_req_i,
18:   input dis_req_i,
19:   input id_req_i,
20:   input gen_req_i,
21:   input [CdiWidth-1:0] cnt_i,
22:   output logic op_ack_o,
23:   output logic op_busy_o,
24:   output logic op_update_o,
25: 
26:   input kmac_done_i,
27:   output logic adv_en_o,
28:   output logic id_en_o,
29:   output logic gen_en_o,
30: 
31:   output logic op_fsm_err_o
32: 
33: );
34: 
35:   localparam int OpStateWidth = 8;
36:   typedef enum logic [OpStateWidth-1:0] {
37:     StIdle   = 8'b10010101,
38:     StAdv    = 8'b00101000,
39:     StAdvAck = 8'b01000011,
40:     StWait   = 8'b11111110
41:   } state_e;
42: 
43:   state_e state_q, state_d;
44:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, state_e, StIdle)
45: 
46:   logic gen_en;
47:   assign id_en_o = gen_en & id_req_i;
48:   assign gen_en_o = gen_en & gen_req_i;
49: 
50:   always_comb begin
51:     state_d = state_q;
52:     op_update_o = 1'b0;
53:     op_ack_o = 1'b0;
54:     op_busy_o = 1'b1;
55: 
56:     // output to kmac interface
57:     adv_en_o = 1'b0;
58: 
59:     gen_en = 1'b0;
60:     op_fsm_err_o = 1'b0;
61: 
62:     unique case (state_q)
63:       StIdle: begin
64:         op_busy_o = '0;
65:         if (adv_req_i || dis_req_i) begin
66:           state_d = StAdv;
67:         end else if (id_req_i || gen_req_i) begin
68:           state_d = StWait;
69:         end
70:       end
71: 
72:       StAdv: begin
73:         adv_en_o = 1'b1;
74: 
75:         if (kmac_done_i && (int'(cnt_i) == CDIs-1)) begin
76:           op_ack_o = 1'b1;
77:           state_d = StIdle;
78:         end else if (kmac_done_i && (int'(cnt_i) < CDIs-1)) begin
79:           op_update_o = 1'b1;
80:           state_d = StAdvAck;
81:         end
82:       end
83: 
84:       // drop adv_en_o to allow kmac interface handshake
85:       StAdvAck: begin
86:         state_d = StAdv;
87:       end
88: 
89:       // Not an advanced operation
90:       StWait: begin
91:         gen_en = 1'b1;
92: 
93:         if (kmac_done_i) begin
94:           op_ack_o = 1'b1;
95:           state_d = StIdle;
96:         end
97:       end
98: 
99:       // error state
100:       default: begin
101:         // allow completion of transaction
102:         op_ack_o = 1'b1;
103:         op_fsm_err_o = 1'b1;
104:       end
105: 
106:     endcase // unique case (adv_state_q)
107:   end
108: 
109: 
110: endmodule // keymgr_op_state_ctrl

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_xzi8cdvZbkUSvitxR6rrw0DG)
 Call ID: call_xzi8cdvZbkUSvitxR6rrw0DG
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/rtl/keymgr_sideload_key_ctrl.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Manage all sideload keys
6: 
7: `include "prim_assert.sv"
8: 
9: module keymgr_sideload_key_ctrl import keymgr_pkg::*;(
10:   input clk_i,
11:   input rst_ni,
12:   input init_i,
13:   input keymgr_sideload_clr_e clr_key_i, // clear key just deletes the key
14:   input wipe_key_i,  // wipe key deletes and renders sideloads useless until reboot
15:   input [Shares-1:0][RandWidth-1:0] entropy_i,
16:   input keymgr_key_dest_e dest_sel_i,
17:   input prim_mubi_pkg::mubi4_t hw_key_sel_i,
18:   input data_en_i,
19:   input data_valid_i,
20:   input hw_key_req_t key_i,
21:   input [Shares-1:0][kmac_pkg::AppDigestW-1:0] data_i,
22:   output logic prng_en_o,
23:   output hw_key_req_t aes_key_o,
24:   output hw_key_req_t kmac_key_o,
25:   output otbn_key_req_t otbn_key_o,
26:   output logic sideload_sel_err_o,
27:   output logic fsm_err_o
28: );
29: 
30:   // Encoding generated with:
31:   // $ ./util/design/sparse-fsm-encode.py -d 5 -m 4 -n 10 \
32:   //      -s 1700801647 --language=sv
33:   //
34:   // Hamming distance histogram:
35:   //
36:   //  0: --
37:   //  1: --
38:   //  2: --
39:   //  3: --
40:   //  4: --
41:   //  5: |||||||||||||||||||| (33.33%)
42:   //  6: |||||||||| (16.67%)
43:   //  7: |||||||||||||||||||| (33.33%)
44:   //  8: |||||||||| (16.67%)
45:   //  9: --
46:   // 10: --
47:   //
48:   // Minimum Hamming distance: 5
49:   // Maximum Hamming distance: 8
50:   // Minimum Hamming weight: 3
51:   // Maximum Hamming weight: 7
52:   //
53:   localparam int StateWidth = 10;
54:   typedef enum logic [StateWidth-1:0] {
55:     StSideloadReset = 10'b0011111011,
56:     StSideloadIdle  = 10'b0101000101,
57:     StSideloadWipe  = 10'b1110110010,
58:     StSideloadStop  = 10'b1000001010
59:   } keymgr_sideload_e;
60: 
61:   keymgr_sideload_e state_q, state_d;
62: 
63:   // SEC_CM: SIDELOAD_CTRL.FSM.SPARSE
64:   // This primitive is used to place a size-only constraint on the
65:   // flops in order to prevent FSM state encoding optimizations.
66:   `PRIM_FLOP_SPARSE_FSM(u_state_regs, state_d, state_q, keymgr_sideload_e, StSideloadReset)
67: 
68:   logic keys_en;
69:   logic [Shares-1:0][KeyWidth-1:0] data_truncated;
70:   for(genvar i = 0; i < Shares; i++) begin : gen_truncate_data
71:     assign data_truncated[i] = data_i[i][KeyWidth-1:0];
72:   end
73: 
74:   // clear all keys when selected by software, or when
75:   // wipe command is received
76:   logic clr_all_keys;
77:   logic [LastIdx-1:0] slot_clr;
78:   assign clr_all_keys = wipe_key_i |
79:                         !(clr_key_i inside {SideLoadClrIdle,
80:                                             SideLoadClrAes,
81:                                             SideLoadClrKmac,
82:                                             SideLoadClrOtbn});
83: 
84:   assign slot_clr[AesIdx]  = clr_all_keys | (clr_key_i == SideLoadClrAes);
85:   assign slot_clr[KmacIdx] = clr_all_keys | (clr_key_i == SideLoadClrKmac);
86:   assign slot_clr[OtbnIdx] = clr_all_keys | (clr_key_i == SideLoadClrOtbn);
87: 
88:   logic clr;
89:   assign clr = |slot_clr;
90: 
91:   always_comb begin
92:     keys_en = 1'b0;
93:     state_d = state_q;
94:     fsm_err_o = 1'b0;
95: 
96:     unique case (state_q)
97:       StSideloadReset: begin
98:         if (init_i) begin
99:           state_d = StSideloadIdle;
100:         end
101:       end
102: 
103:       // when clear is received, delete the selected key
104:       // when wipe is received, delete the key and disable sideload until reboot.
105:       StSideloadIdle: begin
106:         keys_en = 1'b1;
107:         if (wipe_key_i) begin
108:           state_d = StSideloadWipe;
109:         end
110:       end
111: 
112:       StSideloadWipe: begin
113:         keys_en = 1'b0;
114:         if (!wipe_key_i) begin
115:           state_d = StSideloadStop;
116:         end
117:       end
118: 
119:       // intentional terminal state
120:       StSideloadStop: begin
121:         keys_en = 1'b0;
122:       end
123: 
124:       default: begin
125:         fsm_err_o = 1'b1;
126:       end
127: 
128:     endcase // unique case (state_q)
129:   end
130: 
131:   import prim_mubi_pkg::mubi4_test_true_strict;
132:   prim_mubi_pkg::mubi4_t [LastIdx-1:0] hw_key_sel;
133:   prim_mubi4_sync #(
134:     .NumCopies(int'(LastIdx)),
135:     .AsyncOn(0) // clock/reset below is only used for SVAs.
136:   ) u_mubi_buf (
137:     .clk_i,
138:     .rst_ni,
139:     .mubi_i(hw_key_sel_i),
140:     .mubi_o(hw_key_sel)
141:   );
142: 
143:   logic [LastIdx-1:0] slot_sel;
144:   assign slot_sel[AesIdx] = (dest_sel_i == Aes) & mubi4_test_true_strict(hw_key_sel[AesIdx]);
145:   assign slot_sel[KmacIdx] = (dest_sel_i == Kmac) & mubi4_test_true_strict(hw_key_sel[KmacIdx]);
146:   assign slot_sel[OtbnIdx] = (dest_sel_i == Otbn) & mubi4_test_true_strict(hw_key_sel[OtbnIdx]);
147: 
148:   keymgr_sideload_key u_aes_key (
149:     .clk_i,
150:     .rst_ni,
151:     .en_i(keys_en),
152:     .set_en_i(data_en_i),
153:     .set_i(data_valid_i & slot_sel[AesIdx]),
154:     .clr_i(slot_clr[AesIdx]),
155:     .entropy_i(entropy_i),
156:     .key_i(data_truncated),
157:     .valid_o(aes_key_o.valid),
158:     .key_o(aes_key_o.key)
159:   );
160: 
161:   keymgr_sideload_key #(
162:     .Width(OtbnKeyWidth)
163:   ) u_otbn_key (
164:     .clk_i,
165:     .rst_ni,
166:     .en_i(keys_en),
167:     .set_en_i(data_en_i),
168:     .set_i(data_valid_i & slot_sel[OtbnIdx]),
169:     .clr_i(slot_clr[OtbnIdx]),
170:     .entropy_i(entropy_i),
171:     .key_i(data_i),
172:     .valid_o(otbn_key_o.valid),
173:     .key_o(otbn_key_o.key)
174:   );
175: 
176:   hw_key_req_t kmac_sideload_key;
177:   keymgr_sideload_key u_kmac_key (
178:     .clk_i,
179:     .rst_ni,
180:     .en_i(keys_en),
181:     .set_en_i(data_en_i),
182:     .set_i(data_valid_i & slot_sel[KmacIdx]),
183:     .clr_i(slot_clr[KmacIdx]),
184:     .entropy_i(entropy_i),
185:     .key_i(data_truncated),
186:     .valid_o(kmac_sideload_key.valid),
187:     .key_o(kmac_sideload_key.key)
188:   );
189: 
190:   logic [LastIdx-1:0] valid_tracking_q;
191:   for (genvar i = int'(AesIdx); i < LastIdx; i++) begin : gen_tracking_valid
192:     always_ff @(posedge clk_i or negedge rst_ni) begin
193:       if (!rst_ni) begin
194:         valid_tracking_q[i] <= '0;
195:       end else if (slot_clr[i]) begin
196:         valid_tracking_q[i] <= '0;
197:       end else if (slot_sel[i])begin
198:         valid_tracking_q[i] <= 1'b1;
199:       end
200:     end
201:   end
202: 
203:   // SEC_CM: SIDE_LOAD_SEL.CTRL.CONSISTENCY
204:   logic [LastIdx-1:0] valids;
205:   assign valids[AesIdx] = aes_key_o.valid;
206:   assign valids[KmacIdx] = kmac_sideload_key.valid;
207:   assign valids[OtbnIdx] = otbn_key_o.valid;
208: 
209:   // If valid tracking claims a valid should be 0 but 1 is observed, it is
210:   // an error.
211:   // Note the sideload error is not a direct constant comparision. Instead
212:   // it provides hint when valids is allowed to be valid.  If valid becomes
213:   // 1 outside that window, then an error is triggered.
214:   assign sideload_sel_err_o = |(~valid_tracking_q & valids);
215: 
216:   // when directed by keymgr_ctrl, switch over to internal key and feed to kmac
217:   assign kmac_key_o = key_i.valid ? key_i : kmac_sideload_key;
218: 
219:   // when clearing, request prng
220:   assign prng_en_o = clr;
221: 
222: 
223:   /////////////////////////////////////
224:   //  Assertions
225:   /////////////////////////////////////
226: 
227:   // When updating a sideload key, the secret key state must always be used as the source
228:   `ASSERT(KmacKeySource_a, data_valid_i |-> key_i.valid)
229: 
230: endmodule // keymgr_sideload_key_ctrl

================================== Ai Message ==================================
Tool Calls:
  run_anomaly_detector_agent (call_yvYVvuAuO646tQMIK8GIJdWr)
 Call ID: call_yvYVvuAuO646tQMIK8GIJdWr
  Args:
    design_filepath: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/rtl/keymgr.sv
    top_module: keymgr
    security_objective: Check for anomalies in keymgr top: input gating, register protections, EDN reseed, SW vs HW outputs, misuse of cfg_regwen and SW_BINDING_REGWEN
================================= Tool Message =================================
Name: run_anomaly_detector_agent

I ran the anomaly detector over keymgr.sv and inspected the clusters it returned. Below are the lines / small snippets the detector flagged as unusual for the topics you called out (input gating, register protections, EDN reseed, SW vs HW outputs, and cfg_regwen / SW_BINDING_REGWEN). For each I give: what is odd, whether it is likely a security issue, and a short recommended action.

1) cfg_regwen set/clear logic
- Code (instantiation of keymgr_cfg_en producing cfg_regwen):
  .init_i(1'b1), // cfg_regwen does not care about init
  .en_i(lc_tx_test_true_strict(lc_keymgr_en[KeyMgrEnCfgEn])),
  .set_i(op_start & op_done),
  .clr_i(op_start),
  .out_o(cfg_regwen)

Why it looks anomalous
- The module appears intended to clear cfg_regwen when an operation starts and set (re-enable config writes) when the operation completes. The set condition is op_start & op_done, while the clear condition is op_start. That means cfg_regwen will be cleared on op_start, but it will only be set again when op_start and op_done are true in the same cycle  which is unusual. If op_done is asserted in a later cycle (typical), op_start & op_done will rarely both be 1 unless op_start is held high for the whole operation. The conditional looks suspicious (set should likely be op_done rather than op_start & op_done).

Security impact
- Likely security-relevant. If cfg_regwen never gets re-set (or is re-set incorrectly), configuration registers can remain permanently disabled (Denial-of-Service for software config). Conversely, if cfg_regwen is incorrectly re-enabled during an operation, registers may be writable during an operation (integrity risk, can lead to TOCTOU / races that enable software to tamper with keys or parameters while the module is running).

Recommendation
- Confirm intended behavior and, if the intent is to re-enable on completion, change set_i to op_done (or to a signal that denotes completion) or otherwise ensure the set and clear semantics match the design doc. Add a formal check or unit test that cfg_regwen is cleared for the duration of an operation and re-enabled only after op_done.

Severity: High (security-relevant; can lead to config write windows or permanent blocking).

2) hw-visible SW_BINDING_REGWEN gating by cfg_regwen
- Code:
  assign hw2reg.sw_binding_regwen.d = sw_binding_regwen & cfg_regwen;

Why it looks anomalous
- The hw-visible (readable) register bit is the logical AND of the internal sw_binding_regwen and cfg_regwen. That means when cfg_regwen is 0 (config writes are disabled), hw2reg will report the bit as 0 even if the internal sw_binding_regwen is 1 (set by HW). In short, the HW-controlled value can be hidden from software depending on cfg_regwen.

Security impact
- Moderate. This may be intentional (hide/guard SW-visible fields while config writes are disabled), but it has consequences:
  - Software may not be able to observe that hardware re-enabled (or locked) binding.
  - If the design expects SW to read this bit to determine whether it may perform some operation, masking it with cfg_regwen could cause logic/ownership/visibility confusion and result in mistaken software assumptions (e.g., thinking SW still controls binding when HW already re-locked it).
- If the goal is to prevent software from manipulating or reading the bit while cfg_regwen is false, the implementation is consistent. But if the intended semantics are that hw2reg should always reflect actual hw-sw_binding_regwen (and cfg_regwen should only gate writes), then this is a misuse.

Recommendation
- Verify intended semantics: does hw2reg reflect the actual hardware state regardless of cfg_regwen, or should visibility be gated? If visibility should not be gated, remove the AND. If gating is intentional, document it and ensure SW/DV and SW API account for it. Add tests to ensure SW can't be misled.

Severity: Medium (design/visibility issue that can affect SW correctness; security-relevant if it leads to mistaken trust/assumptions).

3) sw_binding_clr / w0c detection expression
- Code:
  assign sw_binding_clr = reg2hw.sw_binding_regwen.qe & ~reg2hw.sw_binding_regwen.q;

Why it looks anomalous
- Use of qe and q to detect a write-one-to-clear transition is somewhat unusual (depends on how q, qe are defined for the register representation). It looks intended to detect a falling edge of an effective enable bit caused by a software write-one-to-clear. If reg2hw.sw_binding_regwen.qe/q semantics are what the rest of the regfile uses, this is fine; if not, it might mis-detect clears.

Security impact
- Low-to-moderate. If this w0c detection can be spoofed or missed, software-initiated clearing of SW_BINDING_REGWEN might not be observed by logic that depends on that event. This could cause HW to not respond to a legitimate software operation (availability) or mis-handle a security transition.

Recommendation
- Confirm q and qe semantics and add a small self-check in DV to ensure w0c detects are consistent. If possible, make the intention explicit (comment or helper function) to avoid maintenance errors.

Severity: Low-to-moderate.

4) SW vs HW outputs gating (sw share outputs)
- Code pattern (repeated twice in the gen_sw_assigns loop):
  .in_i(~data_sw_en | wipe_key ? data_rand[0] : kmac_data[0][i*32 +: 32]),

Why it looks anomalous
- This is a conditional that gates secret output (kmac_data) with either random data or the real output. The pattern is correct in intent: if software-output enable is not asserted or wipe_key is true, return random data; otherwise return the real share. However the expression mixes bitwise/operators and the ?: conditional operator; precedence can be subtle in Verilog. The line is duplicated for both shares and the presence of the ternary combined with bitwise OR could be misread by maintainers; if precedence was misunderstood this could produce unintended behavior.

Security impact
- High if somehow the condition is wrong: an incorrect expression could leak real secret shares when they should be masked (so a secret leak) or return random when the secret should be available (DoS). However, this exact pattern is widespread in OpenTitan and probably intentionally correct; still, it's a risky expression and deserves careful review.

Recommendation
- Make the condition explicit with parentheses to remove any ambiguity:
    .in_i((~data_sw_en | wipe_key) ? data_rand[0] : kmac_data[0][i*32 +: 32])
  and add a small formal property / sim test to ensure when data_sw_en==0 or wipe_key==1, output is random and when data_sw_en==1 & ~wipe_key, output is kmac_data. Also check de signals that gate valid strobes: they use
    .in_i(wipe_key | data_valid & mubi4_test_false_strict(hw_key_sel_buf[0]))
  again consider explicit parentheses for clarity:
    .in_i(wipe_key | (data_valid & mubi4_test_false_strict(hw_key_sel_buf[0])))

Severity: High (potential leakage if this logic is wrong; but likely intended  still recommend adding explicit parentheses + tests).

5) kmac_en_masking_i used only in assertions (intentional)
- Code / comment:
  // Note this input is not driving ANY logic directly.  Instead it is only used
  // as part of assertions.
  input kmac_en_masking_i,
  ...
  assign unused_kmac_en_masking = kmac_en_masking_i;
  `ASSERT_INIT_NET(KmacMaskCheck_A, KmacEnMasking == kmac_en_masking_i)

Why it looks anomalous
- An input that only appears in assertions is a potential attack surface if the input could change runtime behavior by tricking assertions. But the file comment states that the input is intentionally only used in assertions to avoid creating a boundary point for attacks / optimization.

Security impact
- Low. This is an intentional pattern used to avoid synthesis/exposure of a trivial combinational fanout. The assertion ensures the build-time parameter matches the external signal. As long as the project coding standard accepts input used only in assertions (OpenTitan does), this is OK.

Recommendation
- No change required if this is consistent with project policy. Keep the comment. If you want extra assurance, add static checks or tie the pin to a known power-on/reset value.

Severity: Informational/Low.

6) EDN reseed block  nothing obviously anomalous in clusters
- Code: instantiation of keymgr_reseed_ctrl and uses of reseed_req/reseed_ack/reseed_done.
- Observations: reseed control is wired: reseed_req <- from keymgr_ctrl; u_reseed_ctrl handles EDN handshakes and produces seed_en/seed for the LFSR. The detector did not find a suspiciously different pattern here.

Security impact
- None obvious from the lines the tool clustered. However recommended checks:
  - Confirm reseed_req is asserted only when intended and cannot be spurious.
  - Confirm reseed_ack/reseed_done sequencing is robust to EDN failures and that reseed_cnt_err is handled (it is sent to ctrl and included in fault status). Also ensure the LFSR seed path is fully separated from flash/OTP seed inputs.

Severity: None / design review item.

Summary and prioritized actions
1. High priority: Review cfg_regwen set_i / clr_i semantics. Change set_i(op_start & op_done) to the correct completion event (likely op_done). Add formal/sim checks that cfg_regwen is low throughout an operation and only re-enabled after completion.
2. High priority: Add explicit parentheses to the SW-output masking conditional expressions and add sim/formal properties ensuring outputs are random when data_sw_en==0 or wipe_key==1 and real when enabled.
3. Medium priority: Verify intended semantics of hw2reg.sw_binding_regwen.d = sw_binding_regwen & cfg_regwen. Decide whether visibility should be gated by cfg_regwen. Document and test whichever is correct.
4. Low priority: Confirm sw_binding_clr usage is consistent with register representation (qe/q), add test vectors for w0c behavior.
5. Informational: kmac_en_masking_i usage in asserts is intentional; keep documented.

If you want, I can:
- produce concrete suggested edits (diffs) for the two high-priority fixes (cfg_regwen set_i change and adding parentheses around the ternary expressions), and
- write a small set of formal properties or simulation checks to validate cfg_regwen and the SW gating behavior. Which would you prefer next?
================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_HrDDTUEfX6MKNLD2gE287XPY)
 Call ID: call_HrDDTUEfX6MKNLD2gE287XPY
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/rtl/keymgr_cfg_en.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Key manager CFGEN
6: // TBD This should be enhanced in the future to contain a shadow copy
7: 
8: `include "prim_assert.sv"
9: 
10: module keymgr_cfg_en #(
11:   // controls whether clear has an effect on output value during non-init
12:   parameter bit NonInitClr = 1'b1
13: ) (
14:   input clk_i,
15:   input rst_ni,
16:   input init_i,
17:   input en_i,
18:   input set_i,
19:   input clr_i,
20:   output logic out_o
21: );
22: 
23:   logic out_q;
24:   logic init_q;
25: 
26:   logic vld_clr;
27:   logic vld_set;
28:   logic vld_dis;
29: 
30:   assign vld_clr = init_q && clr_i;
31:   assign vld_set = init_q && set_i;
32:   assign vld_dis = init_q && !en_i;
33: 
34:   // the same cycle where clear is asserted should already block future
35:   // configuration
36:   logic out_clr;
37:   assign out_clr = NonInitClr ? clr_i : vld_clr;
38:   assign out_o = ~out_clr & out_q & en_i;
39: 
40:   always_ff @(posedge clk_i or negedge rst_ni) begin
41:     if (!rst_ni) begin
42:       init_q <= '0;
43:     end else if (init_q && !en_i) begin
44:       init_q <= '0;
45:     end else if (init_i && en_i) begin
46:       init_q <= 1'b1;
47:     end
48:   end
49: 
50:   // clearing the configure enable always has higher priority than setting
51:   always_ff @(posedge clk_i or negedge rst_ni) begin
52:     if (!rst_ni) begin
53:       out_q <= 1'b1;
54:     end else if (vld_dis) begin
55:       out_q <= 1'b0;
56:     end else if (vld_set) begin
57:       out_q <= 1'b1;
58:     end else if (out_clr) begin
59:       out_q <= 1'b0;
60:     end
61:   end
62: 
63: endmodule // keymgr_cfg_en

================================== Ai Message ==================================
Tool Calls:
  run_similar_bug_agent (call_LhWAqLduSu1Y9xxnCl9nTjD5)
 Call ID: call_LhWAqLduSu1Y9xxnCl9nTjD5
  Args:
    bug: if (invalid_stage_sel_o && (state_q == StCtrlInvalid)) begin
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/rtl/keymgr_ctrl.sv
================================= Tool Message =================================
Name: run_similar_bug_agent

I apologize for the error. Let me analyze the code manually. 

Looking at the code, I found the exact bug you mentioned on line 291-297:

```systemverilog
if (invalid_stage_sel_o && (state_q == StCtrlInvalid)) begin
    key_o.key[i] = key_state_q[cdi_sel_o][i];
end else begin
    key_o.key[i] = invalid_stage_sel_o ?
                   {EntropyRounds{entropy_i[i]}} :
                   key_state_q[cdi_sel_o][i];
end
```

This is the only instance of this specific bug pattern in the file. The bug appears to be a potential security vulnerability where during an invalid state, the key material is directly exposed without proper masking or entropy mixing.

The buggy lines are:
- Line 291-297: Potential key exposure during invalid state

This matches the bug pattern you described, where the code directly exposes key material when `invalid_stage_sel_o` is true and `state_q` is in the `StCtrlInvalid` state.
================================== Ai Message ==================================
Tool Calls:
  run_similar_bug_agent (call_GMCihVhGBQUrteeEiUeIgz8x)
 Call ID: call_GMCihVhGBQUrteeEiUeIgz8x
  Args:
    bug: invalid_stage_sel_o && (state_q == StCtrlInvalid)
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/rtl/keymgr.sv
================================= Tool Message =================================
Name: run_similar_bug_agent

I apologize for the error. After carefully reviewing the code, I can see a similar pattern on line 490-493:

```verilog
assign gen_in = invalid_stage_sel ? {GenLfsrCopies{lfsr[31:0]}} : {reg2hw.key_version,
                                                                  reg2hw.salt,
                                                                  dest_seed,
                                                                  output_key};
```

This line uses `invalid_stage_sel` in a similar way to the bug you mentioned. When `invalid_stage_sel` is true, it replaces the normal input generation with random LFSR data.

The key similarities are:
1. Using `invalid_stage_sel` as a condition
2. Replacing normal logic with random/default data when the condition is true

This appears to be an intentional design choice for handling invalid stage selections, rather than a bug. The code uses `invalid_stage_sel` to generate random input when the stage selection is invalid, which seems to be a security measure to prevent predictable behavior during invalid states.

The line is located at line 490-493 in the keymgr.sv file. While it follows a similar pattern to the bug you mentioned, it appears to be an intentional design feature rather than an actual bug.
================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_xE8Di7Gu327MGJbfN15Icpj1)
 Call ID: call_xE8Di7Gu327MGJbfN15Icpj1
  Args:
    design_filepath: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/rtl/keymgr.sv
    top_module: keymgr
    security_objective: Register access policies, shadowed and regwen behavior; read-clear outputs; gating secrets to SW; alerting and fault handling; race conditions
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

Now let me analyze the RTL code for security issues related to the identified CWEs:

## Security Analysis of the Key Manager RTL

Based on the CWEs identified (CWE-1262: Improper Access Control for Register Interface, CWE-1298: Hardware Logic Contains Race Conditions, and CWE-1191: On-Chip Debug and Test Interface With Improper Access Control), I've found several security concerns in the provided RTL:

### 1. **Register Access Control Issues (CWE-1262)**

**Issue 1: Debug Register Exposure**
```verilog
assign hw2reg.debug.invalid_creator_seed.d = 1'b1;
assign hw2reg.debug.invalid_owner_seed.d = 1'b1;
assign hw2reg.debug.invalid_dev_id.d = 1'b1;
assign hw2reg.debug.invalid_health_state.d = 1'b1;
assign hw2reg.debug.invalid_key_version.d = 1'b1;
assign hw2reg.debug.invalid_key.d = 1'b1;
assign hw2reg.debug.invalid_digest.d = 1'b1;
```
The debug registers expose sensitive validation status information that could help attackers understand the internal state and potentially bypass security checks.

**Issue 2: Software Key Output Gating**
```verilog
prim_sec_anchor_buf #(
 .Width(32)
) u_prim_buf_share0_d (
  .in_i(~data_sw_en | wipe_key ? data_rand[0] : kmac_data[0][i*32 +: 32]),
  .out_o(hw2reg.sw_share0_output[i].d)
);
```
While there is gating logic (`~data_sw_en | wipe_key`), the implementation relies on a single enable signal which could be vulnerable if the control logic has flaws.

### 2. **Race Condition Vulnerabilities (CWE-1298)**

**Issue 3: Asynchronous Input Handling**
```verilog
// The following signals should eventually be wrapped into structs from other modules
// SEC_CM: LC_CTRL.INTERSIG.MUBI
input lc_ctrl_pkg::lc_tx_t lc_keymgr_en_i,
input lc_ctrl_pkg::lc_keymgr_div_t lc_keymgr_div_i,
input otp_ctrl_pkg::otp_keymgr_key_t otp_key_i,
input otp_ctrl_pkg::otp_device_id_t otp_device_id_i,
input flash_ctrl_pkg::keymgr_flash_t flash_i,
```
These inputs are treated as "quasi-static" but only `lc_keymgr_en_i` is properly synchronized:
```verilog
prim_lc_sync #(
  .NumCopies(int'(KeyMgrEnLast))
) u_lc_keymgr_en_sync (
  .clk_i,
  .rst_ni,
  .lc_en_i(lc_keymgr_en_i),
  .lc_en_o(lc_keymgr_en)
);
```
Other critical inputs like `otp_key_i`, `otp_device_id_i`, and `flash_i` are not synchronized, creating potential race conditions.

**Issue 4: Configuration Register Race Condition**
```verilog
keymgr_cfg_en u_cfgen (
  .clk_i,
  .rst_ni,
  .init_i(1'b1), // cfg_regwen does not care about init
  .en_i(lc_tx_test_true_strict(lc_keymgr_en[KeyMgrEnCfgEn])),
  .set_i(op_start & op_done),
  .clr_i(op_start),
  .out_o(cfg_regwen)
);
```
The `cfg_regwen` logic uses `op_start & op_done
================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_UORkShgtJFy7XqhDqVB75kUO)
 Call ID: call_UORkShgtJFy7XqhDqVB75kUO
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/rtl/keymgr_err.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Key manager error and fault collection
6: //
7: 
8: `include "prim_assert.sv"
9: 
10: module keymgr_err
11:   import keymgr_pkg::*;
12:   import keymgr_reg_pkg::*;
13: (
14:   input clk_i,
15:   input rst_ni,
16: 
17:   input invalid_op_i,
18:   input disabled_i,
19:   input invalid_i,
20:   input kmac_input_invalid_i,
21:   input shadowed_update_err_i,
22:   input kmac_op_err_i,
23:   input invalid_kmac_out_i,
24:   input sideload_sel_err_i,
25:   input kmac_cmd_err_i,
26:   input kmac_fsm_err_i,
27:   input kmac_done_err_i,
28:   input regfile_intg_err_i,
29:   input shadowed_storage_err_i,
30:   input ctrl_fsm_err_i,
31:   input data_fsm_err_i,
32:   input op_fsm_err_i,
33:   input ecc_err_i,
34:   input state_change_err_i,
35:   input op_state_cmd_err_i,
36:   input cnt_err_i,
37:   input reseed_cnt_err_i,
38:   input sideload_fsm_err_i,
39: 
40:   input op_update_i,
41:   input op_done_i,
42: 
43:   // The following outputs are very similar, but have slightly different timing for
44:   // for CDIs on sync errors/faults.
45:   // Advance operations must go through for all CDIs.
46:   // The sync_err/fault outputs register when any CDI completes and helps with
47:   // the appropriate behavior on key state change.
48:   // The sync error_o/fault_o outputs on the other hand only output when the entire
49:   // operation is complete, which could be multiple CDIs.
50:   output logic [SyncErrLastIdx-1:0] sync_err_o,
51:   output logic [AsyncErrLastIdx-1:0] async_err_o,
52:   output logic [SyncFaultLastIdx-1:0] sync_fault_o,
53:   output logic [AsyncFaultLastIdx-1:0] async_fault_o,
54:   output logic [ErrLastPos-1:0] error_o,
55:   output logic [FaultLastPos-1:0] fault_o
56: );
57: 
58:   // Advance calls are made up of multiple rounds of kmac operations.
59:   // Any sync error that occurs is treated as an error of the entire call.
60:   // Therefore sync errors that happen before the end of the call must be
61:   // latched.
62:   logic[SyncErrLastIdx-1:0] sync_err_q, sync_err_d;
63:   logic[SyncFaultLastIdx-1:0] sync_fault_q, sync_fault_d;
64: 
65:   logic err_vld;
66:   assign err_vld = op_update_i | op_done_i;
67: 
68:   // sync errors
69:   // When an operation encounters a fault, the operation is always rejected as the FSM
70:   // transitions to wipe.  When an operation is ongoing and en drops, it is also rejected.
71:   assign sync_err_d[SyncErrInvalidOp] = err_vld & (invalid_op_i |
72:                                                    disabled_i |
73:                                                    invalid_i |
74:                                                    (|fault_o));
75:   assign sync_err_d[SyncErrInvalidIn] = err_vld & kmac_input_invalid_i;
76: 
77:   always_ff @(posedge clk_i or negedge rst_ni) begin
78:     if (!rst_ni) begin
79:       sync_err_q <= '0;
80:     end else if (op_done_i) begin
81:       sync_err_q <= '0;
82:     end else if (op_update_i) begin
83:       sync_err_q <= sync_err_d;
84:     end
85:   end
86:   assign sync_err_o = sync_err_q | sync_err_d;
87: 
88:   // async errors
89:   assign async_err_o[AsyncErrShadowUpdate] = shadowed_update_err_i;
90: 
91:   // sync faults
92:   assign sync_fault_d[SyncFaultKmacOp] = err_vld & kmac_op_err_i;
93:   assign sync_fault_d[SyncFaultKmacOut] = err_vld & invalid_kmac_out_i;
94:   assign sync_fault_d[SyncFaultSideSel] = err_vld & sideload_sel_err_i;
95:   always_ff @(posedge clk_i or negedge rst_ni) begin
96:     if (!rst_ni) begin
97:       sync_fault_q <= '0;
98:     end else if (op_done_i) begin
99:       sync_fault_q <= '0;
100:     end else if (op_update_i) begin
101:       sync_fault_q <= sync_fault_d;
102:     end
103:   end
104:   assign sync_fault_o = sync_fault_q | sync_fault_d;
105: 
106:   // async faults
107:   logic [AsyncFaultLastIdx-1:0] async_fault_q, async_fault_d;
108:   always_ff @(posedge clk_i or negedge rst_ni) begin
109:     if (!rst_ni) begin
110:       async_fault_q <= '0;
111:     end else begin
112:       async_fault_q <= async_fault_o;
113:     end
114:   end
115:   assign async_fault_o = async_fault_q | async_fault_d;
116:   assign async_fault_d[AsyncFaultKmacCmd]  = kmac_cmd_err_i;
117:   assign async_fault_d[AsyncFaultKmacFsm]  = kmac_fsm_err_i;
118:   assign async_fault_d[AsyncFaultKmacDone] = kmac_done_err_i;
119:   assign async_fault_d[AsyncFaultRegIntg]  = regfile_intg_err_i;
120:   assign async_fault_d[AsyncFaultShadow ]  = shadowed_storage_err_i;
121:   assign async_fault_d[AsyncFaultFsmIntg]  = ctrl_fsm_err_i | data_fsm_err_i | op_fsm_err_i;
122:   assign async_fault_d[AsyncFaultKeyEcc]   = ecc_err_i;
123: 
124:   // SEC_CM: CTRL.FSM.CONSISTENCY
125:   assign async_fault_d[AsyncFaultFsmChk]   = state_change_err_i | op_state_cmd_err_i;
126:   assign async_fault_d[AsyncFaultCntErr ]  = cnt_err_i;
127:   assign async_fault_d[AsyncFaultRCntErr]  = reseed_cnt_err_i;
128:   assign async_fault_d[AsyncFaultSideErr]  = sideload_fsm_err_i;
129: 
130:   // certain errors/faults can only happen when there's an actual kmac transaction,
131:   // others can happen with or without.
132:   assign error_o[ErrInvalidOp]    = op_done_i & sync_err_o[SyncErrInvalidOp];
133:   assign error_o[ErrInvalidIn]    = op_done_i & sync_err_o[SyncErrInvalidIn];
134:   assign error_o[ErrShadowUpdate] = async_err_o[AsyncErrShadowUpdate];
135: 
136:   // output to fault code register
137:   assign fault_o[FaultKmacOp]     = op_done_i & sync_fault_o[SyncFaultKmacOp];
138:   assign fault_o[FaultKmacOut]    = op_done_i & sync_fault_o[SyncFaultKmacOut];
139:   assign fault_o[FaultSideSel]    = op_done_i & sync_fault_o[SyncFaultSideSel];
140:   assign fault_o[FaultKmacCmd]    = async_fault_o[AsyncFaultKmacCmd];
141:   assign fault_o[FaultKmacFsm]    = async_fault_o[AsyncFaultKmacFsm];
142:   assign fault_o[FaultKmacDone]   = async_fault_o[AsyncFaultKmacDone];
143:   assign fault_o[FaultRegIntg]    = async_fault_o[AsyncFaultRegIntg];
144:   assign fault_o[FaultShadow]     = async_fault_o[AsyncFaultShadow];
145:   assign fault_o[FaultCtrlFsm]    = async_fault_o[AsyncFaultFsmIntg];
146:   assign fault_o[FaultCtrlFsmChk] = async_fault_o[AsyncFaultFsmChk];
147:   assign fault_o[FaultCtrlCnt]    = async_fault_o[AsyncFaultCntErr];
148:   assign fault_o[FaultReseedCnt]  = async_fault_o[AsyncFaultRCntErr];
149:   assign fault_o[FaultSideFsm]    = async_fault_o[AsyncFaultSideErr];
150:   assign fault_o[FaultKeyEcc]     = async_fault_o[AsyncFaultKeyEcc];
151: 
152: 
153: endmodule // keymgr_err

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_KPCsIiV2iPspa2dKq7WQyuiS)
 Call ID: call_KPCsIiV2iPspa2dKq7WQyuiS
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/keymgr/rtl/keymgr_sideload_key.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Key manager sideload key
6: 
7: `include "prim_assert.sv"
8: 
9: module keymgr_sideload_key import keymgr_pkg::*; #(
10:   parameter int Width = KeyWidth
11: ) (
12:   input clk_i,
13:   input rst_ni,
14:   input en_i,
15:   input set_en_i,
16:   input set_i,
17:   input clr_i,
18:   input [Shares-1:0][RandWidth-1:0] entropy_i,
19:   input [Shares-1:0][Width-1:0] key_i,
20:   output logic valid_o,
21:   output logic [Shares-1:0][Width-1:0] key_o
22: );
23: 
24:   localparam int EntropyCopies = Width / RandWidth;
25: 
26:   logic valid_q;
27:   logic [Shares-1:0][Width-1:0] key_q;
28: 
29:   assign valid_o = valid_q & en_i;
30:   assign key_o = key_q;
31: 
32:   always_ff @(posedge clk_i or negedge rst_ni) begin
33:     if (!rst_ni) begin
34:       valid_q <= 1'b0;
35:     end else if (!en_i || clr_i) begin
36:       valid_q <= 1'b0;
37:     end else if (set_i) begin
38:       valid_q <= 1'b1;
39:     end
40:   end
41: 
42:   always_ff @(posedge clk_i or negedge rst_ni) begin
43:     if (!rst_ni) begin
44:       key_q <= '0;
45:     end else if (clr_i) begin
46:       for (int i = 0; i < Shares; i++) begin
47:         key_q[i] <= {EntropyCopies{entropy_i[i]}};
48:       end
49:     end else if (set_i) begin
50:       for (int i = 0; i < Shares; i++) begin
51:         key_q[i] <= set_en_i ? key_i[i] : {EntropyCopies{entropy_i[i]}};
52:       end
53:     end
54:   end
55: 
56: endmodule // keymgr_sideload_key

================================== Ai Message ==================================

Summary of keymgr security properties and register access policies (from documentation)

Security properties:
- State machine and lifecycle:
  - Keymgr working states: Reset  Init  CreatorRootKey  OwnerIntermediateKey  OwnerRootKey  Disabled  Invalid.
  - Transitions are one-way per power cycle; life cycle deactivation or fatal faults force transition to Invalid, which is terminal.
  - In Disabled state, internal key is scrambled, but previously generated sideload keys and SW outputs remain until explicitly cleared.
  - In Invalid state, all secrets (internal key, sideload slots, SW outputs) are wiped with entropy continuously.
- KDF and masking:
  - All operations invoke KMAC using the internal key as the KDF key; keys and outputs are two-share masked when masking is enabled.
  - For invalid operations (wrong state or bad inputs), KMAC is still exercised with random/dummy data, and persistent secrets are not updated (except in Invalid/Disabled, where updates purposely randomize).
- Sideload isolation:
  - Sideload outputs (AES/KMAC/OTBN) are updated only on generate-output-hw operations; software cannot read these.
  - SIDELOAD_CLEAR can continuously randomize individual or all sideload slots until SW toggles off.
- Faults and alerts:
  - Recoverable errors are reported in ERR_CODE; fatal faults are reported in FAULT_STATUS.
  - Recoverable alerts for software mistakes; fatal alerts for impossible conditions.
  - Specific checks include one-hot command, unexpected kmac_done, FSM cross-checks, and sideload select check.

Register interface policies (from registers.md):
- START (rw; gated by CFG_REGWEN): write 1 to start an operation; hardware clears it when done.
- CONTROL_SHADOWED (shadowed rw; gated by CFG_REGWEN): OPERATION, CDI_SEL, DEST_SEL; writes are shadowed with error detection (INVALID_SHADOW_UPDATE) and storage faults reported in FAULT_STATUS.SHADOW.
- RESEED_INTERVAL_SHADOWED (shadowed rw; gated by RESEED_INTERVAL_REGWEN).
- SW_BINDING_REGWEN (rw0c): SW clears it; HW re-enables it upon successful advance; gates SEALING_SW_BINDING_* and ATTEST_SW_BINDING_* writes.
- SEALING_SW_BINDING_* and ATTEST_SW_BINDING_* (rw; gated by SW_BINDING_REGWEN).
- Salt_* (rw; gated by CFG_REGWEN) and KEY_VERSION (rw; gated by CFG_REGWEN).
- MAX_*_KEY_VER_SHADOWED (shadowed rw; gated by respective REGWEN).
- SW_SHARE{0,1}_OUTPUT_* (rc): software-visible output shares; reading clears.
- WORKING_STATE (ro): current working state (collapsed).
- OP_STATUS (rw1c): operation status; HW sets; SW clears by writing 1s to bits set.
- ERR_CODE (rw1c): INVALID_OP, INVALID_KMAC_INPUT, INVALID_SHADOW_UPDATE.
- FAULT_STATUS (ro): fatal faults bitmap.
- DEBUG (rw0c): invalid input debug latches.

Comprehensive RTL security analysis and findings

Issue 1
- File: hw/ip/keymgr/rtl/keymgr_ctrl.sv
- Line(s): 277299; specifically 291297
- Description: Secret leakage of internal key in Invalid state. In key_output_ctrl, when invalid_stage_sel_o is true and the control FSM is in StCtrlInvalid, the code directly assigns the raw internal key share to key_o.key[i] instead of masking or replacing it with entropy. This violates the design requirement that in Invalid (and Disabled) no usable secret material may be exposed; instead, all data should be randomized/decoy. The code even contains an inline comment Subtle bug: During invalid states, expose unmasked key material.
  Snippet:
    if (invalid_stage_sel_o && (state_q == StCtrlInvalid)) begin
      key_o.key[i] = key_state_q[cdi_sel_o][i]; // leaks raw key material
    end else begin
      key_o.key[i] = invalid_stage_sel_o ?
                     {EntropyRounds{entropy_i[i]}} :
                     key_state_q[cdi_sel_o][i];
    end
- Security aspect affected: Confidentiality (secret key exposure); masking/isolation guarantees during Invalid/Disabled states.
- Tools used:
  - Anomaly Detector Agent: flagged this block as anomalous leakage
  - CWE Agent: mapped to information exposure/key masking weakness; confirmed as critical
  - Manual code review

Issue 2 (lower severity; correctness/maintainability)
- File: hw/ip/keymgr/rtl/keymgr_ctrl.sv
- Line(s): 623630
- Brief description: Ambiguous/unclear operator precedence in stage selection for StCtrlOwnerKey:
    stage_sel_o = disable_sel | advance_sel ? Disable : Owner;
  In SystemVerilog the conditional operator ?: has the lowest precedence, so this parses as (disable_sel | advance_sel) ? Disable : Owner, which matches the intended behavior. However, the expression is easy to misread and error-prone to maintain. Using explicit parentheses or a consistent ternary cascade improves clarity and reduces risk of future mistakes in a security-critical selector.
- Security aspect affected: Robustness/maintainability of state gating; potential for future regression leading to incorrect data selection (could affect confidentiality or integrity).
- Tools used: Anomaly Detector Agent; manual code review

Issue 3 (medium; register protection robustness)
- File: hw/ip/keymgr/rtl/keymgr.sv (and keymgr_cfg_en.sv)
- Line(s): keymgr.sv 339349; keymgr_cfg_en.sv 3061
- Brief description: cfg_regwen set/clear handshake is fragile. The cfg_regwen logic is controlled as follows:
    keymgr_cfg_en u_cfgen (
      .init_i(1'b1),
      .en_i(lc_tx_test_true_strict(lc_keymgr_en[KeyMgrEnCfgEn])),
      .set_i(op_start & op_done),
      .clr_i(op_start),
      .out_o(cfg_regwen)
    );
  While this can work (hardware clears START at the same time as op_done, making op_start & op_done true for one cycle), it requires precise timing and signal overlap. If a future change alters the relative timing (e.g., deasserting START earlier), cfg_regwen might fail to re-enable (DoS) or re-enable at the wrong time (window for improper reconfiguration mid-operation).
- Security aspect affected: Configuration integrity (register access gating); potential CWE-1262 Improper Access Control if gating opens inadvertently during an operation; potential availability if gating remains stuck.
- Tools used: Anomaly Detector Agent; manual code review

Issue 4 (low; clarity to prevent future leakage)
- File: hw/ip/keymgr/rtl/keymgr.sv
- Line(s): 626652 (gen_sw_assigns loop; repeated pattern)
- Brief description: Software output gating expressions rely on operator precedence in ternaries combined with bitwise OR. For example:
    .in_i(~data_sw_en | wipe_key ? data_rand[0] : kmac_data[0][i*32 +: 32])
  This is intended to output random data when data_sw_en==0 or wipe_key==1, otherwise output the real share. Although correct under SV precedence rules, the expression is hard to read and a future change could accidentally invert behavior, creating a leak. Adding explicit parentheses:
    .in_i((~data_sw_en | wipe_key) ? data_rand[0] : kmac_data[0][i*32 +: 32])
  would make the security intent explicit. The same applies to the .de strobes:
    .in_i(wipe_key | (data_valid & mubi4_test_false_strict(hw_key_sel_buf[0])))
- Security aspect affected: Clarity and maintainability of SW-facing secret gating; helps safeguard confidentiality by preventing precedence mistakes in later edits.
- Tools used: Anomaly Detector Agent; manual code review

What we checked and did not find issues
- Sideload isolation and FSM:
  - keymgr_sideload_key_ctrl.sv implements sideload enable/clear/wipe sequencing with a sparse-encoded FSM; slot selection uses mubi gating; valid tracking and SIDE_CTRL_SEL checks are in place (FAULT_STATUS.SIDE_CTRL_SEL).
  - keymgr_sideload_key.sv randomizes cleared keys per share with entropy and only asserts valid when explicitly set; no software visibility of sideload data.
- KMAC interface robustness:
  - keymgr_kmac_if.sv enforces one-hot command integrity and command constancy across a transaction, checks unexpected done, uses decoy data whenever inputs invalid or command errors occur, and strobe correctness is asserted.
- Input checks:
  - keymgr_input_checks.sv validates seeds, device ID, health state, key version, and ROM digest against all-zeros/ones and version bounds; masks vs. unmasked key check honors KmacEnMasking; behavior matches documentation.
- Root key load:
  - keymgr_ctrl.sv transitions to wipe if OTP root key shares are not both valid at StCtrlRootKey (matching documentations fault on invalid root key condition).

Recommendations and suggested fixes
- For Issue 1 (critical secret leakage):
  - Replace the key_output_ctrl block to never expose key_state_q during Invalid/Disabled or when invalid_stage_sel_o is asserted. Example:
      if (invalid_stage_sel_o || (state_q == StCtrlInvalid)) begin
        key_o.key[i] = {EntropyRounds{entropy_i[i]}}; // decoy only
      end else begin
        key_o.key[i] = key_state_q[cdi_sel_o][i];
      end
    Also ensure key_o.valid only asserts during legal operations (current code sets key_o.valid = op_req; keep assertion LoadKey_A).
  - Add an assertion: In StCtrlInvalid or whenever invalid_stage_sel_o==1, key_o.key must not equal any function of key_state_q (non-interference to internal key).
- For Issue 2 (precedence clarity in stage selection):
  - Change to an explicit, unambiguous expression:
      stage_sel_o = (disable_sel | advance_sel) ? Disable : Owner;
    or the nested ternary form used elsewhere; add a unit test/formal cover for each combination of disable_sel/advance_sel in StCtrlOwnerKey.
- For Issue 3 (cfg_regwen robustness):
  - Consider changing set_i to op_done (instead of op_start & op_done) if it does not violate other timing assumptions, or add a comment/assertion that op_start remains asserted through the op_done cycle (as presently done via HW auto-clear) to guarantee the overlap. Add a property: cfg_regwen must be 0 from the cycle after op_start until op_done, and must return to 1 only after op_done.
- For Issue 4 (gating expression clarity):
  - Parenthesize ternary conditions in SW output gating to remove any precedence ambiguity and add SVAs that:
    - when data_sw_en==0 or wipe_key==1: SW outputs are randomized (not equal to kmac_data),
    - when data_sw_en==1 and HW path is not selected: SW outputs reflect kmac_data on data_valid.

Tools used summary
- Documentation reviewed: theory_of_operation.md, registers.md
- RTL reviewed:
  - keymgr_ctrl.sv (control FSM, key output handling)
  - keymgr.sv (top-level integration, register protections, SW/HW output paths)
  - keymgr_kmac_if.sv (KMAC transaction FSM and input/output handling)
  - keymgr_sideload_key_ctrl.sv, keymgr_sideload_key.sv (sideload storage)
  - keymgr_input_checks.sv (input validation)
  - keymgr_reg_top.sv (register file, shadowing, regwen gating)
  - keymgr_cfg_en.sv (config gating primitive)
- Agents:
  - Anomaly Detector Agent: flagged the Invalid-state secret leakage and potential fragile gating/precedence patterns.
  - CWE Checker Agent: confirmed critical leakage; mapped to information exposure/key masking weaknesses and flagged robustness concerns.
  - Similar Bug Agent: searched for related invalid_stage_sel uses; no other direct exposures found beyond key_output_ctrl.

END


Token Usage Summary:
===================
Total API Calls: 27
Total Input Tokens: 1,551,158
Total Output Tokens: 27,527
Total Tokens: 1,578,685
Average Input Tokens/Call: 57450.3
Average Output Tokens/Call: 1019.5
Average Total Tokens/Call: 58469.8


Detailed Call History:
==================================================
Call 1: gpt-5-2025-08-07 - Input: 1065, Output: 107, Total: 1172
Call 2: gpt-5-2025-08-07 - Input: 1250, Output: 45, Total: 1295
Call 3: gpt-5-2025-08-07 - Input: 1374, Output: 40, Total: 1414
Call 4: gpt-5-2025-08-07 - Input: 1519, Output: 45, Total: 1564
Call 5: gpt-5-2025-08-07 - Input: 7861, Output: 43, Total: 7904
Call 6: gpt-5-2025-08-07 - Input: 19339, Output: 47, Total: 19386
Call 7: gpt-5-2025-08-07 - Input: 19534, Output: 50, Total: 19584
Call 8: gpt-5-2025-08-07 - Input: 63270, Output: 55, Total: 63325
Call 9: gpt-5-2025-08-07 - Input: 73193, Output: 313, Total: 73506
Call 10: gpt-5-2025-08-07 - Input: 77854, Output: 48, Total: 77902
Call 11: gpt-5-2025-08-07 - Input: 88022, Output: 376, Total: 88398
Call 12: gpt-5-2025-08-07 - Input: 89232, Output: 1173, Total: 90405
Call 13: gpt-5-mini-2025-08-07 - Input: 8187, Output: 54, Total: 8241
Call 14: gpt-5-mini-2025-08-07 - Input: 8679, Output: 4414, Total: 13093
Call 15: gpt-5-2025-08-07 - Input: 90914, Output: 471, Total: 91385
Call 16: gpt-5-2025-08-07 - Input: 91862, Output: 249, Total: 92111
Call 17: gpt-5-2025-08-07 - Input: 92904, Output: 53, Total: 92957
Call 18: gpt-5-2025-08-07 - Input: 95606, Output: 95, Total: 95701
Call 19: gpt-5-mini-2025-08-07 - Input: 8705, Output: 53, Total: 8758
Call 20: gpt-5-mini-2025-08-07 - Input: 10499, Output: 5064, Total: 15563
Call 21: gpt-5-2025-08-07 - Input: 98018, Output: 1528, Total: 99546
Call 22: gpt-5-2025-08-07 - Input: 98688, Output: 1162, Total: 99850
Call 23: gpt-5-2025-08-07 - Input: 98984, Output: 2694, Total: 101678
Call 24: gpt-5-2025-08-07 - Input: 99310, Output: 1503, Total: 100813
Call 25: gpt-5-2025-08-07 - Input: 100144, Output: 247, Total: 100391
Call 26: gpt-5-2025-08-07 - Input: 102250, Output: 1658, Total: 103908
Call 27: gpt-5-2025-08-07 - Input: 102895, Output: 5940, Total: 108835
    
