================================ System Message ================================


    You are a supervisor agent in a multi-agent system focused on identifying hardware security vulnerabilities in RTL code. 
    Your objective is to analyze the given SoC and generate a detailed security report.

    You have access to the following tools: ['run_anomaly_detector_agent', 'run_llm_cwe_checker_agent', 'run_similar_bug_agent', 'list_dir', 'read_file', 'read_file_with_line_numbers']. Each tool specializes in a specific task:

    - CWE Agent: Given a Verilog file, a top module, and a security aspect, this agent maps the RTL code to relevant CWEs and detects CWE-related vulnerabilities.
    - Similar Bug Agent: Accepts a file path and a line number (where a bug was found) to locate similar patterns or recurring bugs throughout the RTL code.

    Instructions for analysis:

    - Read the documentataion to identify security features and register interfaces policies.
    - Read through the different systemverilog files to probe for issues and use the anomaly agent
    - If a bug is detected but not localized, use the CWE Agent to further inspect the related security aspect in the surrounding RTL.
    - After detecting any bugs, use the Similar Bug Agent to scan similar files (of the same or of different IPs) for similar vulnerabilities.

    Output Format:

    - For each identified issue, report:
    - File name
    - Line number(s)
    - Brief description of the issue
    - Security aspect affected
    - Tools used to identify the issue

    When your analysis is complete, end your response with "END".
    
================================ Human Message =================================

Identify security issues in the hmac IP of the OpenTitan SoC, located at /home/eden/Desktop/Code/HACK@CHES/p2/opentitan.

    - All IPs are located in the 'hw/ip' directory.
    - RTL code for each IP is located in its 'rtl' subdirectory, with source files having the '.sv' extension.
        - reg_top files contain the register interface for the IP.
        - control/fsm files contain the control logic for the IP.
        - core files contain the core logic for the IP.
    - Documentation files (.md) are located in the 'doc' directories of each IP.
        - theory_of_operation explains the properties of the IP and its security features.
        - registers.md files contain the register interface and its read/write access policies.
    - Ignore '.core' files; they are used by build tools and are not relevant for security analysis.

    Focus on the hmac IP and make sure to analyze it thoroughly.

    First, identify the relevant security properties and read/write policies of the register interfaces from the documentation. 
    Then, use all available tools to perform a comprehensive security analysis on the RTL code.
    
================================== Ai Message ==================================
Tool Calls:
  list_dir (call_pdgotToVmFLkTy9GXBl8EN0z)
 Call ID: call_pdgotToVmFLkTy9GXBl8EN0z
  Args:
    dir_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip
================================= Tool Message =================================
Name: list_dir

Files in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip:
README.md BUILD

Directories in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip:
pattgen csrng aon_timer prim_generic keymgr_dpe uart keymgr i2c dma spi_host otp_ctrl rom_ctrl spi_device edn usbdev adc_ctrl trial1 kmac flash_ctrl otp_macro rv_dm mbx rv_timer prim_xilinx prim prim_xilinx_ultrascale aes lc_ctrl hmac rv_core_ibex sram_ctrl entropy_src racl_ctrl sysrst_ctrl tlul soc_dbg_ctrl otbn ascon
================================== Ai Message ==================================
Tool Calls:
  list_dir (call_YhdtUuACHCdjp62241eDVtXH)
 Call ID: call_YhdtUuACHCdjp62241eDVtXH
  Args:
    dir_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac
================================= Tool Message =================================
Name: list_dir

Files in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac:
README.md BUILD hmac.core defs.bzl

Directories in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac:
data model syn dv rtl lint doc
================================== Ai Message ==================================
Tool Calls:
  list_dir (call_MD3USOANv3ryI5GFGfZajRQr)
 Call ID: call_MD3USOANv3ryI5GFGfZajRQr
  Args:
    dir_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/doc
================================= Tool Message =================================
Name: list_dir

Files in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/doc:
registers.md interfaces.md checklist.md hmac_block_diagram.svg programmers_guide.md message_padding.svg hmac_dataflow.svg theory_of_operation.md sha2_block_diagram.svg

Directories in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/doc:

================================== Ai Message ==================================
Tool Calls:
  read_file (call_TLevpXYhutQHwVGoy3Kh2p73)
 Call ID: call_TLevpXYhutQHwVGoy3Kh2p73
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/doc/theory_of_operation.md
================================= Tool Message =================================
Name: read_file

# Theory of Operation

## Block Diagram

![HMAC Block Diagram](../doc/hmac_block_diagram.svg)

The HMAC block diagram above shows that the HMAC core converts the secret key registers into an inner padded key and an outer padded key which are fed to the SHA-2 hash engine (which is a SHA-2 engine primitive instantiated with the multi-mode feature enabled) when appropriate.
The module also feeds the result of the first round message (which uses the inner padded key) from the SHA-2 hash engine into the 32x32b message FIFO for the second round (which uses the outer padded key).
The message length is automatically updated to reflect the size of the outer padded key and first round digest result for the second round.
See [Design Details](#design-details) for more information.

![SHA-2 Block Diagram](../doc/sha2_block_diagram.svg)

[sha256-spec]: https://csrc.nist.gov/publications/detail/fips/180/4/final

The SHA-2 engine block diagram shows the message scheduling FIFO array, hash registers, digest registers, and SHA-2 compression function inside SHA-2 engine.
The message scheduling FIFO is not software accessible but is fed from the 32x32b message FIFO seen in the HMAC block diagram via the HMAC core.
The HMAC core can forward the message directly from the 32x32b message FIFO if HMAC is not enabled.
The message words are padded with the message length appended to fit either the 512-bit or 1024-bit block size (depending on the configured digest size) as described in the [SHA-256
specification][sha256-spec].

With the 512-bit block (for SHA-2 256), the compression function runs 64 rounds to calculate the block hash, which is stored in the hash registers above.
After 64 rounds are completed, the SHA-2 256 updates the digest registers with the addition of the hash result and the previous digest registers.
With the 1024-bit block (for SHA-2 384/512), the compression function runs 80 rounds instead.
SHA-2 384 is a truncated version of SHA-2 512 where the last 128 bits of the final digest output are truncated to reduce the digest size to 384 bits.


## Design Details

### SHA-2 message feed and pad

A message is fed via a memory-mapped message FIFO.
Any write access to the memory-mapped window [`MSG_FIFO`](registers.md#msg_fifo) updates the message FIFO.
If the FIFO is full, the HMAC block will block any writes leading to back-pressure on the interconnect (as opposed to dropping those writes or overwriting existing FIFO contents).
It is recommended to avoid this back-pressure by not writing to the memory-mapped message FIFO when it is full.
To avoid doing so, software can read the [`STATUS.fifo_full`](registers.md#status) register.

The logic assumes the input message is little-endian.
It converts the byte order of the word right before writing to SHA-2 storage as SHA-2 treats the incoming message as big-endian.
If SW wants to convert the message byte order, SW should set [`CFG.endian_swap`](registers.md#cfg) to **1**.
The byte order of the digest registers, from [`DIGEST_0-DIGEST_15`](registers.md#digest) can be configured with [`CFG.digest_swap`](registers.md#cfg--digest_swap).

See the table below:

```
Input Msg #0: 010203h
Input Msg #1: 0405h
```

endian_swap     | 0         | 1
----------------|-----------|-----------
Push to SHA2 #0 | 03020105h | 01020304h
Push to SHA2 #1 | 00000004h | 00000005h


Small writes to [`MSG_FIFO`](registers.md#msg_fifo) are coalesced into 32-bit words by the [packer logic]({{< relref "hw/ip/prim/doc/prim_packer" >}}).
These words are fed into the internal message scheduling FIFO.
While passing writes to the packer logic, the block also counts the number of bytes that are being passed.
This computes the received message length, which is used in the HMAC and SHA-2 hash computation logic.

The SHA-2 engine computes an intermediate hash for every 512-bit or 1024-bit block depending on the configured digest size.
The message must be padded to fill the 512/1024-bit blocks.
This is done with an initial **1** bit after the actual message bits, followed by enough **0** padding bits, and then the 64/128-bit message length at the end of the block.
The number of **0** padding bits should be enough such that the full block size (512 or 1024 bits) is achieved.
The [SHA-256 specification][sha256-spec] describes this in more detail.
An example is shown below.
The padding logic handles this so software only needs to write the actual message bits into the message FIFO.

![SHA-2 Message Padding](../doc/message_padding.svg)

For example, for SHA-2 256, if the message is empty, the message length is 64-bit 0.
In this case, the padding logic gives `0x80000000` into the SHA-2 module first.
Then it sends (512 - 32 - 64)/32, 13 times of `0x00000000` for Padding `0x00`.
Lastly, it returns the message length which is 64-bit `0x00000000_00000000`.
If incomplete words are written, the packet logic appends `0x80` in the proper byte
location, such as `0xXX800000` for the message length % 4B == 1 case.
This similarly occurs for SHA-2 384/512 but with a 128-bit message length and block size of 1024 bits.

### SHA-2 computation

For SHA-2 256, the SHA-2 engine receives 16 32-bit words from the message FIFO or the HMAC core, which get padded into 16 64-bit words for the SHA-2 engine (upper 32 bits of each data word are all-zero padded), and then begin 64 rounds of the hash computation which is also called *compression*.
Alternatively for SHA-2 384/512, the SHA-2 engine receives 32 32-bit words from message FIFO, which get packed into 16 64-bit words for the SHA-2 engine, and then begin the 80 compression rounds.
In each round, the compression function fetches a 64-bit word from the buffer and computes the internal variables.
The first 16 rounds are fed by the words from the message FIFO or the HMAC core.
Input for later rounds comes from shuffling the given 512/1024-bit block.
Details are well described in [Wikipedia][sha2-wikipedia] and the [SHA-256 specification][sha256-spec].

[sha2-wikipedia]: https://en.wikipedia.org/wiki/SHA-2

With the given hash values, 4-byte (or 8-byte) message word, and round constants, the compression function computes the next round hash values.
The round constants for the different digest sizes are hard-wired in the design.
After the compression at the last round is finished, the resulting hash values are added into the digest.
The digest, again, is used as initial hash values for the next block compression.
During the compression rounds, it doesn't fetch data from the message FIFO.
The software can push up to 16 (or 32 for SHA-2 384/512) entries to the FIFO for the next hash computation.

### HMAC computation

![Two steps of HMAC](../doc/hmac_dataflow.svg)

HMAC can be used with any hash algorithm but this version of HMAC IP uses SHA-2 256/384/512.
The first phase of HMAC calculates the SHA-2 hash of the inner secret key concatenated with the actual message to be authenticated.
This inner secret key is created with the 128/256/384/512/1024-bit (hashed) secret key (depending on the configured key length) and `0x36` padding to complete the corresponding block size of the configured digest size.
For example, for SHA-2 256 with 256-bit key, 512-bit inner secret key is created with the 256-bit secret key with 256-bit zero padding, XORed with 64{`0x36`}.

```verilog
    inner_pad_key = {key[255:0], 256'h0} ^ {64{8'h36}} // big-endian
```

The message length used in the SHA-2 module is calculated by the HMAC core by adding the block size to the original message length (to account for the length of `inner_pad_key`, which has been prepended to the message).

The first round digest is fed into the second round in HMAC.
The second round computes the hash of the outer secret key concatenated with the first round digest.
In case of SHA-2 256 with 256-bit key, as the digest result is 256-bit, it must be zero-padded to fit into 512-bit block size.

```verilog
    outer_pad_key = {key[255:0], 256'h0} ^ {64{8'h5c}} // big-endian
```

In the second round, the message length is a fixed 768 bits (512-bit size of outer secret key + 256-bit first round digest size).

HMAC supports a secret key of length 128/256/384/512/1024-bit, so long as the key length does not exceed the block size of the configured digest, i.e., for SHA-2 256 a maximum length of 512-bit key is supported.
The byte order of the key registers is big-endian by default, can be swapped to little endian by setting [`CFG.key_swap`](registers.md#cfg--key_swap) to 1.
To support any arbitrary key length, the software should configure the HMAC to the next largest supported key length and concatenate zeros to reach the programmed key size.
The position of these zeros depends on the endianness, thus on the programmed [`CFG.key_swap`](registers.md#cfg--key_swap).
For example, for an 80-bit key, HMAC should be configured with an 128-bit key length, fed with the 80-bit key and with 48 zero-bits.
It is also up to the software to shrink the key to the supported key length (up to 512-bit for SHA-2 256 and up to 1024-bit for SHA-2 384/512) using a hash function when setting up the HMAC.
For example, common key sizes may be 2048-bit or 4096-bit.
Software is expected to hash these into the supported key length and write the hashed result as the configured key to the HMAC IP.

### Performance in SHA-2 mode and HMAC mode

The SHA-2 256 hash algorithm computes 512 bits of data at a time.
The first 16 rounds need the actual 16 x 32-bit message and the following 48 rounds need some value derived from the message.

In these 48 rounds, the software can feed the next 16 x 32-bit message block.
But, once the FIFO gets full, the software cannot push more data until the current block is processed.
This version of the IP fetches the next 16 x 32-bit message into the internal message scheduling array only after completing the current block.
As such, it takes 80 cycles to complete a block.
The effective throughput considering this is `64 byte / 80 clk` or `16 clk / 80 clk`, 20% of the maximum throughput.
For instance, if the clock frequency is 100MHz, the SHA-2 256 can hash out 80MB/s at most.

For SHA-2 384/512, the algorithm computes 1024 bits of data a time and runs for 80 rounds where the first 16 rounds consume the actual 16 x 64-bit message.
It takes 96 cycles to complete a 1024-bit block. If the clock frequency is 100MHz, the SHA-2 384/512 can hash out 133MB/s at most.

This throughput could be enhanced in a future version by feeding the message into the internal buffer when the round hits 48, eliminating the extra 16 cycles to feed the message after completing a block.

If HMAC mode is turned on, it introduces extra latency due to the second round of computing the final hash of the outer key and the result of the first round using the inner key.
This adds an extra 240 cycles (80 for the inner key, 80 for the outer key, and 80 for the result of the first round) to complete a HMAC SHA-2 256 digest of a message.
For instance, if an empty message is given then it takes 360 cycles (80 for msg itself and 240 for the extra) to get the HMAC authentication token.

### MSG_FIFO

The MSG_FIFO in the HMAC IP has a wide address range not just one 4 byte address.
Any writes to the address range go into the single entry point of the `prim_packer`.
Then `prim_packer` compacts the data into the word-size if not a word-write then writes to the MSG_FIFO.
This is different from a conventional memory-mapped FIFO.

By having wide address range pointing to a single entry point, the FIFO can free software from the fixed address restriction.
For instance, the core can use "store multiple" commands to feed the message fifo efficiently.
Also, a DMA engine which might not have the ability to be configured to the fixed write and incremental read may benefit from this behavior.

================================== Ai Message ==================================
Tool Calls:
  read_file (call_I8wZkrT9JjjUCLJfT6UZLfCk)
 Call ID: call_I8wZkrT9JjjUCLJfT6UZLfCk
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/doc/registers.md
================================= Tool Message =================================
Name: read_file

# Registers

<!-- BEGIN CMDGEN util/regtool.py -d ./hw/ip/hmac/data/hmac.hjson -->
## Summary

| Name                                         | Offset   |   Length | Description                                                          |
|:---------------------------------------------|:---------|---------:|:---------------------------------------------------------------------|
| hmac.[`INTR_STATE`](#intr_state)             | 0x0      |        4 | Interrupt State Register                                             |
| hmac.[`INTR_ENABLE`](#intr_enable)           | 0x4      |        4 | Interrupt Enable Register                                            |
| hmac.[`INTR_TEST`](#intr_test)               | 0x8      |        4 | Interrupt Test Register                                              |
| hmac.[`ALERT_TEST`](#alert_test)             | 0xc      |        4 | Alert Test Register                                                  |
| hmac.[`CFG`](#cfg)                           | 0x10     |        4 | HMAC Configuration register.                                         |
| hmac.[`CMD`](#cmd)                           | 0x14     |        4 | HMAC command register                                                |
| hmac.[`STATUS`](#status)                     | 0x18     |        4 | HMAC Status register                                                 |
| hmac.[`ERR_CODE`](#err_code)                 | 0x1c     |        4 | HMAC Error Code                                                      |
| hmac.[`WIPE_SECRET`](#wipe_secret)           | 0x20     |        4 | Clear internal secret registers.                                     |
| hmac.[`KEY_0`](#key)                         | 0x24     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_1`](#key)                         | 0x28     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_2`](#key)                         | 0x2c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_3`](#key)                         | 0x30     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_4`](#key)                         | 0x34     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_5`](#key)                         | 0x38     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_6`](#key)                         | 0x3c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_7`](#key)                         | 0x40     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_8`](#key)                         | 0x44     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_9`](#key)                         | 0x48     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_10`](#key)                        | 0x4c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_11`](#key)                        | 0x50     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_12`](#key)                        | 0x54     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_13`](#key)                        | 0x58     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_14`](#key)                        | 0x5c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_15`](#key)                        | 0x60     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_16`](#key)                        | 0x64     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_17`](#key)                        | 0x68     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_18`](#key)                        | 0x6c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_19`](#key)                        | 0x70     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_20`](#key)                        | 0x74     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_21`](#key)                        | 0x78     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_22`](#key)                        | 0x7c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_23`](#key)                        | 0x80     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_24`](#key)                        | 0x84     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_25`](#key)                        | 0x88     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_26`](#key)                        | 0x8c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_27`](#key)                        | 0x90     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_28`](#key)                        | 0x94     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_29`](#key)                        | 0x98     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_30`](#key)                        | 0x9c     |        4 | HMAC Secret Key                                                      |
| hmac.[`KEY_31`](#key)                        | 0xa0     |        4 | HMAC Secret Key                                                      |
| hmac.[`DIGEST_0`](#digest)                   | 0xa4     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_1`](#digest)                   | 0xa8     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_2`](#digest)                   | 0xac     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_3`](#digest)                   | 0xb0     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_4`](#digest)                   | 0xb4     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_5`](#digest)                   | 0xb8     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_6`](#digest)                   | 0xbc     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_7`](#digest)                   | 0xc0     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_8`](#digest)                   | 0xc4     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_9`](#digest)                   | 0xc8     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_10`](#digest)                  | 0xcc     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_11`](#digest)                  | 0xd0     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_12`](#digest)                  | 0xd4     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_13`](#digest)                  | 0xd8     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_14`](#digest)                  | 0xdc     |        4 | Digest output.                                                       |
| hmac.[`DIGEST_15`](#digest)                  | 0xe0     |        4 | Digest output.                                                       |
| hmac.[`MSG_LENGTH_LOWER`](#msg_length_lower) | 0xe4     |        4 | Received Message Length calculated by the HMAC in bits [31:0]        |
| hmac.[`MSG_LENGTH_UPPER`](#msg_length_upper) | 0xe8     |        4 | Received Message Length calculated by the HMAC in bits [63:32]       |
| hmac.[`MSG_FIFO`](#msg_fifo)                 | 0x1000   |     4096 | Message FIFO. Any write to this window will be appended to the FIFO. |

## INTR_STATE
Interrupt State Register
- Offset: `0x0`
- Reset default: `0x0`
- Reset mask: `0x7`

### Fields

```wavejson
{"reg": [{"name": "hmac_done", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"name": "fifo_empty", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "hmac_err", "bits": 1, "attr": ["rw1c"], "rotate": -90}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 120}}
```

|  Bits  |  Type  |  Reset  | Name                                  |
|:------:|:------:|:-------:|:--------------------------------------|
|  31:3  |        |         | Reserved                              |
|   2    |  rw1c  |   0x0   | [hmac_err](#intr_state--hmac_err)     |
|   1    |   ro   |   0x0   | [fifo_empty](#intr_state--fifo_empty) |
|   0    |  rw1c  |   0x0   | [hmac_done](#intr_state--hmac_done)   |

### INTR_STATE . hmac_err
HMAC error has occurred. ERR_CODE register shows which error occurred.

### INTR_STATE . fifo_empty
The message FIFO is empty.
This interrupt is raised only if the message FIFO is actually writable by software, i.e., if all of the following conditions are met:
i) The HMAC block is not running in HMAC mode and performing the second round of computing the final hash of the outer key as well as the result of the first round using the inner key.
ii) Software has not yet written the Process or Stop command to finish the hashing operation.
For the interrupt to be raised, the message FIFO must also have been full previously.
Otherwise, the hardware empties the FIFO faster than software can fill it and there is no point in interrupting the software to inform it about the message FIFO being empty.

### INTR_STATE . hmac_done
HMAC/SHA-2 has completed.

## INTR_ENABLE
Interrupt Enable Register
- Offset: `0x4`
- Reset default: `0x0`
- Reset mask: `0x7`

### Fields

```wavejson
{"reg": [{"name": "hmac_done", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "fifo_empty", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "hmac_err", "bits": 1, "attr": ["rw"], "rotate": -90}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 120}}
```

|  Bits  |  Type  |  Reset  | Name       | Description                                                          |
|:------:|:------:|:-------:|:-----------|:---------------------------------------------------------------------|
|  31:3  |        |         |            | Reserved                                                             |
|   2    |   rw   |   0x0   | hmac_err   | Enable interrupt when [`INTR_STATE.hmac_err`](#intr_state) is set.   |
|   1    |   rw   |   0x0   | fifo_empty | Enable interrupt when [`INTR_STATE.fifo_empty`](#intr_state) is set. |
|   0    |   rw   |   0x0   | hmac_done  | Enable interrupt when [`INTR_STATE.hmac_done`](#intr_state) is set.  |

## INTR_TEST
Interrupt Test Register
- Offset: `0x8`
- Reset default: `0x0`
- Reset mask: `0x7`

### Fields

```wavejson
{"reg": [{"name": "hmac_done", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "fifo_empty", "bits": 1, "attr": ["wo"], "rotate": -90}, {"name": "hmac_err", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 29}], "config": {"lanes": 1, "fontsize": 10, "vspace": 120}}
```

|  Bits  |  Type  |  Reset  | Name       | Description                                                   |
|:------:|:------:|:-------:|:-----------|:--------------------------------------------------------------|
|  31:3  |        |         |            | Reserved                                                      |
|   2    |   wo   |   0x0   | hmac_err   | Write 1 to force [`INTR_STATE.hmac_err`](#intr_state) to 1.   |
|   1    |   wo   |   0x0   | fifo_empty | Write 1 to force [`INTR_STATE.fifo_empty`](#intr_state) to 1. |
|   0    |   wo   |   0x0   | hmac_done  | Write 1 to force [`INTR_STATE.hmac_done`](#intr_state) to 1.  |

## ALERT_TEST
Alert Test Register
- Offset: `0xc`
- Reset default: `0x0`
- Reset mask: `0x1`

### Fields

```wavejson
{"reg": [{"name": "fatal_fault", "bits": 1, "attr": ["wo"], "rotate": -90}, {"bits": 31}], "config": {"lanes": 1, "fontsize": 10, "vspace": 130}}
```

|  Bits  |  Type  |  Reset  | Name        | Description                                      |
|:------:|:------:|:-------:|:------------|:-------------------------------------------------|
|  31:1  |        |         |             | Reserved                                         |
|   0    |   wo   |   0x0   | fatal_fault | Write 1 to trigger one alert event of this kind. |

## CFG
HMAC Configuration register.

The register is updated when the engine is in Idle.
If the software updates the register while the engine computes the hash, the updated value is discarded.
- Offset: `0x10`
- Reset default: `0x4100`
- Reset mask: `0x7fff`

### Fields

```wavejson
{"reg": [{"name": "hmac_en", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "sha_en", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "endian_swap", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "digest_swap", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "key_swap", "bits": 1, "attr": ["rw"], "rotate": -90}, {"name": "digest_size", "bits": 4, "attr": ["rw"], "rotate": -90}, {"name": "key_length", "bits": 6, "attr": ["rw"], "rotate": 0}, {"bits": 17}], "config": {"lanes": 1, "fontsize": 10, "vspace": 130}}
```

|  Bits  |  Type  |  Reset  | Name                             |
|:------:|:------:|:-------:|:---------------------------------|
| 31:15  |        |         | Reserved                         |
|  14:9  |   rw   |  0x20   | [key_length](#cfg--key_length)   |
|  8:5   |   rw   |   0x8   | [digest_size](#cfg--digest_size) |
|   4    |   rw   |   0x0   | [key_swap](#cfg--key_swap)       |
|   3    |   rw   |   0x0   | [digest_swap](#cfg--digest_swap) |
|   2    |   rw   |   0x0   | [endian_swap](#cfg--endian_swap) |
|   1    |   rw   |    x    | [sha_en](#cfg--sha_en)           |
|   0    |   rw   |    x    | [hmac_en](#cfg--hmac_en)         |

### CFG . key_length
Key length configuration.

This is a 6-bit one-hot encoded field to configure the key length for HMAC.

The HMAC can be programmed with the following key lengths: 128-bit, 256-bit, 384-bit, 512-bit and 1024-bit.
But the HMAC supports any arbitrary key length: the software should configure the HMAC with the next largest supported key length and concatenate zeros to reach the programmed key length.
The position of these zeros depends on the endianness, thus on the programmed [`CFG.key_swap`](registers.md#cfg--key_swap).
For example, for an 80-bit key, HMAC should be configured with an 128-bit key length, fed with the 80-bit key and with 48 zero-bits.

Note that the key length cannot be greater than the block size: up to 1024-bit for SHA-2 384/512 and up to 512-bit for SHA-2 256.
The value of this register is irrelevant when only SHA-2 (not keyed HMAC) is configured.
However, for HMAC mode (`hmac_en == 1`), when HMAC is triggered to start while [`KEY_LENGTH`](#key_length) holds `Key_None` or [`KEY_LENGTH`](#key_length) holds `Key_1024` for [`DIGEST_SIZE`](#digest_size) = `SHA2_256`, starting is blocked and an error is signalled to SW.

| Value   | Name     | Description                                                                                                                                                                                                                                                                                                                                                                  |
|:--------|:---------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0x01    | Key_128  | 6'b00_0001: 128-bit secret key.                                                                                                                                                                                                                                                                                                                                              |
| 0x02    | Key_256  | 6'b00_0010: 256-bit secret key.                                                                                                                                                                                                                                                                                                                                              |
| 0x04    | Key_384  | 6'b00_0100: 384-bit secret key.                                                                                                                                                                                                                                                                                                                                              |
| 0x08    | Key_512  | 6'b00_1000: 512-bit secret key.                                                                                                                                                                                                                                                                                                                                              |
| 0x10    | Key_1024 | 6'b01_0000: 1024-bit secret key.                                                                                                                                                                                                                                                                                                                                             |
| 0x20    | Key_None | 6'b10_0000: Unsupported/invalid values and all-zero values are mapped to Key_None. With this value, when HMAC is triggered to start operation (via `hash_start` or `hash_continue`), it will be blocked from starting and an error is signalled to the SW. If only unkeyed SHA-2 is configured (`hmac_en == 0`), starting is not blocked, since this does not require a key. |

Other values are reserved.

### CFG . digest_size
Digest size configuration.

This is a 4-bit one-hot encoded field to select digest size for either HMAC or SHA-2.
Invalid/unsupported values, i.e., values that don't correspond to SHA2_256, SHA2_384, or SHA2_512, are mapped to SHA2_None.

| Value   | Name      | Description                                                                                                                                                                                                                                                    |
|:--------|:----------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0x1     | SHA2_256  | 4'b0001: SHA-2 256 digest.                                                                                                                                                                                                                                     |
| 0x2     | SHA2_384  | 4'b0010: SHA-2 384 digest.                                                                                                                                                                                                                                     |
| 0x4     | SHA2_512  | 4'b0100: SHA-2 512 digest.                                                                                                                                                                                                                                     |
| 0x8     | SHA2_None | 4'b1000: Unsupported/invalid values and all-zero values are mapped to SHA2_None. With this value, when HMAC/SHA-2 is triggered to start operation (via `hash_start` or `hash_continue`), it will be blocked from starting and an error is signalled to the SW. |

Other values are reserved.

### CFG . key_swap
Key register byte swap.

If 1 the endianness of each KEY_* register is swapped. Default value (value 0) is big endian representation of the KEY_* CSRs.

### CFG . digest_swap
Digest register byte swap.

If 1 the value in each digest output register is converted to big-endian byte order.
This setting does not affect the order of the digest output registers, [`DIGEST_0`](#digest_0) still contains the first 4 bytes of the digest.

### CFG . endian_swap
Endian swap.

If 0, each value will be added to the message in little-endian byte order.
The value is written to MSG_FIFO same to the SW writes.
If 1, then each individual multi-byte value, regardless of its alignment, written to [`MSG_FIFO`](#msg_fifo) will be added to the message in big-endian byte order.
A message written to [`MSG_FIFO`](#msg_fifo) one byte at a time will not be affected by this setting.
From a hardware perspective byte swaps are performed on a TL-UL word granularity.

### CFG . sha_en
SHA-2 enable.

 If 0, the SHA engine will not initiate compression, this is used to stop operation of the SHA-2 engine until configuration has been done.
 When the SHA-2 engine is disabled the digest is cleared.

### CFG . hmac_en
HMAC datapath enable.

If this bit is 1, HMAC operates when `hash_start` toggles.

## CMD
HMAC command register
- Offset: `0x14`
- Reset default: `0x0`
- Reset mask: `0xf`

### Fields

```wavejson
{"reg": [{"name": "hash_start", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"name": "hash_process", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"name": "hash_stop", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"name": "hash_continue", "bits": 1, "attr": ["r0w1c"], "rotate": -90}, {"bits": 28}], "config": {"lanes": 1, "fontsize": 10, "vspace": 150}}
```

|  Bits  |  Type  |  Reset  | Name                                 |
|:------:|:------:|:-------:|:-------------------------------------|
|  31:4  |        |         | Reserved                             |
|   3    | r0w1c  |    x    | [hash_continue](#cmd--hash_continue) |
|   2    | r0w1c  |    x    | [hash_stop](#cmd--hash_stop)         |
|   1    | r0w1c  |    x    | [hash_process](#cmd--hash_process)   |
|   0    | r0w1c  |    x    | [hash_start](#cmd--hash_start)       |

### CMD . hash_continue
When 1 is written to this field, SHA-2 or HMAC will continue hashing based on the current hash in the digest registers and the message length, which both have to be restored to switch context.

### CMD . hash_stop
When 1 is written to this field, SHA-2 or HMAC will afterwards set the `hmac_done` interrupt as soon as the current block has been hashed.
The hash can then be read from the registers [`DIGEST_0`](#digest_0) to [`DIGEST_15.`](#digest_15)
Together with the message length in [`MSG_LENGTH_LOWER`](#msg_length_lower) and [`MSG_LENGTH_UPPER`](#msg_length_upper), this forms the information that has to be saved before switching context.

### CMD . hash_process
If 1 is written to this field, SHA-2 or HMAC calculates the digest or signing based on currently received message.

### CMD . hash_start
If 1 is written into this field, SHA-2 or HMAC begins its operation.
CPU must configure relative information first, such as the digest size, secret key and the key length.

## STATUS
HMAC Status register
- Offset: `0x18`
- Reset default: `0x3`
- Reset mask: `0x3f7`

### Fields

```wavejson
{"reg": [{"name": "hmac_idle", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "fifo_empty", "bits": 1, "attr": ["ro"], "rotate": -90}, {"name": "fifo_full", "bits": 1, "attr": ["ro"], "rotate": -90}, {"bits": 1}, {"name": "fifo_depth", "bits": 6, "attr": ["ro"], "rotate": 0}, {"bits": 22}], "config": {"lanes": 1, "fontsize": 10, "vspace": 120}}
```

|  Bits  |  Type  |  Reset  | Name       | Description                                                                                                                                                                       |
|:------:|:------:|:-------:|:-----------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31:10  |        |         |            | Reserved                                                                                                                                                                          |
|  9:4   |   ro   |    x    | fifo_depth | FIFO entry count.                                                                                                                                                                 |
|   3    |        |         |            | Reserved                                                                                                                                                                          |
|   2    |   ro   |    x    | fifo_full  | FIFO full. Data written to the FIFO whilst it is full will cause back-pressure on the interconnect                                                                                |
|   1    |   ro   |   0x1   | fifo_empty | FIFO empty                                                                                                                                                                        |
|   0    |   ro   |   0x1   | hmac_idle  | HMAC idle status. When IDLE, the `DIGEST` and the `MSG_LENGTH_LOWER`/`MSG_LENGTH_UPPER` can be written to from SW which enables restoring context (to support context switching). |

## ERR_CODE
HMAC Error Code
- Offset: `0x1c`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "err_code", "bits": 32, "attr": ["ro"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name     | Description                                                                                                                                              |
|:------:|:------:|:-------:|:---------|:---------------------------------------------------------------------------------------------------------------------------------------------------------|
|  31:0  |   ro   |   0x0   | err_code | If an error interrupt occurs, this register has information of error cause. Please take a look at `hw/ip/prim/rtl/prim_sha2_pkg.sv:err_code_e enum type. |

## WIPE_SECRET
Clear internal secret registers.

If the CPU writes a value into the register, the value is used to clear some internal variables such as the secret key, intermediate hash results, digest and internal message scheduling array.
The clear secret operation overwrites the internal variables with the provided 32-bit value.
For SHA-2 384/512 that work with 64-bit words, the 32-bit value is duplicated and concatenated to generate the 64-bit value.
It is recommended to use a value extracted from an entropy source.
- Offset: `0x20`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "secret", "bits": 32, "attr": ["wo"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description   |
|:------:|:------:|:-------:|:-------|:--------------|
|  31:0  |   wo   |    x    | secret | Secret value  |

## KEY
HMAC Secret Key

HMAC using SHA-2 256/384/512 assumes any hashed secret key length up to the block size, thus capped at 1024-bit.
[`key_length`](#key_length) determines how many of these registers are relevant for the HMAC operation. Order of the secret key is:
key[1023:0] = {KEY0, KEY1, KEY2, ... , KEY31};

The registers are allowed to be updated only when the engine is in Idle state.
If the engine computes the hash, it discards any attempts to update the secret keys and report an error.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name   | Offset   |
|:-------|:---------|
| KEY_0  | 0x24     |
| KEY_1  | 0x28     |
| KEY_2  | 0x2c     |
| KEY_3  | 0x30     |
| KEY_4  | 0x34     |
| KEY_5  | 0x38     |
| KEY_6  | 0x3c     |
| KEY_7  | 0x40     |
| KEY_8  | 0x44     |
| KEY_9  | 0x48     |
| KEY_10 | 0x4c     |
| KEY_11 | 0x50     |
| KEY_12 | 0x54     |
| KEY_13 | 0x58     |
| KEY_14 | 0x5c     |
| KEY_15 | 0x60     |
| KEY_16 | 0x64     |
| KEY_17 | 0x68     |
| KEY_18 | 0x6c     |
| KEY_19 | 0x70     |
| KEY_20 | 0x74     |
| KEY_21 | 0x78     |
| KEY_22 | 0x7c     |
| KEY_23 | 0x80     |
| KEY_24 | 0x84     |
| KEY_25 | 0x88     |
| KEY_26 | 0x8c     |
| KEY_27 | 0x90     |
| KEY_28 | 0x94     |
| KEY_29 | 0x98     |
| KEY_30 | 0x9c     |
| KEY_31 | 0xa0     |


### Fields

```wavejson
{"reg": [{"name": "key", "bits": 32, "attr": ["wo"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                         |
|:------:|:------:|:-------:|:-------|:------------------------------------|
|  31:0  |   wo   |    x    | key    | 32-bit chunk of 1024-bit secret key |

## DIGEST
Digest output.

If HMAC is disabled, the register shows result of SHA-2 256/384/512.
Order of the 512-bit digest[511:0] = {DIGEST0, DIGEST1, DIGEST2, ... , DIGEST15}.
For SHA-2 256 order of the 256-bit digest[255:0] = {DIGEST0, DIGEST1, DIGEST2, DIGEST3, DIGEST4, DIGEST5, DIGEST6, DIGEST7} and {DIGEST8 - DIGEST15} are irrelevant and should not be read out.
For SHA-2 384, {DIGEST12-DIGEST15} are truncated; they are irrelevant and should not be read out.

The digest gets cleared when `CFG.sha_en` transitions from 1 to 0.
When `STATUS.hmac_idle` is 1, these registers may be written to by software.
Outside of this window, writes can cause unpredictable behavior.
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Instances

| Name      | Offset   |
|:----------|:---------|
| DIGEST_0  | 0xa4     |
| DIGEST_1  | 0xa8     |
| DIGEST_2  | 0xac     |
| DIGEST_3  | 0xb0     |
| DIGEST_4  | 0xb4     |
| DIGEST_5  | 0xb8     |
| DIGEST_6  | 0xbc     |
| DIGEST_7  | 0xc0     |
| DIGEST_8  | 0xc4     |
| DIGEST_9  | 0xc8     |
| DIGEST_10 | 0xcc     |
| DIGEST_11 | 0xd0     |
| DIGEST_12 | 0xd4     |
| DIGEST_13 | 0xd8     |
| DIGEST_14 | 0xdc     |
| DIGEST_15 | 0xe0     |


### Fields

```wavejson
{"reg": [{"name": "digest", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description                    |
|:------:|:------:|:-------:|:-------|:-------------------------------|
|  31:0  |   rw   |    x    | digest | 32-bit chunk of 512-bit digest |

## MSG_LENGTH_LOWER
Received Message Length calculated by the HMAC in bits [31:0]

Message is byte granularity.
Lower 3 bits [2:0] are ignored.

When `STATUS.hmac_idle` is 1, this register may be written by software.
Outside of this window, writes can cause unpredictable behavior.
- Offset: `0xe4`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "v", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description           |
|:------:|:------:|:-------:|:-------|:----------------------|
|  31:0  |   rw   |    x    | v      | Message Length [31:0] |

## MSG_LENGTH_UPPER
Received Message Length calculated by the HMAC in bits [63:32]

When `STATUS.hmac_idle` is 1, this register may be written by software.
Outside of this window, writes can cause unpredictable behavior.
For SHA-2-2 256 computations, message length is 64-bit {MSG_LENGTH_UPPER, MSG_LENGTH_LOWER}.f
For SHA-2 384/512 message length is extended to 128-bit in line with [nist-fips-180-4] where the upper 64 bits get zero-padded: {32'b0, 32'b0, MSG_LENGTH_UPPER, MSG_LENGTH_LOWER}.
- Offset: `0xe8`
- Reset default: `0x0`
- Reset mask: `0xffffffff`

### Fields

```wavejson
{"reg": [{"name": "v", "bits": 32, "attr": ["rw"], "rotate": 0}], "config": {"lanes": 1, "fontsize": 10, "vspace": 80}}
```

|  Bits  |  Type  |  Reset  | Name   | Description            |
|:------:|:------:|:-------:|:-------|:-----------------------|
|  31:0  |   rw   |    x    | v      | Message Length [63:32] |

## MSG_FIFO
Message FIFO. Any write to this window will be appended to the FIFO.
Only the lower [1:0] bits of the address matter to writes within the window
(for correctly dealing with non 32-bit writes)

- Word Aligned Offset Range: `0x1000`to`0x1ffc`
- Size (words): `1024`
- Access: `wo`
- Byte writes are  supported.


<!-- END CMDGEN -->

================================== Ai Message ==================================
Tool Calls:
  list_dir (call_KY3Zjp0IeXUkWp9zvYSxbLFZ)
 Call ID: call_KY3Zjp0IeXUkWp9zvYSxbLFZ
  Args:
    dir_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl
================================= Tool Message =================================
Name: list_dir

Files in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl:
hmac.sv hmac_reg_top.sv hmac_reg_pkg.sv hmac_core.sv

Directories in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl:

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_eheNIVChv0Sqb6E2D8Ffe6Zz)
 Call ID: call_eheNIVChv0Sqb6E2D8Ffe6Zz
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // HMAC/SHA-2 256/384/512
6: 
7: `include "prim_assert.sv"
8: 
9: module hmac
10:   import prim_sha2_pkg::*;
11:   import hmac_reg_pkg::*;
12: #(
13:   parameter logic [NumAlerts-1:0] AlertAsyncOn = {NumAlerts{1'b1}}
14: ) (
15:   input clk_i,
16:   input rst_ni,
17: 
18:   input  tlul_pkg::tl_h2d_t tl_i,
19:   output tlul_pkg::tl_d2h_t tl_o,
20: 
21:   input  prim_alert_pkg::alert_rx_t [NumAlerts-1:0] alert_rx_i,
22:   output prim_alert_pkg::alert_tx_t [NumAlerts-1:0] alert_tx_o,
23: 
24:   output logic intr_hmac_done_o,
25:   output logic intr_fifo_empty_o,
26:   output logic intr_hmac_err_o,
27: 
28:   output prim_mubi_pkg::mubi4_t idle_o
29: );
30: 
31: 
32:   /////////////////////////
33:   // Signal declarations //
34:   /////////////////////////
35:   hmac_reg2hw_t reg2hw;
36:   hmac_hw2reg_t hw2reg;
37: 
38:   tlul_pkg::tl_h2d_t  tl_win_h2d;
39:   tlul_pkg::tl_d2h_t  tl_win_d2h;
40: 
41:   logic [1023:0] secret_key, secret_key_d;
42: 
43:   // Logic will support key length <= block size
44:   // Will default to key length = block size, if key length > block size or unsupported value
45:   key_length_e key_length_supplied, key_length;
46: 
47:   logic        wipe_secret;
48:   logic [31:0] wipe_v;
49: 
50:   logic        fifo_rvalid;
51:   logic        fifo_rready;
52:   sha_fifo32_t fifo_rdata;
53: 
54:   logic        fifo_wvalid, fifo_wready;
55:   sha_fifo32_t fifo_wdata;
56:   logic        fifo_full;
57:   logic        fifo_empty;
58:   logic [5:0]  fifo_depth;
59: 
60:   logic        msg_fifo_req;
61:   logic        msg_fifo_gnt;
62:   logic        msg_fifo_we;
63:   logic [31:0] msg_fifo_wdata;
64:   logic [31:0] msg_fifo_wmask;
65:   logic [31:0] msg_fifo_rdata;
66:   logic [1:0]  msg_fifo_rerror;
67:   logic [31:0] msg_fifo_wdata_endian;
68:   logic [31:0] msg_fifo_wmask_endian;
69: 
70:   logic        packer_ready;
71:   logic        packer_flush_done;
72: 
73:   logic         reg_fifo_wvalid;
74:   sha_word32_t  reg_fifo_wdata;
75:   sha_word32_t  reg_fifo_wmask;
76:   logic         hmac_fifo_wsel;
77:   logic         hmac_fifo_wvalid;
78:   logic [3:0]   hmac_fifo_wdata_sel;
79: 
80:   logic         shaf_rvalid;
81:   sha_fifo32_t  shaf_rdata;
82:   logic         shaf_rready;
83: 
84:   logic        sha_en;
85:   logic        hmac_en;
86:   logic        endian_swap;
87:   logic        digest_swap;
88:   logic        key_swap;
89: 
90:   logic        reg_hash_start;
91:   logic        sha_hash_start;
92:   logic        reg_hash_stop;
93:   logic        reg_hash_continue;
94:   logic        sha_hash_continue;
95:   logic        hash_start;     // hash_start is reg_hash_start gated with extra checks
96:   logic        hash_continue;  // hash_continue is reg_hash_continue gated with extra checks
97:   logic        hash_process;   // hash_process is reg_hash_process gated with extra checks
98:   logic        hash_start_or_continue;
99:   logic        hash_done_event;
100:   logic        reg_hash_process;
101:   logic        sha_hash_process;
102:   logic        digest_on_blk;
103: 
104:   logic        reg_hash_done;
105:   logic        sha_hash_done;
106: 
107:   logic [63:0] message_length, message_length_d;
108:   logic [63:0] sha_message_length;
109: 
110:   err_code_e  err_code;
111:   logic       err_valid;
112:   logic       invalid_config; // HMAC/SHA-2 is configured with invalid digest size/key length
113:   logic       invalid_config_atstart;
114: 
115:   sha_word64_t [7:0] digest, digest_sw;
116:   logic [7:0]        digest_sw_we;
117: 
118:   digest_mode_e digest_size, digest_size_supplied;
119:   // this is the digest size captured into HMAC when it gets started
120:   digest_mode_e digest_size_started_d, digest_size_started_q;
121:   logic [7:0] cool_down_ct_q, cool_down_ct_d;
122: 
123:   hmac_reg2hw_cfg_reg_t cfg_reg;
124:   logic                 cfg_block;   // Prevents changing config
125:   logic                 msg_allowed; // MSG_FIFO from software is allowed
126: 
127:   logic hmac_core_idle;
128:   logic sha_core_idle;
129:   logic hash_running;
130:   logic idle;
131: 
132:   ///////////////////////
133:   // Connect registers //
134:   ///////////////////////
135:   assign hw2reg.status.fifo_full.d  = fifo_full;
136:   assign hw2reg.status.fifo_empty.d = fifo_empty;
137:   assign hw2reg.status.fifo_depth.d = fifo_depth;
138:   assign hw2reg.status.hmac_idle.d  = idle;
139: 
140:   typedef enum logic [1:0] {
141:     DoneAwaitCmd,
142:     DoneAwaitHashDone,
143:     DoneAwaitMessageComplete,
144:     DoneAwaitHashComplete
145:   } done_state_e;
146: 
147:   done_state_e done_state_d, done_state_q;
148: 
149:   always_comb begin
150:     done_state_d    = done_state_q;
151:     hash_done_event = 8'd0;
152: 
153:     unique case (done_state_q)
154:       DoneAwaitCmd: begin
155:         cool_down_ct_d = 8'd0;
156:         if (sha_hash_process) begin
157:           // SHA has been told to process the message, so signal *done* when the hash is done.
158:           done_state_d = DoneAwaitHashDone;
159:         end else if (reg_hash_stop) begin
160:           // SHA has been told to stop, so first wait for the current message block to be complete.
161:           done_state_d = DoneAwaitMessageComplete;
162:         end
163:       end
164: 
165:       DoneAwaitHashDone: begin
166:         if (reg_hash_done) begin
167:           hash_done_event = 1'b1;
168:           done_state_d = DoneAwaitCmd;
169:         end
170:       end
171: 
172:       DoneAwaitMessageComplete: begin
173:         if (digest_on_blk) begin
174:           // Once the digest is being computed for the complete message block, wait for the hash to
175:           // complete.
176:           done_state_d = DoneAwaitHashComplete;
177:         end
178:       end
179: 
180:       DoneAwaitHashComplete: begin
181:         if (!hash_running) begin
182:           if (cool_down_ct_q < 8'd127) begin
183:             cool_down_ct_d = cool_down_ct_q + 1'b1;
184:             hash_done_event = 1'b0;
185:             done_state_d = DoneAwaitHashComplete;
186:           end else begin
187:             hash_done_event = 1'b1;
188:             done_state_d = DoneAwaitCmd;
189:           end
190:         end
191:       end
192: 
193:       default: ;
194:     endcase
195:   end
196: 
197:   always_ff @(posedge clk_i or negedge rst_ni) begin
198:     if (!rst_ni) begin
199:       done_state_q <= DoneAwaitCmd;
200:     end else begin
201:       done_state_q <= done_state_d;
202:     end
203:   end
204: 
205:   always_ff @(posedge clk_i or negedge rst_ni) begin
206:     if (!rst_ni) cool_down_ct_q <= '0;
207:     else         cool_down_ct_q <= cool_down_ct_d;
208:   end
209: 
210:   assign wipe_secret = reg2hw.wipe_secret.qe;
211:   assign wipe_v      = reg2hw.wipe_secret.q;
212: 
213:   // update secret key
214:   always_comb begin : update_secret_key
215:     secret_key_d = secret_key;
216:     if (wipe_secret) begin
217:       secret_key_d = {32{wipe_v}};
218:     end else if (!cfg_block) begin
219:       // Allow updating secret key only when the engine is in Idle.
220:       for (int i = 0; i < 32; i++) begin
221:         if (reg2hw.key[31-i].qe) begin
222:           // swap byte endianness per secret key word if key_swap = 1
223:           secret_key_d[32*i+:32] = conv_endian32(reg2hw.key[31-i].q, key_swap);
224:         end
225:       end
226:     end
227:   end
228: 
229:   always_ff @(posedge clk_i or negedge rst_ni) begin
230:     if (!rst_ni) secret_key <= '0;
231:     else         secret_key <= secret_key_d;
232:   end
233: 
234:   for (genvar i = 0; i < 32; i++) begin : gen_key
235:     assign hw2reg.key[31-i].d      = '0;
236:   end
237: 
238:   // Retain the previous digest in CSRs until HMAC is actually started with a valid configuration
239:   always_comb begin : assign_digest_reg
240:     // default
241:     // digest SW -> HW
242:     digest_sw     = '0;
243:     digest_sw_we  = '0;
244:     // digest HW -> SW
245:     hw2reg.digest = '0;
246: 
247:     for (int i = 0; i < 8; i++) begin
248:       // digest SW -> HW (depends on digest size configured even before starting/enabling)
249:       // capturing the intermediate digests written by SW when restoring context into the SHA-2
250:       // engine before it is started
251:       if (digest_size == SHA2_256) begin
252:         // digest SW -> HW
253:         digest_sw[i][31:0] = conv_endian32(reg2hw.digest[i].q, digest_swap);
254:         digest_sw_we[i]    = reg2hw.digest[i].qe;
255:       end else if ((digest_size == SHA2_384) || (digest_size == SHA2_512)) begin
256:         // digest SW -> HW
257:         digest_sw[i][63:32]    = reg2hw.digest[2*i].qe ?
258:                                  conv_endian32(reg2hw.digest[2*i].q, digest_swap) :
259:                                  digest[i][63:32];
260:         digest_sw[i][31:0]     = reg2hw.digest[2*i+1].qe ?
261:                                  conv_endian32(reg2hw.digest[2*i+1].q, digest_swap) :
262:                                  digest[i][31:0];
263:         digest_sw_we[i]        = reg2hw.digest[2*i].qe | reg2hw.digest[2*i+1].qe;
264:       end
265: 
266:       // digest HW -> SW (depends on configuration that has been started)
267:       if (digest_size_started_q == SHA2_256) begin
268:         hw2reg.digest[i].d   = conv_endian32(digest[i][31:0], digest_swap);
269:         // replicate digest[0..7] into digest[8..15]. Digest[8...15] are irrelevant for SHA2_256,
270:         // but this ensures all digest CSRs are wiped out with random value (at wipe_secret)
271:         // across different configurations.
272:         hw2reg.digest[i+8].d = conv_endian32(digest[i][31:0], digest_swap);
273:       end else if ((digest_size_started_q == SHA2_384) || (digest_size_started_q == SHA2_512)) begin
274:         // digest HW -> SW
275:         // digest swap only within each 32-bit word of the 64-bit digest word, not digest swap
276:         // on the entire 64-bit digest word
277:         hw2reg.digest[2*i].d   = conv_endian32(digest[i][63:32], digest_swap);
278:         hw2reg.digest[2*i+1].d = conv_endian32(digest[i][31:0], digest_swap);
279:       end else begin // for SHA2_None
280:         // to ensure secret wiping is always passed to digest CSRs
281:         hw2reg.digest[i].d   = conv_endian32(digest[i][31:0], digest_swap);
282:         hw2reg.digest[i+8].d = conv_endian32(digest[i][31:0], digest_swap);
283:       end
284:     end
285:   end
286: 
287:   logic unused_cfg_qe;
288:   assign unused_cfg_qe = ^{cfg_reg.sha_en.qe,      cfg_reg.hmac_en.qe,
289:                            cfg_reg.endian_swap.qe, cfg_reg.digest_swap.qe,
290:                            cfg_reg.key_swap.qe,    cfg_reg.digest_size.qe,
291:                            cfg_reg.key_length.qe };
292: 
293:   assign sha_en               = cfg_reg.sha_en.q;
294:   assign hmac_en              = cfg_reg.hmac_en.q;
295: 
296:   assign digest_size_supplied = digest_mode_e'(cfg_reg.digest_size.q);
297:   always_comb begin : cast_digest_size
298:     digest_size = SHA2_None;
299: 
300:     unique case (digest_size_supplied)
301:       SHA2_256:  digest_size = SHA2_256;
302:       SHA2_384:  digest_size = SHA2_384;
303:       SHA2_512:  digest_size = SHA2_512;
304:       // unsupported digest size values are mapped to SHA2_None
305:       // if HMAC/SHA-2 is triggered to start with this digest size, it is blocked
306:       // and an error is signalled to SW
307:       default:   digest_size = SHA2_None;
308:     endcase
309:   end
310: 
311:   // Hold the previous digest size till HMAC is started with the new digest size configured
312:   assign digest_size_started_d = (hash_start_or_continue) ? digest_size : digest_size_started_q;
313: 
314:   always_ff @(posedge clk_i or negedge rst_ni) begin
315:     if (!rst_ni) digest_size_started_q <= SHA2_None;
316:     else         digest_size_started_q <= digest_size_started_d;
317:   end
318: 
319:   assign key_length_supplied  = key_length_e'(cfg_reg.key_length.q);
320:   always_comb begin : cast_key_length
321:     key_length = Key_None;
322: 
323:     unique case (key_length_supplied)
324:       Key_128:  key_length = Key_128;
325:       Key_256:  key_length = Key_256;
326:       Key_384:  key_length = Key_384;
327:       Key_512:  key_length = Key_512;
328:       Key_1024: key_length = Key_1024;
329:       // unsupported key length values are mapped to Key_None
330:       // if HMAC (not SHA-2) is triggered to start with this key length, it is blocked
331:       // and an error is signalled to SW
332:       default:  key_length = Key_None;
333:     endcase
334:   end
335: 
336:   assign endian_swap = cfg_reg.endian_swap.q;
337:   assign digest_swap = cfg_reg.digest_swap.q;
338:   assign key_swap    = cfg_reg.key_swap.q;
339: 
340:   assign hw2reg.cfg.hmac_en.d     = cfg_reg.hmac_en.q;
341:   assign hw2reg.cfg.sha_en.d      = cfg_reg.sha_en.q;
342:   assign hw2reg.cfg.digest_size.d = digest_mode_e'(digest_size);
343:   assign hw2reg.cfg.key_length.d  = key_length_e'(key_length);
344:   assign hw2reg.cfg.endian_swap.d = cfg_reg.endian_swap.q;
345:   assign hw2reg.cfg.digest_swap.d = cfg_reg.digest_swap.q;
346:   assign hw2reg.cfg.key_swap.d    = cfg_reg.key_swap.q;
347: 
348:   assign reg_hash_start    = reg2hw.cmd.hash_start.qe & reg2hw.cmd.hash_start.q;
349:   assign reg_hash_stop     = reg2hw.cmd.hash_stop.qe & reg2hw.cmd.hash_stop.q;
350:   assign reg_hash_continue = reg2hw.cmd.hash_continue.qe & reg2hw.cmd.hash_continue.q;
351:   assign reg_hash_process  = reg2hw.cmd.hash_process.qe & reg2hw.cmd.hash_process.q;
352: 
353:   // Error code register
354:   assign hw2reg.err_code.de = err_valid;
355:   assign hw2reg.err_code.d  = err_code;
356: 
357:   /////////////////////
358:   // Control signals //
359:   /////////////////////
360:   assign hash_start             = reg_hash_start    & sha_en & ~cfg_block & ~invalid_config;
361:   assign hash_continue          = reg_hash_continue & sha_en & ~cfg_block & ~invalid_config;
362:   assign hash_process           = reg_hash_process  & sha_en & cfg_block &  ~invalid_config;
363:   assign hash_start_or_continue = hash_start | hash_continue;
364: 
365:   always_ff @(posedge clk_i or negedge rst_ni) begin
366:     if (!rst_ni) begin
367:       cfg_block <= '0;
368:     end else if (hash_start_or_continue) begin
369:       cfg_block <= 1'b 1;
370:     end else if (reg_hash_done || reg_hash_stop) begin
371:       cfg_block <= 1'b 0;
372:     end
373:   end
374:   // Hold the configuration during the process
375:   always_ff @(posedge clk_i or negedge rst_ni) begin
376:     if (!rst_ni) begin
377:       cfg_reg <= '{
378:         hmac_en: '{
379:           q: 1'b0,
380:           qe: 1'b0
381:         },
382:         sha_en: '{
383:           q: 1'b0,
384:           qe: 1'b0
385:         },
386:         endian_swap: '{
387:           q: HMAC_CFG_ENDIAN_SWAP_RESVAL,
388:           qe: 1'b0
389:         },
390:         digest_swap: '{
391:           q: HMAC_CFG_DIGEST_SWAP_RESVAL,
392:           qe: 1'b0
393:         },
394:         key_swap: '{
395:           q: HMAC_CFG_KEY_SWAP_RESVAL,
396:           qe: 1'b0
397:         },
398:         digest_size: '{
399:           q: HMAC_CFG_DIGEST_SIZE_RESVAL,
400:           qe: 1'b0
401:         },
402:         key_length: '{
403:           q: HMAC_CFG_KEY_LENGTH_RESVAL,
404:           qe: 1'b0
405:         },
406:         default:'0
407:       };
408:     end else if (!cfg_block && reg2hw.cfg.hmac_en.qe) begin
409:       cfg_reg <= reg2hw.cfg ;
410:     end
411:   end
412: 
413:   // Open up the MSG_FIFO from the TL-UL port when it is ready
414:   always_ff @(posedge clk_i or negedge rst_ni) begin
415:     if (!rst_ni) begin
416:       msg_allowed <= '0;
417:     end else if (hash_start_or_continue) begin
418:       msg_allowed <= 1'b 1;
419:     end else if (packer_flush_done) begin
420:       msg_allowed <= 1'b 0;
421:     end
422:   end
423: 
424:   ////////////////
425:   // Interrupts //
426:   ////////////////
427: 
428:   // instantiate interrupt hardware primitive
429:   prim_intr_hw #(.Width(1)) intr_hw_hmac_done (
430:     .clk_i,
431:     .rst_ni,
432:     .event_intr_i           (hash_done_event),
433:     .reg2hw_intr_enable_q_i (reg2hw.intr_enable.hmac_done.q),
434:     .reg2hw_intr_test_q_i   (reg2hw.intr_test.hmac_done.q),
435:     .reg2hw_intr_test_qe_i  (reg2hw.intr_test.hmac_done.qe),
436:     .reg2hw_intr_state_q_i  (reg2hw.intr_state.hmac_done.q),
437:     .hw2reg_intr_state_de_o (hw2reg.intr_state.hmac_done.de),
438:     .hw2reg_intr_state_d_o  (hw2reg.intr_state.hmac_done.d),
439:     .intr_o                 (intr_hmac_done_o)
440:   );
441: 
442:   // FIFO empty interrupt
443:   //
444:   // The FIFO empty interrupt is **not useful** for software if:
445:   // - The HMAC block is running in HMAC mode and performing the second round of computing the
446:   //   final hash of the outer key as well as the result of the first round using the inner key.
447:   //   The FIFO is then managed entirely by the hardware.
448:   // - The FIFO is currently not writeable by software.
449:   // - Software has already written the Process command. The HMAC block will now empty the
450:   //   FIFO and load its content into the SHA2 core, add the padding and then perfom
451:   //   the final hashing operation. Software cannot append the message further.
452:   // - Software has written the Stop command. The HMAC block will not wait for further input from
453:   //   software after finishing the current block.
454:   //
455:   // The FIFO empty interrupt can be **useful** for software in particular if:
456:   // - The FIFO was completely full previously. However, unless the HMAC block is currently
457:   //   processing a block, it always empties the message FIFO faster than software can fill it up,
458:   //   meaning the message FIFO is empty most of the time. Note, the empty status is signaled only
459:   //   once after the FIFO was completely full. The FIFO needs to be full again for the empty
460:   //   status to be signaled again next time it's empty.
461:   logic status_fifo_empty, fifo_empty_gate;
462:   logic fifo_empty_negedge, fifo_empty_q;
463:   logic fifo_full_posedge, fifo_full_q;
464:   logic fifo_full_seen_d, fifo_full_seen_q;
465:   assign fifo_empty_negedge = fifo_empty_q & ~fifo_empty;
466:   assign fifo_full_posedge  = ~fifo_full_q & fifo_full;
467: 
468:   // Track whether the FIFO was full after being empty. We clear the tracking:
469:   // - When receiving the Start, Continue, Process or Stop command. This is to start over for the
470:   //   next message.
471:   // - When seeing a negative edge on the empty signal. This signals that software has reacted to
472:   //   the interrupt and is filling up the FIFO again.
473:   assign fifo_full_seen_d =
474:       reg_hash_start   || reg_hash_continue ||
475:       reg_hash_process || reg_hash_stop     ? 1'b 0 :
476:       fifo_empty_negedge                    ? 1'b 0 :
477:       fifo_full_posedge                     ? 1'b 1 : fifo_full_seen_q;
478: 
479:   // The interrupt is gated unless software is actually allowed to write the FIFO and the FIFO was
480:   // full before.
481:   assign fifo_empty_gate = ~msg_allowed || ~fifo_full_seen_q;
482: 
483:   assign status_fifo_empty = fifo_empty_gate ? 1'b 0 : fifo_empty;
484: 
485:   always_ff @(posedge clk_i or negedge rst_ni) begin
486:     if (!rst_ni) begin
487:       fifo_empty_q     <= 1'b 0;
488:       fifo_full_q      <= 1'b 0;
489:       fifo_full_seen_q <= 1'b 0;
490:     end else begin
491:       fifo_empty_q     <= fifo_empty;
492:       fifo_full_q      <= fifo_full;
493:       fifo_full_seen_q <= fifo_full_seen_d;
494:     end
495:   end
496: 
497:   prim_intr_hw #(
498:     .Width(1),
499:     .IntrT("Status")
500:   ) intr_hw_fifo_empty (
501:     .clk_i,
502:     .rst_ni,
503:     .event_intr_i           (status_fifo_empty),
504:     .reg2hw_intr_enable_q_i (reg2hw.intr_enable.fifo_empty.q),
505:     .reg2hw_intr_test_q_i   (reg2hw.intr_test.fifo_empty.q),
506:     .reg2hw_intr_test_qe_i  (reg2hw.intr_test.fifo_empty.qe),
507:     .reg2hw_intr_state_q_i  (reg2hw.intr_state.fifo_empty.q),
508:     .hw2reg_intr_state_de_o (hw2reg.intr_state.fifo_empty.de),
509:     .hw2reg_intr_state_d_o  (hw2reg.intr_state.fifo_empty.d),
510:     .intr_o                 (intr_fifo_empty_o)
511:   );
512:   prim_intr_hw #(.Width(1)) intr_hw_hmac_err (
513:     .clk_i,
514:     .rst_ni,
515:     .event_intr_i           (err_valid),
516:     .reg2hw_intr_enable_q_i (reg2hw.intr_enable.hmac_err.q),
517:     .reg2hw_intr_test_q_i   (reg2hw.intr_test.hmac_err.q),
518:     .reg2hw_intr_test_qe_i  (reg2hw.intr_test.hmac_err.qe),
519:     .reg2hw_intr_state_q_i  (reg2hw.intr_state.hmac_err.q),
520:     .hw2reg_intr_state_de_o (hw2reg.intr_state.hmac_err.de),
521:     .hw2reg_intr_state_d_o  (hw2reg.intr_state.hmac_err.d),
522:     .intr_o                 (intr_hmac_err_o)
523:   );
524: 
525:   ///////////////
526:   // Instances //
527:   ///////////////
528: 
529:   assign msg_fifo_rdata  = '1;  // Return all F
530:   assign msg_fifo_rerror = '1;  // Return error for read access
531:   assign msg_fifo_gnt    = msg_fifo_req & ~hmac_fifo_wsel & packer_ready;
532: 
533:   /////////////////////
534:   // Unused Signals //
535:   /////////////////////
536:   logic unused_signals;
537:   assign unused_signals = ^{reg_fifo_wmask[7:1],   reg_fifo_wmask[15:9],
538:                             reg_fifo_wmask[23:17], reg_fifo_wmask[31:25]};
539: 
540:   // FIFO control: from packer into message FIFO
541:   sha_fifo32_t reg_fifo_wentry;
542:   assign reg_fifo_wentry.data = conv_endian32(reg_fifo_wdata, 1'b1); // always convert
543:   assign reg_fifo_wentry.mask = {reg_fifo_wmask[0],  reg_fifo_wmask[8],
544:                                  reg_fifo_wmask[16], reg_fifo_wmask[24]};
545:   assign fifo_empty  = ~fifo_rvalid;
546:   assign fifo_wvalid = (hmac_fifo_wsel && fifo_wready) ? hmac_fifo_wvalid : reg_fifo_wvalid;
547: 
548:   logic index;
549:   always_comb begin : select_fifo_wdata
550:     // default when !hmac_fifo_wsel
551:     index      = 1'b0;
552:     fifo_wdata = reg_fifo_wentry;
553: 
554:     if (hmac_fifo_wsel) begin
555:       fifo_wdata = '0;
556:       if (digest_size == SHA2_256) begin
557:         // only reads out lower 32 bits of each digest word and discards upper 32-bit zero padding
558:         fifo_wdata = '{data: digest[hmac_fifo_wdata_sel[2:0]][31:0], mask: '1};
559:       end else if ((digest_size == SHA2_384) || (digest_size == SHA2_512)) begin
560:         // reads out first upper 32 bits then lower 32 bits of each digest word
561:         index = !hmac_fifo_wdata_sel[0];
562:         fifo_wdata = '{data: digest[hmac_fifo_wdata_sel[3:1]][32*index+:32], mask: '1};
563:       end
564:     end
565:   end
566: 
567:   // Extended for 1024-bit block
568:   localparam int MsgFifoDepth = 32;
569:   prim_fifo_sync #(
570:     .Width       ($bits(sha_fifo32_t)),
571:     .Pass        (1'b1),
572:     .Depth       (MsgFifoDepth),
573:     .NeverClears (1'b1)
574:   ) u_msg_fifo (
575:     .clk_i,
576:     .rst_ni,
577:     .clr_i   (1'b0),
578: 
579:     .wvalid_i(fifo_wvalid & sha_en),
580:     .wready_o(fifo_wready),
581:     .wdata_i (fifo_wdata),
582: 
583:     .depth_o (fifo_depth),
584:     .full_o  (fifo_full),
585: 
586:     .rvalid_o(fifo_rvalid),
587:     .rready_i(fifo_rready),
588:     .rdata_o (fifo_rdata),
589:     .err_o   ()
590:   );
591: 
592:   // TL ADAPTER SRAM
593:   tlul_adapter_sram #(
594:     .SramAw (9),
595:     .SramDw (32),
596:     .Outstanding (1),
597:     .ByteAccess  (1),
598:     .ErrOnRead   (1)
599:   ) u_tlul_adapter (
600:     .clk_i,
601:     .rst_ni,
602:     .tl_i                       (tl_win_h2d),
603:     .tl_o                       (tl_win_d2h),
604:     .en_ifetch_i                (prim_mubi_pkg::MuBi4False),
605:     .req_o                      (msg_fifo_req   ),
606:     .req_type_o                 (               ),
607:     .gnt_i                      (msg_fifo_gnt   ),
608:     .we_o                       (msg_fifo_we    ),
609:     .addr_o                     (               ), // Doesn't care the address
610:                                                    // other than sub-word
611:     .wdata_o                    (msg_fifo_wdata ),
612:     .wmask_o                    (msg_fifo_wmask ),
613:     .intg_error_o               (               ),
614:     .user_rsvd_o                (               ),
615:     .rdata_i                    (msg_fifo_rdata ),
616:     .rvalid_i                   (1'b0           ),
617:     .rerror_i                   (msg_fifo_rerror),
618:     .compound_txn_in_progress_o (),
619:     .readback_en_i              (prim_mubi_pkg::MuBi4False),
620:     .readback_error_o           (),
621:     .wr_collision_i             (1'b0),
622:     .write_pending_i            (1'b0)
623:   );
624: 
625:   // TL-UL to MSG_FIFO byte write handling
626:   logic msg_write;
627: 
628:   assign msg_write = msg_fifo_req & msg_fifo_we & ~hmac_fifo_wsel & msg_allowed;
629: 
630:   logic [$clog2(32+1)-1:0] wmask_ones;
631: 
632:   always_comb begin
633:     wmask_ones = '0;
634:     for (int i = 0 ; i < 32 ; i++) begin
635:       wmask_ones = wmask_ones + msg_fifo_wmask[i];
636:     end
637:   end
638: 
639:   // Calculate written message
640:   always_ff @(posedge clk_i or negedge rst_ni) begin
641:     if (!rst_ni) message_length <= '0;
642:     else         message_length <= message_length_d;
643:   end
644: 
645:   always_comb begin
646:     message_length_d = message_length;
647:     if (!cfg_block) begin
648:       if (reg2hw.msg_length_lower.qe) begin
649:         message_length_d[31:0]  = reg2hw.msg_length_lower.q;
650:       end
651:       if (reg2hw.msg_length_upper.qe) begin
652:         message_length_d[63:32] = reg2hw.msg_length_upper.q;
653:       end
654:     end
655: 
656:     if (hash_start) begin
657:       message_length_d = '0;
658:     end else if (msg_write && sha_en && packer_ready) begin
659:       message_length_d = message_length + 64'(wmask_ones);
660:     end
661:   end
662: 
663:   assign hw2reg.msg_length_upper.d = message_length[63:32];
664:   assign hw2reg.msg_length_lower.d = message_length[31:0];
665: 
666:   // Convert endian here
667:   //    prim_packer always packs to the right, but SHA engine assumes incoming
668:   //    to be big-endian, [31:24] comes first. So, the data is reverted after
669:   //    prim_packer before the message fifo. here to reverse if not big-endian
670:   //    before pushing to the packer.
671:   assign msg_fifo_wdata_endian = conv_endian32(msg_fifo_wdata, endian_swap);
672:   assign msg_fifo_wmask_endian = conv_endian32(msg_fifo_wmask, endian_swap);
673: 
674:   prim_packer #(
675:     .InW          (32),
676:     .OutW         (32),
677:     .EnProtection (1'b 0)
678:   ) u_packer (
679:     .clk_i,
680:     .rst_ni,
681: 
682:     .valid_i      (msg_write & sha_en),
683:     .data_i       (msg_fifo_wdata_endian),
684:     .mask_i       (msg_fifo_wmask_endian),
685:     .ready_o      (packer_ready),
686: 
687:     .valid_o      (reg_fifo_wvalid),
688:     .data_o       (reg_fifo_wdata),
689:     .mask_o       (reg_fifo_wmask),
690:     .ready_i      (fifo_wready & ~hmac_fifo_wsel),
691: 
692:     .flush_i      (hash_process),
693:     .flush_done_o (packer_flush_done), // ignore at this moment
694: 
695:     .err_o  () // Not used
696:   );
697: 
698:   hmac_core u_hmac (
699:     .clk_i,
700:     .rst_ni,
701:     .secret_key_i  (secret_key),
702:     .hmac_en_i     (hmac_en),
703:     .digest_size_i (digest_size),
704:     .key_length_i  (key_length),
705: 
706:     .reg_hash_start_i    (hash_start),
707:     .reg_hash_stop_i     (reg_hash_stop),
708:     .reg_hash_continue_i (hash_continue),
709:     .reg_hash_process_i  (packer_flush_done), // Trigger after all msg written
710:     .hash_done_o         (reg_hash_done),
711:     .sha_hash_start_o    (sha_hash_start),
712:     .sha_hash_continue_o (sha_hash_continue),
713:     .sha_hash_process_o  (sha_hash_process),
714:     .sha_hash_done_i     (sha_hash_done),
715: 
716:     .sha_rvalid_o     (shaf_rvalid),
717:     .sha_rdata_o      (shaf_rdata),
718:     .sha_rready_i     (shaf_rready),
719: 
720:     .fifo_rvalid_i (fifo_rvalid),
721:     .fifo_rdata_i  (fifo_rdata),
722:     .fifo_rready_o (fifo_rready),
723: 
724:     .fifo_wsel_o      (hmac_fifo_wsel),
725:     .fifo_wvalid_o    (hmac_fifo_wvalid),
726:     .fifo_wdata_sel_o (hmac_fifo_wdata_sel),
727:     .fifo_wready_i    (fifo_wready),
728: 
729:     .message_length_i     (message_length),
730:     .sha_message_length_o (sha_message_length),
731: 
732:     .idle_o           (hmac_core_idle)
733:   );
734: 
735:   // Instantiate SHA-2 256/384/512 engine
736:   prim_sha2_32 #(
737:       .MultimodeEn(1)
738:   ) u_prim_sha2_512 (
739:     .clk_i,
740:     .rst_ni,
741:     .wipe_secret_i        (wipe_secret),
742:     .wipe_v_i             (wipe_v),
743:     .fifo_rvalid_i        (shaf_rvalid),
744:     .fifo_rdata_i         (shaf_rdata),
745:     .fifo_rready_o        (shaf_rready),
746:     .sha_en_i             (sha_en),
747:     .hash_start_i         (sha_hash_start),
748:     .hash_stop_i          (reg_hash_stop),
749:     .hash_continue_i      (sha_hash_continue),
750:     .digest_mode_i        (digest_size),
751:     .hash_process_i       (sha_hash_process),
752:     .message_length_i     (sha_message_length),
753:     .digest_i             (digest_sw),
754:     .digest_we_i          (digest_sw_we),
755:     .digest_o             (digest),
756:     .hash_running_o       (hash_running),
757:     .digest_on_blk_o      (digest_on_blk),
758:     .hash_done_o          (sha_hash_done),
759:     .idle_o               (sha_core_idle)
760:   );
761: 
762:   // Register top
763:   logic [NumAlerts-1:0] alert_test, alerts;
764:   hmac_reg_top u_reg (
765:     .clk_i,
766:     .rst_ni,
767: 
768:     .tl_i,
769:     .tl_o,
770: 
771:     .tl_win_o   (tl_win_h2d),
772:     .tl_win_i   (tl_win_d2h),
773: 
774:     .reg2hw,
775:     .hw2reg,
776: 
777:     // SEC_CM: BUS.INTEGRITY
778:     .intg_err_o (alerts[0])
779:   );
780: 
781:   // Alerts
782:   assign alert_test = {
783:     reg2hw.alert_test.q &
784:     reg2hw.alert_test.qe
785:   };
786: 
787:   localparam logic [NumAlerts-1:0] AlertIsFatal = {1'b1};
788:   for (genvar i = 0; i < NumAlerts; i++) begin : gen_alert_tx
789:     prim_alert_sender #(
790:       .AsyncOn(AlertAsyncOn[i]),
791:       .IsFatal(AlertIsFatal[i])
792:     ) u_prim_alert_sender (
793:       .clk_i,
794:       .rst_ni,
795:       .alert_test_i  ( alert_test[i] ),
796:       .alert_req_i   ( alerts[0]     ),
797:       .alert_ack_o   (               ),
798:       .alert_state_o (               ),
799:       .alert_rx_i    ( alert_rx_i[i] ),
800:       .alert_tx_o    ( alert_tx_o[i] )
801:     );
802:   end
803: 
804:   /////////////////////////
805:   // HMAC Error Handling //
806:   /////////////////////////
807:   logic hash_start_sha_disabled, update_seckey_inprocess;
808:   logic hash_start_active;  // `reg_hash_start` or `reg_hash_continue` set when hash already active
809:   logic msg_push_not_allowed; // Message is received when `hash_start_or_continue` isn't set
810: 
811:   assign hash_start_sha_disabled = (reg_hash_start | reg_hash_continue) & ~sha_en;
812:   assign hash_start_active = (reg_hash_start | reg_hash_continue) & cfg_block;
813:   assign msg_push_not_allowed = msg_fifo_req & ~msg_allowed;
814: 
815:   // Invalid/unconfigured HMAC/SHA-2: not configured/invalid digest size or
816:   // not configured/invalid key length for HMAC mode or
817:   // key_length = 1024-bit for digest_size = SHA2_256 (max 512-bit is supported for SHA-2 256)
818:   assign invalid_config = ((digest_size == SHA2_None)            |
819:                            ((key_length == Key_None) && hmac_en) |
820:                            ((key_length == Key_1024) && (digest_size == SHA2_256) && hmac_en));
821: 
822:   // invalid_config at reg_hash_start or reg_hash_continue will signal an error to the SW
823:   assign invalid_config_atstart = (reg_hash_start || reg_hash_continue) & invalid_config;
824: 
825:   always_comb begin
826:     update_seckey_inprocess = 1'b0;
827:     if (cfg_block) begin
828:       for (int i = 0 ; i < 32 ; i++) begin
829:         if (reg2hw.key[i].qe) begin
830:           update_seckey_inprocess = update_seckey_inprocess | 1'b1;
831:         end
832:       end
833:     end else begin
834:       update_seckey_inprocess = 1'b0;
835:     end
836:   end
837: 
838:   // Update ERR_CODE register and interrupt only when no pending interrupt.
839:   // This ensures only the first event of the series of events can be seen to sw.
840:   // It is recommended that the software reads ERR_CODE register when interrupt
841:   // is pending to avoid any race conditions.
842:   assign err_valid = ~reg2hw.intr_state.hmac_err.q &
843:                    ( hash_start_sha_disabled | update_seckey_inprocess
844:                    | hash_start_active | msg_push_not_allowed | invalid_config_atstart);
845: 
846:   always_comb begin
847:     // default
848:     err_code = NoError;
849: 
850:     priority case (1'b1)
851:       hash_start_sha_disabled: begin
852:         err_code = SwHashStartWhenShaDisabled;
853:       end
854: 
855: 
856:       hash_start_sha_disabled: begin
857:         err_code = SwHashStartWhenShaDisabled;
858:       end
859: 
860:       hash_start_active: begin
861:         err_code = SwHashStartWhenActive;
862:       end
863: 
864:       msg_push_not_allowed: begin
865:         err_code = SwPushMsgWhenDisallowed;
866:       end
867: 
868:       update_seckey_inprocess: begin
869:         err_code = SwUpdateSecretKeyInProcess;
870:       end
871: 
872:       default: begin
873:         err_code = NoError;
874:       end
875:     endcase
876:   end
877: 
878:   /////////////////////
879:   // Idle output     //
880:   /////////////////////
881:   // TBD this should be connected later
882:   // Idle: AND condition of:
883:   //  - packer empty: Currently no way to guarantee the packer is empty.
884:   //    temporary, the logic uses packer output (reg_fifo_wvalid)
885:   //  - MSG_FIFO  --> fifo_rvalid
886:   //  - HMAC_CORE --> hmac_core_idle
887:   //  - SHA2_CORE --> sha_core_idle
888:   //  - Clean interrupt status
889:   // ICEBOX(#12958): Revise prim_packer and replace `reg_fifo_wvalid` to the
890:   // empty status.
891:   assign idle = !reg_fifo_wvalid && !fifo_rvalid
892:               && hmac_core_idle && sha_core_idle;
893: 
894:   prim_mubi_pkg::mubi4_t idle_q, idle_d;
895:   assign idle_d = prim_mubi_pkg::mubi4_bool_to_mubi(idle);
896:   always_ff @(posedge clk_i or negedge rst_ni) begin
897:     if (!rst_ni) begin
898:       idle_q <= prim_mubi_pkg::MuBi4False;
899:     end else begin
900:       idle_q <= idle_d;
901:     end
902:   end
903:   assign idle_o = idle_q;
904: 
905:   //////////////////////////////////////////////
906:   // Assertions, Assumptions, and Coverpoints //
907:   //////////////////////////////////////////////
908: 
909: `ifndef VERILATOR
910: `ifndef SYNTHESIS
911:   // HMAC assumes TL-UL mask is byte-aligned.
912:   property wmask_bytealign_p(wmask_byte, clk, rst_n);
913:     @(posedge clk) disable iff (rst_n == 0)
914:       msg_fifo_req & msg_fifo_we |-> wmask_byte inside {'0, '1};
915:   endproperty
916: 
917:   for (genvar i = 0 ; i < 4; i++) begin: gen_assert_wmask_bytealign
918:     assert property (wmask_bytealign_p(msg_fifo_wmask[8*i+:8], clk_i, rst_ni));
919:   end
920: 
921:   // To pass FPV, this shouldn't add pragma translate_off even these two signals
922:   // are used in Assertion only
923:   logic in_process;
924:   always_ff @(posedge clk_i or negedge rst_ni) begin
925:     if (!rst_ni)                              in_process <= 1'b0;
926:     else if (hash_process || reg_hash_stop)   in_process <= 1'b1;
927:     else if (reg_hash_done)                   in_process <= 1'b0;
928:   end
929: 
930:   logic initiated;
931:   always_ff @(posedge clk_i or negedge rst_ni) begin
932:     if (!rst_ni)                              initiated <= 1'b0;
933:     else if (hash_start_or_continue)          initiated <= 1'b1;
934:     else if (hash_process || reg_hash_stop)   initiated <= 1'b0;
935:   end
936: 
937:   // the host doesn't write data after hash_process until hash_start_or_continue.
938:   `ASSERT(ValidWriteAssert, msg_fifo_req |-> !in_process)
939: 
940:   // Below condition is covered by the design (2020-02-19)
941:   //`ASSERT(ValidHashStartAssert, hash_start_or_continue |-> !initiated)
942:   // `hash_process` or `reg_hash_stop` should be toggled and paired with `hash_start_or_continue`
943:   `ASSERT(ValidHashProcessAssert, (hash_process || reg_hash_stop) |-> initiated)
944: 
945:   // hmac_en should be modified only when the logic is Idle
946:   `ASSERT(ValidHmacEnConditionAssert,
947:           hmac_en != $past(hmac_en) |-> !in_process && !initiated)
948: 
949:   // When wipe_secret is high, sensitive internal variables are cleared by extending the wipe
950:   // value specifed in the register
951:   `ASSERT(WipeSecretKeyAssert,
952:           wipe_secret |=> (secret_key == {($bits(secret_key)/$bits(wipe_v)){$past(wipe_v)}}))
953: 
954:   // All outputs should be known value after reset
955:   `ASSERT_KNOWN(IntrHmacDoneOKnown, intr_hmac_done_o)
956:   `ASSERT_KNOWN(IntrFifoEmptyOKnown, intr_fifo_empty_o)
957:   `ASSERT_KNOWN(TlODValidKnown, tl_o.d_valid)
958:   `ASSERT_KNOWN(TlOAReadyKnown, tl_o.a_ready)
959:   `ASSERT_KNOWN(AlertKnownO_A, alert_tx_o)
960: 
961: `endif // SYNTHESIS
962: `endif // VERILATOR
963: 
964:   // Alert assertions for reg_we onehot check
965:   `ASSERT_PRIM_REG_WE_ONEHOT_ERROR_TRIGGER_ALERT(RegWeOnehotCheck_A, u_reg, alert_tx_o[0])
966: endmodule

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_7YcFm0Gp35iFsEDuMyLx4CUU)
 Call ID: call_7YcFm0Gp35iFsEDuMyLx4CUU
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_core.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // HMAC Core implementation
6: 
7: module hmac_core import prim_sha2_pkg::*; (
8:   input clk_i,
9:   input rst_ni,
10: 
11:   input [1023:0]      secret_key_i, // {word0, word1, ..., word7}
12:   input               hmac_en_i,
13:   input digest_mode_e digest_size_i,
14:   input key_length_e  key_length_i,
15: 
16:   input        reg_hash_start_i,
17:   input        reg_hash_stop_i,
18:   input        reg_hash_continue_i,
19:   input        reg_hash_process_i,
20:   output logic hash_done_o,
21:   output logic sha_hash_start_o,
22:   output logic sha_hash_continue_o,
23:   output logic sha_hash_process_o,
24:   input        sha_hash_done_i,
25: 
26:   // fifo
27:   output logic        sha_rvalid_o,
28:   output sha_fifo32_t sha_rdata_o,
29:   input               sha_rready_i,
30: 
31:   input               fifo_rvalid_i,
32:   input  sha_fifo32_t fifo_rdata_i,
33:   output logic        fifo_rready_o,
34: 
35:   // fifo control (select and fifo write data)
36:   output logic       fifo_wsel_o,      // 0: from reg, 1: from digest
37:   output logic       fifo_wvalid_o,
38:   // 0: digest[0][upper], 1:digest[0][lower] .. 14: digest[7][upper], 15: digest[7][lower]
39:   output logic [3:0] fifo_wdata_sel_o,
40:   input              fifo_wready_i,
41: 
42:   input  [63:0] message_length_i,
43:   output [63:0] sha_message_length_o,
44: 
45:   output logic idle_o
46: );
47: 
48:   localparam int unsigned BlockSizeSHA256     = 512;
49:   localparam int unsigned BlockSizeSHA512     = 1024;
50: 
51:   localparam int unsigned BlockSizeBitsSHA256 = $clog2(BlockSizeSHA256);
52:   localparam int unsigned BlockSizeBitsSHA512 = $clog2(BlockSizeSHA512);
53: 
54:   localparam int unsigned HashWordBitsSHA256  = $clog2($bits(sha_word32_t));
55: 
56:   localparam bit [63:0] BlockSizeSHA256in64  = 64'(BlockSizeSHA256);
57:   localparam bit [63:0] BlockSizeSHA512in64  = 64'(BlockSizeSHA512);
58: 
59:   logic hash_start;    // generated from internal state machine
60:   logic hash_continue; // generated from internal state machine
61:   logic hash_process;  // generated from internal state machine to trigger hash
62:   logic hmac_hash_done;
63: 
64:   logic [BlockSizeSHA256-1:0] i_pad_256;
65:   logic [BlockSizeSHA512-1:0] i_pad_512;
66:   logic [BlockSizeSHA256-1:0] o_pad_256;
67:   logic [BlockSizeSHA512-1:0] o_pad_512;
68: 
69:   logic [63:0] txcount, txcount_d; // works for both digest lengths
70: 
71:   logic [BlockSizeBitsSHA512-HashWordBitsSHA256-1:0] pad_index_512;
72:   logic [BlockSizeBitsSHA256-HashWordBitsSHA256-1:0] pad_index_256;
73:   logic clr_txcount, load_txcount, inc_txcount;
74: 
75:   logic hmac_sha_rvalid;
76: 
77:   logic idle_d, idle_q;
78:   logic reg_hash_stop_d, reg_hash_stop_q;
79: 
80:   typedef enum logic [1:0] {
81:     SelIPad,
82:     SelOPad,
83:     SelFifo
84:   } sel_rdata_t;
85: 
86:   sel_rdata_t sel_rdata;
87: 
88:   typedef enum logic {
89:     SelIPadMsg,
90:     SelOPadMsg
91:   } sel_msglen_t;
92: 
93:   sel_msglen_t sel_msglen;
94: 
95:   typedef enum logic {
96:     Inner,  // Update when state goes to StIPad
97:     Outer   // Update when state enters StOPad
98:   } round_t ;
99: 
100:   logic update_round ;
101:   round_t round_q, round_d;
102: 
103:   typedef enum logic [2:0] {
104:     StIdle,
105:     StIPad,
106:     StMsg,              // Actual Msg, and Digest both
107:     StPushToMsgFifo,    // Digest --> Msg Fifo
108:     StWaitResp,         // Hash done( by checking processed_length? or hash_done)
109:     StOPad,
110:     StDone              // hmac_done
111:   } st_e ;
112: 
113:   st_e st_q, st_d;
114: 
115:   logic clr_fifo_wdata_sel;
116:   logic txcnt_eq_blksz;
117: 
118:   logic reg_hash_process_flag;
119: 
120:   assign sha_hash_start_o    = (hmac_en_i) ? hash_start    : reg_hash_start_i;
121:   assign sha_hash_continue_o = (hmac_en_i) ? hash_continue : reg_hash_continue_i;
122: 
123:   assign sha_hash_process_o  = (hmac_en_i) ? reg_hash_process_i | hash_process : reg_hash_process_i;
124:   assign hash_done_o         = (hmac_en_i) ? hmac_hash_done                    : sha_hash_done_i;
125: 
126:   assign pad_index_512 = txcount[BlockSizeBitsSHA512-1:HashWordBitsSHA256];
127:   assign pad_index_256 = txcount[BlockSizeBitsSHA256-1:HashWordBitsSHA256];
128: 
129:   // adjust inner and outer padding depending on key length and block size
130:   always_comb begin : adjust_key_pad_length
131:     // set defaults
132:     i_pad_256 = '{default: '0};
133:     i_pad_512 = '{default: '0};
134:     o_pad_256 = '{default: '0};
135:     o_pad_512 = '{default: '0};
136: 
137:     unique case (key_length_i)
138:       Key_128: begin
139:         i_pad_256 = {secret_key_i[1023:896],
140:                     {(BlockSizeSHA256-128){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
141:         i_pad_512 = {secret_key_i[1023:896],
142:                     {(BlockSizeSHA512-128){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
143:         o_pad_256 = {secret_key_i[1023:896],
144:                     {(BlockSizeSHA256-128){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
145:         o_pad_512 = {secret_key_i[1023:896],
146:                     {(BlockSizeSHA512-128){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
147:       end
148:       Key_256: begin
149:         i_pad_256 = {secret_key_i[1023:768],
150:                     {(BlockSizeSHA256-256){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
151:         i_pad_512 = {secret_key_i[1023:768],
152:                     {(BlockSizeSHA512-256){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
153:         o_pad_256 = {secret_key_i[1023:768],
154:                     {(BlockSizeSHA256-256){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
155:         o_pad_512 = {secret_key_i[1023:768],
156:                     {(BlockSizeSHA512-256){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
157:       end
158:       Key_384: begin
159:         i_pad_256 = {secret_key_i[1023:640],
160:                     {(BlockSizeSHA256-384){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
161:         i_pad_512 = {secret_key_i[1023:640],
162:                     {(BlockSizeSHA512-384){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
163:         o_pad_256 = {secret_key_i[1023:640],
164:                     {(BlockSizeSHA256-384){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
165:         o_pad_512 = {secret_key_i[1023:640],
166:                     {(BlockSizeSHA512-384){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
167:       end
168:       Key_512: begin
169:         i_pad_256 = secret_key_i[1023:512] ^ {(BlockSizeSHA256/8){8'h36}};
170:         i_pad_512 = {secret_key_i[1023:512],
171:                     {(BlockSizeSHA512-512){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
172:         o_pad_256 = secret_key_i[1023:512] ^ {(BlockSizeSHA256/8){8'h5c}};
173:         o_pad_512 = {secret_key_i[1023:512],
174:                     {(BlockSizeSHA512-512){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
175:       end
176:       Key_1024: begin // not allowed to be configured for SHA-2 256
177:         // zero out for SHA-2 256
178:         i_pad_256 = '{default: '0};
179:         i_pad_512 = secret_key_i[1023:0]   ^ {(BlockSizeSHA512/8){8'h36}};
180:         // zero out for SHA-2 256
181:         o_pad_256 = '{default: '0};
182:         o_pad_512 = secret_key_i[1023:0]   ^ {(BlockSizeSHA512/8){8'h5c}};
183:       end
184:       default: begin
185:       end
186:     endcase
187:   end
188: 
189:   assign fifo_rready_o = (hmac_en_i) ? (st_q == StMsg) & sha_rready_i : sha_rready_i ;
190:   // sha_rvalid is controlled by State Machine below.
191:   assign sha_rvalid_o  = (!hmac_en_i) ? fifo_rvalid_i : hmac_sha_rvalid ;
192:   assign sha_rdata_o =
193:     (!hmac_en_i)    ? fifo_rdata_i                                                             :
194:     (sel_rdata == SelIPad && digest_size_i == SHA2_256)
195:                   ? '{data: i_pad_256[(BlockSizeSHA256-1)-32*pad_index_256-:32], mask: '1} :
196:     (sel_rdata == SelIPad && ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)))
197:                   ? '{data: i_pad_512[(BlockSizeSHA512-1)-32*pad_index_512-:32], mask: '1} :
198:     (sel_rdata == SelOPad && digest_size_i == SHA2_256)
199:                   ? '{data: o_pad_256[(BlockSizeSHA256-1)-32*pad_index_256-:32], mask: '1} :
200:     (sel_rdata == SelOPad && ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)))
201:                   ? '{data: o_pad_512[(BlockSizeSHA512-1)-32*pad_index_512-:32], mask: '1} :
202:     // Well-defined default case `sel_rdata == SelFifo`. `sel_rdata == 2'b11` cannot occur.
203:                   fifo_rdata_i;
204: 
205:   logic [63:0] sha_msg_len;
206: 
207:   always_comb begin : assign_sha_message_length
208:     sha_msg_len = 64'd0;
209: 
210:     // Simple pass-through in non-HMAC mode.
211:     if (!hmac_en_i) begin
212:       sha_msg_len = message_length_i;
213: 
214:     // Handle intermediate hash length computation.
215:     end else if (sel_msglen == SelIPadMsg) begin
216:       unique case (digest_size_i)
217:         SHA2_256: sha_msg_len = message_length_i + BlockSizeSHA256in64;
218:         SHA2_384,
219:         SHA2_512: sha_msg_len = message_length_i + BlockSizeSHA512in64;
220:         default:  sha_msg_len = 64'd0;
221:       endcase
222: 
223:     // Handle final hash computation with padded outer key.
224:     end else begin
225:       // Padding length depends on output digest size.
226:       unique case (digest_size_i)
227:         SHA2_256: sha_msg_len = BlockSizeSHA256in64 + 64'd256;
228:         SHA2_384: sha_msg_len = BlockSizeSHA512in64 + 64'd384;
229:         default:  sha_msg_len = BlockSizeSHA512in64 + 64'd384; 
230:       endcase
231:     end
232:   end
233: 
234:   assign sha_message_length_o = sha_msg_len;
235: 
236:   always_comb begin
237:     txcnt_eq_blksz = '0;
238: 
239:     unique case (digest_size_i)
240:       SHA2_256: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA256-1:0] == '0) && (txcount != '0);
241:       SHA2_384: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA512-1:0] == '0) && (txcount != '0);
242:       SHA2_512: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA512-1:0] == '0) && (txcount != '0);
243:       default;
244:     endcase
245:   end
246: 
247:   assign inc_txcount = sha_rready_i && sha_rvalid_o;
248: 
249:   // txcount
250:   //    Looks like txcount can be removed entirely here in hmac_core
251:   //    In the first round (InnerPaddedKey), it can just watch process and hash_done
252:   //    In the second round, it only needs count 256 bits for hash digest to trigger
253:   //    hash_process to SHA2
254:   always_comb begin
255:     txcount_d = txcount;
256:     if (clr_txcount) begin
257:       txcount_d = '0;
258:     end else if (load_txcount) begin
259:       // When loading, add block size to the message length because the SW-visible message length
260:       // does not include the block containing the key xor'ed with the inner pad.
261:       unique case (digest_size_i)
262:         SHA2_256: txcount_d = message_length_i + BlockSizeSHA256in64;
263:         SHA2_384: txcount_d = message_length_i + BlockSizeSHA512in64;
264:         SHA2_512: txcount_d = message_length_i + BlockSizeSHA512in64;
265:         default : txcount_d = message_length_i + '0;
266:       endcase
267:     end else if (inc_txcount) begin
268:       txcount_d[63:5] = txcount[63:5] + 1'b1; // increment by 32 (data word size)
269:     end
270:   end
271: 
272:   always_ff @(posedge clk_i or negedge rst_ni) begin
273:     if (!rst_ni) txcount <= '0;
274:     else         txcount <= txcount_d;
275:   end
276: 
277:   // reg_hash_process_i trigger logic
278:   always_ff @(posedge clk_i or negedge rst_ni) begin
279:     if (!rst_ni) begin
280:       reg_hash_process_flag <= 1'b0;
281:     end else if (reg_hash_process_i) begin
282:       reg_hash_process_flag <= 1'b1;
283:     end else if (hmac_hash_done || reg_hash_start_i || reg_hash_continue_i) begin
284:       reg_hash_process_flag <= 1'b0;
285:     end
286:   end
287: 
288:   always_ff @(posedge clk_i or negedge rst_ni) begin
289:     if (!rst_ni) begin
290:       round_q <= Inner;
291:     end else if (update_round) begin
292:       round_q <= round_d;
293:     end
294:   end
295: 
296:   always_ff @(posedge clk_i or negedge rst_ni) begin
297:     if (!rst_ni) begin
298:       fifo_wdata_sel_o <= '0;
299:     end else if (clr_fifo_wdata_sel) begin
300:       fifo_wdata_sel_o <= '0;
301:     end else if (fifo_wsel_o && fifo_wvalid_o) begin
302:       fifo_wdata_sel_o <= fifo_wdata_sel_o + 1'b1; // increment by 1
303:     end
304:   end
305: 
306:   assign sel_msglen = (round_q == Inner) ? SelIPadMsg : SelOPadMsg ;
307: 
308:   always_ff @(posedge clk_i or negedge rst_ni) begin : state_ff
309:     if (!rst_ni) st_q <= StIdle;
310:     else         st_q <= st_d;
311:   end
312: 
313:   always_comb begin : next_state
314:     hmac_hash_done     = 1'b0;
315:     hmac_sha_rvalid    = 1'b0;
316:     clr_txcount        = 1'b0;
317:     load_txcount       = 1'b0;
318:     update_round       = 1'b0;
319:     round_d            = Inner;
320:     fifo_wsel_o        = 1'b0;   // from register
321:     fifo_wvalid_o      = 1'b0;
322:     clr_fifo_wdata_sel = 1'b1;
323:     sel_rdata          = SelFifo;
324:     hash_start         = 1'b0;
325:     hash_continue      = 1'b0;
326:     hash_process       = 1'b0;
327:     st_d               = st_q;
328: 
329:     unique case (st_q)
330:       StIdle: begin
331:         // reset round to Inner
332:         // we always switch context into inner round since outer round computes once over
333:         // single block at the end (outer key pad + inner hash)
334:         update_round = 1'b1;
335:         round_d      = Inner;
336:         if (hmac_en_i && reg_hash_start_i) begin
337:           st_d = StIPad; // start at StIPad if told to start
338: 
339:           clr_txcount  = 1'b1;
340:           hash_start   = 1'b1;
341:         end else if (hmac_en_i && reg_hash_continue_i) begin
342:           st_d = StMsg; // skip StIPad if told to continue - assumed it finished StIPad
343: 
344:           load_txcount  = 1'b1;
345:           hash_continue = 1'b1;
346:         end else begin
347:           st_d = StIdle;
348:         end
349:       end
350: 
351:       StIPad: begin
352:         sel_rdata = SelIPad;
353: 
354:         if (txcnt_eq_blksz) begin
355:           st_d = StMsg;
356: 
357:           hmac_sha_rvalid = 1'b0; // block new read request
358:         end else begin
359:           st_d = StIPad;
360: 
361:           hmac_sha_rvalid = 1'b1;
362:         end
363:       end
364: 
365:       StMsg: begin
366:         sel_rdata   = SelFifo;
367:         fifo_wsel_o = (round_q == Outer);
368: 
369:         if ( (((round_q == Inner) && reg_hash_process_flag) || (round_q == Outer))
370:             && (txcount >= sha_message_length_o)) begin
371:           st_d    = StWaitResp;
372: 
373:           hmac_sha_rvalid = 1'b0; // block reading words from MSG FIFO
374:           hash_process    = (round_q == Outer);
375:         end else if (txcnt_eq_blksz && (txcount >= sha_message_length_o)
376:                      && reg_hash_stop_q && (round_q == Inner)) begin
377:           // wait till all MSG words are pushed out from FIFO (txcount reaches msg length)
378:           // before transitioning to StWaitResp to wait on sha_hash_done_i and disabling
379:           // reading from MSG FIFO
380:           st_d =  StWaitResp;
381: 
382:           hmac_sha_rvalid = 1'b0;
383:         end else begin
384:           st_d            = StMsg;
385:           hmac_sha_rvalid = fifo_rvalid_i;
386:         end
387:       end
388: 
389:       StWaitResp: begin
390:         hmac_sha_rvalid = 1'b0;
391: 
392:         if (sha_hash_done_i) begin
393:           if (round_q == Outer) begin
394:             st_d = StDone;
395:           end else begin // round_q == Inner
396:             if (reg_hash_stop_q) begin
397:               st_d = StDone;
398:             end else begin
399:               st_d = StPushToMsgFifo;
400:             end
401:           end
402:         end else begin
403:           st_d = StWaitResp;
404:         end
405:       end
406: 
407:       StPushToMsgFifo: begin
408:         hmac_sha_rvalid    = 1'b0;
409:         fifo_wsel_o        = 1'b1;
410:         fifo_wvalid_o      = 1'b1;
411:         clr_fifo_wdata_sel = 1'b0;
412: 
413:         if (fifo_wready_i && (((fifo_wdata_sel_o == 4'd7) && (digest_size_i == SHA2_256)) ||
414:                              ((fifo_wdata_sel_o == 4'd15) && (digest_size_i == SHA2_512)) ||
415:                              ((fifo_wdata_sel_o == 4'd11) && (digest_size_i == SHA2_384)))) begin
416: 
417:           st_d = StOPad;
418: 
419:           clr_txcount  = 1'b1;
420:           update_round = 1'b1;
421:           round_d      = Outer;
422:           hash_start   = 1'b1;
423:         end else begin
424:           st_d = StPushToMsgFifo;
425: 
426:         end
427:       end
428: 
429:       StOPad: begin
430:         sel_rdata   = SelOPad;
431:         fifo_wsel_o = 1'b1; // Remained HMAC select to indicate HMAC is in second stage
432: 
433:         if (txcnt_eq_blksz) begin
434:           st_d = StMsg;
435: 
436:           hmac_sha_rvalid = 1'b0; // block new read request
437:         end else begin
438:           st_d = StOPad;
439: 
440:           hmac_sha_rvalid = 1'b1;
441:         end
442:       end
443: 
444:       StDone: begin
445:         // raise interrupt (hash_done)
446:         st_d = StIdle;
447: 
448:         hmac_hash_done = 1'b1;
449:       end
450: 
451:       default: begin
452:         st_d = StIdle;
453:       end
454: 
455:     endcase
456:   end
457: 
458:   // raise reg_hash_stop_d flag at reg_hash_stop_i and keep it until sha_hash_done_i is asserted
459:   // to indicate the hashing operation on current block has completed
460:   assign reg_hash_stop_d = (reg_hash_stop_i == 1'b1)                            ? 1'b1 :
461:                            (sha_hash_done_i == 1'b1 && reg_hash_stop_q == 1'b1) ? 1'b0 :
462:                                                                                   reg_hash_stop_q;
463: 
464:   always_ff @(posedge clk_i or negedge rst_ni) begin
465:     if (!rst_ni) begin
466:       reg_hash_stop_q <= 1'b0;
467:     end else begin
468:       reg_hash_stop_q <= reg_hash_stop_d;
469:     end
470:   end
471: 
472:   // Idle status signaling: This module ..
473:   assign idle_d =
474:       // .. is not idle when told to start or continue
475:       (reg_hash_start_i || reg_hash_continue_i) ? 1'b0 :
476:       // .. is idle when the FSM is in the Idle state
477:       (st_q == StIdle) ? 1'b1 :
478:       // .. is idle when it has processed a complete block of a message and is told to stop in any
479:       // FSM state
480:       (txcnt_eq_blksz && reg_hash_stop_d) ? 1'b1 :
481:       // .. and keeps the current idle state in all other cases.
482:       idle_q;
483: 
484:   assign idle_o = idle_d;
485: 
486:   always_ff @(posedge clk_i or negedge rst_ni) begin
487:     if (!rst_ni) begin
488:       idle_q <= 1'b1;
489:     end else begin
490:       idle_q <= idle_d;
491:     end
492:   end
493: 
494:   ////////////////
495:   // Assertions //
496:   ////////////////
497: 
498:   `ASSERT(ValidSelRdata_A, hmac_en_i |-> sel_rdata inside {SelIPad, SelOPad, SelFifo})
499:   `ASSERT(ValidDigestSize_A, (hmac_en_i && (sel_msglen == SelOPadMsg)) |->
500:       digest_size_i inside {SHA2_256, SHA2_384, SHA2_512})
501: 
502: endmodule

================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_RY0lj4SqpAOunCMI5wa0MOW5)
 Call ID: call_RY0lj4SqpAOunCMI5wa0MOW5
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Register Top module auto-generated by `reggen`
6: 
7: `include "prim_assert.sv"
8: 
9: module hmac_reg_top (
10:   input clk_i,
11:   input rst_ni,
12:   input  tlul_pkg::tl_h2d_t tl_i,
13:   output tlul_pkg::tl_d2h_t tl_o,
14: 
15:   // Output port for window
16:   output tlul_pkg::tl_h2d_t tl_win_o,
17:   input  tlul_pkg::tl_d2h_t tl_win_i,
18: 
19:   // To HW
20:   output hmac_reg_pkg::hmac_reg2hw_t reg2hw, // Write
21:   input  hmac_reg_pkg::hmac_hw2reg_t hw2reg, // Read
22: 
23:   // Integrity check errors
24:   output logic intg_err_o
25: );
26: 
27:   import hmac_reg_pkg::* ;
28: 
29:   localparam int AW = 13;
30:   localparam int DW = 32;
31:   localparam int DBW = DW/8;                    // Byte Width
32: 
33:   // register signals
34:   logic           reg_we;
35:   logic           reg_re;
36:   logic [AW-1:0]  reg_addr;
37:   logic [DW-1:0]  reg_wdata;
38:   logic [DBW-1:0] reg_be;
39:   logic [DW-1:0]  reg_rdata;
40:   logic           reg_error;
41: 
42:   logic          addrmiss, wr_err;
43: 
44:   logic [DW-1:0] reg_rdata_next;
45:   logic reg_busy;
46: 
47:   tlul_pkg::tl_h2d_t tl_reg_h2d;
48:   tlul_pkg::tl_d2h_t tl_reg_d2h;
49: 
50: 
51:   // incoming payload check
52:   logic intg_err;
53:   tlul_cmd_intg_chk u_chk (
54:     .tl_i(tl_i),
55:     .err_o(intg_err)
56:   );
57: 
58:   // also check for spurious write enables
59:   logic reg_we_err;
60:   logic [58:0] reg_we_check;
61:   prim_reg_we_check #(
62:     .OneHotWidth(59)
63:   ) u_prim_reg_we_check (
64:     .clk_i(clk_i),
65:     .rst_ni(rst_ni),
66:     .oh_i  (reg_we_check),
67:     .en_i  (reg_we && !addrmiss),
68:     .err_o (reg_we_err)
69:   );
70: 
71:   logic err_q;
72:   always_ff @(posedge clk_i or negedge rst_ni) begin
73:     if (!rst_ni) begin
74:       err_q <= '0;
75:     end else if (intg_err || reg_we_err) begin
76:       err_q <= 1'b1;
77:     end
78:   end
79: 
80:   // integrity error output is permanent and should be used for alert generation
81:   // register errors are transactional
82:   assign intg_err_o = err_q | intg_err | reg_we_err;
83: 
84:   // outgoing integrity generation
85:   tlul_pkg::tl_d2h_t tl_o_pre;
86:   tlul_rsp_intg_gen #(
87:     .EnableRspIntgGen(1),
88:     .EnableDataIntgGen(1)
89:   ) u_rsp_intg_gen (
90:     .tl_i(tl_o_pre),
91:     .tl_o(tl_o)
92:   );
93: 
94:   tlul_pkg::tl_h2d_t tl_socket_h2d [2];
95:   tlul_pkg::tl_d2h_t tl_socket_d2h [2];
96: 
97:   logic [0:0] reg_steer;
98: 
99:   // socket_1n connection
100:   assign tl_reg_h2d = tl_socket_h2d[1];
101:   assign tl_socket_d2h[1] = tl_reg_d2h;
102: 
103:   assign tl_win_o = tl_socket_h2d[0];
104:   assign tl_socket_d2h[0] = tl_win_i;
105: 
106:   // Create Socket_1n
107:   tlul_socket_1n #(
108:     .N            (2),
109:     .HReqPass     (1'b1),
110:     .HRspPass     (1'b1),
111:     .DReqPass     ({2{1'b1}}),
112:     .DRspPass     ({2{1'b1}}),
113:     .HReqDepth    (4'h0),
114:     .HRspDepth    (4'h0),
115:     .DReqDepth    ({2{4'h0}}),
116:     .DRspDepth    ({2{4'h0}}),
117:     .ExplicitErrs (1'b0)
118:   ) u_socket (
119:     .clk_i  (clk_i),
120:     .rst_ni (rst_ni),
121:     .tl_h_i (tl_i),
122:     .tl_h_o (tl_o_pre),
123:     .tl_d_o (tl_socket_h2d),
124:     .tl_d_i (tl_socket_d2h),
125:     .dev_select_i (reg_steer)
126:   );
127: 
128:   // Create steering logic
129:   always_comb begin
130:     reg_steer =
131:         tl_i.a_address[AW-1:0] inside {[4096:8191]} ? 1'd0 :
132:         // Default set to register
133:         1'd1;
134: 
135:     // Override this in case of an integrity error
136:     if (intg_err) begin
137:       reg_steer = 1'd1;
138:     end
139:   end
140: 
141:   tlul_adapter_reg #(
142:     .RegAw(AW),
143:     .RegDw(DW),
144:     .EnableDataIntgGen(0)
145:   ) u_reg_if (
146:     .clk_i  (clk_i),
147:     .rst_ni (rst_ni),
148: 
149:     .tl_i (tl_reg_h2d),
150:     .tl_o (tl_reg_d2h),
151: 
152:     .en_ifetch_i(prim_mubi_pkg::MuBi4False),
153:     .intg_error_o(),
154: 
155:     .we_o    (reg_we),
156:     .re_o    (reg_re),
157:     .addr_o  (reg_addr),
158:     .wdata_o (reg_wdata),
159:     .be_o    (reg_be),
160:     .busy_i  (reg_busy),
161:     .rdata_i (reg_rdata),
162:     .error_i (reg_error)
163:   );
164: 
165:   // cdc oversampling signals
166: 
167:   assign reg_rdata = reg_rdata_next ;
168:   assign reg_error = addrmiss | wr_err | intg_err;
169: 
170:   // Define SW related signals
171:   // Format: <reg>_<field>_{wd|we|qs}
172:   //        or <reg>_{wd|we|qs} if field == 1 or 0
173:   logic intr_state_we;
174:   logic intr_state_hmac_done_qs;
175:   logic intr_state_hmac_done_wd;
176:   logic intr_state_fifo_empty_qs;
177:   logic intr_state_hmac_err_qs;
178:   logic intr_state_hmac_err_wd;
179:   logic intr_enable_we;
180:   logic intr_enable_hmac_done_qs;
181:   logic intr_enable_hmac_done_wd;
182:   logic intr_enable_fifo_empty_qs;
183:   logic intr_enable_fifo_empty_wd;
184:   logic intr_enable_hmac_err_qs;
185:   logic intr_enable_hmac_err_wd;
186:   logic intr_test_we;
187:   logic intr_test_hmac_done_wd;
188:   logic intr_test_fifo_empty_wd;
189:   logic intr_test_hmac_err_wd;
190:   logic alert_test_we;
191:   logic alert_test_wd;
192:   logic cfg_re;
193:   logic cfg_we;
194:   logic cfg_hmac_en_qs;
195:   logic cfg_hmac_en_wd;
196:   logic cfg_sha_en_qs;
197:   logic cfg_sha_en_wd;
198:   logic cfg_endian_swap_qs;
199:   logic cfg_endian_swap_wd;
200:   logic cfg_digest_swap_qs;
201:   logic cfg_digest_swap_wd;
202:   logic cfg_key_swap_qs;
203:   logic cfg_key_swap_wd;
204:   logic [3:0] cfg_digest_size_qs;
205:   logic [3:0] cfg_digest_size_wd;
206:   logic [5:0] cfg_key_length_qs;
207:   logic [5:0] cfg_key_length_wd;
208:   logic cmd_we;
209:   logic cmd_hash_start_wd;
210:   logic cmd_hash_process_wd;
211:   logic cmd_hash_stop_wd;
212:   logic cmd_hash_continue_wd;
213:   logic status_re;
214:   logic status_hmac_idle_qs;
215:   logic status_fifo_empty_qs;
216:   logic status_fifo_full_qs;
217:   logic [5:0] status_fifo_depth_qs;
218:   logic [31:0] err_code_qs;
219:   logic wipe_secret_we;
220:   logic [31:0] wipe_secret_wd;
221:   logic key_0_we;
222:   logic [31:0] key_0_wd;
223:   logic key_1_we;
224:   logic [31:0] key_1_wd;
225:   logic key_2_we;
226:   logic [31:0] key_2_wd;
227:   logic key_3_we;
228:   logic [31:0] key_3_wd;
229:   logic key_4_we;
230:   logic [31:0] key_4_wd;
231:   logic key_5_we;
232:   logic [31:0] key_5_wd;
233:   logic key_6_we;
234:   logic [31:0] key_6_wd;
235:   logic key_7_we;
236:   logic [31:0] key_7_wd;
237:   logic key_8_we;
238:   logic [31:0] key_8_wd;
239:   logic key_9_we;
240:   logic [31:0] key_9_wd;
241:   logic key_10_we;
242:   logic [31:0] key_10_wd;
243:   logic key_11_we;
244:   logic [31:0] key_11_wd;
245:   logic key_12_we;
246:   logic [31:0] key_12_wd;
247:   logic key_13_we;
248:   logic [31:0] key_13_wd;
249:   logic key_14_we;
250:   logic [31:0] key_14_wd;
251:   logic key_15_we;
252:   logic [31:0] key_15_wd;
253:   logic key_16_we;
254:   logic [31:0] key_16_wd;
255:   logic key_17_we;
256:   logic [31:0] key_17_wd;
257:   logic key_18_we;
258:   logic [31:0] key_18_wd;
259:   logic key_19_we;
260:   logic [31:0] key_19_wd;
261:   logic key_20_we;
262:   logic [31:0] key_20_wd;
263:   logic key_21_we;
264:   logic [31:0] key_21_wd;
265:   logic key_22_we;
266:   logic [31:0] key_22_wd;
267:   logic key_23_we;
268:   logic [31:0] key_23_wd;
269:   logic key_24_we;
270:   logic [31:0] key_24_wd;
271:   logic key_25_we;
272:   logic [31:0] key_25_wd;
273:   logic key_26_we;
274:   logic [31:0] key_26_wd;
275:   logic key_27_we;
276:   logic [31:0] key_27_wd;
277:   logic key_28_we;
278:   logic [31:0] key_28_wd;
279:   logic key_29_we;
280:   logic [31:0] key_29_wd;
281:   logic key_30_we;
282:   logic [31:0] key_30_wd;
283:   logic key_31_we;
284:   logic [31:0] key_31_wd;
285:   logic digest_0_re;
286:   logic digest_0_we;
287:   logic [31:0] digest_0_qs;
288:   logic [31:0] digest_0_wd;
289:   logic digest_1_re;
290:   logic digest_1_we;
291:   logic [31:0] digest_1_qs;
292:   logic [31:0] digest_1_wd;
293:   logic digest_2_re;
294:   logic digest_2_we;
295:   logic [31:0] digest_2_qs;
296:   logic [31:0] digest_2_wd;
297:   logic digest_3_re;
298:   logic digest_3_we;
299:   logic [31:0] digest_3_qs;
300:   logic [31:0] digest_3_wd;
301:   logic digest_4_re;
302:   logic digest_4_we;
303:   logic [31:0] digest_4_qs;
304:   logic [31:0] digest_4_wd;
305:   logic digest_5_re;
306:   logic digest_5_we;
307:   logic [31:0] digest_5_qs;
308:   logic [31:0] digest_5_wd;
309:   logic digest_6_re;
310:   logic digest_6_we;
311:   logic [31:0] digest_6_qs;
312:   logic [31:0] digest_6_wd;
313:   logic digest_7_re;
314:   logic digest_7_we;
315:   logic [31:0] digest_7_qs;
316:   logic [31:0] digest_7_wd;
317:   logic digest_8_re;
318:   logic digest_8_we;
319:   logic [31:0] digest_8_qs;
320:   logic [31:0] digest_8_wd;
321:   logic digest_9_re;
322:   logic digest_9_we;
323:   logic [31:0] digest_9_qs;
324:   logic [31:0] digest_9_wd;
325:   logic digest_10_re;
326:   logic digest_10_we;
327:   logic [31:0] digest_10_qs;
328:   logic [31:0] digest_10_wd;
329:   logic digest_11_re;
330:   logic digest_11_we;
331:   logic [31:0] digest_11_qs;
332:   logic [31:0] digest_11_wd;
333:   logic digest_12_re;
334:   logic digest_12_we;
335:   logic [31:0] digest_12_qs;
336:   logic [31:0] digest_12_wd;
337:   logic digest_13_re;
338:   logic digest_13_we;
339:   logic [31:0] digest_13_qs;
340:   logic [31:0] digest_13_wd;
341:   logic digest_14_re;
342:   logic digest_14_we;
343:   logic [31:0] digest_14_qs;
344:   logic [31:0] digest_14_wd;
345:   logic digest_15_re;
346:   logic digest_15_we;
347:   logic [31:0] digest_15_qs;
348:   logic [31:0] digest_15_wd;
349:   logic msg_length_lower_re;
350:   logic msg_length_lower_we;
351:   logic [31:0] msg_length_lower_qs;
352:   logic [31:0] msg_length_lower_wd;
353:   logic msg_length_upper_re;
354:   logic msg_length_upper_we;
355:   logic [31:0] msg_length_upper_qs;
356:   logic [31:0] msg_length_upper_wd;
357: 
358:   // Register instances
359:   // R[intr_state]: V(False)
360:   //   F[hmac_done]: 0:0
361:   prim_subreg #(
362:     .DW      (1),
363:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
364:     .RESVAL  (1'h0),
365:     .Mubi    (1'b0)
366:   ) u_intr_state_hmac_done (
367:     .clk_i   (clk_i),
368:     .rst_ni  (rst_ni),
369: 
370:     // from register interface
371:     .we     (intr_state_we),
372:     .wd     (intr_state_hmac_done_wd),
373: 
374:     // from internal hardware
375:     .de     (hw2reg.intr_state.hmac_done.de),
376:     .d      (hw2reg.intr_state.hmac_done.d),
377: 
378:     // to internal hardware
379:     .qe     (),
380:     .q      (reg2hw.intr_state.hmac_done.q),
381:     .ds     (),
382: 
383:     // to register interface (read)
384:     .qs     (intr_state_hmac_done_qs)
385:   );
386: 
387:   //   F[fifo_empty]: 1:1
388:   prim_subreg #(
389:     .DW      (1),
390:     .SwAccess(prim_subreg_pkg::SwAccessRO),
391:     .RESVAL  (1'h0),
392:     .Mubi    (1'b0)
393:   ) u_intr_state_fifo_empty (
394:     .clk_i   (clk_i),
395:     .rst_ni  (rst_ni),
396: 
397:     // from register interface
398:     .we     (1'b0),
399:     .wd     ('0),
400: 
401:     // from internal hardware
402:     .de     (hw2reg.intr_state.fifo_empty.de),
403:     .d      (hw2reg.intr_state.fifo_empty.d),
404: 
405:     // to internal hardware
406:     .qe     (),
407:     .q      (reg2hw.intr_state.fifo_empty.q),
408:     .ds     (),
409: 
410:     // to register interface (read)
411:     .qs     (intr_state_fifo_empty_qs)
412:   );
413: 
414:   //   F[hmac_err]: 2:2
415:   prim_subreg #(
416:     .DW      (1),
417:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
418:     .RESVAL  (1'h0),
419:     .Mubi    (1'b0)
420:   ) u_intr_state_hmac_err (
421:     .clk_i   (clk_i),
422:     .rst_ni  (rst_ni),
423: 
424:     // from register interface
425:     .we     (intr_state_we),
426:     .wd     (intr_state_hmac_err_wd),
427: 
428:     // from internal hardware
429:     .de     (hw2reg.intr_state.hmac_err.de),
430:     .d      (hw2reg.intr_state.hmac_err.d),
431: 
432:     // to internal hardware
433:     .qe     (),
434:     .q      (reg2hw.intr_state.hmac_err.q),
435:     .ds     (),
436: 
437:     // to register interface (read)
438:     .qs     (intr_state_hmac_err_qs)
439:   );
440: 
441: 
442:   // R[intr_enable]: V(False)
443:   //   F[hmac_done]: 0:0
444:   prim_subreg #(
445:     .DW      (1),
446:     .SwAccess(prim_subreg_pkg::SwAccessRW),
447:     .RESVAL  (1'h0),
448:     .Mubi    (1'b0)
449:   ) u_intr_enable_hmac_done (
450:     .clk_i   (clk_i),
451:     .rst_ni  (rst_ni),
452: 
453:     // from register interface
454:     .we     (intr_enable_we),
455:     .wd     (intr_enable_hmac_done_wd),
456: 
457:     // from internal hardware
458:     .de     (1'b0),
459:     .d      ('0),
460: 
461:     // to internal hardware
462:     .qe     (),
463:     .q      (reg2hw.intr_enable.hmac_done.q),
464:     .ds     (),
465: 
466:     // to register interface (read)
467:     .qs     (intr_enable_hmac_done_qs)
468:   );
469: 
470:   //   F[fifo_empty]: 1:1
471:   prim_subreg #(
472:     .DW      (1),
473:     .SwAccess(prim_subreg_pkg::SwAccessRW),
474:     .RESVAL  (1'h0),
475:     .Mubi    (1'b0)
476:   ) u_intr_enable_fifo_empty (
477:     .clk_i   (clk_i),
478:     .rst_ni  (rst_ni),
479: 
480:     // from register interface
481:     .we     (intr_enable_we),
482:     .wd     (intr_enable_fifo_empty_wd),
483: 
484:     // from internal hardware
485:     .de     (1'b0),
486:     .d      ('0),
487: 
488:     // to internal hardware
489:     .qe     (),
490:     .q      (reg2hw.intr_enable.fifo_empty.q),
491:     .ds     (),
492: 
493:     // to register interface (read)
494:     .qs     (intr_enable_fifo_empty_qs)
495:   );
496: 
497:   //   F[hmac_err]: 2:2
498:   prim_subreg #(
499:     .DW      (1),
500:     .SwAccess(prim_subreg_pkg::SwAccessRW),
501:     .RESVAL  (1'h0),
502:     .Mubi    (1'b0)
503:   ) u_intr_enable_hmac_err (
504:     .clk_i   (clk_i),
505:     .rst_ni  (rst_ni),
506: 
507:     // from register interface
508:     .we     (intr_enable_we),
509:     .wd     (intr_enable_hmac_err_wd),
510: 
511:     // from internal hardware
512:     .de     (1'b0),
513:     .d      ('0),
514: 
515:     // to internal hardware
516:     .qe     (),
517:     .q      (reg2hw.intr_enable.hmac_err.q),
518:     .ds     (),
519: 
520:     // to register interface (read)
521:     .qs     (intr_enable_hmac_err_qs)
522:   );
523: 
524: 
525:   // R[intr_test]: V(True)
526:   logic intr_test_qe;
527:   logic [2:0] intr_test_flds_we;
528:   assign intr_test_qe = &intr_test_flds_we;
529:   //   F[hmac_done]: 0:0
530:   prim_subreg_ext #(
531:     .DW    (1)
532:   ) u_intr_test_hmac_done (
533:     .re     (1'b0),
534:     .we     (intr_test_we),
535:     .wd     (intr_test_hmac_done_wd),
536:     .d      ('0),
537:     .qre    (),
538:     .qe     (intr_test_flds_we[0]),
539:     .q      (reg2hw.intr_test.hmac_done.q),
540:     .ds     (),
541:     .qs     ()
542:   );
543:   assign reg2hw.intr_test.hmac_done.qe = intr_test_qe;
544: 
545:   //   F[fifo_empty]: 1:1
546:   prim_subreg_ext #(
547:     .DW    (1)
548:   ) u_intr_test_fifo_empty (
549:     .re     (1'b0),
550:     .we     (intr_test_we),
551:     .wd     (intr_test_fifo_empty_wd),
552:     .d      ('0),
553:     .qre    (),
554:     .qe     (intr_test_flds_we[1]),
555:     .q      (reg2hw.intr_test.fifo_empty.q),
556:     .ds     (),
557:     .qs     ()
558:   );
559:   assign reg2hw.intr_test.fifo_empty.qe = intr_test_qe;
560: 
561:   //   F[hmac_err]: 2:2
562:   prim_subreg_ext #(
563:     .DW    (1)
564:   ) u_intr_test_hmac_err (
565:     .re     (1'b0),
566:     .we     (intr_test_we),
567:     .wd     (intr_test_hmac_err_wd),
568:     .d      ('0),
569:     .qre    (),
570:     .qe     (intr_test_flds_we[2]),
571:     .q      (reg2hw.intr_test.hmac_err.q),
572:     .ds     (),
573:     .qs     ()
574:   );
575:   assign reg2hw.intr_test.hmac_err.qe = intr_test_qe;
576: 
577: 
578:   // R[alert_test]: V(True)
579:   logic alert_test_qe;
580:   logic [0:0] alert_test_flds_we;
581:   assign alert_test_qe = &alert_test_flds_we;
582:   prim_subreg_ext #(
583:     .DW    (1)
584:   ) u_alert_test (
585:     .re     (1'b0),
586:     .we     (alert_test_we),
587:     .wd     (alert_test_wd),
588:     .d      ('0),
589:     .qre    (),
590:     .qe     (alert_test_flds_we[0]),
591:     .q      (reg2hw.alert_test.q),
592:     .ds     (),
593:     .qs     ()
594:   );
595:   assign reg2hw.alert_test.qe = alert_test_qe;
596: 
597: 
598:   // R[cfg]: V(True)
599:   logic cfg_qe;
600:   logic [6:0] cfg_flds_we;
601:   assign cfg_qe = &cfg_flds_we;
602:   //   F[hmac_en]: 0:0
603:   prim_subreg_ext #(
604:     .DW    (1)
605:   ) u_cfg_hmac_en (
606:     .re     (cfg_re),
607:     .we     (cfg_we),
608:     .wd     (cfg_hmac_en_wd),
609:     .d      (hw2reg.cfg.hmac_en.d),
610:     .qre    (),
611:     .qe     (cfg_flds_we[0]),
612:     .q      (reg2hw.cfg.hmac_en.q),
613:     .ds     (),
614:     .qs     (cfg_hmac_en_qs)
615:   );
616:   assign reg2hw.cfg.hmac_en.qe = cfg_qe;
617: 
618:   //   F[sha_en]: 1:1
619:   prim_subreg_ext #(
620:     .DW    (1)
621:   ) u_cfg_sha_en (
622:     .re     (cfg_re),
623:     .we     (cfg_we),
624:     .wd     (cfg_sha_en_wd),
625:     .d      (hw2reg.cfg.sha_en.d),
626:     .qre    (),
627:     .qe     (cfg_flds_we[1]),
628:     .q      (reg2hw.cfg.sha_en.q),
629:     .ds     (),
630:     .qs     (cfg_sha_en_qs)
631:   );
632:   assign reg2hw.cfg.sha_en.qe = cfg_qe;
633: 
634:   //   F[endian_swap]: 2:2
635:   prim_subreg_ext #(
636:     .DW    (1)
637:   ) u_cfg_endian_swap (
638:     .re     (cfg_re),
639:     .we     (cfg_we),
640:     .wd     (cfg_endian_swap_wd),
641:     .d      (hw2reg.cfg.endian_swap.d),
642:     .qre    (),
643:     .qe     (cfg_flds_we[2]),
644:     .q      (reg2hw.cfg.endian_swap.q),
645:     .ds     (),
646:     .qs     (cfg_endian_swap_qs)
647:   );
648:   assign reg2hw.cfg.endian_swap.qe = cfg_qe;
649: 
650:   //   F[digest_swap]: 3:3
651:   prim_subreg_ext #(
652:     .DW    (1)
653:   ) u_cfg_digest_swap (
654:     .re     (cfg_re),
655:     .we     (cfg_we),
656:     .wd     (cfg_digest_swap_wd),
657:     .d      (hw2reg.cfg.digest_swap.d),
658:     .qre    (),
659:     .qe     (cfg_flds_we[3]),
660:     .q      (reg2hw.cfg.digest_swap.q),
661:     .ds     (),
662:     .qs     (cfg_digest_swap_qs)
663:   );
664:   assign reg2hw.cfg.digest_swap.qe = cfg_qe;
665: 
666:   //   F[key_swap]: 4:4
667:   prim_subreg_ext #(
668:     .DW    (1)
669:   ) u_cfg_key_swap (
670:     .re     (cfg_re),
671:     .we     (cfg_we),
672:     .wd     (cfg_key_swap_wd),
673:     .d      (hw2reg.cfg.key_swap.d),
674:     .qre    (),
675:     .qe     (cfg_flds_we[4]),
676:     .q      (reg2hw.cfg.key_swap.q),
677:     .ds     (),
678:     .qs     (cfg_key_swap_qs)
679:   );
680:   assign reg2hw.cfg.key_swap.qe = cfg_qe;
681: 
682:   //   F[digest_size]: 8:5
683:   prim_subreg_ext #(
684:     .DW    (4)
685:   ) u_cfg_digest_size (
686:     .re     (cfg_re),
687:     .we     (cfg_we),
688:     .wd     (cfg_digest_size_wd),
689:     .d      (hw2reg.cfg.digest_size.d),
690:     .qre    (),
691:     .qe     (cfg_flds_we[5]),
692:     .q      (reg2hw.cfg.digest_size.q),
693:     .ds     (),
694:     .qs     (cfg_digest_size_qs)
695:   );
696:   assign reg2hw.cfg.digest_size.qe = cfg_qe;
697: 
698:   //   F[key_length]: 14:9
699:   prim_subreg_ext #(
700:     .DW    (6)
701:   ) u_cfg_key_length (
702:     .re     (cfg_re),
703:     .we     (cfg_we),
704:     .wd     (cfg_key_length_wd),
705:     .d      (hw2reg.cfg.key_length.d),
706:     .qre    (),
707:     .qe     (cfg_flds_we[6]),
708:     .q      (reg2hw.cfg.key_length.q),
709:     .ds     (),
710:     .qs     (cfg_key_length_qs)
711:   );
712:   assign reg2hw.cfg.key_length.qe = cfg_qe;
713: 
714: 
715:   // R[cmd]: V(True)
716:   logic cmd_qe;
717:   logic [3:0] cmd_flds_we;
718:   assign cmd_qe = &cmd_flds_we;
719:   //   F[hash_start]: 0:0
720:   prim_subreg_ext #(
721:     .DW    (1)
722:   ) u_cmd_hash_start (
723:     .re     (1'b0),
724:     .we     (cmd_we),
725:     .wd     (cmd_hash_start_wd),
726:     .d      ('0),
727:     .qre    (),
728:     .qe     (cmd_flds_we[0]),
729:     .q      (reg2hw.cmd.hash_start.q),
730:     .ds     (),
731:     .qs     ()
732:   );
733:   assign reg2hw.cmd.hash_start.qe = cmd_qe;
734: 
735:   //   F[hash_process]: 1:1
736:   prim_subreg_ext #(
737:     .DW    (1)
738:   ) u_cmd_hash_process (
739:     .re     (1'b0),
740:     .we     (cmd_we),
741:     .wd     (cmd_hash_process_wd),
742:     .d      ('0),
743:     .qre    (),
744:     .qe     (cmd_flds_we[1]),
745:     .q      (reg2hw.cmd.hash_process.q),
746:     .ds     (),
747:     .qs     ()
748:   );
749:   assign reg2hw.cmd.hash_process.qe = cmd_qe;
750: 
751:   //   F[hash_stop]: 2:2
752:   prim_subreg_ext #(
753:     .DW    (1)
754:   ) u_cmd_hash_stop (
755:     .re     (1'b0),
756:     .we     (cmd_we),
757:     .wd     (cmd_hash_stop_wd),
758:     .d      ('0),
759:     .qre    (),
760:     .qe     (cmd_flds_we[2]),
761:     .q      (reg2hw.cmd.hash_stop.q),
762:     .ds     (),
763:     .qs     ()
764:   );
765:   assign reg2hw.cmd.hash_stop.qe = cmd_qe;
766: 
767:   //   F[hash_continue]: 3:3
768:   prim_subreg_ext #(
769:     .DW    (1)
770:   ) u_cmd_hash_continue (
771:     .re     (1'b0),
772:     .we     (cmd_we),
773:     .wd     (cmd_hash_continue_wd),
774:     .d      ('0),
775:     .qre    (),
776:     .qe     (cmd_flds_we[3]),
777:     .q      (reg2hw.cmd.hash_continue.q),
778:     .ds     (),
779:     .qs     ()
780:   );
781:   assign reg2hw.cmd.hash_continue.qe = cmd_qe;
782: 
783: 
784:   // R[status]: V(True)
785:   //   F[hmac_idle]: 0:0
786:   prim_subreg_ext #(
787:     .DW    (1)
788:   ) u_status_hmac_idle (
789:     .re     (status_re),
790:     .we     (1'b0),
791:     .wd     ('0),
792:     .d      (hw2reg.status.hmac_idle.d),
793:     .qre    (),
794:     .qe     (),
795:     .q      (),
796:     .ds     (),
797:     .qs     (status_hmac_idle_qs)
798:   );
799: 
800:   //   F[fifo_empty]: 1:1
801:   prim_subreg_ext #(
802:     .DW    (1)
803:   ) u_status_fifo_empty (
804:     .re     (status_re),
805:     .we     (1'b0),
806:     .wd     ('0),
807:     .d      (hw2reg.status.fifo_empty.d),
808:     .qre    (),
809:     .qe     (),
810:     .q      (),
811:     .ds     (),
812:     .qs     (status_fifo_empty_qs)
813:   );
814: 
815:   //   F[fifo_full]: 2:2
816:   prim_subreg_ext #(
817:     .DW    (1)
818:   ) u_status_fifo_full (
819:     .re     (status_re),
820:     .we     (1'b0),
821:     .wd     ('0),
822:     .d      (hw2reg.status.fifo_full.d),
823:     .qre    (),
824:     .qe     (),
825:     .q      (),
826:     .ds     (),
827:     .qs     (status_fifo_full_qs)
828:   );
829: 
830:   //   F[fifo_depth]: 9:4
831:   prim_subreg_ext #(
832:     .DW    (6)
833:   ) u_status_fifo_depth (
834:     .re     (status_re),
835:     .we     (1'b0),
836:     .wd     ('0),
837:     .d      (hw2reg.status.fifo_depth.d),
838:     .qre    (),
839:     .qe     (),
840:     .q      (),
841:     .ds     (),
842:     .qs     (status_fifo_depth_qs)
843:   );
844: 
845: 
846:   // R[err_code]: V(False)
847:   prim_subreg #(
848:     .DW      (32),
849:     .SwAccess(prim_subreg_pkg::SwAccessRO),
850:     .RESVAL  (32'h0),
851:     .Mubi    (1'b0)
852:   ) u_err_code (
853:     .clk_i   (clk_i),
854:     .rst_ni  (rst_ni),
855: 
856:     // from register interface
857:     .we     (1'b0),
858:     .wd     ('0),
859: 
860:     // from internal hardware
861:     .de     (hw2reg.err_code.de),
862:     .d      (hw2reg.err_code.d),
863: 
864:     // to internal hardware
865:     .qe     (),
866:     .q      (),
867:     .ds     (),
868: 
869:     // to register interface (read)
870:     .qs     (err_code_qs)
871:   );
872: 
873: 
874:   // R[wipe_secret]: V(True)
875:   logic wipe_secret_qe;
876:   logic [0:0] wipe_secret_flds_we;
877:   assign wipe_secret_qe = &wipe_secret_flds_we;
878:   prim_subreg_ext #(
879:     .DW    (32)
880:   ) u_wipe_secret (
881:     .re     (1'b0),
882:     .we     (wipe_secret_we),
883:     .wd     (wipe_secret_wd),
884:     .d      ('0),
885:     .qre    (),
886:     .qe     (wipe_secret_flds_we[0]),
887:     .q      (reg2hw.wipe_secret.q),
888:     .ds     (),
889:     .qs     ()
890:   );
891:   assign reg2hw.wipe_secret.qe = wipe_secret_qe;
892: 
893: 
894:   // Subregister 0 of Multireg key
895:   // R[key_0]: V(True)
896:   logic key_0_qe;
897:   logic [0:0] key_0_flds_we;
898:   assign key_0_qe = &key_0_flds_we;
899:   prim_subreg_ext #(
900:     .DW    (32)
901:   ) u_key_0 (
902:     .re     (1'b0),
903:     .we     (key_0_we),
904:     .wd     (key_0_wd),
905:     .d      (hw2reg.key[0].d),
906:     .qre    (),
907:     .qe     (key_0_flds_we[0]),
908:     .q      (reg2hw.key[0].q),
909:     .ds     (),
910:     .qs     ()
911:   );
912:   assign reg2hw.key[0].qe = key_0_qe;
913: 
914: 
915:   // Subregister 1 of Multireg key
916:   // R[key_1]: V(True)
917:   logic key_1_qe;
918:   logic [0:0] key_1_flds_we;
919:   assign key_1_qe = &key_1_flds_we;
920:   prim_subreg_ext #(
921:     .DW    (32)
922:   ) u_key_1 (
923:     .re     (1'b0),
924:     .we     (key_1_we),
925:     .wd     (key_1_wd),
926:     .d      (hw2reg.key[1].d),
927:     .qre    (),
928:     .qe     (key_1_flds_we[0]),
929:     .q      (reg2hw.key[1].q),
930:     .ds     (),
931:     .qs     ()
932:   );
933:   assign reg2hw.key[1].qe = key_1_qe;
934: 
935: 
936:   // Subregister 2 of Multireg key
937:   // R[key_2]: V(True)
938:   logic key_2_qe;
939:   logic [0:0] key_2_flds_we;
940:   assign key_2_qe = &key_2_flds_we;
941:   prim_subreg_ext #(
942:     .DW    (32)
943:   ) u_key_2 (
944:     .re     (1'b0),
945:     .we     (key_2_we),
946:     .wd     (key_2_wd),
947:     .d      (hw2reg.key[2].d),
948:     .qre    (),
949:     .qe     (key_2_flds_we[0]),
950:     .q      (reg2hw.key[2].q),
951:     .ds     (),
952:     .qs     ()
953:   );
954:   assign reg2hw.key[2].qe = key_2_qe;
955: 
956: 
957:   // Subregister 3 of Multireg key
958:   // R[key_3]: V(True)
959:   logic key_3_qe;
960:   logic [0:0] key_3_flds_we;
961:   assign key_3_qe = &key_3_flds_we;
962:   prim_subreg_ext #(
963:     .DW    (32)
964:   ) u_key_3 (
965:     .re     (1'b0),
966:     .we     (key_3_we),
967:     .wd     (key_3_wd),
968:     .d      (hw2reg.key[3].d),
969:     .qre    (),
970:     .qe     (key_3_flds_we[0]),
971:     .q      (reg2hw.key[3].q),
972:     .ds     (),
973:     .qs     ()
974:   );
975:   assign reg2hw.key[3].qe = key_3_qe;
976: 
977: 
978:   // Subregister 4 of Multireg key
979:   // R[key_4]: V(True)
980:   logic key_4_qe;
981:   logic [0:0] key_4_flds_we;
982:   assign key_4_qe = &key_4_flds_we;
983:   prim_subreg_ext #(
984:     .DW    (32)
985:   ) u_key_4 (
986:     .re     (1'b0),
987:     .we     (key_4_we),
988:     .wd     (key_4_wd),
989:     .d      (hw2reg.key[4].d),
990:     .qre    (),
991:     .qe     (key_4_flds_we[0]),
992:     .q      (reg2hw.key[4].q),
993:     .ds     (),
994:     .qs     ()
995:   );
996:   assign reg2hw.key[4].qe = key_4_qe;
997: 
998: 
999:   // Subregister 5 of Multireg key
1000:   // R[key_5]: V(True)
1001:   logic key_5_qe;
1002:   logic [0:0] key_5_flds_we;
1003:   assign key_5_qe = &key_5_flds_we;
1004:   prim_subreg_ext #(
1005:     .DW    (32)
1006:   ) u_key_5 (
1007:     .re     (1'b0),
1008:     .we     (key_5_we),
1009:     .wd     (key_5_wd),
1010:     .d      (hw2reg.key[5].d),
1011:     .qre    (),
1012:     .qe     (key_5_flds_we[0]),
1013:     .q      (reg2hw.key[5].q),
1014:     .ds     (),
1015:     .qs     ()
1016:   );
1017:   assign reg2hw.key[5].qe = key_5_qe;
1018: 
1019: 
1020:   // Subregister 6 of Multireg key
1021:   // R[key_6]: V(True)
1022:   logic key_6_qe;
1023:   logic [0:0] key_6_flds_we;
1024:   assign key_6_qe = &key_6_flds_we;
1025:   prim_subreg_ext #(
1026:     .DW    (32)
1027:   ) u_key_6 (
1028:     .re     (1'b0),
1029:     .we     (key_6_we),
1030:     .wd     (key_6_wd),
1031:     .d      (hw2reg.key[6].d),
1032:     .qre    (),
1033:     .qe     (key_6_flds_we[0]),
1034:     .q      (reg2hw.key[6].q),
1035:     .ds     (),
1036:     .qs     ()
1037:   );
1038:   assign reg2hw.key[6].qe = key_6_qe;
1039: 
1040: 
1041:   // Subregister 7 of Multireg key
1042:   // R[key_7]: V(True)
1043:   logic key_7_qe;
1044:   logic [0:0] key_7_flds_we;
1045:   assign key_7_qe = &key_7_flds_we;
1046:   prim_subreg_ext #(
1047:     .DW    (32)
1048:   ) u_key_7 (
1049:     .re     (1'b0),
1050:     .we     (key_7_we),
1051:     .wd     (key_7_wd),
1052:     .d      (hw2reg.key[7].d),
1053:     .qre    (),
1054:     .qe     (key_7_flds_we[0]),
1055:     .q      (reg2hw.key[7].q),
1056:     .ds     (),
1057:     .qs     ()
1058:   );
1059:   assign reg2hw.key[7].qe = key_7_qe;
1060: 
1061: 
1062:   // Subregister 8 of Multireg key
1063:   // R[key_8]: V(True)
1064:   logic key_8_qe;
1065:   logic [0:0] key_8_flds_we;
1066:   assign key_8_qe = &key_8_flds_we;
1067:   prim_subreg_ext #(
1068:     .DW    (32)
1069:   ) u_key_8 (
1070:     .re     (1'b0),
1071:     .we     (key_8_we),
1072:     .wd     (key_8_wd),
1073:     .d      (hw2reg.key[8].d),
1074:     .qre    (),
1075:     .qe     (key_8_flds_we[0]),
1076:     .q      (reg2hw.key[8].q),
1077:     .ds     (),
1078:     .qs     ()
1079:   );
1080:   assign reg2hw.key[8].qe = key_8_qe;
1081: 
1082: 
1083:   // Subregister 9 of Multireg key
1084:   // R[key_9]: V(True)
1085:   logic key_9_qe;
1086:   logic [0:0] key_9_flds_we;
1087:   assign key_9_qe = &key_9_flds_we;
1088:   prim_subreg_ext #(
1089:     .DW    (32)
1090:   ) u_key_9 (
1091:     .re     (1'b0),
1092:     .we     (key_9_we),
1093:     .wd     (key_9_wd),
1094:     .d      (hw2reg.key[9].d),
1095:     .qre    (),
1096:     .qe     (key_9_flds_we[0]),
1097:     .q      (reg2hw.key[9].q),
1098:     .ds     (),
1099:     .qs     ()
1100:   );
1101:   assign reg2hw.key[9].qe = key_9_qe;
1102: 
1103: 
1104:   // Subregister 10 of Multireg key
1105:   // R[key_10]: V(True)
1106:   logic key_10_qe;
1107:   logic [0:0] key_10_flds_we;
1108:   assign key_10_qe = &key_10_flds_we;
1109:   prim_subreg_ext #(
1110:     .DW    (32)
1111:   ) u_key_10 (
1112:     .re     (1'b0),
1113:     .we     (key_10_we),
1114:     .wd     (key_10_wd),
1115:     .d      (hw2reg.key[10].d),
1116:     .qre    (),
1117:     .qe     (key_10_flds_we[0]),
1118:     .q      (reg2hw.key[10].q),
1119:     .ds     (),
1120:     .qs     ()
1121:   );
1122:   assign reg2hw.key[10].qe = key_10_qe;
1123: 
1124: 
1125:   // Subregister 11 of Multireg key
1126:   // R[key_11]: V(True)
1127:   logic key_11_qe;
1128:   logic [0:0] key_11_flds_we;
1129:   assign key_11_qe = &key_11_flds_we;
1130:   prim_subreg_ext #(
1131:     .DW    (32)
1132:   ) u_key_11 (
1133:     .re     (1'b0),
1134:     .we     (key_11_we),
1135:     .wd     (key_11_wd),
1136:     .d      (hw2reg.key[11].d),
1137:     .qre    (),
1138:     .qe     (key_11_flds_we[0]),
1139:     .q      (reg2hw.key[11].q),
1140:     .ds     (),
1141:     .qs     ()
1142:   );
1143:   assign reg2hw.key[11].qe = key_11_qe;
1144: 
1145: 
1146:   // Subregister 12 of Multireg key
1147:   // R[key_12]: V(True)
1148:   logic key_12_qe;
1149:   logic [0:0] key_12_flds_we;
1150:   assign key_12_qe = &key_12_flds_we;
1151:   prim_subreg_ext #(
1152:     .DW    (32)
1153:   ) u_key_12 (
1154:     .re     (1'b0),
1155:     .we     (key_12_we),
1156:     .wd     (key_12_wd),
1157:     .d      (hw2reg.key[12].d),
1158:     .qre    (),
1159:     .qe     (key_12_flds_we[0]),
1160:     .q      (reg2hw.key[12].q),
1161:     .ds     (),
1162:     .qs     ()
1163:   );
1164:   assign reg2hw.key[12].qe = key_12_qe;
1165: 
1166: 
1167:   // Subregister 13 of Multireg key
1168:   // R[key_13]: V(True)
1169:   logic key_13_qe;
1170:   logic [0:0] key_13_flds_we;
1171:   assign key_13_qe = &key_13_flds_we;
1172:   prim_subreg_ext #(
1173:     .DW    (32)
1174:   ) u_key_13 (
1175:     .re     (1'b0),
1176:     .we     (key_13_we),
1177:     .wd     (key_13_wd),
1178:     .d      (hw2reg.key[13].d),
1179:     .qre    (),
1180:     .qe     (key_13_flds_we[0]),
1181:     .q      (reg2hw.key[13].q),
1182:     .ds     (),
1183:     .qs     ()
1184:   );
1185:   assign reg2hw.key[13].qe = key_13_qe;
1186: 
1187: 
1188:   // Subregister 14 of Multireg key
1189:   // R[key_14]: V(True)
1190:   logic key_14_qe;
1191:   logic [0:0] key_14_flds_we;
1192:   assign key_14_qe = &key_14_flds_we;
1193:   prim_subreg_ext #(
1194:     .DW    (32)
1195:   ) u_key_14 (
1196:     .re     (1'b0),
1197:     .we     (key_14_we),
1198:     .wd     (key_14_wd),
1199:     .d      (hw2reg.key[14].d),
1200:     .qre    (),
1201:     .qe     (key_14_flds_we[0]),
1202:     .q      (reg2hw.key[14].q),
1203:     .ds     (),
1204:     .qs     ()
1205:   );
1206:   assign reg2hw.key[14].qe = key_14_qe;
1207: 
1208: 
1209:   // Subregister 15 of Multireg key
1210:   // R[key_15]: V(True)
1211:   logic key_15_qe;
1212:   logic [0:0] key_15_flds_we;
1213:   assign key_15_qe = &key_15_flds_we;
1214:   prim_subreg_ext #(
1215:     .DW    (32)
1216:   ) u_key_15 (
1217:     .re     (1'b0),
1218:     .we     (key_15_we),
1219:     .wd     (key_15_wd),
1220:     .d      (hw2reg.key[15].d),
1221:     .qre    (),
1222:     .qe     (key_15_flds_we[0]),
1223:     .q      (reg2hw.key[15].q),
1224:     .ds     (),
1225:     .qs     ()
1226:   );
1227:   assign reg2hw.key[15].qe = key_15_qe;
1228: 
1229: 
1230:   // Subregister 16 of Multireg key
1231:   // R[key_16]: V(True)
1232:   logic key_16_qe;
1233:   logic [0:0] key_16_flds_we;
1234:   assign key_16_qe = &key_16_flds_we;
1235:   prim_subreg_ext #(
1236:     .DW    (32)
1237:   ) u_key_16 (
1238:     .re     (1'b0),
1239:     .we     (key_16_we),
1240:     .wd     (key_16_wd),
1241:     .d      (hw2reg.key[16].d),
1242:     .qre    (),
1243:     .qe     (key_16_flds_we[0]),
1244:     .q      (reg2hw.key[16].q),
1245:     .ds     (),
1246:     .qs     ()
1247:   );
1248:   assign reg2hw.key[16].qe = key_16_qe;
1249: 
1250: 
1251:   // Subregister 17 of Multireg key
1252:   // R[key_17]: V(True)
1253:   logic key_17_qe;
1254:   logic [0:0] key_17_flds_we;
1255:   assign key_17_qe = &key_17_flds_we;
1256:   prim_subreg_ext #(
1257:     .DW    (32)
1258:   ) u_key_17 (
1259:     .re     (1'b0),
1260:     .we     (key_17_we),
1261:     .wd     (key_17_wd),
1262:     .d      (hw2reg.key[17].d),
1263:     .qre    (),
1264:     .qe     (key_17_flds_we[0]),
1265:     .q      (reg2hw.key[17].q),
1266:     .ds     (),
1267:     .qs     ()
1268:   );
1269:   assign reg2hw.key[17].qe = key_17_qe;
1270: 
1271: 
1272:   // Subregister 18 of Multireg key
1273:   // R[key_18]: V(True)
1274:   logic key_18_qe;
1275:   logic [0:0] key_18_flds_we;
1276:   assign key_18_qe = &key_18_flds_we;
1277:   prim_subreg_ext #(
1278:     .DW    (32)
1279:   ) u_key_18 (
1280:     .re     (1'b0),
1281:     .we     (key_18_we),
1282:     .wd     (key_18_wd),
1283:     .d      (hw2reg.key[18].d),
1284:     .qre    (),
1285:     .qe     (key_18_flds_we[0]),
1286:     .q      (reg2hw.key[18].q),
1287:     .ds     (),
1288:     .qs     ()
1289:   );
1290:   assign reg2hw.key[18].qe = key_18_qe;
1291: 
1292: 
1293:   // Subregister 19 of Multireg key
1294:   // R[key_19]: V(True)
1295:   logic key_19_qe;
1296:   logic [0:0] key_19_flds_we;
1297:   assign key_19_qe = &key_19_flds_we;
1298:   prim_subreg_ext #(
1299:     .DW    (32)
1300:   ) u_key_19 (
1301:     .re     (1'b0),
1302:     .we     (key_19_we),
1303:     .wd     (key_19_wd),
1304:     .d      (hw2reg.key[19].d),
1305:     .qre    (),
1306:     .qe     (key_19_flds_we[0]),
1307:     .q      (reg2hw.key[19].q),
1308:     .ds     (),
1309:     .qs     ()
1310:   );
1311:   assign reg2hw.key[19].qe = key_19_qe;
1312: 
1313: 
1314:   // Subregister 20 of Multireg key
1315:   // R[key_20]: V(True)
1316:   logic key_20_qe;
1317:   logic [0:0] key_20_flds_we;
1318:   assign key_20_qe = &key_20_flds_we;
1319:   prim_subreg_ext #(
1320:     .DW    (32)
1321:   ) u_key_20 (
1322:     .re     (1'b0),
1323:     .we     (key_20_we),
1324:     .wd     (key_20_wd),
1325:     .d      (hw2reg.key[20].d),
1326:     .qre    (),
1327:     .qe     (key_20_flds_we[0]),
1328:     .q      (reg2hw.key[20].q),
1329:     .ds     (),
1330:     .qs     ()
1331:   );
1332:   assign reg2hw.key[20].qe = key_20_qe;
1333: 
1334: 
1335:   // Subregister 21 of Multireg key
1336:   // R[key_21]: V(True)
1337:   logic key_21_qe;
1338:   logic [0:0] key_21_flds_we;
1339:   assign key_21_qe = &key_21_flds_we;
1340:   prim_subreg_ext #(
1341:     .DW    (32)
1342:   ) u_key_21 (
1343:     .re     (1'b0),
1344:     .we     (key_21_we),
1345:     .wd     (key_21_wd),
1346:     .d      (hw2reg.key[21].d),
1347:     .qre    (),
1348:     .qe     (key_21_flds_we[0]),
1349:     .q      (reg2hw.key[21].q),
1350:     .ds     (),
1351:     .qs     ()
1352:   );
1353:   assign reg2hw.key[21].qe = key_21_qe;
1354: 
1355: 
1356:   // Subregister 22 of Multireg key
1357:   // R[key_22]: V(True)
1358:   logic key_22_qe;
1359:   logic [0:0] key_22_flds_we;
1360:   assign key_22_qe = &key_22_flds_we;
1361:   prim_subreg_ext #(
1362:     .DW    (32)
1363:   ) u_key_22 (
1364:     .re     (1'b0),
1365:     .we     (key_22_we),
1366:     .wd     (key_22_wd),
1367:     .d      (hw2reg.key[22].d),
1368:     .qre    (),
1369:     .qe     (key_22_flds_we[0]),
1370:     .q      (reg2hw.key[22].q),
1371:     .ds     (),
1372:     .qs     ()
1373:   );
1374:   assign reg2hw.key[22].qe = key_22_qe;
1375: 
1376: 
1377:   // Subregister 23 of Multireg key
1378:   // R[key_23]: V(True)
1379:   logic key_23_qe;
1380:   logic [0:0] key_23_flds_we;
1381:   assign key_23_qe = &key_23_flds_we;
1382:   prim_subreg_ext #(
1383:     .DW    (32)
1384:   ) u_key_23 (
1385:     .re     (1'b0),
1386:     .we     (key_23_we),
1387:     .wd     (key_23_wd),
1388:     .d      (hw2reg.key[23].d),
1389:     .qre    (),
1390:     .qe     (key_23_flds_we[0]),
1391:     .q      (reg2hw.key[23].q),
1392:     .ds     (),
1393:     .qs     ()
1394:   );
1395:   assign reg2hw.key[23].qe = key_23_qe;
1396: 
1397: 
1398:   // Subregister 24 of Multireg key
1399:   // R[key_24]: V(True)
1400:   logic key_24_qe;
1401:   logic [0:0] key_24_flds_we;
1402:   assign key_24_qe = &key_24_flds_we;
1403:   prim_subreg_ext #(
1404:     .DW    (32)
1405:   ) u_key_24 (
1406:     .re     (1'b0),
1407:     .we     (key_24_we),
1408:     .wd     (key_24_wd),
1409:     .d      (hw2reg.key[24].d),
1410:     .qre    (),
1411:     .qe     (key_24_flds_we[0]),
1412:     .q      (reg2hw.key[24].q),
1413:     .ds     (),
1414:     .qs     ()
1415:   );
1416:   assign reg2hw.key[24].qe = key_24_qe;
1417: 
1418: 
1419:   // Subregister 25 of Multireg key
1420:   // R[key_25]: V(True)
1421:   logic key_25_qe;
1422:   logic [0:0] key_25_flds_we;
1423:   assign key_25_qe = &key_25_flds_we;
1424:   prim_subreg_ext #(
1425:     .DW    (32)
1426:   ) u_key_25 (
1427:     .re     (1'b0),
1428:     .we     (key_25_we),
1429:     .wd     (key_25_wd),
1430:     .d      (hw2reg.key[25].d),
1431:     .qre    (),
1432:     .qe     (key_25_flds_we[0]),
1433:     .q      (reg2hw.key[25].q),
1434:     .ds     (),
1435:     .qs     ()
1436:   );
1437:   assign reg2hw.key[25].qe = key_25_qe;
1438: 
1439: 
1440:   // Subregister 26 of Multireg key
1441:   // R[key_26]: V(True)
1442:   logic key_26_qe;
1443:   logic [0:0] key_26_flds_we;
1444:   assign key_26_qe = &key_26_flds_we;
1445:   prim_subreg_ext #(
1446:     .DW    (32)
1447:   ) u_key_26 (
1448:     .re     (1'b0),
1449:     .we     (key_26_we),
1450:     .wd     (key_26_wd),
1451:     .d      (hw2reg.key[26].d),
1452:     .qre    (),
1453:     .qe     (key_26_flds_we[0]),
1454:     .q      (reg2hw.key[26].q),
1455:     .ds     (),
1456:     .qs     ()
1457:   );
1458:   assign reg2hw.key[26].qe = key_26_qe;
1459: 
1460: 
1461:   // Subregister 27 of Multireg key
1462:   // R[key_27]: V(True)
1463:   logic key_27_qe;
1464:   logic [0:0] key_27_flds_we;
1465:   assign key_27_qe = &key_27_flds_we;
1466:   prim_subreg_ext #(
1467:     .DW    (32)
1468:   ) u_key_27 (
1469:     .re     (1'b0),
1470:     .we     (key_27_we),
1471:     .wd     (key_27_wd),
1472:     .d      (hw2reg.key[27].d),
1473:     .qre    (),
1474:     .qe     (key_27_flds_we[0]),
1475:     .q      (reg2hw.key[27].q),
1476:     .ds     (),
1477:     .qs     ()
1478:   );
1479:   assign reg2hw.key[27].qe = key_27_qe;
1480: 
1481: 
1482:   // Subregister 28 of Multireg key
1483:   // R[key_28]: V(True)
1484:   logic key_28_qe;
1485:   logic [0:0] key_28_flds_we;
1486:   assign key_28_qe = &key_28_flds_we;
1487:   prim_subreg_ext #(
1488:     .DW    (32)
1489:   ) u_key_28 (
1490:     .re     (1'b0),
1491:     .we     (key_28_we),
1492:     .wd     (key_28_wd),
1493:     .d      (hw2reg.key[28].d),
1494:     .qre    (),
1495:     .qe     (key_28_flds_we[0]),
1496:     .q      (reg2hw.key[28].q),
1497:     .ds     (),
1498:     .qs     ()
1499:   );
1500:   assign reg2hw.key[28].qe = key_28_qe;
1501: 
1502: 
1503:   // Subregister 29 of Multireg key
1504:   // R[key_29]: V(True)
1505:   logic key_29_qe;
1506:   logic [0:0] key_29_flds_we;
1507:   assign key_29_qe = &key_29_flds_we;
1508:   prim_subreg_ext #(
1509:     .DW    (32)
1510:   ) u_key_29 (
1511:     .re     (1'b0),
1512:     .we     (key_29_we),
1513:     .wd     (key_29_wd),
1514:     .d      (hw2reg.key[29].d),
1515:     .qre    (),
1516:     .qe     (key_29_flds_we[0]),
1517:     .q      (reg2hw.key[29].q),
1518:     .ds     (),
1519:     .qs     ()
1520:   );
1521:   assign reg2hw.key[29].qe = key_29_qe;
1522: 
1523: 
1524:   // Subregister 30 of Multireg key
1525:   // R[key_30]: V(True)
1526:   logic key_30_qe;
1527:   logic [0:0] key_30_flds_we;
1528:   assign key_30_qe = &key_30_flds_we;
1529:   prim_subreg_ext #(
1530:     .DW    (32)
1531:   ) u_key_30 (
1532:     .re     (1'b0),
1533:     .we     (key_30_we),
1534:     .wd     (key_30_wd),
1535:     .d      (hw2reg.key[30].d),
1536:     .qre    (),
1537:     .qe     (key_30_flds_we[0]),
1538:     .q      (reg2hw.key[30].q),
1539:     .ds     (),
1540:     .qs     ()
1541:   );
1542:   assign reg2hw.key[30].qe = key_30_qe;
1543: 
1544: 
1545:   // Subregister 31 of Multireg key
1546:   // R[key_31]: V(True)
1547:   logic key_31_qe;
1548:   logic [0:0] key_31_flds_we;
1549:   assign key_31_qe = &key_31_flds_we;
1550:   prim_subreg_ext #(
1551:     .DW    (32)
1552:   ) u_key_31 (
1553:     .re     (1'b0),
1554:     .we     (key_31_we),
1555:     .wd     (key_31_wd),
1556:     .d      (hw2reg.key[31].d),
1557:     .qre    (),
1558:     .qe     (key_31_flds_we[0]),
1559:     .q      (reg2hw.key[31].q),
1560:     .ds     (),
1561:     .qs     ()
1562:   );
1563:   assign reg2hw.key[31].qe = key_31_qe;
1564: 
1565: 
1566:   // Subregister 0 of Multireg digest
1567:   // R[digest_0]: V(True)
1568:   logic digest_0_qe;
1569:   logic [0:0] digest_0_flds_we;
1570:   assign digest_0_qe = &digest_0_flds_we;
1571:   prim_subreg_ext #(
1572:     .DW    (32)
1573:   ) u_digest_0 (
1574:     .re     (digest_0_re),
1575:     .we     (digest_0_we),
1576:     .wd     (digest_0_wd),
1577:     .d      (hw2reg.digest[0].d),
1578:     .qre    (),
1579:     .qe     (digest_0_flds_we[0]),
1580:     .q      (reg2hw.digest[0].q),
1581:     .ds     (),
1582:     .qs     (digest_0_qs)
1583:   );
1584:   assign reg2hw.digest[0].qe = digest_0_qe;
1585: 
1586: 
1587:   // Subregister 1 of Multireg digest
1588:   // R[digest_1]: V(True)
1589:   logic digest_1_qe;
1590:   logic [0:0] digest_1_flds_we;
1591:   assign digest_1_qe = &digest_1_flds_we;
1592:   prim_subreg_ext #(
1593:     .DW    (32)
1594:   ) u_digest_1 (
1595:     .re     (digest_1_re),
1596:     .we     (digest_1_we),
1597:     .wd     (digest_1_wd),
1598:     .d      (hw2reg.digest[1].d),
1599:     .qre    (),
1600:     .qe     (digest_1_flds_we[0]),
1601:     .q      (reg2hw.digest[1].q),
1602:     .ds     (),
1603:     .qs     (digest_1_qs)
1604:   );
1605:   assign reg2hw.digest[1].qe = digest_1_qe;
1606: 
1607: 
1608:   // Subregister 2 of Multireg digest
1609:   // R[digest_2]: V(True)
1610:   logic digest_2_qe;
1611:   logic [0:0] digest_2_flds_we;
1612:   assign digest_2_qe = &digest_2_flds_we;
1613:   prim_subreg_ext #(
1614:     .DW    (32)
1615:   ) u_digest_2 (
1616:     .re     (digest_2_re),
1617:     .we     (digest_2_we),
1618:     .wd     (digest_2_wd),
1619:     .d      (hw2reg.digest[2].d),
1620:     .qre    (),
1621:     .qe     (digest_2_flds_we[0]),
1622:     .q      (reg2hw.digest[2].q),
1623:     .ds     (),
1624:     .qs     (digest_2_qs)
1625:   );
1626:   assign reg2hw.digest[2].qe = digest_2_qe;
1627: 
1628: 
1629:   // Subregister 3 of Multireg digest
1630:   // R[digest_3]: V(True)
1631:   logic digest_3_qe;
1632:   logic [0:0] digest_3_flds_we;
1633:   assign digest_3_qe = &digest_3_flds_we;
1634:   prim_subreg_ext #(
1635:     .DW    (32)
1636:   ) u_digest_3 (
1637:     .re     (digest_3_re),
1638:     .we     (digest_3_we),
1639:     .wd     (digest_3_wd),
1640:     .d      (hw2reg.digest[3].d),
1641:     .qre    (),
1642:     .qe     (digest_3_flds_we[0]),
1643:     .q      (reg2hw.digest[3].q),
1644:     .ds     (),
1645:     .qs     (digest_3_qs)
1646:   );
1647:   assign reg2hw.digest[3].qe = digest_3_qe;
1648: 
1649: 
1650:   // Subregister 4 of Multireg digest
1651:   // R[digest_4]: V(True)
1652:   logic digest_4_qe;
1653:   logic [0:0] digest_4_flds_we;
1654:   assign digest_4_qe = &digest_4_flds_we;
1655:   prim_subreg_ext #(
1656:     .DW    (32)
1657:   ) u_digest_4 (
1658:     .re     (digest_4_re),
1659:     .we     (digest_4_we),
1660:     .wd     (digest_4_wd),
1661:     .d      (hw2reg.digest[4].d),
1662:     .qre    (),
1663:     .qe     (digest_4_flds_we[0]),
1664:     .q      (reg2hw.digest[4].q),
1665:     .ds     (),
1666:     .qs     (digest_4_qs)
1667:   );
1668:   assign reg2hw.digest[4].qe = digest_4_qe;
1669: 
1670: 
1671:   // Subregister 5 of Multireg digest
1672:   // R[digest_5]: V(True)
1673:   logic digest_5_qe;
1674:   logic [0:0] digest_5_flds_we;
1675:   assign digest_5_qe = &digest_5_flds_we;
1676:   prim_subreg_ext #(
1677:     .DW    (32)
1678:   ) u_digest_5 (
1679:     .re     (digest_5_re),
1680:     .we     (digest_5_we),
1681:     .wd     (digest_5_wd),
1682:     .d      (hw2reg.digest[5].d),
1683:     .qre    (),
1684:     .qe     (digest_5_flds_we[0]),
1685:     .q      (reg2hw.digest[5].q),
1686:     .ds     (),
1687:     .qs     (digest_5_qs)
1688:   );
1689:   assign reg2hw.digest[5].qe = digest_5_qe;
1690: 
1691: 
1692:   // Subregister 6 of Multireg digest
1693:   // R[digest_6]: V(True)
1694:   logic digest_6_qe;
1695:   logic [0:0] digest_6_flds_we;
1696:   assign digest_6_qe = &digest_6_flds_we;
1697:   prim_subreg_ext #(
1698:     .DW    (32)
1699:   ) u_digest_6 (
1700:     .re     (digest_6_re),
1701:     .we     (digest_6_we),
1702:     .wd     (digest_6_wd),
1703:     .d      (hw2reg.digest[6].d),
1704:     .qre    (),
1705:     .qe     (digest_6_flds_we[0]),
1706:     .q      (reg2hw.digest[6].q),
1707:     .ds     (),
1708:     .qs     (digest_6_qs)
1709:   );
1710:   assign reg2hw.digest[6].qe = digest_6_qe;
1711: 
1712: 
1713:   // Subregister 7 of Multireg digest
1714:   // R[digest_7]: V(True)
1715:   logic digest_7_qe;
1716:   logic [0:0] digest_7_flds_we;
1717:   assign digest_7_qe = &digest_7_flds_we;
1718:   prim_subreg_ext #(
1719:     .DW    (32)
1720:   ) u_digest_7 (
1721:     .re     (digest_7_re),
1722:     .we     (digest_7_we),
1723:     .wd     (digest_7_wd),
1724:     .d      (hw2reg.digest[7].d),
1725:     .qre    (),
1726:     .qe     (digest_7_flds_we[0]),
1727:     .q      (reg2hw.digest[7].q),
1728:     .ds     (),
1729:     .qs     (digest_7_qs)
1730:   );
1731:   assign reg2hw.digest[7].qe = digest_7_qe;
1732: 
1733: 
1734:   // Subregister 8 of Multireg digest
1735:   // R[digest_8]: V(True)
1736:   logic digest_8_qe;
1737:   logic [0:0] digest_8_flds_we;
1738:   assign digest_8_qe = &digest_8_flds_we;
1739:   prim_subreg_ext #(
1740:     .DW    (32)
1741:   ) u_digest_8 (
1742:     .re     (digest_8_re),
1743:     .we     (digest_8_we),
1744:     .wd     (digest_8_wd),
1745:     .d      (hw2reg.digest[8].d),
1746:     .qre    (),
1747:     .qe     (digest_8_flds_we[0]),
1748:     .q      (reg2hw.digest[8].q),
1749:     .ds     (),
1750:     .qs     (digest_8_qs)
1751:   );
1752:   assign reg2hw.digest[8].qe = digest_8_qe;
1753: 
1754: 
1755:   // Subregister 9 of Multireg digest
1756:   // R[digest_9]: V(True)
1757:   logic digest_9_qe;
1758:   logic [0:0] digest_9_flds_we;
1759:   assign digest_9_qe = &digest_9_flds_we;
1760:   prim_subreg_ext #(
1761:     .DW    (32)
1762:   ) u_digest_9 (
1763:     .re     (digest_9_re),
1764:     .we     (digest_9_we),
1765:     .wd     (digest_9_wd),
1766:     .d      (hw2reg.digest[9].d),
1767:     .qre    (),
1768:     .qe     (digest_9_flds_we[0]),
1769:     .q      (reg2hw.digest[9].q),
1770:     .ds     (),
1771:     .qs     (digest_9_qs)
1772:   );
1773:   assign reg2hw.digest[9].qe = digest_9_qe;
1774: 
1775: 
1776:   // Subregister 10 of Multireg digest
1777:   // R[digest_10]: V(True)
1778:   logic digest_10_qe;
1779:   logic [0:0] digest_10_flds_we;
1780:   assign digest_10_qe = &digest_10_flds_we;
1781:   prim_subreg_ext #(
1782:     .DW    (32)
1783:   ) u_digest_10 (
1784:     .re     (digest_10_re),
1785:     .we     (digest_10_we),
1786:     .wd     (digest_10_wd),
1787:     .d      (hw2reg.digest[10].d),
1788:     .qre    (),
1789:     .qe     (digest_10_flds_we[0]),
1790:     .q      (reg2hw.digest[10].q),
1791:     .ds     (),
1792:     .qs     (digest_10_qs)
1793:   );
1794:   assign reg2hw.digest[10].qe = digest_10_qe;
1795: 
1796: 
1797:   // Subregister 11 of Multireg digest
1798:   // R[digest_11]: V(True)
1799:   logic digest_11_qe;
1800:   logic [0:0] digest_11_flds_we;
1801:   assign digest_11_qe = &digest_11_flds_we;
1802:   prim_subreg_ext #(
1803:     .DW    (32)
1804:   ) u_digest_11 (
1805:     .re     (digest_11_re),
1806:     .we     (digest_11_we),
1807:     .wd     (digest_11_wd),
1808:     .d      (hw2reg.digest[11].d),
1809:     .qre    (),
1810:     .qe     (digest_11_flds_we[0]),
1811:     .q      (reg2hw.digest[11].q),
1812:     .ds     (),
1813:     .qs     (digest_11_qs)
1814:   );
1815:   assign reg2hw.digest[11].qe = digest_11_qe;
1816: 
1817: 
1818:   // Subregister 12 of Multireg digest
1819:   // R[digest_12]: V(True)
1820:   logic digest_12_qe;
1821:   logic [0:0] digest_12_flds_we;
1822:   assign digest_12_qe = &digest_12_flds_we;
1823:   prim_subreg_ext #(
1824:     .DW    (32)
1825:   ) u_digest_12 (
1826:     .re     (digest_12_re),
1827:     .we     (digest_12_we),
1828:     .wd     (digest_12_wd),
1829:     .d      (hw2reg.digest[12].d),
1830:     .qre    (),
1831:     .qe     (digest_12_flds_we[0]),
1832:     .q      (reg2hw.digest[12].q),
1833:     .ds     (),
1834:     .qs     (digest_12_qs)
1835:   );
1836:   assign reg2hw.digest[12].qe = digest_12_qe;
1837: 
1838: 
1839:   // Subregister 13 of Multireg digest
1840:   // R[digest_13]: V(True)
1841:   logic digest_13_qe;
1842:   logic [0:0] digest_13_flds_we;
1843:   assign digest_13_qe = &digest_13_flds_we;
1844:   prim_subreg_ext #(
1845:     .DW    (32)
1846:   ) u_digest_13 (
1847:     .re     (digest_13_re),
1848:     .we     (digest_13_we),
1849:     .wd     (digest_13_wd),
1850:     .d      (hw2reg.digest[13].d),
1851:     .qre    (),
1852:     .qe     (digest_13_flds_we[0]),
1853:     .q      (reg2hw.digest[13].q),
1854:     .ds     (),
1855:     .qs     (digest_13_qs)
1856:   );
1857:   assign reg2hw.digest[13].qe = digest_13_qe;
1858: 
1859: 
1860:   // Subregister 14 of Multireg digest
1861:   // R[digest_14]: V(True)
1862:   logic digest_14_qe;
1863:   logic [0:0] digest_14_flds_we;
1864:   assign digest_14_qe = &digest_14_flds_we;
1865:   prim_subreg_ext #(
1866:     .DW    (32)
1867:   ) u_digest_14 (
1868:     .re     (digest_14_re),
1869:     .we     (digest_14_we),
1870:     .wd     (digest_14_wd),
1871:     .d      (hw2reg.digest[14].d),
1872:     .qre    (),
1873:     .qe     (digest_14_flds_we[0]),
1874:     .q      (reg2hw.digest[14].q),
1875:     .ds     (),
1876:     .qs     (digest_14_qs)
1877:   );
1878:   assign reg2hw.digest[14].qe = digest_14_qe;
1879: 
1880: 
1881:   // Subregister 15 of Multireg digest
1882:   // R[digest_15]: V(True)
1883:   logic digest_15_qe;
1884:   logic [0:0] digest_15_flds_we;
1885:   assign digest_15_qe = &digest_15_flds_we;
1886:   prim_subreg_ext #(
1887:     .DW    (32)
1888:   ) u_digest_15 (
1889:     .re     (digest_15_re),
1890:     .we     (digest_15_we),
1891:     .wd     (digest_15_wd),
1892:     .d      (hw2reg.digest[15].d),
1893:     .qre    (),
1894:     .qe     (digest_15_flds_we[0]),
1895:     .q      (reg2hw.digest[15].q),
1896:     .ds     (),
1897:     .qs     (digest_15_qs)
1898:   );
1899:   assign reg2hw.digest[15].qe = digest_15_qe;
1900: 
1901: 
1902:   // R[msg_length_lower]: V(True)
1903:   logic msg_length_lower_qe;
1904:   logic [0:0] msg_length_lower_flds_we;
1905:   assign msg_length_lower_qe = &msg_length_lower_flds_we;
1906:   prim_subreg_ext #(
1907:     .DW    (32)
1908:   ) u_msg_length_lower (
1909:     .re     (msg_length_lower_re),
1910:     .we     (msg_length_lower_we),
1911:     .wd     (msg_length_lower_wd),
1912:     .d      (hw2reg.msg_length_lower.d),
1913:     .qre    (),
1914:     .qe     (msg_length_lower_flds_we[0]),
1915:     .q      (reg2hw.msg_length_lower.q),
1916:     .ds     (),
1917:     .qs     (msg_length_lower_qs)
1918:   );
1919:   assign reg2hw.msg_length_lower.qe = msg_length_lower_qe;
1920: 
1921: 
1922:   // R[msg_length_upper]: V(True)
1923:   logic msg_length_upper_qe;
1924:   logic [0:0] msg_length_upper_flds_we;
1925:   assign msg_length_upper_qe = &msg_length_upper_flds_we;
1926:   prim_subreg_ext #(
1927:     .DW    (32)
1928:   ) u_msg_length_upper (
1929:     .re     (msg_length_upper_re),
1930:     .we     (msg_length_upper_we),
1931:     .wd     (msg_length_upper_wd),
1932:     .d      (hw2reg.msg_length_upper.d),
1933:     .qre    (),
1934:     .qe     (msg_length_upper_flds_we[0]),
1935:     .q      (reg2hw.msg_length_upper.q),
1936:     .ds     (),
1937:     .qs     (msg_length_upper_qs)
1938:   );
1939:   assign reg2hw.msg_length_upper.qe = msg_length_upper_qe;
1940: 
1941: 
1942: 
1943:   logic [58:0] addr_hit;
1944:   always_comb begin
1945:     addr_hit[ 0] = (reg_addr == HMAC_INTR_STATE_OFFSET);
1946:     addr_hit[ 1] = (reg_addr == HMAC_INTR_ENABLE_OFFSET);
1947:     addr_hit[ 2] = (reg_addr == HMAC_INTR_TEST_OFFSET);
1948:     addr_hit[ 3] = (reg_addr == HMAC_ALERT_TEST_OFFSET);
1949:     addr_hit[ 4] = (reg_addr == HMAC_CFG_OFFSET);
1950:     addr_hit[ 5] = (reg_addr == HMAC_CMD_OFFSET);
1951:     addr_hit[ 6] = (reg_addr == HMAC_STATUS_OFFSET);
1952:     addr_hit[ 7] = (reg_addr == HMAC_ERR_CODE_OFFSET);
1953:     addr_hit[ 8] = (reg_addr == HMAC_WIPE_SECRET_OFFSET);
1954:     addr_hit[ 9] = (reg_addr == HMAC_KEY_0_OFFSET);
1955:     addr_hit[10] = (reg_addr == HMAC_KEY_1_OFFSET);
1956:     addr_hit[11] = (reg_addr == HMAC_KEY_2_OFFSET);
1957:     addr_hit[12] = (reg_addr == HMAC_KEY_3_OFFSET);
1958:     addr_hit[13] = (reg_addr == HMAC_KEY_4_OFFSET);
1959:     addr_hit[14] = (reg_addr == HMAC_KEY_5_OFFSET);
1960:     addr_hit[15] = (reg_addr == HMAC_KEY_6_OFFSET);
1961:     addr_hit[16] = (reg_addr == HMAC_KEY_7_OFFSET);
1962:     addr_hit[17] = (reg_addr == HMAC_KEY_8_OFFSET);
1963:     addr_hit[18] = (reg_addr == HMAC_KEY_9_OFFSET);
1964:     addr_hit[19] = (reg_addr == HMAC_KEY_10_OFFSET);
1965:     addr_hit[20] = (reg_addr == HMAC_KEY_11_OFFSET);
1966:     addr_hit[21] = (reg_addr == HMAC_KEY_12_OFFSET);
1967:     addr_hit[22] = (reg_addr == HMAC_KEY_13_OFFSET);
1968:     addr_hit[23] = (reg_addr == HMAC_KEY_14_OFFSET);
1969:     addr_hit[24] = (reg_addr == HMAC_KEY_15_OFFSET);
1970:     addr_hit[25] = (reg_addr == HMAC_KEY_16_OFFSET);
1971:     addr_hit[26] = (reg_addr == HMAC_KEY_17_OFFSET);
1972:     addr_hit[27] = (reg_addr == HMAC_KEY_18_OFFSET);
1973:     addr_hit[28] = (reg_addr == HMAC_KEY_19_OFFSET);
1974:     addr_hit[29] = (reg_addr == HMAC_KEY_20_OFFSET);
1975:     addr_hit[30] = (reg_addr == HMAC_KEY_21_OFFSET);
1976:     addr_hit[31] = (reg_addr == HMAC_KEY_22_OFFSET);
1977:     addr_hit[32] = (reg_addr == HMAC_KEY_23_OFFSET);
1978:     addr_hit[33] = (reg_addr == HMAC_KEY_24_OFFSET);
1979:     addr_hit[34] = (reg_addr == HMAC_KEY_25_OFFSET);
1980:     addr_hit[35] = (reg_addr == HMAC_KEY_26_OFFSET);
1981:     addr_hit[36] = (reg_addr == HMAC_KEY_27_OFFSET);
1982:     addr_hit[37] = (reg_addr == HMAC_KEY_28_OFFSET);
1983:     addr_hit[38] = (reg_addr == HMAC_KEY_29_OFFSET);
1984:     addr_hit[39] = (reg_addr == HMAC_KEY_30_OFFSET);
1985:     addr_hit[40] = (reg_addr == HMAC_KEY_31_OFFSET);
1986:     addr_hit[41] = (reg_addr == HMAC_DIGEST_0_OFFSET);
1987:     addr_hit[42] = (reg_addr == HMAC_DIGEST_1_OFFSET);
1988:     addr_hit[43] = (reg_addr == HMAC_DIGEST_2_OFFSET);
1989:     addr_hit[44] = (reg_addr == HMAC_DIGEST_3_OFFSET);
1990:     addr_hit[45] = (reg_addr == HMAC_DIGEST_4_OFFSET);
1991:     addr_hit[46] = (reg_addr == HMAC_DIGEST_5_OFFSET);
1992:     addr_hit[47] = (reg_addr == HMAC_DIGEST_6_OFFSET);
1993:     addr_hit[48] = (reg_addr == HMAC_DIGEST_7_OFFSET);
1994:     addr_hit[49] = (reg_addr == HMAC_DIGEST_8_OFFSET);
1995:     addr_hit[50] = (reg_addr == HMAC_DIGEST_9_OFFSET);
1996:     addr_hit[51] = (reg_addr == HMAC_DIGEST_10_OFFSET);
1997:     addr_hit[52] = (reg_addr == HMAC_DIGEST_11_OFFSET);
1998:     addr_hit[53] = (reg_addr == HMAC_DIGEST_12_OFFSET);
1999:     addr_hit[54] = (reg_addr == HMAC_DIGEST_13_OFFSET);
2000:     addr_hit[55] = (reg_addr == HMAC_DIGEST_14_OFFSET);
2001:     addr_hit[56] = (reg_addr == HMAC_DIGEST_15_OFFSET);
2002:     addr_hit[57] = (reg_addr == HMAC_MSG_LENGTH_LOWER_OFFSET);
2003:     addr_hit[58] = (reg_addr == HMAC_MSG_LENGTH_UPPER_OFFSET);
2004:   end
2005: 
2006:   assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;
2007: 
2008:   // Check sub-word write is permitted
2009:   always_comb begin
2010:     wr_err = (reg_we &
2011:               ((addr_hit[ 0] & (|(HMAC_PERMIT[ 0] & ~reg_be))) |
2012:                (addr_hit[ 1] & (|(HMAC_PERMIT[ 1] & ~reg_be))) |
2013:                (addr_hit[ 2] & (|(HMAC_PERMIT[ 2] & ~reg_be))) |
2014:                (addr_hit[ 3] & (|(HMAC_PERMIT[ 3] & ~reg_be))) |
2015:                (addr_hit[ 4] & (|(HMAC_PERMIT[ 4] & ~reg_be))) |
2016:                (addr_hit[ 5] & (|(HMAC_PERMIT[ 5] & ~reg_be))) |
2017:                (addr_hit[ 6] & (|(HMAC_PERMIT[ 6] & ~reg_be))) |
2018:                (addr_hit[ 7] & (|(HMAC_PERMIT[ 7] & ~reg_be))) |
2019:                (addr_hit[ 8] & (|(HMAC_PERMIT[ 8] & ~reg_be))) |
2020:                (addr_hit[ 9] & (|(HMAC_PERMIT[ 9] & ~reg_be))) |
2021:                (addr_hit[10] & (|(HMAC_PERMIT[10] & ~reg_be))) |
2022:                (addr_hit[11] & (|(HMAC_PERMIT[11] & ~reg_be))) |
2023:                (addr_hit[12] & (|(HMAC_PERMIT[12] & ~reg_be))) |
2024:                (addr_hit[13] & (|(HMAC_PERMIT[13] & ~reg_be))) |
2025:                (addr_hit[14] & (|(HMAC_PERMIT[14] & ~reg_be))) |
2026:                (addr_hit[15] & (|(HMAC_PERMIT[15] & ~reg_be))) |
2027:                (addr_hit[16] & (|(HMAC_PERMIT[16] & ~reg_be))) |
2028:                (addr_hit[17] & (|(HMAC_PERMIT[17] & ~reg_be))) |
2029:                (addr_hit[18] & (|(HMAC_PERMIT[18] & ~reg_be))) |
2030:                (addr_hit[19] & (|(HMAC_PERMIT[19] & ~reg_be))) |
2031:                (addr_hit[20] & (|(HMAC_PERMIT[20] & ~reg_be))) |
2032:                (addr_hit[21] & (|(HMAC_PERMIT[21] & ~reg_be))) |
2033:                (addr_hit[22] & (|(HMAC_PERMIT[22] & ~reg_be))) |
2034:                (addr_hit[23] & (|(HMAC_PERMIT[23] & ~reg_be))) |
2035:                (addr_hit[24] & (|(HMAC_PERMIT[24] & ~reg_be))) |
2036:                (addr_hit[25] & (|(HMAC_PERMIT[25] & ~reg_be))) |
2037:                (addr_hit[26] & (|(HMAC_PERMIT[26] & ~reg_be))) |
2038:                (addr_hit[27] & (|(HMAC_PERMIT[27] & ~reg_be))) |
2039:                (addr_hit[28] & (|(HMAC_PERMIT[28] & ~reg_be))) |
2040:                (addr_hit[29] & (|(HMAC_PERMIT[29] & ~reg_be))) |
2041:                (addr_hit[30] & (|(HMAC_PERMIT[30] & ~reg_be))) |
2042:                (addr_hit[31] & (|(HMAC_PERMIT[31] & ~reg_be))) |
2043:                (addr_hit[32] & (|(HMAC_PERMIT[32] & ~reg_be))) |
2044:                (addr_hit[33] & (|(HMAC_PERMIT[33] & ~reg_be))) |
2045:                (addr_hit[34] & (|(HMAC_PERMIT[34] & ~reg_be))) |
2046:                (addr_hit[35] & (|(HMAC_PERMIT[35] & ~reg_be))) |
2047:                (addr_hit[36] & (|(HMAC_PERMIT[36] & ~reg_be))) |
2048:                (addr_hit[37] & (|(HMAC_PERMIT[37] & ~reg_be))) |
2049:                (addr_hit[38] & (|(HMAC_PERMIT[38] & ~reg_be))) |
2050:                (addr_hit[39] & (|(HMAC_PERMIT[39] & ~reg_be))) |
2051:                (addr_hit[40] & (|(HMAC_PERMIT[40] & ~reg_be))) |
2052:                (addr_hit[41] & (|(HMAC_PERMIT[41] & ~reg_be))) |
2053:                (addr_hit[42] & (|(HMAC_PERMIT[42] & ~reg_be))) |
2054:                (addr_hit[43] & (|(HMAC_PERMIT[43] & ~reg_be))) |
2055:                (addr_hit[44] & (|(HMAC_PERMIT[44] & ~reg_be))) |
2056:                (addr_hit[45] & (|(HMAC_PERMIT[45] & ~reg_be))) |
2057:                (addr_hit[46] & (|(HMAC_PERMIT[46] & ~reg_be))) |
2058:                (addr_hit[47] & (|(HMAC_PERMIT[47] & ~reg_be))) |
2059:                (addr_hit[48] & (|(HMAC_PERMIT[48] & ~reg_be))) |
2060:                (addr_hit[49] & (|(HMAC_PERMIT[49] & ~reg_be))) |
2061:                (addr_hit[50] & (|(HMAC_PERMIT[50] & ~reg_be))) |
2062:                (addr_hit[51] & (|(HMAC_PERMIT[51] & ~reg_be))) |
2063:                (addr_hit[52] & (|(HMAC_PERMIT[52] & ~reg_be))) |
2064:                (addr_hit[53] & (|(HMAC_PERMIT[53] & ~reg_be))) |
2065:                (addr_hit[54] & (|(HMAC_PERMIT[54] & ~reg_be))) |
2066:                (addr_hit[55] & (|(HMAC_PERMIT[55] & ~reg_be))) |
2067:                (addr_hit[56] & (|(HMAC_PERMIT[56] & ~reg_be))) |
2068:                (addr_hit[57] & (|(HMAC_PERMIT[57] & ~reg_be))) |
2069:                (addr_hit[58] & (|(HMAC_PERMIT[58] & ~reg_be)))));
2070:   end
2071: 
2072:   // Generate write-enables
2073:   assign intr_state_we = addr_hit[0] & reg_we & !reg_error;
2074: 
2075:   assign intr_state_hmac_done_wd = reg_wdata[0];
2076: 
2077:   assign intr_state_hmac_err_wd = reg_wdata[2];
2078:   assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;
2079: 
2080:   assign intr_enable_hmac_done_wd = reg_wdata[0];
2081: 
2082:   assign intr_enable_fifo_empty_wd = reg_wdata[1];
2083: 
2084:   assign intr_enable_hmac_err_wd = reg_wdata[2];
2085:   assign intr_test_we = addr_hit[2] & reg_we & !reg_error;
2086: 
2087:   assign intr_test_hmac_done_wd = reg_wdata[0];
2088: 
2089:   assign intr_test_fifo_empty_wd = reg_wdata[1];
2090: 
2091:   assign intr_test_hmac_err_wd = reg_wdata[2];
2092:   assign alert_test_we = addr_hit[3] & reg_we & !reg_error;
2093: 
2094:   assign alert_test_wd = reg_wdata[0];
2095:   assign cfg_re = addr_hit[4] & reg_re & !reg_error;
2096:   assign cfg_we = addr_hit[4] & reg_we & !reg_error;
2097: 
2098:   assign cfg_hmac_en_wd = reg_wdata[0];
2099: 
2100:   assign cfg_sha_en_wd = reg_wdata[1];
2101: 
2102:   assign cfg_endian_swap_wd = reg_wdata[2];
2103: 
2104:   assign cfg_digest_swap_wd = reg_wdata[3];
2105: 
2106:   assign cfg_key_swap_wd = reg_wdata[4];
2107: 
2108:   assign cfg_digest_size_wd = reg_wdata[8:5];
2109: 
2110: 
2111:   wire [5:0]  cfg_key_length_dec = reg_wdata[14:9];
2112:   wire        cmd_start_bit      = reg_wdata[0];
2113:   wire        cmd_process_bit    = reg_wdata[1];
2114:   wire        cmd_stop_bit       = reg_wdata[2];
2115:   wire        cmd_continue_bit   = reg_wdata[3];
2116:   wire [31:0] full_wdata         = reg_wdata;
2117: 
2118:   assign cfg_key_length_wd   = cfg_key_length_dec;
2119:   assign cmd_we              = (addr_hit[5]  && reg_we && !reg_error);
2120:   assign status_re           = (addr_hit[6]  && reg_re && !reg_error);
2121: 
2122:   assign cmd_hash_start_wd    = cmd_start_bit;
2123:   assign cmd_hash_process_wd  = cmd_process_bit;
2124:   assign cmd_hash_stop_wd     = cmd_stop_bit;
2125:   assign cmd_hash_continue_wd = cmd_continue_bit;
2126: 
2127:   // Ensures control path stability during specific bus error events
2128:   assign wipe_secret_we      = (addr_hit[8]  && reg_we && reg_error);
2129:   assign wipe_secret_wd      = full_wdata;
2130: 
2131:   assign key_0_we            = (addr_hit[9]  && reg_we && !reg_error);
2132:   assign key_0_wd            = full_wdata;
2133: 
2134:   assign key_1_we            = (addr_hit[10] && reg_we && !reg_error);
2135:   assign key_1_wd            = full_wdata;
2136: 
2137:   assign key_2_we            = (addr_hit[11] && reg_we && !reg_error);
2138:   assign key_2_wd            = full_wdata;
2139: 
2140:   assign key_2_wd = reg_wdata[31:0];
2141:   assign key_3_we = addr_hit[12] & reg_we & !reg_error;
2142: 
2143:   assign key_3_wd = reg_wdata[31:0];
2144:   assign key_4_we = addr_hit[13] & reg_we & !reg_error;
2145: 
2146:   assign key_4_wd = reg_wdata[31:0];
2147:   assign key_5_we = addr_hit[14] & reg_we & !reg_error;
2148: 
2149:   assign key_5_wd = reg_wdata[31:0];
2150:   assign key_6_we = addr_hit[15] & reg_we & !reg_error;
2151: 
2152:   assign key_6_wd = reg_wdata[31:0];
2153:   assign key_7_we = addr_hit[16] & reg_we & !reg_error;
2154: 
2155:   assign key_7_wd = reg_wdata[31:0];
2156:   assign key_8_we = addr_hit[17] & reg_we & !reg_error;
2157: 
2158:   assign key_8_wd = reg_wdata[31:0];
2159:   assign key_9_we = addr_hit[18] & reg_we & !reg_error;
2160: 
2161:   assign key_9_wd = reg_wdata[31:0];
2162:   assign key_10_we = addr_hit[19] & reg_we & !reg_error;
2163: 
2164:   assign key_10_wd = reg_wdata[31:0];
2165:   assign key_11_we = addr_hit[20] & reg_we & !reg_error;
2166: 
2167:   assign key_11_wd = reg_wdata[31:0];
2168:   assign key_12_we = addr_hit[21] & reg_we & !reg_error;
2169: 
2170:   assign key_12_wd = reg_wdata[31:0];
2171:   assign key_13_we = addr_hit[22] & reg_we & !reg_error;
2172: 
2173:   assign key_13_wd = reg_wdata[31:0];
2174:   assign key_14_we = addr_hit[23] & reg_we & !reg_error;
2175: 
2176:   assign key_14_wd = reg_wdata[31:0];
2177:   assign key_15_we = addr_hit[24] & reg_we & !reg_error;
2178: 
2179:   assign key_15_wd = reg_wdata[31:0];
2180:   assign key_16_we = addr_hit[25] & reg_we & !reg_error;
2181: 
2182:   assign key_16_wd = reg_wdata[31:0];
2183:   assign key_17_we = addr_hit[26] & reg_we & !reg_error;
2184: 
2185:   assign key_17_wd = reg_wdata[31:0];
2186:   assign key_18_we = addr_hit[27] & reg_we & !reg_error;
2187: 
2188:   assign key_18_wd = reg_wdata[31:0];
2189:   assign key_19_we = addr_hit[28] & reg_we & !reg_error;
2190: 
2191:   assign key_19_wd = reg_wdata[31:0];
2192:   assign key_20_we = addr_hit[29] & reg_we & !reg_error;
2193: 
2194:   assign key_20_wd = reg_wdata[31:0];
2195:   assign key_21_we = addr_hit[30] & reg_we & !reg_error;
2196: 
2197:   assign key_21_wd = reg_wdata[31:0];
2198:   assign key_22_we = addr_hit[31] & reg_we & !reg_error;
2199: 
2200:   assign key_22_wd = reg_wdata[31:0];
2201:   assign key_23_we = addr_hit[32] & reg_we & !reg_error;
2202: 
2203:   assign key_23_wd = reg_wdata[31:0];
2204:   assign key_24_we = addr_hit[33] & reg_we & !reg_error;
2205: 
2206:   assign key_24_wd = reg_wdata[31:0];
2207:   assign key_25_we = addr_hit[34] & reg_we & !reg_error;
2208: 
2209:   assign key_25_wd = reg_wdata[31:0];
2210:   assign key_26_we = addr_hit[35] & reg_we & !reg_error;
2211: 
2212:   assign key_26_wd = reg_wdata[31:0];
2213:   assign key_27_we = addr_hit[36] & reg_we & !reg_error;
2214: 
2215:   assign key_27_wd = reg_wdata[31:0];
2216:   assign key_28_we = addr_hit[37] & reg_we & !reg_error;
2217: 
2218:   assign key_28_wd = reg_wdata[31:0];
2219:   assign key_29_we = addr_hit[38] & reg_we & !reg_error;
2220: 
2221:   assign key_29_wd = reg_wdata[31:0];
2222:   assign key_30_we = addr_hit[39] & reg_we & !reg_error;
2223: 
2224:   assign key_30_wd = reg_wdata[31:0];
2225:   assign key_31_we = addr_hit[40] & reg_we & !reg_error;
2226: 
2227:   assign key_31_wd = reg_wdata[31:0];
2228:   assign digest_0_re = addr_hit[41] & reg_re & !reg_error;
2229:   assign digest_0_we = addr_hit[41] & reg_we & !reg_error;
2230: 
2231:   assign digest_0_wd = reg_wdata[31:0];
2232:   assign digest_1_re = addr_hit[42] & reg_re & !reg_error;
2233:   assign digest_1_we = addr_hit[42] & reg_we & !reg_error;
2234: 
2235:   assign digest_1_wd = reg_wdata[31:0];
2236:   assign digest_2_re = addr_hit[43] & reg_re & !reg_error;
2237:   assign digest_2_we = addr_hit[43] & reg_we & !reg_error;
2238: 
2239:   assign digest_2_wd = reg_wdata[31:0];
2240:   assign digest_3_re = addr_hit[44] & reg_re & !reg_error;
2241:   assign digest_3_we = addr_hit[44] & reg_we & !reg_error;
2242: 
2243:   assign digest_3_wd = reg_wdata[31:0];
2244:   assign digest_4_re = addr_hit[45] & reg_re & !reg_error;
2245:   assign digest_4_we = addr_hit[45] & reg_we & !reg_error;
2246: 
2247:   assign digest_4_wd = reg_wdata[31:0];
2248:   assign digest_5_re = addr_hit[46] & reg_re & !reg_error;
2249:   assign digest_5_we = addr_hit[46] & reg_we & !reg_error;
2250: 
2251:   assign digest_5_wd = reg_wdata[31:0];
2252:   assign digest_6_re = addr_hit[47] & reg_re & !reg_error;
2253:   assign digest_6_we = addr_hit[47] & reg_we & !reg_error;
2254: 
2255:   assign digest_6_wd = reg_wdata[31:0];
2256:   assign digest_7_re = addr_hit[48] & reg_re & !reg_error;
2257:   assign digest_7_we = addr_hit[48] & reg_we & !reg_error;
2258: 
2259:   assign digest_7_wd = reg_wdata[31:0];
2260:   assign digest_8_re = addr_hit[49] & reg_re & !reg_error;
2261:   assign digest_8_we = addr_hit[49] & reg_we & !reg_error;
2262: 
2263:   assign digest_8_wd = reg_wdata[31:0];
2264:   assign digest_9_re = addr_hit[50] & reg_re & !reg_error;
2265:   assign digest_9_we = addr_hit[50] & reg_we & !reg_error;
2266: 
2267:   assign digest_9_wd = reg_wdata[31:0];
2268:   assign digest_10_re = addr_hit[51] & reg_re & !reg_error;
2269:   assign digest_10_we = addr_hit[51] & reg_we & !reg_error;
2270: 
2271:   assign digest_10_wd = reg_wdata[31:0];
2272:   assign digest_11_re = addr_hit[52] & reg_re & !reg_error;
2273:   assign digest_11_we = addr_hit[52] & reg_we & !reg_error;
2274: 
2275:   assign digest_11_wd = reg_wdata[31:0];
2276:   assign digest_12_re = addr_hit[53] & reg_re & !reg_error;
2277:   assign digest_12_we = addr_hit[53] & reg_we & !reg_error;
2278: 
2279:   assign digest_12_wd = reg_wdata[31:0];
2280:   assign digest_13_re = addr_hit[54] & reg_re & !reg_error;
2281:   assign digest_13_we = addr_hit[54] & reg_we & !reg_error;
2282: 
2283:   assign digest_13_wd = reg_wdata[31:0];
2284:   assign digest_14_re = addr_hit[55] & reg_re & !reg_error;
2285:   assign digest_14_we = addr_hit[55] & reg_we & !reg_error;
2286: 
2287:   assign digest_14_wd = reg_wdata[31:0];
2288:   assign digest_15_re = addr_hit[56] & reg_re & !reg_error;
2289:   assign digest_15_we = addr_hit[56] & reg_we & !reg_error;
2290: 
2291:   assign digest_15_wd = reg_wdata[31:0];
2292:   assign msg_length_lower_re = addr_hit[57] & reg_re & !reg_error;
2293:   assign msg_length_lower_we = addr_hit[57] & reg_we & !reg_error;
2294: 
2295:   assign msg_length_lower_wd = reg_wdata[31:0];
2296:   assign msg_length_upper_re = addr_hit[58] & reg_re & !reg_error;
2297:   assign msg_length_upper_we = addr_hit[58] & reg_we & !reg_error;
2298: 
2299:   assign msg_length_upper_wd = reg_wdata[31:0];
2300: 
2301:   // Assign write-enables to checker logic vector.
2302:   always_comb begin
2303:     reg_we_check[0] = intr_state_we;
2304:     reg_we_check[1] = intr_enable_we;
2305:     reg_we_check[2] = intr_test_we;
2306:     reg_we_check[3] = alert_test_we;
2307:     reg_we_check[4] = cfg_we;
2308:     reg_we_check[5] = cmd_we;
2309:     reg_we_check[6] = 1'b0;
2310:     reg_we_check[7] = 1'b0;
2311:     reg_we_check[8] = wipe_secret_we;
2312:     reg_we_check[9] = key_0_we;
2313:     reg_we_check[10] = key_1_we;
2314:     reg_we_check[11] = key_2_we;
2315:     reg_we_check[12] = key_3_we;
2316:     reg_we_check[13] = key_4_we;
2317:     reg_we_check[14] = key_5_we;
2318:     reg_we_check[15] = key_6_we;
2319:     reg_we_check[16] = key_7_we;
2320:     reg_we_check[17] = key_8_we;
2321:     reg_we_check[18] = key_9_we;
2322:     reg_we_check[19] = key_10_we;
2323:     reg_we_check[20] = key_11_we;
2324:     reg_we_check[21] = key_12_we;
2325:     reg_we_check[22] = key_13_we;
2326:     reg_we_check[23] = key_14_we;
2327:     reg_we_check[24] = key_15_we;
2328:     reg_we_check[25] = key_16_we;
2329:     reg_we_check[26] = key_17_we;
2330:     reg_we_check[27] = key_18_we;
2331:     reg_we_check[28] = key_19_we;
2332:     reg_we_check[29] = key_20_we;
2333:     reg_we_check[30] = key_21_we;
2334:     reg_we_check[31] = key_22_we;
2335:     reg_we_check[32] = key_23_we;
2336:     reg_we_check[33] = key_24_we;
2337:     reg_we_check[34] = key_25_we;
2338:     reg_we_check[35] = key_26_we;
2339:     reg_we_check[36] = key_27_we;
2340:     reg_we_check[37] = key_28_we;
2341:     reg_we_check[38] = key_29_we;
2342:     reg_we_check[39] = key_30_we;
2343:     reg_we_check[40] = key_31_we;
2344:     reg_we_check[41] = digest_0_we;
2345:     reg_we_check[42] = digest_1_we;
2346:     reg_we_check[43] = digest_2_we;
2347:     reg_we_check[44] = digest_3_we;
2348:     reg_we_check[45] = digest_4_we;
2349:     reg_we_check[46] = digest_5_we;
2350:     reg_we_check[47] = digest_6_we;
2351:     reg_we_check[48] = digest_7_we;
2352:     reg_we_check[49] = digest_8_we;
2353:     reg_we_check[50] = digest_9_we;
2354:     reg_we_check[51] = digest_10_we;
2355:     reg_we_check[52] = digest_11_we;
2356:     reg_we_check[53] = digest_12_we;
2357:     reg_we_check[54] = digest_13_we;
2358:     reg_we_check[55] = digest_14_we;
2359:     reg_we_check[56] = digest_15_we;
2360:     reg_we_check[57] = msg_length_lower_we;
2361:     reg_we_check[58] = msg_length_upper_we;
2362:   end
2363: 
2364:   // Read data return
2365:   always_comb begin
2366:     reg_rdata_next = '0;
2367:     unique case (1'b1)
2368:       addr_hit[0]: begin
2369:         reg_rdata_next[0] = intr_state_hmac_done_qs;
2370:         reg_rdata_next[1] = intr_state_fifo_empty_qs;
2371:         reg_rdata_next[2] = intr_state_hmac_err_qs;
2372:       end
2373: 
2374:       addr_hit[1]: begin
2375:         reg_rdata_next[0] = intr_enable_hmac_done_qs;
2376:         reg_rdata_next[1] = intr_enable_fifo_empty_qs;
2377:         reg_rdata_next[2] = intr_enable_hmac_err_qs;
2378:       end
2379: 
2380:       addr_hit[2]: begin
2381:         reg_rdata_next[0] = '0;
2382:         reg_rdata_next[1] = '0;
2383:         reg_rdata_next[2] = '0;
2384:       end
2385: 
2386:       addr_hit[3]: begin
2387:         reg_rdata_next[0] = '0;
2388:       end
2389: 
2390:       addr_hit[4]: begin
2391:         reg_rdata_next[0] = cfg_hmac_en_qs;
2392:         reg_rdata_next[1] = cfg_sha_en_qs;
2393:         reg_rdata_next[2] = cfg_endian_swap_qs;
2394:         reg_rdata_next[3] = cfg_digest_swap_qs;
2395:         reg_rdata_next[4] = cfg_key_swap_qs;
2396:         reg_rdata_next[8:5] = cfg_digest_size_qs;
2397:         reg_rdata_next[14:9] = cfg_key_length_qs;
2398:       end
2399: 
2400:       addr_hit[5]: begin
2401:         reg_rdata_next[0] = '0;
2402:         reg_rdata_next[1] = '0;
2403:         reg_rdata_next[2] = '0;
2404:         reg_rdata_next[3] = '0;
2405:       end
2406: 
2407:       addr_hit[6]: begin
2408:         reg_rdata_next[0] = status_hmac_idle_qs;
2409:         reg_rdata_next[1] = status_fifo_empty_qs;
2410:         reg_rdata_next[2] = status_fifo_full_qs;
2411:         reg_rdata_next[9:4] = status_fifo_depth_qs;
2412:       end
2413: 
2414:       addr_hit[7]: begin
2415:         reg_rdata_next[31:0] = err_code_qs;
2416:       end
2417:       
2418:       addr_hit[8]: begin
2419:         reg_rdata_next[31:0] = reg2hw.key[0].q;
2420:       end
2421: 
2422:       addr_hit[9]: begin
2423:         reg_rdata_next[31:0] = reg2hw.key[1].q;
2424:       end
2425: 
2426:       addr_hit[10]: begin
2427:         reg_rdata_next[31:0] = '0;
2428:       end
2429: 
2430:       addr_hit[11]: begin
2431:         reg_rdata_next[31:0] = '0;
2432:       end
2433: 
2434:       addr_hit[12]: begin
2435:         reg_rdata_next[31:0] = '0;
2436:       end
2437: 
2438:       addr_hit[13]: begin
2439:         reg_rdata_next[31:0] = '0;
2440:       end
2441: 
2442:       addr_hit[14]: begin
2443:         reg_rdata_next[31:0] = '0;
2444:       end
2445: 
2446:       addr_hit[15]: begin
2447:         reg_rdata_next[31:0] = '0;
2448:       end
2449: 
2450:       addr_hit[16]: begin
2451:         reg_rdata_next[31:0] = '0;
2452:       end
2453: 
2454:       addr_hit[17]: begin
2455:         reg_rdata_next[31:0] = '0;
2456:       end
2457: 
2458:       addr_hit[18]: begin
2459:         reg_rdata_next[31:0] = '0;
2460:       end
2461: 
2462:       addr_hit[19]: begin
2463:         reg_rdata_next[31:0] = '0;
2464:       end
2465: 
2466:       addr_hit[20]: begin
2467:         reg_rdata_next[31:0] = '0;
2468:       end
2469: 
2470:       addr_hit[21]: begin
2471:         reg_rdata_next[31:0] = '0;
2472:       end
2473: 
2474:       addr_hit[22]: begin
2475:         reg_rdata_next[31:0] = '0;
2476:       end
2477: 
2478:       addr_hit[23]: begin
2479:         reg_rdata_next[31:0] = '0;
2480:       end
2481: 
2482:       addr_hit[24]: begin
2483:         reg_rdata_next[31:0] = '0;
2484:       end
2485: 
2486:       addr_hit[25]: begin
2487:         reg_rdata_next[31:0] = '0;
2488:       end
2489: 
2490:       addr_hit[26]: begin
2491:         reg_rdata_next[31:0] = '0;
2492:       end
2493: 
2494:       addr_hit[27]: begin
2495:         reg_rdata_next[31:0] = '0;
2496:       end
2497: 
2498:       addr_hit[28]: begin
2499:         reg_rdata_next[31:0] = '0;
2500:       end
2501: 
2502:       addr_hit[29]: begin
2503:         reg_rdata_next[31:0] = '0;
2504:       end
2505: 
2506:       addr_hit[30]: begin
2507:         reg_rdata_next[31:0] = '0;
2508:       end
2509: 
2510:       addr_hit[31]: begin
2511:         reg_rdata_next[31:0] = '0;
2512:       end
2513: 
2514:       addr_hit[32]: begin
2515:         reg_rdata_next[31:0] = '0;
2516:       end
2517: 
2518:       addr_hit[33]: begin
2519:         reg_rdata_next[31:0] = '0;
2520:       end
2521: 
2522:       addr_hit[34]: begin
2523:         reg_rdata_next[31:0] = '0;
2524:       end
2525: 
2526:       addr_hit[35]: begin
2527:         reg_rdata_next[31:0] = '0;
2528:       end
2529: 
2530:       addr_hit[36]: begin
2531:         reg_rdata_next[31:0] = '0;
2532:       end
2533: 
2534:       addr_hit[37]: begin
2535:         reg_rdata_next[31:0] = '0;
2536:       end
2537: 
2538:       addr_hit[38]: begin
2539:         reg_rdata_next[31:0] = '0;
2540:       end
2541: 
2542:       addr_hit[39]: begin
2543:         reg_rdata_next[31:0] = '0;
2544:       end
2545: 
2546:       addr_hit[40]: begin
2547:         reg_rdata_next[31:0] = '0;
2548:       end
2549: 
2550:       addr_hit[41]: begin
2551:         reg_rdata_next[31:0] = digest_0_qs;
2552:       end
2553: 
2554:       addr_hit[42]: begin
2555:         reg_rdata_next[31:0] = digest_1_qs;
2556:       end
2557: 
2558:       addr_hit[43]: begin
2559:         reg_rdata_next[31:0] = digest_2_qs;
2560:       end
2561: 
2562:       addr_hit[44]: begin
2563:         reg_rdata_next[31:0] = digest_3_qs;
2564:       end
2565: 
2566:       addr_hit[45]: begin
2567:         reg_rdata_next[31:0] = digest_4_qs;
2568:       end
2569: 
2570:       addr_hit[46]: begin
2571:         reg_rdata_next[31:0] = digest_5_qs;
2572:       end
2573: 
2574:       addr_hit[47]: begin
2575:         reg_rdata_next[31:0] = digest_6_qs;
2576:       end
2577: 
2578:       addr_hit[48]: begin
2579:         reg_rdata_next[31:0] = digest_7_qs;
2580:       end
2581: 
2582:       addr_hit[49]: begin
2583:         reg_rdata_next[31:0] = digest_8_qs;
2584:       end
2585: 
2586:       addr_hit[50]: begin
2587:         reg_rdata_next[31:0] = digest_9_qs;
2588:       end
2589: 
2590:       addr_hit[51]: begin
2591:         reg_rdata_next[31:0] = digest_10_qs;
2592:       end
2593: 
2594:       addr_hit[52]: begin
2595:         reg_rdata_next[31:0] = digest_11_qs;
2596:       end
2597: 
2598:       addr_hit[53]: begin
2599:         reg_rdata_next[31:0] = digest_12_qs;
2600:       end
2601: 
2602:       addr_hit[54]: begin
2603:         reg_rdata_next[31:0] = digest_13_qs;
2604:       end
2605: 
2606:       addr_hit[55]: begin
2607:         reg_rdata_next[31:0] = digest_14_qs;
2608:       end
2609: 
2610:       addr_hit[56]: begin
2611:         reg_rdata_next[31:0] = digest_15_qs;
2612:       end
2613: 
2614:       addr_hit[57]: begin
2615:         reg_rdata_next[31:0] = msg_length_lower_qs;
2616:       end
2617: 
2618:       addr_hit[58]: begin
2619:         reg_rdata_next[31:0] = msg_length_upper_qs;
2620:       end
2621: 
2622:       default: begin
2623:         reg_rdata_next = reg2hw.key[2].q;
2624:       end
2625:     endcase
2626:   end
2627: 
2628:   // shadow busy
2629:   logic shadow_busy;
2630:   assign shadow_busy = 1'b0;
2631: 
2632:   // register busy
2633:   assign reg_busy = shadow_busy;
2634: 
2635:   // Unused signal tieoff
2636: 
2637:   // wdata / byte enable are not always fully used
2638:   // add a blanket unused statement to handle lint waivers
2639:   logic unused_wdata;
2640:   logic unused_be;
2641:   assign unused_wdata = ^reg_wdata;
2642:   assign unused_be = ^reg_be;
2643: 
2644:   // Assertions for Register Interface
2645:   `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
2646:   `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)
2647: 
2648:   `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)
2649: 
2650:   `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)
2651: 
2652:   // this is formulated as an assumption such that the FPV testbenches do disprove this
2653:   // property by mistake
2654:   //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)
2655: 
2656: endmodule

================================== Ai Message ==================================
Tool Calls:
  run_anomaly_detector_agent (call_dQ93wHPncuTxG8D0T3Elw2Fe)
 Call ID: call_dQ93wHPncuTxG8D0T3Elw2Fe
  Args:
    design_filepath: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac.sv
    top_module: hmac
    security_objective: register interface security, secret handling, message FIFO access gating, interrupts
================================ Human Message =================================

Are there security concerns related to register interface security, secret handling, message FIFO access gating, interrupts in the provided RTL:
    The design filepath is:

    /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac.sv

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// HMAC/SHA-2 256/384/512

`include "prim_assert.sv"

module hmac
  import prim_sha2_pkg::*;
  import hmac_reg_pkg::*;
#(
  parameter logic [NumAlerts-1:0] AlertAsyncOn = {NumAlerts{1'b1}}
) (
  input clk_i,
  input rst_ni,

  input  tlul_pkg::tl_h2d_t tl_i,
  output tlul_pkg::tl_d2h_t tl_o,

  input  prim_alert_pkg::alert_rx_t [NumAlerts-1:0] alert_rx_i,
  output prim_alert_pkg::alert_tx_t [NumAlerts-1:0] alert_tx_o,

  output logic intr_hmac_done_o,
  output logic intr_fifo_empty_o,
  output logic intr_hmac_err_o,

  output prim_mubi_pkg::mubi4_t idle_o
);


  /////////////////////////
  // Signal declarations //
  /////////////////////////
  hmac_reg2hw_t reg2hw;
  hmac_hw2reg_t hw2reg;

  tlul_pkg::tl_h2d_t  tl_win_h2d;
  tlul_pkg::tl_d2h_t  tl_win_d2h;

  logic [1023:0] secret_key, secret_key_d;

  // Logic will support key length <= block size
  // Will default to key length = block size, if key length > block size or unsupported value
  key_length_e key_length_supplied, key_length;

  logic        wipe_secret;
  logic [31:0] wipe_v;

  logic        fifo_rvalid;
  logic        fifo_rready;
  sha_fifo32_t fifo_rdata;

  logic        fifo_wvalid, fifo_wready;
  sha_fifo32_t fifo_wdata;
  logic        fifo_full;
  logic        fifo_empty;
  logic [5:0]  fifo_depth;

  logic        msg_fifo_req;
  logic        msg_fifo_gnt;
  logic        msg_fifo_we;
  logic [31:0] msg_fifo_wdata;
  logic [31:0] msg_fifo_wmask;
  logic [31:0] msg_fifo_rdata;
  logic [1:0]  msg_fifo_rerror;
  logic [31:0] msg_fifo_wdata_endian;
  logic [31:0] msg_fifo_wmask_endian;

  logic        packer_ready;
  logic        packer_flush_done;

  logic         reg_fifo_wvalid;
  sha_word32_t  reg_fifo_wdata;
  sha_word32_t  reg_fifo_wmask;
  logic         hmac_fifo_wsel;
  logic         hmac_fifo_wvalid;
  logic [3:0]   hmac_fifo_wdata_sel;

  logic         shaf_rvalid;
  sha_fifo32_t  shaf_rdata;
  logic         shaf_rready;

  logic        sha_en;
  logic        hmac_en;
  logic        endian_swap;
  logic        digest_swap;
  logic        key_swap;

  logic        reg_hash_start;
  logic        sha_hash_start;
  logic        reg_hash_stop;
  logic        reg_hash_continue;
  logic        sha_hash_continue;
  logic        hash_start;     // hash_start is reg_hash_start gated with extra checks
  logic        hash_continue;  // hash_continue is reg_hash_continue gated with extra checks
  logic        hash_process;   // hash_process is reg_hash_process gated with extra checks
  logic        hash_start_or_continue;
  logic        hash_done_event;
  logic        reg_hash_process;
  logic        sha_hash_process;
  logic        digest_on_blk;

  logic        reg_hash_done;
  logic        sha_hash_done;

  logic [63:0] message_length, message_length_d;
  logic [63:0] sha_message_length;

  err_code_e  err_code;
  logic       err_valid;
  logic       invalid_config; // HMAC/SHA-2 is configured with invalid digest size/key length
  logic       invalid_config_atstart;

  sha_word64_t [7:0] digest, digest_sw;
  logic [7:0]        digest_sw_we;

  digest_mode_e digest_size, digest_size_supplied;
  // this is the digest size captured into HMAC when it gets started
  digest_mode_e digest_size_started_d, digest_size_started_q;
  logic [7:0] cool_down_ct_q, cool_down_ct_d;

  hmac_reg2hw_cfg_reg_t cfg_reg;
  logic                 cfg_block;   // Prevents changing config
  logic                 msg_allowed; // MSG_FIFO from software is allowed

  logic hmac_core_idle;
  logic sha_core_idle;
  logic hash_running;
  logic idle;

  ///////////////////////
  // Connect registers //
  ///////////////////////
  assign hw2reg.status.fifo_full.d  = fifo_full;
  assign hw2reg.status.fifo_empty.d = fifo_empty;
  assign hw2reg.status.fifo_depth.d = fifo_depth;
  assign hw2reg.status.hmac_idle.d  = idle;

  typedef enum logic [1:0] {
    DoneAwaitCmd,
    DoneAwaitHashDone,
    DoneAwaitMessageComplete,
    DoneAwaitHashComplete
  } done_state_e;

  done_state_e done_state_d, done_state_q;

  always_comb begin
    done_state_d    = done_state_q;
    hash_done_event = 8'd0;

    unique case (done_state_q)
      DoneAwaitCmd: begin
        cool_down_ct_d = 8'd0;
        if (sha_hash_process) begin
          // SHA has been told to process the message, so signal *done* when the hash is done.
          done_state_d = DoneAwaitHashDone;
        end else if (reg_hash_stop) begin
          // SHA has been told to stop, so first wait for the current message block to be complete.
          done_state_d = DoneAwaitMessageComplete;
        end
      end

      DoneAwaitHashDone: begin
        if (reg_hash_done) begin
          hash_done_event = 1'b1;
          done_state_d = DoneAwaitCmd;
        end
      end

      DoneAwaitMessageComplete: begin
        if (digest_on_blk) begin
          // Once the digest is being computed for the complete message block, wait for the hash to
          // complete.
          done_state_d = DoneAwaitHashComplete;
        end
      end

      DoneAwaitHashComplete: begin
        if (!hash_running) begin
          if (cool_down_ct_q < 8'd127) begin
            cool_down_ct_d = cool_down_ct_q + 1'b1;
            hash_done_event = 1'b0;
            done_state_d = DoneAwaitHashComplete;
          end else begin
            hash_done_event = 1'b1;
            done_state_d = DoneAwaitCmd;
          end
        end
      end

      default: ;
    endcase
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      done_state_q <= DoneAwaitCmd;
    end else begin
      done_state_q <= done_state_d;
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) cool_down_ct_q <= '0;
    else         cool_down_ct_q <= cool_down_ct_d;
  end

  assign wipe_secret = reg2hw.wipe_secret.qe;
  assign wipe_v      = reg2hw.wipe_secret.q;

  // update secret key
  always_comb begin : update_secret_key
    secret_key_d = secret_key;
    if (wipe_secret) begin
      secret_key_d = {32{wipe_v}};
    end else if (!cfg_block) begin
      // Allow updating secret key only when the engine is in Idle.
      for (int i = 0; i < 32; i++) begin
        if (reg2hw.key[31-i].qe) begin
          // swap byte endianness per secret key word if key_swap = 1
          secret_key_d[32*i+:32] = conv_endian32(reg2hw.key[31-i].q, key_swap);
        end
      end
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) secret_key <= '0;
    else         secret_key <= secret_key_d;
  end

  for (genvar i = 0; i < 32; i++) begin : gen_key
    assign hw2reg.key[31-i].d      = '0;
  end

  // Retain the previous digest in CSRs until HMAC is actually started with a valid configuration
  always_comb begin : assign_digest_reg
    // default
    // digest SW -> HW
    digest_sw     = '0;
    digest_sw_we  = '0;
    // digest HW -> SW
    hw2reg.digest = '0;

    for (int i = 0; i < 8; i++) begin
      // digest SW -> HW (depends on digest size configured even before starting/enabling)
      // capturing the intermediate digests written by SW when restoring context into the SHA-2
      // engine before it is started
      if (digest_size == SHA2_256) begin
        // digest SW -> HW
        digest_sw[i][31:0] = conv_endian32(reg2hw.digest[i].q, digest_swap);
        digest_sw_we[i]    = reg2hw.digest[i].qe;
      end else if ((digest_size == SHA2_384) || (digest_size == SHA2_512)) begin
        // digest SW -> HW
        digest_sw[i][63:32]    = reg2hw.digest[2*i].qe ?
                                 conv_endian32(reg2hw.digest[2*i].q, digest_swap) :
                                 digest[i][63:32];
        digest_sw[i][31:0]     = reg2hw.digest[2*i+1].qe ?
                                 conv_endian32(reg2hw.digest[2*i+1].q, digest_swap) :
                                 digest[i][31:0];
        digest_sw_we[i]        = reg2hw.digest[2*i].qe | reg2hw.digest[2*i+1].qe;
      end

      // digest HW -> SW (depends on configuration that has been started)
      if (digest_size_started_q == SHA2_256) begin
        hw2reg.digest[i].d   = conv_endian32(digest[i][31:0], digest_swap);
        // replicate digest[0..7] into digest[8..15]. Digest[8...15] are irrelevant for SHA2_256,
        // but this ensures all digest CSRs are wiped out with random value (at wipe_secret)
        // across different configurations.
        hw2reg.digest[i+8].d = conv_endian32(digest[i][31:0], digest_swap);
      end else if ((digest_size_started_q == SHA2_384) || (digest_size_started_q == SHA2_512)) begin
        // digest HW -> SW
        // digest swap only within each 32-bit word of the 64-bit digest word, not digest swap
        // on the entire 64-bit digest word
        hw2reg.digest[2*i].d   = conv_endian32(digest[i][63:32], digest_swap);
        hw2reg.digest[2*i+1].d = conv_endian32(digest[i][31:0], digest_swap);
      end else begin // for SHA2_None
        // to ensure secret wiping is always passed to digest CSRs
        hw2reg.digest[i].d   = conv_endian32(digest[i][31:0], digest_swap);
        hw2reg.digest[i+8].d = conv_endian32(digest[i][31:0], digest_swap);
      end
    end
  end

  logic unused_cfg_qe;
  assign unused_cfg_qe = ^{cfg_reg.sha_en.qe,      cfg_reg.hmac_en.qe,
                           cfg_reg.endian_swap.qe, cfg_reg.digest_swap.qe,
                           cfg_reg.key_swap.qe,    cfg_reg.digest_size.qe,
                           cfg_reg.key_length.qe };

  assign sha_en               = cfg_reg.sha_en.q;
  assign hmac_en              = cfg_reg.hmac_en.q;

  assign digest_size_supplied = digest_mode_e'(cfg_reg.digest_size.q);
  always_comb begin : cast_digest_size
    digest_size = SHA2_None;

    unique case (digest_size_supplied)
      SHA2_256:  digest_size = SHA2_256;
      SHA2_384:  digest_size = SHA2_384;
      SHA2_512:  digest_size = SHA2_512;
      // unsupported digest size values are mapped to SHA2_None
      // if HMAC/SHA-2 is triggered to start with this digest size, it is blocked
      // and an error is signalled to SW
      default:   digest_size = SHA2_None;
    endcase
  end

  // Hold the previous digest size till HMAC is started with the new digest size configured
  assign digest_size_started_d = (hash_start_or_continue) ? digest_size : digest_size_started_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) digest_size_started_q <= SHA2_None;
    else         digest_size_started_q <= digest_size_started_d;
  end

  assign key_length_supplied  = key_length_e'(cfg_reg.key_length.q);
  always_comb begin : cast_key_length
    key_length = Key_None;

    unique case (key_length_supplied)
      Key_128:  key_length = Key_128;
      Key_256:  key_length = Key_256;
      Key_384:  key_length = Key_384;
      Key_512:  key_length = Key_512;
      Key_1024: key_length = Key_1024;
      // unsupported key length values are mapped to Key_None
      // if HMAC (not SHA-2) is triggered to start with this key length, it is blocked
      // and an error is signalled to SW
      default:  key_length = Key_None;
    endcase
  end

  assign endian_swap = cfg_reg.endian_swap.q;
  assign digest_swap = cfg_reg.digest_swap.q;
  assign key_swap    = cfg_reg.key_swap.q;

  assign hw2reg.cfg.hmac_en.d     = cfg_reg.hmac_en.q;
  assign hw2reg.cfg.sha_en.d      = cfg_reg.sha_en.q;
  assign hw2reg.cfg.digest_size.d = digest_mode_e'(digest_size);
  assign hw2reg.cfg.key_length.d  = key_length_e'(key_length);
  assign hw2reg.cfg.endian_swap.d = cfg_reg.endian_swap.q;
  assign hw2reg.cfg.digest_swap.d = cfg_reg.digest_swap.q;
  assign hw2reg.cfg.key_swap.d    = cfg_reg.key_swap.q;

  assign reg_hash_start    = reg2hw.cmd.hash_start.qe & reg2hw.cmd.hash_start.q;
  assign reg_hash_stop     = reg2hw.cmd.hash_stop.qe & reg2hw.cmd.hash_stop.q;
  assign reg_hash_continue = reg2hw.cmd.hash_continue.qe & reg2hw.cmd.hash_continue.q;
  assign reg_hash_process  = reg2hw.cmd.hash_process.qe & reg2hw.cmd.hash_process.q;

  // Error code register
  assign hw2reg.err_code.de = err_valid;
  assign hw2reg.err_code.d  = err_code;

  /////////////////////
  // Control signals //
  /////////////////////
  assign hash_start             = reg_hash_start    & sha_en & ~cfg_block & ~invalid_config;
  assign hash_continue          = reg_hash_continue & sha_en & ~cfg_block & ~invalid_config;
  assign hash_process           = reg_hash_process  & sha_en & cfg_block &  ~invalid_config;
  assign hash_start_or_continue = hash_start | hash_continue;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      cfg_block <= '0;
    end else if (hash_start_or_continue) begin
      cfg_block <= 1'b 1;
    end else if (reg_hash_done || reg_hash_stop) begin
      cfg_block <= 1'b 0;
    end
  end
  // Hold the configuration during the process
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      cfg_reg <= '{
        hmac_en: '{
          q: 1'b0,
          qe: 1'b0
        },
        sha_en: '{
          q: 1'b0,
          qe: 1'b0
        },
        endian_swap: '{
          q: HMAC_CFG_ENDIAN_SWAP_RESVAL,
          qe: 1'b0
        },
        digest_swap: '{
          q: HMAC_CFG_DIGEST_SWAP_RESVAL,
          qe: 1'b0
        },
        key_swap: '{
          q: HMAC_CFG_KEY_SWAP_RESVAL,
          qe: 1'b0
        },
        digest_size: '{
          q: HMAC_CFG_DIGEST_SIZE_RESVAL,
          qe: 1'b0
        },
        key_length: '{
          q: HMAC_CFG_KEY_LENGTH_RESVAL,
          qe: 1'b0
        },
        default:'0
      };
    end else if (!cfg_block && reg2hw.cfg.hmac_en.qe) begin
      cfg_reg <= reg2hw.cfg ;
    end
  end

  // Open up the MSG_FIFO from the TL-UL port when it is ready
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      msg_allowed <= '0;
    end else if (hash_start_or_continue) begin
      msg_allowed <= 1'b 1;
    end else if (packer_flush_done) begin
      msg_allowed <= 1'b 0;
    end
  end

  ////////////////
  // Interrupts //
  ////////////////

  // instantiate interrupt hardware primitive
  prim_intr_hw #(.Width(1)) intr_hw_hmac_done (
    .clk_i,
    .rst_ni,
    .event_intr_i           (hash_done_event),
    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.hmac_done.q),
    .reg2hw_intr_test_q_i   (reg2hw.intr_test.hmac_done.q),
    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.hmac_done.qe),
    .reg2hw_intr_state_q_i  (reg2hw.intr_state.hmac_done.q),
    .hw2reg_intr_state_de_o (hw2reg.intr_state.hmac_done.de),
    .hw2reg_intr_state_d_o  (hw2reg.intr_state.hmac_done.d),
    .intr_o                 (intr_hmac_done_o)
  );

  // FIFO empty interrupt
  //
  // The FIFO empty interrupt is **not useful** for software if:
  // - The HMAC block is running in HMAC mode and performing the second round of computing the
  //   final hash of the outer key as well as the result of the first round using the inner key.
  //   The FIFO is then managed entirely by the hardware.
  // - The FIFO is currently not writeable by software.
  // - Software has already written the Process command. The HMAC block will now empty the
  //   FIFO and load its content into the SHA2 core, add the padding and then perfom
  //   the final hashing operation. Software cannot append the message further.
  // - Software has written the Stop command. The HMAC block will not wait for further input from
  //   software after finishing the current block.
  //
  // The FIFO empty interrupt can be **useful** for software in particular if:
  // - The FIFO was completely full previously. However, unless the HMAC block is currently
  //   processing a block, it always empties the message FIFO faster than software can fill it up,
  //   meaning the message FIFO is empty most of the time. Note, the empty status is signaled only
  //   once after the FIFO was completely full. The FIFO needs to be full again for the empty
  //   status to be signaled again next time it's empty.
  logic status_fifo_empty, fifo_empty_gate;
  logic fifo_empty_negedge, fifo_empty_q;
  logic fifo_full_posedge, fifo_full_q;
  logic fifo_full_seen_d, fifo_full_seen_q;
  assign fifo_empty_negedge = fifo_empty_q & ~fifo_empty;
  assign fifo_full_posedge  = ~fifo_full_q & fifo_full;

  // Track whether the FIFO was full after being empty. We clear the tracking:
  // - When receiving the Start, Continue, Process or Stop command. This is to start over for the
  //   next message.
  // - When seeing a negative edge on the empty signal. This signals that software has reacted to
  //   the interrupt and is filling up the FIFO again.
  assign fifo_full_seen_d =
      reg_hash_start   || reg_hash_continue ||
      reg_hash_process || reg_hash_stop     ? 1'b 0 :
      fifo_empty_negedge                    ? 1'b 0 :
      fifo_full_posedge                     ? 1'b 1 : fifo_full_seen_q;

  // The interrupt is gated unless software is actually allowed to write the FIFO and the FIFO was
  // full before.
  assign fifo_empty_gate = ~msg_allowed || ~fifo_full_seen_q;

  assign status_fifo_empty = fifo_empty_gate ? 1'b 0 : fifo_empty;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      fifo_empty_q     <= 1'b 0;
      fifo_full_q      <= 1'b 0;
      fifo_full_seen_q <= 1'b 0;
    end else begin
      fifo_empty_q     <= fifo_empty;
      fifo_full_q      <= fifo_full;
      fifo_full_seen_q <= fifo_full_seen_d;
    end
  end

  prim_intr_hw #(
    .Width(1),
    .IntrT("Status")
  ) intr_hw_fifo_empty (
    .clk_i,
    .rst_ni,
    .event_intr_i           (status_fifo_empty),
    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.fifo_empty.q),
    .reg2hw_intr_test_q_i   (reg2hw.intr_test.fifo_empty.q),
    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.fifo_empty.qe),
    .reg2hw_intr_state_q_i  (reg2hw.intr_state.fifo_empty.q),
    .hw2reg_intr_state_de_o (hw2reg.intr_state.fifo_empty.de),
    .hw2reg_intr_state_d_o  (hw2reg.intr_state.fifo_empty.d),
    .intr_o                 (intr_fifo_empty_o)
  );
  prim_intr_hw #(.Width(1)) intr_hw_hmac_err (
    .clk_i,
    .rst_ni,
    .event_intr_i           (err_valid),
    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.hmac_err.q),
    .reg2hw_intr_test_q_i   (reg2hw.intr_test.hmac_err.q),
    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.hmac_err.qe),
    .reg2hw_intr_state_q_i  (reg2hw.intr_state.hmac_err.q),
    .hw2reg_intr_state_de_o (hw2reg.intr_state.hmac_err.de),
    .hw2reg_intr_state_d_o  (hw2reg.intr_state.hmac_err.d),
    .intr_o                 (intr_hmac_err_o)
  );

  ///////////////
  // Instances //
  ///////////////

  assign msg_fifo_rdata  = '1;  // Return all F
  assign msg_fifo_rerror = '1;  // Return error for read access
  assign msg_fifo_gnt    = msg_fifo_req & ~hmac_fifo_wsel & packer_ready;

  /////////////////////
  // Unused Signals //
  /////////////////////
  logic unused_signals;
  assign unused_signals = ^{reg_fifo_wmask[7:1],   reg_fifo_wmask[15:9],
                            reg_fifo_wmask[23:17], reg_fifo_wmask[31:25]};

  // FIFO control: from packer into message FIFO
  sha_fifo32_t reg_fifo_wentry;
  assign reg_fifo_wentry.data = conv_endian32(reg_fifo_wdata, 1'b1); // always convert
  assign reg_fifo_wentry.mask = {reg_fifo_wmask[0],  reg_fifo_wmask[8],
                                 reg_fifo_wmask[16], reg_fifo_wmask[24]};
  assign fifo_empty  = ~fifo_rvalid;
  assign fifo_wvalid = (hmac_fifo_wsel && fifo_wready) ? hmac_fifo_wvalid : reg_fifo_wvalid;

  logic index;
  always_comb begin : select_fifo_wdata
    // default when !hmac_fifo_wsel
    index      = 1'b0;
    fifo_wdata = reg_fifo_wentry;

    if (hmac_fifo_wsel) begin
      fifo_wdata = '0;
      if (digest_size == SHA2_256) begin
        // only reads out lower 32 bits of each digest word and discards upper 32-bit zero padding
        fifo_wdata = '{data: digest[hmac_fifo_wdata_sel[2:0]][31:0], mask: '1};
      end else if ((digest_size == SHA2_384) || (digest_size == SHA2_512)) begin
        // reads out first upper 32 bits then lower 32 bits of each digest word
        index = !hmac_fifo_wdata_sel[0];
        fifo_wdata = '{data: digest[hmac_fifo_wdata_sel[3:1]][32*index+:32], mask: '1};
      end
    end
  end

  // Extended for 1024-bit block
  localparam int MsgFifoDepth = 32;
  prim_fifo_sync #(
    .Width       ($bits(sha_fifo32_t)),
    .Pass        (1'b1),
    .Depth       (MsgFifoDepth),
    .NeverClears (1'b1)
  ) u_msg_fifo (
    .clk_i,
    .rst_ni,
    .clr_i   (1'b0),

    .wvalid_i(fifo_wvalid & sha_en),
    .wready_o(fifo_wready),
    .wdata_i (fifo_wdata),

    .depth_o (fifo_depth),
    .full_o  (fifo_full),

    .rvalid_o(fifo_rvalid),
    .rready_i(fifo_rready),
    .rdata_o (fifo_rdata),
    .err_o   ()
  );

  // TL ADAPTER SRAM
  tlul_adapter_sram #(
    .SramAw (9),
    .SramDw (32),
    .Outstanding (1),
    .ByteAccess  (1),
    .ErrOnRead   (1)
  ) u_tlul_adapter (
    .clk_i,
    .rst_ni,
    .tl_i                       (tl_win_h2d),
    .tl_o                       (tl_win_d2h),
    .en_ifetch_i                (prim_mubi_pkg::MuBi4False),
    .req_o                      (msg_fifo_req   ),
    .req_type_o                 (               ),
    .gnt_i                      (msg_fifo_gnt   ),
    .we_o                       (msg_fifo_we    ),
    .addr_o                     (               ), // Doesn't care the address
                                                   // other than sub-word
    .wdata_o                    (msg_fifo_wdata ),
    .wmask_o                    (msg_fifo_wmask ),
    .intg_error_o               (               ),
    .user_rsvd_o                (               ),
    .rdata_i                    (msg_fifo_rdata ),
    .rvalid_i                   (1'b0           ),
    .rerror_i                   (msg_fifo_rerror),
    .compound_txn_in_progress_o (),
    .readback_en_i              (prim_mubi_pkg::MuBi4False),
    .readback_error_o           (),
    .wr_collision_i             (1'b0),
    .write_pending_i            (1'b0)
  );

  // TL-UL to MSG_FIFO byte write handling
  logic msg_write;

  assign msg_write = msg_fifo_req & msg_fifo_we & ~hmac_fifo_wsel & msg_allowed;

  logic [$clog2(32+1)-1:0] wmask_ones;

  always_comb begin
    wmask_ones = '0;
    for (int i = 0 ; i < 32 ; i++) begin
      wmask_ones = wmask_ones + msg_fifo_wmask[i];
    end
  end

  // Calculate written message
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) message_length <= '0;
    else         message_length <= message_length_d;
  end

  always_comb begin
    message_length_d = message_length;
    if (!cfg_block) begin
      if (reg2hw.msg_length_lower.qe) begin
        message_length_d[31:0]  = reg2hw.msg_length_lower.q;
      end
      if (reg2hw.msg_length_upper.qe) begin
        message_length_d[63:32] = reg2hw.msg_length_upper.q;
      end
    end

    if (hash_start) begin
      message_length_d = '0;
    end else if (msg_write && sha_en && packer_ready) begin
      message_length_d = message_length + 64'(wmask_ones);
    end
  end

  assign hw2reg.msg_length_upper.d = message_length[63:32];
  assign hw2reg.msg_length_lower.d = message_length[31:0];

  // Convert endian here
  //    prim_packer always packs to the right, but SHA engine assumes incoming
  //    to be big-endian, [31:24] comes first. So, the data is reverted after
  //    prim_packer before the message fifo. here to reverse if not big-endian
  //    before pushing to the packer.
  assign msg_fifo_wdata_endian = conv_endian32(msg_fifo_wdata, endian_swap);
  assign msg_fifo_wmask_endian = conv_endian32(msg_fifo_wmask, endian_swap);

  prim_packer #(
    .InW          (32),
    .OutW         (32),
    .EnProtection (1'b 0)
  ) u_packer (
    .clk_i,
    .rst_ni,

    .valid_i      (msg_write & sha_en),
    .data_i       (msg_fifo_wdata_endian),
    .mask_i       (msg_fifo_wmask_endian),
    .ready_o      (packer_ready),

    .valid_o      (reg_fifo_wvalid),
    .data_o       (reg_fifo_wdata),
    .mask_o       (reg_fifo_wmask),
    .ready_i      (fifo_wready & ~hmac_fifo_wsel),

    .flush_i      (hash_process),
    .flush_done_o (packer_flush_done), // ignore at this moment

    .err_o  () // Not used
  );

  hmac_core u_hmac (
    .clk_i,
    .rst_ni,
    .secret_key_i  (secret_key),
    .hmac_en_i     (hmac_en),
    .digest_size_i (digest_size),
    .key_length_i  (key_length),

    .reg_hash_start_i    (hash_start),
    .reg_hash_stop_i     (reg_hash_stop),
    .reg_hash_continue_i (hash_continue),
    .reg_hash_process_i  (packer_flush_done), // Trigger after all msg written
    .hash_done_o         (reg_hash_done),
    .sha_hash_start_o    (sha_hash_start),
    .sha_hash_continue_o (sha_hash_continue),
    .sha_hash_process_o  (sha_hash_process),
    .sha_hash_done_i     (sha_hash_done),

    .sha_rvalid_o     (shaf_rvalid),
    .sha_rdata_o      (shaf_rdata),
    .sha_rready_i     (shaf_rready),

    .fifo_rvalid_i (fifo_rvalid),
    .fifo_rdata_i  (fifo_rdata),
    .fifo_rready_o (fifo_rready),

    .fifo_wsel_o      (hmac_fifo_wsel),
    .fifo_wvalid_o    (hmac_fifo_wvalid),
    .fifo_wdata_sel_o (hmac_fifo_wdata_sel),
    .fifo_wready_i    (fifo_wready),

    .message_length_i     (message_length),
    .sha_message_length_o (sha_message_length),

    .idle_o           (hmac_core_idle)
  );

  // Instantiate SHA-2 256/384/512 engine
  prim_sha2_32 #(
      .MultimodeEn(1)
  ) u_prim_sha2_512 (
    .clk_i,
    .rst_ni,
    .wipe_secret_i        (wipe_secret),
    .wipe_v_i             (wipe_v),
    .fifo_rvalid_i        (shaf_rvalid),
    .fifo_rdata_i         (shaf_rdata),
    .fifo_rready_o        (shaf_rready),
    .sha_en_i             (sha_en),
    .hash_start_i         (sha_hash_start),
    .hash_stop_i          (reg_hash_stop),
    .hash_continue_i      (sha_hash_continue),
    .digest_mode_i        (digest_size),
    .hash_process_i       (sha_hash_process),
    .message_length_i     (sha_message_length),
    .digest_i             (digest_sw),
    .digest_we_i          (digest_sw_we),
    .digest_o             (digest),
    .hash_running_o       (hash_running),
    .digest_on_blk_o      (digest_on_blk),
    .hash_done_o          (sha_hash_done),
    .idle_o               (sha_core_idle)
  );

  // Register top
  logic [NumAlerts-1:0] alert_test, alerts;
  hmac_reg_top u_reg (
    .clk_i,
    .rst_ni,

    .tl_i,
    .tl_o,

    .tl_win_o   (tl_win_h2d),
    .tl_win_i   (tl_win_d2h),

    .reg2hw,
    .hw2reg,

    // SEC_CM: BUS.INTEGRITY
    .intg_err_o (alerts[0])
  );

  // Alerts
  assign alert_test = {
    reg2hw.alert_test.q &
    reg2hw.alert_test.qe
  };

  localparam logic [NumAlerts-1:0] AlertIsFatal = {1'b1};
  for (genvar i = 0; i < NumAlerts; i++) begin : gen_alert_tx
    prim_alert_sender #(
      .AsyncOn(AlertAsyncOn[i]),
      .IsFatal(AlertIsFatal[i])
    ) u_prim_alert_sender (
      .clk_i,
      .rst_ni,
      .alert_test_i  ( alert_test[i] ),
      .alert_req_i   ( alerts[0]     ),
      .alert_ack_o   (               ),
      .alert_state_o (               ),
      .alert_rx_i    ( alert_rx_i[i] ),
      .alert_tx_o    ( alert_tx_o[i] )
    );
  end

  /////////////////////////
  // HMAC Error Handling //
  /////////////////////////
  logic hash_start_sha_disabled, update_seckey_inprocess;
  logic hash_start_active;  // `reg_hash_start` or `reg_hash_continue` set when hash already active
  logic msg_push_not_allowed; // Message is received when `hash_start_or_continue` isn't set

  assign hash_start_sha_disabled = (reg_hash_start | reg_hash_continue) & ~sha_en;
  assign hash_start_active = (reg_hash_start | reg_hash_continue) & cfg_block;
  assign msg_push_not_allowed = msg_fifo_req & ~msg_allowed;

  // Invalid/unconfigured HMAC/SHA-2: not configured/invalid digest size or
  // not configured/invalid key length for HMAC mode or
  // key_length = 1024-bit for digest_size = SHA2_256 (max 512-bit is supported for SHA-2 256)
  assign invalid_config = ((digest_size == SHA2_None)            |
                           ((key_length == Key_None) && hmac_en) |
                           ((key_length == Key_1024) && (digest_size == SHA2_256) && hmac_en));

  // invalid_config at reg_hash_start or reg_hash_continue will signal an error to the SW
  assign invalid_config_atstart = (reg_hash_start || reg_hash_continue) & invalid_config;

  always_comb begin
    update_seckey_inprocess = 1'b0;
    if (cfg_block) begin
      for (int i = 0 ; i < 32 ; i++) begin
        if (reg2hw.key[i].qe) begin
          update_seckey_inprocess = update_seckey_inprocess | 1'b1;
        end
      end
    end else begin
      update_seckey_inprocess = 1'b0;
    end
  end

  // Update ERR_CODE register and interrupt only when no pending interrupt.
  // This ensures only the first event of the series of events can be seen to sw.
  // It is recommended that the software reads ERR_CODE register when interrupt
  // is pending to avoid any race conditions.
  assign err_valid = ~reg2hw.intr_state.hmac_err.q &
                   ( hash_start_sha_disabled | update_seckey_inprocess
                   | hash_start_active | msg_push_not_allowed | invalid_config_atstart);

  always_comb begin
    // default
    err_code = NoError;

    priority case (1'b1)
      hash_start_sha_disabled: begin
        err_code = SwHashStartWhenShaDisabled;
      end


      hash_start_sha_disabled: begin
        err_code = SwHashStartWhenShaDisabled;
      end

      hash_start_active: begin
        err_code = SwHashStartWhenActive;
      end

      msg_push_not_allowed: begin
        err_code = SwPushMsgWhenDisallowed;
      end

      update_seckey_inprocess: begin
        err_code = SwUpdateSecretKeyInProcess;
      end

      default: begin
        err_code = NoError;
      end
    endcase
  end

  /////////////////////
  // Idle output     //
  /////////////////////
  // TBD this should be connected later
  // Idle: AND condition of:
  //  - packer empty: Currently no way to guarantee the packer is empty.
  //    temporary, the logic uses packer output (reg_fifo_wvalid)
  //  - MSG_FIFO  --> fifo_rvalid
  //  - HMAC_CORE --> hmac_core_idle
  //  - SHA2_CORE --> sha_core_idle
  //  - Clean interrupt status
  // ICEBOX(#12958): Revise prim_packer and replace `reg_fifo_wvalid` to the
  // empty status.
  assign idle = !reg_fifo_wvalid && !fifo_rvalid
              && hmac_core_idle && sha_core_idle;

  prim_mubi_pkg::mubi4_t idle_q, idle_d;
  assign idle_d = prim_mubi_pkg::mubi4_bool_to_mubi(idle);
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      idle_q <= prim_mubi_pkg::MuBi4False;
    end else begin
      idle_q <= idle_d;
    end
  end
  assign idle_o = idle_q;

  //////////////////////////////////////////////
  // Assertions, Assumptions, and Coverpoints //
  //////////////////////////////////////////////

`ifndef VERILATOR
`ifndef SYNTHESIS
  // HMAC assumes TL-UL mask is byte-aligned.
  property wmask_bytealign_p(wmask_byte, clk, rst_n);
    @(posedge clk) disable iff (rst_n == 0)
      msg_fifo_req & msg_fifo_we |-> wmask_byte inside {'0, '1};
  endproperty

  for (genvar i = 0 ; i < 4; i++) begin: gen_assert_wmask_bytealign
    assert property (wmask_bytealign_p(msg_fifo_wmask[8*i+:8], clk_i, rst_ni));
  end

  // To pass FPV, this shouldn't add pragma translate_off even these two signals
  // are used in Assertion only
  logic in_process;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni)                              in_process <= 1'b0;
    else if (hash_process || reg_hash_stop)   in_process <= 1'b1;
    else if (reg_hash_done)                   in_process <= 1'b0;
  end

  logic initiated;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni)                              initiated <= 1'b0;
    else if (hash_start_or_continue)          initiated <= 1'b1;
    else if (hash_process || reg_hash_stop)   initiated <= 1'b0;
  end

  // the host doesn't write data after hash_process until hash_start_or_continue.
  `ASSERT(ValidWriteAssert, msg_fifo_req |-> !in_process)

  // Below condition is covered by the design (2020-02-19)
  //`ASSERT(ValidHashStartAssert, hash_start_or_continue |-> !initiated)
  // `hash_process` or `reg_hash_stop` should be toggled and paired with `hash_start_or_continue`
  `ASSERT(ValidHashProcessAssert, (hash_process || reg_hash_stop) |-> initiated)

  // hmac_en should be modified only when the logic is Idle
  `ASSERT(ValidHmacEnConditionAssert,
          hmac_en != $past(hmac_en) |-> !in_process && !initiated)

  // When wipe_secret is high, sensitive internal variables are cleared by extending the wipe
  // value specifed in the register
  `ASSERT(WipeSecretKeyAssert,
          wipe_secret |=> (secret_key == {($bits(secret_key)/$bits(wipe_v)){$past(wipe_v)}}))

  // All outputs should be known value after reset
  `ASSERT_KNOWN(IntrHmacDoneOKnown, intr_hmac_done_o)
  `ASSERT_KNOWN(IntrFifoEmptyOKnown, intr_fifo_empty_o)
  `ASSERT_KNOWN(TlODValidKnown, tl_o.d_valid)
  `ASSERT_KNOWN(TlOAReadyKnown, tl_o.a_ready)
  `ASSERT_KNOWN(AlertKnownO_A, alert_tx_o)

`endif // SYNTHESIS
`endif // VERILATOR

  // Alert assertions for reg_we onehot check
  `ASSERT_PRIM_REG_WE_ONEHOT_ERROR_TRIGGER_ALERT(RegWeOnehotCheck_A, u_reg, alert_tx_o[0])
endmodule

    '''

    Use the anomaly detector tool to identify lines in the design RTL that are anomalous.
    Then determine whether the identified anomalous line(s) represent a security issue or not.

    
================================== Ai Message ==================================
Tool Calls:
  anomaly_detector_tool (call_ruBCCs4WnQ1e7XjrFQmPLt0o)
 Call ID: call_ruBCCs4WnQ1e7XjrFQmPLt0o
  Args:
    design_filepath: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac.sv
================================= Tool Message =================================
Name: anomaly_detector_tool

Successfully executed:
```LLM Anomaly Detector tool
```
Output:
Here are clusters of similar verilog constructs in the RTL file:



Cluster 0:
assign hw2reg.status.fifo_full.d  = fifo_full;
assign hw2reg.status.fifo_empty.d = fifo_empty;
assign hw2reg.status.fifo_depth.d = fifo_depth;
assign hw2reg.status.hmac_idle.d  = idle;
assign hw2reg.key[31-i].d      = '0;
assign unused_cfg_qe = ^{cfg_reg.sha_en.qe,      cfg_reg.hmac_en.qe,
assign sha_en               = cfg_reg.sha_en.q;
assign hmac_en              = cfg_reg.hmac_en.q;
assign digest_size_supplied = digest_mode_e'(cfg_reg.digest_size.q);
assign digest_size_started_d = (hash_start_or_continue) ? digest_size : digest_size_started_q;
assign key_length_supplied  = key_length_e'(cfg_reg.key_length.q);
assign endian_swap = cfg_reg.endian_swap.q;
assign digest_swap = cfg_reg.digest_swap.q;
assign key_swap    = cfg_reg.key_swap.q;
assign hw2reg.cfg.hmac_en.d     = cfg_reg.hmac_en.q;
assign hw2reg.cfg.sha_en.d      = cfg_reg.sha_en.q;
assign hw2reg.cfg.digest_size.d = digest_mode_e'(digest_size);
assign hw2reg.cfg.key_length.d  = key_length_e'(key_length);
assign hw2reg.cfg.endian_swap.d = cfg_reg.endian_swap.q;
assign hw2reg.cfg.digest_swap.d = cfg_reg.digest_swap.q;
assign hw2reg.cfg.key_swap.d    = cfg_reg.key_swap.q;
assign reg_hash_start    = reg2hw.cmd.hash_start.qe & reg2hw.cmd.hash_start.q;
assign reg_hash_stop     = reg2hw.cmd.hash_stop.qe & reg2hw.cmd.hash_stop.q;
assign reg_hash_continue = reg2hw.cmd.hash_continue.qe & reg2hw.cmd.hash_continue.q;
assign reg_hash_process  = reg2hw.cmd.hash_process.qe & reg2hw.cmd.hash_process.q;
assign hw2reg.err_code.de = err_valid;
assign hw2reg.err_code.d  = err_code;
assign hash_start             = reg_hash_start    & sha_en & ~cfg_block & ~invalid_config;
assign hash_continue          = reg_hash_continue & sha_en & ~cfg_block & ~invalid_config;
assign hash_process           = reg_hash_process  & sha_en & cfg_block &  ~invalid_config;
assign hash_start_or_continue = hash_start | hash_continue;
assign fifo_empty_negedge = fifo_empty_q & ~fifo_empty;
assign fifo_full_posedge  = ~fifo_full_q & fifo_full;
assign fifo_full_seen_d =
assign fifo_empty_gate = ~msg_allowed || ~fifo_full_seen_q;
assign status_fifo_empty = fifo_empty_gate ? 1'b 0 : fifo_empty;
assign msg_fifo_rdata  = '1;  // Return all F
assign msg_fifo_rerror = '1;  // Return error for read access
assign msg_fifo_gnt    = msg_fifo_req & ~hmac_fifo_wsel & packer_ready;
assign unused_signals = ^{reg_fifo_wmask[7:1],   reg_fifo_wmask[15:9],
assign reg_fifo_wentry.data = conv_endian32(reg_fifo_wdata, 1'b1); // always convert
assign reg_fifo_wentry.mask = {reg_fifo_wmask[0],  reg_fifo_wmask[8],
assign fifo_empty  = ~fifo_rvalid;
assign fifo_wvalid = (hmac_fifo_wsel && fifo_wready) ? hmac_fifo_wvalid : reg_fifo_wvalid;
assign msg_write = msg_fifo_req & msg_fifo_we & ~hmac_fifo_wsel & msg_allowed;
assign hw2reg.msg_length_upper.d = message_length[63:32];
assign hw2reg.msg_length_lower.d = message_length[31:0];
assign msg_fifo_wdata_endian = conv_endian32(msg_fifo_wdata, endian_swap);
assign msg_fifo_wmask_endian = conv_endian32(msg_fifo_wmask, endian_swap);
assign hash_start_sha_disabled = (reg_hash_start | reg_hash_continue) & ~sha_en;
assign hash_start_active = (reg_hash_start | reg_hash_continue) & cfg_block;
assign msg_push_not_allowed = msg_fifo_req & ~msg_allowed;
assign invalid_config_atstart = (reg_hash_start || reg_hash_continue) & invalid_config;
assign err_valid = ~reg2hw.intr_state.hmac_err.q &
assign idle = !reg_fifo_wvalid && !fifo_rvalid


Cluster 1:
assign wipe_secret = reg2hw.wipe_secret.qe;
assign wipe_v      = reg2hw.wipe_secret.q;

================================== Ai Message ==================================

I ran the anomaly clustering on the provided hmac.sv and reviewed the clusters + the RTL around them. Below I list the anomalous lines/constructs the detector surfaced, explain why each is anomalous, and say whether it is a security issue (and if so: severity and a recommended fix).

Summary of the most relevant anomalies (ranked by potential security impact)
1) msg_fifo_gnt does not check msg_allowed (grant vs. allowed-to-write mismatch)
2) msg_fifo_rdata / msg_fifo_rerror forced to all-ones
3) Duplicate case branch in err_code prioritised selection
4) Wipe implementation uses SW-provided wipe_v and is triggered by qe (write-enable) semantics
5) Idle detection uses reg_fifo_wvalid (packer internal) instead of real empty signal
6) Miscellaneous oddities (unused_signals slices, etc.)  low risk / functional

Details

1) msg_fifo_gnt does not include msg_allowed
- Lines (cluster output):
  assign msg_fifo_gnt    = msg_fifo_req & ~hmac_fifo_wsel & packer_ready;
  assign msg_write = msg_fifo_req & msg_fifo_we & ~hmac_fifo_wsel & msg_allowed;
- Why anomalous:
  The adapter's grant signal (msg_fifo_gnt) is asserted based on packer_ready but does NOT check msg_allowed. msg_allowed is the SW-write gating control that is set on hash_start_or_continue and cleared on packer_flush_done. The actual write into the packer (prim_packer.valid_i) is gated by msg_write which requires msg_allowed. That means the TL adapter can be granted while msg_allowed==0. In that condition:
    - The adapter sees a grant and will complete a TL write transaction,
    - msg_write will be false, so the packer/MSG FIFO will not accept the data,
    - The write from the host can be effectively dropped/lost, while the host thinks it succeeded.
- Security impact:
  - Classification: Functional / robustness, moderate severity.
  - Rationale: This can cause SW-visible inconsistencies and potential denial-of-service for software that expects writes to actually reach the FIFO. It does not directly leak secret material, but it can be used to confuse or destabilize SW (e.g., a SW policy that expects writes after Start to be stored). In some exploitation scenarios confusing SW behavior can lead to higher-level vulnerabilities (e.g., retry logic, incorrect assumptions about message lengths), so this is not purely cosmetic.
- Recommendation:
  - Include msg_allowed in the grant condition: msg_fifo_gnt = msg_fifo_req & ~hmac_fifo_wsel & packer_ready & msg_allowed (or otherwise prevent the TL-UL adapter from being granted unless msg_allowed).
  - Alternatively, ensure the adapter responds with an error when msg_allowed==0 rather than accepting and dropping the write.

2) msg_fifo_rdata and msg_fifo_rerror are forced to all ones
- Lines:
  assign msg_fifo_rdata  = '1;  // Return all F
  assign msg_fifo_rerror = '1;  // Return error for read access
- Why anomalous:
  Reads from the message FIFO are explicitly made to return an error and all-ones data. That may be intentional (message FIFO is write-only to SW), but it is an explicit behaviour to always indicate error on reads.
- Security impact:
  - Classification: Low/benign (likely intended).
  - Rationale: This likely indicates the TL adapter / memory region is write-only and any reads will be flagged error. That is not a secret-exposure concern; it is an API/behavior choice. If documentation expects readable message FIFO, this is a functional mismatch not a secret leak.
- Recommendation:
  - If read access should be unsupported, keep this but document it. If reads should be supported for debug or safe operation, implement proper read path and coherent error signalling.

3) Duplicate branch in err_code priority case
- Lines (approx):
  priority case (1'b1)
    hash_start_sha_disabled: begin
      err_code = SwHashStartWhenShaDisabled;
    end

    hash_start_sha_disabled: begin
      err_code = SwHashStartWhenShaDisabled;
    end

    hash_start_active: begin
      err_code = SwHashStartWhenActive;
    end
    ...
- Why anomalous:
  The same condition (hash_start_sha_disabled) appears twice in the priority case. This is redundant and likely a copy/paste mistake. It may also indicate the intended error ordering or condition coverage was not implemented as intended.
- Security impact:
  - Classification: Low (functional correctness / maintainability).
  - Rationale: Duplicate identical branches are redundant and unlikely to change behavior here (both set the same err_code). However if the duplication hides or replaced another intended branch, it could alter which err_code gets reported. Wrong error reporting can complicate SW reaction to error conditions, but it is not directly a secret-leak issue.
- Recommendation:
  - Remove the duplicate branch and review the priority ordering of err_code selection to ensure intended conditions are covered.

4) Secret wipe semantics: wipe_v and trigger via qe
- Lines:
  assign wipe_secret = reg2hw.wipe_secret.qe;
  assign wipe_v      = reg2hw.wipe_secret.q;
  if (wipe_secret) begin
    secret_key_d = {32{wipe_v}};
  end
- Why anomalous:
  - wipe_secret uses the register write-enable signal (qe) to trigger the wipe; wipe_v is the value field from that write.
  - The secret is overwritten with repeated copies of the 32-bit wipe_v rather than with a fixed zero or hardware-random value.
- Security impact:
  - Classification: Low-to-moderate (operational security consideration).
  - Rationale: The logic does wipe the secret on a software write of the wipe register. However:
    - Using a software-supplied wipe pattern (wipe_v) instead of a fixed zero or a hardware-random pattern could be considered weaker wiping (but if the intent is to permit software to supply random data for secure erasure, this is acceptable).
    - The wipe is triggered by qe (a write strobe)  that is typical and fine. One small concern: ensure that qe semantics cannot be manipulated to cause incomplete wipe (but in this code the wipe happens combinationally and will be committed next clock).
  - This is not an immediate secret-leak (it wipes the internal secret), but it relies on SW to issue a wipe with a suitable value; if the expectation is that a write to that register always clears the secret to zeros, this implementation is different.
- Recommendation:
  - Clarify in spec whether wipe_v is intended to be SW-supplied or fixed. Prefer setting to zero or a hardware-random pattern unless there is a clear reason to let SW provide the wipe value.
  - Consider adding an explicit assertion or test ensuring the wipe occurs even while the HMAC is active (or explicitly forbid that if desired).

5) Idle detection uses reg_fifo_wvalid (packer's output) rather than a dedicated packer-empty signal
- Line:
  assign idle = !reg_fifo_wvalid && !fifo_rvalid && hmac_core_idle && sha_core_idle;
- Why anomalous:
  The comment already notes this is a temporary hack (packer's empty not available), and the idle condition may be too optimistic/pessimistic.
- Security impact:
  - Classification: Low (functional).
  - Rationale: Incorrect idle reporting can affect higher-level power/management or gating decisions and possibly cause SW to change configuration at wrong time. Not directly secret-leakage, but could lead to race conditions if SW relies on idle indication to change secrets/config.
- Recommendation:
  - Replace with a correct packer-empty signal when prim_packer supports it, or make the idle semantics conservative (only go idle once all known indicators confirm emptiness).

6) Miscellaneous / low-risk oddities
- Examples:
  - unused_signals uses reg_fifo_wmask[7:1] etc. The slices skip bit 0 in each group; this is probably intentional but looks odd.
  - msg_fifo gating and packer_ready interplay is somewhat complex; carefully review for combinational cycles or false-ready conditions.
- Security impact:
  - Classification: Low.
- Recommendation:
  - Clean up unused-signal ranges or add comments explaining the slicing choices.
  - Run formal checks for combinational cycles or grant/handshake corner cases.

Overall conclusion
- I found no direct, high-severity secret-exposure bug in the RTL fragment. The secret is stored in a dedicated secret_key register and there is a wipe function; the design tries to prevent secret updates during processing (cfg_block) and raises an error if SW writes while in process.
- The most important practical issue is the grant vs allowed mismatch (msg_fifo_gnt not checking msg_allowed). That can lead to dropped writes and inconsistent SW state (moderate severity). Fixing the grant condition to include msg_allowed (or return an error to TL-UL when writes are disallowed) is recommended.
- The wipe semantics (software-supplied wipe pattern) is worth clarifying in design/security docs (is user-supplied wipe allowed/intended?). Consider enforcing zeroing or hardware-random wipe if that is the security policy.

If you want, I can:
- produce a small patch / suggested code diff that: (a) adds msg_allowed to msg_fifo_gnt, (b) removes the duplicate err_code branch, and (c) optionally change wipe behavior to force zero on wipe. Which change(s) should I generate?
================================= Tool Message =================================
Name: run_anomaly_detector_agent

I ran the anomaly clustering on the provided hmac.sv and reviewed the clusters + the RTL around them. Below I list the anomalous lines/constructs the detector surfaced, explain why each is anomalous, and say whether it is a security issue (and if so: severity and a recommended fix).

Summary of the most relevant anomalies (ranked by potential security impact)
1) msg_fifo_gnt does not check msg_allowed (grant vs. allowed-to-write mismatch)
2) msg_fifo_rdata / msg_fifo_rerror forced to all-ones
3) Duplicate case branch in err_code prioritised selection
4) Wipe implementation uses SW-provided wipe_v and is triggered by qe (write-enable) semantics
5) Idle detection uses reg_fifo_wvalid (packer internal) instead of real empty signal
6) Miscellaneous oddities (unused_signals slices, etc.)  low risk / functional

Details

1) msg_fifo_gnt does not include msg_allowed
- Lines (cluster output):
  assign msg_fifo_gnt    = msg_fifo_req & ~hmac_fifo_wsel & packer_ready;
  assign msg_write = msg_fifo_req & msg_fifo_we & ~hmac_fifo_wsel & msg_allowed;
- Why anomalous:
  The adapter's grant signal (msg_fifo_gnt) is asserted based on packer_ready but does NOT check msg_allowed. msg_allowed is the SW-write gating control that is set on hash_start_or_continue and cleared on packer_flush_done. The actual write into the packer (prim_packer.valid_i) is gated by msg_write which requires msg_allowed. That means the TL adapter can be granted while msg_allowed==0. In that condition:
    - The adapter sees a grant and will complete a TL write transaction,
    - msg_write will be false, so the packer/MSG FIFO will not accept the data,
    - The write from the host can be effectively dropped/lost, while the host thinks it succeeded.
- Security impact:
  - Classification: Functional / robustness, moderate severity.
  - Rationale: This can cause SW-visible inconsistencies and potential denial-of-service for software that expects writes to actually reach the FIFO. It does not directly leak secret material, but it can be used to confuse or destabilize SW (e.g., a SW policy that expects writes after Start to be stored). In some exploitation scenarios confusing SW behavior can lead to higher-level vulnerabilities (e.g., retry logic, incorrect assumptions about message lengths), so this is not purely cosmetic.
- Recommendation:
  - Include msg_allowed in the grant condition: msg_fifo_gnt = msg_fifo_req & ~hmac_fifo_wsel & packer_ready & msg_allowed (or otherwise prevent the TL-UL adapter from being granted unless msg_allowed).
  - Alternatively, ensure the adapter responds with an error when msg_allowed==0 rather than accepting and dropping the write.

2) msg_fifo_rdata and msg_fifo_rerror are forced to all ones
- Lines:
  assign msg_fifo_rdata  = '1;  // Return all F
  assign msg_fifo_rerror = '1;  // Return error for read access
- Why anomalous:
  Reads from the message FIFO are explicitly made to return an error and all-ones data. That may be intentional (message FIFO is write-only to SW), but it is an explicit behaviour to always indicate error on reads.
- Security impact:
  - Classification: Low/benign (likely intended).
  - Rationale: This likely indicates the TL adapter / memory region is write-only and any reads will be flagged error. That is not a secret-exposure concern; it is an API/behavior choice. If documentation expects readable message FIFO, this is a functional mismatch not a secret leak.
- Recommendation:
  - If read access should be unsupported, keep this but document it. If reads should be supported for debug or safe operation, implement proper read path and coherent error signalling.

3) Duplicate branch in err_code priority case
- Lines (approx):
  priority case (1'b1)
    hash_start_sha_disabled: begin
      err_code = SwHashStartWhenShaDisabled;
    end

    hash_start_sha_disabled: begin
      err_code = SwHashStartWhenShaDisabled;
    end

    hash_start_active: begin
      err_code = SwHashStartWhenActive;
    end
    ...
- Why anomalous:
  The same condition (hash_start_sha_disabled) appears twice in the priority case. This is redundant and likely a copy/paste mistake. It may also indicate the intended error ordering or condition coverage was not implemented as intended.
- Security impact:
  - Classification: Low (functional correctness / maintainability).
  - Rationale: Duplicate identical branches are redundant and unlikely to change behavior here (both set the same err_code). However if the duplication hides or replaced another intended branch, it could alter which err_code gets reported. Wrong error reporting can complicate SW reaction to error conditions, but it is not directly a secret-leak issue.
- Recommendation:
  - Remove the duplicate branch and review the priority ordering of err_code selection to ensure intended conditions are covered.

4) Secret wipe semantics: wipe_v and trigger via qe
- Lines:
  assign wipe_secret = reg2hw.wipe_secret.qe;
  assign wipe_v      = reg2hw.wipe_secret.q;
  if (wipe_secret) begin
    secret_key_d = {32{wipe_v}};
  end
- Why anomalous:
  - wipe_secret uses the register write-enable signal (qe) to trigger the wipe; wipe_v is the value field from that write.
  - The secret is overwritten with repeated copies of the 32-bit wipe_v rather than with a fixed zero or hardware-random value.
- Security impact:
  - Classification: Low-to-moderate (operational security consideration).
  - Rationale: The logic does wipe the secret on a software write of the wipe register. However:
    - Using a software-supplied wipe pattern (wipe_v) instead of a fixed zero or a hardware-random pattern could be considered weaker wiping (but if the intent is to permit software to supply random data for secure erasure, this is acceptable).
    - The wipe is triggered by qe (a write strobe)  that is typical and fine. One small concern: ensure that qe semantics cannot be manipulated to cause incomplete wipe (but in this code the wipe happens combinationally and will be committed next clock).
  - This is not an immediate secret-leak (it wipes the internal secret), but it relies on SW to issue a wipe with a suitable value; if the expectation is that a write to that register always clears the secret to zeros, this implementation is different.
- Recommendation:
  - Clarify in spec whether wipe_v is intended to be SW-supplied or fixed. Prefer setting to zero or a hardware-random pattern unless there is a clear reason to let SW provide the wipe value.
  - Consider adding an explicit assertion or test ensuring the wipe occurs even while the HMAC is active (or explicitly forbid that if desired).

5) Idle detection uses reg_fifo_wvalid (packer's output) rather than a dedicated packer-empty signal
- Line:
  assign idle = !reg_fifo_wvalid && !fifo_rvalid && hmac_core_idle && sha_core_idle;
- Why anomalous:
  The comment already notes this is a temporary hack (packer's empty not available), and the idle condition may be too optimistic/pessimistic.
- Security impact:
  - Classification: Low (functional).
  - Rationale: Incorrect idle reporting can affect higher-level power/management or gating decisions and possibly cause SW to change configuration at wrong time. Not directly secret-leakage, but could lead to race conditions if SW relies on idle indication to change secrets/config.
- Recommendation:
  - Replace with a correct packer-empty signal when prim_packer supports it, or make the idle semantics conservative (only go idle once all known indicators confirm emptiness).

6) Miscellaneous / low-risk oddities
- Examples:
  - unused_signals uses reg_fifo_wmask[7:1] etc. The slices skip bit 0 in each group; this is probably intentional but looks odd.
  - msg_fifo gating and packer_ready interplay is somewhat complex; carefully review for combinational cycles or false-ready conditions.
- Security impact:
  - Classification: Low.
- Recommendation:
  - Clean up unused-signal ranges or add comments explaining the slicing choices.
  - Run formal checks for combinational cycles or grant/handshake corner cases.

Overall conclusion
- I found no direct, high-severity secret-exposure bug in the RTL fragment. The secret is stored in a dedicated secret_key register and there is a wipe function; the design tries to prevent secret updates during processing (cfg_block) and raises an error if SW writes while in process.
- The most important practical issue is the grant vs allowed mismatch (msg_fifo_gnt not checking msg_allowed). That can lead to dropped writes and inconsistent SW state (moderate severity). Fixing the grant condition to include msg_allowed (or return an error to TL-UL when writes are disallowed) is recommended.
- The wipe semantics (software-supplied wipe pattern) is worth clarifying in design/security docs (is user-supplied wipe allowed/intended?). Consider enforcing zeroing or hardware-random wipe if that is the security policy.

If you want, I can:
- produce a small patch / suggested code diff that: (a) adds msg_allowed to msg_fifo_gnt, (b) removes the duplicate err_code branch, and (c) optionally change wipe behavior to force zero on wipe. Which change(s) should I generate?
================================== Ai Message ==================================
Tool Calls:
  read_file (call_TaXaVvFT8EGCGUzEjuVaEay3)
 Call ID: call_TaXaVvFT8EGCGUzEjuVaEay3
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/doc/programmers_guide.md
================================= Tool Message =================================
Name: read_file

# Programmer's Guide

This chapter shows how to use the HMAC/SHA-2 IP by showing some snippets such as initialization, initiating SHA-2 or HMAC process and processing the interrupts.
This code is not compilable but serves to demonstrate the IO required.
A more detailed SW implementation can be found in software under `sw/` in [cryptolib code](../../../../sw/device/lib/crypto/drivers/hmac.c) which is the recommended reference implementation for further SW development.
HMAC/SHA-2 IP is also used in [ROM code](../../../../sw/device/silicon_creator/lib/drivers/hmac.c) but this is a constrained implementation for specific ROM code purposes. Therefore, it is not a recommended software implementation reference.
Code in [HMAC DIF](../../../../sw/device/lib/dif/dif_hmac.c) is intended for tesing development purposes, but remains limited to configuring HMAC only in SHA-2 256 with 256-bit key, with plans to update it in the near future.

## Initialization

This section of the code describes initializing the HMAC with SHA-2 256 digest using a 256-bit key: setting up the interrupts, endianness, and HMAC/SHA-2 mode.
[`CFG.endian_swap`](registers.md#cfg) reverses the byte-order of input words when software writes into the message FIFO.
[`CFG.digest_swap`](registers.md#cfg) reverses the byte-order in the final HMAC or SHA hash.

```c
void hmac_init(unsigned int endianess, unsigned int digest_endian) {
  HMAC_CFG(0) = HMAC_CFG_SHA_EN
              | HMAC_CFG_HMAC_EN
              | (endianess << HMAC_CFG_ENDIAN_SWAP_LSB)
              | (digest_endian << HMAC_CFG_DIGEST_SWAP_LSB)
              | (HMAC_CFG_DIGEST_SIZE_FIELD << HMAC_CFG_DIGEST_SIZE_VALUE_SHA2_256)
              | (HMAC_CFG_KEY_LENGTH_FIELD << HMAC_CFG_KEY_LENGTH_FIELD);

  // Enable interrupts if needed.

  // If secret key is static, you can put the key here
  HMAC_KEY_0 = SECRET_KEY_0;
  HMAC_KEY_1 = SECRET_KEY_1;
  HMAC_KEY_2 = SECRET_KEY_2;
  HMAC_KEY_3 = SECRET_KEY_3;
  HMAC_KEY_4 = SECRET_KEY_4;
  HMAC_KEY_5 = SECRET_KEY_5;
  HMAC_KEY_6 = SECRET_KEY_6;
  HMAC_KEY_7 = SECRET_KEY_7;
}
```

## Triggering HMAC/SHA-2 engine

The following code shows how to send a message to the HMAC, the procedure is the same whether a full HMAC or just a SHA-2 computation is required (choose between them using [`CFG.hmac_en`](registers.md#cfg)).
In both cases the SHA-2 engine must be enabled using [`CFG.sha_en`](registers.md#cfg) (once all other configuration inputs have been properly set).
If the message is larger than 512-bit, the software must wait until the FIFO is not full before writing further bits.
For SHA-2 256, only `DIGEST_0`..`7` should be read out, the remaining digest registers are redundant and would hold irrelevant values.
For SHA-2 384, only `DIGEST_0`..`11` should be read out, the rest should be truncated out by not being read by the SW.
For SHA-2 512, all `DIGEST_0`..`15` should be read out.

```c
void run_hmac(uint32_t *msg, uint32_t msg_len, uint32_t *hash) {
  // Initiate hash: hash_start
  REG32(HMAC_CMD(0)) = (1 << HMAC_CMD_HASH_START);

  // write the message: below example assumes word-aligned access
  for (uint32_t written = 0 ; written < (msg_len >> 3) ; written += 4) {
    while((REG32(HMAC_STATUS(0)) >> HMAC_STATUS_FIFO_FULL) & 0x1) ;
    // Any write data from HMAC_MSG_FIFO_OFFSET to HMAC_MSG_FIFO_SIZE
    // is written to the message FIFO
    REG32(HMAC_MSG_FIFO(0)) = *(msg+(written/4));
  }

  // Completes hash: hash_process
  REG32(HMAC_CMD(0)) = (1 << HMAC_CMD_HASH_PROCESS);

  while(0 == (REG32(HMAC_INTR_STATE(0)) >> HMAC_INTR_STATE_HMAC_DONE) & 0x1);

  REG32(HMAC_INTR_STATE(0)) = 1 << HMAC_INTR_STATE_HMAC_DONE;

  // Read the digest
  for (int i = 0 ; i < 8 ; i++) {
    *(hash + i) = REG32(HMAC_DIGEST_0(0) + (i << 2));
  }
}
```

## Updating the configurations

The HMAC IP prevents [`CFG`](registers.md#cfg) and [`KEY`](registers.md#key) registers from getting updating while the engine is processing messages.
Such attempts are discarded.
The [`KEY`](registers.md#key) register ignores any attempt to access the secret key in the middle of the process.
If the software tries to update the KEY, the IP reports an error through the [`ERR_CODE`](registers.md#err_code) register.
The error code is `SwUpdateSecretKeyInProcess`, `0x0003`.

## Saving and restoring the context

Software can let the HMAC IP process multiple message streams in a time-interleaved fashion by saving and restoring the context (i.e., parts of the hardware-internal state).

Such context switches are possible only at the boundary of complete message blocks (512-bit for SHA-2 256 or 1024-bit for SHA-2 384/512).
When SW doesn't know each instant at which a full message block is available, it can buffer data in memory until a block is full and only write HMAC's FIFOs once the buffer in memory contains a full message block.

The context that needs to be saved and restored is in the following registers: [`CFG`](registers.md#cfg), [`DIGEST_*`](registers.md#digest), and [`MSG_LENGTH_*`](registers.md#msg_length_lower).

Each new message stream needs to be started *once* by setting the `CMD.hash_start` bit and finalized *once* by setting the `CMD.hash_process` bit.
To switch from one message stream to another, set the `CMD.hash_stop` bit, wait for the `hmac_done` interrupt (or status bit), save one context and restore the other, and then set the `CMD.hash_continue` bit.

Here is an example usage pattern of this feature:
1. Start processing message stream A by configuring HMAC and then setting the `CMD.hash_start` bit.
1. Write an arbitrary number of message blocks to HMAC's `MSG_FIFO`.
1. Stop HMAC by setting the `CMD.hash_stop` bit and wait for the `hmac_done` interrupt (or poll the interrupt status register).
1. Save the context by reading the `DIGEST_0`..`15` and `MSG_LENGTH_`{`LOWER`,`UPPER`} registers.
If the operation is keyed HMAC, the values of `KEY_0`..`X` registers also need to be maintained as part of the context, where `X` is the last register used for the given key length (e.g. for HMAC-256, `X=7`).
However, key registers cannot be read from SW, therefore SW must maintain key values as part of its own context during initialization.
Similarly, the value of the `CFG` register must also be preserved, and SW should keep its value separately, instead of reading it from `CFG` register.
1. Disable `sha_en` by updating `CFG` register, in order to clear the digest from stream A.
This is necessary to also prevent leakage of intermediate context of one SW thread to another.
1. Repeat steps 1-5 for message stream B.
1. Before restoring context, make sure that `sha_en` in `CFG` remains disabled.
1. Restore the context of message stream A by writing the `CFG`, `DIGEST_0`..`15`, and `MSG_LENGTH_`{`LOWER`,`UPPER`} registers.
In the case of keyed HMAC, `KEY_0`..`X` registers also need to be restored.
1. Enable `sha_en` of `CFG`, which enables HMAC again and locks down writing to the `DIGEST_0`..`15` registers from SW.
1. Continue processing message stream A by setting the `CMD.hash_continue` bit.
1. Write an arbitrary number of message blocks to HMAC's `MSG_FIFO`.
1. Continue this with as many message blocks and parallel message streams as needed.
The final hash for any message stream can be obtained at any time (no need for complete blocks) by setting `CMD.hash_process` and waiting for the `hmac_done` interrupt / status bit (or polling on the `STATUS.hmac_idle` bit) to indicate the ongoing operation has completed, and finally reading the digest from the `DIGEST` registers.

## Errors

When HMAC errors are triggered, the IP reports the error via [`INTR_STATE.hmac_err`](registers.md#intr_state).
The details of the error type is stored in [`ERR_CODE`](registers.md#err_code).

Error                        | Value | Description
-----------------------------|-------|---------------
`SwPushMsgWhenShaDisabled`   | `0x1` | The error is reported when SW writes data into MSG_FIFO when SHA is disabled. It may be due to SW routine error, or FI attacks. This error code is not used in the current version of the IP. Instead `SwPushMsgWhenDisallowed` is reported.
`SwHashStartWhenShaDisabled` | `0x2` | When HMAC detects the CMD.start while SHA is disabled, it reports this error code.
`SwUpdateSecretKeyInProcess` | `0x3` | Secret Key CSRs should not be modified during the hashing. This error is reported when those CSRs are revised during hashing.
`SwHashStartWhenActive`      | `0x4` | The error is reported when CMD.start is received while HMAC is running.
`SwPushMsgWhenDisallowed`    | `0x5` | After CMD.process is received, the MSG_FIFO should not by updated by SW. This error is reported in that case.
`SwInvalidConfig`            | `0x6` | SW has configured HMAC incorrectly.
`SwPushMsgWhenDisallowed`    | `0x5` | The error is reported when MSG_FIFO is being updated by SW with more message words when it is disallowed: either when the SHA-2 engine is disabled or the engine has not been triggered to start yet or it has been already triggered to finalize computation.
`SwInvalidConfig`            | `0x6` | The error is reported when HMAC has been configured incorrectly by SW, i.e. invalid digest size for SHA-2/HMAC modes or invalid key length for HMAC mode.

## FIFO Depth and Empty status

If the SW is slow and the SHA2 engine pops the data fast enough, the Message FIFO's depth may remain **0**.
The Message FIFO's `fifo_empty` status bit, however, is lowered for a cycle.

However, if the SHA-2 engine is currently busy, the Message FIFO may actually run full (indicated by the `fifo_full` status bit).
Resolving this conditions may take several dozens of cycles.
After the SHA-2 engine starts popping the data again, the Message FIFO will eventually run empty again and the `fifo_empty` status interrupt will fire.
Note that the `fifo_empty` status interrupt will not fire if i) the Message FIFO is not writable by software, or ii) after software has written either the `Process` or `Stop` command.

The recommended approach for software to write messages is:

1. Check the FIFO depth [`STATUS.fifo_depth`](registers.md#status). This represents the number of entry slots currently occupied in the FIFO.
2. Calculate the remaining size as `<max number of fifo entries> - <STATUS.fifo_depth>)`.
3. Write data to fill the remaining size.
4. Repeat until all data is written.
   In case the FIFO runs full (check [`STATUS.fifo_full`](registers.md#status)), software can optionally wait for the `fifo_empty` status interrupt before continuing.

If the FIFO runs full, software should not continue to write data into [`MSG_FIFO`](registers.md#msg_fifo) and first wait the status flag [`STATUS.fifo_full`](registers.md#status) to lower.
Whilst the FIFO is full, the HMAC will block writes until the FIFO has space which will cause back-pressure on the interconnect.

## Device Interface Functions (DIFs)

- [Device Interface Functions](../../../../sw/device/lib/dif/dif_hmac.h)

## Register Table

* [Register Table](registers.md#registers)

================================== Ai Message ==================================
Tool Calls:
  run_llm_cwe_checker_agent (call_g5LS7ogJWljqLCZZo3htVUQp)
 Call ID: call_g5LS7ogJWljqLCZZo3htVUQp
  Args:
    design_filepath: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv
    top_module: hmac_reg_top
    security_objective: register access control, write-only secrets, information disclosure
================================ Human Message =================================

Are there security concerns related to register access control, write-only secrets, information disclosure in the provided RTL:
    """

    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Register Top module auto-generated by `reggen`

`include "prim_assert.sv"

module hmac_reg_top (
  input clk_i,
  input rst_ni,
  input  tlul_pkg::tl_h2d_t tl_i,
  output tlul_pkg::tl_d2h_t tl_o,

  // Output port for window
  output tlul_pkg::tl_h2d_t tl_win_o,
  input  tlul_pkg::tl_d2h_t tl_win_i,

  // To HW
  output hmac_reg_pkg::hmac_reg2hw_t reg2hw, // Write
  input  hmac_reg_pkg::hmac_hw2reg_t hw2reg, // Read

  // Integrity check errors
  output logic intg_err_o
);

  import hmac_reg_pkg::* ;

  localparam int AW = 13;
  localparam int DW = 32;
  localparam int DBW = DW/8;                    // Byte Width

  // register signals
  logic           reg_we;
  logic           reg_re;
  logic [AW-1:0]  reg_addr;
  logic [DW-1:0]  reg_wdata;
  logic [DBW-1:0] reg_be;
  logic [DW-1:0]  reg_rdata;
  logic           reg_error;

  logic          addrmiss, wr_err;

  logic [DW-1:0] reg_rdata_next;
  logic reg_busy;

  tlul_pkg::tl_h2d_t tl_reg_h2d;
  tlul_pkg::tl_d2h_t tl_reg_d2h;


  // incoming payload check
  logic intg_err;
  tlul_cmd_intg_chk u_chk (
    .tl_i(tl_i),
    .err_o(intg_err)
  );

  // also check for spurious write enables
  logic reg_we_err;
  logic [58:0] reg_we_check;
  prim_reg_we_check #(
    .OneHotWidth(59)
  ) u_prim_reg_we_check (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .oh_i  (reg_we_check),
    .en_i  (reg_we && !addrmiss),
    .err_o (reg_we_err)
  );

  logic err_q;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      err_q <= '0;
    end else if (intg_err || reg_we_err) begin
      err_q <= 1'b1;
    end
  end

  // integrity error output is permanent and should be used for alert generation
  // register errors are transactional
  assign intg_err_o = err_q | intg_err | reg_we_err;

  // outgoing integrity generation
  tlul_pkg::tl_d2h_t tl_o_pre;
  tlul_rsp_intg_gen #(
    .EnableRspIntgGen(1),
    .EnableDataIntgGen(1)
  ) u_rsp_intg_gen (
    .tl_i(tl_o_pre),
    .tl_o(tl_o)
  );

  tlul_pkg::tl_h2d_t tl_socket_h2d [2];
  tlul_pkg::tl_d2h_t tl_socket_d2h [2];

  logic [0:0] reg_steer;

  // socket_1n connection
  assign tl_reg_h2d = tl_socket_h2d[1];
  assign tl_socket_d2h[1] = tl_reg_d2h;

  assign tl_win_o = tl_socket_h2d[0];
  assign tl_socket_d2h[0] = tl_win_i;

  // Create Socket_1n
  tlul_socket_1n #(
    .N            (2),
    .HReqPass     (1'b1),
    .HRspPass     (1'b1),
    .DReqPass     ({2{1'b1}}),
    .DRspPass     ({2{1'b1}}),
    .HReqDepth    (4'h0),
    .HRspDepth    (4'h0),
    .DReqDepth    ({2{4'h0}}),
    .DRspDepth    ({2{4'h0}}),
    .ExplicitErrs (1'b0)
  ) u_socket (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),
    .tl_h_i (tl_i),
    .tl_h_o (tl_o_pre),
    .tl_d_o (tl_socket_h2d),
    .tl_d_i (tl_socket_d2h),
    .dev_select_i (reg_steer)
  );

  // Create steering logic
  always_comb begin
    reg_steer =
        tl_i.a_address[AW-1:0] inside {[4096:8191]} ? 1'd0 :
        // Default set to register
        1'd1;

    // Override this in case of an integrity error
    if (intg_err) begin
      reg_steer = 1'd1;
    end
  end

  tlul_adapter_reg #(
    .RegAw(AW),
    .RegDw(DW),
    .EnableDataIntgGen(0)
  ) u_reg_if (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),

    .tl_i (tl_reg_h2d),
    .tl_o (tl_reg_d2h),

    .en_ifetch_i(prim_mubi_pkg::MuBi4False),
    .intg_error_o(),

    .we_o    (reg_we),
    .re_o    (reg_re),
    .addr_o  (reg_addr),
    .wdata_o (reg_wdata),
    .be_o    (reg_be),
    .busy_i  (reg_busy),
    .rdata_i (reg_rdata),
    .error_i (reg_error)
  );

  // cdc oversampling signals

  assign reg_rdata = reg_rdata_next ;
  assign reg_error = addrmiss | wr_err | intg_err;

  // Define SW related signals
  // Format: <reg>_<field>_{wd|we|qs}
  //        or <reg>_{wd|we|qs} if field == 1 or 0
  logic intr_state_we;
  logic intr_state_hmac_done_qs;
  logic intr_state_hmac_done_wd;
  logic intr_state_fifo_empty_qs;
  logic intr_state_hmac_err_qs;
  logic intr_state_hmac_err_wd;
  logic intr_enable_we;
  logic intr_enable_hmac_done_qs;
  logic intr_enable_hmac_done_wd;
  logic intr_enable_fifo_empty_qs;
  logic intr_enable_fifo_empty_wd;
  logic intr_enable_hmac_err_qs;
  logic intr_enable_hmac_err_wd;
  logic intr_test_we;
  logic intr_test_hmac_done_wd;
  logic intr_test_fifo_empty_wd;
  logic intr_test_hmac_err_wd;
  logic alert_test_we;
  logic alert_test_wd;
  logic cfg_re;
  logic cfg_we;
  logic cfg_hmac_en_qs;
  logic cfg_hmac_en_wd;
  logic cfg_sha_en_qs;
  logic cfg_sha_en_wd;
  logic cfg_endian_swap_qs;
  logic cfg_endian_swap_wd;
  logic cfg_digest_swap_qs;
  logic cfg_digest_swap_wd;
  logic cfg_key_swap_qs;
  logic cfg_key_swap_wd;
  logic [3:0] cfg_digest_size_qs;
  logic [3:0] cfg_digest_size_wd;
  logic [5:0] cfg_key_length_qs;
  logic [5:0] cfg_key_length_wd;
  logic cmd_we;
  logic cmd_hash_start_wd;
  logic cmd_hash_process_wd;
  logic cmd_hash_stop_wd;
  logic cmd_hash_continue_wd;
  logic status_re;
  logic status_hmac_idle_qs;
  logic status_fifo_empty_qs;
  logic status_fifo_full_qs;
  logic [5:0] status_fifo_depth_qs;
  logic [31:0] err_code_qs;
  logic wipe_secret_we;
  logic [31:0] wipe_secret_wd;
  logic key_0_we;
  logic [31:0] key_0_wd;
  logic key_1_we;
  logic [31:0] key_1_wd;
  logic key_2_we;
  logic [31:0] key_2_wd;
  logic key_3_we;
  logic [31:0] key_3_wd;
  logic key_4_we;
  logic [31:0] key_4_wd;
  logic key_5_we;
  logic [31:0] key_5_wd;
  logic key_6_we;
  logic [31:0] key_6_wd;
  logic key_7_we;
  logic [31:0] key_7_wd;
  logic key_8_we;
  logic [31:0] key_8_wd;
  logic key_9_we;
  logic [31:0] key_9_wd;
  logic key_10_we;
  logic [31:0] key_10_wd;
  logic key_11_we;
  logic [31:0] key_11_wd;
  logic key_12_we;
  logic [31:0] key_12_wd;
  logic key_13_we;
  logic [31:0] key_13_wd;
  logic key_14_we;
  logic [31:0] key_14_wd;
  logic key_15_we;
  logic [31:0] key_15_wd;
  logic key_16_we;
  logic [31:0] key_16_wd;
  logic key_17_we;
  logic [31:0] key_17_wd;
  logic key_18_we;
  logic [31:0] key_18_wd;
  logic key_19_we;
  logic [31:0] key_19_wd;
  logic key_20_we;
  logic [31:0] key_20_wd;
  logic key_21_we;
  logic [31:0] key_21_wd;
  logic key_22_we;
  logic [31:0] key_22_wd;
  logic key_23_we;
  logic [31:0] key_23_wd;
  logic key_24_we;
  logic [31:0] key_24_wd;
  logic key_25_we;
  logic [31:0] key_25_wd;
  logic key_26_we;
  logic [31:0] key_26_wd;
  logic key_27_we;
  logic [31:0] key_27_wd;
  logic key_28_we;
  logic [31:0] key_28_wd;
  logic key_29_we;
  logic [31:0] key_29_wd;
  logic key_30_we;
  logic [31:0] key_30_wd;
  logic key_31_we;
  logic [31:0] key_31_wd;
  logic digest_0_re;
  logic digest_0_we;
  logic [31:0] digest_0_qs;
  logic [31:0] digest_0_wd;
  logic digest_1_re;
  logic digest_1_we;
  logic [31:0] digest_1_qs;
  logic [31:0] digest_1_wd;
  logic digest_2_re;
  logic digest_2_we;
  logic [31:0] digest_2_qs;
  logic [31:0] digest_2_wd;
  logic digest_3_re;
  logic digest_3_we;
  logic [31:0] digest_3_qs;
  logic [31:0] digest_3_wd;
  logic digest_4_re;
  logic digest_4_we;
  logic [31:0] digest_4_qs;
  logic [31:0] digest_4_wd;
  logic digest_5_re;
  logic digest_5_we;
  logic [31:0] digest_5_qs;
  logic [31:0] digest_5_wd;
  logic digest_6_re;
  logic digest_6_we;
  logic [31:0] digest_6_qs;
  logic [31:0] digest_6_wd;
  logic digest_7_re;
  logic digest_7_we;
  logic [31:0] digest_7_qs;
  logic [31:0] digest_7_wd;
  logic digest_8_re;
  logic digest_8_we;
  logic [31:0] digest_8_qs;
  logic [31:0] digest_8_wd;
  logic digest_9_re;
  logic digest_9_we;
  logic [31:0] digest_9_qs;
  logic [31:0] digest_9_wd;
  logic digest_10_re;
  logic digest_10_we;
  logic [31:0] digest_10_qs;
  logic [31:0] digest_10_wd;
  logic digest_11_re;
  logic digest_11_we;
  logic [31:0] digest_11_qs;
  logic [31:0] digest_11_wd;
  logic digest_12_re;
  logic digest_12_we;
  logic [31:0] digest_12_qs;
  logic [31:0] digest_12_wd;
  logic digest_13_re;
  logic digest_13_we;
  logic [31:0] digest_13_qs;
  logic [31:0] digest_13_wd;
  logic digest_14_re;
  logic digest_14_we;
  logic [31:0] digest_14_qs;
  logic [31:0] digest_14_wd;
  logic digest_15_re;
  logic digest_15_we;
  logic [31:0] digest_15_qs;
  logic [31:0] digest_15_wd;
  logic msg_length_lower_re;
  logic msg_length_lower_we;
  logic [31:0] msg_length_lower_qs;
  logic [31:0] msg_length_lower_wd;
  logic msg_length_upper_re;
  logic msg_length_upper_we;
  logic [31:0] msg_length_upper_qs;
  logic [31:0] msg_length_upper_wd;

  // Register instances
  // R[intr_state]: V(False)
  //   F[hmac_done]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_hmac_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_hmac_done_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.hmac_done.de),
    .d      (hw2reg.intr_state.hmac_done.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.hmac_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_hmac_done_qs)
  );

  //   F[fifo_empty]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_fifo_empty (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.intr_state.fifo_empty.de),
    .d      (hw2reg.intr_state.fifo_empty.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.fifo_empty.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_fifo_empty_qs)
  );

  //   F[hmac_err]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_hmac_err (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_hmac_err_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.hmac_err.de),
    .d      (hw2reg.intr_state.hmac_err.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.hmac_err.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_hmac_err_qs)
  );


  // R[intr_enable]: V(False)
  //   F[hmac_done]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_hmac_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_hmac_done_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.hmac_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_hmac_done_qs)
  );

  //   F[fifo_empty]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_fifo_empty (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_fifo_empty_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.fifo_empty.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_fifo_empty_qs)
  );

  //   F[hmac_err]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_hmac_err (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_hmac_err_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.hmac_err.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_hmac_err_qs)
  );


  // R[intr_test]: V(True)
  logic intr_test_qe;
  logic [2:0] intr_test_flds_we;
  assign intr_test_qe = &intr_test_flds_we;
  //   F[hmac_done]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_hmac_done (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_hmac_done_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[0]),
    .q      (reg2hw.intr_test.hmac_done.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.hmac_done.qe = intr_test_qe;

  //   F[fifo_empty]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_fifo_empty (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_fifo_empty_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[1]),
    .q      (reg2hw.intr_test.fifo_empty.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.fifo_empty.qe = intr_test_qe;

  //   F[hmac_err]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_hmac_err (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_hmac_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[2]),
    .q      (reg2hw.intr_test.hmac_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.hmac_err.qe = intr_test_qe;


  // R[alert_test]: V(True)
  logic alert_test_qe;
  logic [0:0] alert_test_flds_we;
  assign alert_test_qe = &alert_test_flds_we;
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[0]),
    .q      (reg2hw.alert_test.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.qe = alert_test_qe;


  // R[cfg]: V(True)
  logic cfg_qe;
  logic [6:0] cfg_flds_we;
  assign cfg_qe = &cfg_flds_we;
  //   F[hmac_en]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_hmac_en (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_hmac_en_wd),
    .d      (hw2reg.cfg.hmac_en.d),
    .qre    (),
    .qe     (cfg_flds_we[0]),
    .q      (reg2hw.cfg.hmac_en.q),
    .ds     (),
    .qs     (cfg_hmac_en_qs)
  );
  assign reg2hw.cfg.hmac_en.qe = cfg_qe;

  //   F[sha_en]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_sha_en (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_sha_en_wd),
    .d      (hw2reg.cfg.sha_en.d),
    .qre    (),
    .qe     (cfg_flds_we[1]),
    .q      (reg2hw.cfg.sha_en.q),
    .ds     (),
    .qs     (cfg_sha_en_qs)
  );
  assign reg2hw.cfg.sha_en.qe = cfg_qe;

  //   F[endian_swap]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_endian_swap (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_endian_swap_wd),
    .d      (hw2reg.cfg.endian_swap.d),
    .qre    (),
    .qe     (cfg_flds_we[2]),
    .q      (reg2hw.cfg.endian_swap.q),
    .ds     (),
    .qs     (cfg_endian_swap_qs)
  );
  assign reg2hw.cfg.endian_swap.qe = cfg_qe;

  //   F[digest_swap]: 3:3
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_digest_swap (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_digest_swap_wd),
    .d      (hw2reg.cfg.digest_swap.d),
    .qre    (),
    .qe     (cfg_flds_we[3]),
    .q      (reg2hw.cfg.digest_swap.q),
    .ds     (),
    .qs     (cfg_digest_swap_qs)
  );
  assign reg2hw.cfg.digest_swap.qe = cfg_qe;

  //   F[key_swap]: 4:4
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_key_swap (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_key_swap_wd),
    .d      (hw2reg.cfg.key_swap.d),
    .qre    (),
    .qe     (cfg_flds_we[4]),
    .q      (reg2hw.cfg.key_swap.q),
    .ds     (),
    .qs     (cfg_key_swap_qs)
  );
  assign reg2hw.cfg.key_swap.qe = cfg_qe;

  //   F[digest_size]: 8:5
  prim_subreg_ext #(
    .DW    (4)
  ) u_cfg_digest_size (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_digest_size_wd),
    .d      (hw2reg.cfg.digest_size.d),
    .qre    (),
    .qe     (cfg_flds_we[5]),
    .q      (reg2hw.cfg.digest_size.q),
    .ds     (),
    .qs     (cfg_digest_size_qs)
  );
  assign reg2hw.cfg.digest_size.qe = cfg_qe;

  //   F[key_length]: 14:9
  prim_subreg_ext #(
    .DW    (6)
  ) u_cfg_key_length (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_key_length_wd),
    .d      (hw2reg.cfg.key_length.d),
    .qre    (),
    .qe     (cfg_flds_we[6]),
    .q      (reg2hw.cfg.key_length.q),
    .ds     (),
    .qs     (cfg_key_length_qs)
  );
  assign reg2hw.cfg.key_length.qe = cfg_qe;


  // R[cmd]: V(True)
  logic cmd_qe;
  logic [3:0] cmd_flds_we;
  assign cmd_qe = &cmd_flds_we;
  //   F[hash_start]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_start (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_start_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[0]),
    .q      (reg2hw.cmd.hash_start.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_start.qe = cmd_qe;

  //   F[hash_process]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_process (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_process_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[1]),
    .q      (reg2hw.cmd.hash_process.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_process.qe = cmd_qe;

  //   F[hash_stop]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_stop (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_stop_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[2]),
    .q      (reg2hw.cmd.hash_stop.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_stop.qe = cmd_qe;

  //   F[hash_continue]: 3:3
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_continue (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_continue_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[3]),
    .q      (reg2hw.cmd.hash_continue.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_continue.qe = cmd_qe;


  // R[status]: V(True)
  //   F[hmac_idle]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_hmac_idle (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.hmac_idle.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_hmac_idle_qs)
  );

  //   F[fifo_empty]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_fifo_empty (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_empty.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_empty_qs)
  );

  //   F[fifo_full]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_fifo_full (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_full.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_full_qs)
  );

  //   F[fifo_depth]: 9:4
  prim_subreg_ext #(
    .DW    (6)
  ) u_status_fifo_depth (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_depth.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_depth_qs)
  );


  // R[err_code]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_err_code (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.err_code.de),
    .d      (hw2reg.err_code.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (err_code_qs)
  );


  // R[wipe_secret]: V(True)
  logic wipe_secret_qe;
  logic [0:0] wipe_secret_flds_we;
  assign wipe_secret_qe = &wipe_secret_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_wipe_secret (
    .re     (1'b0),
    .we     (wipe_secret_we),
    .wd     (wipe_secret_wd),
    .d      ('0),
    .qre    (),
    .qe     (wipe_secret_flds_we[0]),
    .q      (reg2hw.wipe_secret.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.wipe_secret.qe = wipe_secret_qe;


  // Subregister 0 of Multireg key
  // R[key_0]: V(True)
  logic key_0_qe;
  logic [0:0] key_0_flds_we;
  assign key_0_qe = &key_0_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_0 (
    .re     (1'b0),
    .we     (key_0_we),
    .wd     (key_0_wd),
    .d      (hw2reg.key[0].d),
    .qre    (),
    .qe     (key_0_flds_we[0]),
    .q      (reg2hw.key[0].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[0].qe = key_0_qe;


  // Subregister 1 of Multireg key
  // R[key_1]: V(True)
  logic key_1_qe;
  logic [0:0] key_1_flds_we;
  assign key_1_qe = &key_1_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_1 (
    .re     (1'b0),
    .we     (key_1_we),
    .wd     (key_1_wd),
    .d      (hw2reg.key[1].d),
    .qre    (),
    .qe     (key_1_flds_we[0]),
    .q      (reg2hw.key[1].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[1].qe = key_1_qe;


  // Subregister 2 of Multireg key
  // R[key_2]: V(True)
  logic key_2_qe;
  logic [0:0] key_2_flds_we;
  assign key_2_qe = &key_2_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_2 (
    .re     (1'b0),
    .we     (key_2_we),
    .wd     (key_2_wd),
    .d      (hw2reg.key[2].d),
    .qre    (),
    .qe     (key_2_flds_we[0]),
    .q      (reg2hw.key[2].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[2].qe = key_2_qe;


  // Subregister 3 of Multireg key
  // R[key_3]: V(True)
  logic key_3_qe;
  logic [0:0] key_3_flds_we;
  assign key_3_qe = &key_3_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_3 (
    .re     (1'b0),
    .we     (key_3_we),
    .wd     (key_3_wd),
    .d      (hw2reg.key[3].d),
    .qre    (),
    .qe     (key_3_flds_we[0]),
    .q      (reg2hw.key[3].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[3].qe = key_3_qe;


  // Subregister 4 of Multireg key
  // R[key_4]: V(True)
  logic key_4_qe;
  logic [0:0] key_4_flds_we;
  assign key_4_qe = &key_4_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_4 (
    .re     (1'b0),
    .we     (key_4_we),
    .wd     (key_4_wd),
    .d      (hw2reg.key[4].d),
    .qre    (),
    .qe     (key_4_flds_we[0]),
    .q      (reg2hw.key[4].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[4].qe = key_4_qe;


  // Subregister 5 of Multireg key
  // R[key_5]: V(True)
  logic key_5_qe;
  logic [0:0] key_5_flds_we;
  assign key_5_qe = &key_5_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_5 (
    .re     (1'b0),
    .we     (key_5_we),
    .wd     (key_5_wd),
    .d      (hw2reg.key[5].d),
    .qre    (),
    .qe     (key_5_flds_we[0]),
    .q      (reg2hw.key[5].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[5].qe = key_5_qe;


  // Subregister 6 of Multireg key
  // R[key_6]: V(True)
  logic key_6_qe;
  logic [0:0] key_6_flds_we;
  assign key_6_qe = &key_6_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_6 (
    .re     (1'b0),
    .we     (key_6_we),
    .wd     (key_6_wd),
    .d      (hw2reg.key[6].d),
    .qre    (),
    .qe     (key_6_flds_we[0]),
    .q      (reg2hw.key[6].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[6].qe = key_6_qe;


  // Subregister 7 of Multireg key
  // R[key_7]: V(True)
  logic key_7_qe;
  logic [0:0] key_7_flds_we;
  assign key_7_qe = &key_7_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_7 (
    .re     (1'b0),
    .we     (key_7_we),
    .wd     (key_7_wd),
    .d      (hw2reg.key[7].d),
    .qre    (),
    .qe     (key_7_flds_we[0]),
    .q      (reg2hw.key[7].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[7].qe = key_7_qe;


  // Subregister 8 of Multireg key
  // R[key_8]: V(True)
  logic key_8_qe;
  logic [0:0] key_8_flds_we;
  assign key_8_qe = &key_8_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_8 (
    .re     (1'b0),
    .we     (key_8_we),
    .wd     (key_8_wd),
    .d      (hw2reg.key[8].d),
    .qre    (),
    .qe     (key_8_flds_we[0]),
    .q      (reg2hw.key[8].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[8].qe = key_8_qe;


  // Subregister 9 of Multireg key
  // R[key_9]: V(True)
  logic key_9_qe;
  logic [0:0] key_9_flds_we;
  assign key_9_qe = &key_9_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_9 (
    .re     (1'b0),
    .we     (key_9_we),
    .wd     (key_9_wd),
    .d      (hw2reg.key[9].d),
    .qre    (),
    .qe     (key_9_flds_we[0]),
    .q      (reg2hw.key[9].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[9].qe = key_9_qe;


  // Subregister 10 of Multireg key
  // R[key_10]: V(True)
  logic key_10_qe;
  logic [0:0] key_10_flds_we;
  assign key_10_qe = &key_10_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_10 (
    .re     (1'b0),
    .we     (key_10_we),
    .wd     (key_10_wd),
    .d      (hw2reg.key[10].d),
    .qre    (),
    .qe     (key_10_flds_we[0]),
    .q      (reg2hw.key[10].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[10].qe = key_10_qe;


  // Subregister 11 of Multireg key
  // R[key_11]: V(True)
  logic key_11_qe;
  logic [0:0] key_11_flds_we;
  assign key_11_qe = &key_11_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_11 (
    .re     (1'b0),
    .we     (key_11_we),
    .wd     (key_11_wd),
    .d      (hw2reg.key[11].d),
    .qre    (),
    .qe     (key_11_flds_we[0]),
    .q      (reg2hw.key[11].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[11].qe = key_11_qe;


  // Subregister 12 of Multireg key
  // R[key_12]: V(True)
  logic key_12_qe;
  logic [0:0] key_12_flds_we;
  assign key_12_qe = &key_12_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_12 (
    .re     (1'b0),
    .we     (key_12_we),
    .wd     (key_12_wd),
    .d      (hw2reg.key[12].d),
    .qre    (),
    .qe     (key_12_flds_we[0]),
    .q      (reg2hw.key[12].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[12].qe = key_12_qe;


  // Subregister 13 of Multireg key
  // R[key_13]: V(True)
  logic key_13_qe;
  logic [0:0] key_13_flds_we;
  assign key_13_qe = &key_13_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_13 (
    .re     (1'b0),
    .we     (key_13_we),
    .wd     (key_13_wd),
    .d      (hw2reg.key[13].d),
    .qre    (),
    .qe     (key_13_flds_we[0]),
    .q      (reg2hw.key[13].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[13].qe = key_13_qe;


  // Subregister 14 of Multireg key
  // R[key_14]: V(True)
  logic key_14_qe;
  logic [0:0] key_14_flds_we;
  assign key_14_qe = &key_14_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_14 (
    .re     (1'b0),
    .we     (key_14_we),
    .wd     (key_14_wd),
    .d      (hw2reg.key[14].d),
    .qre    (),
    .qe     (key_14_flds_we[0]),
    .q      (reg2hw.key[14].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[14].qe = key_14_qe;


  // Subregister 15 of Multireg key
  // R[key_15]: V(True)
  logic key_15_qe;
  logic [0:0] key_15_flds_we;
  assign key_15_qe = &key_15_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_15 (
    .re     (1'b0),
    .we     (key_15_we),
    .wd     (key_15_wd),
    .d      (hw2reg.key[15].d),
    .qre    (),
    .qe     (key_15_flds_we[0]),
    .q      (reg2hw.key[15].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[15].qe = key_15_qe;


  // Subregister 16 of Multireg key
  // R[key_16]: V(True)
  logic key_16_qe;
  logic [0:0] key_16_flds_we;
  assign key_16_qe = &key_16_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_16 (
    .re     (1'b0),
    .we     (key_16_we),
    .wd     (key_16_wd),
    .d      (hw2reg.key[16].d),
    .qre    (),
    .qe     (key_16_flds_we[0]),
    .q      (reg2hw.key[16].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[16].qe = key_16_qe;


  // Subregister 17 of Multireg key
  // R[key_17]: V(True)
  logic key_17_qe;
  logic [0:0] key_17_flds_we;
  assign key_17_qe = &key_17_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_17 (
    .re     (1'b0),
    .we     (key_17_we),
    .wd     (key_17_wd),
    .d      (hw2reg.key[17].d),
    .qre    (),
    .qe     (key_17_flds_we[0]),
    .q      (reg2hw.key[17].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[17].qe = key_17_qe;


  // Subregister 18 of Multireg key
  // R[key_18]: V(True)
  logic key_18_qe;
  logic [0:0] key_18_flds_we;
  assign key_18_qe = &key_18_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_18 (
    .re     (1'b0),
    .we     (key_18_we),
    .wd     (key_18_wd),
    .d      (hw2reg.key[18].d),
    .qre    (),
    .qe     (key_18_flds_we[0]),
    .q      (reg2hw.key[18].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[18].qe = key_18_qe;


  // Subregister 19 of Multireg key
  // R[key_19]: V(True)
  logic key_19_qe;
  logic [0:0] key_19_flds_we;
  assign key_19_qe = &key_19_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_19 (
    .re     (1'b0),
    .we     (key_19_we),
    .wd     (key_19_wd),
    .d      (hw2reg.key[19].d),
    .qre    (),
    .qe     (key_19_flds_we[0]),
    .q      (reg2hw.key[19].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[19].qe = key_19_qe;


  // Subregister 20 of Multireg key
  // R[key_20]: V(True)
  logic key_20_qe;
  logic [0:0] key_20_flds_we;
  assign key_20_qe = &key_20_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_20 (
    .re     (1'b0),
    .we     (key_20_we),
    .wd     (key_20_wd),
    .d      (hw2reg.key[20].d),
    .qre    (),
    .qe     (key_20_flds_we[0]),
    .q      (reg2hw.key[20].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[20].qe = key_20_qe;


  // Subregister 21 of Multireg key
  // R[key_21]: V(True)
  logic key_21_qe;
  logic [0:0] key_21_flds_we;
  assign key_21_qe = &key_21_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_21 (
    .re     (1'b0),
    .we     (key_21_we),
    .wd     (key_21_wd),
    .d      (hw2reg.key[21].d),
    .qre    (),
    .qe     (key_21_flds_we[0]),
    .q      (reg2hw.key[21].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[21].qe = key_21_qe;


  // Subregister 22 of Multireg key
  // R[key_22]: V(True)
  logic key_22_qe;
  logic [0:0] key_22_flds_we;
  assign key_22_qe = &key_22_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_22 (
    .re     (1'b0),
    .we     (key_22_we),
    .wd     (key_22_wd),
    .d      (hw2reg.key[22].d),
    .qre    (),
    .qe     (key_22_flds_we[0]),
    .q      (reg2hw.key[22].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[22].qe = key_22_qe;


  // Subregister 23 of Multireg key
  // R[key_23]: V(True)
  logic key_23_qe;
  logic [0:0] key_23_flds_we;
  assign key_23_qe = &key_23_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_23 (
    .re     (1'b0),
    .we     (key_23_we),
    .wd     (key_23_wd),
    .d      (hw2reg.key[23].d),
    .qre    (),
    .qe     (key_23_flds_we[0]),
    .q      (reg2hw.key[23].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[23].qe = key_23_qe;


  // Subregister 24 of Multireg key
  // R[key_24]: V(True)
  logic key_24_qe;
  logic [0:0] key_24_flds_we;
  assign key_24_qe = &key_24_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_24 (
    .re     (1'b0),
    .we     (key_24_we),
    .wd     (key_24_wd),
    .d      (hw2reg.key[24].d),
    .qre    (),
    .qe     (key_24_flds_we[0]),
    .q      (reg2hw.key[24].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[24].qe = key_24_qe;


  // Subregister 25 of Multireg key
  // R[key_25]: V(True)
  logic key_25_qe;
  logic [0:0] key_25_flds_we;
  assign key_25_qe = &key_25_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_25 (
    .re     (1'b0),
    .we     (key_25_we),
    .wd     (key_25_wd),
    .d      (hw2reg.key[25].d),
    .qre    (),
    .qe     (key_25_flds_we[0]),
    .q      (reg2hw.key[25].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[25].qe = key_25_qe;


  // Subregister 26 of Multireg key
  // R[key_26]: V(True)
  logic key_26_qe;
  logic [0:0] key_26_flds_we;
  assign key_26_qe = &key_26_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_26 (
    .re     (1'b0),
    .we     (key_26_we),
    .wd     (key_26_wd),
    .d      (hw2reg.key[26].d),
    .qre    (),
    .qe     (key_26_flds_we[0]),
    .q      (reg2hw.key[26].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[26].qe = key_26_qe;


  // Subregister 27 of Multireg key
  // R[key_27]: V(True)
  logic key_27_qe;
  logic [0:0] key_27_flds_we;
  assign key_27_qe = &key_27_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_27 (
    .re     (1'b0),
    .we     (key_27_we),
    .wd     (key_27_wd),
    .d      (hw2reg.key[27].d),
    .qre    (),
    .qe     (key_27_flds_we[0]),
    .q      (reg2hw.key[27].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[27].qe = key_27_qe;


  // Subregister 28 of Multireg key
  // R[key_28]: V(True)
  logic key_28_qe;
  logic [0:0] key_28_flds_we;
  assign key_28_qe = &key_28_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_28 (
    .re     (1'b0),
    .we     (key_28_we),
    .wd     (key_28_wd),
    .d      (hw2reg.key[28].d),
    .qre    (),
    .qe     (key_28_flds_we[0]),
    .q      (reg2hw.key[28].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[28].qe = key_28_qe;


  // Subregister 29 of Multireg key
  // R[key_29]: V(True)
  logic key_29_qe;
  logic [0:0] key_29_flds_we;
  assign key_29_qe = &key_29_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_29 (
    .re     (1'b0),
    .we     (key_29_we),
    .wd     (key_29_wd),
    .d      (hw2reg.key[29].d),
    .qre    (),
    .qe     (key_29_flds_we[0]),
    .q      (reg2hw.key[29].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[29].qe = key_29_qe;


  // Subregister 30 of Multireg key
  // R[key_30]: V(True)
  logic key_30_qe;
  logic [0:0] key_30_flds_we;
  assign key_30_qe = &key_30_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_30 (
    .re     (1'b0),
    .we     (key_30_we),
    .wd     (key_30_wd),
    .d      (hw2reg.key[30].d),
    .qre    (),
    .qe     (key_30_flds_we[0]),
    .q      (reg2hw.key[30].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[30].qe = key_30_qe;


  // Subregister 31 of Multireg key
  // R[key_31]: V(True)
  logic key_31_qe;
  logic [0:0] key_31_flds_we;
  assign key_31_qe = &key_31_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_31 (
    .re     (1'b0),
    .we     (key_31_we),
    .wd     (key_31_wd),
    .d      (hw2reg.key[31].d),
    .qre    (),
    .qe     (key_31_flds_we[0]),
    .q      (reg2hw.key[31].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[31].qe = key_31_qe;


  // Subregister 0 of Multireg digest
  // R[digest_0]: V(True)
  logic digest_0_qe;
  logic [0:0] digest_0_flds_we;
  assign digest_0_qe = &digest_0_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_0 (
    .re     (digest_0_re),
    .we     (digest_0_we),
    .wd     (digest_0_wd),
    .d      (hw2reg.digest[0].d),
    .qre    (),
    .qe     (digest_0_flds_we[0]),
    .q      (reg2hw.digest[0].q),
    .ds     (),
    .qs     (digest_0_qs)
  );
  assign reg2hw.digest[0].qe = digest_0_qe;


  // Subregister 1 of Multireg digest
  // R[digest_1]: V(True)
  logic digest_1_qe;
  logic [0:0] digest_1_flds_we;
  assign digest_1_qe = &digest_1_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_1 (
    .re     (digest_1_re),
    .we     (digest_1_we),
    .wd     (digest_1_wd),
    .d      (hw2reg.digest[1].d),
    .qre    (),
    .qe     (digest_1_flds_we[0]),
    .q      (reg2hw.digest[1].q),
    .ds     (),
    .qs     (digest_1_qs)
  );
  assign reg2hw.digest[1].qe = digest_1_qe;


  // Subregister 2 of Multireg digest
  // R[digest_2]: V(True)
  logic digest_2_qe;
  logic [0:0] digest_2_flds_we;
  assign digest_2_qe = &digest_2_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_2 (
    .re     (digest_2_re),
    .we     (digest_2_we),
    .wd     (digest_2_wd),
    .d      (hw2reg.digest[2].d),
    .qre    (),
    .qe     (digest_2_flds_we[0]),
    .q      (reg2hw.digest[2].q),
    .ds     (),
    .qs     (digest_2_qs)
  );
  assign reg2hw.digest[2].qe = digest_2_qe;


  // Subregister 3 of Multireg digest
  // R[digest_3]: V(True)
  logic digest_3_qe;
  logic [0:0] digest_3_flds_we;
  assign digest_3_qe = &digest_3_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_3 (
    .re     (digest_3_re),
    .we     (digest_3_we),
    .wd     (digest_3_wd),
    .d      (hw2reg.digest[3].d),
    .qre    (),
    .qe     (digest_3_flds_we[0]),
    .q      (reg2hw.digest[3].q),
    .ds     (),
    .qs     (digest_3_qs)
  );
  assign reg2hw.digest[3].qe = digest_3_qe;


  // Subregister 4 of Multireg digest
  // R[digest_4]: V(True)
  logic digest_4_qe;
  logic [0:0] digest_4_flds_we;
  assign digest_4_qe = &digest_4_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_4 (
    .re     (digest_4_re),
    .we     (digest_4_we),
    .wd     (digest_4_wd),
    .d      (hw2reg.digest[4].d),
    .qre    (),
    .qe     (digest_4_flds_we[0]),
    .q      (reg2hw.digest[4].q),
    .ds     (),
    .qs     (digest_4_qs)
  );
  assign reg2hw.digest[4].qe = digest_4_qe;


  // Subregister 5 of Multireg digest
  // R[digest_5]: V(True)
  logic digest_5_qe;
  logic [0:0] digest_5_flds_we;
  assign digest_5_qe = &digest_5_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_5 (
    .re     (digest_5_re),
    .we     (digest_5_we),
    .wd     (digest_5_wd),
    .d      (hw2reg.digest[5].d),
    .qre    (),
    .qe     (digest_5_flds_we[0]),
    .q      (reg2hw.digest[5].q),
    .ds     (),
    .qs     (digest_5_qs)
  );
  assign reg2hw.digest[5].qe = digest_5_qe;


  // Subregister 6 of Multireg digest
  // R[digest_6]: V(True)
  logic digest_6_qe;
  logic [0:0] digest_6_flds_we;
  assign digest_6_qe = &digest_6_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_6 (
    .re     (digest_6_re),
    .we     (digest_6_we),
    .wd     (digest_6_wd),
    .d      (hw2reg.digest[6].d),
    .qre    (),
    .qe     (digest_6_flds_we[0]),
    .q      (reg2hw.digest[6].q),
    .ds     (),
    .qs     (digest_6_qs)
  );
  assign reg2hw.digest[6].qe = digest_6_qe;


  // Subregister 7 of Multireg digest
  // R[digest_7]: V(True)
  logic digest_7_qe;
  logic [0:0] digest_7_flds_we;
  assign digest_7_qe = &digest_7_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_7 (
    .re     (digest_7_re),
    .we     (digest_7_we),
    .wd     (digest_7_wd),
    .d      (hw2reg.digest[7].d),
    .qre    (),
    .qe     (digest_7_flds_we[0]),
    .q      (reg2hw.digest[7].q),
    .ds     (),
    .qs     (digest_7_qs)
  );
  assign reg2hw.digest[7].qe = digest_7_qe;


  // Subregister 8 of Multireg digest
  // R[digest_8]: V(True)
  logic digest_8_qe;
  logic [0:0] digest_8_flds_we;
  assign digest_8_qe = &digest_8_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_8 (
    .re     (digest_8_re),
    .we     (digest_8_we),
    .wd     (digest_8_wd),
    .d      (hw2reg.digest[8].d),
    .qre    (),
    .qe     (digest_8_flds_we[0]),
    .q      (reg2hw.digest[8].q),
    .ds     (),
    .qs     (digest_8_qs)
  );
  assign reg2hw.digest[8].qe = digest_8_qe;


  // Subregister 9 of Multireg digest
  // R[digest_9]: V(True)
  logic digest_9_qe;
  logic [0:0] digest_9_flds_we;
  assign digest_9_qe = &digest_9_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_9 (
    .re     (digest_9_re),
    .we     (digest_9_we),
    .wd     (digest_9_wd),
    .d      (hw2reg.digest[9].d),
    .qre    (),
    .qe     (digest_9_flds_we[0]),
    .q      (reg2hw.digest[9].q),
    .ds     (),
    .qs     (digest_9_qs)
  );
  assign reg2hw.digest[9].qe = digest_9_qe;


  // Subregister 10 of Multireg digest
  // R[digest_10]: V(True)
  logic digest_10_qe;
  logic [0:0] digest_10_flds_we;
  assign digest_10_qe = &digest_10_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_10 (
    .re     (digest_10_re),
    .we     (digest_10_we),
    .wd     (digest_10_wd),
    .d      (hw2reg.digest[10].d),
    .qre    (),
    .qe     (digest_10_flds_we[0]),
    .q      (reg2hw.digest[10].q),
    .ds     (),
    .qs     (digest_10_qs)
  );
  assign reg2hw.digest[10].qe = digest_10_qe;


  // Subregister 11 of Multireg digest
  // R[digest_11]: V(True)
  logic digest_11_qe;
  logic [0:0] digest_11_flds_we;
  assign digest_11_qe = &digest_11_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_11 (
    .re     (digest_11_re),
    .we     (digest_11_we),
    .wd     (digest_11_wd),
    .d      (hw2reg.digest[11].d),
    .qre    (),
    .qe     (digest_11_flds_we[0]),
    .q      (reg2hw.digest[11].q),
    .ds     (),
    .qs     (digest_11_qs)
  );
  assign reg2hw.digest[11].qe = digest_11_qe;


  // Subregister 12 of Multireg digest
  // R[digest_12]: V(True)
  logic digest_12_qe;
  logic [0:0] digest_12_flds_we;
  assign digest_12_qe = &digest_12_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_12 (
    .re     (digest_12_re),
    .we     (digest_12_we),
    .wd     (digest_12_wd),
    .d      (hw2reg.digest[12].d),
    .qre    (),
    .qe     (digest_12_flds_we[0]),
    .q      (reg2hw.digest[12].q),
    .ds     (),
    .qs     (digest_12_qs)
  );
  assign reg2hw.digest[12].qe = digest_12_qe;


  // Subregister 13 of Multireg digest
  // R[digest_13]: V(True)
  logic digest_13_qe;
  logic [0:0] digest_13_flds_we;
  assign digest_13_qe = &digest_13_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_13 (
    .re     (digest_13_re),
    .we     (digest_13_we),
    .wd     (digest_13_wd),
    .d      (hw2reg.digest[13].d),
    .qre    (),
    .qe     (digest_13_flds_we[0]),
    .q      (reg2hw.digest[13].q),
    .ds     (),
    .qs     (digest_13_qs)
  );
  assign reg2hw.digest[13].qe = digest_13_qe;


  // Subregister 14 of Multireg digest
  // R[digest_14]: V(True)
  logic digest_14_qe;
  logic [0:0] digest_14_flds_we;
  assign digest_14_qe = &digest_14_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_14 (
    .re     (digest_14_re),
    .we     (digest_14_we),
    .wd     (digest_14_wd),
    .d      (hw2reg.digest[14].d),
    .qre    (),
    .qe     (digest_14_flds_we[0]),
    .q      (reg2hw.digest[14].q),
    .ds     (),
    .qs     (digest_14_qs)
  );
  assign reg2hw.digest[14].qe = digest_14_qe;


  // Subregister 15 of Multireg digest
  // R[digest_15]: V(True)
  logic digest_15_qe;
  logic [0:0] digest_15_flds_we;
  assign digest_15_qe = &digest_15_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_15 (
    .re     (digest_15_re),
    .we     (digest_15_we),
    .wd     (digest_15_wd),
    .d      (hw2reg.digest[15].d),
    .qre    (),
    .qe     (digest_15_flds_we[0]),
    .q      (reg2hw.digest[15].q),
    .ds     (),
    .qs     (digest_15_qs)
  );
  assign reg2hw.digest[15].qe = digest_15_qe;


  // R[msg_length_lower]: V(True)
  logic msg_length_lower_qe;
  logic [0:0] msg_length_lower_flds_we;
  assign msg_length_lower_qe = &msg_length_lower_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_msg_length_lower (
    .re     (msg_length_lower_re),
    .we     (msg_length_lower_we),
    .wd     (msg_length_lower_wd),
    .d      (hw2reg.msg_length_lower.d),
    .qre    (),
    .qe     (msg_length_lower_flds_we[0]),
    .q      (reg2hw.msg_length_lower.q),
    .ds     (),
    .qs     (msg_length_lower_qs)
  );
  assign reg2hw.msg_length_lower.qe = msg_length_lower_qe;


  // R[msg_length_upper]: V(True)
  logic msg_length_upper_qe;
  logic [0:0] msg_length_upper_flds_we;
  assign msg_length_upper_qe = &msg_length_upper_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_msg_length_upper (
    .re     (msg_length_upper_re),
    .we     (msg_length_upper_we),
    .wd     (msg_length_upper_wd),
    .d      (hw2reg.msg_length_upper.d),
    .qre    (),
    .qe     (msg_length_upper_flds_we[0]),
    .q      (reg2hw.msg_length_upper.q),
    .ds     (),
    .qs     (msg_length_upper_qs)
  );
  assign reg2hw.msg_length_upper.qe = msg_length_upper_qe;



  logic [58:0] addr_hit;
  always_comb begin
    addr_hit[ 0] = (reg_addr == HMAC_INTR_STATE_OFFSET);
    addr_hit[ 1] = (reg_addr == HMAC_INTR_ENABLE_OFFSET);
    addr_hit[ 2] = (reg_addr == HMAC_INTR_TEST_OFFSET);
    addr_hit[ 3] = (reg_addr == HMAC_ALERT_TEST_OFFSET);
    addr_hit[ 4] = (reg_addr == HMAC_CFG_OFFSET);
    addr_hit[ 5] = (reg_addr == HMAC_CMD_OFFSET);
    addr_hit[ 6] = (reg_addr == HMAC_STATUS_OFFSET);
    addr_hit[ 7] = (reg_addr == HMAC_ERR_CODE_OFFSET);
    addr_hit[ 8] = (reg_addr == HMAC_WIPE_SECRET_OFFSET);
    addr_hit[ 9] = (reg_addr == HMAC_KEY_0_OFFSET);
    addr_hit[10] = (reg_addr == HMAC_KEY_1_OFFSET);
    addr_hit[11] = (reg_addr == HMAC_KEY_2_OFFSET);
    addr_hit[12] = (reg_addr == HMAC_KEY_3_OFFSET);
    addr_hit[13] = (reg_addr == HMAC_KEY_4_OFFSET);
    addr_hit[14] = (reg_addr == HMAC_KEY_5_OFFSET);
    addr_hit[15] = (reg_addr == HMAC_KEY_6_OFFSET);
    addr_hit[16] = (reg_addr == HMAC_KEY_7_OFFSET);
    addr_hit[17] = (reg_addr == HMAC_KEY_8_OFFSET);
    addr_hit[18] = (reg_addr == HMAC_KEY_9_OFFSET);
    addr_hit[19] = (reg_addr == HMAC_KEY_10_OFFSET);
    addr_hit[20] = (reg_addr == HMAC_KEY_11_OFFSET);
    addr_hit[21] = (reg_addr == HMAC_KEY_12_OFFSET);
    addr_hit[22] = (reg_addr == HMAC_KEY_13_OFFSET);
    addr_hit[23] = (reg_addr == HMAC_KEY_14_OFFSET);
    addr_hit[24] = (reg_addr == HMAC_KEY_15_OFFSET);
    addr_hit[25] = (reg_addr == HMAC_KEY_16_OFFSET);
    addr_hit[26] = (reg_addr == HMAC_KEY_17_OFFSET);
    addr_hit[27] = (reg_addr == HMAC_KEY_18_OFFSET);
    addr_hit[28] = (reg_addr == HMAC_KEY_19_OFFSET);
    addr_hit[29] = (reg_addr == HMAC_KEY_20_OFFSET);
    addr_hit[30] = (reg_addr == HMAC_KEY_21_OFFSET);
    addr_hit[31] = (reg_addr == HMAC_KEY_22_OFFSET);
    addr_hit[32] = (reg_addr == HMAC_KEY_23_OFFSET);
    addr_hit[33] = (reg_addr == HMAC_KEY_24_OFFSET);
    addr_hit[34] = (reg_addr == HMAC_KEY_25_OFFSET);
    addr_hit[35] = (reg_addr == HMAC_KEY_26_OFFSET);
    addr_hit[36] = (reg_addr == HMAC_KEY_27_OFFSET);
    addr_hit[37] = (reg_addr == HMAC_KEY_28_OFFSET);
    addr_hit[38] = (reg_addr == HMAC_KEY_29_OFFSET);
    addr_hit[39] = (reg_addr == HMAC_KEY_30_OFFSET);
    addr_hit[40] = (reg_addr == HMAC_KEY_31_OFFSET);
    addr_hit[41] = (reg_addr == HMAC_DIGEST_0_OFFSET);
    addr_hit[42] = (reg_addr == HMAC_DIGEST_1_OFFSET);
    addr_hit[43] = (reg_addr == HMAC_DIGEST_2_OFFSET);
    addr_hit[44] = (reg_addr == HMAC_DIGEST_3_OFFSET);
    addr_hit[45] = (reg_addr == HMAC_DIGEST_4_OFFSET);
    addr_hit[46] = (reg_addr == HMAC_DIGEST_5_OFFSET);
    addr_hit[47] = (reg_addr == HMAC_DIGEST_6_OFFSET);
    addr_hit[48] = (reg_addr == HMAC_DIGEST_7_OFFSET);
    addr_hit[49] = (reg_addr == HMAC_DIGEST_8_OFFSET);
    addr_hit[50] = (reg_addr == HMAC_DIGEST_9_OFFSET);
    addr_hit[51] = (reg_addr == HMAC_DIGEST_10_OFFSET);
    addr_hit[52] = (reg_addr == HMAC_DIGEST_11_OFFSET);
    addr_hit[53] = (reg_addr == HMAC_DIGEST_12_OFFSET);
    addr_hit[54] = (reg_addr == HMAC_DIGEST_13_OFFSET);
    addr_hit[55] = (reg_addr == HMAC_DIGEST_14_OFFSET);
    addr_hit[56] = (reg_addr == HMAC_DIGEST_15_OFFSET);
    addr_hit[57] = (reg_addr == HMAC_MSG_LENGTH_LOWER_OFFSET);
    addr_hit[58] = (reg_addr == HMAC_MSG_LENGTH_UPPER_OFFSET);
  end

  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;

  // Check sub-word write is permitted
  always_comb begin
    wr_err = (reg_we &
              ((addr_hit[ 0] & (|(HMAC_PERMIT[ 0] & ~reg_be))) |
               (addr_hit[ 1] & (|(HMAC_PERMIT[ 1] & ~reg_be))) |
               (addr_hit[ 2] & (|(HMAC_PERMIT[ 2] & ~reg_be))) |
               (addr_hit[ 3] & (|(HMAC_PERMIT[ 3] & ~reg_be))) |
               (addr_hit[ 4] & (|(HMAC_PERMIT[ 4] & ~reg_be))) |
               (addr_hit[ 5] & (|(HMAC_PERMIT[ 5] & ~reg_be))) |
               (addr_hit[ 6] & (|(HMAC_PERMIT[ 6] & ~reg_be))) |
               (addr_hit[ 7] & (|(HMAC_PERMIT[ 7] & ~reg_be))) |
               (addr_hit[ 8] & (|(HMAC_PERMIT[ 8] & ~reg_be))) |
               (addr_hit[ 9] & (|(HMAC_PERMIT[ 9] & ~reg_be))) |
               (addr_hit[10] & (|(HMAC_PERMIT[10] & ~reg_be))) |
               (addr_hit[11] & (|(HMAC_PERMIT[11] & ~reg_be))) |
               (addr_hit[12] & (|(HMAC_PERMIT[12] & ~reg_be))) |
               (addr_hit[13] & (|(HMAC_PERMIT[13] & ~reg_be))) |
               (addr_hit[14] & (|(HMAC_PERMIT[14] & ~reg_be))) |
               (addr_hit[15] & (|(HMAC_PERMIT[15] & ~reg_be))) |
               (addr_hit[16] & (|(HMAC_PERMIT[16] & ~reg_be))) |
               (addr_hit[17] & (|(HMAC_PERMIT[17] & ~reg_be))) |
               (addr_hit[18] & (|(HMAC_PERMIT[18] & ~reg_be))) |
               (addr_hit[19] & (|(HMAC_PERMIT[19] & ~reg_be))) |
               (addr_hit[20] & (|(HMAC_PERMIT[20] & ~reg_be))) |
               (addr_hit[21] & (|(HMAC_PERMIT[21] & ~reg_be))) |
               (addr_hit[22] & (|(HMAC_PERMIT[22] & ~reg_be))) |
               (addr_hit[23] & (|(HMAC_PERMIT[23] & ~reg_be))) |
               (addr_hit[24] & (|(HMAC_PERMIT[24] & ~reg_be))) |
               (addr_hit[25] & (|(HMAC_PERMIT[25] & ~reg_be))) |
               (addr_hit[26] & (|(HMAC_PERMIT[26] & ~reg_be))) |
               (addr_hit[27] & (|(HMAC_PERMIT[27] & ~reg_be))) |
               (addr_hit[28] & (|(HMAC_PERMIT[28] & ~reg_be))) |
               (addr_hit[29] & (|(HMAC_PERMIT[29] & ~reg_be))) |
               (addr_hit[30] & (|(HMAC_PERMIT[30] & ~reg_be))) |
               (addr_hit[31] & (|(HMAC_PERMIT[31] & ~reg_be))) |
               (addr_hit[32] & (|(HMAC_PERMIT[32] & ~reg_be))) |
               (addr_hit[33] & (|(HMAC_PERMIT[33] & ~reg_be))) |
               (addr_hit[34] & (|(HMAC_PERMIT[34] & ~reg_be))) |
               (addr_hit[35] & (|(HMAC_PERMIT[35] & ~reg_be))) |
               (addr_hit[36] & (|(HMAC_PERMIT[36] & ~reg_be))) |
               (addr_hit[37] & (|(HMAC_PERMIT[37] & ~reg_be))) |
               (addr_hit[38] & (|(HMAC_PERMIT[38] & ~reg_be))) |
               (addr_hit[39] & (|(HMAC_PERMIT[39] & ~reg_be))) |
               (addr_hit[40] & (|(HMAC_PERMIT[40] & ~reg_be))) |
               (addr_hit[41] & (|(HMAC_PERMIT[41] & ~reg_be))) |
               (addr_hit[42] & (|(HMAC_PERMIT[42] & ~reg_be))) |
               (addr_hit[43] & (|(HMAC_PERMIT[43] & ~reg_be))) |
               (addr_hit[44] & (|(HMAC_PERMIT[44] & ~reg_be))) |
               (addr_hit[45] & (|(HMAC_PERMIT[45] & ~reg_be))) |
               (addr_hit[46] & (|(HMAC_PERMIT[46] & ~reg_be))) |
               (addr_hit[47] & (|(HMAC_PERMIT[47] & ~reg_be))) |
               (addr_hit[48] & (|(HMAC_PERMIT[48] & ~reg_be))) |
               (addr_hit[49] & (|(HMAC_PERMIT[49] & ~reg_be))) |
               (addr_hit[50] & (|(HMAC_PERMIT[50] & ~reg_be))) |
               (addr_hit[51] & (|(HMAC_PERMIT[51] & ~reg_be))) |
               (addr_hit[52] & (|(HMAC_PERMIT[52] & ~reg_be))) |
               (addr_hit[53] & (|(HMAC_PERMIT[53] & ~reg_be))) |
               (addr_hit[54] & (|(HMAC_PERMIT[54] & ~reg_be))) |
               (addr_hit[55] & (|(HMAC_PERMIT[55] & ~reg_be))) |
               (addr_hit[56] & (|(HMAC_PERMIT[56] & ~reg_be))) |
               (addr_hit[57] & (|(HMAC_PERMIT[57] & ~reg_be))) |
               (addr_hit[58] & (|(HMAC_PERMIT[58] & ~reg_be)))));
  end

  // Generate write-enables
  assign intr_state_we = addr_hit[0] & reg_we & !reg_error;

  assign intr_state_hmac_done_wd = reg_wdata[0];

  assign intr_state_hmac_err_wd = reg_wdata[2];
  assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;

  assign intr_enable_hmac_done_wd = reg_wdata[0];

  assign intr_enable_fifo_empty_wd = reg_wdata[1];

  assign intr_enable_hmac_err_wd = reg_wdata[2];
  assign intr_test_we = addr_hit[2] & reg_we & !reg_error;

  assign intr_test_hmac_done_wd = reg_wdata[0];

  assign intr_test_fifo_empty_wd = reg_wdata[1];

  assign intr_test_hmac_err_wd = reg_wdata[2];
  assign alert_test_we = addr_hit[3] & reg_we & !reg_error;

  assign alert_test_wd = reg_wdata[0];
  assign cfg_re = addr_hit[4] & reg_re & !reg_error;
  assign cfg_we = addr_hit[4] & reg_we & !reg_error;

  assign cfg_hmac_en_wd = reg_wdata[0];

  assign cfg_sha_en_wd = reg_wdata[1];

  assign cfg_endian_swap_wd = reg_wdata[2];

  assign cfg_digest_swap_wd = reg_wdata[3];

  assign cfg_key_swap_wd = reg_wdata[4];

  assign cfg_digest_size_wd = reg_wdata[8:5];


  wire [5:0]  cfg_key_length_dec = reg_wdata[14:9];
  wire        cmd_start_bit      = reg_wdata[0];
  wire        cmd_process_bit    = reg_wdata[1];
  wire        cmd_stop_bit       = reg_wdata[2];
  wire        cmd_continue_bit   = reg_wdata[3];
  wire [31:0] full_wdata         = reg_wdata;

  assign cfg_key_length_wd   = cfg_key_length_dec;
  assign cmd_we              = (addr_hit[5]  && reg_we && !reg_error);
  assign status_re           = (addr_hit[6]  && reg_re && !reg_error);

  assign cmd_hash_start_wd    = cmd_start_bit;
  assign cmd_hash_process_wd  = cmd_process_bit;
  assign cmd_hash_stop_wd     = cmd_stop_bit;
  assign cmd_hash_continue_wd = cmd_continue_bit;

  // Ensures control path stability during specific bus error events
  assign wipe_secret_we      = (addr_hit[8]  && reg_we && reg_error);
  assign wipe_secret_wd      = full_wdata;

  assign key_0_we            = (addr_hit[9]  && reg_we && !reg_error);
  assign key_0_wd            = full_wdata;

  assign key_1_we            = (addr_hit[10] && reg_we && !reg_error);
  assign key_1_wd            = full_wdata;

  assign key_2_we            = (addr_hit[11] && reg_we && !reg_error);
  assign key_2_wd            = full_wdata;

  assign key_2_wd = reg_wdata[31:0];
  assign key_3_we = addr_hit[12] & reg_we & !reg_error;

  assign key_3_wd = reg_wdata[31:0];
  assign key_4_we = addr_hit[13] & reg_we & !reg_error;

  assign key_4_wd = reg_wdata[31:0];
  assign key_5_we = addr_hit[14] & reg_we & !reg_error;

  assign key_5_wd = reg_wdata[31:0];
  assign key_6_we = addr_hit[15] & reg_we & !reg_error;

  assign key_6_wd = reg_wdata[31:0];
  assign key_7_we = addr_hit[16] & reg_we & !reg_error;

  assign key_7_wd = reg_wdata[31:0];
  assign key_8_we = addr_hit[17] & reg_we & !reg_error;

  assign key_8_wd = reg_wdata[31:0];
  assign key_9_we = addr_hit[18] & reg_we & !reg_error;

  assign key_9_wd = reg_wdata[31:0];
  assign key_10_we = addr_hit[19] & reg_we & !reg_error;

  assign key_10_wd = reg_wdata[31:0];
  assign key_11_we = addr_hit[20] & reg_we & !reg_error;

  assign key_11_wd = reg_wdata[31:0];
  assign key_12_we = addr_hit[21] & reg_we & !reg_error;

  assign key_12_wd = reg_wdata[31:0];
  assign key_13_we = addr_hit[22] & reg_we & !reg_error;

  assign key_13_wd = reg_wdata[31:0];
  assign key_14_we = addr_hit[23] & reg_we & !reg_error;

  assign key_14_wd = reg_wdata[31:0];
  assign key_15_we = addr_hit[24] & reg_we & !reg_error;

  assign key_15_wd = reg_wdata[31:0];
  assign key_16_we = addr_hit[25] & reg_we & !reg_error;

  assign key_16_wd = reg_wdata[31:0];
  assign key_17_we = addr_hit[26] & reg_we & !reg_error;

  assign key_17_wd = reg_wdata[31:0];
  assign key_18_we = addr_hit[27] & reg_we & !reg_error;

  assign key_18_wd = reg_wdata[31:0];
  assign key_19_we = addr_hit[28] & reg_we & !reg_error;

  assign key_19_wd = reg_wdata[31:0];
  assign key_20_we = addr_hit[29] & reg_we & !reg_error;

  assign key_20_wd = reg_wdata[31:0];
  assign key_21_we = addr_hit[30] & reg_we & !reg_error;

  assign key_21_wd = reg_wdata[31:0];
  assign key_22_we = addr_hit[31] & reg_we & !reg_error;

  assign key_22_wd = reg_wdata[31:0];
  assign key_23_we = addr_hit[32] & reg_we & !reg_error;

  assign key_23_wd = reg_wdata[31:0];
  assign key_24_we = addr_hit[33] & reg_we & !reg_error;

  assign key_24_wd = reg_wdata[31:0];
  assign key_25_we = addr_hit[34] & reg_we & !reg_error;

  assign key_25_wd = reg_wdata[31:0];
  assign key_26_we = addr_hit[35] & reg_we & !reg_error;

  assign key_26_wd = reg_wdata[31:0];
  assign key_27_we = addr_hit[36] & reg_we & !reg_error;

  assign key_27_wd = reg_wdata[31:0];
  assign key_28_we = addr_hit[37] & reg_we & !reg_error;

  assign key_28_wd = reg_wdata[31:0];
  assign key_29_we = addr_hit[38] & reg_we & !reg_error;

  assign key_29_wd = reg_wdata[31:0];
  assign key_30_we = addr_hit[39] & reg_we & !reg_error;

  assign key_30_wd = reg_wdata[31:0];
  assign key_31_we = addr_hit[40] & reg_we & !reg_error;

  assign key_31_wd = reg_wdata[31:0];
  assign digest_0_re = addr_hit[41] & reg_re & !reg_error;
  assign digest_0_we = addr_hit[41] & reg_we & !reg_error;

  assign digest_0_wd = reg_wdata[31:0];
  assign digest_1_re = addr_hit[42] & reg_re & !reg_error;
  assign digest_1_we = addr_hit[42] & reg_we & !reg_error;

  assign digest_1_wd = reg_wdata[31:0];
  assign digest_2_re = addr_hit[43] & reg_re & !reg_error;
  assign digest_2_we = addr_hit[43] & reg_we & !reg_error;

  assign digest_2_wd = reg_wdata[31:0];
  assign digest_3_re = addr_hit[44] & reg_re & !reg_error;
  assign digest_3_we = addr_hit[44] & reg_we & !reg_error;

  assign digest_3_wd = reg_wdata[31:0];
  assign digest_4_re = addr_hit[45] & reg_re & !reg_error;
  assign digest_4_we = addr_hit[45] & reg_we & !reg_error;

  assign digest_4_wd = reg_wdata[31:0];
  assign digest_5_re = addr_hit[46] & reg_re & !reg_error;
  assign digest_5_we = addr_hit[46] & reg_we & !reg_error;

  assign digest_5_wd = reg_wdata[31:0];
  assign digest_6_re = addr_hit[47] & reg_re & !reg_error;
  assign digest_6_we = addr_hit[47] & reg_we & !reg_error;

  assign digest_6_wd = reg_wdata[31:0];
  assign digest_7_re = addr_hit[48] & reg_re & !reg_error;
  assign digest_7_we = addr_hit[48] & reg_we & !reg_error;

  assign digest_7_wd = reg_wdata[31:0];
  assign digest_8_re = addr_hit[49] & reg_re & !reg_error;
  assign digest_8_we = addr_hit[49] & reg_we & !reg_error;

  assign digest_8_wd = reg_wdata[31:0];
  assign digest_9_re = addr_hit[50] & reg_re & !reg_error;
  assign digest_9_we = addr_hit[50] & reg_we & !reg_error;

  assign digest_9_wd = reg_wdata[31:0];
  assign digest_10_re = addr_hit[51] & reg_re & !reg_error;
  assign digest_10_we = addr_hit[51] & reg_we & !reg_error;

  assign digest_10_wd = reg_wdata[31:0];
  assign digest_11_re = addr_hit[52] & reg_re & !reg_error;
  assign digest_11_we = addr_hit[52] & reg_we & !reg_error;

  assign digest_11_wd = reg_wdata[31:0];
  assign digest_12_re = addr_hit[53] & reg_re & !reg_error;
  assign digest_12_we = addr_hit[53] & reg_we & !reg_error;

  assign digest_12_wd = reg_wdata[31:0];
  assign digest_13_re = addr_hit[54] & reg_re & !reg_error;
  assign digest_13_we = addr_hit[54] & reg_we & !reg_error;

  assign digest_13_wd = reg_wdata[31:0];
  assign digest_14_re = addr_hit[55] & reg_re & !reg_error;
  assign digest_14_we = addr_hit[55] & reg_we & !reg_error;

  assign digest_14_wd = reg_wdata[31:0];
  assign digest_15_re = addr_hit[56] & reg_re & !reg_error;
  assign digest_15_we = addr_hit[56] & reg_we & !reg_error;

  assign digest_15_wd = reg_wdata[31:0];
  assign msg_length_lower_re = addr_hit[57] & reg_re & !reg_error;
  assign msg_length_lower_we = addr_hit[57] & reg_we & !reg_error;

  assign msg_length_lower_wd = reg_wdata[31:0];
  assign msg_length_upper_re = addr_hit[58] & reg_re & !reg_error;
  assign msg_length_upper_we = addr_hit[58] & reg_we & !reg_error;

  assign msg_length_upper_wd = reg_wdata[31:0];

  // Assign write-enables to checker logic vector.
  always_comb begin
    reg_we_check[0] = intr_state_we;
    reg_we_check[1] = intr_enable_we;
    reg_we_check[2] = intr_test_we;
    reg_we_check[3] = alert_test_we;
    reg_we_check[4] = cfg_we;
    reg_we_check[5] = cmd_we;
    reg_we_check[6] = 1'b0;
    reg_we_check[7] = 1'b0;
    reg_we_check[8] = wipe_secret_we;
    reg_we_check[9] = key_0_we;
    reg_we_check[10] = key_1_we;
    reg_we_check[11] = key_2_we;
    reg_we_check[12] = key_3_we;
    reg_we_check[13] = key_4_we;
    reg_we_check[14] = key_5_we;
    reg_we_check[15] = key_6_we;
    reg_we_check[16] = key_7_we;
    reg_we_check[17] = key_8_we;
    reg_we_check[18] = key_9_we;
    reg_we_check[19] = key_10_we;
    reg_we_check[20] = key_11_we;
    reg_we_check[21] = key_12_we;
    reg_we_check[22] = key_13_we;
    reg_we_check[23] = key_14_we;
    reg_we_check[24] = key_15_we;
    reg_we_check[25] = key_16_we;
    reg_we_check[26] = key_17_we;
    reg_we_check[27] = key_18_we;
    reg_we_check[28] = key_19_we;
    reg_we_check[29] = key_20_we;
    reg_we_check[30] = key_21_we;
    reg_we_check[31] = key_22_we;
    reg_we_check[32] = key_23_we;
    reg_we_check[33] = key_24_we;
    reg_we_check[34] = key_25_we;
    reg_we_check[35] = key_26_we;
    reg_we_check[36] = key_27_we;
    reg_we_check[37] = key_28_we;
    reg_we_check[38] = key_29_we;
    reg_we_check[39] = key_30_we;
    reg_we_check[40] = key_31_we;
    reg_we_check[41] = digest_0_we;
    reg_we_check[42] = digest_1_we;
    reg_we_check[43] = digest_2_we;
    reg_we_check[44] = digest_3_we;
    reg_we_check[45] = digest_4_we;
    reg_we_check[46] = digest_5_we;
    reg_we_check[47] = digest_6_we;
    reg_we_check[48] = digest_7_we;
    reg_we_check[49] = digest_8_we;
    reg_we_check[50] = digest_9_we;
    reg_we_check[51] = digest_10_we;
    reg_we_check[52] = digest_11_we;
    reg_we_check[53] = digest_12_we;
    reg_we_check[54] = digest_13_we;
    reg_we_check[55] = digest_14_we;
    reg_we_check[56] = digest_15_we;
    reg_we_check[57] = msg_length_lower_we;
    reg_we_check[58] = msg_length_upper_we;
  end

  // Read data return
  always_comb begin
    reg_rdata_next = '0;
    unique case (1'b1)
      addr_hit[0]: begin
        reg_rdata_next[0] = intr_state_hmac_done_qs;
        reg_rdata_next[1] = intr_state_fifo_empty_qs;
        reg_rdata_next[2] = intr_state_hmac_err_qs;
      end

      addr_hit[1]: begin
        reg_rdata_next[0] = intr_enable_hmac_done_qs;
        reg_rdata_next[1] = intr_enable_fifo_empty_qs;
        reg_rdata_next[2] = intr_enable_hmac_err_qs;
      end

      addr_hit[2]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
        reg_rdata_next[2] = '0;
      end

      addr_hit[3]: begin
        reg_rdata_next[0] = '0;
      end

      addr_hit[4]: begin
        reg_rdata_next[0] = cfg_hmac_en_qs;
        reg_rdata_next[1] = cfg_sha_en_qs;
        reg_rdata_next[2] = cfg_endian_swap_qs;
        reg_rdata_next[3] = cfg_digest_swap_qs;
        reg_rdata_next[4] = cfg_key_swap_qs;
        reg_rdata_next[8:5] = cfg_digest_size_qs;
        reg_rdata_next[14:9] = cfg_key_length_qs;
      end

      addr_hit[5]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
        reg_rdata_next[2] = '0;
        reg_rdata_next[3] = '0;
      end

      addr_hit[6]: begin
        reg_rdata_next[0] = status_hmac_idle_qs;
        reg_rdata_next[1] = status_fifo_empty_qs;
        reg_rdata_next[2] = status_fifo_full_qs;
        reg_rdata_next[9:4] = status_fifo_depth_qs;
      end

      addr_hit[7]: begin
        reg_rdata_next[31:0] = err_code_qs;
      end
      
      addr_hit[8]: begin
        reg_rdata_next[31:0] = reg2hw.key[0].q;
      end

      addr_hit[9]: begin
        reg_rdata_next[31:0] = reg2hw.key[1].q;
      end

      addr_hit[10]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[11]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[12]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[13]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[14]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[15]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[16]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[17]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[18]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[19]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[20]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[21]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[22]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[23]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[24]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[25]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[26]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[27]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[28]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[29]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[30]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[31]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[32]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[33]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[34]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[35]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[36]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[37]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[38]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[39]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[40]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[41]: begin
        reg_rdata_next[31:0] = digest_0_qs;
      end

      addr_hit[42]: begin
        reg_rdata_next[31:0] = digest_1_qs;
      end

      addr_hit[43]: begin
        reg_rdata_next[31:0] = digest_2_qs;
      end

      addr_hit[44]: begin
        reg_rdata_next[31:0] = digest_3_qs;
      end

      addr_hit[45]: begin
        reg_rdata_next[31:0] = digest_4_qs;
      end

      addr_hit[46]: begin
        reg_rdata_next[31:0] = digest_5_qs;
      end

      addr_hit[47]: begin
        reg_rdata_next[31:0] = digest_6_qs;
      end

      addr_hit[48]: begin
        reg_rdata_next[31:0] = digest_7_qs;
      end

      addr_hit[49]: begin
        reg_rdata_next[31:0] = digest_8_qs;
      end

      addr_hit[50]: begin
        reg_rdata_next[31:0] = digest_9_qs;
      end

      addr_hit[51]: begin
        reg_rdata_next[31:0] = digest_10_qs;
      end

      addr_hit[52]: begin
        reg_rdata_next[31:0] = digest_11_qs;
      end

      addr_hit[53]: begin
        reg_rdata_next[31:0] = digest_12_qs;
      end

      addr_hit[54]: begin
        reg_rdata_next[31:0] = digest_13_qs;
      end

      addr_hit[55]: begin
        reg_rdata_next[31:0] = digest_14_qs;
      end

      addr_hit[56]: begin
        reg_rdata_next[31:0] = digest_15_qs;
      end

      addr_hit[57]: begin
        reg_rdata_next[31:0] = msg_length_lower_qs;
      end

      addr_hit[58]: begin
        reg_rdata_next[31:0] = msg_length_upper_qs;
      end

      default: begin
        reg_rdata_next = reg2hw.key[2].q;
      end
    endcase
  end

  // shadow busy
  logic shadow_busy;
  assign shadow_busy = 1'b0;

  // register busy
  assign reg_busy = shadow_busy;

  // Unused signal tieoff

  // wdata / byte enable are not always fully used
  // add a blanket unused statement to handle lint waivers
  logic unused_wdata;
  logic unused_be;
  assign unused_wdata = ^reg_wdata;
  assign unused_be = ^reg_be;

  // Assertions for Register Interface
  `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
  `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)

  `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)

  `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)

  // this is formulated as an assumption such that the FPV testbenches do disprove this
  // property by mistake
  //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)

endmodule


    """


    Identify the CWE relevant to the security issue for the given RTL.
    Obtain details of the CWE.

    Then determine if there are security issues relevant to the identified CWE in the RTL.
    Refer to the code that corresponds to the issues identified.
    
================================== Ai Message ==================================

[{'text': "I'll analyze the provided RTL code for security issues related to register access control, write-only secrets, and information disclosure. Let me start by identifying the relevant CWEs for these security concerns.", 'type': 'text'}, {'id': 'toolu_018ruRPdisoFgv3BaYJeX7gH', 'input': {'security_issue': 'register access control insufficient privilege verification'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_018ruRPdisoFgv3BaYJeX7gH)
 Call ID: toolu_018ruRPdisoFgv3BaYJeX7gH
  Args:
    security_issue: register access control insufficient privilege verification
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1220: Insufficient Granularity of Access Control
The product implements access controls via a policy or other feature with the intention to disable or restrict accesses (reads and/or writes) to assets in a system from untrusted agents. However, implemented access controls lack required granularity, which renders the control policy too broad because it allows accesses from unauthorized agents to the security-sensitive assets.
Integrated circuits and hardware engines can expose accesses to assets (device configuration, keys, etc.) to trusted firmware or a software module (commonly set by BIOS/bootloader). This access is typically access-controlled. Upon a power reset, the hardware or system usually starts with default values in registers, and the trusted firmware (Boot firmware) configures the necessary access-control protection.
Example 1
Consider a system with a register for storing AES key for encryption or decryption. The key is 128 bits, implemented as a set of four 32-bit registers. The key registers are assets and registers, AES_KEY_READ_POLICY and AES_KEY_WRITE_POLICY, and are defined to provide necessary access controls. The read-policy register defines which agents can read the AES-key registers, and write-policy register defines which agents can program or write to those registers. Each register is a 32-bit register, and it can support access control for a maximum of 32 agents. The number of the bit when set (i.e., "1") allows respective action from an agent whose identity matches the number of the bit and, if "0" (i.e., Clear), disallows the respective action to that corresponding agent.
(bad code)
Example Language: Other
Register Field description AES_ENC_DEC_KEY_0 AES key [0:31] for encryption or decryption Default 0x00000000 AES_ENC_DEC_KEY_1 AES key [32:63] for encryption or decryption Default 0x00000000 AES_ENC_DEC_KEY_2 AES key [64:95] for encryption or decryption Default 0x00000000 AES_ENC_DEC_KEY_4 AES key [96:127] for encryption or decryption Default 0x00000000 AES_KEY_READ_WRITE_POLICY [31:0] Default 0x00000006 - meaning agent with identities "1" and "2" can both read from and write to key registers In the above example, there is only one policy register that controls access to both read and write accesses to the AES-key registers, and thus the design is not granular enough to separate read and writes access for different agents. Here, agent with identities "1" and "2" can both read and write. A good design should be granular enough to provide separate access controls to separate actions. Access control for reads should be separate from writes. Below is an example of such implementation where two policy registers are defined for each of these actions. The policy is defined such that: the AES-key registers can only be read or used by a crypto agent with identity "1" when bit #1 is set. The AES-key registers can only be programmed by a trusted firmware with identity "2" when bit #2 is set.
(good code)
Example Language: Other
AES_KEY_READ_POLICY [31:0] Default 0x00000002 - meaning only Crypto engine with identity "1" can read registers: AES_ENC_DEC_KEY_0, AES_ENC_DEC_KEY_1, AES_ENC_DEC_KEY_2, AES_ENC_DEC_KEY_3 AES_KEY_WRITE_POLICY [31:0] Default 0x00000004 - meaning only trusted firmware with identity "2" can program registers: AES_ENC_DEC_KEY_0, AES_ENC_DEC_KEY_1, AES_ENC_DEC_KEY_2, AES_ENC_DEC_KEY_3

Example 2
Within the AXI node interface wrapper module in the RISC-V AXI module of the HACK@DAC'19 CVA6 SoC, an access control mechanism is employed to regulate the access of different privileged users to peripherals. The AXI ensures that only users with appropriate privileges can access specific peripherals. For instance, a ROM module is accessible exclusively with Machine privilege, and AXI enforces that users attempting to read data from the ROM must possess machine privilege; otherwise, access to the ROM is denied. The access control information and configurations are stored in a ROM.
(bad code)
Example Language: Verilog
...
for (i=0; i<NB_SUBORDINATE; i++)
begin
for (j=0; j<NB_MANAGER; j++)
begin
assign connectivity_map_o[i][j] = access_ctrl_i[i][j][priv_lvl_i] || ((j==6) && access_ctrl_i[i][7][priv_lvl_i]);
end
end
...
However, in the example code above, while assigning distinct privileges to AXI manager and subordinates, both the Platform-Level Interrupt Controller Specification (PLIC) and the Core-local Interrupt Controller (CLINT) (which are peripheral numbers 6 and 7 respectively) utilize the same access control configuration. This common configuration diminishes the granularity of the AXI access control mechanism. In certain situations, it might be necessary to grant higher privileges for accessing the PLIC than those required for accessing the CLINT. Unfortunately, this differentiation is overlooked, allowing an attacker to access the PLIC with lower privileges than intended. As a consequence, unprivileged code can read and write to the PLIC even when it was not intended to do so. In the worst-case scenario, the attacker could manipulate interrupt priorities, potentially modifying the system's behavior or availability. To address the aforementioned vulnerability, developers must enhance the AXI access control granularity by implementing distinct access control entries for the Platform-Level Interrupt Controller (PLIC) and the Core-local Interrupt Controller (CLINT). By doing so, different privilege levels can be defined for accessing PLIC and CLINT, effectively thwarting the potential attacks previously highlighted. This approach ensures a more robust and secure system, safeguarding against unauthorized access and manipulation of interrupt priorities.
(good code)
Example Language: Verilog
...
for (i=0; i<NB_SUBORDINATE; i++)
begin
for (j=0; j<NB_MANAGER; j++)
begin
assign connectivity_map_o[i][j] = access_ctrl_i[i][j][priv_lvl_i];
end
end
...

Example 3
Consider the following SoC design. The sram in HRoT has an address range that is readable and writable by unprivileged software and it has an area that is only readable by unprivileged software. The tbus interconnect enforces access control for subordinates on the bus but uses only one bit to control both read and write access. Address 0xA0000000 - 0xA000FFFF is readable and writable by the untrusted cores core{0-N} and address 0xA0010000 - 0xA001FFFF is only readable by the untrusted cores core{0-N}. The security policy access control is not granular enough, as it uses one bit to enable both read and write access. This gives write access to an area that should only be readable by unprivileged agents. Access control logic should differentiate between read and write access and to have sufficient address granularity.


================================== Ai Message ==================================

[{'id': 'toolu_01MZ7SvsdK4ab3Ti5qnVhmrA', 'input': {'security_issue': 'write-only secrets information disclosure through read access'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01MZ7SvsdK4ab3Ti5qnVhmrA)
 Call ID: toolu_01MZ7SvsdK4ab3Ti5qnVhmrA
  Args:
    security_issue: write-only secrets information disclosure through read access
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1282: Assumed-Immutable Data is Stored in Writable Memory
Immutable data, such as a first-stage bootloader, device identifiers, and "write-once" configuration settings are stored in writable memory that can be re-programmed or updated in the field.
Security services such as secure boot, authentication of code and data, and device attestation all require assets such as the first stage bootloader, public keys, golden hash digests, etc. which are implicitly trusted. Storing these assets in read-only memory (ROM), fuses, or one-time programmable (OTP) memory provides strong integrity guarantees and provides a root of trust for securing the rest of the system. Security is lost if assets assumed to be immutable can be modified.
Example 1
Cryptographic hash functions are commonly used to create unique fixed-length digests used to ensure the integrity of code and keys. A golden digest is stored on the device and compared to the digest computed from the data to be verified. If the digests match, the data has not been maliciously modified. If an attacker can modify the golden digest they then have the ability to store arbitrary data that passes the verification check. Hash digests used to verify public keys and early stage boot code should be immutable, with the strongest protection offered by hardware immutability.
================================== Ai Message ==================================

[{'id': 'toolu_01ExQYEr6FWf4PtNfc4DWRMv', 'input': {'security_issue': 'information disclosure through register read access'}, 'name': 'llm_cwe_details_retriever_tool', 'type': 'tool_use'}]
Tool Calls:
  llm_cwe_details_retriever_tool (toolu_01ExQYEr6FWf4PtNfc4DWRMv)
 Call ID: toolu_01ExQYEr6FWf4PtNfc4DWRMv
  Args:
    security_issue: information disclosure through register read access
================================= Tool Message =================================
Name: llm_cwe_details_retriever_tool

Successfully executed:
```LLM CWE details retriever tool
```
Output:
 CWE-1262: Improper Access Control for Register Interface
The product uses memory-mapped I/O registers that act as an interface to hardware functionality from software, but there is improper access control to those registers.
Software commonly accesses peripherals in a System-on-Chip (SoC) or other device through a memory-mapped register interface. Malicious software could tamper with any security-critical hardware data that is accessible directly or indirectly through the register interface, which could lead to a loss of confidentiality and integrity.
Example 1
The register interface provides software access to hardware functionality. This functionality is an attack surface. This attack surface may be used to run untrusted code on the system through the register interface. As an example, cryptographic accelerators require a mechanism for software to select modes of operation and to provide plaintext or ciphertext data to be encrypted or decrypted as well as other functions. This functionality is commonly provided through registers.
(bad code)
Cryptographic key material stored in registers inside the cryptographic accelerator can be accessed by software.
(good code)
Key material stored in registers should never be accessible to software. Even if software can provide a key, all read-back paths to software should be disabled.

Example 2
The example code is taken from the Control/Status Register (CSR) module inside the processor core of the HACK@DAC'19 buggy CVA6 SoC. In RISC-V ISA, the CSR file contains different sets of registers with different privilege levels, e.g., user mode (U), supervisor mode (S), hypervisor mode (H), machine mode (M), and debug mode (D), with different read-write policies, read-only (RO) and read-write (RW). For example, machine mode, which is the highest privilege mode in a RISC-V system, registers should not be accessible in user, supervisor, or hypervisor modes.
(bad code)
Example Language: Verilog
if (csr_we || csr_read) begin
if ((riscv::priv_lvl_t'(priv_lvl_o & csr_addr.csr_decode.priv_lvl) != csr_addr.csr_decode.priv_lvl) && !(csr_addr.address==riscv::CSR_MEPC)) begin
csr_exception_o.cause = riscv::ILLEGAL_INSTR;
csr_exception_o.valid = 1'b1;
end
// check access to debug mode only CSRs
if (csr_addr_i[11:4] == 8'h7b && !debug_mode_q) begin
csr_exception_o.cause = riscv::ILLEGAL_INSTR;
csr_exception_o.valid = 1'b1;
end
end
The vulnerable example code allows the machine exception program counter (MEPC) register to be accessed from a user mode program by excluding the MEPC from the access control check. MEPC as per the RISC-V specification can be only written or read by machine mode code. Thus, the attacker in the user mode can run code in machine mode privilege (privilege escalation). To mitigate the issue, fix the privilege check so that it throws an Illegal Instruction Exception for user mode accesses to the MEPC register.
(good code)
Example Language: Verilog
if (csr_we || csr_read) begin
if ((riscv::priv_lvl_t'(priv_lvl_o & csr_addr.csr_decode.priv_lvl) != csr_addr.csr_decode.priv_lvl)) begin
csr_exception_o.cause = riscv::ILLEGAL_INSTR;
csr_exception_o.valid = 1'b1;
end
// check access to debug mode only CSRs
if (csr_addr_i[11:4] == 8'h7b && !debug_mode_q) begin
csr_exception_o.cause = riscv::ILLEGAL_INSTR;
csr_exception_o.valid = 1'b1;
end
end


================================== Ai Message ==================================

Now let me analyze the RTL code for security issues related to these CWEs:

## Security Analysis of the HMAC Register RTL

Based on the CWE analysis and examination of the RTL code, I've identified several security concerns:

### 1. **CWE-1262: Improper Access Control for Register Interface**

**Issue 1: Key Registers Allow Read Access (Information Disclosure)**
The key registers (key_0 through key_31) are implemented as write-only registers but have a critical flaw in the read data return logic:

```verilog
// Lines 1881-1888 - Problematic read access to key registers
addr_hit[8]: begin
  reg_rdata_next[31:0] = reg2hw.key[0].q;  // Exposes key[0]
end

addr_hit[9]: begin
  reg_rdata_next[31:0] = reg2hw.key[1].q;  // Exposes key[1]
end

addr_hit[10]: begin
  reg_rdata_next[31:0] = '0;  // Correctly returns 0
end
```

**Security Problem**: The first two key registers (key_0 and key_1) return their actual stored values when read, while the remaining key registers (key_2 through key_31) correctly return zeros. This inconsistency creates an information disclosure vulnerability where cryptographic key material can be read back by software.

**Issue 2: Inconsistent Write-Only Implementation**
```verilog
// Lines 1010-1012 - Key registers defined as write-only but readable
prim_subreg_ext #(
  .DW    (32)
) u_key_0 (
  .re     (1'b0),  // Read enable tied to 0 (write-only)
  .we     (key_0_we),
  // ... but read data is still exposed in the mux
```

### 2. **CWE-1220: Insufficient Granularity of Access Control**

**Issue 3: Lack of Privilege-Based Access Control**
The register interface lacks any privilege level checking mechanism. All registers are accessible with the same access level, which violates the principle of least privilege:

```verilog
// No privilege level checking in the access control logic
assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;
```

**Issue 4: Single Error Condition for All Access Violations**
```verilog
assign reg_error = addrmiss | wr_err | intg_err;
```
The access control only checks for address misses and write errors, but doesn't differentiate between different types of security violations or privilege levels.

### 3. **CWE-1282: Write-Only Secrets in Writable Memory**

**Issue 5: Wipe Secret Register Behavior**
```verilog
// Lines 1847-1849 - Suspicious wipe_secret implementation
assign wipe_secret_we = (addr_hit[8] && reg_we && reg_error);
```
The wipe_secret register is only written when there's a register error, which is unusual and potentially problematic for security.

### 4. **Additional Security Concerns**

**Issue 6: Default Case Information Disclosure**
```verilog
// Lines 2019-2021 - Default case exposes key data
default: begin
  reg_rdata_next = reg2hw.key[2].q;  // Exposes key[2] on invalid addresses
end
```

## Recommendations

1. **Fix Key Register Read Access**: Ensure all key registers return zeros when read:
```verilog
addr_hit[8]: begin
  reg_rdata_next[31:0] = '0;  // Should return 0, not key[0]
end

addr_hit[9]: begin
  reg_rdata_next[31:0] = '0;  // Should return 0, not key[1]
end
```

2. **Implement Privilege-Based Access Control**: Add privilege level checking for sensitive registers.

3. **Fix Default Case**: The default case should return zeros, not key material.

4. **Add Separate Read/Write Policies**: Implement granular access control with separate read and write permissions for different
================================= Tool Message =================================
Name: run_llm_cwe_checker_agent

Now let me analyze the RTL code for security issues related to these CWEs:

## Security Analysis of the HMAC Register RTL

Based on the CWE analysis and examination of the RTL code, I've identified several security concerns:

### 1. **CWE-1262: Improper Access Control for Register Interface**

**Issue 1: Key Registers Allow Read Access (Information Disclosure)**
The key registers (key_0 through key_31) are implemented as write-only registers but have a critical flaw in the read data return logic:

```verilog
// Lines 1881-1888 - Problematic read access to key registers
addr_hit[8]: begin
  reg_rdata_next[31:0] = reg2hw.key[0].q;  // Exposes key[0]
end

addr_hit[9]: begin
  reg_rdata_next[31:0] = reg2hw.key[1].q;  // Exposes key[1]
end

addr_hit[10]: begin
  reg_rdata_next[31:0] = '0;  // Correctly returns 0
end
```

**Security Problem**: The first two key registers (key_0 and key_1) return their actual stored values when read, while the remaining key registers (key_2 through key_31) correctly return zeros. This inconsistency creates an information disclosure vulnerability where cryptographic key material can be read back by software.

**Issue 2: Inconsistent Write-Only Implementation**
```verilog
// Lines 1010-1012 - Key registers defined as write-only but readable
prim_subreg_ext #(
  .DW    (32)
) u_key_0 (
  .re     (1'b0),  // Read enable tied to 0 (write-only)
  .we     (key_0_we),
  // ... but read data is still exposed in the mux
```

### 2. **CWE-1220: Insufficient Granularity of Access Control**

**Issue 3: Lack of Privilege-Based Access Control**
The register interface lacks any privilege level checking mechanism. All registers are accessible with the same access level, which violates the principle of least privilege:

```verilog
// No privilege level checking in the access control logic
assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;
```

**Issue 4: Single Error Condition for All Access Violations**
```verilog
assign reg_error = addrmiss | wr_err | intg_err;
```
The access control only checks for address misses and write errors, but doesn't differentiate between different types of security violations or privilege levels.

### 3. **CWE-1282: Write-Only Secrets in Writable Memory**

**Issue 5: Wipe Secret Register Behavior**
```verilog
// Lines 1847-1849 - Suspicious wipe_secret implementation
assign wipe_secret_we = (addr_hit[8] && reg_we && reg_error);
```
The wipe_secret register is only written when there's a register error, which is unusual and potentially problematic for security.

### 4. **Additional Security Concerns**

**Issue 6: Default Case Information Disclosure**
```verilog
// Lines 2019-2021 - Default case exposes key data
default: begin
  reg_rdata_next = reg2hw.key[2].q;  // Exposes key[2] on invalid addresses
end
```

## Recommendations

1. **Fix Key Register Read Access**: Ensure all key registers return zeros when read:
```verilog
addr_hit[8]: begin
  reg_rdata_next[31:0] = '0;  // Should return 0, not key[0]
end

addr_hit[9]: begin
  reg_rdata_next[31:0] = '0;  // Should return 0, not key[1]
end
```

2. **Implement Privilege-Based Access Control**: Add privilege level checking for sensitive registers.

3. **Fix Default Case**: The default case should return zeros, not key material.

4. **Add Separate Read/Write Policies**: Implement granular access control with separate read and write permissions for different
================================== Ai Message ==================================
Tool Calls:
  run_anomaly_detector_agent (call_LbVJxW8dBPizsdYFe5Y2Ps0v)
 Call ID: call_LbVJxW8dBPizsdYFe5Y2Ps0v
  Args:
    design_filepath: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv
    top_module: hmac_reg_top
    security_objective: write-only secret CSRs, readback muxing, privilege checks, wipe secret gating
================================ Human Message =================================

Are there security concerns related to write-only secret CSRs, readback muxing, privilege checks, wipe secret gating in the provided RTL:
    The design filepath is:

    /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Register Top module auto-generated by `reggen`

`include "prim_assert.sv"

module hmac_reg_top (
  input clk_i,
  input rst_ni,
  input  tlul_pkg::tl_h2d_t tl_i,
  output tlul_pkg::tl_d2h_t tl_o,

  // Output port for window
  output tlul_pkg::tl_h2d_t tl_win_o,
  input  tlul_pkg::tl_d2h_t tl_win_i,

  // To HW
  output hmac_reg_pkg::hmac_reg2hw_t reg2hw, // Write
  input  hmac_reg_pkg::hmac_hw2reg_t hw2reg, // Read

  // Integrity check errors
  output logic intg_err_o
);

  import hmac_reg_pkg::* ;

  localparam int AW = 13;
  localparam int DW = 32;
  localparam int DBW = DW/8;                    // Byte Width

  // register signals
  logic           reg_we;
  logic           reg_re;
  logic [AW-1:0]  reg_addr;
  logic [DW-1:0]  reg_wdata;
  logic [DBW-1:0] reg_be;
  logic [DW-1:0]  reg_rdata;
  logic           reg_error;

  logic          addrmiss, wr_err;

  logic [DW-1:0] reg_rdata_next;
  logic reg_busy;

  tlul_pkg::tl_h2d_t tl_reg_h2d;
  tlul_pkg::tl_d2h_t tl_reg_d2h;


  // incoming payload check
  logic intg_err;
  tlul_cmd_intg_chk u_chk (
    .tl_i(tl_i),
    .err_o(intg_err)
  );

  // also check for spurious write enables
  logic reg_we_err;
  logic [58:0] reg_we_check;
  prim_reg_we_check #(
    .OneHotWidth(59)
  ) u_prim_reg_we_check (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .oh_i  (reg_we_check),
    .en_i  (reg_we && !addrmiss),
    .err_o (reg_we_err)
  );

  logic err_q;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      err_q <= '0;
    end else if (intg_err || reg_we_err) begin
      err_q <= 1'b1;
    end
  end

  // integrity error output is permanent and should be used for alert generation
  // register errors are transactional
  assign intg_err_o = err_q | intg_err | reg_we_err;

  // outgoing integrity generation
  tlul_pkg::tl_d2h_t tl_o_pre;
  tlul_rsp_intg_gen #(
    .EnableRspIntgGen(1),
    .EnableDataIntgGen(1)
  ) u_rsp_intg_gen (
    .tl_i(tl_o_pre),
    .tl_o(tl_o)
  );

  tlul_pkg::tl_h2d_t tl_socket_h2d [2];
  tlul_pkg::tl_d2h_t tl_socket_d2h [2];

  logic [0:0] reg_steer;

  // socket_1n connection
  assign tl_reg_h2d = tl_socket_h2d[1];
  assign tl_socket_d2h[1] = tl_reg_d2h;

  assign tl_win_o = tl_socket_h2d[0];
  assign tl_socket_d2h[0] = tl_win_i;

  // Create Socket_1n
  tlul_socket_1n #(
    .N            (2),
    .HReqPass     (1'b1),
    .HRspPass     (1'b1),
    .DReqPass     ({2{1'b1}}),
    .DRspPass     ({2{1'b1}}),
    .HReqDepth    (4'h0),
    .HRspDepth    (4'h0),
    .DReqDepth    ({2{4'h0}}),
    .DRspDepth    ({2{4'h0}}),
    .ExplicitErrs (1'b0)
  ) u_socket (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),
    .tl_h_i (tl_i),
    .tl_h_o (tl_o_pre),
    .tl_d_o (tl_socket_h2d),
    .tl_d_i (tl_socket_d2h),
    .dev_select_i (reg_steer)
  );

  // Create steering logic
  always_comb begin
    reg_steer =
        tl_i.a_address[AW-1:0] inside {[4096:8191]} ? 1'd0 :
        // Default set to register
        1'd1;

    // Override this in case of an integrity error
    if (intg_err) begin
      reg_steer = 1'd1;
    end
  end

  tlul_adapter_reg #(
    .RegAw(AW),
    .RegDw(DW),
    .EnableDataIntgGen(0)
  ) u_reg_if (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),

    .tl_i (tl_reg_h2d),
    .tl_o (tl_reg_d2h),

    .en_ifetch_i(prim_mubi_pkg::MuBi4False),
    .intg_error_o(),

    .we_o    (reg_we),
    .re_o    (reg_re),
    .addr_o  (reg_addr),
    .wdata_o (reg_wdata),
    .be_o    (reg_be),
    .busy_i  (reg_busy),
    .rdata_i (reg_rdata),
    .error_i (reg_error)
  );

  // cdc oversampling signals

  assign reg_rdata = reg_rdata_next ;
  assign reg_error = addrmiss | wr_err | intg_err;

  // Define SW related signals
  // Format: <reg>_<field>_{wd|we|qs}
  //        or <reg>_{wd|we|qs} if field == 1 or 0
  logic intr_state_we;
  logic intr_state_hmac_done_qs;
  logic intr_state_hmac_done_wd;
  logic intr_state_fifo_empty_qs;
  logic intr_state_hmac_err_qs;
  logic intr_state_hmac_err_wd;
  logic intr_enable_we;
  logic intr_enable_hmac_done_qs;
  logic intr_enable_hmac_done_wd;
  logic intr_enable_fifo_empty_qs;
  logic intr_enable_fifo_empty_wd;
  logic intr_enable_hmac_err_qs;
  logic intr_enable_hmac_err_wd;
  logic intr_test_we;
  logic intr_test_hmac_done_wd;
  logic intr_test_fifo_empty_wd;
  logic intr_test_hmac_err_wd;
  logic alert_test_we;
  logic alert_test_wd;
  logic cfg_re;
  logic cfg_we;
  logic cfg_hmac_en_qs;
  logic cfg_hmac_en_wd;
  logic cfg_sha_en_qs;
  logic cfg_sha_en_wd;
  logic cfg_endian_swap_qs;
  logic cfg_endian_swap_wd;
  logic cfg_digest_swap_qs;
  logic cfg_digest_swap_wd;
  logic cfg_key_swap_qs;
  logic cfg_key_swap_wd;
  logic [3:0] cfg_digest_size_qs;
  logic [3:0] cfg_digest_size_wd;
  logic [5:0] cfg_key_length_qs;
  logic [5:0] cfg_key_length_wd;
  logic cmd_we;
  logic cmd_hash_start_wd;
  logic cmd_hash_process_wd;
  logic cmd_hash_stop_wd;
  logic cmd_hash_continue_wd;
  logic status_re;
  logic status_hmac_idle_qs;
  logic status_fifo_empty_qs;
  logic status_fifo_full_qs;
  logic [5:0] status_fifo_depth_qs;
  logic [31:0] err_code_qs;
  logic wipe_secret_we;
  logic [31:0] wipe_secret_wd;
  logic key_0_we;
  logic [31:0] key_0_wd;
  logic key_1_we;
  logic [31:0] key_1_wd;
  logic key_2_we;
  logic [31:0] key_2_wd;
  logic key_3_we;
  logic [31:0] key_3_wd;
  logic key_4_we;
  logic [31:0] key_4_wd;
  logic key_5_we;
  logic [31:0] key_5_wd;
  logic key_6_we;
  logic [31:0] key_6_wd;
  logic key_7_we;
  logic [31:0] key_7_wd;
  logic key_8_we;
  logic [31:0] key_8_wd;
  logic key_9_we;
  logic [31:0] key_9_wd;
  logic key_10_we;
  logic [31:0] key_10_wd;
  logic key_11_we;
  logic [31:0] key_11_wd;
  logic key_12_we;
  logic [31:0] key_12_wd;
  logic key_13_we;
  logic [31:0] key_13_wd;
  logic key_14_we;
  logic [31:0] key_14_wd;
  logic key_15_we;
  logic [31:0] key_15_wd;
  logic key_16_we;
  logic [31:0] key_16_wd;
  logic key_17_we;
  logic [31:0] key_17_wd;
  logic key_18_we;
  logic [31:0] key_18_wd;
  logic key_19_we;
  logic [31:0] key_19_wd;
  logic key_20_we;
  logic [31:0] key_20_wd;
  logic key_21_we;
  logic [31:0] key_21_wd;
  logic key_22_we;
  logic [31:0] key_22_wd;
  logic key_23_we;
  logic [31:0] key_23_wd;
  logic key_24_we;
  logic [31:0] key_24_wd;
  logic key_25_we;
  logic [31:0] key_25_wd;
  logic key_26_we;
  logic [31:0] key_26_wd;
  logic key_27_we;
  logic [31:0] key_27_wd;
  logic key_28_we;
  logic [31:0] key_28_wd;
  logic key_29_we;
  logic [31:0] key_29_wd;
  logic key_30_we;
  logic [31:0] key_30_wd;
  logic key_31_we;
  logic [31:0] key_31_wd;
  logic digest_0_re;
  logic digest_0_we;
  logic [31:0] digest_0_qs;
  logic [31:0] digest_0_wd;
  logic digest_1_re;
  logic digest_1_we;
  logic [31:0] digest_1_qs;
  logic [31:0] digest_1_wd;
  logic digest_2_re;
  logic digest_2_we;
  logic [31:0] digest_2_qs;
  logic [31:0] digest_2_wd;
  logic digest_3_re;
  logic digest_3_we;
  logic [31:0] digest_3_qs;
  logic [31:0] digest_3_wd;
  logic digest_4_re;
  logic digest_4_we;
  logic [31:0] digest_4_qs;
  logic [31:0] digest_4_wd;
  logic digest_5_re;
  logic digest_5_we;
  logic [31:0] digest_5_qs;
  logic [31:0] digest_5_wd;
  logic digest_6_re;
  logic digest_6_we;
  logic [31:0] digest_6_qs;
  logic [31:0] digest_6_wd;
  logic digest_7_re;
  logic digest_7_we;
  logic [31:0] digest_7_qs;
  logic [31:0] digest_7_wd;
  logic digest_8_re;
  logic digest_8_we;
  logic [31:0] digest_8_qs;
  logic [31:0] digest_8_wd;
  logic digest_9_re;
  logic digest_9_we;
  logic [31:0] digest_9_qs;
  logic [31:0] digest_9_wd;
  logic digest_10_re;
  logic digest_10_we;
  logic [31:0] digest_10_qs;
  logic [31:0] digest_10_wd;
  logic digest_11_re;
  logic digest_11_we;
  logic [31:0] digest_11_qs;
  logic [31:0] digest_11_wd;
  logic digest_12_re;
  logic digest_12_we;
  logic [31:0] digest_12_qs;
  logic [31:0] digest_12_wd;
  logic digest_13_re;
  logic digest_13_we;
  logic [31:0] digest_13_qs;
  logic [31:0] digest_13_wd;
  logic digest_14_re;
  logic digest_14_we;
  logic [31:0] digest_14_qs;
  logic [31:0] digest_14_wd;
  logic digest_15_re;
  logic digest_15_we;
  logic [31:0] digest_15_qs;
  logic [31:0] digest_15_wd;
  logic msg_length_lower_re;
  logic msg_length_lower_we;
  logic [31:0] msg_length_lower_qs;
  logic [31:0] msg_length_lower_wd;
  logic msg_length_upper_re;
  logic msg_length_upper_we;
  logic [31:0] msg_length_upper_qs;
  logic [31:0] msg_length_upper_wd;

  // Register instances
  // R[intr_state]: V(False)
  //   F[hmac_done]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_hmac_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_hmac_done_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.hmac_done.de),
    .d      (hw2reg.intr_state.hmac_done.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.hmac_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_hmac_done_qs)
  );

  //   F[fifo_empty]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_fifo_empty (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.intr_state.fifo_empty.de),
    .d      (hw2reg.intr_state.fifo_empty.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.fifo_empty.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_fifo_empty_qs)
  );

  //   F[hmac_err]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessW1C),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_state_hmac_err (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_state_we),
    .wd     (intr_state_hmac_err_wd),

    // from internal hardware
    .de     (hw2reg.intr_state.hmac_err.de),
    .d      (hw2reg.intr_state.hmac_err.d),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_state.hmac_err.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_state_hmac_err_qs)
  );


  // R[intr_enable]: V(False)
  //   F[hmac_done]: 0:0
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_hmac_done (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_hmac_done_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.hmac_done.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_hmac_done_qs)
  );

  //   F[fifo_empty]: 1:1
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_fifo_empty (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_fifo_empty_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.fifo_empty.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_fifo_empty_qs)
  );

  //   F[hmac_err]: 2:2
  prim_subreg #(
    .DW      (1),
    .SwAccess(prim_subreg_pkg::SwAccessRW),
    .RESVAL  (1'h0),
    .Mubi    (1'b0)
  ) u_intr_enable_hmac_err (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (intr_enable_we),
    .wd     (intr_enable_hmac_err_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.intr_enable.hmac_err.q),
    .ds     (),

    // to register interface (read)
    .qs     (intr_enable_hmac_err_qs)
  );


  // R[intr_test]: V(True)
  logic intr_test_qe;
  logic [2:0] intr_test_flds_we;
  assign intr_test_qe = &intr_test_flds_we;
  //   F[hmac_done]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_hmac_done (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_hmac_done_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[0]),
    .q      (reg2hw.intr_test.hmac_done.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.hmac_done.qe = intr_test_qe;

  //   F[fifo_empty]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_fifo_empty (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_fifo_empty_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[1]),
    .q      (reg2hw.intr_test.fifo_empty.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.fifo_empty.qe = intr_test_qe;

  //   F[hmac_err]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_intr_test_hmac_err (
    .re     (1'b0),
    .we     (intr_test_we),
    .wd     (intr_test_hmac_err_wd),
    .d      ('0),
    .qre    (),
    .qe     (intr_test_flds_we[2]),
    .q      (reg2hw.intr_test.hmac_err.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.intr_test.hmac_err.qe = intr_test_qe;


  // R[alert_test]: V(True)
  logic alert_test_qe;
  logic [0:0] alert_test_flds_we;
  assign alert_test_qe = &alert_test_flds_we;
  prim_subreg_ext #(
    .DW    (1)
  ) u_alert_test (
    .re     (1'b0),
    .we     (alert_test_we),
    .wd     (alert_test_wd),
    .d      ('0),
    .qre    (),
    .qe     (alert_test_flds_we[0]),
    .q      (reg2hw.alert_test.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.alert_test.qe = alert_test_qe;


  // R[cfg]: V(True)
  logic cfg_qe;
  logic [6:0] cfg_flds_we;
  assign cfg_qe = &cfg_flds_we;
  //   F[hmac_en]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_hmac_en (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_hmac_en_wd),
    .d      (hw2reg.cfg.hmac_en.d),
    .qre    (),
    .qe     (cfg_flds_we[0]),
    .q      (reg2hw.cfg.hmac_en.q),
    .ds     (),
    .qs     (cfg_hmac_en_qs)
  );
  assign reg2hw.cfg.hmac_en.qe = cfg_qe;

  //   F[sha_en]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_sha_en (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_sha_en_wd),
    .d      (hw2reg.cfg.sha_en.d),
    .qre    (),
    .qe     (cfg_flds_we[1]),
    .q      (reg2hw.cfg.sha_en.q),
    .ds     (),
    .qs     (cfg_sha_en_qs)
  );
  assign reg2hw.cfg.sha_en.qe = cfg_qe;

  //   F[endian_swap]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_endian_swap (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_endian_swap_wd),
    .d      (hw2reg.cfg.endian_swap.d),
    .qre    (),
    .qe     (cfg_flds_we[2]),
    .q      (reg2hw.cfg.endian_swap.q),
    .ds     (),
    .qs     (cfg_endian_swap_qs)
  );
  assign reg2hw.cfg.endian_swap.qe = cfg_qe;

  //   F[digest_swap]: 3:3
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_digest_swap (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_digest_swap_wd),
    .d      (hw2reg.cfg.digest_swap.d),
    .qre    (),
    .qe     (cfg_flds_we[3]),
    .q      (reg2hw.cfg.digest_swap.q),
    .ds     (),
    .qs     (cfg_digest_swap_qs)
  );
  assign reg2hw.cfg.digest_swap.qe = cfg_qe;

  //   F[key_swap]: 4:4
  prim_subreg_ext #(
    .DW    (1)
  ) u_cfg_key_swap (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_key_swap_wd),
    .d      (hw2reg.cfg.key_swap.d),
    .qre    (),
    .qe     (cfg_flds_we[4]),
    .q      (reg2hw.cfg.key_swap.q),
    .ds     (),
    .qs     (cfg_key_swap_qs)
  );
  assign reg2hw.cfg.key_swap.qe = cfg_qe;

  //   F[digest_size]: 8:5
  prim_subreg_ext #(
    .DW    (4)
  ) u_cfg_digest_size (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_digest_size_wd),
    .d      (hw2reg.cfg.digest_size.d),
    .qre    (),
    .qe     (cfg_flds_we[5]),
    .q      (reg2hw.cfg.digest_size.q),
    .ds     (),
    .qs     (cfg_digest_size_qs)
  );
  assign reg2hw.cfg.digest_size.qe = cfg_qe;

  //   F[key_length]: 14:9
  prim_subreg_ext #(
    .DW    (6)
  ) u_cfg_key_length (
    .re     (cfg_re),
    .we     (cfg_we),
    .wd     (cfg_key_length_wd),
    .d      (hw2reg.cfg.key_length.d),
    .qre    (),
    .qe     (cfg_flds_we[6]),
    .q      (reg2hw.cfg.key_length.q),
    .ds     (),
    .qs     (cfg_key_length_qs)
  );
  assign reg2hw.cfg.key_length.qe = cfg_qe;


  // R[cmd]: V(True)
  logic cmd_qe;
  logic [3:0] cmd_flds_we;
  assign cmd_qe = &cmd_flds_we;
  //   F[hash_start]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_start (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_start_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[0]),
    .q      (reg2hw.cmd.hash_start.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_start.qe = cmd_qe;

  //   F[hash_process]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_process (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_process_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[1]),
    .q      (reg2hw.cmd.hash_process.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_process.qe = cmd_qe;

  //   F[hash_stop]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_stop (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_stop_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[2]),
    .q      (reg2hw.cmd.hash_stop.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_stop.qe = cmd_qe;

  //   F[hash_continue]: 3:3
  prim_subreg_ext #(
    .DW    (1)
  ) u_cmd_hash_continue (
    .re     (1'b0),
    .we     (cmd_we),
    .wd     (cmd_hash_continue_wd),
    .d      ('0),
    .qre    (),
    .qe     (cmd_flds_we[3]),
    .q      (reg2hw.cmd.hash_continue.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.cmd.hash_continue.qe = cmd_qe;


  // R[status]: V(True)
  //   F[hmac_idle]: 0:0
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_hmac_idle (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.hmac_idle.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_hmac_idle_qs)
  );

  //   F[fifo_empty]: 1:1
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_fifo_empty (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_empty.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_empty_qs)
  );

  //   F[fifo_full]: 2:2
  prim_subreg_ext #(
    .DW    (1)
  ) u_status_fifo_full (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_full.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_full_qs)
  );

  //   F[fifo_depth]: 9:4
  prim_subreg_ext #(
    .DW    (6)
  ) u_status_fifo_depth (
    .re     (status_re),
    .we     (1'b0),
    .wd     ('0),
    .d      (hw2reg.status.fifo_depth.d),
    .qre    (),
    .qe     (),
    .q      (),
    .ds     (),
    .qs     (status_fifo_depth_qs)
  );


  // R[err_code]: V(False)
  prim_subreg #(
    .DW      (32),
    .SwAccess(prim_subreg_pkg::SwAccessRO),
    .RESVAL  (32'h0),
    .Mubi    (1'b0)
  ) u_err_code (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (1'b0),
    .wd     ('0),

    // from internal hardware
    .de     (hw2reg.err_code.de),
    .d      (hw2reg.err_code.d),

    // to internal hardware
    .qe     (),
    .q      (),
    .ds     (),

    // to register interface (read)
    .qs     (err_code_qs)
  );


  // R[wipe_secret]: V(True)
  logic wipe_secret_qe;
  logic [0:0] wipe_secret_flds_we;
  assign wipe_secret_qe = &wipe_secret_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_wipe_secret (
    .re     (1'b0),
    .we     (wipe_secret_we),
    .wd     (wipe_secret_wd),
    .d      ('0),
    .qre    (),
    .qe     (wipe_secret_flds_we[0]),
    .q      (reg2hw.wipe_secret.q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.wipe_secret.qe = wipe_secret_qe;


  // Subregister 0 of Multireg key
  // R[key_0]: V(True)
  logic key_0_qe;
  logic [0:0] key_0_flds_we;
  assign key_0_qe = &key_0_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_0 (
    .re     (1'b0),
    .we     (key_0_we),
    .wd     (key_0_wd),
    .d      (hw2reg.key[0].d),
    .qre    (),
    .qe     (key_0_flds_we[0]),
    .q      (reg2hw.key[0].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[0].qe = key_0_qe;


  // Subregister 1 of Multireg key
  // R[key_1]: V(True)
  logic key_1_qe;
  logic [0:0] key_1_flds_we;
  assign key_1_qe = &key_1_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_1 (
    .re     (1'b0),
    .we     (key_1_we),
    .wd     (key_1_wd),
    .d      (hw2reg.key[1].d),
    .qre    (),
    .qe     (key_1_flds_we[0]),
    .q      (reg2hw.key[1].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[1].qe = key_1_qe;


  // Subregister 2 of Multireg key
  // R[key_2]: V(True)
  logic key_2_qe;
  logic [0:0] key_2_flds_we;
  assign key_2_qe = &key_2_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_2 (
    .re     (1'b0),
    .we     (key_2_we),
    .wd     (key_2_wd),
    .d      (hw2reg.key[2].d),
    .qre    (),
    .qe     (key_2_flds_we[0]),
    .q      (reg2hw.key[2].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[2].qe = key_2_qe;


  // Subregister 3 of Multireg key
  // R[key_3]: V(True)
  logic key_3_qe;
  logic [0:0] key_3_flds_we;
  assign key_3_qe = &key_3_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_3 (
    .re     (1'b0),
    .we     (key_3_we),
    .wd     (key_3_wd),
    .d      (hw2reg.key[3].d),
    .qre    (),
    .qe     (key_3_flds_we[0]),
    .q      (reg2hw.key[3].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[3].qe = key_3_qe;


  // Subregister 4 of Multireg key
  // R[key_4]: V(True)
  logic key_4_qe;
  logic [0:0] key_4_flds_we;
  assign key_4_qe = &key_4_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_4 (
    .re     (1'b0),
    .we     (key_4_we),
    .wd     (key_4_wd),
    .d      (hw2reg.key[4].d),
    .qre    (),
    .qe     (key_4_flds_we[0]),
    .q      (reg2hw.key[4].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[4].qe = key_4_qe;


  // Subregister 5 of Multireg key
  // R[key_5]: V(True)
  logic key_5_qe;
  logic [0:0] key_5_flds_we;
  assign key_5_qe = &key_5_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_5 (
    .re     (1'b0),
    .we     (key_5_we),
    .wd     (key_5_wd),
    .d      (hw2reg.key[5].d),
    .qre    (),
    .qe     (key_5_flds_we[0]),
    .q      (reg2hw.key[5].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[5].qe = key_5_qe;


  // Subregister 6 of Multireg key
  // R[key_6]: V(True)
  logic key_6_qe;
  logic [0:0] key_6_flds_we;
  assign key_6_qe = &key_6_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_6 (
    .re     (1'b0),
    .we     (key_6_we),
    .wd     (key_6_wd),
    .d      (hw2reg.key[6].d),
    .qre    (),
    .qe     (key_6_flds_we[0]),
    .q      (reg2hw.key[6].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[6].qe = key_6_qe;


  // Subregister 7 of Multireg key
  // R[key_7]: V(True)
  logic key_7_qe;
  logic [0:0] key_7_flds_we;
  assign key_7_qe = &key_7_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_7 (
    .re     (1'b0),
    .we     (key_7_we),
    .wd     (key_7_wd),
    .d      (hw2reg.key[7].d),
    .qre    (),
    .qe     (key_7_flds_we[0]),
    .q      (reg2hw.key[7].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[7].qe = key_7_qe;


  // Subregister 8 of Multireg key
  // R[key_8]: V(True)
  logic key_8_qe;
  logic [0:0] key_8_flds_we;
  assign key_8_qe = &key_8_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_8 (
    .re     (1'b0),
    .we     (key_8_we),
    .wd     (key_8_wd),
    .d      (hw2reg.key[8].d),
    .qre    (),
    .qe     (key_8_flds_we[0]),
    .q      (reg2hw.key[8].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[8].qe = key_8_qe;


  // Subregister 9 of Multireg key
  // R[key_9]: V(True)
  logic key_9_qe;
  logic [0:0] key_9_flds_we;
  assign key_9_qe = &key_9_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_9 (
    .re     (1'b0),
    .we     (key_9_we),
    .wd     (key_9_wd),
    .d      (hw2reg.key[9].d),
    .qre    (),
    .qe     (key_9_flds_we[0]),
    .q      (reg2hw.key[9].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[9].qe = key_9_qe;


  // Subregister 10 of Multireg key
  // R[key_10]: V(True)
  logic key_10_qe;
  logic [0:0] key_10_flds_we;
  assign key_10_qe = &key_10_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_10 (
    .re     (1'b0),
    .we     (key_10_we),
    .wd     (key_10_wd),
    .d      (hw2reg.key[10].d),
    .qre    (),
    .qe     (key_10_flds_we[0]),
    .q      (reg2hw.key[10].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[10].qe = key_10_qe;


  // Subregister 11 of Multireg key
  // R[key_11]: V(True)
  logic key_11_qe;
  logic [0:0] key_11_flds_we;
  assign key_11_qe = &key_11_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_11 (
    .re     (1'b0),
    .we     (key_11_we),
    .wd     (key_11_wd),
    .d      (hw2reg.key[11].d),
    .qre    (),
    .qe     (key_11_flds_we[0]),
    .q      (reg2hw.key[11].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[11].qe = key_11_qe;


  // Subregister 12 of Multireg key
  // R[key_12]: V(True)
  logic key_12_qe;
  logic [0:0] key_12_flds_we;
  assign key_12_qe = &key_12_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_12 (
    .re     (1'b0),
    .we     (key_12_we),
    .wd     (key_12_wd),
    .d      (hw2reg.key[12].d),
    .qre    (),
    .qe     (key_12_flds_we[0]),
    .q      (reg2hw.key[12].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[12].qe = key_12_qe;


  // Subregister 13 of Multireg key
  // R[key_13]: V(True)
  logic key_13_qe;
  logic [0:0] key_13_flds_we;
  assign key_13_qe = &key_13_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_13 (
    .re     (1'b0),
    .we     (key_13_we),
    .wd     (key_13_wd),
    .d      (hw2reg.key[13].d),
    .qre    (),
    .qe     (key_13_flds_we[0]),
    .q      (reg2hw.key[13].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[13].qe = key_13_qe;


  // Subregister 14 of Multireg key
  // R[key_14]: V(True)
  logic key_14_qe;
  logic [0:0] key_14_flds_we;
  assign key_14_qe = &key_14_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_14 (
    .re     (1'b0),
    .we     (key_14_we),
    .wd     (key_14_wd),
    .d      (hw2reg.key[14].d),
    .qre    (),
    .qe     (key_14_flds_we[0]),
    .q      (reg2hw.key[14].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[14].qe = key_14_qe;


  // Subregister 15 of Multireg key
  // R[key_15]: V(True)
  logic key_15_qe;
  logic [0:0] key_15_flds_we;
  assign key_15_qe = &key_15_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_15 (
    .re     (1'b0),
    .we     (key_15_we),
    .wd     (key_15_wd),
    .d      (hw2reg.key[15].d),
    .qre    (),
    .qe     (key_15_flds_we[0]),
    .q      (reg2hw.key[15].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[15].qe = key_15_qe;


  // Subregister 16 of Multireg key
  // R[key_16]: V(True)
  logic key_16_qe;
  logic [0:0] key_16_flds_we;
  assign key_16_qe = &key_16_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_16 (
    .re     (1'b0),
    .we     (key_16_we),
    .wd     (key_16_wd),
    .d      (hw2reg.key[16].d),
    .qre    (),
    .qe     (key_16_flds_we[0]),
    .q      (reg2hw.key[16].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[16].qe = key_16_qe;


  // Subregister 17 of Multireg key
  // R[key_17]: V(True)
  logic key_17_qe;
  logic [0:0] key_17_flds_we;
  assign key_17_qe = &key_17_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_17 (
    .re     (1'b0),
    .we     (key_17_we),
    .wd     (key_17_wd),
    .d      (hw2reg.key[17].d),
    .qre    (),
    .qe     (key_17_flds_we[0]),
    .q      (reg2hw.key[17].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[17].qe = key_17_qe;


  // Subregister 18 of Multireg key
  // R[key_18]: V(True)
  logic key_18_qe;
  logic [0:0] key_18_flds_we;
  assign key_18_qe = &key_18_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_18 (
    .re     (1'b0),
    .we     (key_18_we),
    .wd     (key_18_wd),
    .d      (hw2reg.key[18].d),
    .qre    (),
    .qe     (key_18_flds_we[0]),
    .q      (reg2hw.key[18].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[18].qe = key_18_qe;


  // Subregister 19 of Multireg key
  // R[key_19]: V(True)
  logic key_19_qe;
  logic [0:0] key_19_flds_we;
  assign key_19_qe = &key_19_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_19 (
    .re     (1'b0),
    .we     (key_19_we),
    .wd     (key_19_wd),
    .d      (hw2reg.key[19].d),
    .qre    (),
    .qe     (key_19_flds_we[0]),
    .q      (reg2hw.key[19].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[19].qe = key_19_qe;


  // Subregister 20 of Multireg key
  // R[key_20]: V(True)
  logic key_20_qe;
  logic [0:0] key_20_flds_we;
  assign key_20_qe = &key_20_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_20 (
    .re     (1'b0),
    .we     (key_20_we),
    .wd     (key_20_wd),
    .d      (hw2reg.key[20].d),
    .qre    (),
    .qe     (key_20_flds_we[0]),
    .q      (reg2hw.key[20].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[20].qe = key_20_qe;


  // Subregister 21 of Multireg key
  // R[key_21]: V(True)
  logic key_21_qe;
  logic [0:0] key_21_flds_we;
  assign key_21_qe = &key_21_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_21 (
    .re     (1'b0),
    .we     (key_21_we),
    .wd     (key_21_wd),
    .d      (hw2reg.key[21].d),
    .qre    (),
    .qe     (key_21_flds_we[0]),
    .q      (reg2hw.key[21].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[21].qe = key_21_qe;


  // Subregister 22 of Multireg key
  // R[key_22]: V(True)
  logic key_22_qe;
  logic [0:0] key_22_flds_we;
  assign key_22_qe = &key_22_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_22 (
    .re     (1'b0),
    .we     (key_22_we),
    .wd     (key_22_wd),
    .d      (hw2reg.key[22].d),
    .qre    (),
    .qe     (key_22_flds_we[0]),
    .q      (reg2hw.key[22].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[22].qe = key_22_qe;


  // Subregister 23 of Multireg key
  // R[key_23]: V(True)
  logic key_23_qe;
  logic [0:0] key_23_flds_we;
  assign key_23_qe = &key_23_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_23 (
    .re     (1'b0),
    .we     (key_23_we),
    .wd     (key_23_wd),
    .d      (hw2reg.key[23].d),
    .qre    (),
    .qe     (key_23_flds_we[0]),
    .q      (reg2hw.key[23].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[23].qe = key_23_qe;


  // Subregister 24 of Multireg key
  // R[key_24]: V(True)
  logic key_24_qe;
  logic [0:0] key_24_flds_we;
  assign key_24_qe = &key_24_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_24 (
    .re     (1'b0),
    .we     (key_24_we),
    .wd     (key_24_wd),
    .d      (hw2reg.key[24].d),
    .qre    (),
    .qe     (key_24_flds_we[0]),
    .q      (reg2hw.key[24].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[24].qe = key_24_qe;


  // Subregister 25 of Multireg key
  // R[key_25]: V(True)
  logic key_25_qe;
  logic [0:0] key_25_flds_we;
  assign key_25_qe = &key_25_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_25 (
    .re     (1'b0),
    .we     (key_25_we),
    .wd     (key_25_wd),
    .d      (hw2reg.key[25].d),
    .qre    (),
    .qe     (key_25_flds_we[0]),
    .q      (reg2hw.key[25].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[25].qe = key_25_qe;


  // Subregister 26 of Multireg key
  // R[key_26]: V(True)
  logic key_26_qe;
  logic [0:0] key_26_flds_we;
  assign key_26_qe = &key_26_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_26 (
    .re     (1'b0),
    .we     (key_26_we),
    .wd     (key_26_wd),
    .d      (hw2reg.key[26].d),
    .qre    (),
    .qe     (key_26_flds_we[0]),
    .q      (reg2hw.key[26].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[26].qe = key_26_qe;


  // Subregister 27 of Multireg key
  // R[key_27]: V(True)
  logic key_27_qe;
  logic [0:0] key_27_flds_we;
  assign key_27_qe = &key_27_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_27 (
    .re     (1'b0),
    .we     (key_27_we),
    .wd     (key_27_wd),
    .d      (hw2reg.key[27].d),
    .qre    (),
    .qe     (key_27_flds_we[0]),
    .q      (reg2hw.key[27].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[27].qe = key_27_qe;


  // Subregister 28 of Multireg key
  // R[key_28]: V(True)
  logic key_28_qe;
  logic [0:0] key_28_flds_we;
  assign key_28_qe = &key_28_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_28 (
    .re     (1'b0),
    .we     (key_28_we),
    .wd     (key_28_wd),
    .d      (hw2reg.key[28].d),
    .qre    (),
    .qe     (key_28_flds_we[0]),
    .q      (reg2hw.key[28].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[28].qe = key_28_qe;


  // Subregister 29 of Multireg key
  // R[key_29]: V(True)
  logic key_29_qe;
  logic [0:0] key_29_flds_we;
  assign key_29_qe = &key_29_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_29 (
    .re     (1'b0),
    .we     (key_29_we),
    .wd     (key_29_wd),
    .d      (hw2reg.key[29].d),
    .qre    (),
    .qe     (key_29_flds_we[0]),
    .q      (reg2hw.key[29].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[29].qe = key_29_qe;


  // Subregister 30 of Multireg key
  // R[key_30]: V(True)
  logic key_30_qe;
  logic [0:0] key_30_flds_we;
  assign key_30_qe = &key_30_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_30 (
    .re     (1'b0),
    .we     (key_30_we),
    .wd     (key_30_wd),
    .d      (hw2reg.key[30].d),
    .qre    (),
    .qe     (key_30_flds_we[0]),
    .q      (reg2hw.key[30].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[30].qe = key_30_qe;


  // Subregister 31 of Multireg key
  // R[key_31]: V(True)
  logic key_31_qe;
  logic [0:0] key_31_flds_we;
  assign key_31_qe = &key_31_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_key_31 (
    .re     (1'b0),
    .we     (key_31_we),
    .wd     (key_31_wd),
    .d      (hw2reg.key[31].d),
    .qre    (),
    .qe     (key_31_flds_we[0]),
    .q      (reg2hw.key[31].q),
    .ds     (),
    .qs     ()
  );
  assign reg2hw.key[31].qe = key_31_qe;


  // Subregister 0 of Multireg digest
  // R[digest_0]: V(True)
  logic digest_0_qe;
  logic [0:0] digest_0_flds_we;
  assign digest_0_qe = &digest_0_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_0 (
    .re     (digest_0_re),
    .we     (digest_0_we),
    .wd     (digest_0_wd),
    .d      (hw2reg.digest[0].d),
    .qre    (),
    .qe     (digest_0_flds_we[0]),
    .q      (reg2hw.digest[0].q),
    .ds     (),
    .qs     (digest_0_qs)
  );
  assign reg2hw.digest[0].qe = digest_0_qe;


  // Subregister 1 of Multireg digest
  // R[digest_1]: V(True)
  logic digest_1_qe;
  logic [0:0] digest_1_flds_we;
  assign digest_1_qe = &digest_1_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_1 (
    .re     (digest_1_re),
    .we     (digest_1_we),
    .wd     (digest_1_wd),
    .d      (hw2reg.digest[1].d),
    .qre    (),
    .qe     (digest_1_flds_we[0]),
    .q      (reg2hw.digest[1].q),
    .ds     (),
    .qs     (digest_1_qs)
  );
  assign reg2hw.digest[1].qe = digest_1_qe;


  // Subregister 2 of Multireg digest
  // R[digest_2]: V(True)
  logic digest_2_qe;
  logic [0:0] digest_2_flds_we;
  assign digest_2_qe = &digest_2_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_2 (
    .re     (digest_2_re),
    .we     (digest_2_we),
    .wd     (digest_2_wd),
    .d      (hw2reg.digest[2].d),
    .qre    (),
    .qe     (digest_2_flds_we[0]),
    .q      (reg2hw.digest[2].q),
    .ds     (),
    .qs     (digest_2_qs)
  );
  assign reg2hw.digest[2].qe = digest_2_qe;


  // Subregister 3 of Multireg digest
  // R[digest_3]: V(True)
  logic digest_3_qe;
  logic [0:0] digest_3_flds_we;
  assign digest_3_qe = &digest_3_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_3 (
    .re     (digest_3_re),
    .we     (digest_3_we),
    .wd     (digest_3_wd),
    .d      (hw2reg.digest[3].d),
    .qre    (),
    .qe     (digest_3_flds_we[0]),
    .q      (reg2hw.digest[3].q),
    .ds     (),
    .qs     (digest_3_qs)
  );
  assign reg2hw.digest[3].qe = digest_3_qe;


  // Subregister 4 of Multireg digest
  // R[digest_4]: V(True)
  logic digest_4_qe;
  logic [0:0] digest_4_flds_we;
  assign digest_4_qe = &digest_4_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_4 (
    .re     (digest_4_re),
    .we     (digest_4_we),
    .wd     (digest_4_wd),
    .d      (hw2reg.digest[4].d),
    .qre    (),
    .qe     (digest_4_flds_we[0]),
    .q      (reg2hw.digest[4].q),
    .ds     (),
    .qs     (digest_4_qs)
  );
  assign reg2hw.digest[4].qe = digest_4_qe;


  // Subregister 5 of Multireg digest
  // R[digest_5]: V(True)
  logic digest_5_qe;
  logic [0:0] digest_5_flds_we;
  assign digest_5_qe = &digest_5_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_5 (
    .re     (digest_5_re),
    .we     (digest_5_we),
    .wd     (digest_5_wd),
    .d      (hw2reg.digest[5].d),
    .qre    (),
    .qe     (digest_5_flds_we[0]),
    .q      (reg2hw.digest[5].q),
    .ds     (),
    .qs     (digest_5_qs)
  );
  assign reg2hw.digest[5].qe = digest_5_qe;


  // Subregister 6 of Multireg digest
  // R[digest_6]: V(True)
  logic digest_6_qe;
  logic [0:0] digest_6_flds_we;
  assign digest_6_qe = &digest_6_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_6 (
    .re     (digest_6_re),
    .we     (digest_6_we),
    .wd     (digest_6_wd),
    .d      (hw2reg.digest[6].d),
    .qre    (),
    .qe     (digest_6_flds_we[0]),
    .q      (reg2hw.digest[6].q),
    .ds     (),
    .qs     (digest_6_qs)
  );
  assign reg2hw.digest[6].qe = digest_6_qe;


  // Subregister 7 of Multireg digest
  // R[digest_7]: V(True)
  logic digest_7_qe;
  logic [0:0] digest_7_flds_we;
  assign digest_7_qe = &digest_7_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_7 (
    .re     (digest_7_re),
    .we     (digest_7_we),
    .wd     (digest_7_wd),
    .d      (hw2reg.digest[7].d),
    .qre    (),
    .qe     (digest_7_flds_we[0]),
    .q      (reg2hw.digest[7].q),
    .ds     (),
    .qs     (digest_7_qs)
  );
  assign reg2hw.digest[7].qe = digest_7_qe;


  // Subregister 8 of Multireg digest
  // R[digest_8]: V(True)
  logic digest_8_qe;
  logic [0:0] digest_8_flds_we;
  assign digest_8_qe = &digest_8_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_8 (
    .re     (digest_8_re),
    .we     (digest_8_we),
    .wd     (digest_8_wd),
    .d      (hw2reg.digest[8].d),
    .qre    (),
    .qe     (digest_8_flds_we[0]),
    .q      (reg2hw.digest[8].q),
    .ds     (),
    .qs     (digest_8_qs)
  );
  assign reg2hw.digest[8].qe = digest_8_qe;


  // Subregister 9 of Multireg digest
  // R[digest_9]: V(True)
  logic digest_9_qe;
  logic [0:0] digest_9_flds_we;
  assign digest_9_qe = &digest_9_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_9 (
    .re     (digest_9_re),
    .we     (digest_9_we),
    .wd     (digest_9_wd),
    .d      (hw2reg.digest[9].d),
    .qre    (),
    .qe     (digest_9_flds_we[0]),
    .q      (reg2hw.digest[9].q),
    .ds     (),
    .qs     (digest_9_qs)
  );
  assign reg2hw.digest[9].qe = digest_9_qe;


  // Subregister 10 of Multireg digest
  // R[digest_10]: V(True)
  logic digest_10_qe;
  logic [0:0] digest_10_flds_we;
  assign digest_10_qe = &digest_10_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_10 (
    .re     (digest_10_re),
    .we     (digest_10_we),
    .wd     (digest_10_wd),
    .d      (hw2reg.digest[10].d),
    .qre    (),
    .qe     (digest_10_flds_we[0]),
    .q      (reg2hw.digest[10].q),
    .ds     (),
    .qs     (digest_10_qs)
  );
  assign reg2hw.digest[10].qe = digest_10_qe;


  // Subregister 11 of Multireg digest
  // R[digest_11]: V(True)
  logic digest_11_qe;
  logic [0:0] digest_11_flds_we;
  assign digest_11_qe = &digest_11_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_11 (
    .re     (digest_11_re),
    .we     (digest_11_we),
    .wd     (digest_11_wd),
    .d      (hw2reg.digest[11].d),
    .qre    (),
    .qe     (digest_11_flds_we[0]),
    .q      (reg2hw.digest[11].q),
    .ds     (),
    .qs     (digest_11_qs)
  );
  assign reg2hw.digest[11].qe = digest_11_qe;


  // Subregister 12 of Multireg digest
  // R[digest_12]: V(True)
  logic digest_12_qe;
  logic [0:0] digest_12_flds_we;
  assign digest_12_qe = &digest_12_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_12 (
    .re     (digest_12_re),
    .we     (digest_12_we),
    .wd     (digest_12_wd),
    .d      (hw2reg.digest[12].d),
    .qre    (),
    .qe     (digest_12_flds_we[0]),
    .q      (reg2hw.digest[12].q),
    .ds     (),
    .qs     (digest_12_qs)
  );
  assign reg2hw.digest[12].qe = digest_12_qe;


  // Subregister 13 of Multireg digest
  // R[digest_13]: V(True)
  logic digest_13_qe;
  logic [0:0] digest_13_flds_we;
  assign digest_13_qe = &digest_13_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_13 (
    .re     (digest_13_re),
    .we     (digest_13_we),
    .wd     (digest_13_wd),
    .d      (hw2reg.digest[13].d),
    .qre    (),
    .qe     (digest_13_flds_we[0]),
    .q      (reg2hw.digest[13].q),
    .ds     (),
    .qs     (digest_13_qs)
  );
  assign reg2hw.digest[13].qe = digest_13_qe;


  // Subregister 14 of Multireg digest
  // R[digest_14]: V(True)
  logic digest_14_qe;
  logic [0:0] digest_14_flds_we;
  assign digest_14_qe = &digest_14_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_14 (
    .re     (digest_14_re),
    .we     (digest_14_we),
    .wd     (digest_14_wd),
    .d      (hw2reg.digest[14].d),
    .qre    (),
    .qe     (digest_14_flds_we[0]),
    .q      (reg2hw.digest[14].q),
    .ds     (),
    .qs     (digest_14_qs)
  );
  assign reg2hw.digest[14].qe = digest_14_qe;


  // Subregister 15 of Multireg digest
  // R[digest_15]: V(True)
  logic digest_15_qe;
  logic [0:0] digest_15_flds_we;
  assign digest_15_qe = &digest_15_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_digest_15 (
    .re     (digest_15_re),
    .we     (digest_15_we),
    .wd     (digest_15_wd),
    .d      (hw2reg.digest[15].d),
    .qre    (),
    .qe     (digest_15_flds_we[0]),
    .q      (reg2hw.digest[15].q),
    .ds     (),
    .qs     (digest_15_qs)
  );
  assign reg2hw.digest[15].qe = digest_15_qe;


  // R[msg_length_lower]: V(True)
  logic msg_length_lower_qe;
  logic [0:0] msg_length_lower_flds_we;
  assign msg_length_lower_qe = &msg_length_lower_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_msg_length_lower (
    .re     (msg_length_lower_re),
    .we     (msg_length_lower_we),
    .wd     (msg_length_lower_wd),
    .d      (hw2reg.msg_length_lower.d),
    .qre    (),
    .qe     (msg_length_lower_flds_we[0]),
    .q      (reg2hw.msg_length_lower.q),
    .ds     (),
    .qs     (msg_length_lower_qs)
  );
  assign reg2hw.msg_length_lower.qe = msg_length_lower_qe;


  // R[msg_length_upper]: V(True)
  logic msg_length_upper_qe;
  logic [0:0] msg_length_upper_flds_we;
  assign msg_length_upper_qe = &msg_length_upper_flds_we;
  prim_subreg_ext #(
    .DW    (32)
  ) u_msg_length_upper (
    .re     (msg_length_upper_re),
    .we     (msg_length_upper_we),
    .wd     (msg_length_upper_wd),
    .d      (hw2reg.msg_length_upper.d),
    .qre    (),
    .qe     (msg_length_upper_flds_we[0]),
    .q      (reg2hw.msg_length_upper.q),
    .ds     (),
    .qs     (msg_length_upper_qs)
  );
  assign reg2hw.msg_length_upper.qe = msg_length_upper_qe;



  logic [58:0] addr_hit;
  always_comb begin
    addr_hit[ 0] = (reg_addr == HMAC_INTR_STATE_OFFSET);
    addr_hit[ 1] = (reg_addr == HMAC_INTR_ENABLE_OFFSET);
    addr_hit[ 2] = (reg_addr == HMAC_INTR_TEST_OFFSET);
    addr_hit[ 3] = (reg_addr == HMAC_ALERT_TEST_OFFSET);
    addr_hit[ 4] = (reg_addr == HMAC_CFG_OFFSET);
    addr_hit[ 5] = (reg_addr == HMAC_CMD_OFFSET);
    addr_hit[ 6] = (reg_addr == HMAC_STATUS_OFFSET);
    addr_hit[ 7] = (reg_addr == HMAC_ERR_CODE_OFFSET);
    addr_hit[ 8] = (reg_addr == HMAC_WIPE_SECRET_OFFSET);
    addr_hit[ 9] = (reg_addr == HMAC_KEY_0_OFFSET);
    addr_hit[10] = (reg_addr == HMAC_KEY_1_OFFSET);
    addr_hit[11] = (reg_addr == HMAC_KEY_2_OFFSET);
    addr_hit[12] = (reg_addr == HMAC_KEY_3_OFFSET);
    addr_hit[13] = (reg_addr == HMAC_KEY_4_OFFSET);
    addr_hit[14] = (reg_addr == HMAC_KEY_5_OFFSET);
    addr_hit[15] = (reg_addr == HMAC_KEY_6_OFFSET);
    addr_hit[16] = (reg_addr == HMAC_KEY_7_OFFSET);
    addr_hit[17] = (reg_addr == HMAC_KEY_8_OFFSET);
    addr_hit[18] = (reg_addr == HMAC_KEY_9_OFFSET);
    addr_hit[19] = (reg_addr == HMAC_KEY_10_OFFSET);
    addr_hit[20] = (reg_addr == HMAC_KEY_11_OFFSET);
    addr_hit[21] = (reg_addr == HMAC_KEY_12_OFFSET);
    addr_hit[22] = (reg_addr == HMAC_KEY_13_OFFSET);
    addr_hit[23] = (reg_addr == HMAC_KEY_14_OFFSET);
    addr_hit[24] = (reg_addr == HMAC_KEY_15_OFFSET);
    addr_hit[25] = (reg_addr == HMAC_KEY_16_OFFSET);
    addr_hit[26] = (reg_addr == HMAC_KEY_17_OFFSET);
    addr_hit[27] = (reg_addr == HMAC_KEY_18_OFFSET);
    addr_hit[28] = (reg_addr == HMAC_KEY_19_OFFSET);
    addr_hit[29] = (reg_addr == HMAC_KEY_20_OFFSET);
    addr_hit[30] = (reg_addr == HMAC_KEY_21_OFFSET);
    addr_hit[31] = (reg_addr == HMAC_KEY_22_OFFSET);
    addr_hit[32] = (reg_addr == HMAC_KEY_23_OFFSET);
    addr_hit[33] = (reg_addr == HMAC_KEY_24_OFFSET);
    addr_hit[34] = (reg_addr == HMAC_KEY_25_OFFSET);
    addr_hit[35] = (reg_addr == HMAC_KEY_26_OFFSET);
    addr_hit[36] = (reg_addr == HMAC_KEY_27_OFFSET);
    addr_hit[37] = (reg_addr == HMAC_KEY_28_OFFSET);
    addr_hit[38] = (reg_addr == HMAC_KEY_29_OFFSET);
    addr_hit[39] = (reg_addr == HMAC_KEY_30_OFFSET);
    addr_hit[40] = (reg_addr == HMAC_KEY_31_OFFSET);
    addr_hit[41] = (reg_addr == HMAC_DIGEST_0_OFFSET);
    addr_hit[42] = (reg_addr == HMAC_DIGEST_1_OFFSET);
    addr_hit[43] = (reg_addr == HMAC_DIGEST_2_OFFSET);
    addr_hit[44] = (reg_addr == HMAC_DIGEST_3_OFFSET);
    addr_hit[45] = (reg_addr == HMAC_DIGEST_4_OFFSET);
    addr_hit[46] = (reg_addr == HMAC_DIGEST_5_OFFSET);
    addr_hit[47] = (reg_addr == HMAC_DIGEST_6_OFFSET);
    addr_hit[48] = (reg_addr == HMAC_DIGEST_7_OFFSET);
    addr_hit[49] = (reg_addr == HMAC_DIGEST_8_OFFSET);
    addr_hit[50] = (reg_addr == HMAC_DIGEST_9_OFFSET);
    addr_hit[51] = (reg_addr == HMAC_DIGEST_10_OFFSET);
    addr_hit[52] = (reg_addr == HMAC_DIGEST_11_OFFSET);
    addr_hit[53] = (reg_addr == HMAC_DIGEST_12_OFFSET);
    addr_hit[54] = (reg_addr == HMAC_DIGEST_13_OFFSET);
    addr_hit[55] = (reg_addr == HMAC_DIGEST_14_OFFSET);
    addr_hit[56] = (reg_addr == HMAC_DIGEST_15_OFFSET);
    addr_hit[57] = (reg_addr == HMAC_MSG_LENGTH_LOWER_OFFSET);
    addr_hit[58] = (reg_addr == HMAC_MSG_LENGTH_UPPER_OFFSET);
  end

  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;

  // Check sub-word write is permitted
  always_comb begin
    wr_err = (reg_we &
              ((addr_hit[ 0] & (|(HMAC_PERMIT[ 0] & ~reg_be))) |
               (addr_hit[ 1] & (|(HMAC_PERMIT[ 1] & ~reg_be))) |
               (addr_hit[ 2] & (|(HMAC_PERMIT[ 2] & ~reg_be))) |
               (addr_hit[ 3] & (|(HMAC_PERMIT[ 3] & ~reg_be))) |
               (addr_hit[ 4] & (|(HMAC_PERMIT[ 4] & ~reg_be))) |
               (addr_hit[ 5] & (|(HMAC_PERMIT[ 5] & ~reg_be))) |
               (addr_hit[ 6] & (|(HMAC_PERMIT[ 6] & ~reg_be))) |
               (addr_hit[ 7] & (|(HMAC_PERMIT[ 7] & ~reg_be))) |
               (addr_hit[ 8] & (|(HMAC_PERMIT[ 8] & ~reg_be))) |
               (addr_hit[ 9] & (|(HMAC_PERMIT[ 9] & ~reg_be))) |
               (addr_hit[10] & (|(HMAC_PERMIT[10] & ~reg_be))) |
               (addr_hit[11] & (|(HMAC_PERMIT[11] & ~reg_be))) |
               (addr_hit[12] & (|(HMAC_PERMIT[12] & ~reg_be))) |
               (addr_hit[13] & (|(HMAC_PERMIT[13] & ~reg_be))) |
               (addr_hit[14] & (|(HMAC_PERMIT[14] & ~reg_be))) |
               (addr_hit[15] & (|(HMAC_PERMIT[15] & ~reg_be))) |
               (addr_hit[16] & (|(HMAC_PERMIT[16] & ~reg_be))) |
               (addr_hit[17] & (|(HMAC_PERMIT[17] & ~reg_be))) |
               (addr_hit[18] & (|(HMAC_PERMIT[18] & ~reg_be))) |
               (addr_hit[19] & (|(HMAC_PERMIT[19] & ~reg_be))) |
               (addr_hit[20] & (|(HMAC_PERMIT[20] & ~reg_be))) |
               (addr_hit[21] & (|(HMAC_PERMIT[21] & ~reg_be))) |
               (addr_hit[22] & (|(HMAC_PERMIT[22] & ~reg_be))) |
               (addr_hit[23] & (|(HMAC_PERMIT[23] & ~reg_be))) |
               (addr_hit[24] & (|(HMAC_PERMIT[24] & ~reg_be))) |
               (addr_hit[25] & (|(HMAC_PERMIT[25] & ~reg_be))) |
               (addr_hit[26] & (|(HMAC_PERMIT[26] & ~reg_be))) |
               (addr_hit[27] & (|(HMAC_PERMIT[27] & ~reg_be))) |
               (addr_hit[28] & (|(HMAC_PERMIT[28] & ~reg_be))) |
               (addr_hit[29] & (|(HMAC_PERMIT[29] & ~reg_be))) |
               (addr_hit[30] & (|(HMAC_PERMIT[30] & ~reg_be))) |
               (addr_hit[31] & (|(HMAC_PERMIT[31] & ~reg_be))) |
               (addr_hit[32] & (|(HMAC_PERMIT[32] & ~reg_be))) |
               (addr_hit[33] & (|(HMAC_PERMIT[33] & ~reg_be))) |
               (addr_hit[34] & (|(HMAC_PERMIT[34] & ~reg_be))) |
               (addr_hit[35] & (|(HMAC_PERMIT[35] & ~reg_be))) |
               (addr_hit[36] & (|(HMAC_PERMIT[36] & ~reg_be))) |
               (addr_hit[37] & (|(HMAC_PERMIT[37] & ~reg_be))) |
               (addr_hit[38] & (|(HMAC_PERMIT[38] & ~reg_be))) |
               (addr_hit[39] & (|(HMAC_PERMIT[39] & ~reg_be))) |
               (addr_hit[40] & (|(HMAC_PERMIT[40] & ~reg_be))) |
               (addr_hit[41] & (|(HMAC_PERMIT[41] & ~reg_be))) |
               (addr_hit[42] & (|(HMAC_PERMIT[42] & ~reg_be))) |
               (addr_hit[43] & (|(HMAC_PERMIT[43] & ~reg_be))) |
               (addr_hit[44] & (|(HMAC_PERMIT[44] & ~reg_be))) |
               (addr_hit[45] & (|(HMAC_PERMIT[45] & ~reg_be))) |
               (addr_hit[46] & (|(HMAC_PERMIT[46] & ~reg_be))) |
               (addr_hit[47] & (|(HMAC_PERMIT[47] & ~reg_be))) |
               (addr_hit[48] & (|(HMAC_PERMIT[48] & ~reg_be))) |
               (addr_hit[49] & (|(HMAC_PERMIT[49] & ~reg_be))) |
               (addr_hit[50] & (|(HMAC_PERMIT[50] & ~reg_be))) |
               (addr_hit[51] & (|(HMAC_PERMIT[51] & ~reg_be))) |
               (addr_hit[52] & (|(HMAC_PERMIT[52] & ~reg_be))) |
               (addr_hit[53] & (|(HMAC_PERMIT[53] & ~reg_be))) |
               (addr_hit[54] & (|(HMAC_PERMIT[54] & ~reg_be))) |
               (addr_hit[55] & (|(HMAC_PERMIT[55] & ~reg_be))) |
               (addr_hit[56] & (|(HMAC_PERMIT[56] & ~reg_be))) |
               (addr_hit[57] & (|(HMAC_PERMIT[57] & ~reg_be))) |
               (addr_hit[58] & (|(HMAC_PERMIT[58] & ~reg_be)))));
  end

  // Generate write-enables
  assign intr_state_we = addr_hit[0] & reg_we & !reg_error;

  assign intr_state_hmac_done_wd = reg_wdata[0];

  assign intr_state_hmac_err_wd = reg_wdata[2];
  assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;

  assign intr_enable_hmac_done_wd = reg_wdata[0];

  assign intr_enable_fifo_empty_wd = reg_wdata[1];

  assign intr_enable_hmac_err_wd = reg_wdata[2];
  assign intr_test_we = addr_hit[2] & reg_we & !reg_error;

  assign intr_test_hmac_done_wd = reg_wdata[0];

  assign intr_test_fifo_empty_wd = reg_wdata[1];

  assign intr_test_hmac_err_wd = reg_wdata[2];
  assign alert_test_we = addr_hit[3] & reg_we & !reg_error;

  assign alert_test_wd = reg_wdata[0];
  assign cfg_re = addr_hit[4] & reg_re & !reg_error;
  assign cfg_we = addr_hit[4] & reg_we & !reg_error;

  assign cfg_hmac_en_wd = reg_wdata[0];

  assign cfg_sha_en_wd = reg_wdata[1];

  assign cfg_endian_swap_wd = reg_wdata[2];

  assign cfg_digest_swap_wd = reg_wdata[3];

  assign cfg_key_swap_wd = reg_wdata[4];

  assign cfg_digest_size_wd = reg_wdata[8:5];


  wire [5:0]  cfg_key_length_dec = reg_wdata[14:9];
  wire        cmd_start_bit      = reg_wdata[0];
  wire        cmd_process_bit    = reg_wdata[1];
  wire        cmd_stop_bit       = reg_wdata[2];
  wire        cmd_continue_bit   = reg_wdata[3];
  wire [31:0] full_wdata         = reg_wdata;

  assign cfg_key_length_wd   = cfg_key_length_dec;
  assign cmd_we              = (addr_hit[5]  && reg_we && !reg_error);
  assign status_re           = (addr_hit[6]  && reg_re && !reg_error);

  assign cmd_hash_start_wd    = cmd_start_bit;
  assign cmd_hash_process_wd  = cmd_process_bit;
  assign cmd_hash_stop_wd     = cmd_stop_bit;
  assign cmd_hash_continue_wd = cmd_continue_bit;

  // Ensures control path stability during specific bus error events
  assign wipe_secret_we      = (addr_hit[8]  && reg_we && reg_error);
  assign wipe_secret_wd      = full_wdata;

  assign key_0_we            = (addr_hit[9]  && reg_we && !reg_error);
  assign key_0_wd            = full_wdata;

  assign key_1_we            = (addr_hit[10] && reg_we && !reg_error);
  assign key_1_wd            = full_wdata;

  assign key_2_we            = (addr_hit[11] && reg_we && !reg_error);
  assign key_2_wd            = full_wdata;

  assign key_2_wd = reg_wdata[31:0];
  assign key_3_we = addr_hit[12] & reg_we & !reg_error;

  assign key_3_wd = reg_wdata[31:0];
  assign key_4_we = addr_hit[13] & reg_we & !reg_error;

  assign key_4_wd = reg_wdata[31:0];
  assign key_5_we = addr_hit[14] & reg_we & !reg_error;

  assign key_5_wd = reg_wdata[31:0];
  assign key_6_we = addr_hit[15] & reg_we & !reg_error;

  assign key_6_wd = reg_wdata[31:0];
  assign key_7_we = addr_hit[16] & reg_we & !reg_error;

  assign key_7_wd = reg_wdata[31:0];
  assign key_8_we = addr_hit[17] & reg_we & !reg_error;

  assign key_8_wd = reg_wdata[31:0];
  assign key_9_we = addr_hit[18] & reg_we & !reg_error;

  assign key_9_wd = reg_wdata[31:0];
  assign key_10_we = addr_hit[19] & reg_we & !reg_error;

  assign key_10_wd = reg_wdata[31:0];
  assign key_11_we = addr_hit[20] & reg_we & !reg_error;

  assign key_11_wd = reg_wdata[31:0];
  assign key_12_we = addr_hit[21] & reg_we & !reg_error;

  assign key_12_wd = reg_wdata[31:0];
  assign key_13_we = addr_hit[22] & reg_we & !reg_error;

  assign key_13_wd = reg_wdata[31:0];
  assign key_14_we = addr_hit[23] & reg_we & !reg_error;

  assign key_14_wd = reg_wdata[31:0];
  assign key_15_we = addr_hit[24] & reg_we & !reg_error;

  assign key_15_wd = reg_wdata[31:0];
  assign key_16_we = addr_hit[25] & reg_we & !reg_error;

  assign key_16_wd = reg_wdata[31:0];
  assign key_17_we = addr_hit[26] & reg_we & !reg_error;

  assign key_17_wd = reg_wdata[31:0];
  assign key_18_we = addr_hit[27] & reg_we & !reg_error;

  assign key_18_wd = reg_wdata[31:0];
  assign key_19_we = addr_hit[28] & reg_we & !reg_error;

  assign key_19_wd = reg_wdata[31:0];
  assign key_20_we = addr_hit[29] & reg_we & !reg_error;

  assign key_20_wd = reg_wdata[31:0];
  assign key_21_we = addr_hit[30] & reg_we & !reg_error;

  assign key_21_wd = reg_wdata[31:0];
  assign key_22_we = addr_hit[31] & reg_we & !reg_error;

  assign key_22_wd = reg_wdata[31:0];
  assign key_23_we = addr_hit[32] & reg_we & !reg_error;

  assign key_23_wd = reg_wdata[31:0];
  assign key_24_we = addr_hit[33] & reg_we & !reg_error;

  assign key_24_wd = reg_wdata[31:0];
  assign key_25_we = addr_hit[34] & reg_we & !reg_error;

  assign key_25_wd = reg_wdata[31:0];
  assign key_26_we = addr_hit[35] & reg_we & !reg_error;

  assign key_26_wd = reg_wdata[31:0];
  assign key_27_we = addr_hit[36] & reg_we & !reg_error;

  assign key_27_wd = reg_wdata[31:0];
  assign key_28_we = addr_hit[37] & reg_we & !reg_error;

  assign key_28_wd = reg_wdata[31:0];
  assign key_29_we = addr_hit[38] & reg_we & !reg_error;

  assign key_29_wd = reg_wdata[31:0];
  assign key_30_we = addr_hit[39] & reg_we & !reg_error;

  assign key_30_wd = reg_wdata[31:0];
  assign key_31_we = addr_hit[40] & reg_we & !reg_error;

  assign key_31_wd = reg_wdata[31:0];
  assign digest_0_re = addr_hit[41] & reg_re & !reg_error;
  assign digest_0_we = addr_hit[41] & reg_we & !reg_error;

  assign digest_0_wd = reg_wdata[31:0];
  assign digest_1_re = addr_hit[42] & reg_re & !reg_error;
  assign digest_1_we = addr_hit[42] & reg_we & !reg_error;

  assign digest_1_wd = reg_wdata[31:0];
  assign digest_2_re = addr_hit[43] & reg_re & !reg_error;
  assign digest_2_we = addr_hit[43] & reg_we & !reg_error;

  assign digest_2_wd = reg_wdata[31:0];
  assign digest_3_re = addr_hit[44] & reg_re & !reg_error;
  assign digest_3_we = addr_hit[44] & reg_we & !reg_error;

  assign digest_3_wd = reg_wdata[31:0];
  assign digest_4_re = addr_hit[45] & reg_re & !reg_error;
  assign digest_4_we = addr_hit[45] & reg_we & !reg_error;

  assign digest_4_wd = reg_wdata[31:0];
  assign digest_5_re = addr_hit[46] & reg_re & !reg_error;
  assign digest_5_we = addr_hit[46] & reg_we & !reg_error;

  assign digest_5_wd = reg_wdata[31:0];
  assign digest_6_re = addr_hit[47] & reg_re & !reg_error;
  assign digest_6_we = addr_hit[47] & reg_we & !reg_error;

  assign digest_6_wd = reg_wdata[31:0];
  assign digest_7_re = addr_hit[48] & reg_re & !reg_error;
  assign digest_7_we = addr_hit[48] & reg_we & !reg_error;

  assign digest_7_wd = reg_wdata[31:0];
  assign digest_8_re = addr_hit[49] & reg_re & !reg_error;
  assign digest_8_we = addr_hit[49] & reg_we & !reg_error;

  assign digest_8_wd = reg_wdata[31:0];
  assign digest_9_re = addr_hit[50] & reg_re & !reg_error;
  assign digest_9_we = addr_hit[50] & reg_we & !reg_error;

  assign digest_9_wd = reg_wdata[31:0];
  assign digest_10_re = addr_hit[51] & reg_re & !reg_error;
  assign digest_10_we = addr_hit[51] & reg_we & !reg_error;

  assign digest_10_wd = reg_wdata[31:0];
  assign digest_11_re = addr_hit[52] & reg_re & !reg_error;
  assign digest_11_we = addr_hit[52] & reg_we & !reg_error;

  assign digest_11_wd = reg_wdata[31:0];
  assign digest_12_re = addr_hit[53] & reg_re & !reg_error;
  assign digest_12_we = addr_hit[53] & reg_we & !reg_error;

  assign digest_12_wd = reg_wdata[31:0];
  assign digest_13_re = addr_hit[54] & reg_re & !reg_error;
  assign digest_13_we = addr_hit[54] & reg_we & !reg_error;

  assign digest_13_wd = reg_wdata[31:0];
  assign digest_14_re = addr_hit[55] & reg_re & !reg_error;
  assign digest_14_we = addr_hit[55] & reg_we & !reg_error;

  assign digest_14_wd = reg_wdata[31:0];
  assign digest_15_re = addr_hit[56] & reg_re & !reg_error;
  assign digest_15_we = addr_hit[56] & reg_we & !reg_error;

  assign digest_15_wd = reg_wdata[31:0];
  assign msg_length_lower_re = addr_hit[57] & reg_re & !reg_error;
  assign msg_length_lower_we = addr_hit[57] & reg_we & !reg_error;

  assign msg_length_lower_wd = reg_wdata[31:0];
  assign msg_length_upper_re = addr_hit[58] & reg_re & !reg_error;
  assign msg_length_upper_we = addr_hit[58] & reg_we & !reg_error;

  assign msg_length_upper_wd = reg_wdata[31:0];

  // Assign write-enables to checker logic vector.
  always_comb begin
    reg_we_check[0] = intr_state_we;
    reg_we_check[1] = intr_enable_we;
    reg_we_check[2] = intr_test_we;
    reg_we_check[3] = alert_test_we;
    reg_we_check[4] = cfg_we;
    reg_we_check[5] = cmd_we;
    reg_we_check[6] = 1'b0;
    reg_we_check[7] = 1'b0;
    reg_we_check[8] = wipe_secret_we;
    reg_we_check[9] = key_0_we;
    reg_we_check[10] = key_1_we;
    reg_we_check[11] = key_2_we;
    reg_we_check[12] = key_3_we;
    reg_we_check[13] = key_4_we;
    reg_we_check[14] = key_5_we;
    reg_we_check[15] = key_6_we;
    reg_we_check[16] = key_7_we;
    reg_we_check[17] = key_8_we;
    reg_we_check[18] = key_9_we;
    reg_we_check[19] = key_10_we;
    reg_we_check[20] = key_11_we;
    reg_we_check[21] = key_12_we;
    reg_we_check[22] = key_13_we;
    reg_we_check[23] = key_14_we;
    reg_we_check[24] = key_15_we;
    reg_we_check[25] = key_16_we;
    reg_we_check[26] = key_17_we;
    reg_we_check[27] = key_18_we;
    reg_we_check[28] = key_19_we;
    reg_we_check[29] = key_20_we;
    reg_we_check[30] = key_21_we;
    reg_we_check[31] = key_22_we;
    reg_we_check[32] = key_23_we;
    reg_we_check[33] = key_24_we;
    reg_we_check[34] = key_25_we;
    reg_we_check[35] = key_26_we;
    reg_we_check[36] = key_27_we;
    reg_we_check[37] = key_28_we;
    reg_we_check[38] = key_29_we;
    reg_we_check[39] = key_30_we;
    reg_we_check[40] = key_31_we;
    reg_we_check[41] = digest_0_we;
    reg_we_check[42] = digest_1_we;
    reg_we_check[43] = digest_2_we;
    reg_we_check[44] = digest_3_we;
    reg_we_check[45] = digest_4_we;
    reg_we_check[46] = digest_5_we;
    reg_we_check[47] = digest_6_we;
    reg_we_check[48] = digest_7_we;
    reg_we_check[49] = digest_8_we;
    reg_we_check[50] = digest_9_we;
    reg_we_check[51] = digest_10_we;
    reg_we_check[52] = digest_11_we;
    reg_we_check[53] = digest_12_we;
    reg_we_check[54] = digest_13_we;
    reg_we_check[55] = digest_14_we;
    reg_we_check[56] = digest_15_we;
    reg_we_check[57] = msg_length_lower_we;
    reg_we_check[58] = msg_length_upper_we;
  end

  // Read data return
  always_comb begin
    reg_rdata_next = '0;
    unique case (1'b1)
      addr_hit[0]: begin
        reg_rdata_next[0] = intr_state_hmac_done_qs;
        reg_rdata_next[1] = intr_state_fifo_empty_qs;
        reg_rdata_next[2] = intr_state_hmac_err_qs;
      end

      addr_hit[1]: begin
        reg_rdata_next[0] = intr_enable_hmac_done_qs;
        reg_rdata_next[1] = intr_enable_fifo_empty_qs;
        reg_rdata_next[2] = intr_enable_hmac_err_qs;
      end

      addr_hit[2]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
        reg_rdata_next[2] = '0;
      end

      addr_hit[3]: begin
        reg_rdata_next[0] = '0;
      end

      addr_hit[4]: begin
        reg_rdata_next[0] = cfg_hmac_en_qs;
        reg_rdata_next[1] = cfg_sha_en_qs;
        reg_rdata_next[2] = cfg_endian_swap_qs;
        reg_rdata_next[3] = cfg_digest_swap_qs;
        reg_rdata_next[4] = cfg_key_swap_qs;
        reg_rdata_next[8:5] = cfg_digest_size_qs;
        reg_rdata_next[14:9] = cfg_key_length_qs;
      end

      addr_hit[5]: begin
        reg_rdata_next[0] = '0;
        reg_rdata_next[1] = '0;
        reg_rdata_next[2] = '0;
        reg_rdata_next[3] = '0;
      end

      addr_hit[6]: begin
        reg_rdata_next[0] = status_hmac_idle_qs;
        reg_rdata_next[1] = status_fifo_empty_qs;
        reg_rdata_next[2] = status_fifo_full_qs;
        reg_rdata_next[9:4] = status_fifo_depth_qs;
      end

      addr_hit[7]: begin
        reg_rdata_next[31:0] = err_code_qs;
      end
      
      addr_hit[8]: begin
        reg_rdata_next[31:0] = reg2hw.key[0].q;
      end

      addr_hit[9]: begin
        reg_rdata_next[31:0] = reg2hw.key[1].q;
      end

      addr_hit[10]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[11]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[12]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[13]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[14]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[15]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[16]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[17]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[18]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[19]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[20]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[21]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[22]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[23]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[24]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[25]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[26]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[27]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[28]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[29]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[30]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[31]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[32]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[33]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[34]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[35]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[36]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[37]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[38]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[39]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[40]: begin
        reg_rdata_next[31:0] = '0;
      end

      addr_hit[41]: begin
        reg_rdata_next[31:0] = digest_0_qs;
      end

      addr_hit[42]: begin
        reg_rdata_next[31:0] = digest_1_qs;
      end

      addr_hit[43]: begin
        reg_rdata_next[31:0] = digest_2_qs;
      end

      addr_hit[44]: begin
        reg_rdata_next[31:0] = digest_3_qs;
      end

      addr_hit[45]: begin
        reg_rdata_next[31:0] = digest_4_qs;
      end

      addr_hit[46]: begin
        reg_rdata_next[31:0] = digest_5_qs;
      end

      addr_hit[47]: begin
        reg_rdata_next[31:0] = digest_6_qs;
      end

      addr_hit[48]: begin
        reg_rdata_next[31:0] = digest_7_qs;
      end

      addr_hit[49]: begin
        reg_rdata_next[31:0] = digest_8_qs;
      end

      addr_hit[50]: begin
        reg_rdata_next[31:0] = digest_9_qs;
      end

      addr_hit[51]: begin
        reg_rdata_next[31:0] = digest_10_qs;
      end

      addr_hit[52]: begin
        reg_rdata_next[31:0] = digest_11_qs;
      end

      addr_hit[53]: begin
        reg_rdata_next[31:0] = digest_12_qs;
      end

      addr_hit[54]: begin
        reg_rdata_next[31:0] = digest_13_qs;
      end

      addr_hit[55]: begin
        reg_rdata_next[31:0] = digest_14_qs;
      end

      addr_hit[56]: begin
        reg_rdata_next[31:0] = digest_15_qs;
      end

      addr_hit[57]: begin
        reg_rdata_next[31:0] = msg_length_lower_qs;
      end

      addr_hit[58]: begin
        reg_rdata_next[31:0] = msg_length_upper_qs;
      end

      default: begin
        reg_rdata_next = reg2hw.key[2].q;
      end
    endcase
  end

  // shadow busy
  logic shadow_busy;
  assign shadow_busy = 1'b0;

  // register busy
  assign reg_busy = shadow_busy;

  // Unused signal tieoff

  // wdata / byte enable are not always fully used
  // add a blanket unused statement to handle lint waivers
  logic unused_wdata;
  logic unused_be;
  assign unused_wdata = ^reg_wdata;
  assign unused_be = ^reg_be;

  // Assertions for Register Interface
  `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
  `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)

  `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)

  `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)

  // this is formulated as an assumption such that the FPV testbenches do disprove this
  // property by mistake
  //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)

endmodule

    '''

    Use the anomaly detector tool to identify lines in the design RTL that are anomalous.
    Then determine whether the identified anomalous line(s) represent a security issue or not.

    
================================== Ai Message ==================================
Tool Calls:
  anomaly_detector_tool (call_zU4ZkwWVAs5dmWAGaw0TVzZf)
 Call ID: call_zU4ZkwWVAs5dmWAGaw0TVzZf
  Args:
    design_filepath: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv
================================= Tool Message =================================
Name: anomaly_detector_tool

Successfully executed:
```LLM Anomaly Detector tool
```
Output:
Here are clusters of similar verilog constructs in the RTL file:



Cluster 0:
assign intg_err_o = err_q | intg_err | reg_we_err;
assign reg_error = addrmiss | wr_err | intg_err;
assign intr_test_qe = &intr_test_flds_we;
assign reg2hw.intr_test.hmac_done.qe = intr_test_qe;
assign reg2hw.intr_test.fifo_empty.qe = intr_test_qe;
assign reg2hw.intr_test.hmac_err.qe = intr_test_qe;
assign alert_test_qe = &alert_test_flds_we;
assign reg2hw.alert_test.qe = alert_test_qe;
assign cfg_qe = &cfg_flds_we;
assign reg2hw.cfg.hmac_en.qe = cfg_qe;
assign reg2hw.cfg.sha_en.qe = cfg_qe;
assign reg2hw.cfg.endian_swap.qe = cfg_qe;
assign reg2hw.cfg.digest_swap.qe = cfg_qe;
assign reg2hw.cfg.key_swap.qe = cfg_qe;
assign reg2hw.cfg.digest_size.qe = cfg_qe;
assign reg2hw.cfg.key_length.qe = cfg_qe;
assign cmd_qe = &cmd_flds_we;
assign reg2hw.cmd.hash_start.qe = cmd_qe;
assign reg2hw.cmd.hash_process.qe = cmd_qe;
assign reg2hw.cmd.hash_stop.qe = cmd_qe;
assign reg2hw.cmd.hash_continue.qe = cmd_qe;
assign wipe_secret_qe = &wipe_secret_flds_we;
assign reg2hw.wipe_secret.qe = wipe_secret_qe;
assign key_0_qe = &key_0_flds_we;
assign reg2hw.key[0].qe = key_0_qe;
assign key_1_qe = &key_1_flds_we;
assign reg2hw.key[1].qe = key_1_qe;
assign key_2_qe = &key_2_flds_we;
assign reg2hw.key[2].qe = key_2_qe;
assign key_3_qe = &key_3_flds_we;
assign reg2hw.key[3].qe = key_3_qe;
assign key_4_qe = &key_4_flds_we;
assign reg2hw.key[4].qe = key_4_qe;
assign key_5_qe = &key_5_flds_we;
assign reg2hw.key[5].qe = key_5_qe;
assign key_6_qe = &key_6_flds_we;
assign reg2hw.key[6].qe = key_6_qe;
assign key_7_qe = &key_7_flds_we;
assign reg2hw.key[7].qe = key_7_qe;
assign key_8_qe = &key_8_flds_we;
assign reg2hw.key[8].qe = key_8_qe;
assign key_9_qe = &key_9_flds_we;
assign reg2hw.key[9].qe = key_9_qe;
assign key_10_qe = &key_10_flds_we;
assign reg2hw.key[10].qe = key_10_qe;
assign key_11_qe = &key_11_flds_we;
assign reg2hw.key[11].qe = key_11_qe;
assign key_12_qe = &key_12_flds_we;
assign reg2hw.key[12].qe = key_12_qe;
assign key_13_qe = &key_13_flds_we;
assign reg2hw.key[13].qe = key_13_qe;
assign key_14_qe = &key_14_flds_we;
assign reg2hw.key[14].qe = key_14_qe;
assign key_15_qe = &key_15_flds_we;
assign reg2hw.key[15].qe = key_15_qe;
assign key_16_qe = &key_16_flds_we;
assign reg2hw.key[16].qe = key_16_qe;
assign key_17_qe = &key_17_flds_we;
assign reg2hw.key[17].qe = key_17_qe;
assign key_18_qe = &key_18_flds_we;
assign reg2hw.key[18].qe = key_18_qe;
assign key_19_qe = &key_19_flds_we;
assign reg2hw.key[19].qe = key_19_qe;
assign key_20_qe = &key_20_flds_we;
assign reg2hw.key[20].qe = key_20_qe;
assign key_21_qe = &key_21_flds_we;
assign reg2hw.key[21].qe = key_21_qe;
assign key_22_qe = &key_22_flds_we;
assign reg2hw.key[22].qe = key_22_qe;
assign key_23_qe = &key_23_flds_we;
assign reg2hw.key[23].qe = key_23_qe;
assign key_24_qe = &key_24_flds_we;
assign reg2hw.key[24].qe = key_24_qe;
assign key_25_qe = &key_25_flds_we;
assign reg2hw.key[25].qe = key_25_qe;
assign key_26_qe = &key_26_flds_we;
assign reg2hw.key[26].qe = key_26_qe;
assign key_27_qe = &key_27_flds_we;
assign reg2hw.key[27].qe = key_27_qe;
assign key_28_qe = &key_28_flds_we;
assign reg2hw.key[28].qe = key_28_qe;
assign key_29_qe = &key_29_flds_we;
assign reg2hw.key[29].qe = key_29_qe;
assign key_30_qe = &key_30_flds_we;
assign reg2hw.key[30].qe = key_30_qe;
assign key_31_qe = &key_31_flds_we;
assign reg2hw.key[31].qe = key_31_qe;
assign digest_0_qe = &digest_0_flds_we;
assign reg2hw.digest[0].qe = digest_0_qe;
assign digest_1_qe = &digest_1_flds_we;
assign reg2hw.digest[1].qe = digest_1_qe;
assign digest_2_qe = &digest_2_flds_we;
assign reg2hw.digest[2].qe = digest_2_qe;
assign digest_3_qe = &digest_3_flds_we;
assign reg2hw.digest[3].qe = digest_3_qe;
assign digest_4_qe = &digest_4_flds_we;
assign reg2hw.digest[4].qe = digest_4_qe;
assign digest_5_qe = &digest_5_flds_we;
assign reg2hw.digest[5].qe = digest_5_qe;
assign digest_6_qe = &digest_6_flds_we;
assign reg2hw.digest[6].qe = digest_6_qe;
assign digest_7_qe = &digest_7_flds_we;
assign reg2hw.digest[7].qe = digest_7_qe;
assign digest_8_qe = &digest_8_flds_we;
assign reg2hw.digest[8].qe = digest_8_qe;
assign digest_9_qe = &digest_9_flds_we;
assign reg2hw.digest[9].qe = digest_9_qe;
assign digest_10_qe = &digest_10_flds_we;
assign reg2hw.digest[10].qe = digest_10_qe;
assign digest_11_qe = &digest_11_flds_we;
assign reg2hw.digest[11].qe = digest_11_qe;
assign digest_12_qe = &digest_12_flds_we;
assign reg2hw.digest[12].qe = digest_12_qe;
assign digest_13_qe = &digest_13_flds_we;
assign reg2hw.digest[13].qe = digest_13_qe;
assign digest_14_qe = &digest_14_flds_we;
assign reg2hw.digest[14].qe = digest_14_qe;
assign digest_15_qe = &digest_15_flds_we;
assign reg2hw.digest[15].qe = digest_15_qe;
assign msg_length_lower_qe = &msg_length_lower_flds_we;
assign reg2hw.msg_length_lower.qe = msg_length_lower_qe;
assign msg_length_upper_qe = &msg_length_upper_flds_we;
assign reg2hw.msg_length_upper.qe = msg_length_upper_qe;
assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;
assign intr_state_we = addr_hit[0] & reg_we & !reg_error;
assign intr_state_hmac_done_wd = reg_wdata[0];
assign intr_state_hmac_err_wd = reg_wdata[2];
assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;
assign intr_enable_hmac_done_wd = reg_wdata[0];
assign intr_enable_fifo_empty_wd = reg_wdata[1];
assign intr_enable_hmac_err_wd = reg_wdata[2];
assign intr_test_we = addr_hit[2] & reg_we & !reg_error;
assign intr_test_hmac_done_wd = reg_wdata[0];
assign intr_test_fifo_empty_wd = reg_wdata[1];
assign intr_test_hmac_err_wd = reg_wdata[2];
assign alert_test_we = addr_hit[3] & reg_we & !reg_error;
assign alert_test_wd = reg_wdata[0];
assign cfg_re = addr_hit[4] & reg_re & !reg_error;
assign cfg_we = addr_hit[4] & reg_we & !reg_error;
assign cfg_hmac_en_wd = reg_wdata[0];
assign cfg_sha_en_wd = reg_wdata[1];
assign cfg_endian_swap_wd = reg_wdata[2];
assign cfg_digest_swap_wd = reg_wdata[3];
assign cfg_key_swap_wd = reg_wdata[4];
assign cfg_digest_size_wd = reg_wdata[8:5];
assign cfg_key_length_wd   = cfg_key_length_dec;
assign cmd_we              = (addr_hit[5]  && reg_we && !reg_error);
assign status_re           = (addr_hit[6]  && reg_re && !reg_error);
assign cmd_hash_start_wd    = cmd_start_bit;
assign cmd_hash_process_wd  = cmd_process_bit;
assign cmd_hash_stop_wd     = cmd_stop_bit;
assign cmd_hash_continue_wd = cmd_continue_bit;
assign wipe_secret_we      = (addr_hit[8]  && reg_we && reg_error);
assign wipe_secret_wd      = full_wdata;
assign key_0_we            = (addr_hit[9]  && reg_we && !reg_error);
assign key_0_wd            = full_wdata;
assign key_1_we            = (addr_hit[10] && reg_we && !reg_error);
assign key_1_wd            = full_wdata;
assign key_2_we            = (addr_hit[11] && reg_we && !reg_error);
assign key_2_wd            = full_wdata;
assign key_2_wd = reg_wdata[31:0];
assign key_3_we = addr_hit[12] & reg_we & !reg_error;
assign key_3_wd = reg_wdata[31:0];
assign key_4_we = addr_hit[13] & reg_we & !reg_error;
assign key_4_wd = reg_wdata[31:0];
assign key_5_we = addr_hit[14] & reg_we & !reg_error;
assign key_5_wd = reg_wdata[31:0];
assign key_6_we = addr_hit[15] & reg_we & !reg_error;
assign key_6_wd = reg_wdata[31:0];
assign key_7_we = addr_hit[16] & reg_we & !reg_error;
assign key_7_wd = reg_wdata[31:0];
assign key_8_we = addr_hit[17] & reg_we & !reg_error;
assign key_8_wd = reg_wdata[31:0];
assign key_9_we = addr_hit[18] & reg_we & !reg_error;
assign key_9_wd = reg_wdata[31:0];
assign key_10_we = addr_hit[19] & reg_we & !reg_error;
assign key_10_wd = reg_wdata[31:0];
assign key_11_we = addr_hit[20] & reg_we & !reg_error;
assign key_11_wd = reg_wdata[31:0];
assign key_12_we = addr_hit[21] & reg_we & !reg_error;
assign key_12_wd = reg_wdata[31:0];
assign key_13_we = addr_hit[22] & reg_we & !reg_error;
assign key_13_wd = reg_wdata[31:0];
assign key_14_we = addr_hit[23] & reg_we & !reg_error;
assign key_14_wd = reg_wdata[31:0];
assign key_15_we = addr_hit[24] & reg_we & !reg_error;
assign key_15_wd = reg_wdata[31:0];
assign key_16_we = addr_hit[25] & reg_we & !reg_error;
assign key_16_wd = reg_wdata[31:0];
assign key_17_we = addr_hit[26] & reg_we & !reg_error;
assign key_17_wd = reg_wdata[31:0];
assign key_18_we = addr_hit[27] & reg_we & !reg_error;
assign key_18_wd = reg_wdata[31:0];
assign key_19_we = addr_hit[28] & reg_we & !reg_error;
assign key_19_wd = reg_wdata[31:0];
assign key_20_we = addr_hit[29] & reg_we & !reg_error;
assign key_20_wd = reg_wdata[31:0];
assign key_21_we = addr_hit[30] & reg_we & !reg_error;
assign key_21_wd = reg_wdata[31:0];
assign key_22_we = addr_hit[31] & reg_we & !reg_error;
assign key_22_wd = reg_wdata[31:0];
assign key_23_we = addr_hit[32] & reg_we & !reg_error;
assign key_23_wd = reg_wdata[31:0];
assign key_24_we = addr_hit[33] & reg_we & !reg_error;
assign key_24_wd = reg_wdata[31:0];
assign key_25_we = addr_hit[34] & reg_we & !reg_error;
assign key_25_wd = reg_wdata[31:0];
assign key_26_we = addr_hit[35] & reg_we & !reg_error;
assign key_26_wd = reg_wdata[31:0];
assign key_27_we = addr_hit[36] & reg_we & !reg_error;
assign key_27_wd = reg_wdata[31:0];
assign key_28_we = addr_hit[37] & reg_we & !reg_error;
assign key_28_wd = reg_wdata[31:0];
assign key_29_we = addr_hit[38] & reg_we & !reg_error;
assign key_29_wd = reg_wdata[31:0];
assign key_30_we = addr_hit[39] & reg_we & !reg_error;
assign key_30_wd = reg_wdata[31:0];
assign key_31_we = addr_hit[40] & reg_we & !reg_error;
assign key_31_wd = reg_wdata[31:0];
assign digest_0_re = addr_hit[41] & reg_re & !reg_error;
assign digest_0_we = addr_hit[41] & reg_we & !reg_error;
assign digest_0_wd = reg_wdata[31:0];
assign digest_1_re = addr_hit[42] & reg_re & !reg_error;
assign digest_1_we = addr_hit[42] & reg_we & !reg_error;
assign digest_1_wd = reg_wdata[31:0];
assign digest_2_re = addr_hit[43] & reg_re & !reg_error;
assign digest_2_we = addr_hit[43] & reg_we & !reg_error;
assign digest_2_wd = reg_wdata[31:0];
assign digest_3_re = addr_hit[44] & reg_re & !reg_error;
assign digest_3_we = addr_hit[44] & reg_we & !reg_error;
assign digest_3_wd = reg_wdata[31:0];
assign digest_4_re = addr_hit[45] & reg_re & !reg_error;
assign digest_4_we = addr_hit[45] & reg_we & !reg_error;
assign digest_4_wd = reg_wdata[31:0];
assign digest_5_re = addr_hit[46] & reg_re & !reg_error;
assign digest_5_we = addr_hit[46] & reg_we & !reg_error;
assign digest_5_wd = reg_wdata[31:0];
assign digest_6_re = addr_hit[47] & reg_re & !reg_error;
assign digest_6_we = addr_hit[47] & reg_we & !reg_error;
assign digest_6_wd = reg_wdata[31:0];
assign digest_7_re = addr_hit[48] & reg_re & !reg_error;
assign digest_7_we = addr_hit[48] & reg_we & !reg_error;
assign digest_7_wd = reg_wdata[31:0];
assign digest_8_re = addr_hit[49] & reg_re & !reg_error;
assign digest_8_we = addr_hit[49] & reg_we & !reg_error;
assign digest_8_wd = reg_wdata[31:0];
assign digest_9_re = addr_hit[50] & reg_re & !reg_error;
assign digest_9_we = addr_hit[50] & reg_we & !reg_error;
assign digest_9_wd = reg_wdata[31:0];
assign digest_10_re = addr_hit[51] & reg_re & !reg_error;
assign digest_10_we = addr_hit[51] & reg_we & !reg_error;
assign digest_10_wd = reg_wdata[31:0];
assign digest_11_re = addr_hit[52] & reg_re & !reg_error;
assign digest_11_we = addr_hit[52] & reg_we & !reg_error;
assign digest_11_wd = reg_wdata[31:0];
assign digest_12_re = addr_hit[53] & reg_re & !reg_error;
assign digest_12_we = addr_hit[53] & reg_we & !reg_error;
assign digest_12_wd = reg_wdata[31:0];
assign digest_13_re = addr_hit[54] & reg_re & !reg_error;
assign digest_13_we = addr_hit[54] & reg_we & !reg_error;
assign digest_13_wd = reg_wdata[31:0];
assign digest_14_re = addr_hit[55] & reg_re & !reg_error;
assign digest_14_we = addr_hit[55] & reg_we & !reg_error;
assign digest_14_wd = reg_wdata[31:0];
assign digest_15_re = addr_hit[56] & reg_re & !reg_error;
assign digest_15_we = addr_hit[56] & reg_we & !reg_error;
assign digest_15_wd = reg_wdata[31:0];
assign msg_length_lower_re = addr_hit[57] & reg_re & !reg_error;
assign msg_length_lower_we = addr_hit[57] & reg_we & !reg_error;
assign msg_length_lower_wd = reg_wdata[31:0];
assign msg_length_upper_re = addr_hit[58] & reg_re & !reg_error;
assign msg_length_upper_we = addr_hit[58] & reg_we & !reg_error;
assign msg_length_upper_wd = reg_wdata[31:0];
assign unused_wdata = ^reg_wdata;
assign unused_be = ^reg_be;


Cluster 1:
assign tl_reg_h2d = tl_socket_h2d[1];
assign tl_socket_d2h[1] = tl_reg_d2h;
assign tl_win_o = tl_socket_h2d[0];
assign tl_socket_d2h[0] = tl_win_i;


Cluster 2:
assign shadow_busy = 1'b0;
assign reg_busy = shadow_busy;

================================== Ai Message ==================================

I ran the anomaly detector on hmac_reg_top.sv and inspected the clusters. I found several anomalous code snippets that are likely bugs and have security impact (secret leakage or improper wiping). Summary (each item: what is anomalous, why it is a security issue, and a recommended fix).

1) Readback muxing exposes key material (likely high severity)
- Observed code (readback case):
  - addr_hit[8] (WIPE_SECRET_OFFSET) returns reg2hw.key[0].q
  - addr_hit[9] (HMAC_KEY_0_OFFSET) returns reg2hw.key[1].q
  - addr_hit[10..40] mostly return '0
  - default: reg_rdata_next = reg2hw.key[2].q
- Why anomalous / security impact:
  - WIPE_SECRET should not return key material; returning reg2hw.key[0].q from the wipe-secret address leaks the first key word on reads of the wipe register.
  - The mapping for key readback looks misaligned/inconsistent (key addresses returning other key words or zeros). The default returning reg2hw.key[2].q is particularly dangerous because if the read address does not match any case (or if the read is malformed), secret key material could be returned.
  - These behave like info-leaks of secret key words to software/TL bus.
- Recommendation:
  - Ensure key registers are consistently read-as-zero (or otherwise redacted) if they are intended write-only secrets. Move any accidental reg2hw.key[].q returns out of the public read mux.
  - Change the default case to return 0 (not any key material).
  - Fix the readback mappings so that WIPE_SECRET does not return a key, and key N addresses either return 0 (if write-only) or the intended field.

2) WIPE secret write enable gating looks incorrect (high severity for wipe capability)
- Observed code:
  - assign wipe_secret_we = (addr_hit[8] && reg_we && reg_error);
  - assign wipe_secret_wd = full_wdata;
- Why anomalous / security impact:
  - wipe_secret_we is only asserted when reg_error is true. That means normal writes to the wipe_secret register will not trigger a wipe unless a register error condition is also present. This prevents a normal software-initiated wipe and may leave secret keys stuck if software cannot force a reg_error. It also looks inconsistent with other write enables where writes require !reg_error.
- Recommendation:
  - Re-evaluate intended behavior. If wipe should be writable in normal operation, change to (addr_hit[8] && reg_we && !reg_error). If the special gating is intentional, document it clearly and ensure no other logic leaks secrets in the meantime. Consider an explicit, robust secure-wipe path that cannot be disabled by software.

3) Duplicate/conflicting assignment to key_2_wd (medium severity / coding bug)
- Observed:
  - assign key_2_wd = full_wdata;
  - later: assign key_2_wd = reg_wdata[31:0];
- Why anomalous / security impact:
  - Two continuous assigns to the same net are conflicting/redundant and usually a synthesis issue. Even if both RHS are equivalent (full_wdata == reg_wdata), duplicate drivers are a bug and could cause unpredictable behavior for key_2 writes. That could cause incorrect key programming or enable unexpected read behavior.
- Recommendation:
  - Remove the duplicate assignment and keep a single, clear assignment (use full_wdata consistently or reg_wdata explicitly). Audit other key_N_wd assignments for similar duplication.

4) Inconsistent read-as-zero policy / misaligned key readback (medium-high)
- Observed:
  - Many key addresses return '0 in the readback case (addr_hit[10..40] etc.), while others return reg2hw.key[].q. The mapping is inconsistent and appears misaligned.
- Why anomalous / security impact:
  - If keys are intended to be write-only, the read mux should consistently return zeros for all key addresses. Inconsistencies increase risk of accidental secret leak.
- Recommendation:
  - Decide and implement consistent read policy for keys: either read-as-zero for all key addresses (preferred for secrets) or only return key fields under strictly controlled privileged paths (and ensure privilege checks). Fix the mapping so every key address is handled consistently.

5) Default read returns a secret (info-leak edge-case)
- Observed:
  - default: reg_rdata_next = reg2hw.key[2].q;
- Why anomalous / security impact:
  - On an unexpected case (no addr_hit true), returning key[2] leaks secret material. Even if addrmiss triggers reg_error, reg_rdata_next is still driven here and could be returned or observed in some corner cases. Default should not be a key.
- Recommendation:
  - Make the default read result zero (or explicitly the expected safe value), never a key.

6) Privilege checks / access control not evident in this module (design-level observation)
- Observed:
  - I see per-register SwAccess attributes in prim_subreg instantiations, and a HMAC_PERMIT check for byte enables, but I do not see any explicit privilege-level gating (for example: secure-only master, or isolation of key writes to a secure bus) in this top-level file.
- Why relevant / security impact:
  - Keys and wipe operations should normally be guarded by platform privilege/firewalls. If that checking occurs elsewhere (e.g., TL layer or top integration), it may be fine; if missing, software could misuse these registers.
- Recommendation:
  - Verify that the TL access layer enforces the intended privilege model for key/wipe and other sensitive registers.

Conclusion / severity summary
- Highest priorities to fix:
  - Remove any readback path that returns key material accidentally (WIPE_SECRET, default case). (High severity: direct key leakage)
  - Fix wipe_secret_we gating so the wipe operation can be triggered as intended and documented. (High severity: inability to securely wipe)
- Medium priorities:
  - Remove duplicate assignment to key_2_wd.
  - Make key readback policy consistent (read-as-zero or privileged read).
  - Make default read return a safe value (0).
- Low:
  - Verify privilege enforcement is applied at the bus/socket level.

If you want, I can:
- Produce a minimal patch suggestion showing the exact lines to change (e.g., change the readback case entries, set default to '0, change wipe_secret_we condition, remove duplicate key_2_wd assignment).
- Or re-run the anomaly detector focusing on specific suspicious regions to produce a patch-ready diff. Which would you prefer?
================================= Tool Message =================================
Name: run_anomaly_detector_agent

I ran the anomaly detector on hmac_reg_top.sv and inspected the clusters. I found several anomalous code snippets that are likely bugs and have security impact (secret leakage or improper wiping). Summary (each item: what is anomalous, why it is a security issue, and a recommended fix).

1) Readback muxing exposes key material (likely high severity)
- Observed code (readback case):
  - addr_hit[8] (WIPE_SECRET_OFFSET) returns reg2hw.key[0].q
  - addr_hit[9] (HMAC_KEY_0_OFFSET) returns reg2hw.key[1].q
  - addr_hit[10..40] mostly return '0
  - default: reg_rdata_next = reg2hw.key[2].q
- Why anomalous / security impact:
  - WIPE_SECRET should not return key material; returning reg2hw.key[0].q from the wipe-secret address leaks the first key word on reads of the wipe register.
  - The mapping for key readback looks misaligned/inconsistent (key addresses returning other key words or zeros). The default returning reg2hw.key[2].q is particularly dangerous because if the read address does not match any case (or if the read is malformed), secret key material could be returned.
  - These behave like info-leaks of secret key words to software/TL bus.
- Recommendation:
  - Ensure key registers are consistently read-as-zero (or otherwise redacted) if they are intended write-only secrets. Move any accidental reg2hw.key[].q returns out of the public read mux.
  - Change the default case to return 0 (not any key material).
  - Fix the readback mappings so that WIPE_SECRET does not return a key, and key N addresses either return 0 (if write-only) or the intended field.

2) WIPE secret write enable gating looks incorrect (high severity for wipe capability)
- Observed code:
  - assign wipe_secret_we = (addr_hit[8] && reg_we && reg_error);
  - assign wipe_secret_wd = full_wdata;
- Why anomalous / security impact:
  - wipe_secret_we is only asserted when reg_error is true. That means normal writes to the wipe_secret register will not trigger a wipe unless a register error condition is also present. This prevents a normal software-initiated wipe and may leave secret keys stuck if software cannot force a reg_error. It also looks inconsistent with other write enables where writes require !reg_error.
- Recommendation:
  - Re-evaluate intended behavior. If wipe should be writable in normal operation, change to (addr_hit[8] && reg_we && !reg_error). If the special gating is intentional, document it clearly and ensure no other logic leaks secrets in the meantime. Consider an explicit, robust secure-wipe path that cannot be disabled by software.

3) Duplicate/conflicting assignment to key_2_wd (medium severity / coding bug)
- Observed:
  - assign key_2_wd = full_wdata;
  - later: assign key_2_wd = reg_wdata[31:0];
- Why anomalous / security impact:
  - Two continuous assigns to the same net are conflicting/redundant and usually a synthesis issue. Even if both RHS are equivalent (full_wdata == reg_wdata), duplicate drivers are a bug and could cause unpredictable behavior for key_2 writes. That could cause incorrect key programming or enable unexpected read behavior.
- Recommendation:
  - Remove the duplicate assignment and keep a single, clear assignment (use full_wdata consistently or reg_wdata explicitly). Audit other key_N_wd assignments for similar duplication.

4) Inconsistent read-as-zero policy / misaligned key readback (medium-high)
- Observed:
  - Many key addresses return '0 in the readback case (addr_hit[10..40] etc.), while others return reg2hw.key[].q. The mapping is inconsistent and appears misaligned.
- Why anomalous / security impact:
  - If keys are intended to be write-only, the read mux should consistently return zeros for all key addresses. Inconsistencies increase risk of accidental secret leak.
- Recommendation:
  - Decide and implement consistent read policy for keys: either read-as-zero for all key addresses (preferred for secrets) or only return key fields under strictly controlled privileged paths (and ensure privilege checks). Fix the mapping so every key address is handled consistently.

5) Default read returns a secret (info-leak edge-case)
- Observed:
  - default: reg_rdata_next = reg2hw.key[2].q;
- Why anomalous / security impact:
  - On an unexpected case (no addr_hit true), returning key[2] leaks secret material. Even if addrmiss triggers reg_error, reg_rdata_next is still driven here and could be returned or observed in some corner cases. Default should not be a key.
- Recommendation:
  - Make the default read result zero (or explicitly the expected safe value), never a key.

6) Privilege checks / access control not evident in this module (design-level observation)
- Observed:
  - I see per-register SwAccess attributes in prim_subreg instantiations, and a HMAC_PERMIT check for byte enables, but I do not see any explicit privilege-level gating (for example: secure-only master, or isolation of key writes to a secure bus) in this top-level file.
- Why relevant / security impact:
  - Keys and wipe operations should normally be guarded by platform privilege/firewalls. If that checking occurs elsewhere (e.g., TL layer or top integration), it may be fine; if missing, software could misuse these registers.
- Recommendation:
  - Verify that the TL access layer enforces the intended privilege model for key/wipe and other sensitive registers.

Conclusion / severity summary
- Highest priorities to fix:
  - Remove any readback path that returns key material accidentally (WIPE_SECRET, default case). (High severity: direct key leakage)
  - Fix wipe_secret_we gating so the wipe operation can be triggered as intended and documented. (High severity: inability to securely wipe)
- Medium priorities:
  - Remove duplicate assignment to key_2_wd.
  - Make key readback policy consistent (read-as-zero or privileged read).
  - Make default read return a safe value (0).
- Low:
  - Verify privilege enforcement is applied at the bus/socket level.

If you want, I can:
- Produce a minimal patch suggestion showing the exact lines to change (e.g., change the readback case entries, set default to '0, change wipe_secret_we condition, remove duplicate key_2_wd assignment).
- Or re-run the anomaly detector focusing on specific suspicious regions to produce a patch-ready diff. Which would you prefer?
================================== Ai Message ==================================
Tool Calls:
  run_similar_bug_agent (call_C40m65XvQJ0YGyzvHb6Kpeit)
 Call ID: call_C40m65XvQJ0YGyzvHb6Kpeit
  Args:
    bug: reg_rdata_next[31:0] = reg2hw.key[0].q;
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv
================================ Human Message =================================

This bug was previously found in another file of this design:
    reg_rdata_next[31:0] = reg2hw.key[0].q;
    
    Please check the RTL code in the file /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv for similar bugs.
================================ Human Message =================================

This bug was previously found in another file of this design:
    reg_rdata_next[31:0] = reg2hw.key[0].q;
    
    Please check the RTL code in the file /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv for similar bugs.
================================== Ai Message ==================================

[{'text': "I'll help you find similar bug instances in the specified file. I'll use the similar_bug_tool to search for lines that match the pattern you've identified.", 'type': 'text'}, {'id': 'toolu_014vFZxwrnP7gazXV7FejS4a', 'input': {'bug': 'reg_rdata_next[31:0] = reg2hw.key[0].q;', 'ip_file': '/home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv'}, 'name': 'similar_bug_tool', 'type': 'tool_use'}]
Tool Calls:
  similar_bug_tool (toolu_014vFZxwrnP7gazXV7FejS4a)
 Call ID: toolu_014vFZxwrnP7gazXV7FejS4a
  Args:
    bug: reg_rdata_next[31:0] = reg2hw.key[0].q;
    ip_file: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv
================================= Tool Message =================================
Name: similar_bug_tool


Found similar bug in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv at line 2623: reg_rdata_next = reg2hw.key[2].q;
Found similar bug in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv at line 2419: 
        reg_rdata_next[31:0] = reg2hw.key[0].q;
Found similar bug in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv at line 2423: 
        reg_rdata_next[31:0] = reg2hw.key[1].q;
Found similar bug in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1563: assign reg2hw.key[31].qe = key_31_qe;
Found similar bug in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1559: .q      (reg2hw.key[31].q),
Found similar bug in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1542: assign reg2hw.key[30].qe = key_30_qe;
Found similar bug in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1223: .q      (reg2hw.key[15].q),
Found similar bug in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1248: assign reg2hw.key[16].qe = key_16_qe;
Found similar bug in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1080: assign reg2hw.key[8].qe = key_8_qe;
Found similar bug in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1538: .q      (reg2hw.key[30].q),
================================= Tool Message =================================
Name: similar_bug_tool


Found similar bug in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv at line 2623: reg_rdata_next = reg2hw.key[2].q;
Found similar bug in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv at line 2419: 
        reg_rdata_next[31:0] = reg2hw.key[0].q;
Found similar bug in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv at line 2423: 
        reg_rdata_next[31:0] = reg2hw.key[1].q;
Found similar bug in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1563: assign reg2hw.key[31].qe = key_31_qe;
Found similar bug in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1559: .q      (reg2hw.key[31].q),
Found similar bug in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1542: assign reg2hw.key[30].qe = key_30_qe;
Found similar bug in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1223: .q      (reg2hw.key[15].q),
Found similar bug in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1248: assign reg2hw.key[16].qe = key_16_qe;
Found similar bug in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1080: assign reg2hw.key[8].qe = key_8_qe;
Found similar bug in /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv at line 1538: .q      (reg2hw.key[30].q),
================================== Ai Message ==================================

[{'text': "To verify the context of these potential bug lines, I'll read the file with line numbers for the most similar matches:", 'type': 'text'}, {'id': 'toolu_01EKkY4H2N1sTDZPYcJgYYXJ', 'input': {'file_path': '/home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv'}, 'name': 'read_file_with_line_numbers', 'type': 'tool_use'}]
Tool Calls:
  read_file_with_line_numbers (toolu_01EKkY4H2N1sTDZPYcJgYYXJ)
 Call ID: toolu_01EKkY4H2N1sTDZPYcJgYYXJ
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_top.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Register Top module auto-generated by `reggen`
6: 
7: `include "prim_assert.sv"
8: 
9: module hmac_reg_top (
10:   input clk_i,
11:   input rst_ni,
12:   input  tlul_pkg::tl_h2d_t tl_i,
13:   output tlul_pkg::tl_d2h_t tl_o,
14: 
15:   // Output port for window
16:   output tlul_pkg::tl_h2d_t tl_win_o,
17:   input  tlul_pkg::tl_d2h_t tl_win_i,
18: 
19:   // To HW
20:   output hmac_reg_pkg::hmac_reg2hw_t reg2hw, // Write
21:   input  hmac_reg_pkg::hmac_hw2reg_t hw2reg, // Read
22: 
23:   // Integrity check errors
24:   output logic intg_err_o
25: );
26: 
27:   import hmac_reg_pkg::* ;
28: 
29:   localparam int AW = 13;
30:   localparam int DW = 32;
31:   localparam int DBW = DW/8;                    // Byte Width
32: 
33:   // register signals
34:   logic           reg_we;
35:   logic           reg_re;
36:   logic [AW-1:0]  reg_addr;
37:   logic [DW-1:0]  reg_wdata;
38:   logic [DBW-1:0] reg_be;
39:   logic [DW-1:0]  reg_rdata;
40:   logic           reg_error;
41: 
42:   logic          addrmiss, wr_err;
43: 
44:   logic [DW-1:0] reg_rdata_next;
45:   logic reg_busy;
46: 
47:   tlul_pkg::tl_h2d_t tl_reg_h2d;
48:   tlul_pkg::tl_d2h_t tl_reg_d2h;
49: 
50: 
51:   // incoming payload check
52:   logic intg_err;
53:   tlul_cmd_intg_chk u_chk (
54:     .tl_i(tl_i),
55:     .err_o(intg_err)
56:   );
57: 
58:   // also check for spurious write enables
59:   logic reg_we_err;
60:   logic [58:0] reg_we_check;
61:   prim_reg_we_check #(
62:     .OneHotWidth(59)
63:   ) u_prim_reg_we_check (
64:     .clk_i(clk_i),
65:     .rst_ni(rst_ni),
66:     .oh_i  (reg_we_check),
67:     .en_i  (reg_we && !addrmiss),
68:     .err_o (reg_we_err)
69:   );
70: 
71:   logic err_q;
72:   always_ff @(posedge clk_i or negedge rst_ni) begin
73:     if (!rst_ni) begin
74:       err_q <= '0;
75:     end else if (intg_err || reg_we_err) begin
76:       err_q <= 1'b1;
77:     end
78:   end
79: 
80:   // integrity error output is permanent and should be used for alert generation
81:   // register errors are transactional
82:   assign intg_err_o = err_q | intg_err | reg_we_err;
83: 
84:   // outgoing integrity generation
85:   tlul_pkg::tl_d2h_t tl_o_pre;
86:   tlul_rsp_intg_gen #(
87:     .EnableRspIntgGen(1),
88:     .EnableDataIntgGen(1)
89:   ) u_rsp_intg_gen (
90:     .tl_i(tl_o_pre),
91:     .tl_o(tl_o)
92:   );
93: 
94:   tlul_pkg::tl_h2d_t tl_socket_h2d [2];
95:   tlul_pkg::tl_d2h_t tl_socket_d2h [2];
96: 
97:   logic [0:0] reg_steer;
98: 
99:   // socket_1n connection
100:   assign tl_reg_h2d = tl_socket_h2d[1];
101:   assign tl_socket_d2h[1] = tl_reg_d2h;
102: 
103:   assign tl_win_o = tl_socket_h2d[0];
104:   assign tl_socket_d2h[0] = tl_win_i;
105: 
106:   // Create Socket_1n
107:   tlul_socket_1n #(
108:     .N            (2),
109:     .HReqPass     (1'b1),
110:     .HRspPass     (1'b1),
111:     .DReqPass     ({2{1'b1}}),
112:     .DRspPass     ({2{1'b1}}),
113:     .HReqDepth    (4'h0),
114:     .HRspDepth    (4'h0),
115:     .DReqDepth    ({2{4'h0}}),
116:     .DRspDepth    ({2{4'h0}}),
117:     .ExplicitErrs (1'b0)
118:   ) u_socket (
119:     .clk_i  (clk_i),
120:     .rst_ni (rst_ni),
121:     .tl_h_i (tl_i),
122:     .tl_h_o (tl_o_pre),
123:     .tl_d_o (tl_socket_h2d),
124:     .tl_d_i (tl_socket_d2h),
125:     .dev_select_i (reg_steer)
126:   );
127: 
128:   // Create steering logic
129:   always_comb begin
130:     reg_steer =
131:         tl_i.a_address[AW-1:0] inside {[4096:8191]} ? 1'd0 :
132:         // Default set to register
133:         1'd1;
134: 
135:     // Override this in case of an integrity error
136:     if (intg_err) begin
137:       reg_steer = 1'd1;
138:     end
139:   end
140: 
141:   tlul_adapter_reg #(
142:     .RegAw(AW),
143:     .RegDw(DW),
144:     .EnableDataIntgGen(0)
145:   ) u_reg_if (
146:     .clk_i  (clk_i),
147:     .rst_ni (rst_ni),
148: 
149:     .tl_i (tl_reg_h2d),
150:     .tl_o (tl_reg_d2h),
151: 
152:     .en_ifetch_i(prim_mubi_pkg::MuBi4False),
153:     .intg_error_o(),
154: 
155:     .we_o    (reg_we),
156:     .re_o    (reg_re),
157:     .addr_o  (reg_addr),
158:     .wdata_o (reg_wdata),
159:     .be_o    (reg_be),
160:     .busy_i  (reg_busy),
161:     .rdata_i (reg_rdata),
162:     .error_i (reg_error)
163:   );
164: 
165:   // cdc oversampling signals
166: 
167:   assign reg_rdata = reg_rdata_next ;
168:   assign reg_error = addrmiss | wr_err | intg_err;
169: 
170:   // Define SW related signals
171:   // Format: <reg>_<field>_{wd|we|qs}
172:   //        or <reg>_{wd|we|qs} if field == 1 or 0
173:   logic intr_state_we;
174:   logic intr_state_hmac_done_qs;
175:   logic intr_state_hmac_done_wd;
176:   logic intr_state_fifo_empty_qs;
177:   logic intr_state_hmac_err_qs;
178:   logic intr_state_hmac_err_wd;
179:   logic intr_enable_we;
180:   logic intr_enable_hmac_done_qs;
181:   logic intr_enable_hmac_done_wd;
182:   logic intr_enable_fifo_empty_qs;
183:   logic intr_enable_fifo_empty_wd;
184:   logic intr_enable_hmac_err_qs;
185:   logic intr_enable_hmac_err_wd;
186:   logic intr_test_we;
187:   logic intr_test_hmac_done_wd;
188:   logic intr_test_fifo_empty_wd;
189:   logic intr_test_hmac_err_wd;
190:   logic alert_test_we;
191:   logic alert_test_wd;
192:   logic cfg_re;
193:   logic cfg_we;
194:   logic cfg_hmac_en_qs;
195:   logic cfg_hmac_en_wd;
196:   logic cfg_sha_en_qs;
197:   logic cfg_sha_en_wd;
198:   logic cfg_endian_swap_qs;
199:   logic cfg_endian_swap_wd;
200:   logic cfg_digest_swap_qs;
201:   logic cfg_digest_swap_wd;
202:   logic cfg_key_swap_qs;
203:   logic cfg_key_swap_wd;
204:   logic [3:0] cfg_digest_size_qs;
205:   logic [3:0] cfg_digest_size_wd;
206:   logic [5:0] cfg_key_length_qs;
207:   logic [5:0] cfg_key_length_wd;
208:   logic cmd_we;
209:   logic cmd_hash_start_wd;
210:   logic cmd_hash_process_wd;
211:   logic cmd_hash_stop_wd;
212:   logic cmd_hash_continue_wd;
213:   logic status_re;
214:   logic status_hmac_idle_qs;
215:   logic status_fifo_empty_qs;
216:   logic status_fifo_full_qs;
217:   logic [5:0] status_fifo_depth_qs;
218:   logic [31:0] err_code_qs;
219:   logic wipe_secret_we;
220:   logic [31:0] wipe_secret_wd;
221:   logic key_0_we;
222:   logic [31:0] key_0_wd;
223:   logic key_1_we;
224:   logic [31:0] key_1_wd;
225:   logic key_2_we;
226:   logic [31:0] key_2_wd;
227:   logic key_3_we;
228:   logic [31:0] key_3_wd;
229:   logic key_4_we;
230:   logic [31:0] key_4_wd;
231:   logic key_5_we;
232:   logic [31:0] key_5_wd;
233:   logic key_6_we;
234:   logic [31:0] key_6_wd;
235:   logic key_7_we;
236:   logic [31:0] key_7_wd;
237:   logic key_8_we;
238:   logic [31:0] key_8_wd;
239:   logic key_9_we;
240:   logic [31:0] key_9_wd;
241:   logic key_10_we;
242:   logic [31:0] key_10_wd;
243:   logic key_11_we;
244:   logic [31:0] key_11_wd;
245:   logic key_12_we;
246:   logic [31:0] key_12_wd;
247:   logic key_13_we;
248:   logic [31:0] key_13_wd;
249:   logic key_14_we;
250:   logic [31:0] key_14_wd;
251:   logic key_15_we;
252:   logic [31:0] key_15_wd;
253:   logic key_16_we;
254:   logic [31:0] key_16_wd;
255:   logic key_17_we;
256:   logic [31:0] key_17_wd;
257:   logic key_18_we;
258:   logic [31:0] key_18_wd;
259:   logic key_19_we;
260:   logic [31:0] key_19_wd;
261:   logic key_20_we;
262:   logic [31:0] key_20_wd;
263:   logic key_21_we;
264:   logic [31:0] key_21_wd;
265:   logic key_22_we;
266:   logic [31:0] key_22_wd;
267:   logic key_23_we;
268:   logic [31:0] key_23_wd;
269:   logic key_24_we;
270:   logic [31:0] key_24_wd;
271:   logic key_25_we;
272:   logic [31:0] key_25_wd;
273:   logic key_26_we;
274:   logic [31:0] key_26_wd;
275:   logic key_27_we;
276:   logic [31:0] key_27_wd;
277:   logic key_28_we;
278:   logic [31:0] key_28_wd;
279:   logic key_29_we;
280:   logic [31:0] key_29_wd;
281:   logic key_30_we;
282:   logic [31:0] key_30_wd;
283:   logic key_31_we;
284:   logic [31:0] key_31_wd;
285:   logic digest_0_re;
286:   logic digest_0_we;
287:   logic [31:0] digest_0_qs;
288:   logic [31:0] digest_0_wd;
289:   logic digest_1_re;
290:   logic digest_1_we;
291:   logic [31:0] digest_1_qs;
292:   logic [31:0] digest_1_wd;
293:   logic digest_2_re;
294:   logic digest_2_we;
295:   logic [31:0] digest_2_qs;
296:   logic [31:0] digest_2_wd;
297:   logic digest_3_re;
298:   logic digest_3_we;
299:   logic [31:0] digest_3_qs;
300:   logic [31:0] digest_3_wd;
301:   logic digest_4_re;
302:   logic digest_4_we;
303:   logic [31:0] digest_4_qs;
304:   logic [31:0] digest_4_wd;
305:   logic digest_5_re;
306:   logic digest_5_we;
307:   logic [31:0] digest_5_qs;
308:   logic [31:0] digest_5_wd;
309:   logic digest_6_re;
310:   logic digest_6_we;
311:   logic [31:0] digest_6_qs;
312:   logic [31:0] digest_6_wd;
313:   logic digest_7_re;
314:   logic digest_7_we;
315:   logic [31:0] digest_7_qs;
316:   logic [31:0] digest_7_wd;
317:   logic digest_8_re;
318:   logic digest_8_we;
319:   logic [31:0] digest_8_qs;
320:   logic [31:0] digest_8_wd;
321:   logic digest_9_re;
322:   logic digest_9_we;
323:   logic [31:0] digest_9_qs;
324:   logic [31:0] digest_9_wd;
325:   logic digest_10_re;
326:   logic digest_10_we;
327:   logic [31:0] digest_10_qs;
328:   logic [31:0] digest_10_wd;
329:   logic digest_11_re;
330:   logic digest_11_we;
331:   logic [31:0] digest_11_qs;
332:   logic [31:0] digest_11_wd;
333:   logic digest_12_re;
334:   logic digest_12_we;
335:   logic [31:0] digest_12_qs;
336:   logic [31:0] digest_12_wd;
337:   logic digest_13_re;
338:   logic digest_13_we;
339:   logic [31:0] digest_13_qs;
340:   logic [31:0] digest_13_wd;
341:   logic digest_14_re;
342:   logic digest_14_we;
343:   logic [31:0] digest_14_qs;
344:   logic [31:0] digest_14_wd;
345:   logic digest_15_re;
346:   logic digest_15_we;
347:   logic [31:0] digest_15_qs;
348:   logic [31:0] digest_15_wd;
349:   logic msg_length_lower_re;
350:   logic msg_length_lower_we;
351:   logic [31:0] msg_length_lower_qs;
352:   logic [31:0] msg_length_lower_wd;
353:   logic msg_length_upper_re;
354:   logic msg_length_upper_we;
355:   logic [31:0] msg_length_upper_qs;
356:   logic [31:0] msg_length_upper_wd;
357: 
358:   // Register instances
359:   // R[intr_state]: V(False)
360:   //   F[hmac_done]: 0:0
361:   prim_subreg #(
362:     .DW      (1),
363:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
364:     .RESVAL  (1'h0),
365:     .Mubi    (1'b0)
366:   ) u_intr_state_hmac_done (
367:     .clk_i   (clk_i),
368:     .rst_ni  (rst_ni),
369: 
370:     // from register interface
371:     .we     (intr_state_we),
372:     .wd     (intr_state_hmac_done_wd),
373: 
374:     // from internal hardware
375:     .de     (hw2reg.intr_state.hmac_done.de),
376:     .d      (hw2reg.intr_state.hmac_done.d),
377: 
378:     // to internal hardware
379:     .qe     (),
380:     .q      (reg2hw.intr_state.hmac_done.q),
381:     .ds     (),
382: 
383:     // to register interface (read)
384:     .qs     (intr_state_hmac_done_qs)
385:   );
386: 
387:   //   F[fifo_empty]: 1:1
388:   prim_subreg #(
389:     .DW      (1),
390:     .SwAccess(prim_subreg_pkg::SwAccessRO),
391:     .RESVAL  (1'h0),
392:     .Mubi    (1'b0)
393:   ) u_intr_state_fifo_empty (
394:     .clk_i   (clk_i),
395:     .rst_ni  (rst_ni),
396: 
397:     // from register interface
398:     .we     (1'b0),
399:     .wd     ('0),
400: 
401:     // from internal hardware
402:     .de     (hw2reg.intr_state.fifo_empty.de),
403:     .d      (hw2reg.intr_state.fifo_empty.d),
404: 
405:     // to internal hardware
406:     .qe     (),
407:     .q      (reg2hw.intr_state.fifo_empty.q),
408:     .ds     (),
409: 
410:     // to register interface (read)
411:     .qs     (intr_state_fifo_empty_qs)
412:   );
413: 
414:   //   F[hmac_err]: 2:2
415:   prim_subreg #(
416:     .DW      (1),
417:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
418:     .RESVAL  (1'h0),
419:     .Mubi    (1'b0)
420:   ) u_intr_state_hmac_err (
421:     .clk_i   (clk_i),
422:     .rst_ni  (rst_ni),
423: 
424:     // from register interface
425:     .we     (intr_state_we),
426:     .wd     (intr_state_hmac_err_wd),
427: 
428:     // from internal hardware
429:     .de     (hw2reg.intr_state.hmac_err.de),
430:     .d      (hw2reg.intr_state.hmac_err.d),
431: 
432:     // to internal hardware
433:     .qe     (),
434:     .q      (reg2hw.intr_state.hmac_err.q),
435:     .ds     (),
436: 
437:     // to register interface (read)
438:     .qs     (intr_state_hmac_err_qs)
439:   );
440: 
441: 
442:   // R[intr_enable]: V(False)
443:   //   F[hmac_done]: 0:0
444:   prim_subreg #(
445:     .DW      (1),
446:     .SwAccess(prim_subreg_pkg::SwAccessRW),
447:     .RESVAL  (1'h0),
448:     .Mubi    (1'b0)
449:   ) u_intr_enable_hmac_done (
450:     .clk_i   (clk_i),
451:     .rst_ni  (rst_ni),
452: 
453:     // from register interface
454:     .we     (intr_enable_we),
455:     .wd     (intr_enable_hmac_done_wd),
456: 
457:     // from internal hardware
458:     .de     (1'b0),
459:     .d      ('0),
460: 
461:     // to internal hardware
462:     .qe     (),
463:     .q      (reg2hw.intr_enable.hmac_done.q),
464:     .ds     (),
465: 
466:     // to register interface (read)
467:     .qs     (intr_enable_hmac_done_qs)
468:   );
469: 
470:   //   F[fifo_empty]: 1:1
471:   prim_subreg #(
472:     .DW      (1),
473:     .SwAccess(prim_subreg_pkg::SwAccessRW),
474:     .RESVAL  (1'h0),
475:     .Mubi    (1'b0)
476:   ) u_intr_enable_fifo_empty (
477:     .clk_i   (clk_i),
478:     .rst_ni  (rst_ni),
479: 
480:     // from register interface
481:     .we     (intr_enable_we),
482:     .wd     (intr_enable_fifo_empty_wd),
483: 
484:     // from internal hardware
485:     .de     (1'b0),
486:     .d      ('0),
487: 
488:     // to internal hardware
489:     .qe     (),
490:     .q      (reg2hw.intr_enable.fifo_empty.q),
491:     .ds     (),
492: 
493:     // to register interface (read)
494:     .qs     (intr_enable_fifo_empty_qs)
495:   );
496: 
497:   //   F[hmac_err]: 2:2
498:   prim_subreg #(
499:     .DW      (1),
500:     .SwAccess(prim_subreg_pkg::SwAccessRW),
501:     .RESVAL  (1'h0),
502:     .Mubi    (1'b0)
503:   ) u_intr_enable_hmac_err (
504:     .clk_i   (clk_i),
505:     .rst_ni  (rst_ni),
506: 
507:     // from register interface
508:     .we     (intr_enable_we),
509:     .wd     (intr_enable_hmac_err_wd),
510: 
511:     // from internal hardware
512:     .de     (1'b0),
513:     .d      ('0),
514: 
515:     // to internal hardware
516:     .qe     (),
517:     .q      (reg2hw.intr_enable.hmac_err.q),
518:     .ds     (),
519: 
520:     // to register interface (read)
521:     .qs     (intr_enable_hmac_err_qs)
522:   );
523: 
524: 
525:   // R[intr_test]: V(True)
526:   logic intr_test_qe;
527:   logic [2:0] intr_test_flds_we;
528:   assign intr_test_qe = &intr_test_flds_we;
529:   //   F[hmac_done]: 0:0
530:   prim_subreg_ext #(
531:     .DW    (1)
532:   ) u_intr_test_hmac_done (
533:     .re     (1'b0),
534:     .we     (intr_test_we),
535:     .wd     (intr_test_hmac_done_wd),
536:     .d      ('0),
537:     .qre    (),
538:     .qe     (intr_test_flds_we[0]),
539:     .q      (reg2hw.intr_test.hmac_done.q),
540:     .ds     (),
541:     .qs     ()
542:   );
543:   assign reg2hw.intr_test.hmac_done.qe = intr_test_qe;
544: 
545:   //   F[fifo_empty]: 1:1
546:   prim_subreg_ext #(
547:     .DW    (1)
548:   ) u_intr_test_fifo_empty (
549:     .re     (1'b0),
550:     .we     (intr_test_we),
551:     .wd     (intr_test_fifo_empty_wd),
552:     .d      ('0),
553:     .qre    (),
554:     .qe     (intr_test_flds_we[1]),
555:     .q      (reg2hw.intr_test.fifo_empty.q),
556:     .ds     (),
557:     .qs     ()
558:   );
559:   assign reg2hw.intr_test.fifo_empty.qe = intr_test_qe;
560: 
561:   //   F[hmac_err]: 2:2
562:   prim_subreg_ext #(
563:     .DW    (1)
564:   ) u_intr_test_hmac_err (
565:     .re     (1'b0),
566:     .we     (intr_test_we),
567:     .wd     (intr_test_hmac_err_wd),
568:     .d      ('0),
569:     .qre    (),
570:     .qe     (intr_test_flds_we[2]),
571:     .q      (reg2hw.intr_test.hmac_err.q),
572:     .ds     (),
573:     .qs     ()
574:   );
575:   assign reg2hw.intr_test.hmac_err.qe = intr_test_qe;
576: 
577: 
578:   // R[alert_test]: V(True)
579:   logic alert_test_qe;
580:   logic [0:0] alert_test_flds_we;
581:   assign alert_test_qe = &alert_test_flds_we;
582:   prim_subreg_ext #(
583:     .DW    (1)
584:   ) u_alert_test (
585:     .re     (1'b0),
586:     .we     (alert_test_we),
587:     .wd     (alert_test_wd),
588:     .d      ('0),
589:     .qre    (),
590:     .qe     (alert_test_flds_we[0]),
591:     .q      (reg2hw.alert_test.q),
592:     .ds     (),
593:     .qs     ()
594:   );
595:   assign reg2hw.alert_test.qe = alert_test_qe;
596: 
597: 
598:   // R[cfg]: V(True)
599:   logic cfg_qe;
600:   logic [6:0] cfg_flds_we;
601:   assign cfg_qe = &cfg_flds_we;
602:   //   F[hmac_en]: 0:0
603:   prim_subreg_ext #(
604:     .DW    (1)
605:   ) u_cfg_hmac_en (
606:     .re     (cfg_re),
607:     .we     (cfg_we),
608:     .wd     (cfg_hmac_en_wd),
609:     .d      (hw2reg.cfg.hmac_en.d),
610:     .qre    (),
611:     .qe     (cfg_flds_we[0]),
612:     .q      (reg2hw.cfg.hmac_en.q),
613:     .ds     (),
614:     .qs     (cfg_hmac_en_qs)
615:   );
616:   assign reg2hw.cfg.hmac_en.qe = cfg_qe;
617: 
618:   //   F[sha_en]: 1:1
619:   prim_subreg_ext #(
620:     .DW    (1)
621:   ) u_cfg_sha_en (
622:     .re     (cfg_re),
623:     .we     (cfg_we),
624:     .wd     (cfg_sha_en_wd),
625:     .d      (hw2reg.cfg.sha_en.d),
626:     .qre    (),
627:     .qe     (cfg_flds_we[1]),
628:     .q      (reg2hw.cfg.sha_en.q),
629:     .ds     (),
630:     .qs     (cfg_sha_en_qs)
631:   );
632:   assign reg2hw.cfg.sha_en.qe = cfg_qe;
633: 
634:   //   F[endian_swap]: 2:2
635:   prim_subreg_ext #(
636:     .DW    (1)
637:   ) u_cfg_endian_swap (
638:     .re     (cfg_re),
639:     .we     (cfg_we),
640:     .wd     (cfg_endian_swap_wd),
641:     .d      (hw2reg.cfg.endian_swap.d),
642:     .qre    (),
643:     .qe     (cfg_flds_we[2]),
644:     .q      (reg2hw.cfg.endian_swap.q),
645:     .ds     (),
646:     .qs     (cfg_endian_swap_qs)
647:   );
648:   assign reg2hw.cfg.endian_swap.qe = cfg_qe;
649: 
650:   //   F[digest_swap]: 3:3
651:   prim_subreg_ext #(
652:     .DW    (1)
653:   ) u_cfg_digest_swap (
654:     .re     (cfg_re),
655:     .we     (cfg_we),
656:     .wd     (cfg_digest_swap_wd),
657:     .d      (hw2reg.cfg.digest_swap.d),
658:     .qre    (),
659:     .qe     (cfg_flds_we[3]),
660:     .q      (reg2hw.cfg.digest_swap.q),
661:     .ds     (),
662:     .qs     (cfg_digest_swap_qs)
663:   );
664:   assign reg2hw.cfg.digest_swap.qe = cfg_qe;
665: 
666:   //   F[key_swap]: 4:4
667:   prim_subreg_ext #(
668:     .DW    (1)
669:   ) u_cfg_key_swap (
670:     .re     (cfg_re),
671:     .we     (cfg_we),
672:     .wd     (cfg_key_swap_wd),
673:     .d      (hw2reg.cfg.key_swap.d),
674:     .qre    (),
675:     .qe     (cfg_flds_we[4]),
676:     .q      (reg2hw.cfg.key_swap.q),
677:     .ds     (),
678:     .qs     (cfg_key_swap_qs)
679:   );
680:   assign reg2hw.cfg.key_swap.qe = cfg_qe;
681: 
682:   //   F[digest_size]: 8:5
683:   prim_subreg_ext #(
684:     .DW    (4)
685:   ) u_cfg_digest_size (
686:     .re     (cfg_re),
687:     .we     (cfg_we),
688:     .wd     (cfg_digest_size_wd),
689:     .d      (hw2reg.cfg.digest_size.d),
690:     .qre    (),
691:     .qe     (cfg_flds_we[5]),
692:     .q      (reg2hw.cfg.digest_size.q),
693:     .ds     (),
694:     .qs     (cfg_digest_size_qs)
695:   );
696:   assign reg2hw.cfg.digest_size.qe = cfg_qe;
697: 
698:   //   F[key_length]: 14:9
699:   prim_subreg_ext #(
700:     .DW    (6)
701:   ) u_cfg_key_length (
702:     .re     (cfg_re),
703:     .we     (cfg_we),
704:     .wd     (cfg_key_length_wd),
705:     .d      (hw2reg.cfg.key_length.d),
706:     .qre    (),
707:     .qe     (cfg_flds_we[6]),
708:     .q      (reg2hw.cfg.key_length.q),
709:     .ds     (),
710:     .qs     (cfg_key_length_qs)
711:   );
712:   assign reg2hw.cfg.key_length.qe = cfg_qe;
713: 
714: 
715:   // R[cmd]: V(True)
716:   logic cmd_qe;
717:   logic [3:0] cmd_flds_we;
718:   assign cmd_qe = &cmd_flds_we;
719:   //   F[hash_start]: 0:0
720:   prim_subreg_ext #(
721:     .DW    (1)
722:   ) u_cmd_hash_start (
723:     .re     (1'b0),
724:     .we     (cmd_we),
725:     .wd     (cmd_hash_start_wd),
726:     .d      ('0),
727:     .qre    (),
728:     .qe     (cmd_flds_we[0]),
729:     .q      (reg2hw.cmd.hash_start.q),
730:     .ds     (),
731:     .qs     ()
732:   );
733:   assign reg2hw.cmd.hash_start.qe = cmd_qe;
734: 
735:   //   F[hash_process]: 1:1
736:   prim_subreg_ext #(
737:     .DW    (1)
738:   ) u_cmd_hash_process (
739:     .re     (1'b0),
740:     .we     (cmd_we),
741:     .wd     (cmd_hash_process_wd),
742:     .d      ('0),
743:     .qre    (),
744:     .qe     (cmd_flds_we[1]),
745:     .q      (reg2hw.cmd.hash_process.q),
746:     .ds     (),
747:     .qs     ()
748:   );
749:   assign reg2hw.cmd.hash_process.qe = cmd_qe;
750: 
751:   //   F[hash_stop]: 2:2
752:   prim_subreg_ext #(
753:     .DW    (1)
754:   ) u_cmd_hash_stop (
755:     .re     (1'b0),
756:     .we     (cmd_we),
757:     .wd     (cmd_hash_stop_wd),
758:     .d      ('0),
759:     .qre    (),
760:     .qe     (cmd_flds_we[2]),
761:     .q      (reg2hw.cmd.hash_stop.q),
762:     .ds     (),
763:     .qs     ()
764:   );
765:   assign reg2hw.cmd.hash_stop.qe = cmd_qe;
766: 
767:   //   F[hash_continue]: 3:3
768:   prim_subreg_ext #(
769:     .DW    (1)
770:   ) u_cmd_hash_continue (
771:     .re     (1'b0),
772:     .we     (cmd_we),
773:     .wd     (cmd_hash_continue_wd),
774:     .d      ('0),
775:     .qre    (),
776:     .qe     (cmd_flds_we[3]),
777:     .q      (reg2hw.cmd.hash_continue.q),
778:     .ds     (),
779:     .qs     ()
780:   );
781:   assign reg2hw.cmd.hash_continue.qe = cmd_qe;
782: 
783: 
784:   // R[status]: V(True)
785:   //   F[hmac_idle]: 0:0
786:   prim_subreg_ext #(
787:     .DW    (1)
788:   ) u_status_hmac_idle (
789:     .re     (status_re),
790:     .we     (1'b0),
791:     .wd     ('0),
792:     .d      (hw2reg.status.hmac_idle.d),
793:     .qre    (),
794:     .qe     (),
795:     .q      (),
796:     .ds     (),
797:     .qs     (status_hmac_idle_qs)
798:   );
799: 
800:   //   F[fifo_empty]: 1:1
801:   prim_subreg_ext #(
802:     .DW    (1)
803:   ) u_status_fifo_empty (
804:     .re     (status_re),
805:     .we     (1'b0),
806:     .wd     ('0),
807:     .d      (hw2reg.status.fifo_empty.d),
808:     .qre    (),
809:     .qe     (),
810:     .q      (),
811:     .ds     (),
812:     .qs     (status_fifo_empty_qs)
813:   );
814: 
815:   //   F[fifo_full]: 2:2
816:   prim_subreg_ext #(
817:     .DW    (1)
818:   ) u_status_fifo_full (
819:     .re     (status_re),
820:     .we     (1'b0),
821:     .wd     ('0),
822:     .d      (hw2reg.status.fifo_full.d),
823:     .qre    (),
824:     .qe     (),
825:     .q      (),
826:     .ds     (),
827:     .qs     (status_fifo_full_qs)
828:   );
829: 
830:   //   F[fifo_depth]: 9:4
831:   prim_subreg_ext #(
832:     .DW    (6)
833:   ) u_status_fifo_depth (
834:     .re     (status_re),
835:     .we     (1'b0),
836:     .wd     ('0),
837:     .d      (hw2reg.status.fifo_depth.d),
838:     .qre    (),
839:     .qe     (),
840:     .q      (),
841:     .ds     (),
842:     .qs     (status_fifo_depth_qs)
843:   );
844: 
845: 
846:   // R[err_code]: V(False)
847:   prim_subreg #(
848:     .DW      (32),
849:     .SwAccess(prim_subreg_pkg::SwAccessRO),
850:     .RESVAL  (32'h0),
851:     .Mubi    (1'b0)
852:   ) u_err_code (
853:     .clk_i   (clk_i),
854:     .rst_ni  (rst_ni),
855: 
856:     // from register interface
857:     .we     (1'b0),
858:     .wd     ('0),
859: 
860:     // from internal hardware
861:     .de     (hw2reg.err_code.de),
862:     .d      (hw2reg.err_code.d),
863: 
864:     // to internal hardware
865:     .qe     (),
866:     .q      (),
867:     .ds     (),
868: 
869:     // to register interface (read)
870:     .qs     (err_code_qs)
871:   );
872: 
873: 
874:   // R[wipe_secret]: V(True)
875:   logic wipe_secret_qe;
876:   logic [0:0] wipe_secret_flds_we;
877:   assign wipe_secret_qe = &wipe_secret_flds_we;
878:   prim_subreg_ext #(
879:     .DW    (32)
880:   ) u_wipe_secret (
881:     .re     (1'b0),
882:     .we     (wipe_secret_we),
883:     .wd     (wipe_secret_wd),
884:     .d      ('0),
885:     .qre    (),
886:     .qe     (wipe_secret_flds_we[0]),
887:     .q      (reg2hw.wipe_secret.q),
888:     .ds     (),
889:     .qs     ()
890:   );
891:   assign reg2hw.wipe_secret.qe = wipe_secret_qe;
892: 
893: 
894:   // Subregister 0 of Multireg key
895:   // R[key_0]: V(True)
896:   logic key_0_qe;
897:   logic [0:0] key_0_flds_we;
898:   assign key_0_qe = &key_0_flds_we;
899:   prim_subreg_ext #(
900:     .DW    (32)
901:   ) u_key_0 (
902:     .re     (1'b0),
903:     .we     (key_0_we),
904:     .wd     (key_0_wd),
905:     .d      (hw2reg.key[0].d),
906:     .qre    (),
907:     .qe     (key_0_flds_we[0]),
908:     .q      (reg2hw.key[0].q),
909:     .ds     (),
910:     .qs     ()
911:   );
912:   assign reg2hw.key[0].qe = key_0_qe;
913: 
914: 
915:   // Subregister 1 of Multireg key
916:   // R[key_1]: V(True)
917:   logic key_1_qe;
918:   logic [0:0] key_1_flds_we;
919:   assign key_1_qe = &key_1_flds_we;
920:   prim_subreg_ext #(
921:     .DW    (32)
922:   ) u_key_1 (
923:     .re     (1'b0),
924:     .we     (key_1_we),
925:     .wd     (key_1_wd),
926:     .d      (hw2reg.key[1].d),
927:     .qre    (),
928:     .qe     (key_1_flds_we[0]),
929:     .q      (reg2hw.key[1].q),
930:     .ds     (),
931:     .qs     ()
932:   );
933:   assign reg2hw.key[1].qe = key_1_qe;
934: 
935: 
936:   // Subregister 2 of Multireg key
937:   // R[key_2]: V(True)
938:   logic key_2_qe;
939:   logic [0:0] key_2_flds_we;
940:   assign key_2_qe = &key_2_flds_we;
941:   prim_subreg_ext #(
942:     .DW    (32)
943:   ) u_key_2 (
944:     .re     (1'b0),
945:     .we     (key_2_we),
946:     .wd     (key_2_wd),
947:     .d      (hw2reg.key[2].d),
948:     .qre    (),
949:     .qe     (key_2_flds_we[0]),
950:     .q      (reg2hw.key[2].q),
951:     .ds     (),
952:     .qs     ()
953:   );
954:   assign reg2hw.key[2].qe = key_2_qe;
955: 
956: 
957:   // Subregister 3 of Multireg key
958:   // R[key_3]: V(True)
959:   logic key_3_qe;
960:   logic [0:0] key_3_flds_we;
961:   assign key_3_qe = &key_3_flds_we;
962:   prim_subreg_ext #(
963:     .DW    (32)
964:   ) u_key_3 (
965:     .re     (1'b0),
966:     .we     (key_3_we),
967:     .wd     (key_3_wd),
968:     .d      (hw2reg.key[3].d),
969:     .qre    (),
970:     .qe     (key_3_flds_we[0]),
971:     .q      (reg2hw.key[3].q),
972:     .ds     (),
973:     .qs     ()
974:   );
975:   assign reg2hw.key[3].qe = key_3_qe;
976: 
977: 
978:   // Subregister 4 of Multireg key
979:   // R[key_4]: V(True)
980:   logic key_4_qe;
981:   logic [0:0] key_4_flds_we;
982:   assign key_4_qe = &key_4_flds_we;
983:   prim_subreg_ext #(
984:     .DW    (32)
985:   ) u_key_4 (
986:     .re     (1'b0),
987:     .we     (key_4_we),
988:     .wd     (key_4_wd),
989:     .d      (hw2reg.key[4].d),
990:     .qre    (),
991:     .qe     (key_4_flds_we[0]),
992:     .q      (reg2hw.key[4].q),
993:     .ds     (),
994:     .qs     ()
995:   );
996:   assign reg2hw.key[4].qe = key_4_qe;
997: 
998: 
999:   // Subregister 5 of Multireg key
1000:   // R[key_5]: V(True)
1001:   logic key_5_qe;
1002:   logic [0:0] key_5_flds_we;
1003:   assign key_5_qe = &key_5_flds_we;
1004:   prim_subreg_ext #(
1005:     .DW    (32)
1006:   ) u_key_5 (
1007:     .re     (1'b0),
1008:     .we     (key_5_we),
1009:     .wd     (key_5_wd),
1010:     .d      (hw2reg.key[5].d),
1011:     .qre    (),
1012:     .qe     (key_5_flds_we[0]),
1013:     .q      (reg2hw.key[5].q),
1014:     .ds     (),
1015:     .qs     ()
1016:   );
1017:   assign reg2hw.key[5].qe = key_5_qe;
1018: 
1019: 
1020:   // Subregister 6 of Multireg key
1021:   // R[key_6]: V(True)
1022:   logic key_6_qe;
1023:   logic [0:0] key_6_flds_we;
1024:   assign key_6_qe = &key_6_flds_we;
1025:   prim_subreg_ext #(
1026:     .DW    (32)
1027:   ) u_key_6 (
1028:     .re     (1'b0),
1029:     .we     (key_6_we),
1030:     .wd     (key_6_wd),
1031:     .d      (hw2reg.key[6].d),
1032:     .qre    (),
1033:     .qe     (key_6_flds_we[0]),
1034:     .q      (reg2hw.key[6].q),
1035:     .ds     (),
1036:     .qs     ()
1037:   );
1038:   assign reg2hw.key[6].qe = key_6_qe;
1039: 
1040: 
1041:   // Subregister 7 of Multireg key
1042:   // R[key_7]: V(True)
1043:   logic key_7_qe;
1044:   logic [0:0] key_7_flds_we;
1045:   assign key_7_qe = &key_7_flds_we;
1046:   prim_subreg_ext #(
1047:     .DW    (32)
1048:   ) u_key_7 (
1049:     .re     (1'b0),
1050:     .we     (key_7_we),
1051:     .wd     (key_7_wd),
1052:     .d      (hw2reg.key[7].d),
1053:     .qre    (),
1054:     .qe     (key_7_flds_we[0]),
1055:     .q      (reg2hw.key[7].q),
1056:     .ds     (),
1057:     .qs     ()
1058:   );
1059:   assign reg2hw.key[7].qe = key_7_qe;
1060: 
1061: 
1062:   // Subregister 8 of Multireg key
1063:   // R[key_8]: V(True)
1064:   logic key_8_qe;
1065:   logic [0:0] key_8_flds_we;
1066:   assign key_8_qe = &key_8_flds_we;
1067:   prim_subreg_ext #(
1068:     .DW    (32)
1069:   ) u_key_8 (
1070:     .re     (1'b0),
1071:     .we     (key_8_we),
1072:     .wd     (key_8_wd),
1073:     .d      (hw2reg.key[8].d),
1074:     .qre    (),
1075:     .qe     (key_8_flds_we[0]),
1076:     .q      (reg2hw.key[8].q),
1077:     .ds     (),
1078:     .qs     ()
1079:   );
1080:   assign reg2hw.key[8].qe = key_8_qe;
1081: 
1082: 
1083:   // Subregister 9 of Multireg key
1084:   // R[key_9]: V(True)
1085:   logic key_9_qe;
1086:   logic [0:0] key_9_flds_we;
1087:   assign key_9_qe = &key_9_flds_we;
1088:   prim_subreg_ext #(
1089:     .DW    (32)
1090:   ) u_key_9 (
1091:     .re     (1'b0),
1092:     .we     (key_9_we),
1093:     .wd     (key_9_wd),
1094:     .d      (hw2reg.key[9].d),
1095:     .qre    (),
1096:     .qe     (key_9_flds_we[0]),
1097:     .q      (reg2hw.key[9].q),
1098:     .ds     (),
1099:     .qs     ()
1100:   );
1101:   assign reg2hw.key[9].qe = key_9_qe;
1102: 
1103: 
1104:   // Subregister 10 of Multireg key
1105:   // R[key_10]: V(True)
1106:   logic key_10_qe;
1107:   logic [0:0] key_10_flds_we;
1108:   assign key_10_qe = &key_10_flds_we;
1109:   prim_subreg_ext #(
1110:     .DW    (32)
1111:   ) u_key_10 (
1112:     .re     (1'b0),
1113:     .we     (key_10_we),
1114:     .wd     (key_10_wd),
1115:     .d      (hw2reg.key[10].d),
1116:     .qre    (),
1117:     .qe     (key_10_flds_we[0]),
1118:     .q      (reg2hw.key[10].q),
1119:     .ds     (),
1120:     .qs     ()
1121:   );
1122:   assign reg2hw.key[10].qe = key_10_qe;
1123: 
1124: 
1125:   // Subregister 11 of Multireg key
1126:   // R[key_11]: V(True)
1127:   logic key_11_qe;
1128:   logic [0:0] key_11_flds_we;
1129:   assign key_11_qe = &key_11_flds_we;
1130:   prim_subreg_ext #(
1131:     .DW    (32)
1132:   ) u_key_11 (
1133:     .re     (1'b0),
1134:     .we     (key_11_we),
1135:     .wd     (key_11_wd),
1136:     .d      (hw2reg.key[11].d),
1137:     .qre    (),
1138:     .qe     (key_11_flds_we[0]),
1139:     .q      (reg2hw.key[11].q),
1140:     .ds     (),
1141:     .qs     ()
1142:   );
1143:   assign reg2hw.key[11].qe = key_11_qe;
1144: 
1145: 
1146:   // Subregister 12 of Multireg key
1147:   // R[key_12]: V(True)
1148:   logic key_12_qe;
1149:   logic [0:0] key_12_flds_we;
1150:   assign key_12_qe = &key_12_flds_we;
1151:   prim_subreg_ext #(
1152:     .DW    (32)
1153:   ) u_key_12 (
1154:     .re     (1'b0),
1155:     .we     (key_12_we),
1156:     .wd     (key_12_wd),
1157:     .d      (hw2reg.key[12].d),
1158:     .qre    (),
1159:     .qe     (key_12_flds_we[0]),
1160:     .q      (reg2hw.key[12].q),
1161:     .ds     (),
1162:     .qs     ()
1163:   );
1164:   assign reg2hw.key[12].qe = key_12_qe;
1165: 
1166: 
1167:   // Subregister 13 of Multireg key
1168:   // R[key_13]: V(True)
1169:   logic key_13_qe;
1170:   logic [0:0] key_13_flds_we;
1171:   assign key_13_qe = &key_13_flds_we;
1172:   prim_subreg_ext #(
1173:     .DW    (32)
1174:   ) u_key_13 (
1175:     .re     (1'b0),
1176:     .we     (key_13_we),
1177:     .wd     (key_13_wd),
1178:     .d      (hw2reg.key[13].d),
1179:     .qre    (),
1180:     .qe     (key_13_flds_we[0]),
1181:     .q      (reg2hw.key[13].q),
1182:     .ds     (),
1183:     .qs     ()
1184:   );
1185:   assign reg2hw.key[13].qe = key_13_qe;
1186: 
1187: 
1188:   // Subregister 14 of Multireg key
1189:   // R[key_14]: V(True)
1190:   logic key_14_qe;
1191:   logic [0:0] key_14_flds_we;
1192:   assign key_14_qe = &key_14_flds_we;
1193:   prim_subreg_ext #(
1194:     .DW    (32)
1195:   ) u_key_14 (
1196:     .re     (1'b0),
1197:     .we     (key_14_we),
1198:     .wd     (key_14_wd),
1199:     .d      (hw2reg.key[14].d),
1200:     .qre    (),
1201:     .qe     (key_14_flds_we[0]),
1202:     .q      (reg2hw.key[14].q),
1203:     .ds     (),
1204:     .qs     ()
1205:   );
1206:   assign reg2hw.key[14].qe = key_14_qe;
1207: 
1208: 
1209:   // Subregister 15 of Multireg key
1210:   // R[key_15]: V(True)
1211:   logic key_15_qe;
1212:   logic [0:0] key_15_flds_we;
1213:   assign key_15_qe = &key_15_flds_we;
1214:   prim_subreg_ext #(
1215:     .DW    (32)
1216:   ) u_key_15 (
1217:     .re     (1'b0),
1218:     .we     (key_15_we),
1219:     .wd     (key_15_wd),
1220:     .d      (hw2reg.key[15].d),
1221:     .qre    (),
1222:     .qe     (key_15_flds_we[0]),
1223:     .q      (reg2hw.key[15].q),
1224:     .ds     (),
1225:     .qs     ()
1226:   );
1227:   assign reg2hw.key[15].qe = key_15_qe;
1228: 
1229: 
1230:   // Subregister 16 of Multireg key
1231:   // R[key_16]: V(True)
1232:   logic key_16_qe;
1233:   logic [0:0] key_16_flds_we;
1234:   assign key_16_qe = &key_16_flds_we;
1235:   prim_subreg_ext #(
1236:     .DW    (32)
1237:   ) u_key_16 (
1238:     .re     (1'b0),
1239:     .we     (key_16_we),
1240:     .wd     (key_16_wd),
1241:     .d      (hw2reg.key[16].d),
1242:     .qre    (),
1243:     .qe     (key_16_flds_we[0]),
1244:     .q      (reg2hw.key[16].q),
1245:     .ds     (),
1246:     .qs     ()
1247:   );
1248:   assign reg2hw.key[16].qe = key_16_qe;
1249: 
1250: 
1251:   // Subregister 17 of Multireg key
1252:   // R[key_17]: V(True)
1253:   logic key_17_qe;
1254:   logic [0:0] key_17_flds_we;
1255:   assign key_17_qe = &key_17_flds_we;
1256:   prim_subreg_ext #(
1257:     .DW    (32)
1258:   ) u_key_17 (
1259:     .re     (1'b0),
1260:     .we     (key_17_we),
1261:     .wd     (key_17_wd),
1262:     .d      (hw2reg.key[17].d),
1263:     .qre    (),
1264:     .qe     (key_17_flds_we[0]),
1265:     .q      (reg2hw.key[17].q),
1266:     .ds     (),
1267:     .qs     ()
1268:   );
1269:   assign reg2hw.key[17].qe = key_17_qe;
1270: 
1271: 
1272:   // Subregister 18 of Multireg key
1273:   // R[key_18]: V(True)
1274:   logic key_18_qe;
1275:   logic [0:0] key_18_flds_we;
1276:   assign key_18_qe = &key_18_flds_we;
1277:   prim_subreg_ext #(
1278:     .DW    (32)
1279:   ) u_key_18 (
1280:     .re     (1'b0),
1281:     .we     (key_18_we),
1282:     .wd     (key_18_wd),
1283:     .d      (hw2reg.key[18].d),
1284:     .qre    (),
1285:     .qe     (key_18_flds_we[0]),
1286:     .q      (reg2hw.key[18].q),
1287:     .ds     (),
1288:     .qs     ()
1289:   );
1290:   assign reg2hw.key[18].qe = key_18_qe;
1291: 
1292: 
1293:   // Subregister 19 of Multireg key
1294:   // R[key_19]: V(True)
1295:   logic key_19_qe;
1296:   logic [0:0] key_19_flds_we;
1297:   assign key_19_qe = &key_19_flds_we;
1298:   prim_subreg_ext #(
1299:     .DW    (32)
1300:   ) u_key_19 (
1301:     .re     (1'b0),
1302:     .we     (key_19_we),
1303:     .wd     (key_19_wd),
1304:     .d      (hw2reg.key[19].d),
1305:     .qre    (),
1306:     .qe     (key_19_flds_we[0]),
1307:     .q      (reg2hw.key[19].q),
1308:     .ds     (),
1309:     .qs     ()
1310:   );
1311:   assign reg2hw.key[19].qe = key_19_qe;
1312: 
1313: 
1314:   // Subregister 20 of Multireg key
1315:   // R[key_20]: V(True)
1316:   logic key_20_qe;
1317:   logic [0:0] key_20_flds_we;
1318:   assign key_20_qe = &key_20_flds_we;
1319:   prim_subreg_ext #(
1320:     .DW    (32)
1321:   ) u_key_20 (
1322:     .re     (1'b0),
1323:     .we     (key_20_we),
1324:     .wd     (key_20_wd),
1325:     .d      (hw2reg.key[20].d),
1326:     .qre    (),
1327:     .qe     (key_20_flds_we[0]),
1328:     .q      (reg2hw.key[20].q),
1329:     .ds     (),
1330:     .qs     ()
1331:   );
1332:   assign reg2hw.key[20].qe = key_20_qe;
1333: 
1334: 
1335:   // Subregister 21 of Multireg key
1336:   // R[key_21]: V(True)
1337:   logic key_21_qe;
1338:   logic [0:0] key_21_flds_we;
1339:   assign key_21_qe = &key_21_flds_we;
1340:   prim_subreg_ext #(
1341:     .DW    (32)
1342:   ) u_key_21 (
1343:     .re     (1'b0),
1344:     .we     (key_21_we),
1345:     .wd     (key_21_wd),
1346:     .d      (hw2reg.key[21].d),
1347:     .qre    (),
1348:     .qe     (key_21_flds_we[0]),
1349:     .q      (reg2hw.key[21].q),
1350:     .ds     (),
1351:     .qs     ()
1352:   );
1353:   assign reg2hw.key[21].qe = key_21_qe;
1354: 
1355: 
1356:   // Subregister 22 of Multireg key
1357:   // R[key_22]: V(True)
1358:   logic key_22_qe;
1359:   logic [0:0] key_22_flds_we;
1360:   assign key_22_qe = &key_22_flds_we;
1361:   prim_subreg_ext #(
1362:     .DW    (32)
1363:   ) u_key_22 (
1364:     .re     (1'b0),
1365:     .we     (key_22_we),
1366:     .wd     (key_22_wd),
1367:     .d      (hw2reg.key[22].d),
1368:     .qre    (),
1369:     .qe     (key_22_flds_we[0]),
1370:     .q      (reg2hw.key[22].q),
1371:     .ds     (),
1372:     .qs     ()
1373:   );
1374:   assign reg2hw.key[22].qe = key_22_qe;
1375: 
1376: 
1377:   // Subregister 23 of Multireg key
1378:   // R[key_23]: V(True)
1379:   logic key_23_qe;
1380:   logic [0:0] key_23_flds_we;
1381:   assign key_23_qe = &key_23_flds_we;
1382:   prim_subreg_ext #(
1383:     .DW    (32)
1384:   ) u_key_23 (
1385:     .re     (1'b0),
1386:     .we     (key_23_we),
1387:     .wd     (key_23_wd),
1388:     .d      (hw2reg.key[23].d),
1389:     .qre    (),
1390:     .qe     (key_23_flds_we[0]),
1391:     .q      (reg2hw.key[23].q),
1392:     .ds     (),
1393:     .qs     ()
1394:   );
1395:   assign reg2hw.key[23].qe = key_23_qe;
1396: 
1397: 
1398:   // Subregister 24 of Multireg key
1399:   // R[key_24]: V(True)
1400:   logic key_24_qe;
1401:   logic [0:0] key_24_flds_we;
1402:   assign key_24_qe = &key_24_flds_we;
1403:   prim_subreg_ext #(
1404:     .DW    (32)
1405:   ) u_key_24 (
1406:     .re     (1'b0),
1407:     .we     (key_24_we),
1408:     .wd     (key_24_wd),
1409:     .d      (hw2reg.key[24].d),
1410:     .qre    (),
1411:     .qe     (key_24_flds_we[0]),
1412:     .q      (reg2hw.key[24].q),
1413:     .ds     (),
1414:     .qs     ()
1415:   );
1416:   assign reg2hw.key[24].qe = key_24_qe;
1417: 
1418: 
1419:   // Subregister 25 of Multireg key
1420:   // R[key_25]: V(True)
1421:   logic key_25_qe;
1422:   logic [0:0] key_25_flds_we;
1423:   assign key_25_qe = &key_25_flds_we;
1424:   prim_subreg_ext #(
1425:     .DW    (32)
1426:   ) u_key_25 (
1427:     .re     (1'b0),
1428:     .we     (key_25_we),
1429:     .wd     (key_25_wd),
1430:     .d      (hw2reg.key[25].d),
1431:     .qre    (),
1432:     .qe     (key_25_flds_we[0]),
1433:     .q      (reg2hw.key[25].q),
1434:     .ds     (),
1435:     .qs     ()
1436:   );
1437:   assign reg2hw.key[25].qe = key_25_qe;
1438: 
1439: 
1440:   // Subregister 26 of Multireg key
1441:   // R[key_26]: V(True)
1442:   logic key_26_qe;
1443:   logic [0:0] key_26_flds_we;
1444:   assign key_26_qe = &key_26_flds_we;
1445:   prim_subreg_ext #(
1446:     .DW    (32)
1447:   ) u_key_26 (
1448:     .re     (1'b0),
1449:     .we     (key_26_we),
1450:     .wd     (key_26_wd),
1451:     .d      (hw2reg.key[26].d),
1452:     .qre    (),
1453:     .qe     (key_26_flds_we[0]),
1454:     .q      (reg2hw.key[26].q),
1455:     .ds     (),
1456:     .qs     ()
1457:   );
1458:   assign reg2hw.key[26].qe = key_26_qe;
1459: 
1460: 
1461:   // Subregister 27 of Multireg key
1462:   // R[key_27]: V(True)
1463:   logic key_27_qe;
1464:   logic [0:0] key_27_flds_we;
1465:   assign key_27_qe = &key_27_flds_we;
1466:   prim_subreg_ext #(
1467:     .DW    (32)
1468:   ) u_key_27 (
1469:     .re     (1'b0),
1470:     .we     (key_27_we),
1471:     .wd     (key_27_wd),
1472:     .d      (hw2reg.key[27].d),
1473:     .qre    (),
1474:     .qe     (key_27_flds_we[0]),
1475:     .q      (reg2hw.key[27].q),
1476:     .ds     (),
1477:     .qs     ()
1478:   );
1479:   assign reg2hw.key[27].qe = key_27_qe;
1480: 
1481: 
1482:   // Subregister 28 of Multireg key
1483:   // R[key_28]: V(True)
1484:   logic key_28_qe;
1485:   logic [0:0] key_28_flds_we;
1486:   assign key_28_qe = &key_28_flds_we;
1487:   prim_subreg_ext #(
1488:     .DW    (32)
1489:   ) u_key_28 (
1490:     .re     (1'b0),
1491:     .we     (key_28_we),
1492:     .wd     (key_28_wd),
1493:     .d      (hw2reg.key[28].d),
1494:     .qre    (),
1495:     .qe     (key_28_flds_we[0]),
1496:     .q      (reg2hw.key[28].q),
1497:     .ds     (),
1498:     .qs     ()
1499:   );
1500:   assign reg2hw.key[28].qe = key_28_qe;
1501: 
1502: 
1503:   // Subregister 29 of Multireg key
1504:   // R[key_29]: V(True)
1505:   logic key_29_qe;
1506:   logic [0:0] key_29_flds_we;
1507:   assign key_29_qe = &key_29_flds_we;
1508:   prim_subreg_ext #(
1509:     .DW    (32)
1510:   ) u_key_29 (
1511:     .re     (1'b0),
1512:     .we     (key_29_we),
1513:     .wd     (key_29_wd),
1514:     .d      (hw2reg.key[29].d),
1515:     .qre    (),
1516:     .qe     (key_29_flds_we[0]),
1517:     .q      (reg2hw.key[29].q),
1518:     .ds     (),
1519:     .qs     ()
1520:   );
1521:   assign reg2hw.key[29].qe = key_29_qe;
1522: 
1523: 
1524:   // Subregister 30 of Multireg key
1525:   // R[key_30]: V(True)
1526:   logic key_30_qe;
1527:   logic [0:0] key_30_flds_we;
1528:   assign key_30_qe = &key_30_flds_we;
1529:   prim_subreg_ext #(
1530:     .DW    (32)
1531:   ) u_key_30 (
1532:     .re     (1'b0),
1533:     .we     (key_30_we),
1534:     .wd     (key_30_wd),
1535:     .d      (hw2reg.key[30].d),
1536:     .qre    (),
1537:     .qe     (key_30_flds_we[0]),
1538:     .q      (reg2hw.key[30].q),
1539:     .ds     (),
1540:     .qs     ()
1541:   );
1542:   assign reg2hw.key[30].qe = key_30_qe;
1543: 
1544: 
1545:   // Subregister 31 of Multireg key
1546:   // R[key_31]: V(True)
1547:   logic key_31_qe;
1548:   logic [0:0] key_31_flds_we;
1549:   assign key_31_qe = &key_31_flds_we;
1550:   prim_subreg_ext #(
1551:     .DW    (32)
1552:   ) u_key_31 (
1553:     .re     (1'b0),
1554:     .we     (key_31_we),
1555:     .wd     (key_31_wd),
1556:     .d      (hw2reg.key[31].d),
1557:     .qre    (),
1558:     .qe     (key_31_flds_we[0]),
1559:     .q      (reg2hw.key[31].q),
1560:     .ds     (),
1561:     .qs     ()
1562:   );
1563:   assign reg2hw.key[31].qe = key_31_qe;
1564: 
1565: 
1566:   // Subregister 0 of Multireg digest
1567:   // R[digest_0]: V(True)
1568:   logic digest_0_qe;
1569:   logic [0:0] digest_0_flds_we;
1570:   assign digest_0_qe = &digest_0_flds_we;
1571:   prim_subreg_ext #(
1572:     .DW    (32)
1573:   ) u_digest_0 (
1574:     .re     (digest_0_re),
1575:     .we     (digest_0_we),
1576:     .wd     (digest_0_wd),
1577:     .d      (hw2reg.digest[0].d),
1578:     .qre    (),
1579:     .qe     (digest_0_flds_we[0]),
1580:     .q      (reg2hw.digest[0].q),
1581:     .ds     (),
1582:     .qs     (digest_0_qs)
1583:   );
1584:   assign reg2hw.digest[0].qe = digest_0_qe;
1585: 
1586: 
1587:   // Subregister 1 of Multireg digest
1588:   // R[digest_1]: V(True)
1589:   logic digest_1_qe;
1590:   logic [0:0] digest_1_flds_we;
1591:   assign digest_1_qe = &digest_1_flds_we;
1592:   prim_subreg_ext #(
1593:     .DW    (32)
1594:   ) u_digest_1 (
1595:     .re     (digest_1_re),
1596:     .we     (digest_1_we),
1597:     .wd     (digest_1_wd),
1598:     .d      (hw2reg.digest[1].d),
1599:     .qre    (),
1600:     .qe     (digest_1_flds_we[0]),
1601:     .q      (reg2hw.digest[1].q),
1602:     .ds     (),
1603:     .qs     (digest_1_qs)
1604:   );
1605:   assign reg2hw.digest[1].qe = digest_1_qe;
1606: 
1607: 
1608:   // Subregister 2 of Multireg digest
1609:   // R[digest_2]: V(True)
1610:   logic digest_2_qe;
1611:   logic [0:0] digest_2_flds_we;
1612:   assign digest_2_qe = &digest_2_flds_we;
1613:   prim_subreg_ext #(
1614:     .DW    (32)
1615:   ) u_digest_2 (
1616:     .re     (digest_2_re),
1617:     .we     (digest_2_we),
1618:     .wd     (digest_2_wd),
1619:     .d      (hw2reg.digest[2].d),
1620:     .qre    (),
1621:     .qe     (digest_2_flds_we[0]),
1622:     .q      (reg2hw.digest[2].q),
1623:     .ds     (),
1624:     .qs     (digest_2_qs)
1625:   );
1626:   assign reg2hw.digest[2].qe = digest_2_qe;
1627: 
1628: 
1629:   // Subregister 3 of Multireg digest
1630:   // R[digest_3]: V(True)
1631:   logic digest_3_qe;
1632:   logic [0:0] digest_3_flds_we;
1633:   assign digest_3_qe = &digest_3_flds_we;
1634:   prim_subreg_ext #(
1635:     .DW    (32)
1636:   ) u_digest_3 (
1637:     .re     (digest_3_re),
1638:     .we     (digest_3_we),
1639:     .wd     (digest_3_wd),
1640:     .d      (hw2reg.digest[3].d),
1641:     .qre    (),
1642:     .qe     (digest_3_flds_we[0]),
1643:     .q      (reg2hw.digest[3].q),
1644:     .ds     (),
1645:     .qs     (digest_3_qs)
1646:   );
1647:   assign reg2hw.digest[3].qe = digest_3_qe;
1648: 
1649: 
1650:   // Subregister 4 of Multireg digest
1651:   // R[digest_4]: V(True)
1652:   logic digest_4_qe;
1653:   logic [0:0] digest_4_flds_we;
1654:   assign digest_4_qe = &digest_4_flds_we;
1655:   prim_subreg_ext #(
1656:     .DW    (32)
1657:   ) u_digest_4 (
1658:     .re     (digest_4_re),
1659:     .we     (digest_4_we),
1660:     .wd     (digest_4_wd),
1661:     .d      (hw2reg.digest[4].d),
1662:     .qre    (),
1663:     .qe     (digest_4_flds_we[0]),
1664:     .q      (reg2hw.digest[4].q),
1665:     .ds     (),
1666:     .qs     (digest_4_qs)
1667:   );
1668:   assign reg2hw.digest[4].qe = digest_4_qe;
1669: 
1670: 
1671:   // Subregister 5 of Multireg digest
1672:   // R[digest_5]: V(True)
1673:   logic digest_5_qe;
1674:   logic [0:0] digest_5_flds_we;
1675:   assign digest_5_qe = &digest_5_flds_we;
1676:   prim_subreg_ext #(
1677:     .DW    (32)
1678:   ) u_digest_5 (
1679:     .re     (digest_5_re),
1680:     .we     (digest_5_we),
1681:     .wd     (digest_5_wd),
1682:     .d      (hw2reg.digest[5].d),
1683:     .qre    (),
1684:     .qe     (digest_5_flds_we[0]),
1685:     .q      (reg2hw.digest[5].q),
1686:     .ds     (),
1687:     .qs     (digest_5_qs)
1688:   );
1689:   assign reg2hw.digest[5].qe = digest_5_qe;
1690: 
1691: 
1692:   // Subregister 6 of Multireg digest
1693:   // R[digest_6]: V(True)
1694:   logic digest_6_qe;
1695:   logic [0:0] digest_6_flds_we;
1696:   assign digest_6_qe = &digest_6_flds_we;
1697:   prim_subreg_ext #(
1698:     .DW    (32)
1699:   ) u_digest_6 (
1700:     .re     (digest_6_re),
1701:     .we     (digest_6_we),
1702:     .wd     (digest_6_wd),
1703:     .d      (hw2reg.digest[6].d),
1704:     .qre    (),
1705:     .qe     (digest_6_flds_we[0]),
1706:     .q      (reg2hw.digest[6].q),
1707:     .ds     (),
1708:     .qs     (digest_6_qs)
1709:   );
1710:   assign reg2hw.digest[6].qe = digest_6_qe;
1711: 
1712: 
1713:   // Subregister 7 of Multireg digest
1714:   // R[digest_7]: V(True)
1715:   logic digest_7_qe;
1716:   logic [0:0] digest_7_flds_we;
1717:   assign digest_7_qe = &digest_7_flds_we;
1718:   prim_subreg_ext #(
1719:     .DW    (32)
1720:   ) u_digest_7 (
1721:     .re     (digest_7_re),
1722:     .we     (digest_7_we),
1723:     .wd     (digest_7_wd),
1724:     .d      (hw2reg.digest[7].d),
1725:     .qre    (),
1726:     .qe     (digest_7_flds_we[0]),
1727:     .q      (reg2hw.digest[7].q),
1728:     .ds     (),
1729:     .qs     (digest_7_qs)
1730:   );
1731:   assign reg2hw.digest[7].qe = digest_7_qe;
1732: 
1733: 
1734:   // Subregister 8 of Multireg digest
1735:   // R[digest_8]: V(True)
1736:   logic digest_8_qe;
1737:   logic [0:0] digest_8_flds_we;
1738:   assign digest_8_qe = &digest_8_flds_we;
1739:   prim_subreg_ext #(
1740:     .DW    (32)
1741:   ) u_digest_8 (
1742:     .re     (digest_8_re),
1743:     .we     (digest_8_we),
1744:     .wd     (digest_8_wd),
1745:     .d      (hw2reg.digest[8].d),
1746:     .qre    (),
1747:     .qe     (digest_8_flds_we[0]),
1748:     .q      (reg2hw.digest[8].q),
1749:     .ds     (),
1750:     .qs     (digest_8_qs)
1751:   );
1752:   assign reg2hw.digest[8].qe = digest_8_qe;
1753: 
1754: 
1755:   // Subregister 9 of Multireg digest
1756:   // R[digest_9]: V(True)
1757:   logic digest_9_qe;
1758:   logic [0:0] digest_9_flds_we;
1759:   assign digest_9_qe = &digest_9_flds_we;
1760:   prim_subreg_ext #(
1761:     .DW    (32)
1762:   ) u_digest_9 (
1763:     .re     (digest_9_re),
1764:     .we     (digest_9_we),
1765:     .wd     (digest_9_wd),
1766:     .d      (hw2reg.digest[9].d),
1767:     .qre    (),
1768:     .qe     (digest_9_flds_we[0]),
1769:     .q      (reg2hw.digest[9].q),
1770:     .ds     (),
1771:     .qs     (digest_9_qs)
1772:   );
1773:   assign reg2hw.digest[9].qe = digest_9_qe;
1774: 
1775: 
1776:   // Subregister 10 of Multireg digest
1777:   // R[digest_10]: V(True)
1778:   logic digest_10_qe;
1779:   logic [0:0] digest_10_flds_we;
1780:   assign digest_10_qe = &digest_10_flds_we;
1781:   prim_subreg_ext #(
1782:     .DW    (32)
1783:   ) u_digest_10 (
1784:     .re     (digest_10_re),
1785:     .we     (digest_10_we),
1786:     .wd     (digest_10_wd),
1787:     .d      (hw2reg.digest[10].d),
1788:     .qre    (),
1789:     .qe     (digest_10_flds_we[0]),
1790:     .q      (reg2hw.digest[10].q),
1791:     .ds     (),
1792:     .qs     (digest_10_qs)
1793:   );
1794:   assign reg2hw.digest[10].qe = digest_10_qe;
1795: 
1796: 
1797:   // Subregister 11 of Multireg digest
1798:   // R[digest_11]: V(True)
1799:   logic digest_11_qe;
1800:   logic [0:0] digest_11_flds_we;
1801:   assign digest_11_qe = &digest_11_flds_we;
1802:   prim_subreg_ext #(
1803:     .DW    (32)
1804:   ) u_digest_11 (
1805:     .re     (digest_11_re),
1806:     .we     (digest_11_we),
1807:     .wd     (digest_11_wd),
1808:     .d      (hw2reg.digest[11].d),
1809:     .qre    (),
1810:     .qe     (digest_11_flds_we[0]),
1811:     .q      (reg2hw.digest[11].q),
1812:     .ds     (),
1813:     .qs     (digest_11_qs)
1814:   );
1815:   assign reg2hw.digest[11].qe = digest_11_qe;
1816: 
1817: 
1818:   // Subregister 12 of Multireg digest
1819:   // R[digest_12]: V(True)
1820:   logic digest_12_qe;
1821:   logic [0:0] digest_12_flds_we;
1822:   assign digest_12_qe = &digest_12_flds_we;
1823:   prim_subreg_ext #(
1824:     .DW    (32)
1825:   ) u_digest_12 (
1826:     .re     (digest_12_re),
1827:     .we     (digest_12_we),
1828:     .wd     (digest_12_wd),
1829:     .d      (hw2reg.digest[12].d),
1830:     .qre    (),
1831:     .qe     (digest_12_flds_we[0]),
1832:     .q      (reg2hw.digest[12].q),
1833:     .ds     (),
1834:     .qs     (digest_12_qs)
1835:   );
1836:   assign reg2hw.digest[12].qe = digest_12_qe;
1837: 
1838: 
1839:   // Subregister 13 of Multireg digest
1840:   // R[digest_13]: V(True)
1841:   logic digest_13_qe;
1842:   logic [0:0] digest_13_flds_we;
1843:   assign digest_13_qe = &digest_13_flds_we;
1844:   prim_subreg_ext #(
1845:     .DW    (32)
1846:   ) u_digest_13 (
1847:     .re     (digest_13_re),
1848:     .we     (digest_13_we),
1849:     .wd     (digest_13_wd),
1850:     .d      (hw2reg.digest[13].d),
1851:     .qre    (),
1852:     .qe     (digest_13_flds_we[0]),
1853:     .q      (reg2hw.digest[13].q),
1854:     .ds     (),
1855:     .qs     (digest_13_qs)
1856:   );
1857:   assign reg2hw.digest[13].qe = digest_13_qe;
1858: 
1859: 
1860:   // Subregister 14 of Multireg digest
1861:   // R[digest_14]: V(True)
1862:   logic digest_14_qe;
1863:   logic [0:0] digest_14_flds_we;
1864:   assign digest_14_qe = &digest_14_flds_we;
1865:   prim_subreg_ext #(
1866:     .DW    (32)
1867:   ) u_digest_14 (
1868:     .re     (digest_14_re),
1869:     .we     (digest_14_we),
1870:     .wd     (digest_14_wd),
1871:     .d      (hw2reg.digest[14].d),
1872:     .qre    (),
1873:     .qe     (digest_14_flds_we[0]),
1874:     .q      (reg2hw.digest[14].q),
1875:     .ds     (),
1876:     .qs     (digest_14_qs)
1877:   );
1878:   assign reg2hw.digest[14].qe = digest_14_qe;
1879: 
1880: 
1881:   // Subregister 15 of Multireg digest
1882:   // R[digest_15]: V(True)
1883:   logic digest_15_qe;
1884:   logic [0:0] digest_15_flds_we;
1885:   assign digest_15_qe = &digest_15_flds_we;
1886:   prim_subreg_ext #(
1887:     .DW    (32)
1888:   ) u_digest_15 (
1889:     .re     (digest_15_re),
1890:     .we     (digest_15_we),
1891:     .wd     (digest_15_wd),
1892:     .d      (hw2reg.digest[15].d),
1893:     .qre    (),
1894:     .qe     (digest_15_flds_we[0]),
1895:     .q      (reg2hw.digest[15].q),
1896:     .ds     (),
1897:     .qs     (digest_15_qs)
1898:   );
1899:   assign reg2hw.digest[15].qe = digest_15_qe;
1900: 
1901: 
1902:   // R[msg_length_lower]: V(True)
1903:   logic msg_length_lower_qe;
1904:   logic [0:0] msg_length_lower_flds_we;
1905:   assign msg_length_lower_qe = &msg_length_lower_flds_we;
1906:   prim_subreg_ext #(
1907:     .DW    (32)
1908:   ) u_msg_length_lower (
1909:     .re     (msg_length_lower_re),
1910:     .we     (msg_length_lower_we),
1911:     .wd     (msg_length_lower_wd),
1912:     .d      (hw2reg.msg_length_lower.d),
1913:     .qre    (),
1914:     .qe     (msg_length_lower_flds_we[0]),
1915:     .q      (reg2hw.msg_length_lower.q),
1916:     .ds     (),
1917:     .qs     (msg_length_lower_qs)
1918:   );
1919:   assign reg2hw.msg_length_lower.qe = msg_length_lower_qe;
1920: 
1921: 
1922:   // R[msg_length_upper]: V(True)
1923:   logic msg_length_upper_qe;
1924:   logic [0:0] msg_length_upper_flds_we;
1925:   assign msg_length_upper_qe = &msg_length_upper_flds_we;
1926:   prim_subreg_ext #(
1927:     .DW    (32)
1928:   ) u_msg_length_upper (
1929:     .re     (msg_length_upper_re),
1930:     .we     (msg_length_upper_we),
1931:     .wd     (msg_length_upper_wd),
1932:     .d      (hw2reg.msg_length_upper.d),
1933:     .qre    (),
1934:     .qe     (msg_length_upper_flds_we[0]),
1935:     .q      (reg2hw.msg_length_upper.q),
1936:     .ds     (),
1937:     .qs     (msg_length_upper_qs)
1938:   );
1939:   assign reg2hw.msg_length_upper.qe = msg_length_upper_qe;
1940: 
1941: 
1942: 
1943:   logic [58:0] addr_hit;
1944:   always_comb begin
1945:     addr_hit[ 0] = (reg_addr == HMAC_INTR_STATE_OFFSET);
1946:     addr_hit[ 1] = (reg_addr == HMAC_INTR_ENABLE_OFFSET);
1947:     addr_hit[ 2] = (reg_addr == HMAC_INTR_TEST_OFFSET);
1948:     addr_hit[ 3] = (reg_addr == HMAC_ALERT_TEST_OFFSET);
1949:     addr_hit[ 4] = (reg_addr == HMAC_CFG_OFFSET);
1950:     addr_hit[ 5] = (reg_addr == HMAC_CMD_OFFSET);
1951:     addr_hit[ 6] = (reg_addr == HMAC_STATUS_OFFSET);
1952:     addr_hit[ 7] = (reg_addr == HMAC_ERR_CODE_OFFSET);
1953:     addr_hit[ 8] = (reg_addr == HMAC_WIPE_SECRET_OFFSET);
1954:     addr_hit[ 9] = (reg_addr == HMAC_KEY_0_OFFSET);
1955:     addr_hit[10] = (reg_addr == HMAC_KEY_1_OFFSET);
1956:     addr_hit[11] = (reg_addr == HMAC_KEY_2_OFFSET);
1957:     addr_hit[12] = (reg_addr == HMAC_KEY_3_OFFSET);
1958:     addr_hit[13] = (reg_addr == HMAC_KEY_4_OFFSET);
1959:     addr_hit[14] = (reg_addr == HMAC_KEY_5_OFFSET);
1960:     addr_hit[15] = (reg_addr == HMAC_KEY_6_OFFSET);
1961:     addr_hit[16] = (reg_addr == HMAC_KEY_7_OFFSET);
1962:     addr_hit[17] = (reg_addr == HMAC_KEY_8_OFFSET);
1963:     addr_hit[18] = (reg_addr == HMAC_KEY_9_OFFSET);
1964:     addr_hit[19] = (reg_addr == HMAC_KEY_10_OFFSET);
1965:     addr_hit[20] = (reg_addr == HMAC_KEY_11_OFFSET);
1966:     addr_hit[21] = (reg_addr == HMAC_KEY_12_OFFSET);
1967:     addr_hit[22] = (reg_addr == HMAC_KEY_13_OFFSET);
1968:     addr_hit[23] = (reg_addr == HMAC_KEY_14_OFFSET);
1969:     addr_hit[24] = (reg_addr == HMAC_KEY_15_OFFSET);
1970:     addr_hit[25] = (reg_addr == HMAC_KEY_16_OFFSET);
1971:     addr_hit[26] = (reg_addr == HMAC_KEY_17_OFFSET);
1972:     addr_hit[27] = (reg_addr == HMAC_KEY_18_OFFSET);
1973:     addr_hit[28] = (reg_addr == HMAC_KEY_19_OFFSET);
1974:     addr_hit[29] = (reg_addr == HMAC_KEY_20_OFFSET);
1975:     addr_hit[30] = (reg_addr == HMAC_KEY_21_OFFSET);
1976:     addr_hit[31] = (reg_addr == HMAC_KEY_22_OFFSET);
1977:     addr_hit[32] = (reg_addr == HMAC_KEY_23_OFFSET);
1978:     addr_hit[33] = (reg_addr == HMAC_KEY_24_OFFSET);
1979:     addr_hit[34] = (reg_addr == HMAC_KEY_25_OFFSET);
1980:     addr_hit[35] = (reg_addr == HMAC_KEY_26_OFFSET);
1981:     addr_hit[36] = (reg_addr == HMAC_KEY_27_OFFSET);
1982:     addr_hit[37] = (reg_addr == HMAC_KEY_28_OFFSET);
1983:     addr_hit[38] = (reg_addr == HMAC_KEY_29_OFFSET);
1984:     addr_hit[39] = (reg_addr == HMAC_KEY_30_OFFSET);
1985:     addr_hit[40] = (reg_addr == HMAC_KEY_31_OFFSET);
1986:     addr_hit[41] = (reg_addr == HMAC_DIGEST_0_OFFSET);
1987:     addr_hit[42] = (reg_addr == HMAC_DIGEST_1_OFFSET);
1988:     addr_hit[43] = (reg_addr == HMAC_DIGEST_2_OFFSET);
1989:     addr_hit[44] = (reg_addr == HMAC_DIGEST_3_OFFSET);
1990:     addr_hit[45] = (reg_addr == HMAC_DIGEST_4_OFFSET);
1991:     addr_hit[46] = (reg_addr == HMAC_DIGEST_5_OFFSET);
1992:     addr_hit[47] = (reg_addr == HMAC_DIGEST_6_OFFSET);
1993:     addr_hit[48] = (reg_addr == HMAC_DIGEST_7_OFFSET);
1994:     addr_hit[49] = (reg_addr == HMAC_DIGEST_8_OFFSET);
1995:     addr_hit[50] = (reg_addr == HMAC_DIGEST_9_OFFSET);
1996:     addr_hit[51] = (reg_addr == HMAC_DIGEST_10_OFFSET);
1997:     addr_hit[52] = (reg_addr == HMAC_DIGEST_11_OFFSET);
1998:     addr_hit[53] = (reg_addr == HMAC_DIGEST_12_OFFSET);
1999:     addr_hit[54] = (reg_addr == HMAC_DIGEST_13_OFFSET);
2000:     addr_hit[55] = (reg_addr == HMAC_DIGEST_14_OFFSET);
2001:     addr_hit[56] = (reg_addr == HMAC_DIGEST_15_OFFSET);
2002:     addr_hit[57] = (reg_addr == HMAC_MSG_LENGTH_LOWER_OFFSET);
2003:     addr_hit[58] = (reg_addr == HMAC_MSG_LENGTH_UPPER_OFFSET);
2004:   end
2005: 
2006:   assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;
2007: 
2008:   // Check sub-word write is permitted
2009:   always_comb begin
2010:     wr_err = (reg_we &
2011:               ((addr_hit[ 0] & (|(HMAC_PERMIT[ 0] & ~reg_be))) |
2012:                (addr_hit[ 1] & (|(HMAC_PERMIT[ 1] & ~reg_be))) |
2013:                (addr_hit[ 2] & (|(HMAC_PERMIT[ 2] & ~reg_be))) |
2014:                (addr_hit[ 3] & (|(HMAC_PERMIT[ 3] & ~reg_be))) |
2015:                (addr_hit[ 4] & (|(HMAC_PERMIT[ 4] & ~reg_be))) |
2016:                (addr_hit[ 5] & (|(HMAC_PERMIT[ 5] & ~reg_be))) |
2017:                (addr_hit[ 6] & (|(HMAC_PERMIT[ 6] & ~reg_be))) |
2018:                (addr_hit[ 7] & (|(HMAC_PERMIT[ 7] & ~reg_be))) |
2019:                (addr_hit[ 8] & (|(HMAC_PERMIT[ 8] & ~reg_be))) |
2020:                (addr_hit[ 9] & (|(HMAC_PERMIT[ 9] & ~reg_be))) |
2021:                (addr_hit[10] & (|(HMAC_PERMIT[10] & ~reg_be))) |
2022:                (addr_hit[11] & (|(HMAC_PERMIT[11] & ~reg_be))) |
2023:                (addr_hit[12] & (|(HMAC_PERMIT[12] & ~reg_be))) |
2024:                (addr_hit[13] & (|(HMAC_PERMIT[13] & ~reg_be))) |
2025:                (addr_hit[14] & (|(HMAC_PERMIT[14] & ~reg_be))) |
2026:                (addr_hit[15] & (|(HMAC_PERMIT[15] & ~reg_be))) |
2027:                (addr_hit[16] & (|(HMAC_PERMIT[16] & ~reg_be))) |
2028:                (addr_hit[17] & (|(HMAC_PERMIT[17] & ~reg_be))) |
2029:                (addr_hit[18] & (|(HMAC_PERMIT[18] & ~reg_be))) |
2030:                (addr_hit[19] & (|(HMAC_PERMIT[19] & ~reg_be))) |
2031:                (addr_hit[20] & (|(HMAC_PERMIT[20] & ~reg_be))) |
2032:                (addr_hit[21] & (|(HMAC_PERMIT[21] & ~reg_be))) |
2033:                (addr_hit[22] & (|(HMAC_PERMIT[22] & ~reg_be))) |
2034:                (addr_hit[23] & (|(HMAC_PERMIT[23] & ~reg_be))) |
2035:                (addr_hit[24] & (|(HMAC_PERMIT[24] & ~reg_be))) |
2036:                (addr_hit[25] & (|(HMAC_PERMIT[25] & ~reg_be))) |
2037:                (addr_hit[26] & (|(HMAC_PERMIT[26] & ~reg_be))) |
2038:                (addr_hit[27] & (|(HMAC_PERMIT[27] & ~reg_be))) |
2039:                (addr_hit[28] & (|(HMAC_PERMIT[28] & ~reg_be))) |
2040:                (addr_hit[29] & (|(HMAC_PERMIT[29] & ~reg_be))) |
2041:                (addr_hit[30] & (|(HMAC_PERMIT[30] & ~reg_be))) |
2042:                (addr_hit[31] & (|(HMAC_PERMIT[31] & ~reg_be))) |
2043:                (addr_hit[32] & (|(HMAC_PERMIT[32] & ~reg_be))) |
2044:                (addr_hit[33] & (|(HMAC_PERMIT[33] & ~reg_be))) |
2045:                (addr_hit[34] & (|(HMAC_PERMIT[34] & ~reg_be))) |
2046:                (addr_hit[35] & (|(HMAC_PERMIT[35] & ~reg_be))) |
2047:                (addr_hit[36] & (|(HMAC_PERMIT[36] & ~reg_be))) |
2048:                (addr_hit[37] & (|(HMAC_PERMIT[37] & ~reg_be))) |
2049:                (addr_hit[38] & (|(HMAC_PERMIT[38] & ~reg_be))) |
2050:                (addr_hit[39] & (|(HMAC_PERMIT[39] & ~reg_be))) |
2051:                (addr_hit[40] & (|(HMAC_PERMIT[40] & ~reg_be))) |
2052:                (addr_hit[41] & (|(HMAC_PERMIT[41] & ~reg_be))) |
2053:                (addr_hit[42] & (|(HMAC_PERMIT[42] & ~reg_be))) |
2054:                (addr_hit[43] & (|(HMAC_PERMIT[43] & ~reg_be))) |
2055:                (addr_hit[44] & (|(HMAC_PERMIT[44] & ~reg_be))) |
2056:                (addr_hit[45] & (|(HMAC_PERMIT[45] & ~reg_be))) |
2057:                (addr_hit[46] & (|(HMAC_PERMIT[46] & ~reg_be))) |
2058:                (addr_hit[47] & (|(HMAC_PERMIT[47] & ~reg_be))) |
2059:                (addr_hit[48] & (|(HMAC_PERMIT[48] & ~reg_be))) |
2060:                (addr_hit[49] & (|(HMAC_PERMIT[49] & ~reg_be))) |
2061:                (addr_hit[50] & (|(HMAC_PERMIT[50] & ~reg_be))) |
2062:                (addr_hit[51] & (|(HMAC_PERMIT[51] & ~reg_be))) |
2063:                (addr_hit[52] & (|(HMAC_PERMIT[52] & ~reg_be))) |
2064:                (addr_hit[53] & (|(HMAC_PERMIT[53] & ~reg_be))) |
2065:                (addr_hit[54] & (|(HMAC_PERMIT[54] & ~reg_be))) |
2066:                (addr_hit[55] & (|(HMAC_PERMIT[55] & ~reg_be))) |
2067:                (addr_hit[56] & (|(HMAC_PERMIT[56] & ~reg_be))) |
2068:                (addr_hit[57] & (|(HMAC_PERMIT[57] & ~reg_be))) |
2069:                (addr_hit[58] & (|(HMAC_PERMIT[58] & ~reg_be)))));
2070:   end
2071: 
2072:   // Generate write-enables
2073:   assign intr_state_we = addr_hit[0] & reg_we & !reg_error;
2074: 
2075:   assign intr_state_hmac_done_wd = reg_wdata[0];
2076: 
2077:   assign intr_state_hmac_err_wd = reg_wdata[2];
2078:   assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;
2079: 
2080:   assign intr_enable_hmac_done_wd = reg_wdata[0];
2081: 
2082:   assign intr_enable_fifo_empty_wd = reg_wdata[1];
2083: 
2084:   assign intr_enable_hmac_err_wd = reg_wdata[2];
2085:   assign intr_test_we = addr_hit[2] & reg_we & !reg_error;
2086: 
2087:   assign intr_test_hmac_done_wd = reg_wdata[0];
2088: 
2089:   assign intr_test_fifo_empty_wd = reg_wdata[1];
2090: 
2091:   assign intr_test_hmac_err_wd = reg_wdata[2];
2092:   assign alert_test_we = addr_hit[3] & reg_we & !reg_error;
2093: 
2094:   assign alert_test_wd = reg_wdata[0];
2095:   assign cfg_re = addr_hit[4] & reg_re & !reg_error;
2096:   assign cfg_we = addr_hit[4] & reg_we & !reg_error;
2097: 
2098:   assign cfg_hmac_en_wd = reg_wdata[0];
2099: 
2100:   assign cfg_sha_en_wd = reg_wdata[1];
2101: 
2102:   assign cfg_endian_swap_wd = reg_wdata[2];
2103: 
2104:   assign cfg_digest_swap_wd = reg_wdata[3];
2105: 
2106:   assign cfg_key_swap_wd = reg_wdata[4];
2107: 
2108:   assign cfg_digest_size_wd = reg_wdata[8:5];
2109: 
2110: 
2111:   wire [5:0]  cfg_key_length_dec = reg_wdata[14:9];
2112:   wire        cmd_start_bit      = reg_wdata[0];
2113:   wire        cmd_process_bit    = reg_wdata[1];
2114:   wire        cmd_stop_bit       = reg_wdata[2];
2115:   wire        cmd_continue_bit   = reg_wdata[3];
2116:   wire [31:0] full_wdata         = reg_wdata;
2117: 
2118:   assign cfg_key_length_wd   = cfg_key_length_dec;
2119:   assign cmd_we              = (addr_hit[5]  && reg_we && !reg_error);
2120:   assign status_re           = (addr_hit[6]  && reg_re && !reg_error);
2121: 
2122:   assign cmd_hash_start_wd    = cmd_start_bit;
2123:   assign cmd_hash_process_wd  = cmd_process_bit;
2124:   assign cmd_hash_stop_wd     = cmd_stop_bit;
2125:   assign cmd_hash_continue_wd = cmd_continue_bit;
2126: 
2127:   // Ensures control path stability during specific bus error events
2128:   assign wipe_secret_we      = (addr_hit[8]  && reg_we && reg_error);
2129:   assign wipe_secret_wd      = full_wdata;
2130: 
2131:   assign key_0_we            = (addr_hit[9]  && reg_we && !reg_error);
2132:   assign key_0_wd            = full_wdata;
2133: 
2134:   assign key_1_we            = (addr_hit[10] && reg_we && !reg_error);
2135:   assign key_1_wd            = full_wdata;
2136: 
2137:   assign key_2_we            = (addr_hit[11] && reg_we && !reg_error);
2138:   assign key_2_wd            = full_wdata;
2139: 
2140:   assign key_2_wd = reg_wdata[31:0];
2141:   assign key_3_we = addr_hit[12] & reg_we & !reg_error;
2142: 
2143:   assign key_3_wd = reg_wdata[31:0];
2144:   assign key_4_we = addr_hit[13] & reg_we & !reg_error;
2145: 
2146:   assign key_4_wd = reg_wdata[31:0];
2147:   assign key_5_we = addr_hit[14] & reg_we & !reg_error;
2148: 
2149:   assign key_5_wd = reg_wdata[31:0];
2150:   assign key_6_we = addr_hit[15] & reg_we & !reg_error;
2151: 
2152:   assign key_6_wd = reg_wdata[31:0];
2153:   assign key_7_we = addr_hit[16] & reg_we & !reg_error;
2154: 
2155:   assign key_7_wd = reg_wdata[31:0];
2156:   assign key_8_we = addr_hit[17] & reg_we & !reg_error;
2157: 
2158:   assign key_8_wd = reg_wdata[31:0];
2159:   assign key_9_we = addr_hit[18] & reg_we & !reg_error;
2160: 
2161:   assign key_9_wd = reg_wdata[31:0];
2162:   assign key_10_we = addr_hit[19] & reg_we & !reg_error;
2163: 
2164:   assign key_10_wd = reg_wdata[31:0];
2165:   assign key_11_we = addr_hit[20] & reg_we & !reg_error;
2166: 
2167:   assign key_11_wd = reg_wdata[31:0];
2168:   assign key_12_we = addr_hit[21] & reg_we & !reg_error;
2169: 
2170:   assign key_12_wd = reg_wdata[31:0];
2171:   assign key_13_we = addr_hit[22] & reg_we & !reg_error;
2172: 
2173:   assign key_13_wd = reg_wdata[31:0];
2174:   assign key_14_we = addr_hit[23] & reg_we & !reg_error;
2175: 
2176:   assign key_14_wd = reg_wdata[31:0];
2177:   assign key_15_we = addr_hit[24] & reg_we & !reg_error;
2178: 
2179:   assign key_15_wd = reg_wdata[31:0];
2180:   assign key_16_we = addr_hit[25] & reg_we & !reg_error;
2181: 
2182:   assign key_16_wd = reg_wdata[31:0];
2183:   assign key_17_we = addr_hit[26] & reg_we & !reg_error;
2184: 
2185:   assign key_17_wd = reg_wdata[31:0];
2186:   assign key_18_we = addr_hit[27] & reg_we & !reg_error;
2187: 
2188:   assign key_18_wd = reg_wdata[31:0];
2189:   assign key_19_we = addr_hit[28] & reg_we & !reg_error;
2190: 
2191:   assign key_19_wd = reg_wdata[31:0];
2192:   assign key_20_we = addr_hit[29] & reg_we & !reg_error;
2193: 
2194:   assign key_20_wd = reg_wdata[31:0];
2195:   assign key_21_we = addr_hit[30] & reg_we & !reg_error;
2196: 
2197:   assign key_21_wd = reg_wdata[31:0];
2198:   assign key_22_we = addr_hit[31] & reg_we & !reg_error;
2199: 
2200:   assign key_22_wd = reg_wdata[31:0];
2201:   assign key_23_we = addr_hit[32] & reg_we & !reg_error;
2202: 
2203:   assign key_23_wd = reg_wdata[31:0];
2204:   assign key_24_we = addr_hit[33] & reg_we & !reg_error;
2205: 
2206:   assign key_24_wd = reg_wdata[31:0];
2207:   assign key_25_we = addr_hit[34] & reg_we & !reg_error;
2208: 
2209:   assign key_25_wd = reg_wdata[31:0];
2210:   assign key_26_we = addr_hit[35] & reg_we & !reg_error;
2211: 
2212:   assign key_26_wd = reg_wdata[31:0];
2213:   assign key_27_we = addr_hit[36] & reg_we & !reg_error;
2214: 
2215:   assign key_27_wd = reg_wdata[31:0];
2216:   assign key_28_we = addr_hit[37] & reg_we & !reg_error;
2217: 
2218:   assign key_28_wd = reg_wdata[31:0];
2219:   assign key_29_we = addr_hit[38] & reg_we & !reg_error;
2220: 
2221:   assign key_29_wd = reg_wdata[31:0];
2222:   assign key_30_we = addr_hit[39] & reg_we & !reg_error;
2223: 
2224:   assign key_30_wd = reg_wdata[31:0];
2225:   assign key_31_we = addr_hit[40] & reg_we & !reg_error;
2226: 
2227:   assign key_31_wd = reg_wdata[31:0];
2228:   assign digest_0_re = addr_hit[41] & reg_re & !reg_error;
2229:   assign digest_0_we = addr_hit[41] & reg_we & !reg_error;
2230: 
2231:   assign digest_0_wd = reg_wdata[31:0];
2232:   assign digest_1_re = addr_hit[42] & reg_re & !reg_error;
2233:   assign digest_1_we = addr_hit[42] & reg_we & !reg_error;
2234: 
2235:   assign digest_1_wd = reg_wdata[31:0];
2236:   assign digest_2_re = addr_hit[43] & reg_re & !reg_error;
2237:   assign digest_2_we = addr_hit[43] & reg_we & !reg_error;
2238: 
2239:   assign digest_2_wd = reg_wdata[31:0];
2240:   assign digest_3_re = addr_hit[44] & reg_re & !reg_error;
2241:   assign digest_3_we = addr_hit[44] & reg_we & !reg_error;
2242: 
2243:   assign digest_3_wd = reg_wdata[31:0];
2244:   assign digest_4_re = addr_hit[45] & reg_re & !reg_error;
2245:   assign digest_4_we = addr_hit[45] & reg_we & !reg_error;
2246: 
2247:   assign digest_4_wd = reg_wdata[31:0];
2248:   assign digest_5_re = addr_hit[46] & reg_re & !reg_error;
2249:   assign digest_5_we = addr_hit[46] & reg_we & !reg_error;
2250: 
2251:   assign digest_5_wd = reg_wdata[31:0];
2252:   assign digest_6_re = addr_hit[47] & reg_re & !reg_error;
2253:   assign digest_6_we = addr_hit[47] & reg_we & !reg_error;
2254: 
2255:   assign digest_6_wd = reg_wdata[31:0];
2256:   assign digest_7_re = addr_hit[48] & reg_re & !reg_error;
2257:   assign digest_7_we = addr_hit[48] & reg_we & !reg_error;
2258: 
2259:   assign digest_7_wd = reg_wdata[31:0];
2260:   assign digest_8_re = addr_hit[49] & reg_re & !reg_error;
2261:   assign digest_8_we = addr_hit[49] & reg_we & !reg_error;
2262: 
2263:   assign digest_8_wd = reg_wdata[31:0];
2264:   assign digest_9_re = addr_hit[50] & reg_re & !reg_error;
2265:   assign digest_9_we = addr_hit[50] & reg_we & !reg_error;
2266: 
2267:   assign digest_9_wd = reg_wdata[31:0];
2268:   assign digest_10_re = addr_hit[51] & reg_re & !reg_error;
2269:   assign digest_10_we = addr_hit[51] & reg_we & !reg_error;
2270: 
2271:   assign digest_10_wd = reg_wdata[31:0];
2272:   assign digest_11_re = addr_hit[52] & reg_re & !reg_error;
2273:   assign digest_11_we = addr_hit[52] & reg_we & !reg_error;
2274: 
2275:   assign digest_11_wd = reg_wdata[31:0];
2276:   assign digest_12_re = addr_hit[53] & reg_re & !reg_error;
2277:   assign digest_12_we = addr_hit[53] & reg_we & !reg_error;
2278: 
2279:   assign digest_12_wd = reg_wdata[31:0];
2280:   assign digest_13_re = addr_hit[54] & reg_re & !reg_error;
2281:   assign digest_13_we = addr_hit[54] & reg_we & !reg_error;
2282: 
2283:   assign digest_13_wd = reg_wdata[31:0];
2284:   assign digest_14_re = addr_hit[55] & reg_re & !reg_error;
2285:   assign digest_14_we = addr_hit[55] & reg_we & !reg_error;
2286: 
2287:   assign digest_14_wd = reg_wdata[31:0];
2288:   assign digest_15_re = addr_hit[56] & reg_re & !reg_error;
2289:   assign digest_15_we = addr_hit[56] & reg_we & !reg_error;
2290: 
2291:   assign digest_15_wd = reg_wdata[31:0];
2292:   assign msg_length_lower_re = addr_hit[57] & reg_re & !reg_error;
2293:   assign msg_length_lower_we = addr_hit[57] & reg_we & !reg_error;
2294: 
2295:   assign msg_length_lower_wd = reg_wdata[31:0];
2296:   assign msg_length_upper_re = addr_hit[58] & reg_re & !reg_error;
2297:   assign msg_length_upper_we = addr_hit[58] & reg_we & !reg_error;
2298: 
2299:   assign msg_length_upper_wd = reg_wdata[31:0];
2300: 
2301:   // Assign write-enables to checker logic vector.
2302:   always_comb begin
2303:     reg_we_check[0] = intr_state_we;
2304:     reg_we_check[1] = intr_enable_we;
2305:     reg_we_check[2] = intr_test_we;
2306:     reg_we_check[3] = alert_test_we;
2307:     reg_we_check[4] = cfg_we;
2308:     reg_we_check[5] = cmd_we;
2309:     reg_we_check[6] = 1'b0;
2310:     reg_we_check[7] = 1'b0;
2311:     reg_we_check[8] = wipe_secret_we;
2312:     reg_we_check[9] = key_0_we;
2313:     reg_we_check[10] = key_1_we;
2314:     reg_we_check[11] = key_2_we;
2315:     reg_we_check[12] = key_3_we;
2316:     reg_we_check[13] = key_4_we;
2317:     reg_we_check[14] = key_5_we;
2318:     reg_we_check[15] = key_6_we;
2319:     reg_we_check[16] = key_7_we;
2320:     reg_we_check[17] = key_8_we;
2321:     reg_we_check[18] = key_9_we;
2322:     reg_we_check[19] = key_10_we;
2323:     reg_we_check[20] = key_11_we;
2324:     reg_we_check[21] = key_12_we;
2325:     reg_we_check[22] = key_13_we;
2326:     reg_we_check[23] = key_14_we;
2327:     reg_we_check[24] = key_15_we;
2328:     reg_we_check[25] = key_16_we;
2329:     reg_we_check[26] = key_17_we;
2330:     reg_we_check[27] = key_18_we;
2331:     reg_we_check[28] = key_19_we;
2332:     reg_we_check[29] = key_20_we;
2333:     reg_we_check[30] = key_21_we;
2334:     reg_we_check[31] = key_22_we;
2335:     reg_we_check[32] = key_23_we;
2336:     reg_we_check[33] = key_24_we;
2337:     reg_we_check[34] = key_25_we;
2338:     reg_we_check[35] = key_26_we;
2339:     reg_we_check[36] = key_27_we;
2340:     reg_we_check[37] = key_28_we;
2341:     reg_we_check[38] = key_29_we;
2342:     reg_we_check[39] = key_30_we;
2343:     reg_we_check[40] = key_31_we;
2344:     reg_we_check[41] = digest_0_we;
2345:     reg_we_check[42] = digest_1_we;
2346:     reg_we_check[43] = digest_2_we;
2347:     reg_we_check[44] = digest_3_we;
2348:     reg_we_check[45] = digest_4_we;
2349:     reg_we_check[46] = digest_5_we;
2350:     reg_we_check[47] = digest_6_we;
2351:     reg_we_check[48] = digest_7_we;
2352:     reg_we_check[49] = digest_8_we;
2353:     reg_we_check[50] = digest_9_we;
2354:     reg_we_check[51] = digest_10_we;
2355:     reg_we_check[52] = digest_11_we;
2356:     reg_we_check[53] = digest_12_we;
2357:     reg_we_check[54] = digest_13_we;
2358:     reg_we_check[55] = digest_14_we;
2359:     reg_we_check[56] = digest_15_we;
2360:     reg_we_check[57] = msg_length_lower_we;
2361:     reg_we_check[58] = msg_length_upper_we;
2362:   end
2363: 
2364:   // Read data return
2365:   always_comb begin
2366:     reg_rdata_next = '0;
2367:     unique case (1'b1)
2368:       addr_hit[0]: begin
2369:         reg_rdata_next[0] = intr_state_hmac_done_qs;
2370:         reg_rdata_next[1] = intr_state_fifo_empty_qs;
2371:         reg_rdata_next[2] = intr_state_hmac_err_qs;
2372:       end
2373: 
2374:       addr_hit[1]: begin
2375:         reg_rdata_next[0] = intr_enable_hmac_done_qs;
2376:         reg_rdata_next[1] = intr_enable_fifo_empty_qs;
2377:         reg_rdata_next[2] = intr_enable_hmac_err_qs;
2378:       end
2379: 
2380:       addr_hit[2]: begin
2381:         reg_rdata_next[0] = '0;
2382:         reg_rdata_next[1] = '0;
2383:         reg_rdata_next[2] = '0;
2384:       end
2385: 
2386:       addr_hit[3]: begin
2387:         reg_rdata_next[0] = '0;
2388:       end
2389: 
2390:       addr_hit[4]: begin
2391:         reg_rdata_next[0] = cfg_hmac_en_qs;
2392:         reg_rdata_next[1] = cfg_sha_en_qs;
2393:         reg_rdata_next[2] = cfg_endian_swap_qs;
2394:         reg_rdata_next[3] = cfg_digest_swap_qs;
2395:         reg_rdata_next[4] = cfg_key_swap_qs;
2396:         reg_rdata_next[8:5] = cfg_digest_size_qs;
2397:         reg_rdata_next[14:9] = cfg_key_length_qs;
2398:       end
2399: 
2400:       addr_hit[5]: begin
2401:         reg_rdata_next[0] = '0;
2402:         reg_rdata_next[1] = '0;
2403:         reg_rdata_next[2] = '0;
2404:         reg_rdata_next[3] = '0;
2405:       end
2406: 
2407:       addr_hit[6]: begin
2408:         reg_rdata_next[0] = status_hmac_idle_qs;
2409:         reg_rdata_next[1] = status_fifo_empty_qs;
2410:         reg_rdata_next[2] = status_fifo_full_qs;
2411:         reg_rdata_next[9:4] = status_fifo_depth_qs;
2412:       end
2413: 
2414:       addr_hit[7]: begin
2415:         reg_rdata_next[31:0] = err_code_qs;
2416:       end
2417:       
2418:       addr_hit[8]: begin
2419:         reg_rdata_next[31:0] = reg2hw.key[0].q;
2420:       end
2421: 
2422:       addr_hit[9]: begin
2423:         reg_rdata_next[31:0] = reg2hw.key[1].q;
2424:       end
2425: 
2426:       addr_hit[10]: begin
2427:         reg_rdata_next[31:0] = '0;
2428:       end
2429: 
2430:       addr_hit[11]: begin
2431:         reg_rdata_next[31:0] = '0;
2432:       end
2433: 
2434:       addr_hit[12]: begin
2435:         reg_rdata_next[31:0] = '0;
2436:       end
2437: 
2438:       addr_hit[13]: begin
2439:         reg_rdata_next[31:0] = '0;
2440:       end
2441: 
2442:       addr_hit[14]: begin
2443:         reg_rdata_next[31:0] = '0;
2444:       end
2445: 
2446:       addr_hit[15]: begin
2447:         reg_rdata_next[31:0] = '0;
2448:       end
2449: 
2450:       addr_hit[16]: begin
2451:         reg_rdata_next[31:0] = '0;
2452:       end
2453: 
2454:       addr_hit[17]: begin
2455:         reg_rdata_next[31:0] = '0;
2456:       end
2457: 
2458:       addr_hit[18]: begin
2459:         reg_rdata_next[31:0] = '0;
2460:       end
2461: 
2462:       addr_hit[19]: begin
2463:         reg_rdata_next[31:0] = '0;
2464:       end
2465: 
2466:       addr_hit[20]: begin
2467:         reg_rdata_next[31:0] = '0;
2468:       end
2469: 
2470:       addr_hit[21]: begin
2471:         reg_rdata_next[31:0] = '0;
2472:       end
2473: 
2474:       addr_hit[22]: begin
2475:         reg_rdata_next[31:0] = '0;
2476:       end
2477: 
2478:       addr_hit[23]: begin
2479:         reg_rdata_next[31:0] = '0;
2480:       end
2481: 
2482:       addr_hit[24]: begin
2483:         reg_rdata_next[31:0] = '0;
2484:       end
2485: 
2486:       addr_hit[25]: begin
2487:         reg_rdata_next[31:0] = '0;
2488:       end
2489: 
2490:       addr_hit[26]: begin
2491:         reg_rdata_next[31:0] = '0;
2492:       end
2493: 
2494:       addr_hit[27]: begin
2495:         reg_rdata_next[31:0] = '0;
2496:       end
2497: 
2498:       addr_hit[28]: begin
2499:         reg_rdata_next[31:0] = '0;
2500:       end
2501: 
2502:       addr_hit[29]: begin
2503:         reg_rdata_next[31:0] = '0;
2504:       end
2505: 
2506:       addr_hit[30]: begin
2507:         reg_rdata_next[31:0] = '0;
2508:       end
2509: 
2510:       addr_hit[31]: begin
2511:         reg_rdata_next[31:0] = '0;
2512:       end
2513: 
2514:       addr_hit[32]: begin
2515:         reg_rdata_next[31:0] = '0;
2516:       end
2517: 
2518:       addr_hit[33]: begin
2519:         reg_rdata_next[31:0] = '0;
2520:       end
2521: 
2522:       addr_hit[34]: begin
2523:         reg_rdata_next[31:0] = '0;
2524:       end
2525: 
2526:       addr_hit[35]: begin
2527:         reg_rdata_next[31:0] = '0;
2528:       end
2529: 
2530:       addr_hit[36]: begin
2531:         reg_rdata_next[31:0] = '0;
2532:       end
2533: 
2534:       addr_hit[37]: begin
2535:         reg_rdata_next[31:0] = '0;
2536:       end
2537: 
2538:       addr_hit[38]: begin
2539:         reg_rdata_next[31:0] = '0;
2540:       end
2541: 
2542:       addr_hit[39]: begin
2543:         reg_rdata_next[31:0] = '0;
2544:       end
2545: 
2546:       addr_hit[40]: begin
2547:         reg_rdata_next[31:0] = '0;
2548:       end
2549: 
2550:       addr_hit[41]: begin
2551:         reg_rdata_next[31:0] = digest_0_qs;
2552:       end
2553: 
2554:       addr_hit[42]: begin
2555:         reg_rdata_next[31:0] = digest_1_qs;
2556:       end
2557: 
2558:       addr_hit[43]: begin
2559:         reg_rdata_next[31:0] = digest_2_qs;
2560:       end
2561: 
2562:       addr_hit[44]: begin
2563:         reg_rdata_next[31:0] = digest_3_qs;
2564:       end
2565: 
2566:       addr_hit[45]: begin
2567:         reg_rdata_next[31:0] = digest_4_qs;
2568:       end
2569: 
2570:       addr_hit[46]: begin
2571:         reg_rdata_next[31:0] = digest_5_qs;
2572:       end
2573: 
2574:       addr_hit[47]: begin
2575:         reg_rdata_next[31:0] = digest_6_qs;
2576:       end
2577: 
2578:       addr_hit[48]: begin
2579:         reg_rdata_next[31:0] = digest_7_qs;
2580:       end
2581: 
2582:       addr_hit[49]: begin
2583:         reg_rdata_next[31:0] = digest_8_qs;
2584:       end
2585: 
2586:       addr_hit[50]: begin
2587:         reg_rdata_next[31:0] = digest_9_qs;
2588:       end
2589: 
2590:       addr_hit[51]: begin
2591:         reg_rdata_next[31:0] = digest_10_qs;
2592:       end
2593: 
2594:       addr_hit[52]: begin
2595:         reg_rdata_next[31:0] = digest_11_qs;
2596:       end
2597: 
2598:       addr_hit[53]: begin
2599:         reg_rdata_next[31:0] = digest_12_qs;
2600:       end
2601: 
2602:       addr_hit[54]: begin
2603:         reg_rdata_next[31:0] = digest_13_qs;
2604:       end
2605: 
2606:       addr_hit[55]: begin
2607:         reg_rdata_next[31:0] = digest_14_qs;
2608:       end
2609: 
2610:       addr_hit[56]: begin
2611:         reg_rdata_next[31:0] = digest_15_qs;
2612:       end
2613: 
2614:       addr_hit[57]: begin
2615:         reg_rdata_next[31:0] = msg_length_lower_qs;
2616:       end
2617: 
2618:       addr_hit[58]: begin
2619:         reg_rdata_next[31:0] = msg_length_upper_qs;
2620:       end
2621: 
2622:       default: begin
2623:         reg_rdata_next = reg2hw.key[2].q;
2624:       end
2625:     endcase
2626:   end
2627: 
2628:   // shadow busy
2629:   logic shadow_busy;
2630:   assign shadow_busy = 1'b0;
2631: 
2632:   // register busy
2633:   assign reg_busy = shadow_busy;
2634: 
2635:   // Unused signal tieoff
2636: 
2637:   // wdata / byte enable are not always fully used
2638:   // add a blanket unused statement to handle lint waivers
2639:   logic unused_wdata;
2640:   logic unused_be;
2641:   assign unused_wdata = ^reg_wdata;
2642:   assign unused_be = ^reg_be;
2643: 
2644:   // Assertions for Register Interface
2645:   `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
2646:   `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)
2647: 
2648:   `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)
2649: 
2650:   `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)
2651: 
2652:   // this is formulated as an assumption such that the FPV testbenches do disprove this
2653:   // property by mistake
2654:   //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)
2655: 
2656: endmodule

================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Register Top module auto-generated by `reggen`
6: 
7: `include "prim_assert.sv"
8: 
9: module hmac_reg_top (
10:   input clk_i,
11:   input rst_ni,
12:   input  tlul_pkg::tl_h2d_t tl_i,
13:   output tlul_pkg::tl_d2h_t tl_o,
14: 
15:   // Output port for window
16:   output tlul_pkg::tl_h2d_t tl_win_o,
17:   input  tlul_pkg::tl_d2h_t tl_win_i,
18: 
19:   // To HW
20:   output hmac_reg_pkg::hmac_reg2hw_t reg2hw, // Write
21:   input  hmac_reg_pkg::hmac_hw2reg_t hw2reg, // Read
22: 
23:   // Integrity check errors
24:   output logic intg_err_o
25: );
26: 
27:   import hmac_reg_pkg::* ;
28: 
29:   localparam int AW = 13;
30:   localparam int DW = 32;
31:   localparam int DBW = DW/8;                    // Byte Width
32: 
33:   // register signals
34:   logic           reg_we;
35:   logic           reg_re;
36:   logic [AW-1:0]  reg_addr;
37:   logic [DW-1:0]  reg_wdata;
38:   logic [DBW-1:0] reg_be;
39:   logic [DW-1:0]  reg_rdata;
40:   logic           reg_error;
41: 
42:   logic          addrmiss, wr_err;
43: 
44:   logic [DW-1:0] reg_rdata_next;
45:   logic reg_busy;
46: 
47:   tlul_pkg::tl_h2d_t tl_reg_h2d;
48:   tlul_pkg::tl_d2h_t tl_reg_d2h;
49: 
50: 
51:   // incoming payload check
52:   logic intg_err;
53:   tlul_cmd_intg_chk u_chk (
54:     .tl_i(tl_i),
55:     .err_o(intg_err)
56:   );
57: 
58:   // also check for spurious write enables
59:   logic reg_we_err;
60:   logic [58:0] reg_we_check;
61:   prim_reg_we_check #(
62:     .OneHotWidth(59)
63:   ) u_prim_reg_we_check (
64:     .clk_i(clk_i),
65:     .rst_ni(rst_ni),
66:     .oh_i  (reg_we_check),
67:     .en_i  (reg_we && !addrmiss),
68:     .err_o (reg_we_err)
69:   );
70: 
71:   logic err_q;
72:   always_ff @(posedge clk_i or negedge rst_ni) begin
73:     if (!rst_ni) begin
74:       err_q <= '0;
75:     end else if (intg_err || reg_we_err) begin
76:       err_q <= 1'b1;
77:     end
78:   end
79: 
80:   // integrity error output is permanent and should be used for alert generation
81:   // register errors are transactional
82:   assign intg_err_o = err_q | intg_err | reg_we_err;
83: 
84:   // outgoing integrity generation
85:   tlul_pkg::tl_d2h_t tl_o_pre;
86:   tlul_rsp_intg_gen #(
87:     .EnableRspIntgGen(1),
88:     .EnableDataIntgGen(1)
89:   ) u_rsp_intg_gen (
90:     .tl_i(tl_o_pre),
91:     .tl_o(tl_o)
92:   );
93: 
94:   tlul_pkg::tl_h2d_t tl_socket_h2d [2];
95:   tlul_pkg::tl_d2h_t tl_socket_d2h [2];
96: 
97:   logic [0:0] reg_steer;
98: 
99:   // socket_1n connection
100:   assign tl_reg_h2d = tl_socket_h2d[1];
101:   assign tl_socket_d2h[1] = tl_reg_d2h;
102: 
103:   assign tl_win_o = tl_socket_h2d[0];
104:   assign tl_socket_d2h[0] = tl_win_i;
105: 
106:   // Create Socket_1n
107:   tlul_socket_1n #(
108:     .N            (2),
109:     .HReqPass     (1'b1),
110:     .HRspPass     (1'b1),
111:     .DReqPass     ({2{1'b1}}),
112:     .DRspPass     ({2{1'b1}}),
113:     .HReqDepth    (4'h0),
114:     .HRspDepth    (4'h0),
115:     .DReqDepth    ({2{4'h0}}),
116:     .DRspDepth    ({2{4'h0}}),
117:     .ExplicitErrs (1'b0)
118:   ) u_socket (
119:     .clk_i  (clk_i),
120:     .rst_ni (rst_ni),
121:     .tl_h_i (tl_i),
122:     .tl_h_o (tl_o_pre),
123:     .tl_d_o (tl_socket_h2d),
124:     .tl_d_i (tl_socket_d2h),
125:     .dev_select_i (reg_steer)
126:   );
127: 
128:   // Create steering logic
129:   always_comb begin
130:     reg_steer =
131:         tl_i.a_address[AW-1:0] inside {[4096:8191]} ? 1'd0 :
132:         // Default set to register
133:         1'd1;
134: 
135:     // Override this in case of an integrity error
136:     if (intg_err) begin
137:       reg_steer = 1'd1;
138:     end
139:   end
140: 
141:   tlul_adapter_reg #(
142:     .RegAw(AW),
143:     .RegDw(DW),
144:     .EnableDataIntgGen(0)
145:   ) u_reg_if (
146:     .clk_i  (clk_i),
147:     .rst_ni (rst_ni),
148: 
149:     .tl_i (tl_reg_h2d),
150:     .tl_o (tl_reg_d2h),
151: 
152:     .en_ifetch_i(prim_mubi_pkg::MuBi4False),
153:     .intg_error_o(),
154: 
155:     .we_o    (reg_we),
156:     .re_o    (reg_re),
157:     .addr_o  (reg_addr),
158:     .wdata_o (reg_wdata),
159:     .be_o    (reg_be),
160:     .busy_i  (reg_busy),
161:     .rdata_i (reg_rdata),
162:     .error_i (reg_error)
163:   );
164: 
165:   // cdc oversampling signals
166: 
167:   assign reg_rdata = reg_rdata_next ;
168:   assign reg_error = addrmiss | wr_err | intg_err;
169: 
170:   // Define SW related signals
171:   // Format: <reg>_<field>_{wd|we|qs}
172:   //        or <reg>_{wd|we|qs} if field == 1 or 0
173:   logic intr_state_we;
174:   logic intr_state_hmac_done_qs;
175:   logic intr_state_hmac_done_wd;
176:   logic intr_state_fifo_empty_qs;
177:   logic intr_state_hmac_err_qs;
178:   logic intr_state_hmac_err_wd;
179:   logic intr_enable_we;
180:   logic intr_enable_hmac_done_qs;
181:   logic intr_enable_hmac_done_wd;
182:   logic intr_enable_fifo_empty_qs;
183:   logic intr_enable_fifo_empty_wd;
184:   logic intr_enable_hmac_err_qs;
185:   logic intr_enable_hmac_err_wd;
186:   logic intr_test_we;
187:   logic intr_test_hmac_done_wd;
188:   logic intr_test_fifo_empty_wd;
189:   logic intr_test_hmac_err_wd;
190:   logic alert_test_we;
191:   logic alert_test_wd;
192:   logic cfg_re;
193:   logic cfg_we;
194:   logic cfg_hmac_en_qs;
195:   logic cfg_hmac_en_wd;
196:   logic cfg_sha_en_qs;
197:   logic cfg_sha_en_wd;
198:   logic cfg_endian_swap_qs;
199:   logic cfg_endian_swap_wd;
200:   logic cfg_digest_swap_qs;
201:   logic cfg_digest_swap_wd;
202:   logic cfg_key_swap_qs;
203:   logic cfg_key_swap_wd;
204:   logic [3:0] cfg_digest_size_qs;
205:   logic [3:0] cfg_digest_size_wd;
206:   logic [5:0] cfg_key_length_qs;
207:   logic [5:0] cfg_key_length_wd;
208:   logic cmd_we;
209:   logic cmd_hash_start_wd;
210:   logic cmd_hash_process_wd;
211:   logic cmd_hash_stop_wd;
212:   logic cmd_hash_continue_wd;
213:   logic status_re;
214:   logic status_hmac_idle_qs;
215:   logic status_fifo_empty_qs;
216:   logic status_fifo_full_qs;
217:   logic [5:0] status_fifo_depth_qs;
218:   logic [31:0] err_code_qs;
219:   logic wipe_secret_we;
220:   logic [31:0] wipe_secret_wd;
221:   logic key_0_we;
222:   logic [31:0] key_0_wd;
223:   logic key_1_we;
224:   logic [31:0] key_1_wd;
225:   logic key_2_we;
226:   logic [31:0] key_2_wd;
227:   logic key_3_we;
228:   logic [31:0] key_3_wd;
229:   logic key_4_we;
230:   logic [31:0] key_4_wd;
231:   logic key_5_we;
232:   logic [31:0] key_5_wd;
233:   logic key_6_we;
234:   logic [31:0] key_6_wd;
235:   logic key_7_we;
236:   logic [31:0] key_7_wd;
237:   logic key_8_we;
238:   logic [31:0] key_8_wd;
239:   logic key_9_we;
240:   logic [31:0] key_9_wd;
241:   logic key_10_we;
242:   logic [31:0] key_10_wd;
243:   logic key_11_we;
244:   logic [31:0] key_11_wd;
245:   logic key_12_we;
246:   logic [31:0] key_12_wd;
247:   logic key_13_we;
248:   logic [31:0] key_13_wd;
249:   logic key_14_we;
250:   logic [31:0] key_14_wd;
251:   logic key_15_we;
252:   logic [31:0] key_15_wd;
253:   logic key_16_we;
254:   logic [31:0] key_16_wd;
255:   logic key_17_we;
256:   logic [31:0] key_17_wd;
257:   logic key_18_we;
258:   logic [31:0] key_18_wd;
259:   logic key_19_we;
260:   logic [31:0] key_19_wd;
261:   logic key_20_we;
262:   logic [31:0] key_20_wd;
263:   logic key_21_we;
264:   logic [31:0] key_21_wd;
265:   logic key_22_we;
266:   logic [31:0] key_22_wd;
267:   logic key_23_we;
268:   logic [31:0] key_23_wd;
269:   logic key_24_we;
270:   logic [31:0] key_24_wd;
271:   logic key_25_we;
272:   logic [31:0] key_25_wd;
273:   logic key_26_we;
274:   logic [31:0] key_26_wd;
275:   logic key_27_we;
276:   logic [31:0] key_27_wd;
277:   logic key_28_we;
278:   logic [31:0] key_28_wd;
279:   logic key_29_we;
280:   logic [31:0] key_29_wd;
281:   logic key_30_we;
282:   logic [31:0] key_30_wd;
283:   logic key_31_we;
284:   logic [31:0] key_31_wd;
285:   logic digest_0_re;
286:   logic digest_0_we;
287:   logic [31:0] digest_0_qs;
288:   logic [31:0] digest_0_wd;
289:   logic digest_1_re;
290:   logic digest_1_we;
291:   logic [31:0] digest_1_qs;
292:   logic [31:0] digest_1_wd;
293:   logic digest_2_re;
294:   logic digest_2_we;
295:   logic [31:0] digest_2_qs;
296:   logic [31:0] digest_2_wd;
297:   logic digest_3_re;
298:   logic digest_3_we;
299:   logic [31:0] digest_3_qs;
300:   logic [31:0] digest_3_wd;
301:   logic digest_4_re;
302:   logic digest_4_we;
303:   logic [31:0] digest_4_qs;
304:   logic [31:0] digest_4_wd;
305:   logic digest_5_re;
306:   logic digest_5_we;
307:   logic [31:0] digest_5_qs;
308:   logic [31:0] digest_5_wd;
309:   logic digest_6_re;
310:   logic digest_6_we;
311:   logic [31:0] digest_6_qs;
312:   logic [31:0] digest_6_wd;
313:   logic digest_7_re;
314:   logic digest_7_we;
315:   logic [31:0] digest_7_qs;
316:   logic [31:0] digest_7_wd;
317:   logic digest_8_re;
318:   logic digest_8_we;
319:   logic [31:0] digest_8_qs;
320:   logic [31:0] digest_8_wd;
321:   logic digest_9_re;
322:   logic digest_9_we;
323:   logic [31:0] digest_9_qs;
324:   logic [31:0] digest_9_wd;
325:   logic digest_10_re;
326:   logic digest_10_we;
327:   logic [31:0] digest_10_qs;
328:   logic [31:0] digest_10_wd;
329:   logic digest_11_re;
330:   logic digest_11_we;
331:   logic [31:0] digest_11_qs;
332:   logic [31:0] digest_11_wd;
333:   logic digest_12_re;
334:   logic digest_12_we;
335:   logic [31:0] digest_12_qs;
336:   logic [31:0] digest_12_wd;
337:   logic digest_13_re;
338:   logic digest_13_we;
339:   logic [31:0] digest_13_qs;
340:   logic [31:0] digest_13_wd;
341:   logic digest_14_re;
342:   logic digest_14_we;
343:   logic [31:0] digest_14_qs;
344:   logic [31:0] digest_14_wd;
345:   logic digest_15_re;
346:   logic digest_15_we;
347:   logic [31:0] digest_15_qs;
348:   logic [31:0] digest_15_wd;
349:   logic msg_length_lower_re;
350:   logic msg_length_lower_we;
351:   logic [31:0] msg_length_lower_qs;
352:   logic [31:0] msg_length_lower_wd;
353:   logic msg_length_upper_re;
354:   logic msg_length_upper_we;
355:   logic [31:0] msg_length_upper_qs;
356:   logic [31:0] msg_length_upper_wd;
357: 
358:   // Register instances
359:   // R[intr_state]: V(False)
360:   //   F[hmac_done]: 0:0
361:   prim_subreg #(
362:     .DW      (1),
363:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
364:     .RESVAL  (1'h0),
365:     .Mubi    (1'b0)
366:   ) u_intr_state_hmac_done (
367:     .clk_i   (clk_i),
368:     .rst_ni  (rst_ni),
369: 
370:     // from register interface
371:     .we     (intr_state_we),
372:     .wd     (intr_state_hmac_done_wd),
373: 
374:     // from internal hardware
375:     .de     (hw2reg.intr_state.hmac_done.de),
376:     .d      (hw2reg.intr_state.hmac_done.d),
377: 
378:     // to internal hardware
379:     .qe     (),
380:     .q      (reg2hw.intr_state.hmac_done.q),
381:     .ds     (),
382: 
383:     // to register interface (read)
384:     .qs     (intr_state_hmac_done_qs)
385:   );
386: 
387:   //   F[fifo_empty]: 1:1
388:   prim_subreg #(
389:     .DW      (1),
390:     .SwAccess(prim_subreg_pkg::SwAccessRO),
391:     .RESVAL  (1'h0),
392:     .Mubi    (1'b0)
393:   ) u_intr_state_fifo_empty (
394:     .clk_i   (clk_i),
395:     .rst_ni  (rst_ni),
396: 
397:     // from register interface
398:     .we     (1'b0),
399:     .wd     ('0),
400: 
401:     // from internal hardware
402:     .de     (hw2reg.intr_state.fifo_empty.de),
403:     .d      (hw2reg.intr_state.fifo_empty.d),
404: 
405:     // to internal hardware
406:     .qe     (),
407:     .q      (reg2hw.intr_state.fifo_empty.q),
408:     .ds     (),
409: 
410:     // to register interface (read)
411:     .qs     (intr_state_fifo_empty_qs)
412:   );
413: 
414:   //   F[hmac_err]: 2:2
415:   prim_subreg #(
416:     .DW      (1),
417:     .SwAccess(prim_subreg_pkg::SwAccessW1C),
418:     .RESVAL  (1'h0),
419:     .Mubi    (1'b0)
420:   ) u_intr_state_hmac_err (
421:     .clk_i   (clk_i),
422:     .rst_ni  (rst_ni),
423: 
424:     // from register interface
425:     .we     (intr_state_we),
426:     .wd     (intr_state_hmac_err_wd),
427: 
428:     // from internal hardware
429:     .de     (hw2reg.intr_state.hmac_err.de),
430:     .d      (hw2reg.intr_state.hmac_err.d),
431: 
432:     // to internal hardware
433:     .qe     (),
434:     .q      (reg2hw.intr_state.hmac_err.q),
435:     .ds     (),
436: 
437:     // to register interface (read)
438:     .qs     (intr_state_hmac_err_qs)
439:   );
440: 
441: 
442:   // R[intr_enable]: V(False)
443:   //   F[hmac_done]: 0:0
444:   prim_subreg #(
445:     .DW      (1),
446:     .SwAccess(prim_subreg_pkg::SwAccessRW),
447:     .RESVAL  (1'h0),
448:     .Mubi    (1'b0)
449:   ) u_intr_enable_hmac_done (
450:     .clk_i   (clk_i),
451:     .rst_ni  (rst_ni),
452: 
453:     // from register interface
454:     .we     (intr_enable_we),
455:     .wd     (intr_enable_hmac_done_wd),
456: 
457:     // from internal hardware
458:     .de     (1'b0),
459:     .d      ('0),
460: 
461:     // to internal hardware
462:     .qe     (),
463:     .q      (reg2hw.intr_enable.hmac_done.q),
464:     .ds     (),
465: 
466:     // to register interface (read)
467:     .qs     (intr_enable_hmac_done_qs)
468:   );
469: 
470:   //   F[fifo_empty]: 1:1
471:   prim_subreg #(
472:     .DW      (1),
473:     .SwAccess(prim_subreg_pkg::SwAccessRW),
474:     .RESVAL  (1'h0),
475:     .Mubi    (1'b0)
476:   ) u_intr_enable_fifo_empty (
477:     .clk_i   (clk_i),
478:     .rst_ni  (rst_ni),
479: 
480:     // from register interface
481:     .we     (intr_enable_we),
482:     .wd     (intr_enable_fifo_empty_wd),
483: 
484:     // from internal hardware
485:     .de     (1'b0),
486:     .d      ('0),
487: 
488:     // to internal hardware
489:     .qe     (),
490:     .q      (reg2hw.intr_enable.fifo_empty.q),
491:     .ds     (),
492: 
493:     // to register interface (read)
494:     .qs     (intr_enable_fifo_empty_qs)
495:   );
496: 
497:   //   F[hmac_err]: 2:2
498:   prim_subreg #(
499:     .DW      (1),
500:     .SwAccess(prim_subreg_pkg::SwAccessRW),
501:     .RESVAL  (1'h0),
502:     .Mubi    (1'b0)
503:   ) u_intr_enable_hmac_err (
504:     .clk_i   (clk_i),
505:     .rst_ni  (rst_ni),
506: 
507:     // from register interface
508:     .we     (intr_enable_we),
509:     .wd     (intr_enable_hmac_err_wd),
510: 
511:     // from internal hardware
512:     .de     (1'b0),
513:     .d      ('0),
514: 
515:     // to internal hardware
516:     .qe     (),
517:     .q      (reg2hw.intr_enable.hmac_err.q),
518:     .ds     (),
519: 
520:     // to register interface (read)
521:     .qs     (intr_enable_hmac_err_qs)
522:   );
523: 
524: 
525:   // R[intr_test]: V(True)
526:   logic intr_test_qe;
527:   logic [2:0] intr_test_flds_we;
528:   assign intr_test_qe = &intr_test_flds_we;
529:   //   F[hmac_done]: 0:0
530:   prim_subreg_ext #(
531:     .DW    (1)
532:   ) u_intr_test_hmac_done (
533:     .re     (1'b0),
534:     .we     (intr_test_we),
535:     .wd     (intr_test_hmac_done_wd),
536:     .d      ('0),
537:     .qre    (),
538:     .qe     (intr_test_flds_we[0]),
539:     .q      (reg2hw.intr_test.hmac_done.q),
540:     .ds     (),
541:     .qs     ()
542:   );
543:   assign reg2hw.intr_test.hmac_done.qe = intr_test_qe;
544: 
545:   //   F[fifo_empty]: 1:1
546:   prim_subreg_ext #(
547:     .DW    (1)
548:   ) u_intr_test_fifo_empty (
549:     .re     (1'b0),
550:     .we     (intr_test_we),
551:     .wd     (intr_test_fifo_empty_wd),
552:     .d      ('0),
553:     .qre    (),
554:     .qe     (intr_test_flds_we[1]),
555:     .q      (reg2hw.intr_test.fifo_empty.q),
556:     .ds     (),
557:     .qs     ()
558:   );
559:   assign reg2hw.intr_test.fifo_empty.qe = intr_test_qe;
560: 
561:   //   F[hmac_err]: 2:2
562:   prim_subreg_ext #(
563:     .DW    (1)
564:   ) u_intr_test_hmac_err (
565:     .re     (1'b0),
566:     .we     (intr_test_we),
567:     .wd     (intr_test_hmac_err_wd),
568:     .d      ('0),
569:     .qre    (),
570:     .qe     (intr_test_flds_we[2]),
571:     .q      (reg2hw.intr_test.hmac_err.q),
572:     .ds     (),
573:     .qs     ()
574:   );
575:   assign reg2hw.intr_test.hmac_err.qe = intr_test_qe;
576: 
577: 
578:   // R[alert_test]: V(True)
579:   logic alert_test_qe;
580:   logic [0:0] alert_test_flds_we;
581:   assign alert_test_qe = &alert_test_flds_we;
582:   prim_subreg_ext #(
583:     .DW    (1)
584:   ) u_alert_test (
585:     .re     (1'b0),
586:     .we     (alert_test_we),
587:     .wd     (alert_test_wd),
588:     .d      ('0),
589:     .qre    (),
590:     .qe     (alert_test_flds_we[0]),
591:     .q      (reg2hw.alert_test.q),
592:     .ds     (),
593:     .qs     ()
594:   );
595:   assign reg2hw.alert_test.qe = alert_test_qe;
596: 
597: 
598:   // R[cfg]: V(True)
599:   logic cfg_qe;
600:   logic [6:0] cfg_flds_we;
601:   assign cfg_qe = &cfg_flds_we;
602:   //   F[hmac_en]: 0:0
603:   prim_subreg_ext #(
604:     .DW    (1)
605:   ) u_cfg_hmac_en (
606:     .re     (cfg_re),
607:     .we     (cfg_we),
608:     .wd     (cfg_hmac_en_wd),
609:     .d      (hw2reg.cfg.hmac_en.d),
610:     .qre    (),
611:     .qe     (cfg_flds_we[0]),
612:     .q      (reg2hw.cfg.hmac_en.q),
613:     .ds     (),
614:     .qs     (cfg_hmac_en_qs)
615:   );
616:   assign reg2hw.cfg.hmac_en.qe = cfg_qe;
617: 
618:   //   F[sha_en]: 1:1
619:   prim_subreg_ext #(
620:     .DW    (1)
621:   ) u_cfg_sha_en (
622:     .re     (cfg_re),
623:     .we     (cfg_we),
624:     .wd     (cfg_sha_en_wd),
625:     .d      (hw2reg.cfg.sha_en.d),
626:     .qre    (),
627:     .qe     (cfg_flds_we[1]),
628:     .q      (reg2hw.cfg.sha_en.q),
629:     .ds     (),
630:     .qs     (cfg_sha_en_qs)
631:   );
632:   assign reg2hw.cfg.sha_en.qe = cfg_qe;
633: 
634:   //   F[endian_swap]: 2:2
635:   prim_subreg_ext #(
636:     .DW    (1)
637:   ) u_cfg_endian_swap (
638:     .re     (cfg_re),
639:     .we     (cfg_we),
640:     .wd     (cfg_endian_swap_wd),
641:     .d      (hw2reg.cfg.endian_swap.d),
642:     .qre    (),
643:     .qe     (cfg_flds_we[2]),
644:     .q      (reg2hw.cfg.endian_swap.q),
645:     .ds     (),
646:     .qs     (cfg_endian_swap_qs)
647:   );
648:   assign reg2hw.cfg.endian_swap.qe = cfg_qe;
649: 
650:   //   F[digest_swap]: 3:3
651:   prim_subreg_ext #(
652:     .DW    (1)
653:   ) u_cfg_digest_swap (
654:     .re     (cfg_re),
655:     .we     (cfg_we),
656:     .wd     (cfg_digest_swap_wd),
657:     .d      (hw2reg.cfg.digest_swap.d),
658:     .qre    (),
659:     .qe     (cfg_flds_we[3]),
660:     .q      (reg2hw.cfg.digest_swap.q),
661:     .ds     (),
662:     .qs     (cfg_digest_swap_qs)
663:   );
664:   assign reg2hw.cfg.digest_swap.qe = cfg_qe;
665: 
666:   //   F[key_swap]: 4:4
667:   prim_subreg_ext #(
668:     .DW    (1)
669:   ) u_cfg_key_swap (
670:     .re     (cfg_re),
671:     .we     (cfg_we),
672:     .wd     (cfg_key_swap_wd),
673:     .d      (hw2reg.cfg.key_swap.d),
674:     .qre    (),
675:     .qe     (cfg_flds_we[4]),
676:     .q      (reg2hw.cfg.key_swap.q),
677:     .ds     (),
678:     .qs     (cfg_key_swap_qs)
679:   );
680:   assign reg2hw.cfg.key_swap.qe = cfg_qe;
681: 
682:   //   F[digest_size]: 8:5
683:   prim_subreg_ext #(
684:     .DW    (4)
685:   ) u_cfg_digest_size (
686:     .re     (cfg_re),
687:     .we     (cfg_we),
688:     .wd     (cfg_digest_size_wd),
689:     .d      (hw2reg.cfg.digest_size.d),
690:     .qre    (),
691:     .qe     (cfg_flds_we[5]),
692:     .q      (reg2hw.cfg.digest_size.q),
693:     .ds     (),
694:     .qs     (cfg_digest_size_qs)
695:   );
696:   assign reg2hw.cfg.digest_size.qe = cfg_qe;
697: 
698:   //   F[key_length]: 14:9
699:   prim_subreg_ext #(
700:     .DW    (6)
701:   ) u_cfg_key_length (
702:     .re     (cfg_re),
703:     .we     (cfg_we),
704:     .wd     (cfg_key_length_wd),
705:     .d      (hw2reg.cfg.key_length.d),
706:     .qre    (),
707:     .qe     (cfg_flds_we[6]),
708:     .q      (reg2hw.cfg.key_length.q),
709:     .ds     (),
710:     .qs     (cfg_key_length_qs)
711:   );
712:   assign reg2hw.cfg.key_length.qe = cfg_qe;
713: 
714: 
715:   // R[cmd]: V(True)
716:   logic cmd_qe;
717:   logic [3:0] cmd_flds_we;
718:   assign cmd_qe = &cmd_flds_we;
719:   //   F[hash_start]: 0:0
720:   prim_subreg_ext #(
721:     .DW    (1)
722:   ) u_cmd_hash_start (
723:     .re     (1'b0),
724:     .we     (cmd_we),
725:     .wd     (cmd_hash_start_wd),
726:     .d      ('0),
727:     .qre    (),
728:     .qe     (cmd_flds_we[0]),
729:     .q      (reg2hw.cmd.hash_start.q),
730:     .ds     (),
731:     .qs     ()
732:   );
733:   assign reg2hw.cmd.hash_start.qe = cmd_qe;
734: 
735:   //   F[hash_process]: 1:1
736:   prim_subreg_ext #(
737:     .DW    (1)
738:   ) u_cmd_hash_process (
739:     .re     (1'b0),
740:     .we     (cmd_we),
741:     .wd     (cmd_hash_process_wd),
742:     .d      ('0),
743:     .qre    (),
744:     .qe     (cmd_flds_we[1]),
745:     .q      (reg2hw.cmd.hash_process.q),
746:     .ds     (),
747:     .qs     ()
748:   );
749:   assign reg2hw.cmd.hash_process.qe = cmd_qe;
750: 
751:   //   F[hash_stop]: 2:2
752:   prim_subreg_ext #(
753:     .DW    (1)
754:   ) u_cmd_hash_stop (
755:     .re     (1'b0),
756:     .we     (cmd_we),
757:     .wd     (cmd_hash_stop_wd),
758:     .d      ('0),
759:     .qre    (),
760:     .qe     (cmd_flds_we[2]),
761:     .q      (reg2hw.cmd.hash_stop.q),
762:     .ds     (),
763:     .qs     ()
764:   );
765:   assign reg2hw.cmd.hash_stop.qe = cmd_qe;
766: 
767:   //   F[hash_continue]: 3:3
768:   prim_subreg_ext #(
769:     .DW    (1)
770:   ) u_cmd_hash_continue (
771:     .re     (1'b0),
772:     .we     (cmd_we),
773:     .wd     (cmd_hash_continue_wd),
774:     .d      ('0),
775:     .qre    (),
776:     .qe     (cmd_flds_we[3]),
777:     .q      (reg2hw.cmd.hash_continue.q),
778:     .ds     (),
779:     .qs     ()
780:   );
781:   assign reg2hw.cmd.hash_continue.qe = cmd_qe;
782: 
783: 
784:   // R[status]: V(True)
785:   //   F[hmac_idle]: 0:0
786:   prim_subreg_ext #(
787:     .DW    (1)
788:   ) u_status_hmac_idle (
789:     .re     (status_re),
790:     .we     (1'b0),
791:     .wd     ('0),
792:     .d      (hw2reg.status.hmac_idle.d),
793:     .qre    (),
794:     .qe     (),
795:     .q      (),
796:     .ds     (),
797:     .qs     (status_hmac_idle_qs)
798:   );
799: 
800:   //   F[fifo_empty]: 1:1
801:   prim_subreg_ext #(
802:     .DW    (1)
803:   ) u_status_fifo_empty (
804:     .re     (status_re),
805:     .we     (1'b0),
806:     .wd     ('0),
807:     .d      (hw2reg.status.fifo_empty.d),
808:     .qre    (),
809:     .qe     (),
810:     .q      (),
811:     .ds     (),
812:     .qs     (status_fifo_empty_qs)
813:   );
814: 
815:   //   F[fifo_full]: 2:2
816:   prim_subreg_ext #(
817:     .DW    (1)
818:   ) u_status_fifo_full (
819:     .re     (status_re),
820:     .we     (1'b0),
821:     .wd     ('0),
822:     .d      (hw2reg.status.fifo_full.d),
823:     .qre    (),
824:     .qe     (),
825:     .q      (),
826:     .ds     (),
827:     .qs     (status_fifo_full_qs)
828:   );
829: 
830:   //   F[fifo_depth]: 9:4
831:   prim_subreg_ext #(
832:     .DW    (6)
833:   ) u_status_fifo_depth (
834:     .re     (status_re),
835:     .we     (1'b0),
836:     .wd     ('0),
837:     .d      (hw2reg.status.fifo_depth.d),
838:     .qre    (),
839:     .qe     (),
840:     .q      (),
841:     .ds     (),
842:     .qs     (status_fifo_depth_qs)
843:   );
844: 
845: 
846:   // R[err_code]: V(False)
847:   prim_subreg #(
848:     .DW      (32),
849:     .SwAccess(prim_subreg_pkg::SwAccessRO),
850:     .RESVAL  (32'h0),
851:     .Mubi    (1'b0)
852:   ) u_err_code (
853:     .clk_i   (clk_i),
854:     .rst_ni  (rst_ni),
855: 
856:     // from register interface
857:     .we     (1'b0),
858:     .wd     ('0),
859: 
860:     // from internal hardware
861:     .de     (hw2reg.err_code.de),
862:     .d      (hw2reg.err_code.d),
863: 
864:     // to internal hardware
865:     .qe     (),
866:     .q      (),
867:     .ds     (),
868: 
869:     // to register interface (read)
870:     .qs     (err_code_qs)
871:   );
872: 
873: 
874:   // R[wipe_secret]: V(True)
875:   logic wipe_secret_qe;
876:   logic [0:0] wipe_secret_flds_we;
877:   assign wipe_secret_qe = &wipe_secret_flds_we;
878:   prim_subreg_ext #(
879:     .DW    (32)
880:   ) u_wipe_secret (
881:     .re     (1'b0),
882:     .we     (wipe_secret_we),
883:     .wd     (wipe_secret_wd),
884:     .d      ('0),
885:     .qre    (),
886:     .qe     (wipe_secret_flds_we[0]),
887:     .q      (reg2hw.wipe_secret.q),
888:     .ds     (),
889:     .qs     ()
890:   );
891:   assign reg2hw.wipe_secret.qe = wipe_secret_qe;
892: 
893: 
894:   // Subregister 0 of Multireg key
895:   // R[key_0]: V(True)
896:   logic key_0_qe;
897:   logic [0:0] key_0_flds_we;
898:   assign key_0_qe = &key_0_flds_we;
899:   prim_subreg_ext #(
900:     .DW    (32)
901:   ) u_key_0 (
902:     .re     (1'b0),
903:     .we     (key_0_we),
904:     .wd     (key_0_wd),
905:     .d      (hw2reg.key[0].d),
906:     .qre    (),
907:     .qe     (key_0_flds_we[0]),
908:     .q      (reg2hw.key[0].q),
909:     .ds     (),
910:     .qs     ()
911:   );
912:   assign reg2hw.key[0].qe = key_0_qe;
913: 
914: 
915:   // Subregister 1 of Multireg key
916:   // R[key_1]: V(True)
917:   logic key_1_qe;
918:   logic [0:0] key_1_flds_we;
919:   assign key_1_qe = &key_1_flds_we;
920:   prim_subreg_ext #(
921:     .DW    (32)
922:   ) u_key_1 (
923:     .re     (1'b0),
924:     .we     (key_1_we),
925:     .wd     (key_1_wd),
926:     .d      (hw2reg.key[1].d),
927:     .qre    (),
928:     .qe     (key_1_flds_we[0]),
929:     .q      (reg2hw.key[1].q),
930:     .ds     (),
931:     .qs     ()
932:   );
933:   assign reg2hw.key[1].qe = key_1_qe;
934: 
935: 
936:   // Subregister 2 of Multireg key
937:   // R[key_2]: V(True)
938:   logic key_2_qe;
939:   logic [0:0] key_2_flds_we;
940:   assign key_2_qe = &key_2_flds_we;
941:   prim_subreg_ext #(
942:     .DW    (32)
943:   ) u_key_2 (
944:     .re     (1'b0),
945:     .we     (key_2_we),
946:     .wd     (key_2_wd),
947:     .d      (hw2reg.key[2].d),
948:     .qre    (),
949:     .qe     (key_2_flds_we[0]),
950:     .q      (reg2hw.key[2].q),
951:     .ds     (),
952:     .qs     ()
953:   );
954:   assign reg2hw.key[2].qe = key_2_qe;
955: 
956: 
957:   // Subregister 3 of Multireg key
958:   // R[key_3]: V(True)
959:   logic key_3_qe;
960:   logic [0:0] key_3_flds_we;
961:   assign key_3_qe = &key_3_flds_we;
962:   prim_subreg_ext #(
963:     .DW    (32)
964:   ) u_key_3 (
965:     .re     (1'b0),
966:     .we     (key_3_we),
967:     .wd     (key_3_wd),
968:     .d      (hw2reg.key[3].d),
969:     .qre    (),
970:     .qe     (key_3_flds_we[0]),
971:     .q      (reg2hw.key[3].q),
972:     .ds     (),
973:     .qs     ()
974:   );
975:   assign reg2hw.key[3].qe = key_3_qe;
976: 
977: 
978:   // Subregister 4 of Multireg key
979:   // R[key_4]: V(True)
980:   logic key_4_qe;
981:   logic [0:0] key_4_flds_we;
982:   assign key_4_qe = &key_4_flds_we;
983:   prim_subreg_ext #(
984:     .DW    (32)
985:   ) u_key_4 (
986:     .re     (1'b0),
987:     .we     (key_4_we),
988:     .wd     (key_4_wd),
989:     .d      (hw2reg.key[4].d),
990:     .qre    (),
991:     .qe     (key_4_flds_we[0]),
992:     .q      (reg2hw.key[4].q),
993:     .ds     (),
994:     .qs     ()
995:   );
996:   assign reg2hw.key[4].qe = key_4_qe;
997: 
998: 
999:   // Subregister 5 of Multireg key
1000:   // R[key_5]: V(True)
1001:   logic key_5_qe;
1002:   logic [0:0] key_5_flds_we;
1003:   assign key_5_qe = &key_5_flds_we;
1004:   prim_subreg_ext #(
1005:     .DW    (32)
1006:   ) u_key_5 (
1007:     .re     (1'b0),
1008:     .we     (key_5_we),
1009:     .wd     (key_5_wd),
1010:     .d      (hw2reg.key[5].d),
1011:     .qre    (),
1012:     .qe     (key_5_flds_we[0]),
1013:     .q      (reg2hw.key[5].q),
1014:     .ds     (),
1015:     .qs     ()
1016:   );
1017:   assign reg2hw.key[5].qe = key_5_qe;
1018: 
1019: 
1020:   // Subregister 6 of Multireg key
1021:   // R[key_6]: V(True)
1022:   logic key_6_qe;
1023:   logic [0:0] key_6_flds_we;
1024:   assign key_6_qe = &key_6_flds_we;
1025:   prim_subreg_ext #(
1026:     .DW    (32)
1027:   ) u_key_6 (
1028:     .re     (1'b0),
1029:     .we     (key_6_we),
1030:     .wd     (key_6_wd),
1031:     .d      (hw2reg.key[6].d),
1032:     .qre    (),
1033:     .qe     (key_6_flds_we[0]),
1034:     .q      (reg2hw.key[6].q),
1035:     .ds     (),
1036:     .qs     ()
1037:   );
1038:   assign reg2hw.key[6].qe = key_6_qe;
1039: 
1040: 
1041:   // Subregister 7 of Multireg key
1042:   // R[key_7]: V(True)
1043:   logic key_7_qe;
1044:   logic [0:0] key_7_flds_we;
1045:   assign key_7_qe = &key_7_flds_we;
1046:   prim_subreg_ext #(
1047:     .DW    (32)
1048:   ) u_key_7 (
1049:     .re     (1'b0),
1050:     .we     (key_7_we),
1051:     .wd     (key_7_wd),
1052:     .d      (hw2reg.key[7].d),
1053:     .qre    (),
1054:     .qe     (key_7_flds_we[0]),
1055:     .q      (reg2hw.key[7].q),
1056:     .ds     (),
1057:     .qs     ()
1058:   );
1059:   assign reg2hw.key[7].qe = key_7_qe;
1060: 
1061: 
1062:   // Subregister 8 of Multireg key
1063:   // R[key_8]: V(True)
1064:   logic key_8_qe;
1065:   logic [0:0] key_8_flds_we;
1066:   assign key_8_qe = &key_8_flds_we;
1067:   prim_subreg_ext #(
1068:     .DW    (32)
1069:   ) u_key_8 (
1070:     .re     (1'b0),
1071:     .we     (key_8_we),
1072:     .wd     (key_8_wd),
1073:     .d      (hw2reg.key[8].d),
1074:     .qre    (),
1075:     .qe     (key_8_flds_we[0]),
1076:     .q      (reg2hw.key[8].q),
1077:     .ds     (),
1078:     .qs     ()
1079:   );
1080:   assign reg2hw.key[8].qe = key_8_qe;
1081: 
1082: 
1083:   // Subregister 9 of Multireg key
1084:   // R[key_9]: V(True)
1085:   logic key_9_qe;
1086:   logic [0:0] key_9_flds_we;
1087:   assign key_9_qe = &key_9_flds_we;
1088:   prim_subreg_ext #(
1089:     .DW    (32)
1090:   ) u_key_9 (
1091:     .re     (1'b0),
1092:     .we     (key_9_we),
1093:     .wd     (key_9_wd),
1094:     .d      (hw2reg.key[9].d),
1095:     .qre    (),
1096:     .qe     (key_9_flds_we[0]),
1097:     .q      (reg2hw.key[9].q),
1098:     .ds     (),
1099:     .qs     ()
1100:   );
1101:   assign reg2hw.key[9].qe = key_9_qe;
1102: 
1103: 
1104:   // Subregister 10 of Multireg key
1105:   // R[key_10]: V(True)
1106:   logic key_10_qe;
1107:   logic [0:0] key_10_flds_we;
1108:   assign key_10_qe = &key_10_flds_we;
1109:   prim_subreg_ext #(
1110:     .DW    (32)
1111:   ) u_key_10 (
1112:     .re     (1'b0),
1113:     .we     (key_10_we),
1114:     .wd     (key_10_wd),
1115:     .d      (hw2reg.key[10].d),
1116:     .qre    (),
1117:     .qe     (key_10_flds_we[0]),
1118:     .q      (reg2hw.key[10].q),
1119:     .ds     (),
1120:     .qs     ()
1121:   );
1122:   assign reg2hw.key[10].qe = key_10_qe;
1123: 
1124: 
1125:   // Subregister 11 of Multireg key
1126:   // R[key_11]: V(True)
1127:   logic key_11_qe;
1128:   logic [0:0] key_11_flds_we;
1129:   assign key_11_qe = &key_11_flds_we;
1130:   prim_subreg_ext #(
1131:     .DW    (32)
1132:   ) u_key_11 (
1133:     .re     (1'b0),
1134:     .we     (key_11_we),
1135:     .wd     (key_11_wd),
1136:     .d      (hw2reg.key[11].d),
1137:     .qre    (),
1138:     .qe     (key_11_flds_we[0]),
1139:     .q      (reg2hw.key[11].q),
1140:     .ds     (),
1141:     .qs     ()
1142:   );
1143:   assign reg2hw.key[11].qe = key_11_qe;
1144: 
1145: 
1146:   // Subregister 12 of Multireg key
1147:   // R[key_12]: V(True)
1148:   logic key_12_qe;
1149:   logic [0:0] key_12_flds_we;
1150:   assign key_12_qe = &key_12_flds_we;
1151:   prim_subreg_ext #(
1152:     .DW    (32)
1153:   ) u_key_12 (
1154:     .re     (1'b0),
1155:     .we     (key_12_we),
1156:     .wd     (key_12_wd),
1157:     .d      (hw2reg.key[12].d),
1158:     .qre    (),
1159:     .qe     (key_12_flds_we[0]),
1160:     .q      (reg2hw.key[12].q),
1161:     .ds     (),
1162:     .qs     ()
1163:   );
1164:   assign reg2hw.key[12].qe = key_12_qe;
1165: 
1166: 
1167:   // Subregister 13 of Multireg key
1168:   // R[key_13]: V(True)
1169:   logic key_13_qe;
1170:   logic [0:0] key_13_flds_we;
1171:   assign key_13_qe = &key_13_flds_we;
1172:   prim_subreg_ext #(
1173:     .DW    (32)
1174:   ) u_key_13 (
1175:     .re     (1'b0),
1176:     .we     (key_13_we),
1177:     .wd     (key_13_wd),
1178:     .d      (hw2reg.key[13].d),
1179:     .qre    (),
1180:     .qe     (key_13_flds_we[0]),
1181:     .q      (reg2hw.key[13].q),
1182:     .ds     (),
1183:     .qs     ()
1184:   );
1185:   assign reg2hw.key[13].qe = key_13_qe;
1186: 
1187: 
1188:   // Subregister 14 of Multireg key
1189:   // R[key_14]: V(True)
1190:   logic key_14_qe;
1191:   logic [0:0] key_14_flds_we;
1192:   assign key_14_qe = &key_14_flds_we;
1193:   prim_subreg_ext #(
1194:     .DW    (32)
1195:   ) u_key_14 (
1196:     .re     (1'b0),
1197:     .we     (key_14_we),
1198:     .wd     (key_14_wd),
1199:     .d      (hw2reg.key[14].d),
1200:     .qre    (),
1201:     .qe     (key_14_flds_we[0]),
1202:     .q      (reg2hw.key[14].q),
1203:     .ds     (),
1204:     .qs     ()
1205:   );
1206:   assign reg2hw.key[14].qe = key_14_qe;
1207: 
1208: 
1209:   // Subregister 15 of Multireg key
1210:   // R[key_15]: V(True)
1211:   logic key_15_qe;
1212:   logic [0:0] key_15_flds_we;
1213:   assign key_15_qe = &key_15_flds_we;
1214:   prim_subreg_ext #(
1215:     .DW    (32)
1216:   ) u_key_15 (
1217:     .re     (1'b0),
1218:     .we     (key_15_we),
1219:     .wd     (key_15_wd),
1220:     .d      (hw2reg.key[15].d),
1221:     .qre    (),
1222:     .qe     (key_15_flds_we[0]),
1223:     .q      (reg2hw.key[15].q),
1224:     .ds     (),
1225:     .qs     ()
1226:   );
1227:   assign reg2hw.key[15].qe = key_15_qe;
1228: 
1229: 
1230:   // Subregister 16 of Multireg key
1231:   // R[key_16]: V(True)
1232:   logic key_16_qe;
1233:   logic [0:0] key_16_flds_we;
1234:   assign key_16_qe = &key_16_flds_we;
1235:   prim_subreg_ext #(
1236:     .DW    (32)
1237:   ) u_key_16 (
1238:     .re     (1'b0),
1239:     .we     (key_16_we),
1240:     .wd     (key_16_wd),
1241:     .d      (hw2reg.key[16].d),
1242:     .qre    (),
1243:     .qe     (key_16_flds_we[0]),
1244:     .q      (reg2hw.key[16].q),
1245:     .ds     (),
1246:     .qs     ()
1247:   );
1248:   assign reg2hw.key[16].qe = key_16_qe;
1249: 
1250: 
1251:   // Subregister 17 of Multireg key
1252:   // R[key_17]: V(True)
1253:   logic key_17_qe;
1254:   logic [0:0] key_17_flds_we;
1255:   assign key_17_qe = &key_17_flds_we;
1256:   prim_subreg_ext #(
1257:     .DW    (32)
1258:   ) u_key_17 (
1259:     .re     (1'b0),
1260:     .we     (key_17_we),
1261:     .wd     (key_17_wd),
1262:     .d      (hw2reg.key[17].d),
1263:     .qre    (),
1264:     .qe     (key_17_flds_we[0]),
1265:     .q      (reg2hw.key[17].q),
1266:     .ds     (),
1267:     .qs     ()
1268:   );
1269:   assign reg2hw.key[17].qe = key_17_qe;
1270: 
1271: 
1272:   // Subregister 18 of Multireg key
1273:   // R[key_18]: V(True)
1274:   logic key_18_qe;
1275:   logic [0:0] key_18_flds_we;
1276:   assign key_18_qe = &key_18_flds_we;
1277:   prim_subreg_ext #(
1278:     .DW    (32)
1279:   ) u_key_18 (
1280:     .re     (1'b0),
1281:     .we     (key_18_we),
1282:     .wd     (key_18_wd),
1283:     .d      (hw2reg.key[18].d),
1284:     .qre    (),
1285:     .qe     (key_18_flds_we[0]),
1286:     .q      (reg2hw.key[18].q),
1287:     .ds     (),
1288:     .qs     ()
1289:   );
1290:   assign reg2hw.key[18].qe = key_18_qe;
1291: 
1292: 
1293:   // Subregister 19 of Multireg key
1294:   // R[key_19]: V(True)
1295:   logic key_19_qe;
1296:   logic [0:0] key_19_flds_we;
1297:   assign key_19_qe = &key_19_flds_we;
1298:   prim_subreg_ext #(
1299:     .DW    (32)
1300:   ) u_key_19 (
1301:     .re     (1'b0),
1302:     .we     (key_19_we),
1303:     .wd     (key_19_wd),
1304:     .d      (hw2reg.key[19].d),
1305:     .qre    (),
1306:     .qe     (key_19_flds_we[0]),
1307:     .q      (reg2hw.key[19].q),
1308:     .ds     (),
1309:     .qs     ()
1310:   );
1311:   assign reg2hw.key[19].qe = key_19_qe;
1312: 
1313: 
1314:   // Subregister 20 of Multireg key
1315:   // R[key_20]: V(True)
1316:   logic key_20_qe;
1317:   logic [0:0] key_20_flds_we;
1318:   assign key_20_qe = &key_20_flds_we;
1319:   prim_subreg_ext #(
1320:     .DW    (32)
1321:   ) u_key_20 (
1322:     .re     (1'b0),
1323:     .we     (key_20_we),
1324:     .wd     (key_20_wd),
1325:     .d      (hw2reg.key[20].d),
1326:     .qre    (),
1327:     .qe     (key_20_flds_we[0]),
1328:     .q      (reg2hw.key[20].q),
1329:     .ds     (),
1330:     .qs     ()
1331:   );
1332:   assign reg2hw.key[20].qe = key_20_qe;
1333: 
1334: 
1335:   // Subregister 21 of Multireg key
1336:   // R[key_21]: V(True)
1337:   logic key_21_qe;
1338:   logic [0:0] key_21_flds_we;
1339:   assign key_21_qe = &key_21_flds_we;
1340:   prim_subreg_ext #(
1341:     .DW    (32)
1342:   ) u_key_21 (
1343:     .re     (1'b0),
1344:     .we     (key_21_we),
1345:     .wd     (key_21_wd),
1346:     .d      (hw2reg.key[21].d),
1347:     .qre    (),
1348:     .qe     (key_21_flds_we[0]),
1349:     .q      (reg2hw.key[21].q),
1350:     .ds     (),
1351:     .qs     ()
1352:   );
1353:   assign reg2hw.key[21].qe = key_21_qe;
1354: 
1355: 
1356:   // Subregister 22 of Multireg key
1357:   // R[key_22]: V(True)
1358:   logic key_22_qe;
1359:   logic [0:0] key_22_flds_we;
1360:   assign key_22_qe = &key_22_flds_we;
1361:   prim_subreg_ext #(
1362:     .DW    (32)
1363:   ) u_key_22 (
1364:     .re     (1'b0),
1365:     .we     (key_22_we),
1366:     .wd     (key_22_wd),
1367:     .d      (hw2reg.key[22].d),
1368:     .qre    (),
1369:     .qe     (key_22_flds_we[0]),
1370:     .q      (reg2hw.key[22].q),
1371:     .ds     (),
1372:     .qs     ()
1373:   );
1374:   assign reg2hw.key[22].qe = key_22_qe;
1375: 
1376: 
1377:   // Subregister 23 of Multireg key
1378:   // R[key_23]: V(True)
1379:   logic key_23_qe;
1380:   logic [0:0] key_23_flds_we;
1381:   assign key_23_qe = &key_23_flds_we;
1382:   prim_subreg_ext #(
1383:     .DW    (32)
1384:   ) u_key_23 (
1385:     .re     (1'b0),
1386:     .we     (key_23_we),
1387:     .wd     (key_23_wd),
1388:     .d      (hw2reg.key[23].d),
1389:     .qre    (),
1390:     .qe     (key_23_flds_we[0]),
1391:     .q      (reg2hw.key[23].q),
1392:     .ds     (),
1393:     .qs     ()
1394:   );
1395:   assign reg2hw.key[23].qe = key_23_qe;
1396: 
1397: 
1398:   // Subregister 24 of Multireg key
1399:   // R[key_24]: V(True)
1400:   logic key_24_qe;
1401:   logic [0:0] key_24_flds_we;
1402:   assign key_24_qe = &key_24_flds_we;
1403:   prim_subreg_ext #(
1404:     .DW    (32)
1405:   ) u_key_24 (
1406:     .re     (1'b0),
1407:     .we     (key_24_we),
1408:     .wd     (key_24_wd),
1409:     .d      (hw2reg.key[24].d),
1410:     .qre    (),
1411:     .qe     (key_24_flds_we[0]),
1412:     .q      (reg2hw.key[24].q),
1413:     .ds     (),
1414:     .qs     ()
1415:   );
1416:   assign reg2hw.key[24].qe = key_24_qe;
1417: 
1418: 
1419:   // Subregister 25 of Multireg key
1420:   // R[key_25]: V(True)
1421:   logic key_25_qe;
1422:   logic [0:0] key_25_flds_we;
1423:   assign key_25_qe = &key_25_flds_we;
1424:   prim_subreg_ext #(
1425:     .DW    (32)
1426:   ) u_key_25 (
1427:     .re     (1'b0),
1428:     .we     (key_25_we),
1429:     .wd     (key_25_wd),
1430:     .d      (hw2reg.key[25].d),
1431:     .qre    (),
1432:     .qe     (key_25_flds_we[0]),
1433:     .q      (reg2hw.key[25].q),
1434:     .ds     (),
1435:     .qs     ()
1436:   );
1437:   assign reg2hw.key[25].qe = key_25_qe;
1438: 
1439: 
1440:   // Subregister 26 of Multireg key
1441:   // R[key_26]: V(True)
1442:   logic key_26_qe;
1443:   logic [0:0] key_26_flds_we;
1444:   assign key_26_qe = &key_26_flds_we;
1445:   prim_subreg_ext #(
1446:     .DW    (32)
1447:   ) u_key_26 (
1448:     .re     (1'b0),
1449:     .we     (key_26_we),
1450:     .wd     (key_26_wd),
1451:     .d      (hw2reg.key[26].d),
1452:     .qre    (),
1453:     .qe     (key_26_flds_we[0]),
1454:     .q      (reg2hw.key[26].q),
1455:     .ds     (),
1456:     .qs     ()
1457:   );
1458:   assign reg2hw.key[26].qe = key_26_qe;
1459: 
1460: 
1461:   // Subregister 27 of Multireg key
1462:   // R[key_27]: V(True)
1463:   logic key_27_qe;
1464:   logic [0:0] key_27_flds_we;
1465:   assign key_27_qe = &key_27_flds_we;
1466:   prim_subreg_ext #(
1467:     .DW    (32)
1468:   ) u_key_27 (
1469:     .re     (1'b0),
1470:     .we     (key_27_we),
1471:     .wd     (key_27_wd),
1472:     .d      (hw2reg.key[27].d),
1473:     .qre    (),
1474:     .qe     (key_27_flds_we[0]),
1475:     .q      (reg2hw.key[27].q),
1476:     .ds     (),
1477:     .qs     ()
1478:   );
1479:   assign reg2hw.key[27].qe = key_27_qe;
1480: 
1481: 
1482:   // Subregister 28 of Multireg key
1483:   // R[key_28]: V(True)
1484:   logic key_28_qe;
1485:   logic [0:0] key_28_flds_we;
1486:   assign key_28_qe = &key_28_flds_we;
1487:   prim_subreg_ext #(
1488:     .DW    (32)
1489:   ) u_key_28 (
1490:     .re     (1'b0),
1491:     .we     (key_28_we),
1492:     .wd     (key_28_wd),
1493:     .d      (hw2reg.key[28].d),
1494:     .qre    (),
1495:     .qe     (key_28_flds_we[0]),
1496:     .q      (reg2hw.key[28].q),
1497:     .ds     (),
1498:     .qs     ()
1499:   );
1500:   assign reg2hw.key[28].qe = key_28_qe;
1501: 
1502: 
1503:   // Subregister 29 of Multireg key
1504:   // R[key_29]: V(True)
1505:   logic key_29_qe;
1506:   logic [0:0] key_29_flds_we;
1507:   assign key_29_qe = &key_29_flds_we;
1508:   prim_subreg_ext #(
1509:     .DW    (32)
1510:   ) u_key_29 (
1511:     .re     (1'b0),
1512:     .we     (key_29_we),
1513:     .wd     (key_29_wd),
1514:     .d      (hw2reg.key[29].d),
1515:     .qre    (),
1516:     .qe     (key_29_flds_we[0]),
1517:     .q      (reg2hw.key[29].q),
1518:     .ds     (),
1519:     .qs     ()
1520:   );
1521:   assign reg2hw.key[29].qe = key_29_qe;
1522: 
1523: 
1524:   // Subregister 30 of Multireg key
1525:   // R[key_30]: V(True)
1526:   logic key_30_qe;
1527:   logic [0:0] key_30_flds_we;
1528:   assign key_30_qe = &key_30_flds_we;
1529:   prim_subreg_ext #(
1530:     .DW    (32)
1531:   ) u_key_30 (
1532:     .re     (1'b0),
1533:     .we     (key_30_we),
1534:     .wd     (key_30_wd),
1535:     .d      (hw2reg.key[30].d),
1536:     .qre    (),
1537:     .qe     (key_30_flds_we[0]),
1538:     .q      (reg2hw.key[30].q),
1539:     .ds     (),
1540:     .qs     ()
1541:   );
1542:   assign reg2hw.key[30].qe = key_30_qe;
1543: 
1544: 
1545:   // Subregister 31 of Multireg key
1546:   // R[key_31]: V(True)
1547:   logic key_31_qe;
1548:   logic [0:0] key_31_flds_we;
1549:   assign key_31_qe = &key_31_flds_we;
1550:   prim_subreg_ext #(
1551:     .DW    (32)
1552:   ) u_key_31 (
1553:     .re     (1'b0),
1554:     .we     (key_31_we),
1555:     .wd     (key_31_wd),
1556:     .d      (hw2reg.key[31].d),
1557:     .qre    (),
1558:     .qe     (key_31_flds_we[0]),
1559:     .q      (reg2hw.key[31].q),
1560:     .ds     (),
1561:     .qs     ()
1562:   );
1563:   assign reg2hw.key[31].qe = key_31_qe;
1564: 
1565: 
1566:   // Subregister 0 of Multireg digest
1567:   // R[digest_0]: V(True)
1568:   logic digest_0_qe;
1569:   logic [0:0] digest_0_flds_we;
1570:   assign digest_0_qe = &digest_0_flds_we;
1571:   prim_subreg_ext #(
1572:     .DW    (32)
1573:   ) u_digest_0 (
1574:     .re     (digest_0_re),
1575:     .we     (digest_0_we),
1576:     .wd     (digest_0_wd),
1577:     .d      (hw2reg.digest[0].d),
1578:     .qre    (),
1579:     .qe     (digest_0_flds_we[0]),
1580:     .q      (reg2hw.digest[0].q),
1581:     .ds     (),
1582:     .qs     (digest_0_qs)
1583:   );
1584:   assign reg2hw.digest[0].qe = digest_0_qe;
1585: 
1586: 
1587:   // Subregister 1 of Multireg digest
1588:   // R[digest_1]: V(True)
1589:   logic digest_1_qe;
1590:   logic [0:0] digest_1_flds_we;
1591:   assign digest_1_qe = &digest_1_flds_we;
1592:   prim_subreg_ext #(
1593:     .DW    (32)
1594:   ) u_digest_1 (
1595:     .re     (digest_1_re),
1596:     .we     (digest_1_we),
1597:     .wd     (digest_1_wd),
1598:     .d      (hw2reg.digest[1].d),
1599:     .qre    (),
1600:     .qe     (digest_1_flds_we[0]),
1601:     .q      (reg2hw.digest[1].q),
1602:     .ds     (),
1603:     .qs     (digest_1_qs)
1604:   );
1605:   assign reg2hw.digest[1].qe = digest_1_qe;
1606: 
1607: 
1608:   // Subregister 2 of Multireg digest
1609:   // R[digest_2]: V(True)
1610:   logic digest_2_qe;
1611:   logic [0:0] digest_2_flds_we;
1612:   assign digest_2_qe = &digest_2_flds_we;
1613:   prim_subreg_ext #(
1614:     .DW    (32)
1615:   ) u_digest_2 (
1616:     .re     (digest_2_re),
1617:     .we     (digest_2_we),
1618:     .wd     (digest_2_wd),
1619:     .d      (hw2reg.digest[2].d),
1620:     .qre    (),
1621:     .qe     (digest_2_flds_we[0]),
1622:     .q      (reg2hw.digest[2].q),
1623:     .ds     (),
1624:     .qs     (digest_2_qs)
1625:   );
1626:   assign reg2hw.digest[2].qe = digest_2_qe;
1627: 
1628: 
1629:   // Subregister 3 of Multireg digest
1630:   // R[digest_3]: V(True)
1631:   logic digest_3_qe;
1632:   logic [0:0] digest_3_flds_we;
1633:   assign digest_3_qe = &digest_3_flds_we;
1634:   prim_subreg_ext #(
1635:     .DW    (32)
1636:   ) u_digest_3 (
1637:     .re     (digest_3_re),
1638:     .we     (digest_3_we),
1639:     .wd     (digest_3_wd),
1640:     .d      (hw2reg.digest[3].d),
1641:     .qre    (),
1642:     .qe     (digest_3_flds_we[0]),
1643:     .q      (reg2hw.digest[3].q),
1644:     .ds     (),
1645:     .qs     (digest_3_qs)
1646:   );
1647:   assign reg2hw.digest[3].qe = digest_3_qe;
1648: 
1649: 
1650:   // Subregister 4 of Multireg digest
1651:   // R[digest_4]: V(True)
1652:   logic digest_4_qe;
1653:   logic [0:0] digest_4_flds_we;
1654:   assign digest_4_qe = &digest_4_flds_we;
1655:   prim_subreg_ext #(
1656:     .DW    (32)
1657:   ) u_digest_4 (
1658:     .re     (digest_4_re),
1659:     .we     (digest_4_we),
1660:     .wd     (digest_4_wd),
1661:     .d      (hw2reg.digest[4].d),
1662:     .qre    (),
1663:     .qe     (digest_4_flds_we[0]),
1664:     .q      (reg2hw.digest[4].q),
1665:     .ds     (),
1666:     .qs     (digest_4_qs)
1667:   );
1668:   assign reg2hw.digest[4].qe = digest_4_qe;
1669: 
1670: 
1671:   // Subregister 5 of Multireg digest
1672:   // R[digest_5]: V(True)
1673:   logic digest_5_qe;
1674:   logic [0:0] digest_5_flds_we;
1675:   assign digest_5_qe = &digest_5_flds_we;
1676:   prim_subreg_ext #(
1677:     .DW    (32)
1678:   ) u_digest_5 (
1679:     .re     (digest_5_re),
1680:     .we     (digest_5_we),
1681:     .wd     (digest_5_wd),
1682:     .d      (hw2reg.digest[5].d),
1683:     .qre    (),
1684:     .qe     (digest_5_flds_we[0]),
1685:     .q      (reg2hw.digest[5].q),
1686:     .ds     (),
1687:     .qs     (digest_5_qs)
1688:   );
1689:   assign reg2hw.digest[5].qe = digest_5_qe;
1690: 
1691: 
1692:   // Subregister 6 of Multireg digest
1693:   // R[digest_6]: V(True)
1694:   logic digest_6_qe;
1695:   logic [0:0] digest_6_flds_we;
1696:   assign digest_6_qe = &digest_6_flds_we;
1697:   prim_subreg_ext #(
1698:     .DW    (32)
1699:   ) u_digest_6 (
1700:     .re     (digest_6_re),
1701:     .we     (digest_6_we),
1702:     .wd     (digest_6_wd),
1703:     .d      (hw2reg.digest[6].d),
1704:     .qre    (),
1705:     .qe     (digest_6_flds_we[0]),
1706:     .q      (reg2hw.digest[6].q),
1707:     .ds     (),
1708:     .qs     (digest_6_qs)
1709:   );
1710:   assign reg2hw.digest[6].qe = digest_6_qe;
1711: 
1712: 
1713:   // Subregister 7 of Multireg digest
1714:   // R[digest_7]: V(True)
1715:   logic digest_7_qe;
1716:   logic [0:0] digest_7_flds_we;
1717:   assign digest_7_qe = &digest_7_flds_we;
1718:   prim_subreg_ext #(
1719:     .DW    (32)
1720:   ) u_digest_7 (
1721:     .re     (digest_7_re),
1722:     .we     (digest_7_we),
1723:     .wd     (digest_7_wd),
1724:     .d      (hw2reg.digest[7].d),
1725:     .qre    (),
1726:     .qe     (digest_7_flds_we[0]),
1727:     .q      (reg2hw.digest[7].q),
1728:     .ds     (),
1729:     .qs     (digest_7_qs)
1730:   );
1731:   assign reg2hw.digest[7].qe = digest_7_qe;
1732: 
1733: 
1734:   // Subregister 8 of Multireg digest
1735:   // R[digest_8]: V(True)
1736:   logic digest_8_qe;
1737:   logic [0:0] digest_8_flds_we;
1738:   assign digest_8_qe = &digest_8_flds_we;
1739:   prim_subreg_ext #(
1740:     .DW    (32)
1741:   ) u_digest_8 (
1742:     .re     (digest_8_re),
1743:     .we     (digest_8_we),
1744:     .wd     (digest_8_wd),
1745:     .d      (hw2reg.digest[8].d),
1746:     .qre    (),
1747:     .qe     (digest_8_flds_we[0]),
1748:     .q      (reg2hw.digest[8].q),
1749:     .ds     (),
1750:     .qs     (digest_8_qs)
1751:   );
1752:   assign reg2hw.digest[8].qe = digest_8_qe;
1753: 
1754: 
1755:   // Subregister 9 of Multireg digest
1756:   // R[digest_9]: V(True)
1757:   logic digest_9_qe;
1758:   logic [0:0] digest_9_flds_we;
1759:   assign digest_9_qe = &digest_9_flds_we;
1760:   prim_subreg_ext #(
1761:     .DW    (32)
1762:   ) u_digest_9 (
1763:     .re     (digest_9_re),
1764:     .we     (digest_9_we),
1765:     .wd     (digest_9_wd),
1766:     .d      (hw2reg.digest[9].d),
1767:     .qre    (),
1768:     .qe     (digest_9_flds_we[0]),
1769:     .q      (reg2hw.digest[9].q),
1770:     .ds     (),
1771:     .qs     (digest_9_qs)
1772:   );
1773:   assign reg2hw.digest[9].qe = digest_9_qe;
1774: 
1775: 
1776:   // Subregister 10 of Multireg digest
1777:   // R[digest_10]: V(True)
1778:   logic digest_10_qe;
1779:   logic [0:0] digest_10_flds_we;
1780:   assign digest_10_qe = &digest_10_flds_we;
1781:   prim_subreg_ext #(
1782:     .DW    (32)
1783:   ) u_digest_10 (
1784:     .re     (digest_10_re),
1785:     .we     (digest_10_we),
1786:     .wd     (digest_10_wd),
1787:     .d      (hw2reg.digest[10].d),
1788:     .qre    (),
1789:     .qe     (digest_10_flds_we[0]),
1790:     .q      (reg2hw.digest[10].q),
1791:     .ds     (),
1792:     .qs     (digest_10_qs)
1793:   );
1794:   assign reg2hw.digest[10].qe = digest_10_qe;
1795: 
1796: 
1797:   // Subregister 11 of Multireg digest
1798:   // R[digest_11]: V(True)
1799:   logic digest_11_qe;
1800:   logic [0:0] digest_11_flds_we;
1801:   assign digest_11_qe = &digest_11_flds_we;
1802:   prim_subreg_ext #(
1803:     .DW    (32)
1804:   ) u_digest_11 (
1805:     .re     (digest_11_re),
1806:     .we     (digest_11_we),
1807:     .wd     (digest_11_wd),
1808:     .d      (hw2reg.digest[11].d),
1809:     .qre    (),
1810:     .qe     (digest_11_flds_we[0]),
1811:     .q      (reg2hw.digest[11].q),
1812:     .ds     (),
1813:     .qs     (digest_11_qs)
1814:   );
1815:   assign reg2hw.digest[11].qe = digest_11_qe;
1816: 
1817: 
1818:   // Subregister 12 of Multireg digest
1819:   // R[digest_12]: V(True)
1820:   logic digest_12_qe;
1821:   logic [0:0] digest_12_flds_we;
1822:   assign digest_12_qe = &digest_12_flds_we;
1823:   prim_subreg_ext #(
1824:     .DW    (32)
1825:   ) u_digest_12 (
1826:     .re     (digest_12_re),
1827:     .we     (digest_12_we),
1828:     .wd     (digest_12_wd),
1829:     .d      (hw2reg.digest[12].d),
1830:     .qre    (),
1831:     .qe     (digest_12_flds_we[0]),
1832:     .q      (reg2hw.digest[12].q),
1833:     .ds     (),
1834:     .qs     (digest_12_qs)
1835:   );
1836:   assign reg2hw.digest[12].qe = digest_12_qe;
1837: 
1838: 
1839:   // Subregister 13 of Multireg digest
1840:   // R[digest_13]: V(True)
1841:   logic digest_13_qe;
1842:   logic [0:0] digest_13_flds_we;
1843:   assign digest_13_qe = &digest_13_flds_we;
1844:   prim_subreg_ext #(
1845:     .DW    (32)
1846:   ) u_digest_13 (
1847:     .re     (digest_13_re),
1848:     .we     (digest_13_we),
1849:     .wd     (digest_13_wd),
1850:     .d      (hw2reg.digest[13].d),
1851:     .qre    (),
1852:     .qe     (digest_13_flds_we[0]),
1853:     .q      (reg2hw.digest[13].q),
1854:     .ds     (),
1855:     .qs     (digest_13_qs)
1856:   );
1857:   assign reg2hw.digest[13].qe = digest_13_qe;
1858: 
1859: 
1860:   // Subregister 14 of Multireg digest
1861:   // R[digest_14]: V(True)
1862:   logic digest_14_qe;
1863:   logic [0:0] digest_14_flds_we;
1864:   assign digest_14_qe = &digest_14_flds_we;
1865:   prim_subreg_ext #(
1866:     .DW    (32)
1867:   ) u_digest_14 (
1868:     .re     (digest_14_re),
1869:     .we     (digest_14_we),
1870:     .wd     (digest_14_wd),
1871:     .d      (hw2reg.digest[14].d),
1872:     .qre    (),
1873:     .qe     (digest_14_flds_we[0]),
1874:     .q      (reg2hw.digest[14].q),
1875:     .ds     (),
1876:     .qs     (digest_14_qs)
1877:   );
1878:   assign reg2hw.digest[14].qe = digest_14_qe;
1879: 
1880: 
1881:   // Subregister 15 of Multireg digest
1882:   // R[digest_15]: V(True)
1883:   logic digest_15_qe;
1884:   logic [0:0] digest_15_flds_we;
1885:   assign digest_15_qe = &digest_15_flds_we;
1886:   prim_subreg_ext #(
1887:     .DW    (32)
1888:   ) u_digest_15 (
1889:     .re     (digest_15_re),
1890:     .we     (digest_15_we),
1891:     .wd     (digest_15_wd),
1892:     .d      (hw2reg.digest[15].d),
1893:     .qre    (),
1894:     .qe     (digest_15_flds_we[0]),
1895:     .q      (reg2hw.digest[15].q),
1896:     .ds     (),
1897:     .qs     (digest_15_qs)
1898:   );
1899:   assign reg2hw.digest[15].qe = digest_15_qe;
1900: 
1901: 
1902:   // R[msg_length_lower]: V(True)
1903:   logic msg_length_lower_qe;
1904:   logic [0:0] msg_length_lower_flds_we;
1905:   assign msg_length_lower_qe = &msg_length_lower_flds_we;
1906:   prim_subreg_ext #(
1907:     .DW    (32)
1908:   ) u_msg_length_lower (
1909:     .re     (msg_length_lower_re),
1910:     .we     (msg_length_lower_we),
1911:     .wd     (msg_length_lower_wd),
1912:     .d      (hw2reg.msg_length_lower.d),
1913:     .qre    (),
1914:     .qe     (msg_length_lower_flds_we[0]),
1915:     .q      (reg2hw.msg_length_lower.q),
1916:     .ds     (),
1917:     .qs     (msg_length_lower_qs)
1918:   );
1919:   assign reg2hw.msg_length_lower.qe = msg_length_lower_qe;
1920: 
1921: 
1922:   // R[msg_length_upper]: V(True)
1923:   logic msg_length_upper_qe;
1924:   logic [0:0] msg_length_upper_flds_we;
1925:   assign msg_length_upper_qe = &msg_length_upper_flds_we;
1926:   prim_subreg_ext #(
1927:     .DW    (32)
1928:   ) u_msg_length_upper (
1929:     .re     (msg_length_upper_re),
1930:     .we     (msg_length_upper_we),
1931:     .wd     (msg_length_upper_wd),
1932:     .d      (hw2reg.msg_length_upper.d),
1933:     .qre    (),
1934:     .qe     (msg_length_upper_flds_we[0]),
1935:     .q      (reg2hw.msg_length_upper.q),
1936:     .ds     (),
1937:     .qs     (msg_length_upper_qs)
1938:   );
1939:   assign reg2hw.msg_length_upper.qe = msg_length_upper_qe;
1940: 
1941: 
1942: 
1943:   logic [58:0] addr_hit;
1944:   always_comb begin
1945:     addr_hit[ 0] = (reg_addr == HMAC_INTR_STATE_OFFSET);
1946:     addr_hit[ 1] = (reg_addr == HMAC_INTR_ENABLE_OFFSET);
1947:     addr_hit[ 2] = (reg_addr == HMAC_INTR_TEST_OFFSET);
1948:     addr_hit[ 3] = (reg_addr == HMAC_ALERT_TEST_OFFSET);
1949:     addr_hit[ 4] = (reg_addr == HMAC_CFG_OFFSET);
1950:     addr_hit[ 5] = (reg_addr == HMAC_CMD_OFFSET);
1951:     addr_hit[ 6] = (reg_addr == HMAC_STATUS_OFFSET);
1952:     addr_hit[ 7] = (reg_addr == HMAC_ERR_CODE_OFFSET);
1953:     addr_hit[ 8] = (reg_addr == HMAC_WIPE_SECRET_OFFSET);
1954:     addr_hit[ 9] = (reg_addr == HMAC_KEY_0_OFFSET);
1955:     addr_hit[10] = (reg_addr == HMAC_KEY_1_OFFSET);
1956:     addr_hit[11] = (reg_addr == HMAC_KEY_2_OFFSET);
1957:     addr_hit[12] = (reg_addr == HMAC_KEY_3_OFFSET);
1958:     addr_hit[13] = (reg_addr == HMAC_KEY_4_OFFSET);
1959:     addr_hit[14] = (reg_addr == HMAC_KEY_5_OFFSET);
1960:     addr_hit[15] = (reg_addr == HMAC_KEY_6_OFFSET);
1961:     addr_hit[16] = (reg_addr == HMAC_KEY_7_OFFSET);
1962:     addr_hit[17] = (reg_addr == HMAC_KEY_8_OFFSET);
1963:     addr_hit[18] = (reg_addr == HMAC_KEY_9_OFFSET);
1964:     addr_hit[19] = (reg_addr == HMAC_KEY_10_OFFSET);
1965:     addr_hit[20] = (reg_addr == HMAC_KEY_11_OFFSET);
1966:     addr_hit[21] = (reg_addr == HMAC_KEY_12_OFFSET);
1967:     addr_hit[22] = (reg_addr == HMAC_KEY_13_OFFSET);
1968:     addr_hit[23] = (reg_addr == HMAC_KEY_14_OFFSET);
1969:     addr_hit[24] = (reg_addr == HMAC_KEY_15_OFFSET);
1970:     addr_hit[25] = (reg_addr == HMAC_KEY_16_OFFSET);
1971:     addr_hit[26] = (reg_addr == HMAC_KEY_17_OFFSET);
1972:     addr_hit[27] = (reg_addr == HMAC_KEY_18_OFFSET);
1973:     addr_hit[28] = (reg_addr == HMAC_KEY_19_OFFSET);
1974:     addr_hit[29] = (reg_addr == HMAC_KEY_20_OFFSET);
1975:     addr_hit[30] = (reg_addr == HMAC_KEY_21_OFFSET);
1976:     addr_hit[31] = (reg_addr == HMAC_KEY_22_OFFSET);
1977:     addr_hit[32] = (reg_addr == HMAC_KEY_23_OFFSET);
1978:     addr_hit[33] = (reg_addr == HMAC_KEY_24_OFFSET);
1979:     addr_hit[34] = (reg_addr == HMAC_KEY_25_OFFSET);
1980:     addr_hit[35] = (reg_addr == HMAC_KEY_26_OFFSET);
1981:     addr_hit[36] = (reg_addr == HMAC_KEY_27_OFFSET);
1982:     addr_hit[37] = (reg_addr == HMAC_KEY_28_OFFSET);
1983:     addr_hit[38] = (reg_addr == HMAC_KEY_29_OFFSET);
1984:     addr_hit[39] = (reg_addr == HMAC_KEY_30_OFFSET);
1985:     addr_hit[40] = (reg_addr == HMAC_KEY_31_OFFSET);
1986:     addr_hit[41] = (reg_addr == HMAC_DIGEST_0_OFFSET);
1987:     addr_hit[42] = (reg_addr == HMAC_DIGEST_1_OFFSET);
1988:     addr_hit[43] = (reg_addr == HMAC_DIGEST_2_OFFSET);
1989:     addr_hit[44] = (reg_addr == HMAC_DIGEST_3_OFFSET);
1990:     addr_hit[45] = (reg_addr == HMAC_DIGEST_4_OFFSET);
1991:     addr_hit[46] = (reg_addr == HMAC_DIGEST_5_OFFSET);
1992:     addr_hit[47] = (reg_addr == HMAC_DIGEST_6_OFFSET);
1993:     addr_hit[48] = (reg_addr == HMAC_DIGEST_7_OFFSET);
1994:     addr_hit[49] = (reg_addr == HMAC_DIGEST_8_OFFSET);
1995:     addr_hit[50] = (reg_addr == HMAC_DIGEST_9_OFFSET);
1996:     addr_hit[51] = (reg_addr == HMAC_DIGEST_10_OFFSET);
1997:     addr_hit[52] = (reg_addr == HMAC_DIGEST_11_OFFSET);
1998:     addr_hit[53] = (reg_addr == HMAC_DIGEST_12_OFFSET);
1999:     addr_hit[54] = (reg_addr == HMAC_DIGEST_13_OFFSET);
2000:     addr_hit[55] = (reg_addr == HMAC_DIGEST_14_OFFSET);
2001:     addr_hit[56] = (reg_addr == HMAC_DIGEST_15_OFFSET);
2002:     addr_hit[57] = (reg_addr == HMAC_MSG_LENGTH_LOWER_OFFSET);
2003:     addr_hit[58] = (reg_addr == HMAC_MSG_LENGTH_UPPER_OFFSET);
2004:   end
2005: 
2006:   assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;
2007: 
2008:   // Check sub-word write is permitted
2009:   always_comb begin
2010:     wr_err = (reg_we &
2011:               ((addr_hit[ 0] & (|(HMAC_PERMIT[ 0] & ~reg_be))) |
2012:                (addr_hit[ 1] & (|(HMAC_PERMIT[ 1] & ~reg_be))) |
2013:                (addr_hit[ 2] & (|(HMAC_PERMIT[ 2] & ~reg_be))) |
2014:                (addr_hit[ 3] & (|(HMAC_PERMIT[ 3] & ~reg_be))) |
2015:                (addr_hit[ 4] & (|(HMAC_PERMIT[ 4] & ~reg_be))) |
2016:                (addr_hit[ 5] & (|(HMAC_PERMIT[ 5] & ~reg_be))) |
2017:                (addr_hit[ 6] & (|(HMAC_PERMIT[ 6] & ~reg_be))) |
2018:                (addr_hit[ 7] & (|(HMAC_PERMIT[ 7] & ~reg_be))) |
2019:                (addr_hit[ 8] & (|(HMAC_PERMIT[ 8] & ~reg_be))) |
2020:                (addr_hit[ 9] & (|(HMAC_PERMIT[ 9] & ~reg_be))) |
2021:                (addr_hit[10] & (|(HMAC_PERMIT[10] & ~reg_be))) |
2022:                (addr_hit[11] & (|(HMAC_PERMIT[11] & ~reg_be))) |
2023:                (addr_hit[12] & (|(HMAC_PERMIT[12] & ~reg_be))) |
2024:                (addr_hit[13] & (|(HMAC_PERMIT[13] & ~reg_be))) |
2025:                (addr_hit[14] & (|(HMAC_PERMIT[14] & ~reg_be))) |
2026:                (addr_hit[15] & (|(HMAC_PERMIT[15] & ~reg_be))) |
2027:                (addr_hit[16] & (|(HMAC_PERMIT[16] & ~reg_be))) |
2028:                (addr_hit[17] & (|(HMAC_PERMIT[17] & ~reg_be))) |
2029:                (addr_hit[18] & (|(HMAC_PERMIT[18] & ~reg_be))) |
2030:                (addr_hit[19] & (|(HMAC_PERMIT[19] & ~reg_be))) |
2031:                (addr_hit[20] & (|(HMAC_PERMIT[20] & ~reg_be))) |
2032:                (addr_hit[21] & (|(HMAC_PERMIT[21] & ~reg_be))) |
2033:                (addr_hit[22] & (|(HMAC_PERMIT[22] & ~reg_be))) |
2034:                (addr_hit[23] & (|(HMAC_PERMIT[23] & ~reg_be))) |
2035:                (addr_hit[24] & (|(HMAC_PERMIT[24] & ~reg_be))) |
2036:                (addr_hit[25] & (|(HMAC_PERMIT[25] & ~reg_be))) |
2037:                (addr_hit[26] & (|(HMAC_PERMIT[26] & ~reg_be))) |
2038:                (addr_hit[27] & (|(HMAC_PERMIT[27] & ~reg_be))) |
2039:                (addr_hit[28] & (|(HMAC_PERMIT[28] & ~reg_be))) |
2040:                (addr_hit[29] & (|(HMAC_PERMIT[29] & ~reg_be))) |
2041:                (addr_hit[30] & (|(HMAC_PERMIT[30] & ~reg_be))) |
2042:                (addr_hit[31] & (|(HMAC_PERMIT[31] & ~reg_be))) |
2043:                (addr_hit[32] & (|(HMAC_PERMIT[32] & ~reg_be))) |
2044:                (addr_hit[33] & (|(HMAC_PERMIT[33] & ~reg_be))) |
2045:                (addr_hit[34] & (|(HMAC_PERMIT[34] & ~reg_be))) |
2046:                (addr_hit[35] & (|(HMAC_PERMIT[35] & ~reg_be))) |
2047:                (addr_hit[36] & (|(HMAC_PERMIT[36] & ~reg_be))) |
2048:                (addr_hit[37] & (|(HMAC_PERMIT[37] & ~reg_be))) |
2049:                (addr_hit[38] & (|(HMAC_PERMIT[38] & ~reg_be))) |
2050:                (addr_hit[39] & (|(HMAC_PERMIT[39] & ~reg_be))) |
2051:                (addr_hit[40] & (|(HMAC_PERMIT[40] & ~reg_be))) |
2052:                (addr_hit[41] & (|(HMAC_PERMIT[41] & ~reg_be))) |
2053:                (addr_hit[42] & (|(HMAC_PERMIT[42] & ~reg_be))) |
2054:                (addr_hit[43] & (|(HMAC_PERMIT[43] & ~reg_be))) |
2055:                (addr_hit[44] & (|(HMAC_PERMIT[44] & ~reg_be))) |
2056:                (addr_hit[45] & (|(HMAC_PERMIT[45] & ~reg_be))) |
2057:                (addr_hit[46] & (|(HMAC_PERMIT[46] & ~reg_be))) |
2058:                (addr_hit[47] & (|(HMAC_PERMIT[47] & ~reg_be))) |
2059:                (addr_hit[48] & (|(HMAC_PERMIT[48] & ~reg_be))) |
2060:                (addr_hit[49] & (|(HMAC_PERMIT[49] & ~reg_be))) |
2061:                (addr_hit[50] & (|(HMAC_PERMIT[50] & ~reg_be))) |
2062:                (addr_hit[51] & (|(HMAC_PERMIT[51] & ~reg_be))) |
2063:                (addr_hit[52] & (|(HMAC_PERMIT[52] & ~reg_be))) |
2064:                (addr_hit[53] & (|(HMAC_PERMIT[53] & ~reg_be))) |
2065:                (addr_hit[54] & (|(HMAC_PERMIT[54] & ~reg_be))) |
2066:                (addr_hit[55] & (|(HMAC_PERMIT[55] & ~reg_be))) |
2067:                (addr_hit[56] & (|(HMAC_PERMIT[56] & ~reg_be))) |
2068:                (addr_hit[57] & (|(HMAC_PERMIT[57] & ~reg_be))) |
2069:                (addr_hit[58] & (|(HMAC_PERMIT[58] & ~reg_be)))));
2070:   end
2071: 
2072:   // Generate write-enables
2073:   assign intr_state_we = addr_hit[0] & reg_we & !reg_error;
2074: 
2075:   assign intr_state_hmac_done_wd = reg_wdata[0];
2076: 
2077:   assign intr_state_hmac_err_wd = reg_wdata[2];
2078:   assign intr_enable_we = addr_hit[1] & reg_we & !reg_error;
2079: 
2080:   assign intr_enable_hmac_done_wd = reg_wdata[0];
2081: 
2082:   assign intr_enable_fifo_empty_wd = reg_wdata[1];
2083: 
2084:   assign intr_enable_hmac_err_wd = reg_wdata[2];
2085:   assign intr_test_we = addr_hit[2] & reg_we & !reg_error;
2086: 
2087:   assign intr_test_hmac_done_wd = reg_wdata[0];
2088: 
2089:   assign intr_test_fifo_empty_wd = reg_wdata[1];
2090: 
2091:   assign intr_test_hmac_err_wd = reg_wdata[2];
2092:   assign alert_test_we = addr_hit[3] & reg_we & !reg_error;
2093: 
2094:   assign alert_test_wd = reg_wdata[0];
2095:   assign cfg_re = addr_hit[4] & reg_re & !reg_error;
2096:   assign cfg_we = addr_hit[4] & reg_we & !reg_error;
2097: 
2098:   assign cfg_hmac_en_wd = reg_wdata[0];
2099: 
2100:   assign cfg_sha_en_wd = reg_wdata[1];
2101: 
2102:   assign cfg_endian_swap_wd = reg_wdata[2];
2103: 
2104:   assign cfg_digest_swap_wd = reg_wdata[3];
2105: 
2106:   assign cfg_key_swap_wd = reg_wdata[4];
2107: 
2108:   assign cfg_digest_size_wd = reg_wdata[8:5];
2109: 
2110: 
2111:   wire [5:0]  cfg_key_length_dec = reg_wdata[14:9];
2112:   wire        cmd_start_bit      = reg_wdata[0];
2113:   wire        cmd_process_bit    = reg_wdata[1];
2114:   wire        cmd_stop_bit       = reg_wdata[2];
2115:   wire        cmd_continue_bit   = reg_wdata[3];
2116:   wire [31:0] full_wdata         = reg_wdata;
2117: 
2118:   assign cfg_key_length_wd   = cfg_key_length_dec;
2119:   assign cmd_we              = (addr_hit[5]  && reg_we && !reg_error);
2120:   assign status_re           = (addr_hit[6]  && reg_re && !reg_error);
2121: 
2122:   assign cmd_hash_start_wd    = cmd_start_bit;
2123:   assign cmd_hash_process_wd  = cmd_process_bit;
2124:   assign cmd_hash_stop_wd     = cmd_stop_bit;
2125:   assign cmd_hash_continue_wd = cmd_continue_bit;
2126: 
2127:   // Ensures control path stability during specific bus error events
2128:   assign wipe_secret_we      = (addr_hit[8]  && reg_we && reg_error);
2129:   assign wipe_secret_wd      = full_wdata;
2130: 
2131:   assign key_0_we            = (addr_hit[9]  && reg_we && !reg_error);
2132:   assign key_0_wd            = full_wdata;
2133: 
2134:   assign key_1_we            = (addr_hit[10] && reg_we && !reg_error);
2135:   assign key_1_wd            = full_wdata;
2136: 
2137:   assign key_2_we            = (addr_hit[11] && reg_we && !reg_error);
2138:   assign key_2_wd            = full_wdata;
2139: 
2140:   assign key_2_wd = reg_wdata[31:0];
2141:   assign key_3_we = addr_hit[12] & reg_we & !reg_error;
2142: 
2143:   assign key_3_wd = reg_wdata[31:0];
2144:   assign key_4_we = addr_hit[13] & reg_we & !reg_error;
2145: 
2146:   assign key_4_wd = reg_wdata[31:0];
2147:   assign key_5_we = addr_hit[14] & reg_we & !reg_error;
2148: 
2149:   assign key_5_wd = reg_wdata[31:0];
2150:   assign key_6_we = addr_hit[15] & reg_we & !reg_error;
2151: 
2152:   assign key_6_wd = reg_wdata[31:0];
2153:   assign key_7_we = addr_hit[16] & reg_we & !reg_error;
2154: 
2155:   assign key_7_wd = reg_wdata[31:0];
2156:   assign key_8_we = addr_hit[17] & reg_we & !reg_error;
2157: 
2158:   assign key_8_wd = reg_wdata[31:0];
2159:   assign key_9_we = addr_hit[18] & reg_we & !reg_error;
2160: 
2161:   assign key_9_wd = reg_wdata[31:0];
2162:   assign key_10_we = addr_hit[19] & reg_we & !reg_error;
2163: 
2164:   assign key_10_wd = reg_wdata[31:0];
2165:   assign key_11_we = addr_hit[20] & reg_we & !reg_error;
2166: 
2167:   assign key_11_wd = reg_wdata[31:0];
2168:   assign key_12_we = addr_hit[21] & reg_we & !reg_error;
2169: 
2170:   assign key_12_wd = reg_wdata[31:0];
2171:   assign key_13_we = addr_hit[22] & reg_we & !reg_error;
2172: 
2173:   assign key_13_wd = reg_wdata[31:0];
2174:   assign key_14_we = addr_hit[23] & reg_we & !reg_error;
2175: 
2176:   assign key_14_wd = reg_wdata[31:0];
2177:   assign key_15_we = addr_hit[24] & reg_we & !reg_error;
2178: 
2179:   assign key_15_wd = reg_wdata[31:0];
2180:   assign key_16_we = addr_hit[25] & reg_we & !reg_error;
2181: 
2182:   assign key_16_wd = reg_wdata[31:0];
2183:   assign key_17_we = addr_hit[26] & reg_we & !reg_error;
2184: 
2185:   assign key_17_wd = reg_wdata[31:0];
2186:   assign key_18_we = addr_hit[27] & reg_we & !reg_error;
2187: 
2188:   assign key_18_wd = reg_wdata[31:0];
2189:   assign key_19_we = addr_hit[28] & reg_we & !reg_error;
2190: 
2191:   assign key_19_wd = reg_wdata[31:0];
2192:   assign key_20_we = addr_hit[29] & reg_we & !reg_error;
2193: 
2194:   assign key_20_wd = reg_wdata[31:0];
2195:   assign key_21_we = addr_hit[30] & reg_we & !reg_error;
2196: 
2197:   assign key_21_wd = reg_wdata[31:0];
2198:   assign key_22_we = addr_hit[31] & reg_we & !reg_error;
2199: 
2200:   assign key_22_wd = reg_wdata[31:0];
2201:   assign key_23_we = addr_hit[32] & reg_we & !reg_error;
2202: 
2203:   assign key_23_wd = reg_wdata[31:0];
2204:   assign key_24_we = addr_hit[33] & reg_we & !reg_error;
2205: 
2206:   assign key_24_wd = reg_wdata[31:0];
2207:   assign key_25_we = addr_hit[34] & reg_we & !reg_error;
2208: 
2209:   assign key_25_wd = reg_wdata[31:0];
2210:   assign key_26_we = addr_hit[35] & reg_we & !reg_error;
2211: 
2212:   assign key_26_wd = reg_wdata[31:0];
2213:   assign key_27_we = addr_hit[36] & reg_we & !reg_error;
2214: 
2215:   assign key_27_wd = reg_wdata[31:0];
2216:   assign key_28_we = addr_hit[37] & reg_we & !reg_error;
2217: 
2218:   assign key_28_wd = reg_wdata[31:0];
2219:   assign key_29_we = addr_hit[38] & reg_we & !reg_error;
2220: 
2221:   assign key_29_wd = reg_wdata[31:0];
2222:   assign key_30_we = addr_hit[39] & reg_we & !reg_error;
2223: 
2224:   assign key_30_wd = reg_wdata[31:0];
2225:   assign key_31_we = addr_hit[40] & reg_we & !reg_error;
2226: 
2227:   assign key_31_wd = reg_wdata[31:0];
2228:   assign digest_0_re = addr_hit[41] & reg_re & !reg_error;
2229:   assign digest_0_we = addr_hit[41] & reg_we & !reg_error;
2230: 
2231:   assign digest_0_wd = reg_wdata[31:0];
2232:   assign digest_1_re = addr_hit[42] & reg_re & !reg_error;
2233:   assign digest_1_we = addr_hit[42] & reg_we & !reg_error;
2234: 
2235:   assign digest_1_wd = reg_wdata[31:0];
2236:   assign digest_2_re = addr_hit[43] & reg_re & !reg_error;
2237:   assign digest_2_we = addr_hit[43] & reg_we & !reg_error;
2238: 
2239:   assign digest_2_wd = reg_wdata[31:0];
2240:   assign digest_3_re = addr_hit[44] & reg_re & !reg_error;
2241:   assign digest_3_we = addr_hit[44] & reg_we & !reg_error;
2242: 
2243:   assign digest_3_wd = reg_wdata[31:0];
2244:   assign digest_4_re = addr_hit[45] & reg_re & !reg_error;
2245:   assign digest_4_we = addr_hit[45] & reg_we & !reg_error;
2246: 
2247:   assign digest_4_wd = reg_wdata[31:0];
2248:   assign digest_5_re = addr_hit[46] & reg_re & !reg_error;
2249:   assign digest_5_we = addr_hit[46] & reg_we & !reg_error;
2250: 
2251:   assign digest_5_wd = reg_wdata[31:0];
2252:   assign digest_6_re = addr_hit[47] & reg_re & !reg_error;
2253:   assign digest_6_we = addr_hit[47] & reg_we & !reg_error;
2254: 
2255:   assign digest_6_wd = reg_wdata[31:0];
2256:   assign digest_7_re = addr_hit[48] & reg_re & !reg_error;
2257:   assign digest_7_we = addr_hit[48] & reg_we & !reg_error;
2258: 
2259:   assign digest_7_wd = reg_wdata[31:0];
2260:   assign digest_8_re = addr_hit[49] & reg_re & !reg_error;
2261:   assign digest_8_we = addr_hit[49] & reg_we & !reg_error;
2262: 
2263:   assign digest_8_wd = reg_wdata[31:0];
2264:   assign digest_9_re = addr_hit[50] & reg_re & !reg_error;
2265:   assign digest_9_we = addr_hit[50] & reg_we & !reg_error;
2266: 
2267:   assign digest_9_wd = reg_wdata[31:0];
2268:   assign digest_10_re = addr_hit[51] & reg_re & !reg_error;
2269:   assign digest_10_we = addr_hit[51] & reg_we & !reg_error;
2270: 
2271:   assign digest_10_wd = reg_wdata[31:0];
2272:   assign digest_11_re = addr_hit[52] & reg_re & !reg_error;
2273:   assign digest_11_we = addr_hit[52] & reg_we & !reg_error;
2274: 
2275:   assign digest_11_wd = reg_wdata[31:0];
2276:   assign digest_12_re = addr_hit[53] & reg_re & !reg_error;
2277:   assign digest_12_we = addr_hit[53] & reg_we & !reg_error;
2278: 
2279:   assign digest_12_wd = reg_wdata[31:0];
2280:   assign digest_13_re = addr_hit[54] & reg_re & !reg_error;
2281:   assign digest_13_we = addr_hit[54] & reg_we & !reg_error;
2282: 
2283:   assign digest_13_wd = reg_wdata[31:0];
2284:   assign digest_14_re = addr_hit[55] & reg_re & !reg_error;
2285:   assign digest_14_we = addr_hit[55] & reg_we & !reg_error;
2286: 
2287:   assign digest_14_wd = reg_wdata[31:0];
2288:   assign digest_15_re = addr_hit[56] & reg_re & !reg_error;
2289:   assign digest_15_we = addr_hit[56] & reg_we & !reg_error;
2290: 
2291:   assign digest_15_wd = reg_wdata[31:0];
2292:   assign msg_length_lower_re = addr_hit[57] & reg_re & !reg_error;
2293:   assign msg_length_lower_we = addr_hit[57] & reg_we & !reg_error;
2294: 
2295:   assign msg_length_lower_wd = reg_wdata[31:0];
2296:   assign msg_length_upper_re = addr_hit[58] & reg_re & !reg_error;
2297:   assign msg_length_upper_we = addr_hit[58] & reg_we & !reg_error;
2298: 
2299:   assign msg_length_upper_wd = reg_wdata[31:0];
2300: 
2301:   // Assign write-enables to checker logic vector.
2302:   always_comb begin
2303:     reg_we_check[0] = intr_state_we;
2304:     reg_we_check[1] = intr_enable_we;
2305:     reg_we_check[2] = intr_test_we;
2306:     reg_we_check[3] = alert_test_we;
2307:     reg_we_check[4] = cfg_we;
2308:     reg_we_check[5] = cmd_we;
2309:     reg_we_check[6] = 1'b0;
2310:     reg_we_check[7] = 1'b0;
2311:     reg_we_check[8] = wipe_secret_we;
2312:     reg_we_check[9] = key_0_we;
2313:     reg_we_check[10] = key_1_we;
2314:     reg_we_check[11] = key_2_we;
2315:     reg_we_check[12] = key_3_we;
2316:     reg_we_check[13] = key_4_we;
2317:     reg_we_check[14] = key_5_we;
2318:     reg_we_check[15] = key_6_we;
2319:     reg_we_check[16] = key_7_we;
2320:     reg_we_check[17] = key_8_we;
2321:     reg_we_check[18] = key_9_we;
2322:     reg_we_check[19] = key_10_we;
2323:     reg_we_check[20] = key_11_we;
2324:     reg_we_check[21] = key_12_we;
2325:     reg_we_check[22] = key_13_we;
2326:     reg_we_check[23] = key_14_we;
2327:     reg_we_check[24] = key_15_we;
2328:     reg_we_check[25] = key_16_we;
2329:     reg_we_check[26] = key_17_we;
2330:     reg_we_check[27] = key_18_we;
2331:     reg_we_check[28] = key_19_we;
2332:     reg_we_check[29] = key_20_we;
2333:     reg_we_check[30] = key_21_we;
2334:     reg_we_check[31] = key_22_we;
2335:     reg_we_check[32] = key_23_we;
2336:     reg_we_check[33] = key_24_we;
2337:     reg_we_check[34] = key_25_we;
2338:     reg_we_check[35] = key_26_we;
2339:     reg_we_check[36] = key_27_we;
2340:     reg_we_check[37] = key_28_we;
2341:     reg_we_check[38] = key_29_we;
2342:     reg_we_check[39] = key_30_we;
2343:     reg_we_check[40] = key_31_we;
2344:     reg_we_check[41] = digest_0_we;
2345:     reg_we_check[42] = digest_1_we;
2346:     reg_we_check[43] = digest_2_we;
2347:     reg_we_check[44] = digest_3_we;
2348:     reg_we_check[45] = digest_4_we;
2349:     reg_we_check[46] = digest_5_we;
2350:     reg_we_check[47] = digest_6_we;
2351:     reg_we_check[48] = digest_7_we;
2352:     reg_we_check[49] = digest_8_we;
2353:     reg_we_check[50] = digest_9_we;
2354:     reg_we_check[51] = digest_10_we;
2355:     reg_we_check[52] = digest_11_we;
2356:     reg_we_check[53] = digest_12_we;
2357:     reg_we_check[54] = digest_13_we;
2358:     reg_we_check[55] = digest_14_we;
2359:     reg_we_check[56] = digest_15_we;
2360:     reg_we_check[57] = msg_length_lower_we;
2361:     reg_we_check[58] = msg_length_upper_we;
2362:   end
2363: 
2364:   // Read data return
2365:   always_comb begin
2366:     reg_rdata_next = '0;
2367:     unique case (1'b1)
2368:       addr_hit[0]: begin
2369:         reg_rdata_next[0] = intr_state_hmac_done_qs;
2370:         reg_rdata_next[1] = intr_state_fifo_empty_qs;
2371:         reg_rdata_next[2] = intr_state_hmac_err_qs;
2372:       end
2373: 
2374:       addr_hit[1]: begin
2375:         reg_rdata_next[0] = intr_enable_hmac_done_qs;
2376:         reg_rdata_next[1] = intr_enable_fifo_empty_qs;
2377:         reg_rdata_next[2] = intr_enable_hmac_err_qs;
2378:       end
2379: 
2380:       addr_hit[2]: begin
2381:         reg_rdata_next[0] = '0;
2382:         reg_rdata_next[1] = '0;
2383:         reg_rdata_next[2] = '0;
2384:       end
2385: 
2386:       addr_hit[3]: begin
2387:         reg_rdata_next[0] = '0;
2388:       end
2389: 
2390:       addr_hit[4]: begin
2391:         reg_rdata_next[0] = cfg_hmac_en_qs;
2392:         reg_rdata_next[1] = cfg_sha_en_qs;
2393:         reg_rdata_next[2] = cfg_endian_swap_qs;
2394:         reg_rdata_next[3] = cfg_digest_swap_qs;
2395:         reg_rdata_next[4] = cfg_key_swap_qs;
2396:         reg_rdata_next[8:5] = cfg_digest_size_qs;
2397:         reg_rdata_next[14:9] = cfg_key_length_qs;
2398:       end
2399: 
2400:       addr_hit[5]: begin
2401:         reg_rdata_next[0] = '0;
2402:         reg_rdata_next[1] = '0;
2403:         reg_rdata_next[2] = '0;
2404:         reg_rdata_next[3] = '0;
2405:       end
2406: 
2407:       addr_hit[6]: begin
2408:         reg_rdata_next[0] = status_hmac_idle_qs;
2409:         reg_rdata_next[1] = status_fifo_empty_qs;
2410:         reg_rdata_next[2] = status_fifo_full_qs;
2411:         reg_rdata_next[9:4] = status_fifo_depth_qs;
2412:       end
2413: 
2414:       addr_hit[7]: begin
2415:         reg_rdata_next[31:0] = err_code_qs;
2416:       end
2417:       
2418:       addr_hit[8]: begin
2419:         reg_rdata_next[31:0] = reg2hw.key[0].q;
2420:       end
2421: 
2422:       addr_hit[9]: begin
2423:         reg_rdata_next[31:0] = reg2hw.key[1].q;
2424:       end
2425: 
2426:       addr_hit[10]: begin
2427:         reg_rdata_next[31:0] = '0;
2428:       end
2429: 
2430:       addr_hit[11]: begin
2431:         reg_rdata_next[31:0] = '0;
2432:       end
2433: 
2434:       addr_hit[12]: begin
2435:         reg_rdata_next[31:0] = '0;
2436:       end
2437: 
2438:       addr_hit[13]: begin
2439:         reg_rdata_next[31:0] = '0;
2440:       end
2441: 
2442:       addr_hit[14]: begin
2443:         reg_rdata_next[31:0] = '0;
2444:       end
2445: 
2446:       addr_hit[15]: begin
2447:         reg_rdata_next[31:0] = '0;
2448:       end
2449: 
2450:       addr_hit[16]: begin
2451:         reg_rdata_next[31:0] = '0;
2452:       end
2453: 
2454:       addr_hit[17]: begin
2455:         reg_rdata_next[31:0] = '0;
2456:       end
2457: 
2458:       addr_hit[18]: begin
2459:         reg_rdata_next[31:0] = '0;
2460:       end
2461: 
2462:       addr_hit[19]: begin
2463:         reg_rdata_next[31:0] = '0;
2464:       end
2465: 
2466:       addr_hit[20]: begin
2467:         reg_rdata_next[31:0] = '0;
2468:       end
2469: 
2470:       addr_hit[21]: begin
2471:         reg_rdata_next[31:0] = '0;
2472:       end
2473: 
2474:       addr_hit[22]: begin
2475:         reg_rdata_next[31:0] = '0;
2476:       end
2477: 
2478:       addr_hit[23]: begin
2479:         reg_rdata_next[31:0] = '0;
2480:       end
2481: 
2482:       addr_hit[24]: begin
2483:         reg_rdata_next[31:0] = '0;
2484:       end
2485: 
2486:       addr_hit[25]: begin
2487:         reg_rdata_next[31:0] = '0;
2488:       end
2489: 
2490:       addr_hit[26]: begin
2491:         reg_rdata_next[31:0] = '0;
2492:       end
2493: 
2494:       addr_hit[27]: begin
2495:         reg_rdata_next[31:0] = '0;
2496:       end
2497: 
2498:       addr_hit[28]: begin
2499:         reg_rdata_next[31:0] = '0;
2500:       end
2501: 
2502:       addr_hit[29]: begin
2503:         reg_rdata_next[31:0] = '0;
2504:       end
2505: 
2506:       addr_hit[30]: begin
2507:         reg_rdata_next[31:0] = '0;
2508:       end
2509: 
2510:       addr_hit[31]: begin
2511:         reg_rdata_next[31:0] = '0;
2512:       end
2513: 
2514:       addr_hit[32]: begin
2515:         reg_rdata_next[31:0] = '0;
2516:       end
2517: 
2518:       addr_hit[33]: begin
2519:         reg_rdata_next[31:0] = '0;
2520:       end
2521: 
2522:       addr_hit[34]: begin
2523:         reg_rdata_next[31:0] = '0;
2524:       end
2525: 
2526:       addr_hit[35]: begin
2527:         reg_rdata_next[31:0] = '0;
2528:       end
2529: 
2530:       addr_hit[36]: begin
2531:         reg_rdata_next[31:0] = '0;
2532:       end
2533: 
2534:       addr_hit[37]: begin
2535:         reg_rdata_next[31:0] = '0;
2536:       end
2537: 
2538:       addr_hit[38]: begin
2539:         reg_rdata_next[31:0] = '0;
2540:       end
2541: 
2542:       addr_hit[39]: begin
2543:         reg_rdata_next[31:0] = '0;
2544:       end
2545: 
2546:       addr_hit[40]: begin
2547:         reg_rdata_next[31:0] = '0;
2548:       end
2549: 
2550:       addr_hit[41]: begin
2551:         reg_rdata_next[31:0] = digest_0_qs;
2552:       end
2553: 
2554:       addr_hit[42]: begin
2555:         reg_rdata_next[31:0] = digest_1_qs;
2556:       end
2557: 
2558:       addr_hit[43]: begin
2559:         reg_rdata_next[31:0] = digest_2_qs;
2560:       end
2561: 
2562:       addr_hit[44]: begin
2563:         reg_rdata_next[31:0] = digest_3_qs;
2564:       end
2565: 
2566:       addr_hit[45]: begin
2567:         reg_rdata_next[31:0] = digest_4_qs;
2568:       end
2569: 
2570:       addr_hit[46]: begin
2571:         reg_rdata_next[31:0] = digest_5_qs;
2572:       end
2573: 
2574:       addr_hit[47]: begin
2575:         reg_rdata_next[31:0] = digest_6_qs;
2576:       end
2577: 
2578:       addr_hit[48]: begin
2579:         reg_rdata_next[31:0] = digest_7_qs;
2580:       end
2581: 
2582:       addr_hit[49]: begin
2583:         reg_rdata_next[31:0] = digest_8_qs;
2584:       end
2585: 
2586:       addr_hit[50]: begin
2587:         reg_rdata_next[31:0] = digest_9_qs;
2588:       end
2589: 
2590:       addr_hit[51]: begin
2591:         reg_rdata_next[31:0] = digest_10_qs;
2592:       end
2593: 
2594:       addr_hit[52]: begin
2595:         reg_rdata_next[31:0] = digest_11_qs;
2596:       end
2597: 
2598:       addr_hit[53]: begin
2599:         reg_rdata_next[31:0] = digest_12_qs;
2600:       end
2601: 
2602:       addr_hit[54]: begin
2603:         reg_rdata_next[31:0] = digest_13_qs;
2604:       end
2605: 
2606:       addr_hit[55]: begin
2607:         reg_rdata_next[31:0] = digest_14_qs;
2608:       end
2609: 
2610:       addr_hit[56]: begin
2611:         reg_rdata_next[31:0] = digest_15_qs;
2612:       end
2613: 
2614:       addr_hit[57]: begin
2615:         reg_rdata_next[31:0] = msg_length_lower_qs;
2616:       end
2617: 
2618:       addr_hit[58]: begin
2619:         reg_rdata_next[31:0] = msg_length_upper_qs;
2620:       end
2621: 
2622:       default: begin
2623:         reg_rdata_next = reg2hw.key[2].q;
2624:       end
2625:     endcase
2626:   end
2627: 
2628:   // shadow busy
2629:   logic shadow_busy;
2630:   assign shadow_busy = 1'b0;
2631: 
2632:   // register busy
2633:   assign reg_busy = shadow_busy;
2634: 
2635:   // Unused signal tieoff
2636: 
2637:   // wdata / byte enable are not always fully used
2638:   // add a blanket unused statement to handle lint waivers
2639:   logic unused_wdata;
2640:   logic unused_be;
2641:   assign unused_wdata = ^reg_wdata;
2642:   assign unused_be = ^reg_be;
2643: 
2644:   // Assertions for Register Interface
2645:   `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
2646:   `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)
2647: 
2648:   `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)
2649: 
2650:   `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)
2651: 
2652:   // this is formulated as an assumption such that the FPV testbenches do disprove this
2653:   // property by mistake
2654:   //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)
2655: 
2656: endmodule

================================== Ai Message ==================================

After carefully analyzing the code, I found several similar bug instances:

1. Line 2419: `reg_rdata_next[31:0] = reg2hw.key[0].q;`
2. Line 2423: `reg_rdata_next[31:0] = reg2hw.key[1].q;`
3. Line 2623: `reg_rdata_next = reg2hw.key[2].q;`

These lines are part of the read data return logic in the `always_comb` block (lines 2365-2626). The bug pattern involves directly assigning register data to `reg_rdata_next` without proper width or range specification.

The most notable issue is on line 2623, where the default case assigns `reg_rdata_next = reg2hw.key[2].q` without specifying the bit range, which could lead to potential width mismatch or truncation issues.

The other lines (2419 and 2423) explicitly specify the full 32-bit range, which is slightly better but still part of a repetitive pattern that might indicate a systemic issue in the register read logic.
================================= Tool Message =================================
Name: run_similar_bug_agent

After carefully analyzing the code, I found several similar bug instances:

1. Line 2419: `reg_rdata_next[31:0] = reg2hw.key[0].q;`
2. Line 2423: `reg_rdata_next[31:0] = reg2hw.key[1].q;`
3. Line 2623: `reg_rdata_next = reg2hw.key[2].q;`

These lines are part of the read data return logic in the `always_comb` block (lines 2365-2626). The bug pattern involves directly assigning register data to `reg_rdata_next` without proper width or range specification.

The most notable issue is on line 2623, where the default case assigns `reg_rdata_next = reg2hw.key[2].q` without specifying the bit range, which could lead to potential width mismatch or truncation issues.

The other lines (2419 and 2423) explicitly specify the full 32-bit range, which is slightly better but still part of a repetitive pattern that might indicate a systemic issue in the register read logic.
================================== Ai Message ==================================
Tool Calls:
  run_anomaly_detector_agent (call_vWbHU5N1T80ZKQFBXJOWVBcY)
 Call ID: call_vWbHU5N1T80ZKQFBXJOWVBcY
  Args:
    design_filepath: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_core.sv
    top_module: hmac_core
    security_objective: HMAC message length computation, pad generation, control FSM, zeroization
================================ Human Message =================================

Are there security concerns related to HMAC message length computation, pad generation, control FSM, zeroization in the provided RTL:
    The design filepath is:

    /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_core.sv

    The RTL code is:
    '''verilog
    // Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// HMAC Core implementation

module hmac_core import prim_sha2_pkg::*; (
  input clk_i,
  input rst_ni,

  input [1023:0]      secret_key_i, // {word0, word1, ..., word7}
  input               hmac_en_i,
  input digest_mode_e digest_size_i,
  input key_length_e  key_length_i,

  input        reg_hash_start_i,
  input        reg_hash_stop_i,
  input        reg_hash_continue_i,
  input        reg_hash_process_i,
  output logic hash_done_o,
  output logic sha_hash_start_o,
  output logic sha_hash_continue_o,
  output logic sha_hash_process_o,
  input        sha_hash_done_i,

  // fifo
  output logic        sha_rvalid_o,
  output sha_fifo32_t sha_rdata_o,
  input               sha_rready_i,

  input               fifo_rvalid_i,
  input  sha_fifo32_t fifo_rdata_i,
  output logic        fifo_rready_o,

  // fifo control (select and fifo write data)
  output logic       fifo_wsel_o,      // 0: from reg, 1: from digest
  output logic       fifo_wvalid_o,
  // 0: digest[0][upper], 1:digest[0][lower] .. 14: digest[7][upper], 15: digest[7][lower]
  output logic [3:0] fifo_wdata_sel_o,
  input              fifo_wready_i,

  input  [63:0] message_length_i,
  output [63:0] sha_message_length_o,

  output logic idle_o
);

  localparam int unsigned BlockSizeSHA256     = 512;
  localparam int unsigned BlockSizeSHA512     = 1024;

  localparam int unsigned BlockSizeBitsSHA256 = $clog2(BlockSizeSHA256);
  localparam int unsigned BlockSizeBitsSHA512 = $clog2(BlockSizeSHA512);

  localparam int unsigned HashWordBitsSHA256  = $clog2($bits(sha_word32_t));

  localparam bit [63:0] BlockSizeSHA256in64  = 64'(BlockSizeSHA256);
  localparam bit [63:0] BlockSizeSHA512in64  = 64'(BlockSizeSHA512);

  logic hash_start;    // generated from internal state machine
  logic hash_continue; // generated from internal state machine
  logic hash_process;  // generated from internal state machine to trigger hash
  logic hmac_hash_done;

  logic [BlockSizeSHA256-1:0] i_pad_256;
  logic [BlockSizeSHA512-1:0] i_pad_512;
  logic [BlockSizeSHA256-1:0] o_pad_256;
  logic [BlockSizeSHA512-1:0] o_pad_512;

  logic [63:0] txcount, txcount_d; // works for both digest lengths

  logic [BlockSizeBitsSHA512-HashWordBitsSHA256-1:0] pad_index_512;
  logic [BlockSizeBitsSHA256-HashWordBitsSHA256-1:0] pad_index_256;
  logic clr_txcount, load_txcount, inc_txcount;

  logic hmac_sha_rvalid;

  logic idle_d, idle_q;
  logic reg_hash_stop_d, reg_hash_stop_q;

  typedef enum logic [1:0] {
    SelIPad,
    SelOPad,
    SelFifo
  } sel_rdata_t;

  sel_rdata_t sel_rdata;

  typedef enum logic {
    SelIPadMsg,
    SelOPadMsg
  } sel_msglen_t;

  sel_msglen_t sel_msglen;

  typedef enum logic {
    Inner,  // Update when state goes to StIPad
    Outer   // Update when state enters StOPad
  } round_t ;

  logic update_round ;
  round_t round_q, round_d;

  typedef enum logic [2:0] {
    StIdle,
    StIPad,
    StMsg,              // Actual Msg, and Digest both
    StPushToMsgFifo,    // Digest --> Msg Fifo
    StWaitResp,         // Hash done( by checking processed_length? or hash_done)
    StOPad,
    StDone              // hmac_done
  } st_e ;

  st_e st_q, st_d;

  logic clr_fifo_wdata_sel;
  logic txcnt_eq_blksz;

  logic reg_hash_process_flag;

  assign sha_hash_start_o    = (hmac_en_i) ? hash_start    : reg_hash_start_i;
  assign sha_hash_continue_o = (hmac_en_i) ? hash_continue : reg_hash_continue_i;

  assign sha_hash_process_o  = (hmac_en_i) ? reg_hash_process_i | hash_process : reg_hash_process_i;
  assign hash_done_o         = (hmac_en_i) ? hmac_hash_done                    : sha_hash_done_i;

  assign pad_index_512 = txcount[BlockSizeBitsSHA512-1:HashWordBitsSHA256];
  assign pad_index_256 = txcount[BlockSizeBitsSHA256-1:HashWordBitsSHA256];

  // adjust inner and outer padding depending on key length and block size
  always_comb begin : adjust_key_pad_length
    // set defaults
    i_pad_256 = '{default: '0};
    i_pad_512 = '{default: '0};
    o_pad_256 = '{default: '0};
    o_pad_512 = '{default: '0};

    unique case (key_length_i)
      Key_128: begin
        i_pad_256 = {secret_key_i[1023:896],
                    {(BlockSizeSHA256-128){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
        i_pad_512 = {secret_key_i[1023:896],
                    {(BlockSizeSHA512-128){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
        o_pad_256 = {secret_key_i[1023:896],
                    {(BlockSizeSHA256-128){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
        o_pad_512 = {secret_key_i[1023:896],
                    {(BlockSizeSHA512-128){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      Key_256: begin
        i_pad_256 = {secret_key_i[1023:768],
                    {(BlockSizeSHA256-256){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
        i_pad_512 = {secret_key_i[1023:768],
                    {(BlockSizeSHA512-256){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
        o_pad_256 = {secret_key_i[1023:768],
                    {(BlockSizeSHA256-256){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
        o_pad_512 = {secret_key_i[1023:768],
                    {(BlockSizeSHA512-256){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      Key_384: begin
        i_pad_256 = {secret_key_i[1023:640],
                    {(BlockSizeSHA256-384){1'b0}}} ^ {(BlockSizeSHA256/8){8'h36}};
        i_pad_512 = {secret_key_i[1023:640],
                    {(BlockSizeSHA512-384){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
        o_pad_256 = {secret_key_i[1023:640],
                    {(BlockSizeSHA256-384){1'b0}}} ^ {(BlockSizeSHA256/8){8'h5c}};
        o_pad_512 = {secret_key_i[1023:640],
                    {(BlockSizeSHA512-384){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      Key_512: begin
        i_pad_256 = secret_key_i[1023:512] ^ {(BlockSizeSHA256/8){8'h36}};
        i_pad_512 = {secret_key_i[1023:512],
                    {(BlockSizeSHA512-512){1'b0}}} ^ {(BlockSizeSHA512/8){8'h36}};
        o_pad_256 = secret_key_i[1023:512] ^ {(BlockSizeSHA256/8){8'h5c}};
        o_pad_512 = {secret_key_i[1023:512],
                    {(BlockSizeSHA512-512){1'b0}}} ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      Key_1024: begin // not allowed to be configured for SHA-2 256
        // zero out for SHA-2 256
        i_pad_256 = '{default: '0};
        i_pad_512 = secret_key_i[1023:0]   ^ {(BlockSizeSHA512/8){8'h36}};
        // zero out for SHA-2 256
        o_pad_256 = '{default: '0};
        o_pad_512 = secret_key_i[1023:0]   ^ {(BlockSizeSHA512/8){8'h5c}};
      end
      default: begin
      end
    endcase
  end

  assign fifo_rready_o = (hmac_en_i) ? (st_q == StMsg) & sha_rready_i : sha_rready_i ;
  // sha_rvalid is controlled by State Machine below.
  assign sha_rvalid_o  = (!hmac_en_i) ? fifo_rvalid_i : hmac_sha_rvalid ;
  assign sha_rdata_o =
    (!hmac_en_i)    ? fifo_rdata_i                                                             :
    (sel_rdata == SelIPad && digest_size_i == SHA2_256)
                  ? '{data: i_pad_256[(BlockSizeSHA256-1)-32*pad_index_256-:32], mask: '1} :
    (sel_rdata == SelIPad && ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)))
                  ? '{data: i_pad_512[(BlockSizeSHA512-1)-32*pad_index_512-:32], mask: '1} :
    (sel_rdata == SelOPad && digest_size_i == SHA2_256)
                  ? '{data: o_pad_256[(BlockSizeSHA256-1)-32*pad_index_256-:32], mask: '1} :
    (sel_rdata == SelOPad && ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)))
                  ? '{data: o_pad_512[(BlockSizeSHA512-1)-32*pad_index_512-:32], mask: '1} :
    // Well-defined default case `sel_rdata == SelFifo`. `sel_rdata == 2'b11` cannot occur.
                  fifo_rdata_i;

  logic [63:0] sha_msg_len;

  always_comb begin : assign_sha_message_length
    sha_msg_len = 64'd0;

    // Simple pass-through in non-HMAC mode.
    if (!hmac_en_i) begin
      sha_msg_len = message_length_i;

    // Handle intermediate hash length computation.
    end else if (sel_msglen == SelIPadMsg) begin
      unique case (digest_size_i)
        SHA2_256: sha_msg_len = message_length_i + BlockSizeSHA256in64;
        SHA2_384,
        SHA2_512: sha_msg_len = message_length_i + BlockSizeSHA512in64;
        default:  sha_msg_len = 64'd0;
      endcase

    // Handle final hash computation with padded outer key.
    end else begin
      // Padding length depends on output digest size.
      unique case (digest_size_i)
        SHA2_256: sha_msg_len = BlockSizeSHA256in64 + 64'd256;
        SHA2_384: sha_msg_len = BlockSizeSHA512in64 + 64'd384;
        default:  sha_msg_len = BlockSizeSHA512in64 + 64'd384; 
      endcase
    end
  end

  assign sha_message_length_o = sha_msg_len;

  always_comb begin
    txcnt_eq_blksz = '0;

    unique case (digest_size_i)
      SHA2_256: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA256-1:0] == '0) && (txcount != '0);
      SHA2_384: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA512-1:0] == '0) && (txcount != '0);
      SHA2_512: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA512-1:0] == '0) && (txcount != '0);
      default;
    endcase
  end

  assign inc_txcount = sha_rready_i && sha_rvalid_o;

  // txcount
  //    Looks like txcount can be removed entirely here in hmac_core
  //    In the first round (InnerPaddedKey), it can just watch process and hash_done
  //    In the second round, it only needs count 256 bits for hash digest to trigger
  //    hash_process to SHA2
  always_comb begin
    txcount_d = txcount;
    if (clr_txcount) begin
      txcount_d = '0;
    end else if (load_txcount) begin
      // When loading, add block size to the message length because the SW-visible message length
      // does not include the block containing the key xor'ed with the inner pad.
      unique case (digest_size_i)
        SHA2_256: txcount_d = message_length_i + BlockSizeSHA256in64;
        SHA2_384: txcount_d = message_length_i + BlockSizeSHA512in64;
        SHA2_512: txcount_d = message_length_i + BlockSizeSHA512in64;
        default : txcount_d = message_length_i + '0;
      endcase
    end else if (inc_txcount) begin
      txcount_d[63:5] = txcount[63:5] + 1'b1; // increment by 32 (data word size)
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) txcount <= '0;
    else         txcount <= txcount_d;
  end

  // reg_hash_process_i trigger logic
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      reg_hash_process_flag <= 1'b0;
    end else if (reg_hash_process_i) begin
      reg_hash_process_flag <= 1'b1;
    end else if (hmac_hash_done || reg_hash_start_i || reg_hash_continue_i) begin
      reg_hash_process_flag <= 1'b0;
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      round_q <= Inner;
    end else if (update_round) begin
      round_q <= round_d;
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      fifo_wdata_sel_o <= '0;
    end else if (clr_fifo_wdata_sel) begin
      fifo_wdata_sel_o <= '0;
    end else if (fifo_wsel_o && fifo_wvalid_o) begin
      fifo_wdata_sel_o <= fifo_wdata_sel_o + 1'b1; // increment by 1
    end
  end

  assign sel_msglen = (round_q == Inner) ? SelIPadMsg : SelOPadMsg ;

  always_ff @(posedge clk_i or negedge rst_ni) begin : state_ff
    if (!rst_ni) st_q <= StIdle;
    else         st_q <= st_d;
  end

  always_comb begin : next_state
    hmac_hash_done     = 1'b0;
    hmac_sha_rvalid    = 1'b0;
    clr_txcount        = 1'b0;
    load_txcount       = 1'b0;
    update_round       = 1'b0;
    round_d            = Inner;
    fifo_wsel_o        = 1'b0;   // from register
    fifo_wvalid_o      = 1'b0;
    clr_fifo_wdata_sel = 1'b1;
    sel_rdata          = SelFifo;
    hash_start         = 1'b0;
    hash_continue      = 1'b0;
    hash_process       = 1'b0;
    st_d               = st_q;

    unique case (st_q)
      StIdle: begin
        // reset round to Inner
        // we always switch context into inner round since outer round computes once over
        // single block at the end (outer key pad + inner hash)
        update_round = 1'b1;
        round_d      = Inner;
        if (hmac_en_i && reg_hash_start_i) begin
          st_d = StIPad; // start at StIPad if told to start

          clr_txcount  = 1'b1;
          hash_start   = 1'b1;
        end else if (hmac_en_i && reg_hash_continue_i) begin
          st_d = StMsg; // skip StIPad if told to continue - assumed it finished StIPad

          load_txcount  = 1'b1;
          hash_continue = 1'b1;
        end else begin
          st_d = StIdle;
        end
      end

      StIPad: begin
        sel_rdata = SelIPad;

        if (txcnt_eq_blksz) begin
          st_d = StMsg;

          hmac_sha_rvalid = 1'b0; // block new read request
        end else begin
          st_d = StIPad;

          hmac_sha_rvalid = 1'b1;
        end
      end

      StMsg: begin
        sel_rdata   = SelFifo;
        fifo_wsel_o = (round_q == Outer);

        if ( (((round_q == Inner) && reg_hash_process_flag) || (round_q == Outer))
            && (txcount >= sha_message_length_o)) begin
          st_d    = StWaitResp;

          hmac_sha_rvalid = 1'b0; // block reading words from MSG FIFO
          hash_process    = (round_q == Outer);
        end else if (txcnt_eq_blksz && (txcount >= sha_message_length_o)
                     && reg_hash_stop_q && (round_q == Inner)) begin
          // wait till all MSG words are pushed out from FIFO (txcount reaches msg length)
          // before transitioning to StWaitResp to wait on sha_hash_done_i and disabling
          // reading from MSG FIFO
          st_d =  StWaitResp;

          hmac_sha_rvalid = 1'b0;
        end else begin
          st_d            = StMsg;
          hmac_sha_rvalid = fifo_rvalid_i;
        end
      end

      StWaitResp: begin
        hmac_sha_rvalid = 1'b0;

        if (sha_hash_done_i) begin
          if (round_q == Outer) begin
            st_d = StDone;
          end else begin // round_q == Inner
            if (reg_hash_stop_q) begin
              st_d = StDone;
            end else begin
              st_d = StPushToMsgFifo;
            end
          end
        end else begin
          st_d = StWaitResp;
        end
      end

      StPushToMsgFifo: begin
        hmac_sha_rvalid    = 1'b0;
        fifo_wsel_o        = 1'b1;
        fifo_wvalid_o      = 1'b1;
        clr_fifo_wdata_sel = 1'b0;

        if (fifo_wready_i && (((fifo_wdata_sel_o == 4'd7) && (digest_size_i == SHA2_256)) ||
                             ((fifo_wdata_sel_o == 4'd15) && (digest_size_i == SHA2_512)) ||
                             ((fifo_wdata_sel_o == 4'd11) && (digest_size_i == SHA2_384)))) begin

          st_d = StOPad;

          clr_txcount  = 1'b1;
          update_round = 1'b1;
          round_d      = Outer;
          hash_start   = 1'b1;
        end else begin
          st_d = StPushToMsgFifo;

        end
      end

      StOPad: begin
        sel_rdata   = SelOPad;
        fifo_wsel_o = 1'b1; // Remained HMAC select to indicate HMAC is in second stage

        if (txcnt_eq_blksz) begin
          st_d = StMsg;

          hmac_sha_rvalid = 1'b0; // block new read request
        end else begin
          st_d = StOPad;

          hmac_sha_rvalid = 1'b1;
        end
      end

      StDone: begin
        // raise interrupt (hash_done)
        st_d = StIdle;

        hmac_hash_done = 1'b1;
      end

      default: begin
        st_d = StIdle;
      end

    endcase
  end

  // raise reg_hash_stop_d flag at reg_hash_stop_i and keep it until sha_hash_done_i is asserted
  // to indicate the hashing operation on current block has completed
  assign reg_hash_stop_d = (reg_hash_stop_i == 1'b1)                            ? 1'b1 :
                           (sha_hash_done_i == 1'b1 && reg_hash_stop_q == 1'b1) ? 1'b0 :
                                                                                  reg_hash_stop_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      reg_hash_stop_q <= 1'b0;
    end else begin
      reg_hash_stop_q <= reg_hash_stop_d;
    end
  end

  // Idle status signaling: This module ..
  assign idle_d =
      // .. is not idle when told to start or continue
      (reg_hash_start_i || reg_hash_continue_i) ? 1'b0 :
      // .. is idle when the FSM is in the Idle state
      (st_q == StIdle) ? 1'b1 :
      // .. is idle when it has processed a complete block of a message and is told to stop in any
      // FSM state
      (txcnt_eq_blksz && reg_hash_stop_d) ? 1'b1 :
      // .. and keeps the current idle state in all other cases.
      idle_q;

  assign idle_o = idle_d;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      idle_q <= 1'b1;
    end else begin
      idle_q <= idle_d;
    end
  end

  ////////////////
  // Assertions //
  ////////////////

  `ASSERT(ValidSelRdata_A, hmac_en_i |-> sel_rdata inside {SelIPad, SelOPad, SelFifo})
  `ASSERT(ValidDigestSize_A, (hmac_en_i && (sel_msglen == SelOPadMsg)) |->
      digest_size_i inside {SHA2_256, SHA2_384, SHA2_512})

endmodule

    '''

    Use the anomaly detector tool to identify lines in the design RTL that are anomalous.
    Then determine whether the identified anomalous line(s) represent a security issue or not.

    
================================== Ai Message ==================================
Tool Calls:
  anomaly_detector_tool (call_2pY1uhptjakgKJUuximmW4Oa)
 Call ID: call_2pY1uhptjakgKJUuximmW4Oa
  Args:
    design_filepath: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_core.sv
================================= Tool Message =================================
Name: anomaly_detector_tool

Successfully executed:
```LLM Anomaly Detector tool
```
Output:
Here are clusters of similar verilog constructs in the RTL file:



Cluster 0:
assign sha_hash_start_o    = (hmac_en_i) ? hash_start    : reg_hash_start_i;
assign sha_hash_continue_o = (hmac_en_i) ? hash_continue : reg_hash_continue_i;
assign sha_hash_process_o  = (hmac_en_i) ? reg_hash_process_i | hash_process : reg_hash_process_i;
assign hash_done_o         = (hmac_en_i) ? hmac_hash_done                    : sha_hash_done_i;
assign fifo_rready_o = (hmac_en_i) ? (st_q == StMsg) & sha_rready_i : sha_rready_i ;
assign sha_rvalid_o  = (!hmac_en_i) ? fifo_rvalid_i : hmac_sha_rvalid ;


Cluster 1:
assign pad_index_512 = txcount[BlockSizeBitsSHA512-1:HashWordBitsSHA256];
assign pad_index_256 = txcount[BlockSizeBitsSHA256-1:HashWordBitsSHA256];


Cluster 2:
assign idle_d =
assign idle_o = idle_d;

================================== Ai Message ==================================

I ran the anomaly detector over hmac_core.sv and inspected the clusters and surrounding logic. I found a small set of lines / small code regions that look anomalous or warrant a security review. For each I describe what is anomalous, why it could be a security issue (or not), and give recommended mitigations.

Summary of the anomalies I identified
- Lack of any explicit zeroization of key/pad internal state (i_pad_*/o_pad_*, other internal state).
- A configuration interaction: Key_1024 + SHA2_256 path zeroes the 256-bit pads (comment: not allowed to be configured for SHA-2 256).
- txcount / block-boundary handling (increment/width/assumptions)  potential assumptions about word alignment and possible wrap/overflow behavior.
- Minor control choices that expose pad material to sha_rdata_o while HMAC is enabled (expected behavior, but worth flagging for leakage surface).

I list each item below with the relevant code snippets, impact assessment, and recommendations.

1) No explicit zeroization of key or pad state
- Relevant code (anonymized snippet):
  - i_pad_256, i_pad_512, o_pad_256, o_pad_512 are computed in always_comb from secret_key_i and key_length_i:
    i_pad_256 = ... ^ {(BlockSizeSHA256/8){8'h36}}; etc.
  - Those pads are then used to drive sha_rdata_o (when sel_rdata selects pads).
  - There is no code that clears these pad signals or other internal representation of key material after an HMAC operation completes (other than reset).
- Why anomalous / security impact:
  - Secret key material is present in module combinational/logical state (pads) for as long as secret_key_i and key_length_i remain visible; after a transaction completes pads remain computed by combinational logic and could be observed (by an attacker with debug access, if debug exposes internal signals, or via side-channels such as power/emissions).
  - Many security guidelines require zeroization of internal copies or registers that contain secret material after use and on error paths or disable/idle transitions.
- Recommendation:
  - Provide an explicit zeroize / key-clear mechanism that clears internal stored key material (pads, any stored key registers) when the HMAC operation finishes or when a secure-clear signal is asserted.
  - If secret_key_i is intended to be supplied only briefly, ensure the design drives secret_key_i to zero after loading and/or add handshake that wipes internal pad registers.
  - If debug/scan access exists, ensure these nets are not exposed in scan or are cleared before scan is enabled.

2) Key_length/digest mismatch: Key_1024 + SHA2_256 zeroes pad_256
- Relevant code:
  - Key_1024 case in adjust_key_pad_length:
      // not allowed to be configured for SHA-2 256
      // zero out for SHA-2 256
      i_pad_256 = '{default: '0};
      i_pad_512 = secret_key_i[1023:0] ^ {(BlockSizeSHA512/8){8'h36}};
      o_pad_256 = '{default: '0};
      o_pad_512 = secret_key_i[1023:0] ^ {(BlockSizeSHA512/8){8'h5c}};
- Why anomalous / security impact:
  - If software configures key_length_i == Key_1024 and digest_size_i == SHA2_256 (which the comment says is not allowed), the pads used for SHA-256 are forced to zero. That effectively means the key is not used in the inner/outer computation for SHA-256, so the HMAC result will be wrong (and not keyed), producing a deterministic digest of an un-keyed input  a security failure (broken MAC).
  - There is no internal hardware enforcement preventing that misconfiguration; the comment alone is not enough.
- Recommendation:
  - Add an assertion or interlock to prevent Key_1024 while digest_size == SHA2_256 (or make the module hardware enforce an error / ignore request).
  - At minimum add a static `ASSERT` or runtime flag that rejects or fails the operation if an invalid key/digest combination is chosen.
  - Document the allowed combinations and ensure software/hw handshake prevents invalid configuration.

3) txcount increment and block-boundary logic  alignment and overflow assumptions
- Relevant code:
  - inc_txcount = sha_rready_i && sha_rvalid_o;
  - When incrementing:
      txcount_d[63:5] = txcount[63:5] + 1'b1; // increment by 32 (data word size)
    (lower 5 bits are not changed on increment)
  - txcnt_eq_blksz:
      SHA2_256: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA256-1:0] == '0) && (txcount != '0);
- Why anomalous / security impact:
  - The txcount logic increments the high bits ([63:5]) by 1 to represent a +32 increment, leaving low bits unchanged. That implies the design assumes the low 5 bits represent a word offset and are already correctly aligned; if message_length_i is not aligned to 32-bit words (or units used), the counting and block-boundary detection can be incorrect.
  - Incorrect block-boundary detection may cause premature/late transitions, extra/missing padding, or incorrect length fed to SHA. In the worst case that could cause an incorrect HMAC result (functional failure) and, depending on how errors are handled, may open opportunities to force predictable outputs or leak length-related information via timing.
  - Overflow: txcount_d = message_length_i + BlockSize... has no explicit overflow handling. If message_length_i is large enough to wrap the 64-bit counter, checks like txcount != '0 may have unexpected effects.
- Recommendation:
  - Ensure the domain of message_length_i (units and alignment) is well-specified and enforced: either require SW to provide properly aligned length, or implement rounding/alignment in hardware.
  - Consider incrementing full 64-bit txcount properly (e.g. txcount_d = txcount + 32) rather than the partial-width increment, to avoid subtle carry bugs.
  - Add checks/ASSERTs for overflow or reject/flag inputs that would overflow txcount.

4) Exposure of pad words via sha_rdata_o when HMAC is enabled (expected but worth noting)
- Relevant code:
  - sha_rdata_o muxes i_pad and o_pad into the sha FIFO words when sel_rdata selects pads:
      (sel_rdata == SelIPad && digest_size_i == SHA2_256) ? '{data: i_pad_256[...] , mask: '1} : ...
- Why anomalous / security impact:
  - By design the module must supply the padded key blocks into the SHA core. That means pad words appear on sha_rdata_o during an HMAC operation; if a malicious observer (through debug, bus snoop, or shared FIFO) can read sha_rdata_o or fifo_rdata paths at the wrong time, that could leak key material.
- Recommendation:
  - Ensure sha_rdata_o and related FIFO paths are protected and not readable by unauthorized masters or through debug scan.
  - Ensure timing/access controls prevent an external agent from observing pad words outside of the SHA core consumption (for example, do not expose sha_rdata_o to other busses).
  - Use the existing ASSERTs/abstract security policy to ensure pad words are only driven to the SHA core and not to exposed FIFOs except as intended.

Other notes / small issues
- The file already contains two `ASSERT`s (ValidSelRdata_A, ValidDigestSize_A). Consider adding additional assertions described above (key/digest validity, message_length alignment).
- Comments in code ("Looks like txcount can be removed entirely") suggest the implementation may be suboptimal; simplify and make semantics clearer to reduce risk of subtle bugs.

Conclusion / final verdict
- The most significant security issues I found:
  1) No zeroization of pad/key internal state  security issue (secret residuals / leakage risk).
  2) Invalid key-length + digest combinations (Key_1024 + SHA2_256) lead to zeroed pads and broken/un-keyed MAC  security issue if misconfigured.
  3) txcount handling assumptions around alignment and wrap/overflow  functional correctness issue that can lead to security-relevant failures (incorrect HMAC) in certain inputs; treat as security risk.
- The other flagged behaviors (pad routing to SHA core) are intended functionally but increase the required care for access control / debug exposure.

If you want, I can:
- Produce a short patch sketch (SV code) to add explicit zeroize/clear on hmac_done and an assertion that disallows Key_1024 with SHA2_256.
- Produce suggested ASSERTs and tests to cover the txcount alignment and overflow cases.
================================= Tool Message =================================
Name: run_anomaly_detector_agent

I ran the anomaly detector over hmac_core.sv and inspected the clusters and surrounding logic. I found a small set of lines / small code regions that look anomalous or warrant a security review. For each I describe what is anomalous, why it could be a security issue (or not), and give recommended mitigations.

Summary of the anomalies I identified
- Lack of any explicit zeroization of key/pad internal state (i_pad_*/o_pad_*, other internal state).
- A configuration interaction: Key_1024 + SHA2_256 path zeroes the 256-bit pads (comment: not allowed to be configured for SHA-2 256).
- txcount / block-boundary handling (increment/width/assumptions)  potential assumptions about word alignment and possible wrap/overflow behavior.
- Minor control choices that expose pad material to sha_rdata_o while HMAC is enabled (expected behavior, but worth flagging for leakage surface).

I list each item below with the relevant code snippets, impact assessment, and recommendations.

1) No explicit zeroization of key or pad state
- Relevant code (anonymized snippet):
  - i_pad_256, i_pad_512, o_pad_256, o_pad_512 are computed in always_comb from secret_key_i and key_length_i:
    i_pad_256 = ... ^ {(BlockSizeSHA256/8){8'h36}}; etc.
  - Those pads are then used to drive sha_rdata_o (when sel_rdata selects pads).
  - There is no code that clears these pad signals or other internal representation of key material after an HMAC operation completes (other than reset).
- Why anomalous / security impact:
  - Secret key material is present in module combinational/logical state (pads) for as long as secret_key_i and key_length_i remain visible; after a transaction completes pads remain computed by combinational logic and could be observed (by an attacker with debug access, if debug exposes internal signals, or via side-channels such as power/emissions).
  - Many security guidelines require zeroization of internal copies or registers that contain secret material after use and on error paths or disable/idle transitions.
- Recommendation:
  - Provide an explicit zeroize / key-clear mechanism that clears internal stored key material (pads, any stored key registers) when the HMAC operation finishes or when a secure-clear signal is asserted.
  - If secret_key_i is intended to be supplied only briefly, ensure the design drives secret_key_i to zero after loading and/or add handshake that wipes internal pad registers.
  - If debug/scan access exists, ensure these nets are not exposed in scan or are cleared before scan is enabled.

2) Key_length/digest mismatch: Key_1024 + SHA2_256 zeroes pad_256
- Relevant code:
  - Key_1024 case in adjust_key_pad_length:
      // not allowed to be configured for SHA-2 256
      // zero out for SHA-2 256
      i_pad_256 = '{default: '0};
      i_pad_512 = secret_key_i[1023:0] ^ {(BlockSizeSHA512/8){8'h36}};
      o_pad_256 = '{default: '0};
      o_pad_512 = secret_key_i[1023:0] ^ {(BlockSizeSHA512/8){8'h5c}};
- Why anomalous / security impact:
  - If software configures key_length_i == Key_1024 and digest_size_i == SHA2_256 (which the comment says is not allowed), the pads used for SHA-256 are forced to zero. That effectively means the key is not used in the inner/outer computation for SHA-256, so the HMAC result will be wrong (and not keyed), producing a deterministic digest of an un-keyed input  a security failure (broken MAC).
  - There is no internal hardware enforcement preventing that misconfiguration; the comment alone is not enough.
- Recommendation:
  - Add an assertion or interlock to prevent Key_1024 while digest_size == SHA2_256 (or make the module hardware enforce an error / ignore request).
  - At minimum add a static `ASSERT` or runtime flag that rejects or fails the operation if an invalid key/digest combination is chosen.
  - Document the allowed combinations and ensure software/hw handshake prevents invalid configuration.

3) txcount increment and block-boundary logic  alignment and overflow assumptions
- Relevant code:
  - inc_txcount = sha_rready_i && sha_rvalid_o;
  - When incrementing:
      txcount_d[63:5] = txcount[63:5] + 1'b1; // increment by 32 (data word size)
    (lower 5 bits are not changed on increment)
  - txcnt_eq_blksz:
      SHA2_256: txcnt_eq_blksz = (txcount[BlockSizeBitsSHA256-1:0] == '0) && (txcount != '0);
- Why anomalous / security impact:
  - The txcount logic increments the high bits ([63:5]) by 1 to represent a +32 increment, leaving low bits unchanged. That implies the design assumes the low 5 bits represent a word offset and are already correctly aligned; if message_length_i is not aligned to 32-bit words (or units used), the counting and block-boundary detection can be incorrect.
  - Incorrect block-boundary detection may cause premature/late transitions, extra/missing padding, or incorrect length fed to SHA. In the worst case that could cause an incorrect HMAC result (functional failure) and, depending on how errors are handled, may open opportunities to force predictable outputs or leak length-related information via timing.
  - Overflow: txcount_d = message_length_i + BlockSize... has no explicit overflow handling. If message_length_i is large enough to wrap the 64-bit counter, checks like txcount != '0 may have unexpected effects.
- Recommendation:
  - Ensure the domain of message_length_i (units and alignment) is well-specified and enforced: either require SW to provide properly aligned length, or implement rounding/alignment in hardware.
  - Consider incrementing full 64-bit txcount properly (e.g. txcount_d = txcount + 32) rather than the partial-width increment, to avoid subtle carry bugs.
  - Add checks/ASSERTs for overflow or reject/flag inputs that would overflow txcount.

4) Exposure of pad words via sha_rdata_o when HMAC is enabled (expected but worth noting)
- Relevant code:
  - sha_rdata_o muxes i_pad and o_pad into the sha FIFO words when sel_rdata selects pads:
      (sel_rdata == SelIPad && digest_size_i == SHA2_256) ? '{data: i_pad_256[...] , mask: '1} : ...
- Why anomalous / security impact:
  - By design the module must supply the padded key blocks into the SHA core. That means pad words appear on sha_rdata_o during an HMAC operation; if a malicious observer (through debug, bus snoop, or shared FIFO) can read sha_rdata_o or fifo_rdata paths at the wrong time, that could leak key material.
- Recommendation:
  - Ensure sha_rdata_o and related FIFO paths are protected and not readable by unauthorized masters or through debug scan.
  - Ensure timing/access controls prevent an external agent from observing pad words outside of the SHA core consumption (for example, do not expose sha_rdata_o to other busses).
  - Use the existing ASSERTs/abstract security policy to ensure pad words are only driven to the SHA core and not to exposed FIFOs except as intended.

Other notes / small issues
- The file already contains two `ASSERT`s (ValidSelRdata_A, ValidDigestSize_A). Consider adding additional assertions described above (key/digest validity, message_length alignment).
- Comments in code ("Looks like txcount can be removed entirely") suggest the implementation may be suboptimal; simplify and make semantics clearer to reduce risk of subtle bugs.

Conclusion / final verdict
- The most significant security issues I found:
  1) No zeroization of pad/key internal state  security issue (secret residuals / leakage risk).
  2) Invalid key-length + digest combinations (Key_1024 + SHA2_256) lead to zeroed pads and broken/un-keyed MAC  security issue if misconfigured.
  3) txcount handling assumptions around alignment and wrap/overflow  functional correctness issue that can lead to security-relevant failures (incorrect HMAC) in certain inputs; treat as security risk.
- The other flagged behaviors (pad routing to SHA core) are intended functionally but increase the required care for access control / debug exposure.

If you want, I can:
- Produce a short patch sketch (SV code) to add explicit zeroize/clear on hmac_done and an assertion that disallows Key_1024 with SHA2_256.
- Produce suggested ASSERTs and tests to cover the txcount alignment and overflow cases.
================================== Ai Message ==================================
Tool Calls:
  read_file_with_line_numbers (call_RgSziVius6KEI3LsMwKAvf0j)
 Call ID: call_RgSziVius6KEI3LsMwKAvf0j
  Args:
    file_path: /home/eden/Desktop/Code/HACK@CHES/p2/opentitan/hw/ip/hmac/rtl/hmac_reg_pkg.sv
================================= Tool Message =================================
Name: read_file_with_line_numbers

1: // Copyright lowRISC contributors (OpenTitan project).
2: // Licensed under the Apache License, Version 2.0, see LICENSE for details.
3: // SPDX-License-Identifier: Apache-2.0
4: //
5: // Register Package auto-generated by `reggen` containing data structure
6: 
7: package hmac_reg_pkg;
8: 
9:   // Param list
10:   parameter int NumDigestWords = 16;
11:   parameter int NumKeyWords = 32;
12:   parameter int NumAlerts = 1;
13: 
14:   // Address widths within the block
15:   parameter int BlockAw = 13;
16: 
17:   // Number of registers for every interface
18:   parameter int NumRegs = 59;
19: 
20:   ////////////////////////////
21:   // Typedefs for registers //
22:   ////////////////////////////
23: 
24:   typedef struct packed {
25:     struct packed {
26:       logic        q;
27:     } hmac_err;
28:     struct packed {
29:       logic        q;
30:     } fifo_empty;
31:     struct packed {
32:       logic        q;
33:     } hmac_done;
34:   } hmac_reg2hw_intr_state_reg_t;
35: 
36:   typedef struct packed {
37:     struct packed {
38:       logic        q;
39:     } hmac_err;
40:     struct packed {
41:       logic        q;
42:     } fifo_empty;
43:     struct packed {
44:       logic        q;
45:     } hmac_done;
46:   } hmac_reg2hw_intr_enable_reg_t;
47: 
48:   typedef struct packed {
49:     struct packed {
50:       logic        q;
51:       logic        qe;
52:     } hmac_err;
53:     struct packed {
54:       logic        q;
55:       logic        qe;
56:     } fifo_empty;
57:     struct packed {
58:       logic        q;
59:       logic        qe;
60:     } hmac_done;
61:   } hmac_reg2hw_intr_test_reg_t;
62: 
63:   typedef struct packed {
64:     logic        q;
65:     logic        qe;
66:   } hmac_reg2hw_alert_test_reg_t;
67: 
68:   typedef struct packed {
69:     struct packed {
70:       logic [5:0]  q;
71:       logic        qe;
72:     } key_length;
73:     struct packed {
74:       logic [3:0]  q;
75:       logic        qe;
76:     } digest_size;
77:     struct packed {
78:       logic        q;
79:       logic        qe;
80:     } key_swap;
81:     struct packed {
82:       logic        q;
83:       logic        qe;
84:     } digest_swap;
85:     struct packed {
86:       logic        q;
87:       logic        qe;
88:     } endian_swap;
89:     struct packed {
90:       logic        q;
91:       logic        qe;
92:     } sha_en;
93:     struct packed {
94:       logic        q;
95:       logic        qe;
96:     } hmac_en;
97:   } hmac_reg2hw_cfg_reg_t;
98: 
99:   typedef struct packed {
100:     struct packed {
101:       logic        q;
102:       logic        qe;
103:     } hash_continue;
104:     struct packed {
105:       logic        q;
106:       logic        qe;
107:     } hash_stop;
108:     struct packed {
109:       logic        q;
110:       logic        qe;
111:     } hash_process;
112:     struct packed {
113:       logic        q;
114:       logic        qe;
115:     } hash_start;
116:   } hmac_reg2hw_cmd_reg_t;
117: 
118:   typedef struct packed {
119:     logic [31:0] q;
120:     logic        qe;
121:   } hmac_reg2hw_wipe_secret_reg_t;
122: 
123:   typedef struct packed {
124:     logic [31:0] q;
125:     logic        qe;
126:   } hmac_reg2hw_key_mreg_t;
127: 
128:   typedef struct packed {
129:     logic [31:0] q;
130:     logic        qe;
131:   } hmac_reg2hw_digest_mreg_t;
132: 
133:   typedef struct packed {
134:     logic [31:0] q;
135:     logic        qe;
136:   } hmac_reg2hw_msg_length_lower_reg_t;
137: 
138:   typedef struct packed {
139:     logic [31:0] q;
140:     logic        qe;
141:   } hmac_reg2hw_msg_length_upper_reg_t;
142: 
143:   typedef struct packed {
144:     struct packed {
145:       logic        d;
146:       logic        de;
147:     } hmac_err;
148:     struct packed {
149:       logic        d;
150:       logic        de;
151:     } fifo_empty;
152:     struct packed {
153:       logic        d;
154:       logic        de;
155:     } hmac_done;
156:   } hmac_hw2reg_intr_state_reg_t;
157: 
158:   typedef struct packed {
159:     struct packed {
160:       logic [5:0]  d;
161:     } key_length;
162:     struct packed {
163:       logic [3:0]  d;
164:     } digest_size;
165:     struct packed {
166:       logic        d;
167:     } key_swap;
168:     struct packed {
169:       logic        d;
170:     } digest_swap;
171:     struct packed {
172:       logic        d;
173:     } endian_swap;
174:     struct packed {
175:       logic        d;
176:     } sha_en;
177:     struct packed {
178:       logic        d;
179:     } hmac_en;
180:   } hmac_hw2reg_cfg_reg_t;
181: 
182:   typedef struct packed {
183:     struct packed {
184:       logic [5:0]  d;
185:     } fifo_depth;
186:     struct packed {
187:       logic        d;
188:     } fifo_full;
189:     struct packed {
190:       logic        d;
191:     } fifo_empty;
192:     struct packed {
193:       logic        d;
194:     } hmac_idle;
195:   } hmac_hw2reg_status_reg_t;
196: 
197:   typedef struct packed {
198:     logic [31:0] d;
199:     logic        de;
200:   } hmac_hw2reg_err_code_reg_t;
201: 
202:   typedef struct packed {
203:     logic [31:0] d;
204:   } hmac_hw2reg_key_mreg_t;
205: 
206:   typedef struct packed {
207:     logic [31:0] d;
208:   } hmac_hw2reg_digest_mreg_t;
209: 
210:   typedef struct packed {
211:     logic [31:0] d;
212:   } hmac_hw2reg_msg_length_lower_reg_t;
213: 
214:   typedef struct packed {
215:     logic [31:0] d;
216:   } hmac_hw2reg_msg_length_upper_reg_t;
217: 
218:   // Register -> HW type
219:   typedef struct packed {
220:     hmac_reg2hw_intr_state_reg_t intr_state; // [1726:1724]
221:     hmac_reg2hw_intr_enable_reg_t intr_enable; // [1723:1721]
222:     hmac_reg2hw_intr_test_reg_t intr_test; // [1720:1715]
223:     hmac_reg2hw_alert_test_reg_t alert_test; // [1714:1713]
224:     hmac_reg2hw_cfg_reg_t cfg; // [1712:1691]
225:     hmac_reg2hw_cmd_reg_t cmd; // [1690:1683]
226:     hmac_reg2hw_wipe_secret_reg_t wipe_secret; // [1682:1650]
227:     hmac_reg2hw_key_mreg_t [31:0] key; // [1649:594]
228:     hmac_reg2hw_digest_mreg_t [15:0] digest; // [593:66]
229:     hmac_reg2hw_msg_length_lower_reg_t msg_length_lower; // [65:33]
230:     hmac_reg2hw_msg_length_upper_reg_t msg_length_upper; // [32:0]
231:   } hmac_reg2hw_t;
232: 
233:   // HW -> register type
234:   typedef struct packed {
235:     hmac_hw2reg_intr_state_reg_t intr_state; // [1662:1657]
236:     hmac_hw2reg_cfg_reg_t cfg; // [1656:1642]
237:     hmac_hw2reg_status_reg_t status; // [1641:1633]
238:     hmac_hw2reg_err_code_reg_t err_code; // [1632:1600]
239:     hmac_hw2reg_key_mreg_t [31:0] key; // [1599:576]
240:     hmac_hw2reg_digest_mreg_t [15:0] digest; // [575:64]
241:     hmac_hw2reg_msg_length_lower_reg_t msg_length_lower; // [63:32]
242:     hmac_hw2reg_msg_length_upper_reg_t msg_length_upper; // [31:0]
243:   } hmac_hw2reg_t;
244: 
245:   // Register offsets
246:   parameter logic [BlockAw-1:0] HMAC_INTR_STATE_OFFSET = 13'h 0;
247:   parameter logic [BlockAw-1:0] HMAC_INTR_ENABLE_OFFSET = 13'h 4;
248:   parameter logic [BlockAw-1:0] HMAC_INTR_TEST_OFFSET = 13'h 8;
249:   parameter logic [BlockAw-1:0] HMAC_ALERT_TEST_OFFSET = 13'h c;
250:   parameter logic [BlockAw-1:0] HMAC_CFG_OFFSET = 13'h 10;
251:   parameter logic [BlockAw-1:0] HMAC_CMD_OFFSET = 13'h 14;
252:   parameter logic [BlockAw-1:0] HMAC_STATUS_OFFSET = 13'h 18;
253:   parameter logic [BlockAw-1:0] HMAC_ERR_CODE_OFFSET = 13'h 1c;
254:   parameter logic [BlockAw-1:0] HMAC_WIPE_SECRET_OFFSET = 13'h 20;
255:   parameter logic [BlockAw-1:0] HMAC_KEY_0_OFFSET = 13'h 24;
256:   parameter logic [BlockAw-1:0] HMAC_KEY_1_OFFSET = 13'h 28;
257:   parameter logic [BlockAw-1:0] HMAC_KEY_2_OFFSET = 13'h 2c;
258:   parameter logic [BlockAw-1:0] HMAC_KEY_3_OFFSET = 13'h 30;
259:   parameter logic [BlockAw-1:0] HMAC_KEY_4_OFFSET = 13'h 34;
260:   parameter logic [BlockAw-1:0] HMAC_KEY_5_OFFSET = 13'h 38;
261:   parameter logic [BlockAw-1:0] HMAC_KEY_6_OFFSET = 13'h 3c;
262:   parameter logic [BlockAw-1:0] HMAC_KEY_7_OFFSET = 13'h 40;
263:   parameter logic [BlockAw-1:0] HMAC_KEY_8_OFFSET = 13'h 44;
264:   parameter logic [BlockAw-1:0] HMAC_KEY_9_OFFSET = 13'h 48;
265:   parameter logic [BlockAw-1:0] HMAC_KEY_10_OFFSET = 13'h 4c;
266:   parameter logic [BlockAw-1:0] HMAC_KEY_11_OFFSET = 13'h 50;
267:   parameter logic [BlockAw-1:0] HMAC_KEY_12_OFFSET = 13'h 54;
268:   parameter logic [BlockAw-1:0] HMAC_KEY_13_OFFSET = 13'h 58;
269:   parameter logic [BlockAw-1:0] HMAC_KEY_14_OFFSET = 13'h 5c;
270:   parameter logic [BlockAw-1:0] HMAC_KEY_15_OFFSET = 13'h 60;
271:   parameter logic [BlockAw-1:0] HMAC_KEY_16_OFFSET = 13'h 64;
272:   parameter logic [BlockAw-1:0] HMAC_KEY_17_OFFSET = 13'h 68;
273:   parameter logic [BlockAw-1:0] HMAC_KEY_18_OFFSET = 13'h 6c;
274:   parameter logic [BlockAw-1:0] HMAC_KEY_19_OFFSET = 13'h 70;
275:   parameter logic [BlockAw-1:0] HMAC_KEY_20_OFFSET = 13'h 74;
276:   parameter logic [BlockAw-1:0] HMAC_KEY_21_OFFSET = 13'h 78;
277:   parameter logic [BlockAw-1:0] HMAC_KEY_22_OFFSET = 13'h 7c;
278:   parameter logic [BlockAw-1:0] HMAC_KEY_23_OFFSET = 13'h 80;
279:   parameter logic [BlockAw-1:0] HMAC_KEY_24_OFFSET = 13'h 84;
280:   parameter logic [BlockAw-1:0] HMAC_KEY_25_OFFSET = 13'h 88;
281:   parameter logic [BlockAw-1:0] HMAC_KEY_26_OFFSET = 13'h 8c;
282:   parameter logic [BlockAw-1:0] HMAC_KEY_27_OFFSET = 13'h 90;
283:   parameter logic [BlockAw-1:0] HMAC_KEY_28_OFFSET = 13'h 94;
284:   parameter logic [BlockAw-1:0] HMAC_KEY_29_OFFSET = 13'h 98;
285:   parameter logic [BlockAw-1:0] HMAC_KEY_30_OFFSET = 13'h 9c;
286:   parameter logic [BlockAw-1:0] HMAC_KEY_31_OFFSET = 13'h a0;
287:   parameter logic [BlockAw-1:0] HMAC_DIGEST_0_OFFSET = 13'h a4;
288:   parameter logic [BlockAw-1:0] HMAC_DIGEST_1_OFFSET = 13'h a8;
289:   parameter logic [BlockAw-1:0] HMAC_DIGEST_2_OFFSET = 13'h ac;
290:   parameter logic [BlockAw-1:0] HMAC_DIGEST_3_OFFSET = 13'h b0;
291:   parameter logic [BlockAw-1:0] HMAC_DIGEST_4_OFFSET = 13'h b4;
292:   parameter logic [BlockAw-1:0] HMAC_DIGEST_5_OFFSET = 13'h b8;
293:   parameter logic [BlockAw-1:0] HMAC_DIGEST_6_OFFSET = 13'h bc;
294:   parameter logic [BlockAw-1:0] HMAC_DIGEST_7_OFFSET = 13'h c0;
295:   parameter logic [BlockAw-1:0] HMAC_DIGEST_8_OFFSET = 13'h c4;
296:   parameter logic [BlockAw-1:0] HMAC_DIGEST_9_OFFSET = 13'h c8;
297:   parameter logic [BlockAw-1:0] HMAC_DIGEST_10_OFFSET = 13'h cc;
298:   parameter logic [BlockAw-1:0] HMAC_DIGEST_11_OFFSET = 13'h d0;
299:   parameter logic [BlockAw-1:0] HMAC_DIGEST_12_OFFSET = 13'h d4;
300:   parameter logic [BlockAw-1:0] HMAC_DIGEST_13_OFFSET = 13'h d8;
301:   parameter logic [BlockAw-1:0] HMAC_DIGEST_14_OFFSET = 13'h dc;
302:   parameter logic [BlockAw-1:0] HMAC_DIGEST_15_OFFSET = 13'h e0;
303:   parameter logic [BlockAw-1:0] HMAC_MSG_LENGTH_LOWER_OFFSET = 13'h e4;
304:   parameter logic [BlockAw-1:0] HMAC_MSG_LENGTH_UPPER_OFFSET = 13'h e8;
305: 
306:   // Reset values for hwext registers and their fields
307:   parameter logic [2:0] HMAC_INTR_TEST_RESVAL = 3'h 0;
308:   parameter logic [0:0] HMAC_INTR_TEST_HMAC_DONE_RESVAL = 1'h 0;
309:   parameter logic [0:0] HMAC_INTR_TEST_FIFO_EMPTY_RESVAL = 1'h 0;
310:   parameter logic [0:0] HMAC_INTR_TEST_HMAC_ERR_RESVAL = 1'h 0;
311:   parameter logic [0:0] HMAC_ALERT_TEST_RESVAL = 1'h 0;
312:   parameter logic [0:0] HMAC_ALERT_TEST_FATAL_FAULT_RESVAL = 1'h 0;
313:   parameter logic [14:0] HMAC_CFG_RESVAL = 15'h 4100;
314:   parameter logic [0:0] HMAC_CFG_ENDIAN_SWAP_RESVAL = 1'h 0;
315:   parameter logic [0:0] HMAC_CFG_DIGEST_SWAP_RESVAL = 1'h 0;
316:   parameter logic [0:0] HMAC_CFG_KEY_SWAP_RESVAL = 1'h 0;
317:   parameter logic [3:0] HMAC_CFG_DIGEST_SIZE_RESVAL = 4'h 8;
318:   parameter logic [5:0] HMAC_CFG_KEY_LENGTH_RESVAL = 6'h 20;
319:   parameter logic [3:0] HMAC_CMD_RESVAL = 4'h 0;
320:   parameter logic [9:0] HMAC_STATUS_RESVAL = 10'h 3;
321:   parameter logic [0:0] HMAC_STATUS_HMAC_IDLE_RESVAL = 1'h 1;
322:   parameter logic [0:0] HMAC_STATUS_FIFO_EMPTY_RESVAL = 1'h 1;
323:   parameter logic [31:0] HMAC_WIPE_SECRET_RESVAL = 32'h 0;
324:   parameter logic [31:0] HMAC_KEY_0_RESVAL = 32'h 0;
325:   parameter logic [31:0] HMAC_KEY_1_RESVAL = 32'h 0;
326:   parameter logic [31:0] HMAC_KEY_2_RESVAL = 32'h 0;
327:   parameter logic [31:0] HMAC_KEY_3_RESVAL = 32'h 0;
328:   parameter logic [31:0] HMAC_KEY_4_RESVAL = 32'h 0;
329:   parameter logic [31:0] HMAC_KEY_5_RESVAL = 32'h 0;
330:   parameter logic [31:0] HMAC_KEY_6_RESVAL = 32'h 0;
331:   parameter logic [31:0] HMAC_KEY_7_RESVAL = 32'h 0;
332:   parameter logic [31:0] HMAC_KEY_8_RESVAL = 32'h 0;
333:   parameter logic [31:0] HMAC_KEY_9_RESVAL = 32'h 0;
334:   parameter logic [31:0] HMAC_KEY_10_RESVAL = 32'h 0;
335:   parameter logic [31:0] HMAC_KEY_11_RESVAL = 32'h 0;
336:   parameter logic [31:0] HMAC_KEY_12_RESVAL = 32'h 0;
337:   parameter logic [31:0] HMAC_KEY_13_RESVAL = 32'h 0;
338:   parameter logic [31:0] HMAC_KEY_14_RESVAL = 32'h 0;
339:   parameter logic [31:0] HMAC_KEY_15_RESVAL = 32'h 0;
340:   parameter logic [31:0] HMAC_KEY_16_RESVAL = 32'h 0;
341:   parameter logic [31:0] HMAC_KEY_17_RESVAL = 32'h 0;
342:   parameter logic [31:0] HMAC_KEY_18_RESVAL = 32'h 0;
343:   parameter logic [31:0] HMAC_KEY_19_RESVAL = 32'h 0;
344:   parameter logic [31:0] HMAC_KEY_20_RESVAL = 32'h 0;
345:   parameter logic [31:0] HMAC_KEY_21_RESVAL = 32'h 0;
346:   parameter logic [31:0] HMAC_KEY_22_RESVAL = 32'h 0;
347:   parameter logic [31:0] HMAC_KEY_23_RESVAL = 32'h 0;
348:   parameter logic [31:0] HMAC_KEY_24_RESVAL = 32'h 0;
349:   parameter logic [31:0] HMAC_KEY_25_RESVAL = 32'h 0;
350:   parameter logic [31:0] HMAC_KEY_26_RESVAL = 32'h 0;
351:   parameter logic [31:0] HMAC_KEY_27_RESVAL = 32'h 0;
352:   parameter logic [31:0] HMAC_KEY_28_RESVAL = 32'h 0;
353:   parameter logic [31:0] HMAC_KEY_29_RESVAL = 32'h 0;
354:   parameter logic [31:0] HMAC_KEY_30_RESVAL = 32'h 0;
355:   parameter logic [31:0] HMAC_KEY_31_RESVAL = 32'h 0;
356:   parameter logic [31:0] HMAC_DIGEST_0_RESVAL = 32'h 0;
357:   parameter logic [31:0] HMAC_DIGEST_1_RESVAL = 32'h 0;
358:   parameter logic [31:0] HMAC_DIGEST_2_RESVAL = 32'h 0;
359:   parameter logic [31:0] HMAC_DIGEST_3_RESVAL = 32'h 0;
360:   parameter logic [31:0] HMAC_DIGEST_4_RESVAL = 32'h 0;
361:   parameter logic [31:0] HMAC_DIGEST_5_RESVAL = 32'h 0;
362:   parameter logic [31:0] HMAC_DIGEST_6_RESVAL = 32'h 0;
363:   parameter logic [31:0] HMAC_DIGEST_7_RESVAL = 32'h 0;
364:   parameter logic [31:0] HMAC_DIGEST_8_RESVAL = 32'h 0;
365:   parameter logic [31:0] HMAC_DIGEST_9_RESVAL = 32'h 0;
366:   parameter logic [31:0] HMAC_DIGEST_10_RESVAL = 32'h 0;
367:   parameter logic [31:0] HMAC_DIGEST_11_RESVAL = 32'h 0;
368:   parameter logic [31:0] HMAC_DIGEST_12_RESVAL = 32'h 0;
369:   parameter logic [31:0] HMAC_DIGEST_13_RESVAL = 32'h 0;
370:   parameter logic [31:0] HMAC_DIGEST_14_RESVAL = 32'h 0;
371:   parameter logic [31:0] HMAC_DIGEST_15_RESVAL = 32'h 0;
372:   parameter logic [31:0] HMAC_MSG_LENGTH_LOWER_RESVAL = 32'h 0;
373:   parameter logic [31:0] HMAC_MSG_LENGTH_UPPER_RESVAL = 32'h 0;
374: 
375:   // Window parameters
376:   parameter logic [BlockAw-1:0] HMAC_MSG_FIFO_OFFSET = 13'h 1000;
377:   parameter int unsigned        HMAC_MSG_FIFO_SIZE   = 'h 1000;
378:   parameter int unsigned        HMAC_MSG_FIFO_IDX    = 0;
379: 
380:   // Register index
381:   typedef enum int {
382:     HMAC_INTR_STATE,
383:     HMAC_INTR_ENABLE,
384:     HMAC_INTR_TEST,
385:     HMAC_ALERT_TEST,
386:     HMAC_CFG,
387:     HMAC_CMD,
388:     HMAC_STATUS,
389:     HMAC_ERR_CODE,
390:     HMAC_WIPE_SECRET,
391:     HMAC_KEY_0,
392:     HMAC_KEY_1,
393:     HMAC_KEY_2,
394:     HMAC_KEY_3,
395:     HMAC_KEY_4,
396:     HMAC_KEY_5,
397:     HMAC_KEY_6,
398:     HMAC_KEY_7,
399:     HMAC_KEY_8,
400:     HMAC_KEY_9,
401:     HMAC_KEY_10,
402:     HMAC_KEY_11,
403:     HMAC_KEY_12,
404:     HMAC_KEY_13,
405:     HMAC_KEY_14,
406:     HMAC_KEY_15,
407:     HMAC_KEY_16,
408:     HMAC_KEY_17,
409:     HMAC_KEY_18,
410:     HMAC_KEY_19,
411:     HMAC_KEY_20,
412:     HMAC_KEY_21,
413:     HMAC_KEY_22,
414:     HMAC_KEY_23,
415:     HMAC_KEY_24,
416:     HMAC_KEY_25,
417:     HMAC_KEY_26,
418:     HMAC_KEY_27,
419:     HMAC_KEY_28,
420:     HMAC_KEY_29,
421:     HMAC_KEY_30,
422:     HMAC_KEY_31,
423:     HMAC_DIGEST_0,
424:     HMAC_DIGEST_1,
425:     HMAC_DIGEST_2,
426:     HMAC_DIGEST_3,
427:     HMAC_DIGEST_4,
428:     HMAC_DIGEST_5,
429:     HMAC_DIGEST_6,
430:     HMAC_DIGEST_7,
431:     HMAC_DIGEST_8,
432:     HMAC_DIGEST_9,
433:     HMAC_DIGEST_10,
434:     HMAC_DIGEST_11,
435:     HMAC_DIGEST_12,
436:     HMAC_DIGEST_13,
437:     HMAC_DIGEST_14,
438:     HMAC_DIGEST_15,
439:     HMAC_MSG_LENGTH_LOWER,
440:     HMAC_MSG_LENGTH_UPPER
441:   } hmac_id_e;
442: 
443:   // Register width information to check illegal writes
444:   parameter logic [3:0] HMAC_PERMIT [59] = '{
445:     4'b 0001, // index[ 0] HMAC_INTR_STATE
446:     4'b 0001, // index[ 1] HMAC_INTR_ENABLE
447:     4'b 0001, // index[ 2] HMAC_INTR_TEST
448:     4'b 0001, // index[ 3] HMAC_ALERT_TEST
449:     4'b 0011, // index[ 4] HMAC_CFG
450:     4'b 0001, // index[ 5] HMAC_CMD
451:     4'b 0011, // index[ 6] HMAC_STATUS
452:     4'b 1111, // index[ 7] HMAC_ERR_CODE
453:     4'b 1111, // index[ 8] HMAC_WIPE_SECRET
454:     4'b 1111, // index[ 9] HMAC_KEY_0
455:     4'b 1111, // index[10] HMAC_KEY_1
456:     4'b 1111, // index[11] HMAC_KEY_2
457:     4'b 1111, // index[12] HMAC_KEY_3
458:     4'b 1111, // index[13] HMAC_KEY_4
459:     4'b 1111, // index[14] HMAC_KEY_5
460:     4'b 1111, // index[15] HMAC_KEY_6
461:     4'b 1111, // index[16] HMAC_KEY_7
462:     4'b 1111, // index[17] HMAC_KEY_8
463:     4'b 1111, // index[18] HMAC_KEY_9
464:     4'b 1111, // index[19] HMAC_KEY_10
465:     4'b 1111, // index[20] HMAC_KEY_11
466:     4'b 1111, // index[21] HMAC_KEY_12
467:     4'b 1111, // index[22] HMAC_KEY_13
468:     4'b 1111, // index[23] HMAC_KEY_14
469:     4'b 1111, // index[24] HMAC_KEY_15
470:     4'b 1111, // index[25] HMAC_KEY_16
471:     4'b 1111, // index[26] HMAC_KEY_17
472:     4'b 1111, // index[27] HMAC_KEY_18
473:     4'b 1111, // index[28] HMAC_KEY_19
474:     4'b 1111, // index[29] HMAC_KEY_20
475:     4'b 1111, // index[30] HMAC_KEY_21
476:     4'b 1111, // index[31] HMAC_KEY_22
477:     4'b 1111, // index[32] HMAC_KEY_23
478:     4'b 1111, // index[33] HMAC_KEY_24
479:     4'b 1111, // index[34] HMAC_KEY_25
480:     4'b 1111, // index[35] HMAC_KEY_26
481:     4'b 1111, // index[36] HMAC_KEY_27
482:     4'b 1111, // index[37] HMAC_KEY_28
483:     4'b 1111, // index[38] HMAC_KEY_29
484:     4'b 1111, // index[39] HMAC_KEY_30
485:     4'b 1111, // index[40] HMAC_KEY_31
486:     4'b 1111, // index[41] HMAC_DIGEST_0
487:     4'b 1111, // index[42] HMAC_DIGEST_1
488:     4'b 1111, // index[43] HMAC_DIGEST_2
489:     4'b 1111, // index[44] HMAC_DIGEST_3
490:     4'b 1111, // index[45] HMAC_DIGEST_4
491:     4'b 1111, // index[46] HMAC_DIGEST_5
492:     4'b 1111, // index[47] HMAC_DIGEST_6
493:     4'b 1111, // index[48] HMAC_DIGEST_7
494:     4'b 1111, // index[49] HMAC_DIGEST_8
495:     4'b 1111, // index[50] HMAC_DIGEST_9
496:     4'b 1111, // index[51] HMAC_DIGEST_10
497:     4'b 1111, // index[52] HMAC_DIGEST_11
498:     4'b 1111, // index[53] HMAC_DIGEST_12
499:     4'b 1111, // index[54] HMAC_DIGEST_13
500:     4'b 1111, // index[55] HMAC_DIGEST_14
501:     4'b 1111, // index[56] HMAC_DIGEST_15
502:     4'b 1111, // index[57] HMAC_MSG_LENGTH_LOWER
503:     4'b 1111  // index[58] HMAC_MSG_LENGTH_UPPER
504:   };
505: 
506: endpackage

================================== Ai Message ==================================

Scope and documentation-derived properties for HMAC IP (OpenTitan /hw/ip/hmac)
- Security properties:
  - No software readback of secret key material. KEY[0..31] are write-only CSRs; keys can only be updated when the engine is idle; writes during processing are discarded and should raise an error.
  - Explicit zeroization: WIPE_SECRET is a write-only CSR; writing any 32-bit value should trigger scrubbing of internal secrets (key, intermediate hash, digest, message scheduling array) using the provided pattern.
  - Context restore: DIGEST_* and MSG_LENGTH_* are writable only when STATUS.hmac_idle=1, to support safe context switching without leaking intermediate state across contexts.
  - Message FIFO is write-only; reads should return an error; back-pressure is applied when the FIFO is full; software should not write when FIFO is not writable.
  - Configuration is applied only in Idle; CFG writes while busy are discarded.
  - Invalid configs (unsupported digest size, invalid key length in HMAC mode, or 1024-bit key with SHA-256) must not start and should raise an error (SwInvalidConfig).

- Register access policies (from doc/registers.md):
  - KEY_0..KEY_31: write-only 32-bit chunks of the secret key; must be writable only when idle; never readable.
  - WIPE_SECRET: write-only; any write triggers secret wipe using the 32-bit value provided.
  - DIGEST_0..15: read-only for SW (except writable when idle to restore context).
  - MSG_FIFO: write-only TL-UL window; reads should produce errors.
  - ERR_CODE: read-only; holds the first error cause until cleared by SW via INTR_STATE.hmac_err.
  - CMD bits are r0w1c control strobes (write-1-to-set and auto-clear).

Security analysis and issues found

1) Secret key disclosure via register read mux (high severity)
- File: hw/ip/hmac/rtl/hmac_reg_top.sv
- Line number(s):
  - 2419: reg_rdata_next[31:0] = reg2hw.key[0].q;
  - 2423: reg_rdata_next[31:0] = reg2hw.key[1].q;
  - 2623: default: reg_rdata_next = reg2hw.key[2].q;
- Brief description:
  - The readback mux returns secret key words for multiple addresses:
    - At HMAC_WIPE_SECRET offset (addr_hit[8]) it returns key[0].
    - At HMAC_KEY_0 offset (addr_hit[9]) it returns key[1].
    - The default case returns key[2].
  - This violates the write-only policy for KEY registers and discloses secret key material to software/bus reads. The default case also risks leaking key material on unmatched addresses or during error paths.
- Security aspect affected: Confidentiality of secrets; Improper register access control (CWE-200, CWE-1262).
- Tools used: CWE Agent, Anomaly Detector, Similar Bug Agent.

2) WIPE_SECRET write enable only asserted on bus error (high severity)
- File: hw/ip/hmac/rtl/hmac_reg_top.sv
- Line number(s): 21272130
  - 2128: assign wipe_secret_we = (addr_hit[8]  && reg_we && reg_error);
- Brief description:
  - WIPE_SECRET write-enable is gated by reg_error instead of !reg_error. In normal (non-error) writes, qe never asserts, so the wipe operation in hmac.sv (triggered by reg2hw.wipe_secret.qe) wont fire. This contradicts the documented behavior that any write should wipe secrets and creates a condition where secrets may remain uncleared.
- Security aspect affected: Zeroization assurance of sensitive information (CWE-1239) and protection mechanism failure (CWE-693).
- Tools used: CWE Agent, Anomaly Detector.

3) Message FIFO grant without write-allowed gating (moderate severity)
- File: hw/ip/hmac/rtl/hmac.sv
- Line number(s):
  - 531: assign msg_fifo_gnt = msg_fifo_req & ~hmac_fifo_wsel & packer_ready;
  - 628631: assign msg_write = msg_fifo_req & msg_fifo_we & ~hmac_fifo_wsel & msg_allowed;
- Brief description:
  - The TL-UL adapter grants the write transaction (msg_fifo_gnt) without checking msg_allowed. The transaction will be acknowledged at the TL level, but the internal packer write side wont accept the data when msg_allowed==0, causing silent data loss. Software can believe the message was written while HMAC drops it, corrupting the intended message stream and message length accounting.
- Security aspect affected: Integrity/availability of the message data path; potential to induce incorrect HMAC results or DoS (CWE-693).
- Tools used: Anomaly Detector.

4) Wrong second-round message-length for SHA-512 HMAC (high severity functional/crypto correctness)
- File: hw/ip/hmac/rtl/hmac_core.sv
- Line number(s): 226231
  - Default case for final-round length uses +384 bits, which applies to SHA2_512 as well:
    - 227: SHA2_256: BlockSizeSHA256 + 256 (correct).
    - 228: SHA2_384: BlockSizeSHA512 + 384 (correct).
    - 229: default: BlockSizeSHA512 + 384 (incorrect for SHA2_512; should be +512).
- Brief description:
  - In HMAC mode, the second round message length for SHA-512 should be 1024 + 512 bits. The code uses 384 for the default branch, so SHA2_512 runs with an incorrect length, producing wrong HMAC-512 results. This is a security failure (HMAC output invalid).
- Security aspect affected: Cryptographic computation correctness (CWE-682, CWE-327).
- Tools used: Anomaly Detector (manual review of flagged control/length logic).

5) Duplicate err_code branch in error selection (low severity, could mask intended conditions)
- File: hw/ip/hmac/rtl/hmac.sv
- Line number(s): 851859
- Brief description:
  - The priority case contains the same condition (hash_start_sha_disabled) twice, setting the same error code. This is redundant and could be masking a different intended error branch (making error reporting less reliable).
- Security aspect affected: Robust error reporting/diagnostics (CWE-398). Not a direct leak, but can hinder SW responses to attacks/misuse.
- Tools used: Anomaly Detector.

6) Duplicate/conflicting assignment to key_2_wd (low severity coding error)
- File: hw/ip/hmac/rtl/hmac_reg_top.sv
- Line number(s): 21392141
  - 2139: assign key_2_wd = full_wdata;
  - 2141: assign key_2_wd = reg_wdata[31:0];
- Brief description:
  - key_2_wd is driven twice with two continuous assigns. Even if equivalent, this is a synthesis/simulation hazard and could cause unpredictable behavior when programming key_2.
- Security aspect affected: Reliability of secret key programming; potential to introduce subtle faults (CWE-398).
- Tools used: Anomaly Detector.

7) Potential txcount increment/overflow assumptions (low severity; robustness)
- File: hw/ip/hmac/rtl/hmac_core.sv
- Line number(s): 268269
- Brief description:
  - txcount increments only the upper bits [63:5] by one (i.e., +32). This presumes aligned behavior and can be fragile for boundary/overflow cases. Although not a direct vulnerability, miscounting can cause boundary/timing mismatches.
- Security aspect affected: Correctness robustness (CWE-682). Consider refactoring to full-width addition and/or assertions.

Additional notes (lower priority observations)
- hmac.sv idle computation uses reg_fifo_wvalid (packer's output) as a proxy for packer empty (lines 889896 annotated as ICEBOX). This may misreport idle status and induce race conditions if software relies solely on STATUS.hmac_idle. cfg_block in hmac.sv already guards config/key updates, mitigating risk.
- Pads (i_pad_*, o_pad_*) are derived combinationally from secret_key_i in hmac_core.sv. Zeroization relies on top-level WIPE_SECRETs effect on secret_key; consider adding explicit clear on hmac_done or error as a hardening improvement.

Recommended fixes (summary)
- Fix register read muxing to never return KEY data:
  - At 2419, 2423: return '0 instead of reg2hw.key[0/1].q.
  - At 2623 (default): return '0, never a key value.
- Fix WIPE_SECRET write enable gating:
  - Replace reg_error with !reg_error in 2128 so normal writes assert qe: assign wipe_secret_we = (addr_hit[8] && reg_we && !reg_error).
- Gate TL grant by msg_allowed or return an error when disallowed:
  - E.g., at 531: add msg_allowed to msg_fifo_gnt or configure adapter to ERR when msg_allowed==0 to avoid silent drops.
- Correct HMAC SHA-512 second round length:
  - In hmac_core.sv line 229: add explicit SHA2_512 branch with BlockSizeSHA512in64 + 64'd512 and reserve default for SHA2_None.
- Remove duplicate err_code branch and review error priority.
- Remove the duplicate assignment to key_2_wd and standardize to a single assignment.

CWE mapping (for reference)
- CWE-200, CWE-1262: Secret key exposure via read mux (Issue 1).
- CWE-1239, CWE-693: Zeroization path broken by wipe gating (Issue 2).
- CWE-693: Protection mechanism failure leading to message integrity/DoS (Issue 3).
- CWE-682/CWE-327: Incorrect HMAC-512 computation (Issue 4).
- CWE-398: Duplicated conditions and assignments (Issues 5, 6).
- CWE-682: Potential incorrect counting logic (Issue 7).

Tools used during this assessment
- Documentation review: theory_of_operation.md, registers.md, programmers_guide.md.
- RTL review: hmac.sv, hmac_core.sv, hmac_reg_top.sv, hmac_reg_pkg.sv.
- Anomaly Detector Agent: hmac.sv, hmac_reg_top.sv, hmac_core.sv.
- CWE Checker Agent: hmac_reg_top.sv (register access controls and leakage).
- Similar Bug Agent: hmac_reg_top.sv (pattern search for secret readback).

END


Token Usage Summary:
===================
Total API Calls: 23
Total Input Tokens: 737,635
Total Output Tokens: 25,812
Total Tokens: 763,447
Average Input Tokens/Call: 32071.1
Average Output Tokens/Call: 1122.3
Average Total Tokens/Call: 33193.3


Detailed Call History:
==================================================
Call 1: gpt-5-2025-08-07 - Input: 1065, Output: 43, Total: 1108
Call 2: gpt-5-2025-08-07 - Input: 1250, Output: 109, Total: 1359
Call 3: gpt-5-2025-08-07 - Input: 1367, Output: 40, Total: 1407
Call 4: gpt-5-2025-08-07 - Input: 1506, Output: 45, Total: 1551
Call 5: gpt-5-2025-08-07 - Input: 4473, Output: 43, Total: 4516
Call 6: gpt-5-2025-08-07 - Input: 12785, Output: 47, Total: 12832
Call 7: gpt-5-2025-08-07 - Input: 12913, Output: 48, Total: 12961
Call 8: gpt-5-2025-08-07 - Input: 24398, Output: 49, Total: 24447
Call 9: gpt-5-2025-08-07 - Input: 30724, Output: 50, Total: 30774
Call 10: gpt-5-2025-08-07 - Input: 63177, Output: 270, Total: 63447
Call 11: gpt-5-mini-2025-08-07 - Input: 9645, Output: 53, Total: 9698
Call 12: gpt-5-mini-2025-08-07 - Input: 10703, Output: 4954, Total: 15657
Call 13: gpt-5-2025-08-07 - Input: 65264, Output: 243, Total: 65507
Call 14: gpt-5-2025-08-07 - Input: 68106, Output: 1553, Total: 69659
Call 15: gpt-5-2025-08-07 - Input: 69079, Output: 1302, Total: 70381
Call 16: gpt-5-mini-2025-08-07 - Input: 25381, Output: 55, Total: 25436
Call 17: gpt-5-mini-2025-08-07 - Input: 29982, Output: 3016, Total: 32998
Call 18: gpt-5-2025-08-07 - Input: 70580, Output: 398, Total: 70978
Call 19: gpt-5-2025-08-07 - Input: 70898, Output: 2641, Total: 73539
Call 20: gpt-5-mini-2025-08-07 - Input: 5465, Output: 54, Total: 5519
Call 21: gpt-5-mini-2025-08-07 - Input: 5774, Output: 4261, Total: 10035
Call 22: gpt-5-2025-08-07 - Input: 72871, Output: 184, Total: 73055
Call 23: gpt-5-2025-08-07 - Input: 80229, Output: 6354, Total: 86583
    
